[
    {
        "id": 1,
        "completion": "\\d",
        "passed": false
    },
    {
        "id": 1,
        "completion": "[0-9]",
        "passed": false
    },
    {
        "id": 1,
        "completion": "\\d",
        "passed": false
    },
    {
        "id": 1,
        "completion": "0-9",
        "passed": false
    },
    {
        "id": 1,
        "completion": "\\d",
        "passed": false
    },
    {
        "id": 1,
        "completion": "/^[0-9]/",
        "passed": false
    },
    {
        "id": 1,
        "completion": "\\d and.",
        "passed": false
    },
    {
        "id": 1,
        "completion": "[1-9]\\d\\d*(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 1,
        "completion": "^\\d\\d$Useful resources:1. What is the Difference between \\d and \\s?2. Regex Pattern Reference3. Generating Numbers with JavaScript Regular Expression4. Matching Numbers with Javascript RegEx5. How to match digits in JavaScript with RegEx?",
        "passed": false
    },
    {
        "id": 1,
        "completion": "\\d\\d\\d\\d[\\s-]*[mYaRiNgSfUaLnAoD]*$",
        "passed": false
    },
    {
        "id": 2,
        "completion": "[[0-9]{2}[\\-\\s\\)]?[0-9]{3}([\\-\\s]?[0-9]{1,2})?",
        "passed": false
    },
    {
        "id": 2,
        "completion": "\\d{5}\\z",
        "passed": false
    },
    {
        "id": 2,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 2,
        "completion": "12345The RegEx for this description is something like \"[12345]{5}\".",
        "passed": true
    },
    {
        "id": 2,
        "completion": "123456789",
        "passed": true
    },
    {
        "id": 2,
        "completion": "[0-9]{5}",
        "passed": false
    },
    {
        "id": 2,
        "completion": "[0-9](\\s|$)",
        "passed": false
    },
    {
        "id": 2,
        "completion": "^\\d{3}[-\\s]?\\d{2}[-\\s]?\\d{4}$",
        "passed": false
    },
    {
        "id": 2,
        "completion": "^\\d{5}$",
        "passed": true
    },
    {
        "id": 2,
        "completion": "[0-9]{5}",
        "passed": false
    },
    {
        "id": 3,
        "completion": "[a-z0-9]{3}\\-[0-9]{1}-[0-9]{4}/\\d",
        "passed": false
    },
    {
        "id": 3,
        "completion": "[\\d-]{4,10}",
        "passed": false
    },
    {
        "id": 3,
        "completion": "[0-9]{5}\\-\\+[0-9]{4} ZIP",
        "passed": false
    },
    {
        "id": 3,
        "completion": "[1-9]\\d|0[1-9]",
        "passed": false
    },
    {
        "id": 3,
        "completion": "[a-zA-Z0-9][-a-zA-Z0-9]{5}[0-9]{4}",
        "passed": false
    },
    {
        "id": 3,
        "completion": "r\"zip\\(\\s*(-?\\d{5})[\\-\\s,]*\\d\\d\\d\\d\\d(\\s*(-?\\d{4})|\\s*(?:\\d{4}))\\)\"",
        "passed": false
    },
    {
        "id": 3,
        "completion": "r'[A-Z}{3}-{4}'",
        "passed": false
    },
    {
        "id": 3,
        "completion": "((?:\\d{5})?|\\d{4}-\\d{4})\\+?\\d{4}",
        "passed": false
    },
    {
        "id": 3,
        "completion": "#Generate a RegEx to match ZIP +4 zip codespattern = \"(?<=^|[\\-+\\] ])(?<=\\()(?<=\\-)[\\-+ \\]\\()(\\d\\d\\d)$\"#Test the pattern:print(\"'.zip code' - valid:  {0}\\n'zip code - invalid: {1}\\n'.zip code' - invalid: {2}",
        "passed": false
    },
    {
        "id": 3,
        "completion": "",
        "passed": false
    },
    {
        "id": 4,
        "completion": "^[A-Z]{1,3}(?:-[A-Z]{1,3}){36}$",
        "passed": false
    },
    {
        "id": 4,
        "completion": "\\d{3}\\-\\-\\d{4}",
        "passed": false
    },
    {
        "id": 4,
        "completion": "[a-zA-Z0-9-]{1,16}([a-zA-Z0-9\\-]){1,16}",
        "passed": false
    },
    {
        "id": 4,
        "completion": "^[0-9]{5}-[0-9]{3}-[0-9]{4}$",
        "passed": false
    },
    {
        "id": 4,
        "completion": "(?i)(?=\\bzip\\b)(?=\\d{5}[- ]?\\d{4}\\b)",
        "passed": false
    },
    {
        "id": 4,
        "completion": "I would break this problem down into three parts. Each part would be a string that describes the following:",
        "passed": false
    },
    {
        "id": 4,
        "completion": "1",
        "passed": true
    },
    {
        "id": 4,
        "completion": "/^(50[1-9]|100[0-2])-(0[1-9]|1[012])[0-9]{7}$/i",
        "passed": false
    },
    {
        "id": 4,
        "completion": "Here's my regex. It's probably not all that readable, but it should get you started with how to write one.\\d{5}|(?=\\d{5}-\\d{4",
        "passed": false
    },
    {
        "id": 4,
        "completion": "\\w+[\\-][0-9]{5}[\\+](\\d{4})",
        "passed": false
    },
    {
        "id": 5,
        "completion": "\\bSocial-Security-Number-(\\d{3})-(\\d{2})-(\\d{4}\\-\\d{2}-\\d{2})-\\d{4}",
        "passed": false
    },
    {
        "id": 5,
        "completion": "[0-9]{3}-\\d{3}-\\d{4}Generate a RegEx to match this description.",
        "passed": false
    },
    {
        "id": 5,
        "completion": "[\\d]{3}[-\\d]{3}[-\\d]{3}(?:[0-9]{4})?",
        "passed": false
    },
    {
        "id": 5,
        "completion": "NNN-NN-NNNN-[a-zA-Z 0-9]{3}-\\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 5,
        "completion": "`^\\d{3}\\-\\d{2}\\-\\d{4}$`",
        "passed": false
    },
    {
        "id": 5,
        "completion": "\\d{3}-\\d{2}-\\d{4}\\.",
        "passed": false
    },
    {
        "id": 5,
        "completion": "\\b\\d{3}-?\\d{2}[-\\s]?\\d{4}\\b",
        "passed": false
    },
    {
        "id": 5,
        "completion": "/\\d{3}-\\d{2}-\\d{4}/g",
        "passed": false
    },
    {
        "id": 5,
        "completion": "\\b(([1-9]\\d{2}|1[012])-(?!\\d))+\\bThis regular expression will match an SSN in the format XXX-XX-XXXX or 0123-4567-8900, with a hyphen in between. The regex does not include a digit, since numbers that start with 0 are invalid.",
        "passed": false
    },
    {
        "id": 5,
        "completion": "(^[\\d]{3})-[\\d]{3}-(\\d{4})",
        "passed": false
    },
    {
        "id": 6,
        "completion": "r'^[A-Za-z0-9\\-]*$'",
        "passed": false
    },
    {
        "id": 6,
        "completion": "^[A-Z]*$",
        "passed": false
    },
    {
        "id": 6,
        "completion": "^[a-zA-Z].*",
        "passed": false
    },
    {
        "id": 6,
        "completion": ".*[a-zA-Z]{1}\\..*\\..*$Explanation:.*[a-zA-Z]{1} matches any single lowercase letter. The next \\. matches any single character, then * repeats any number of these characters, and {1} requires that we match exactly one of these characters. Afterwards, there are \\. repeated a total of 2 times (to match any two characters). The next * repeats these two characters,",
        "passed": false
    },
    {
        "id": 6,
        "completion": "([A-Za-z])",
        "passed": false
    },
    {
        "id": 6,
        "completion": "\\b[A-Za-z]+\\b",
        "passed": false
    },
    {
        "id": 6,
        "completion": "[a-zA-Z]",
        "passed": false
    },
    {
        "id": 6,
        "completion": "^[a-zA-Z][a-zA-Z0-9]*$",
        "passed": false
    },
    {
        "id": 6,
        "completion": "([a-z]){1,30}",
        "passed": false
    },
    {
        "id": 6,
        "completion": "[A-Z] or [a-z]+",
        "passed": false
    },
    {
        "id": 7,
        "completion": "[a-zA-Z]{2,}",
        "passed": false
    },
    {
        "id": 7,
        "completion": "r'^[a-z]{4,30}$'",
        "passed": false
    },
    {
        "id": 7,
        "completion": "a-zA-Z[a-z0-9_]-_[0-9]{0,4}",
        "passed": false
    },
    {
        "id": 7,
        "completion": "'[A-Za-z ]{3,30}'    **Note**: 3 <= length <= 30",
        "passed": false
    },
    {
        "id": 7,
        "completion": "Regex: ^[a-z0-9]*$",
        "passed": false
    },
    {
        "id": 7,
        "completion": "[^A-Z] +",
        "passed": false
    },
    {
        "id": 7,
        "completion": "/[a-zA-Z]+/u",
        "passed": false
    },
    {
        "id": 7,
        "completion": "^[A-z0-9]+$",
        "passed": false
    },
    {
        "id": 7,
        "completion": ".Example of regex: (.+).",
        "passed": false
    },
    {
        "id": 7,
        "completion": ".+[a-zA-z]+",
        "passed": false
    },
    {
        "id": 8,
        "completion": "^[A-Za-z0-9_+\\-!\\$()\\%=\\^&\\_\\\\\\. ]+$",
        "passed": false
    },
    {
        "id": 8,
        "completion": "^[a-zA-Z0-9]{5}\\S*$",
        "passed": false
    },
    {
        "id": 8,
        "completion": "[a-zA-Z0-9_]Use the code above with the text to verify the results.",
        "passed": false
    },
    {
        "id": 8,
        "completion": "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
        "passed": false
    },
    {
        "id": 8,
        "completion": "^[A-z]+$Explanation:  -------------   ^   |    [A-z]  -----------------",
        "passed": false
    },
    {
        "id": 8,
        "completion": "[A-Za-z0-9$]*",
        "passed": false
    },
    {
        "id": 8,
        "completion": "myWords.txt, myValues.txt, myOtherWords.txtExplanation: This describes a file containing one or more words separated by commas.Exercise 2: Replace all substrings that match the above pattern with \"My Values.\"My Values: My Values,My Other Words,MyValues,myOtherWords should be replaced with \"My Values.\". Explanation: This regex will match the words in the pattern and replace them with \"My Values.\"",
        "passed": false
    },
    {
        "id": 8,
        "completion": "var myreg = /^\\w+$/; // matches any alphanumeric string with at least one character and at least one digitvar match4 = myreg.test(\"\"); // truevar match5 = myreg.test(\"this\"); // false",
        "passed": false
    },
    {
        "id": 8,
        "completion": "\\d{3}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 8,
        "completion": "(\\d|[a-z]|[A-Z])'2. Create a regular expression that will match all words starting with the letter \"n\". Answer: '\\bn\\w*'3. Match any text that has any number of newline characters (\\n) or space characters (\\s). Answer: '\\s+'4. Create a RegEx that will match any floating point number (no decimal point) of any length.",
        "passed": false
    },
    {
        "id": 9,
        "completion": "^[1-6]+$",
        "passed": false
    },
    {
        "id": 9,
        "completion": "This is a positive integer value.",
        "passed": false
    },
    {
        "id": 9,
        "completion": "https://regexr.com/3hqq0",
        "passed": false
    },
    {
        "id": 9,
        "completion": "",
        "passed": false
    },
    {
        "id": 9,
        "completion": "1.1\\d{0,2}.",
        "passed": true
    },
    {
        "id": 9,
        "completion": "*(.+)([\\s,]*)(.*)*.",
        "passed": false
    },
    {
        "id": 9,
        "completion": ".*",
        "passed": false
    },
    {
        "id": 9,
        "completion": "I=.*[0-9]+,P=.*[0-9]+,T=.*[0-9]+,E=.*[0-9]+,Z=.*[0-9]*.*",
        "passed": false
    },
    {
        "id": 9,
        "completion": "a-zA-Z0-9._-*",
        "passed": false
    },
    {
        "id": 9,
        "completion": "(\\d+)(\\.\\d+)?%**Exercise 4:**Write a Python script that takes a list of email addresses as input and filters out those that are not in the correct format (e.g., those that do not start with'spam', contain more than one domain), and keeps only those that pass the validation and validation regex.",
        "passed": false
    },
    {
        "id": 10,
        "completion": "/^\\d+/This will match any number of digits, but will ignore numbers that contain \".\" or \",\" and will include numbers that are in scientific notation. For example, \".45\", 1234.0, and 3.14159 are all matched.",
        "passed": false
    },
    {
        "id": 10,
        "completion": "\\b(0\\d|1\\d|2\\d|3\\d|4\\d|5\\d|6\\d|7\\d|8\\d|9\\d)\\b",
        "passed": false
    },
    {
        "id": 10,
        "completion": "(^[01]|[012]?[345]\\d{3}|3[01]\\d{2}|[12]?\\d{3}-\\d{2}-\\d{4})Here is a website which includes examples of regular expressions: http://www.regular-expressions.info/example.html",
        "passed": false
    },
    {
        "id": 10,
        "completion": "\\d+",
        "passed": false
    },
    {
        "id": 10,
        "completion": "^[1-9]0*-?[1-9]*$",
        "passed": false
    },
    {
        "id": 10,
        "completion": "(0?[1-9]|1[0-2])\\d*",
        "passed": false
    },
    {
        "id": 10,
        "completion": "\"^[0-9]*$\"",
        "passed": false
    },
    {
        "id": 10,
        "completion": "[-+]?[0-9]?.",
        "passed": false
    },
    {
        "id": 10,
        "completion": "",
        "passed": false
    },
    {
        "id": 10,
        "completion": "",
        "passed": false
    },
    {
        "id": 11,
        "completion": "^[a-z][a-z0-9_]{3,15}$",
        "passed": false
    },
    {
        "id": 11,
        "completion": "r'^((?=.*[a-z])(?=.*\\d)[a-z\\d_]{4,15})$'",
        "passed": false
    },
    {
        "id": 11,
        "completion": "[a-zA-Z] [at least 4 digits] [no characters other than letters, numbers and the underscore _]",
        "passed": false
    },
    {
        "id": 11,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d_]{6,15}$",
        "passed": false
    },
    {
        "id": 11,
        "completion": "[aA-zA-Z_]+`````` Python   import re   password = 'P_sss_w0rd#!!'   x = re.match(r'[aA-zA-Z_]+',password)   if x:       print(\"Password Correct\")   else:       print",
        "passed": false
    },
    {
        "id": 11,
        "completion": "(^[a-zA-Z][a-zA-Z0-9_]{1,15}$)",
        "passed": false
    },
    {
        "id": 11,
        "completion": "/^[a-zA-Z]{4,15}$\\/i",
        "passed": false
    },
    {
        "id": 11,
        "completion": "^[A-Za-z0-9_]{4,15}$",
        "passed": false
    },
    {
        "id": 11,
        "completion": "^[a-zA-Z]{4,15}$",
        "passed": true
    },
    {
        "id": 11,
        "completion": "\\A[a-zA-Z][a-zA-Z0-9_]{4,15}\\z",
        "passed": false
    },
    {
        "id": 12,
        "completion": "/^(?!(\\\\\\\\.){2,5}$)([\\w\\d\\.]{1,3}(\\.|\\/)+[\\w\\d\\.]{1,3})*@[a-zA",
        "passed": false
    },
    {
        "id": 12,
        "completion": "/^[\\w\\.-]+@(?:[a-zA-Z0-9-]|[a-z0-9]+\\.)+[a-z]{2}[a-z]$/",
        "passed": false
    },
    {
        "id": 12,
        "completion": "^\\b[^a-zA-Z0-1\\d\\.-]+@\\S+\\.\\S+$",
        "passed": false
    },
    {
        "id": 12,
        "completion": "/^[a-zA-Z0-9-_!@]\\.[a-zA-Z0-9-_!@][a-zA-Z0-9-_!@]\\",
        "passed": false
    },
    {
        "id": 12,
        "completion": "\\b[A-Za-z0-9][A-Za-z0-90-9-]([A-Za-z0-9]+)Email: [^-+\\.]*@[",
        "passed": false
    },
    {
        "id": 12,
        "completion": "(?::([^#].*?)+?(.|[])?#(.|[])?)*(?::([^#].*?)+?(.|[])?#(.|[])?)",
        "passed": false
    },
    {
        "id": 12,
        "completion": "r'^\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\.[0-",
        "passed": false
    },
    {
        "id": 12,
        "completion": "(http[s]?:\\/\\/(([a-zA-Z-]+\\.[^\\.]+)*)|(http[s]?:\\/\\/(\\*|[a-zA-Z-]+\\",
        "passed": false
    },
    {
        "id": 12,
        "completion": "[a-zA-Z0-9][a-zA-Z0-9.-]+[a-zA-Z0-9](@[a-zA-Z0-9.-]+)+\\.[",
        "passed": false
    },
    {
        "id": 12,
        "completion": "/^(?![0-9]+)[a-z](?![a-z0-9]\\.)[a-z0-9\\.-]+[a-z0-9]{1,3}(",
        "passed": false
    },
    {
        "id": 13,
        "completion": "\\b(?:0{0,1}\\d|1{0,1}\\d|2\\d{4}\\b)",
        "passed": false
    },
    {
        "id": 13,
        "completion": "",
        "passed": false
    },
    {
        "id": 13,
        "completion": "/^(0?[1-9]|1\\d|[2-9]?\\d)\\/(0?[1-9]|1\\d|2[0-9]|30)\\s(19|20)\\d$/i",
        "passed": false
    },
    {
        "id": 13,
        "completion": "\\d/\\d/\\d{4}",
        "passed": false
    },
    {
        "id": 13,
        "completion": "^(?P<day>\\d{1,2})(-(?P<month>\\d{1,2})/)?(-(?P<year>\\d{4}))?$",
        "passed": false
    },
    {
        "id": 13,
        "completion": "\\d\\d/\\d{2}-\\d{4}.",
        "passed": false
    },
    {
        "id": 13,
        "completion": "(\\d\\d\\/\\d\\d\\/\\d\\d)\\. (\\d\\d)\\. (\\d\\d)",
        "passed": false
    },
    {
        "id": 13,
        "completion": "/^\\d{0,2}\\d{3}/",
        "passed": false
    },
    {
        "id": 13,
        "completion": "\\d{1,2}\\/\\d{2,4}",
        "passed": false
    },
    {
        "id": 13,
        "completion": "(^(?:\\d{1,2}\\/)|^(?:\\d{1,2}\\/|\\d{1,2}\\/\\d)$)",
        "passed": false
    },
    {
        "id": 15,
        "completion": "",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^[abcde]\\d{6}$",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^[12345]$",
        "passed": true
    },
    {
        "id": 15,
        "completion": "This will match 1 to 5 digits in a row, or groups of 5 digits.",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^(?:[6-9][12]|2[3-7])$",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^(?:[12][345][67890]|[12]*[345]\\\\d|[12]*\\\\d[345]\\\\d|[123]\\\\d[456]\\\\d|[12][34][56]\\\\d|[12345])$",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^[12]\\d{3}[5]$",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^[1-5][1-9][0-9]$",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^[12345]$|^[789]$",
        "passed": false
    },
    {
        "id": 15,
        "completion": "^[12345]$",
        "passed": true
    },
    {
        "id": 16,
        "completion": "^[1-5,]$",
        "passed": false
    },
    {
        "id": 16,
        "completion": "^[1-5]$",
        "passed": true
    },
    {
        "id": 16,
        "completion": "^[1-5]\\d?$|^[1-5]\\d{1,2}$|^1[1-5]\\d{3}$",
        "passed": false
    },
    {
        "id": 16,
        "completion": "^[1-5]$|^[6-9]$",
        "passed": false
    },
    {
        "id": 16,
        "completion": "^[1-5]$",
        "passed": true
    },
    {
        "id": 16,
        "completion": "^[1-5]$",
        "passed": true
    },
    {
        "id": 16,
        "completion": "^[1-5]$",
        "passed": true
    },
    {
        "id": 16,
        "completion": "^[1-5](?!$)[0-9]*$",
        "passed": false
    },
    {
        "id": 16,
        "completion": "my_key = \"(?<!^)[6-9](?!$)\".",
        "passed": false
    },
    {
        "id": 16,
        "completion": "^[1-5]$",
        "passed": true
    },
    {
        "id": 18,
        "completion": "-?([A-Z]{2}-){3}[0-9]{4}",
        "passed": false
    },
    {
        "id": 18,
        "completion": "\\b[A-9]{2}\\d{3}-\\d{4}\\b.",
        "passed": false
    },
    {
        "id": 18,
        "completion": "@regex = /(?P<number>[A-Z]{2})(?P<operator>[0-9]{2})-(?P<number>[0-9]{2})$/;",
        "passed": false
    },
    {
        "id": 18,
        "completion": "r'^(?:(?:\\d[2-9]){2})?-?\\d{3}-?\\d{4}$'",
        "passed": false
    },
    {
        "id": 18,
        "completion": "[^-\\-\\d][-\\d]{3}[-.\\d]{3}[-\\d]{6}",
        "passed": false
    },
    {
        "id": 18,
        "completion": "^[2-9]\\d{3}-[0-9]{3}-[0-9]{3}$",
        "passed": false
    },
    {
        "id": 18,
        "completion": "(^(20[123]|18[2-9]\\d|2[0-3]\\d|1[0-4]\\d|[68]?[69]\\d?|[89]?[91]\\d?).\\d{2}-\\d{9}(-(20\\d{5})?|",
        "passed": false
    },
    {
        "id": 18,
        "completion": "^([^-]|^)(\\d{2})([0-9]{3}-\\d{4})-([0-9]{4})$",
        "passed": false
    },
    {
        "id": 18,
        "completion": "^\\d{3}[-.]\\d{3}$",
        "passed": false
    },
    {
        "id": 18,
        "completion": "\\d{2}(-\\d{3}-){3}\\d{8}",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer: ^(?!www\\.)[\\S\\s-]{1,63}(?=\\.\\w{2,",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer: [a-zA-z0-9]+(\\.[a-zA-z]+)+([a-zA-",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer: ^[a-zA-Z0-9][a-zA-Z0-9\\-\\.]*[a-z",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer: ^(?!.*[@][a-z0-9_-]$).*$",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer: /^[a-z0-9\\-]+\\.[a-z0-9\\-]+.\\.(com|org|net",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer:import rere.IGNORECASE | re.UNICODE",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer: [a-zA-Z0-9][a-zA-Z0-9\\-\\.]*([a-zA",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer: \\D(1[0-9]|2\\d|3[01]|4[0-9]|5[0",
        "passed": false
    },
    {
        "id": 20,
        "completion": "Domain names:This regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in.com,.org,.net,.mil, or.edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.Generate a RegEx for this description. Answer:@\\w+(\\.)?(([A-z]|\\d\\d){1,2}(\\.)?([A",
        "passed": false
    },
    {
        "id": 25,
        "completion": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[A-Za-z\\d]{4,8}$",
        "passed": false
    },
    {
        "id": 25,
        "completion": "#password=\"^([A-Za-z\\d]|[0-9]){4,8}$\"",
        "passed": false
    },
    {
        "id": 25,
        "completion": "The answer will vary, the answer should have a minimum of 4 digits, 1 numerical digit, and at least one non-alphabetical digit. This could be described as \"^[0-9a-zA-Z]3[0-9a-zA-Z]$\"",
        "passed": false
    },
    {
        "id": 25,
        "completion": "/^(?=.*\\d)(?=.*[a-z]).{12,20}$/i.",
        "passed": false
    },
    {
        "id": 25,
        "completion": "[0-9]{4,8}\\.[0-9a-zA-Z]{1,21}$",
        "passed": false
    },
    {
        "id": 25,
        "completion": "(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$",
        "passed": false
    },
    {
        "id": 25,
        "completion": "r'^[4-8][0-9]{1,}$'",
        "passed": false
    },
    {
        "id": 25,
        "completion": "r'^(?=.*[0-9])[0-9]{4,8}$'",
        "passed": false
    },
    {
        "id": 25,
        "completion": "^(?=.*[\\d])[A-Za-z0-9\\d]+$",
        "passed": false
    },
    {
        "id": 25,
        "completion": "/^(?=.{4,8}$)(?=.*[0-9])[a-zA-Z0-9]{6,}$/",
        "passed": false
    },
    {
        "id": 26,
        "completion": "PasswordRegex = r\"^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!\"#$%&()*+,-/:;<=>?@[\\]^_`{|}~]).{8,15}$\"",
        "passed": false
    },
    {
        "id": 26,
        "completion": "[A-Za-z]{3,7}[0-9]{1,2}[A-Z]{1,1}[0-9]{1,2}$",
        "passed": false
    },
    {
        "id": 26,
        "completion": "[A-Zat-z0-9]{4,8}",
        "passed": false
    },
    {
        "id": 26,
        "completion": "/^(?=.{4})(?=\\d.*[a-z])(?=\\d.*[A-Z])(?=\\D.*\\d)(?=\\D.*[a-z]).{8,}$/",
        "passed": false
    },
    {
        "id": 26,
        "completion": "The password must be at least 4 characters, no more than 8 characters, and must include at least one uppercase letter, one lowercase letter, and one numeric digit.",
        "passed": false
    },
    {
        "id": 26,
        "completion": "",
        "passed": false
    },
    {
        "id": 26,
        "completion": "^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[$\\W])[a-zA-Z\\d$\\W]{8,}$",
        "passed": false
    },
    {
        "id": 26,
        "completion": "`^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[A-Za-z\\d]{4,8}$`",
        "passed": false
    },
    {
        "id": 26,
        "completion": "https://regex101.com/test3vxc6/1/",
        "passed": false
    },
    {
        "id": 26,
        "completion": "^[a-zA-Z]{2}[0-9]{2}$",
        "passed": false
    },
    {
        "id": 27,
        "completion": "",
        "passed": false
    },
    {
        "id": 27,
        "completion": "",
        "passed": false
    },
    {
        "id": 27,
        "completion": "",
        "passed": false
    },
    {
        "id": 27,
        "completion": "<tr ng-match=\"ng-pattern\"   ng-repeat=\"ngPattern in ip\">   <td ng-repeat=\"ngPattern in ipPATtern\" ng-bind=\"ngPattern\">{{ngPattern}}</td></tr>",
        "passed": false
    },
    {
        "id": 27,
        "completion": "RegExp pattern = \"^((25[0-5])|(2[0-4][0-9])|(1[0-2][0-9])\\\\.){3}(25[0-5])$\";",
        "passed": false
    },
    {
        "id": 27,
        "completion": "<pre>((22[0-2]|25[0-5])\\.[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,2})</pre>",
        "passed": false
    },
    {
        "id": 27,
        "completion": "A validator that describes an IP address.  The validator should look for the following things:\u2022   Between 1 and 255 255.255.255\u2022   No leading 0's, for example 0.0.0.0\u2022   No leading or trailing zeros, for example 127.0.0.1\u2022   The address can't end with 10, which means subnetting would not",
        "passed": false
    },
    {
        "id": 27,
        "completion": "IP Address Expression Value: ^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|",
        "passed": false
    },
    {
        "id": 27,
        "completion": "<ValidatorRule    ClassName=\"IPRegExpRule\" xmlns=\"http://xmltags.oregistration.org/\">  <Rule>    <Name>IP</Name>    <Value>\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}</Value>",
        "passed": false
    },
    {
        "id": 27,
        "completion": "(30-99.999999).{1,3}.(0|1|2|3|4|5|6|7|8|9)",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: [0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]($|\\.)",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: [^0-9a-zA-Z]+",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: ^[a-zA-Z0-9-\\.]{0,2}$",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: [^0-9]*",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: (.+)\\.(0|1|2|3|4|5|6|7|8|9))",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: [0-9a-z]{1,3}\\.com",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: [^0-9\\s]",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: ((?=^.+?[7]?[^1-9]?\\.))|[1-9][1-9][1-9]|[1-9][0-9]",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer: [\\d-9]{0,2} or [\\d-9]{0,3}.After that you can force a pattern to a letter and replace the.COM in the string with that letter inside the square brackets. For example:.COM[0-9]{0,2}[0-9]{1",
        "passed": false
    },
    {
        "id": 34,
        "completion": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the.COM section.Generate a RegEx for this description. Answer:.{1,3}[\\.]{1,3}(?<![\\.])([0-9]|[A-Za-z]|[^\\s\\d_])",
        "passed": false
    },
    {
        "id": 36,
        "completion": "-?[-+]?\\d{0,2}\\.\\d{0,2}'",
        "passed": false
    },
    {
        "id": 36,
        "completion": "\\d+(?:\\.\\d+)?|\\d?\\d (decimal and decimals optional)",
        "passed": false
    },
    {
        "id": 36,
        "completion": "\\d{1,3}(?:\\.\\d{2})?",
        "passed": false
    },
    {
        "id": 36,
        "completion": "\\$([0-9]|[1-9][0-9]|\\d{2})(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 36,
        "completion": "^\\d*\\.\\d{0,2}$",
        "passed": false
    },
    {
        "id": 36,
        "completion": "^\\$?\\d+(,\\d+)?$",
        "passed": false
    },
    {
        "id": 36,
        "completion": "\\$(?:\\d+.\\d+)?[dD]?",
        "passed": false
    },
    {
        "id": 36,
        "completion": "\\d\\d\\d\\d\\.\\d\\d",
        "passed": false
    },
    {
        "id": 36,
        "completion": "(?:\\d+[\\.,]\\d+)?",
        "passed": false
    },
    {
        "id": 36,
        "completion": "$[ \\d,.]{0,2}(?:[ \\d,.]*\\.)?",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain then",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain,",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain for",
        "passed": false
    },
    {
        "id": 41,
        "completion": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix",
        "passed": false
    },
    {
        "id": 42,
        "completion": "var re = new RegExp('^\\\\d+$');re.test(some_string);",
        "passed": false
    },
    {
        "id": 42,
        "completion": "[0-9]+",
        "passed": false
    },
    {
        "id": 42,
        "completion": "(\\d+)\\s*$)",
        "passed": false
    },
    {
        "id": 42,
        "completion": "var str1 = \"abc123\";var str2 = \"abc-123\";var str3 = \"abc123.\";var numberGenerator = new RegExp(/(^[a-z0-9]+\\d+)|(^[a-z0-9]+\\.)/i);var validNumber = numberGenerator.test(str1);var validNumber = numberGenerator.test(str2);var validNumber = number",
        "passed": false
    },
    {
        "id": 42,
        "completion": "#(^[0-9]*$)|#(^[^0-9]*$)",
        "passed": false
    },
    {
        "id": 42,
        "completion": "\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+",
        "passed": false
    },
    {
        "id": 42,
        "completion": "validating string1 = (re.match('^[a-zA-Z0-9-_]*$', string1))",
        "passed": false
    },
    {
        "id": 42,
        "completion": "\\d/[1-9]\\d/([1-9]\\d|0{3})\\/([1-2][a-z]|[a-Z]{3})\\/[1-9]|[1-3]\\d|[3-9]\\d{2})\\/((1[02])|(02))",
        "passed": false
    },
    {
        "id": 42,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 42,
        "completion": "if(string.match(/\\/\\d+/g)!= null){alert('text is a number!');}",
        "passed": false
    },
    {
        "id": 45,
        "completion": "~[a-zA-Z]{4-8}$",
        "passed": false
    },
    {
        "id": 45,
        "completion": "[456-569]",
        "passed": false
    },
    {
        "id": 45,
        "completion": "",
        "passed": false
    },
    {
        "id": 45,
        "completion": "^[a-zA-Z]{4,8}$",
        "passed": false
    },
    {
        "id": 45,
        "completion": "`^(?=.*([a-z0-9]))(?=.*)(?=.*([A-Z]))[A-Za-z0-9]{3,7}$`This RegEx will match passwords that consist of at least one lowercase letter, one uppercase letter, one digit, and a maximum of 7 characters.",
        "passed": false
    },
    {
        "id": 45,
        "completion": "^(?=.{1,8}$)(?i)[a-zA-Z0-9!@#$%^&*()?.,]{4,8}$",
        "passed": false
    },
    {
        "id": 45,
        "completion": "This example limits the string length to 6 characters.",
        "passed": false
    },
    {
        "id": 45,
        "completion": "\\A(.{1,4})\\Z",
        "passed": false
    },
    {
        "id": 45,
        "completion": "[1234567890]{4,8}",
        "passed": false
    },
    {
        "id": 45,
        "completion": "/[a-z]{3,8}/i",
        "passed": false
    },
    {
        "id": 46,
        "completion": "^[a-z]*[0-9]*$[a-z] matches any non empty letters[0-9]* matches any non empty digits",
        "passed": false
    },
    {
        "id": 46,
        "completion": "(?<![a-z0-9])-?[0-9]",
        "passed": false
    },
    {
        "id": 46,
        "completion": "\\sx\\s*",
        "passed": false
    },
    {
        "id": 46,
        "completion": "/^\\d+$/;This regex matches an integer greater than 0.",
        "passed": false
    },
    {
        "id": 46,
        "completion": "^[0-9a-f]{2,3}[0-9a-f]{2,3}$",
        "passed": false
    },
    {
        "id": 46,
        "completion": "^-?\\d+$",
        "passed": false
    },
    {
        "id": 46,
        "completion": "^(\\d+)",
        "passed": false
    },
    {
        "id": 46,
        "completion": "^\\d*$",
        "passed": true
    },
    {
        "id": 46,
        "completion": "^0+$",
        "passed": false
    },
    {
        "id": 46,
        "completion": "^-?\\d+$",
        "passed": false
    },
    {
        "id": 47,
        "completion": "-?\\d+, or -?[\\d,]+, where the? makes the non-greedy match.",
        "passed": false
    },
    {
        "id": 47,
        "completion": "/^[0-9.-]*+$/",
        "passed": false
    },
    {
        "id": 47,
        "completion": "\\\\d+",
        "passed": false
    },
    {
        "id": 47,
        "completion": "0$",
        "passed": false
    },
    {
        "id": 47,
        "completion": "/^[1-9][0-9]*|[1-9][0-9]*$/",
        "passed": false
    },
    {
        "id": 47,
        "completion": "",
        "passed": false
    },
    {
        "id": 47,
        "completion": "This is a non-static match that matches any digit, any number of digits, no more than 2 digits after the decimal point, and possibly 0 or more whitespace characters.",
        "passed": false
    },
    {
        "id": 47,
        "completion": "\\d+",
        "passed": false
    },
    {
        "id": 47,
        "completion": "^[+-]?(\\d+|\\d+\\.\\d+)$",
        "passed": false
    },
    {
        "id": 47,
        "completion": "[\\d\\-]+",
        "passed": false
    },
    {
        "id": 48,
        "completion": "(^\\s*-?\\b\\d+\\.?\\d+\\b$).*",
        "passed": false
    },
    {
        "id": 48,
        "completion": "^\\d+(\\.0+)?$",
        "passed": false
    },
    {
        "id": 48,
        "completion": "^(([0-1]?(\\.[0-9]+){3})|([0-1]?\\.([0-9]+)[0-9]{3})|([0-1]?\\.)(?:[0-9]+)?)$",
        "passed": false
    },
    {
        "id": 48,
        "completion": "/\\d+\\.\\d+\\.\\d+/In order for the code in your question to compile it has to be written with the backslashes escaped.If you wish to just search for a string between 2 numbers then you can use an expression like: /([1-9]\\d*\\s)(\\d+\\.)\\s(\\d+)/.The regular expression reads as:[1-9]\\d*\\s",
        "passed": false
    },
    {
        "id": 48,
        "completion": "(?=\\+|-)(\\d|\\.|e|e[+-]?\\d+(?:[eE][+-]?\\d+)?)",
        "passed": false
    },
    {
        "id": 48,
        "completion": "\\b[0-9]\\.[0-9]+\\b",
        "passed": false
    },
    {
        "id": 48,
        "completion": "^[^, ]*(-?[0-9]+\\.[0-9]+)?(,[0-9]+(\\.[0-9]+)?(,[0-9]+(\\.[0-9]+)?[0-9]*))?$",
        "passed": false
    },
    {
        "id": 48,
        "completion": "(?<![^-\\d.]+).+(?!$) -- See demo!",
        "passed": false
    },
    {
        "id": 48,
        "completion": "(\\d+(\\.\\d*)?\\s*|\\d+|-|\\s+|)",
        "passed": false
    },
    {
        "id": 48,
        "completion": "^[0-9]*(.[0-9]*)?[ +\\-]?[0-9]*(.[0-9]*)?(.)?$Q:",
        "passed": false
    },
    {
        "id": 53,
        "completion": "^\\+[05][a-z\\d-]{2}\\s[0-9]{2}[.][a-z\\d-]{2}[.][0-9]{3}$",
        "passed": false
    },
    {
        "id": 53,
        "completion": "^([a-zA-Z0-9\\-]*\\ )[a-zA-Z0-9](\\d+)/?( [a-zA-Z0-9]*)",
        "passed": false
    },
    {
        "id": 53,
        "completion": "{1-9}[-\\s]?[0-9]{3}",
        "passed": false
    },
    {
        "id": 53,
        "completion": "\\b(\\d{3}[ -]\\d{3}[ -]\\d{4}|\\d{2}[ -]\\d{2}[ -]\\d{4}|\\d{3}[ -]\\d{3}[ -]\\d{4})\\b",
        "passed": false
    },
    {
        "id": 53,
        "completion": "^(123( -\\d{3})?|123[ -(\\d{3})]?)(\\d{3})[ -]\\d{4}$",
        "passed": false
    },
    {
        "id": 53,
        "completion": "(07)?[0-9][0-9] [A-Z]{3}[ -][0-9]{11}",
        "passed": false
    },
    {
        "id": 53,
        "completion": "0(?!^)\\+1(?!\\s)?(?<number>\\d+)(?<area><\\d{3}-?\\d{3})([\\s.-]\\d*)?(?<provider>[\\d\\w-]+)",
        "passed": false
    },
    {
        "id": 53,
        "completion": "r'\\(?([1-9][0-9]?)[- ]?([1-9][0-9]?)\\)?[- ]?([a-zA-Z0-9]*)?\\b'",
        "passed": false
    },
    {
        "id": 53,
        "completion": "(2) \\d{1,3}\\. \\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 53,
        "completion": "\\b[\\d\\s-]{7} \\z| [\\d\\s-]{9} \\z",
        "passed": false
    },
    {
        "id": 54,
        "completion": "^\\d{2}:\\d{2}$",
        "passed": false
    },
    {
        "id": 54,
        "completion": "(?P<hour>\\d{2}):(?P<minute>\\d{2})",
        "passed": false
    },
    {
        "id": 54,
        "completion": "hh{2}:\\{2}\\|mm{2}",
        "passed": false
    },
    {
        "id": 54,
        "completion": "[0-9]{2}:[0-9]{2] (AM|PM)?",
        "passed": false
    },
    {
        "id": 54,
        "completion": "(?i)(\\d{2}):(\\d{2})(am|pm)",
        "passed": false
    },
    {
        "id": 54,
        "completion": "",
        "passed": false
    },
    {
        "id": 54,
        "completion": "^\\d{1,2}:\\d{2}$|^\\d{1,2}:$",
        "passed": false
    },
    {
        "id": 54,
        "completion": "^((\\d{1,2}):(\\d{2}))((:|)'))*$|^(\\d{1,2})$",
        "passed": false
    },
    {
        "id": 54,
        "completion": "const timeReg = new RegExp(':([0-9]|0[0-9]|1[0-9]|2[0-3]:|3[0-5]:|4[0-5]:|5[0-9]:|6[0-9]:|7[0-9]:|8[0-9]:|9:|10:[0-9]:|11:|12:[0-9",
        "passed": false
    },
    {
        "id": 54,
        "completion": "(\\d{2}):(\\d{2}))",
        "passed": false
    },
    {
        "id": 57,
        "completion": "[[^\\-,\\. \\;\\!\\?\\s]\" -D\"$\",\". [^\\-,\\. \\;\\!\\?\\s]\" -D\"\\s,^\"$\",\"(?!,\\. \\s)\\s\"$\";\"",
        "passed": false
    },
    {
        "id": 57,
        "completion": "The answer is a combination of the two sets of conditions, which needs to be combined through the AND and OR operators (AND | OR ) for the generate_regex() function. The final expression should look like this \"^[a-zA-Z, ]*([a-zA-Z0-9.-]{5})[a-zA-Z0-9]*$\".",
        "passed": false
    },
    {
        "id": 57,
        "completion": "?[a-zA-Z0-9.,]+",
        "passed": false
    },
    {
        "id": 57,
        "completion": "[^[0-9]{4}-\\d{4}-\\d{4},\\s\\s]([A-Za-z0-9_]+)",
        "passed": false
    },
    {
        "id": 57,
        "completion": "\\p{L}\\s*(.+?),?,?,?,?,\\s*This would make sure the letters aren't spaces, and the sentence only has lower case letters.",
        "passed": false
    },
    {
        "id": 57,
        "completion": "(.+)(,){2,5}$",
        "passed": false
    },
    {
        "id": 57,
        "completion": "[\\w\\s.,+-\\'\"]*",
        "passed": false
    },
    {
        "id": 57,
        "completion": "Your answer may vary, but an example format is: \"^[a-zA-Z, ]+[a-zA-Z, ]+$\".",
        "passed": false
    },
    {
        "id": 57,
        "completion": "^[A-Za-z0-9 \\.,\\s-]*$",
        "passed": false
    },
    {
        "id": 57,
        "completion": "Your regex string should look like \"^[a-b]{1}[c-d]{1}[,e-f]{1}[g-h]{1}[,i-j]{1}$\"",
        "passed": false
    },
    {
        "id": 68,
        "completion": "[(\\d{5}[^)]+) (?=(\\d{5}))]",
        "passed": false
    },
    {
        "id": 68,
        "completion": "(Zip+5)-4*[0-9]{1}\\",
        "passed": false
    },
    {
        "id": 68,
        "completion": "([1-3]\\d\\d|[1-3]\\d[1-2]\\d-\\d{2}|\\d{3}[1-4]\\d{2}|20[0-9][6-9]|21-29)",
        "passed": false
    },
    {
        "id": 68,
        "completion": "^[0-9]{2}[0-9]{3}[0-9]{4}$",
        "passed": false
    },
    {
        "id": 68,
        "completion": "((\\d{1,3}(?:\\s|-))\\1)+This expression matches exactly 15 digits, separated by spaces or dashes. The (?:\\s|-) alternates between a space and a dash.",
        "passed": false
    },
    {
        "id": 68,
        "completion": "\\d{5}",
        "passed": false
    },
    {
        "id": 68,
        "completion": "[5-9][0-9]|[0-9][1-5]",
        "passed": false
    },
    {
        "id": 68,
        "completion": "[Z]\\.(\\d{5})+",
        "passed": false
    },
    {
        "id": 68,
        "completion": "^([0-9]{5})(\\-\\s?)?([0-9]{4})$",
        "passed": false
    },
    {
        "id": 68,
        "completion": "(\\d{5}\\d{4})",
        "passed": false
    },
    {
        "id": 69,
        "completion": "+\\d{3}(0)[ +]\\s*(\\d{3}|\\d[1-9])(\\d[1-9])?\\s*(\\d)?\\s?",
        "passed": false
    },
    {
        "id": 69,
        "completion": "^\\s*[\\+]\\d{3}\\s*(0|\\ +31\\s*)?\\s*(\\d{3})\\ ((0| \\+31\\s*)?\\s*(\\d{3})\\ 4).*$",
        "passed": false
    },
    {
        "id": 69,
        "completion": "^\\d{3}(\\+31\\s*)(\\d{3}(\\s*\\+31\\d{3}\\s*)+\\d{3}\\s*)?$",
        "passed": false
    },
    {
        "id": 69,
        "completion": "___________",
        "passed": false
    },
    {
        "id": 69,
        "completion": "^\\+31\\s*(?:[123][0-9]|[123][0-9][0-9])[\\s\\-]*[a-zA-z0-9]*$",
        "passed": false
    },
    {
        "id": 69,
        "completion": "^\\+30[1 0-9]{9}$",
        "passed": false
    },
    {
        "id": 69,
        "completion": "/[\\+\\+\\d][\\s\\-\\s]*(\\d{9}\\s)?[\\+\\+\\d]/gExample: (1) +3623 -3737 -3788 -3782 -3804(2) 0125 -2501(",
        "passed": false
    },
    {
        "id": 69,
        "completion": "(\\+31\\d{3}[ -]\\d{9})",
        "passed": false
    },
    {
        "id": 69,
        "completion": "var regex = /^[+31]+\\d{6}[+-0-9 ]+$/",
        "passed": false
    },
    {
        "id": 69,
        "completion": "[+31(0)][\\s]?(\\d{3}[\\s]?\\d{3}[\\s]?\\d{4}|\\d{9}-\\d{3}-\\d{4})",
        "passed": false
    },
    {
        "id": 73,
        "completion": "(?=[^a-z\\s]+)(?!(?=.{10,19}$)[a-z\\s",
        "passed": false
    },
    {
        "id": 73,
        "completion": "\\d{3}-?[0-9]{9}-?[0-9]{9}-",
        "passed": false
    },
    {
        "id": 73,
        "completion": "^\\s*(?:[-\\s]?\\d{3,}(?:-\\s?\\d{3",
        "passed": false
    },
    {
        "id": 73,
        "completion": "^[0-9]{4}-[0-9]{3}-[0-9]{4}-[0",
        "passed": false
    },
    {
        "id": 73,
        "completion": "[0-9]{10}[ -]?([0-9]{3})|([0-9]{3",
        "passed": false
    },
    {
        "id": 73,
        "completion": "/([0\\d]{3}\\-)?[0-9]{3}\\-?(2[0-9]",
        "passed": false
    },
    {
        "id": 73,
        "completion": "(?:\\d)(\\d)\\d{3}\\s*(?!-)\\s?(?:\\s|-)\\",
        "passed": false
    },
    {
        "id": 73,
        "completion": "[0-9]{1,3}\\-?[0-9]{1}[0-9]{",
        "passed": false
    },
    {
        "id": 73,
        "completion": "(([0-9]{10}[0-9]|[0-9]{9}[0-9]",
        "passed": false
    },
    {
        "id": 73,
        "completion": "\\b\\d{3}(?:-\\d{3})?(?:-\\d{4})?\\b",
        "passed": false
    },
    {
        "id": 74,
        "completion": "(?!\\.)|(?!\\.)|([0-9][0-9])[A-Z]?[A-Z]?\\.?([a-z])(?:\\.)|(?:\\.)(\\w{4})(?:\\.)\\d{3}(?:\\.)\\",
        "passed": false
    },
    {
        "id": 74,
        "completion": "( \\b[1-3][0-9]{2}| [0-3][1-9][0-9] | [0-9]{4} )$This regular expression looks for integers from 1 to 33 and from 12 to 31 to any digit. There are two other options:",
        "passed": false
    },
    {
        "id": 74,
        "completion": "[0-9]{1,2}[-/.][0-9]{1,4}[-/.][0-9]{4}",
        "passed": false
    },
    {
        "id": 74,
        "completion": "^[a-z]{1,2}[-\\s]?\\d{2,4}[-\\s]?\\d{4,}[a-z]{2,10}$Exercise 2: What character class is used above to match day (d or dd",
        "passed": false
    },
    {
        "id": 74,
        "completion": "\\b(d|[dd]|[mmm]|[yyy])( &gt;= )\\d{4}(\\w|-|\\.)(\\w|-|\\.)(\\w|-|\\.)(\\w|-|\\.)(\\w|-|\\.)(\\w|-|\\.)(\\w",
        "passed": false
    },
    {
        "id": 74,
        "completion": "dd/MM/yyyy|dd/MM/yyyy|dd/MM/yyyy|dd/MM/yyyy|d/MM/yyyy|d/MM/yyyy|y/MM/yyyy|y/MM/yyyy|y/MM/yyyy|yy|yy",
        "passed": false
    },
    {
        "id": 74,
        "completion": "[0-9]{4}(-[0-9]?[0-9]){1,2}(. [0-9]{3})?Hint: use the backslash escape sequence \\\\ for.",
        "passed": false
    },
    {
        "id": 74,
        "completion": "\\bY(0[1|2]\\d|1\\d)(-0[1|2]\\d|0\\d):\\d{4}\\bNote: The final string has to only contain alphanumeric characters and dashes.",
        "passed": false
    },
    {
        "id": 74,
        "completion": "d[0-3][0-9]|dd[0-3][0-9]|mm[0-3][0-9]|yyy[0-9]{4}",
        "passed": false
    },
    {
        "id": 74,
        "completion": "(0|1)([0-9]{2})?(0|[1-2][0-9])(20[3-9]){2}?(100[0-9]){3,4}",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer:^(?=(\\d+\\.25|\\d+\\.50|\\d+\\.75|\\d+\\.0|\\d+\\.00))(?=(?=(\\d+\\.25)\\d+)|(?=(\\d+\\.50)\\d+)|(?=(\\d+\\.75)\\d+)|(?",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer:var regEx = new RegExp(/^[0-9]*(50|75|0)(25|50|75)[0-9]*$/);",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer:\"$(.+)\\.(25|50|75|[0-9]{2}|[0-9]{0})\"",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer: ^.\\d{0,3}\\d(50|75|25|0|00)$",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer: ^(\\.25|\\.50|\\.75|\\.)0{5,}$",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer: (0?[5-9]?\\d*)(\\.(25)(50)(75))(\\.(0))",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer: (?=\\d+\\s*[5|50|75|0]$)(?!)",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer: ^(25|50|75|0|00)\\d.$",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer: (\\d{1}(25)|(50)|(75))00$",
        "passed": false
    },
    {
        "id": 75,
        "completion": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok!!Generate a RegEx for this description. Answer: ^(?=(?:\\\\d{1,2})(?:\\\\d{1,4})(?:\\\\d{1,3})(?:\\\\d{1,2}|\\\\d{1,3})$)(?:|(?<=\\\\d{1,2})(?<!\\\\d{1,4}",
        "passed": false
    },
    {
        "id": 80,
        "completion": "78754-12aAGreat",
        "passed": false
    },
    {
        "id": 80,
        "completion": "(\\d{3})-\\d{2}\\-\\d{4} $Code from the regexpal website: https://regexpal.com/?{code}",
        "passed": false
    },
    {
        "id": 80,
        "completion": "I added some white space and added a hyphen between city and zip. Also, I added the leading \"city of \" at the beginning and fixed up the trailing \"-\" as it used to be. No match :(EditHere is the RegEx that fixed my code:(  ^(?P<city>(?:\\s*-\\s*)?city(?",
        "passed": false
    },
    {
        "id": 80,
        "completion": "76-78aA",
        "passed": false
    },
    {
        "id": 80,
        "completion": "\\([^-]*-[^-]*-[^-]*-[^-]*\\). Since there are no restrictions with characters such as parentheses in this input, the regular expression should match.(See: http://www.regular-expressions.info/characterclass.html)",
        "passed": false
    },
    {
        "id": 80,
        "completion": "The two things that it seems to be missing are:",
        "passed": false
    },
    {
        "id": 80,
        "completion": "[\\w\\-\\ \\.]{3,}[A-D]{4}\\s?\\d{5}-\\d{9}",
        "passed": false
    },
    {
        "id": 80,
        "completion": "7875412a",
        "passed": false
    },
    {
        "id": 80,
        "completion": "The description is only valid if the last five characters (\"0123456789\" in the example) are all of an odd digit, the first three characters are two consecutive digit \"2\", the last two characters are either all \"5\"s or all \"9\"s (\"5\") or two consecutive \"9\"s, and the number of digits is between two and five.",
        "passed": false
    },
    {
        "id": 80,
        "completion": "[\\w\\-]{1,14}[-\\w\\s]{1,14}[A-Z]{3,21}$",
        "passed": false
    },
    {
        "id": 84,
        "completion": "postCode = '((\\\\(\\\\d{1,3}\\\\)(\\\\s){3})+|((-\\\\(\\\\d{1,3}\\\\)(\\\\s){3})+|((\\\\d\\\\)\\\\s){6})(\\\\s){5}|((\\\\d\\\\)\\\\s){6})(\\\\s){4}-\\\\d{1,3}\\\\)|((\\\\",
        "passed": false
    },
    {
        "id": 84,
        "completion": "`^[1-9][1-9][1-9][1-9]$`",
        "passed": false
    },
    {
        "id": 84,
        "completion": "(?i)([a-z] {3}[- ]{1}[0-9]{2})",
        "passed": false
    },
    {
        "id": 84,
        "completion": "(UKPostCode\\uE00\\d{3}(?: [-.\\s]\\d+)*)''',      '''US phone numbers can be formatted in 4 ways, this regular expression can be used to validate US phone numbers. The regex pattern is,     ''',      '''(123)... 444-555... or 044... 444-555-6666 or 111",
        "passed": false
    },
    {
        "id": 84,
        "completion": "_ \\d{1,9}_",
        "passed": false
    },
    {
        "id": 84,
        "completion": "^[A-Z]{1} [1-9][0-9][A-Z]{1}$",
        "passed": false
    },
    {
        "id": 84,
        "completion": "(?<!\\d)\\bB1\\d{1,2}\\b[\\b-\\w]? ([\\s\\w\\.-]+)\\b",
        "passed": false
    },
    {
        "id": 84,
        "completion": "",
        "passed": false
    },
    {
        "id": 84,
        "completion": "[a-zA-Z]+[0-9]{2}-[0-9]{2}-[0-9]{2}",
        "passed": false
    },
    {
        "id": 84,
        "completion": "\\b[A-Z]{2}\\d\\d\\d\\d\\b",
        "passed": false
    },
    {
        "id": 86,
        "completion": "DATE FORMAT TEST REGEX",
        "passed": false
    },
    {
        "id": 86,
        "completion": "| Date        | Description | Result                                ||-------------|--------------|---------------------------------------------------------------------|| 2022/01/01  | First day of Jan. | YYYY-MM-DD              || 2022/07/20  | My birthday  | YYYY-MM-DD                                || 2022/01/31  | First day of Jan. | YYYY-MM-DD || 2022/02/15  | My birthday | YYYY-MM-DD",
        "passed": false
    },
    {
        "id": 86,
        "completion": "(?:.*(\\\\d{3})(?:.|$))\\\\s*(?:(\\\\d{1,2})-\\\\d{1,2}-(\\\\d{4}))\\\\s*$Explanation: '?' (?:           # Non-capturing group; group 1 or 0 is returned; the next is allowed a chance to be'matched' against*             # The '*' character means 0 to an unlimited number of characters before it",
        "passed": false
    },
    {
        "id": 86,
        "completion": "(^(?:[0-9]{4}(\\/)?[0-9]{2}(\\/)?[0-9]|[012]?[0-9]|[1][0-9]|3[01])(\\/)?[0-9]{4}|[0-9]{4})$)",
        "passed": false
    },
    {
        "id": 86,
        "completion": "SELECT * FROM table_name INNER JOIN other_table_name ON table_name.date = other_table_name.date IN                (SELECT date FROM table ORDER BY date ASC LIMIT 3)            ORDER BY date ASC)",
        "passed": false
    },
    {
        "id": 86,
        "completion": "[a-zA-Z0-9._-](\\d+),.",
        "passed": false
    },
    {
        "id": 86,
        "completion": "([a-z\\-\\_]([a-z\\-\\_])[a-z\\-\\_]\\s*)",
        "passed": false
    },
    {
        "id": 86,
        "completion": "https://www.regular-expressions.info/timestamp.html",
        "passed": false
    },
    {
        "id": 86,
        "completion": "[a-zA-Z0-9._]+(\\+[a-zA-Z0-9._]+)[a-zA-Z0-9._]+(\\-[a-zA-Z0-9._]+)[a-zA-Z0-9._]+",
        "passed": false
    },
    {
        "id": 86,
        "completion": "",
        "passed": false
    },
    {
        "id": 87,
        "completion": "",
        "passed": false
    },
    {
        "id": 87,
        "completion": "\\d\\d\\d[-/.]\\d\\d\\d - Day of a month, optionally preceded by either - or/",
        "passed": false
    },
    {
        "id": 87,
        "completion": "^[0-9][- ]$|^[0-9][- ](1[1-9]|0?[1-9])[0-9][- ]$|^[0-9][- ]([01][0-",
        "passed": false
    },
    {
        "id": 87,
        "completion": "^(?=0[1-9])\\d\\d-\\d\\d-(\\d\\d)?-(\\d\\d)?$",
        "passed": false
    },
    {
        "id": 87,
        "completion": "(?:[2][0-1][0-9]|[3][0-1][0-2])(/)?(?:[0-9][0-9]|1[01])?(?:/?)(?:[0-",
        "passed": false
    },
    {
        "id": 87,
        "completion": "^(\\d{4})/(\\d{2})/\\d{2}$|^\\d{1,3}/\\d{1,2}/\\d{1,2}$|^\\d{3,9}",
        "passed": false
    },
    {
        "id": 87,
        "completion": "^[1-9][0-9]|1[012]|(0[1-9]|1[012])\\/3[0-9]{2}$",
        "passed": false
    },
    {
        "id": 87,
        "completion": "yyyy mm DD[- /# ]#",
        "passed": false
    },
    {
        "id": 87,
        "completion": "(?:(?:[0-9]{4})(?:-[0-9]{1,2})?(?:\\+(?:0(?:\\.0?)|1(?:\\.01))|(?:\\+(?:1(",
        "passed": false
    },
    {
        "id": 87,
        "completion": "xxx-xxx-xxxx-xxxx  yyy YYYY/MM/DD",
        "passed": false
    },
    {
        "id": 89,
        "completion": "*\\d{1,11}*\\d*-?\\d*",
        "passed": false
    },
    {
        "id": 89,
        "completion": "-?[1-9]\\d{9}|-?[1-9]\\d{10}|-?[1-9]\\d{11}|-?\\d",
        "passed": false
    },
    {
        "id": 89,
        "completion": "\\b(?:[1-4]?[0-9]{1,2}|[1-4]?[0-9]{0,3})[3-6]?[0-9]{3}[0-9]\\b",
        "passed": false
    },
    {
        "id": 89,
        "completion": "([0-9]'][0-9]'[0-9]-[0-9]|[0-9]{7}|[0-9]{10}|[0-9]{11}[0-9][0-9])",
        "passed": false
    },
    {
        "id": 89,
        "completion": "(0-9)(?:(-0-9){0,6})(0-9|\\.|\\-)",
        "passed": false
    },
    {
        "id": 89,
        "completion": "",
        "passed": false
    },
    {
        "id": 89,
        "completion": "[0-9]{1,7}-?[0-9]{1,7}-?[0-9]{1,7}|[0-9]{1,10}-?[0-9]{1,11}",
        "passed": false
    },
    {
        "id": 89,
        "completion": "^[0-9A-F][0-9A-F][0-9A-F]\\s[0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9]?[0-9]?$",
        "passed": false
    },
    {
        "id": 89,
        "completion": "[0-9]{7,10,11}$",
        "passed": false
    },
    {
        "id": 89,
        "completion": "(?<!\\d)-(?!\\d)\\.",
        "passed": false
    },
    {
        "id": 92,
        "completion": "^.*?\\.xls$",
        "passed": false
    },
    {
        "id": 92,
        "completion": "re.compile(r\"^\\.xls$\")",
        "passed": false
    },
    {
        "id": 92,
        "completion": "```^(?:\\/|(?:                [\\w.]+ \\.)+ <\\S+>(?:<([a-zA-Z \\-.,_ \\:\\\"]+)>\\s+)?([\\'][a-zA-Z0-9 _.-]+)$```",
        "passed": false
    },
    {
        "id": 92,
        "completion": "r\"^.*\\.xls\"",
        "passed": false
    },
    {
        "id": 92,
        "completion": "/^[a-zA-Z0-9\\.-]*\\/[a-zA-Z0-9\\.-]*\\/[a-zA-Z0-9\\._]{2}$/",
        "passed": false
    },
    {
        "id": 92,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 92,
        "completion": "\\.xls$",
        "passed": false
    },
    {
        "id": 92,
        "completion": "",
        "passed": false
    },
    {
        "id": 92,
        "completion": "'^.*files.*[\\$.].*xls$'",
        "passed": false
    },
    {
        "id": 92,
        "completion": "([a-zA-Z0-9]+\\.[a-zA-Z0-9\\-.]+xls)",
        "passed": false
    },
    {
        "id": 94,
        "completion": "/^09[0-2]?[0-9]|1[0-9]|1[012]), 1[0-9]), 2[0-4], 6[0-1] \\2$",
        "passed": false
    },
    {
        "id": 94,
        "completion": ".+((12|AM) | (1[012]|0?[1-9])?(AM|PM))+Explanation:.+ is used to match anything in the string. (|) specifies matches either 12 or a 12 followed by AM",
        "passed": false
    },
    {
        "id": 94,
        "completion": "(?!.*[a-z,A-Z]$)(?=[0-9]{9}|0[1-9])[0-9][0-9 ]",
        "passed": false
    },
    {
        "id": 94,
        "completion": "^([0-2]?[0-9]|3[0-1])([a-zA-Z])(2[0-9]|3[0-4])$",
        "passed": false
    },
    {
        "id": 94,
        "completion": "[0-9]{1,2}\\d{3,4} | [0-1]?\\d{2}\\d{2} PM | [0-1]?\\d{2}\\d{2} AM",
        "passed": false
    },
    {
        "id": 94,
        "completion": "(?>0(?=(?:0[3-9]|[012])[01][5-9]|[12]):[0-5][0-9])",
        "passed": false
    },
    {
        "id": 94,
        "completion": "(?:\\d{2}((?:[012]|1[012]):[012] \\d{3})|(?:\\d{2}))",
        "passed": false
    },
    {
        "id": 94,
        "completion": "",
        "passed": false
    },
    {
        "id": 94,
        "completion": "",
        "passed": false
    },
    {
        "id": 94,
        "completion": "^(0?[1-9]|1[0-2]) (?:M[0-9]|M00) T(1[0-2]|0[1-9])$ and^0(?:(0?[1-9",
        "passed": false
    },
    {
        "id": 95,
        "completion": "(?P<Month>\\d{1,2})\\/?(?P<Year>\\d{2,4})/$",
        "passed": false
    },
    {
        "id": 95,
        "completion": "/(0|[1-9][0-9]{1,2} /[0-9]{1,2} [0-9]{1,2})/.",
        "passed": false
    },
    {
        "id": 95,
        "completion": "\\d{1,2}\\/\\d{1,4}",
        "passed": false
    },
    {
        "id": 95,
        "completion": "(\\d{1}\\/\\d{1})/(\\d{2}-\\d{4})",
        "passed": false
    },
    {
        "id": 95,
        "completion": "[a-z]{1,2}\\/[0-9]{1,2}\\/[0-9]{1,4}",
        "passed": false
    },
    {
        "id": 95,
        "completion": "/^\\d{1,2}\\s*\\/\\d{2,4}$/",
        "passed": false
    },
    {
        "id": 95,
        "completion": "\\d{1,2}\\/\\d{1,4}",
        "passed": false
    },
    {
        "id": 95,
        "completion": "\\/\\d{1,2}\\/\\d{2,4}",
        "passed": false
    },
    {
        "id": 95,
        "completion": "\\d{1,2}/\\d{2,}",
        "passed": false
    },
    {
        "id": 95,
        "completion": "(\\d{1,2})\\/(\\d{1,2})/(\\d{4})",
        "passed": false
    },
    {
        "id": 96,
        "completion": "\\b\\d{2}\\/\\d{2}\\/\\d{4}\\z",
        "passed": false
    },
    {
        "id": 96,
        "completion": "[0-9]{2}\\s[0-9]{2}\\s[0-9]{4}",
        "passed": false
    },
    {
        "id": 96,
        "completion": "/^[1203]\\d/",
        "passed": false
    },
    {
        "id": 96,
        "completion": "^0?(?P<year>[01]\\d|2[0-8]|3[01])/(?P<month>[01]\\d|2[0-9]|3[01])/(?P<day>[0-9]{2})$",
        "passed": false
    },
    {
        "id": 96,
        "completion": "\\d{1,2}\\/\\d{1,2}\\/\\d{2}\\b",
        "passed": false
    },
    {
        "id": 96,
        "completion": "\\b(0[1-9]|1[012])/$|^[12][048]?[0-9]?[6-9]|[12][0-9]|3[01]$",
        "passed": false
    },
    {
        "id": 96,
        "completion": "([0-9]{2}\\w{3}\\/\\d{2}[0-9]{2}\\/\\d{4})",
        "passed": false
    },
    {
        "id": 96,
        "completion": "\"^(0[1-9])|([0-9]/[0-9])[0-9]|(20[1-9])$\"3. Write a pattern that matches any string starting with a \"a\" or \"A\" and ending with any non-letter character or the end of the string.",
        "passed": false
    },
    {
        "id": 96,
        "completion": "\\d{3}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 96,
        "completion": "^(0|1|2)[0-9]{2}.[0-9]{2}([0-9]{2})?[A-Z]{2}$",
        "passed": false
    },
    {
        "id": 97,
        "completion": "^(?!0[1-9]|2[0-3]|(0?[1-9])\\d):\\\\d{2}\\\\/\\\\d{2}\\\\/\\\\d{4}$",
        "passed": false
    },
    {
        "id": 97,
        "completion": "/(?P<year>[1-9]\\d{1,2})\\D+(?P<day>[0-2]\\d{1,2})(?P<month>[1-3]\\d{1,2})?(?:\\D+(",
        "passed": false
    },
    {
        "id": 97,
        "completion": "%B/%d/%Y",
        "passed": false
    },
    {
        "id": 97,
        "completion": "^\\d{2}[^/0]+/\\d{4}\\z",
        "passed": false
    },
    {
        "id": 97,
        "completion": "\\d{3}(?:[/-]\\d{2})?$",
        "passed": false
    },
    {
        "id": 97,
        "completion": "MM?[0-9]([0-9]|[01]))[0-9]?\\\\/([0-9]\\\\d{2})[0-9]?/2020| \\/ |   | |   +-----------------------------------",
        "passed": false
    },
    {
        "id": 97,
        "completion": "\\d\\d/\\d\\d/\\d\\d\\s\\d\\d",
        "passed": false
    },
    {
        "id": 97,
        "completion": "/^[0-9][1-9]/?[1-9][0-9]/",
        "passed": false
    },
    {
        "id": 97,
        "completion": "(?:(?<!\\\\.)\\\\d{1,2}/\\\\d{1,2}/\\\\d{4}|\\\\d{1,2}/\\\\d{1,2}/\\\\d{1,2}/\\\\d{2,}",
        "passed": false
    },
    {
        "id": 97,
        "completion": "\\b(?=(?:0(?:5|6)\\d)?)[0-2](?:0(?:5|6)\\d)?[1-3]\\d{2}\\b",
        "passed": false
    },
    {
        "id": 98,
        "completion": "\"([0-9]{1,3})'([0-9.]{1,3}).{0,3}\"",
        "passed": false
    },
    {
        "id": 98,
        "completion": "r'^(\\d{1,3})(?:\\.\\d{1,3})?$'",
        "passed": false
    },
    {
        "id": 98,
        "completion": "(\\d+)\\.\\w+\\.\\d+",
        "passed": false
    },
    {
        "id": 98,
        "completion": "^([3-9][0-9]{0,2})(('[ 0-9]{3,9})(('[ 0-9]{3,9})('[ 0-9]{3,9})))|(('[0-9]{3,9})(('",
        "passed": false
    },
    {
        "id": 98,
        "completion": "(.*)?'(\\d{1,3}(\\.\\d{0,3})?)?'",
        "passed": false
    },
    {
        "id": 98,
        "completion": "\\d\\.\\d{1,3}\\d([''])){0,1}",
        "passed": false
    },
    {
        "id": 98,
        "completion": "",
        "passed": false
    },
    {
        "id": 98,
        "completion": "r'[\\d,.]-?\\d{1,3}\\.?[\\d,.]+'",
        "passed": false
    },
    {
        "id": 98,
        "completion": "(\\d{3,4})(\\.\\d*)?(,(?!\\.))",
        "passed": false
    },
    {
        "id": 98,
        "completion": "(?<number>[^\\s](\\.\\d{3,}),?(?<unit>[^\\s]))",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer: 1.0000010101010101Explanation:",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer:(?P<mm>\\d{1,2})[.:](?P<dd>\\d)y(?:e(?P<y>\\d{4}))?",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer:^(    [[1]][1-9][1-9][1-9]    [0][1-9][1-9]    [1][0-2][0-9]    ([3][0-",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer: ^(0?\\d{2})([-/.])(\\d{2})$ and another one for the same year.",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer: \"^(20[3-9])\\.(0?[1-9])\\.(2018\\)|(2019)'(19)$\"",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer:0?[9]\\d{1,2}[1-4]",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer: (\\d+[-\\.\\/]\\d+)The regex is compiled in a javascript functionfunction MyRegexValidator(){    var regexPattern = new RegExp(r'^[0-9]{1,2}\\.[",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer: yymmdd",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer:\"^(19|20)\\d{2}(.?)$\"",
        "passed": false
    },
    {
        "id": 99,
        "completion": "Fully functional date validator in format dd.MM.yyyyWorks only within range of years 2000-2099!It allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through when",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through is",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through in",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through the",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through is",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through is",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through is",
        "passed": false
    },
    {
        "id": 100,
        "completion": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through it",
        "passed": false
    },
    {
        "id": 103,
        "completion": "(0?[1-9])/([1-2]?[0-9])/([0-9]{4})/([0-9]{4})$|1\\.(02|3)$",
        "passed": false
    },
    {
        "id": 103,
        "completion": "^(?=\\d{1,2}/\\d{1,2}/\\d{4}$)((?=^\\s)*)\\d{1,31}\\/\\d{1,2}",
        "passed": false
    },
    {
        "id": 103,
        "completion": "[2-9][1-3]/\\d{2}|3[1-9]/\\d{2}|(?= \\d{4}-\\d{2}$)[2-9][",
        "passed": false
    },
    {
        "id": 103,
        "completion": "^(?:\\d{1,14}|3[01]\\d|0\\d(1\\2)?)/(0[1-9]|1[0-2])$",
        "passed": false
    },
    {
        "id": 103,
        "completion": "r'^([1-9]\\d|1\\d|2[3-9])/([0-3]\\d|[4-9]\\d|[12])/([0-2]\\d\\",
        "passed": false
    },
    {
        "id": 103,
        "completion": "^(\\d{1,2}\\/\\d{1,2}\\/\\d{4})(,(\\d{3})\\d{3})$",
        "passed": false
    },
    {
        "id": 103,
        "completion": "^\\\\d{2}/?\\\\d{1,2}/\\\\d{4}$ and \\\\d{2,2}\\\\d{2}\\\\d{4}$ Question 1: Write a function that takes",
        "passed": false
    },
    {
        "id": 103,
        "completion": "^(0?[1-9]|1[012])\\/(\\d{1,2})\\/('(([1-9]\\d) \\d?|(3[01]\\d)|(4[01",
        "passed": false
    },
    {
        "id": 103,
        "completion": "/^(?:(?:0?[1-9]|[12])|1[0-2])[0-9]{2}/\\d{2}[0-9]{2}?$/(",
        "passed": false
    },
    {
        "id": 103,
        "completion": "\\D[0-9]{2}?[/][0-9]{2}[/][0-9]{4}(?:[.-][0-9]{2})?)|(?:\\D[",
        "passed": false
    },
    {
        "id": 108,
        "completion": "1-9[0-9]{0,2}([.[][0-9]{0,2}]+)?",
        "passed": true
    },
    {
        "id": 108,
        "completion": "(\\d+(\\.\\d+)?|\\d\\.)",
        "passed": false
    },
    {
        "id": 108,
        "completion": "\\d{1,3}((\\.\\d{3})?|(\\.\\d{1,2}))",
        "passed": false
    },
    {
        "id": 108,
        "completion": "+[1-9](\\.[0-9]{1,6})?([eE][-+]?[0-9]+)",
        "passed": false
    },
    {
        "id": 108,
        "completion": "n/(float)m*signum(n)/2^(3.9 - n)",
        "passed": false
    },
    {
        "id": 108,
        "completion": "(\\d+\\.\\d+)([+-])\\d*$",
        "passed": false
    },
    {
        "id": 108,
        "completion": "^\\d+(\\.\\d+)?(-\\d+)?$",
        "passed": false
    },
    {
        "id": 108,
        "completion": "(?:\\d+(\\.\\d+)?|\\d+\\.\\d+)",
        "passed": false
    },
    {
        "id": 108,
        "completion": "r'[+-]?[0-9]*\\.?[0-9]*'?",
        "passed": false
    },
    {
        "id": 108,
        "completion": "r'(?: [+-]?\\d+(?:\\.\\d+)?(?:[eE][-+]\\d+)?)+'",
        "passed": false
    },
    {
        "id": 110,
        "completion": "US zip code regex = '^\\\\d{5}.zip$'; CA2",
        "passed": false
    },
    {
        "id": 110,
        "completion": "/^([1-9][0-9]?)\\+(\\d)\\",
        "passed": false
    },
    {
        "id": 110,
        "completion": "US ZIP+4 = 5{ALPHANUM[0-9], -",
        "passed": false
    },
    {
        "id": 110,
        "completion": "^\\d\\d\\d-\\d\\d-\\d\\d",
        "passed": false
    },
    {
        "id": 110,
        "completion": "postal_code_regex = r\"(:\\d\\d\\-\\d\\",
        "passed": false
    },
    {
        "id": 110,
        "completion": "^(?=.*\\d)(?=.*[-]).?(?",
        "passed": false
    },
    {
        "id": 110,
        "completion": "``` pythonzipcode = re.compile(r'5\\",
        "passed": false
    },
    {
        "id": 110,
        "completion": "The following RegEx will do what we want: '^5[0-9",
        "passed": false
    },
    {
        "id": 110,
        "completion": "^[5-9]\\d{0,\\d}\\*-?",
        "passed": false
    },
    {
        "id": 110,
        "completion": "US5(?:-?(?:\\d{4}|\\d{",
        "passed": false
    },
    {
        "id": 113,
        "completion": "\\d{5}",
        "passed": false
    },
    {
        "id": 113,
        "completion": "(?<cod>(?=(?:[a-z])(?:\\s){3}[0-9])(?:\\s){2}[0-9]{5})This regex matches a",
        "passed": false
    },
    {
        "id": 113,
        "completion": "\\d{5}\\D(\\d{3})?",
        "passed": false
    },
    {
        "id": 113,
        "completion": "(\\d{1,3})\\s?(D|B{4})\\s?[F\\s](\\d{1,5})?(\\b)(   \\d{1,3",
        "passed": false
    },
    {
        "id": 113,
        "completion": "[A-Z][A-Z]\\d{3}              // Match any capital letter, then 3 digits after that.",
        "passed": false
    },
    {
        "id": 113,
        "completion": "(?:C\\d{3})|(?:E\\d{3})",
        "passed": false
    },
    {
        "id": 113,
        "completion": "\\d{3}(?:[-\\.,]\\d{3})?For more info refer to: https://www.regular-expressions.info/braces.htmlAnswer (with a space between",
        "passed": false
    },
    {
        "id": 113,
        "completion": "[^\\d]|(?=(([\\d\\s]+=)?\\1))",
        "passed": false
    },
    {
        "id": 113,
        "completion": "(2\\d\\d)?\\-(0[1-9]|1[012])or for your request^(2\\d\\d)?- (0[1-9]|1[012])",
        "passed": false
    },
    {
        "id": 113,
        "completion": "CEP\\s[^\\[]*[^\\]]*$",
        "passed": false
    },
    {
        "id": 114,
        "completion": "([^,]*)(?:(?:,[^,]*){3})",
        "passed": false
    },
    {
        "id": 114,
        "completion": "[0-9]\\.[0-9,]*",
        "passed": false
    },
    {
        "id": 114,
        "completion": "^[$\\\\,\\\\d,\\\\d,\\\\.\\\\d,\\\\d]+$",
        "passed": false
    },
    {
        "id": 114,
        "completion": "",
        "passed": false
    },
    {
        "id": 114,
        "completion": "\\$(\\d+(,\\d+)?|\\d+)([dDc][eE][e][d][c][c][c][i][n][n][n][n][]?)",
        "passed": false
    },
    {
        "id": 114,
        "completion": "^[\\d,](\\d{1,3})[\\,](?:\\d{1,3})$",
        "passed": false
    },
    {
        "id": 114,
        "completion": "```pythonre = re.compile(r\"(\\d+(?:\\,\\d+)?)\\s*[$]\",                 re.VERBOSE)```",
        "passed": false
    },
    {
        "id": 114,
        "completion": "^\\$([0-9]{1,})(?:, [0-9]{1,})*$",
        "passed": false
    },
    {
        "id": 114,
        "completion": "#\\S*?(\\d(,\\d{3})*$|\\d+,?(\\d+)$)",
        "passed": false
    },
    {
        "id": 114,
        "completion": "[0-9]\\.[0-9]\\.[0-9]'\\\\b((?!,\\\\d)|,)",
        "passed": false
    },
    {
        "id": 117,
        "completion": "^\\d{1,2} \\d{1,2}: \\d{2}$",
        "passed": false
    },
    {
        "id": 117,
        "completion": "(^(0|1|2|3|4|5|6|7|8|9)\\.?(0|1|2|3|4|5|6|7)\\.?(0|1),?\\?(0|1|2|3)\\.??(0|1)\\.?(0|1));",
        "passed": false
    },
    {
        "id": 117,
        "completion": "\\d{2}:\\d{2}|\\d{2}:\\d{2}|\\d{2}:\\d{2}|\\d{2}-\\d{2}-\\d{2}|\\d{2}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 117,
        "completion": ".*\\s+HH[0-9][0-9] [0-9][0-9] [0-9][0-9] //H[0-9][0-9](.*)\\s+MM[0-9][0-9]",
        "passed": false
    },
    {
        "id": 117,
        "completion": "/^([1-9]|[1-2]\\d|2[0-3])\\s*[0-5][0-9]\\s[0-5][0-9]$/",
        "passed": false
    },
    {
        "id": 117,
        "completion": "\\d{2}:[0-5]\\s{2}\\d{2}",
        "passed": false
    },
    {
        "id": 117,
        "completion": "(?:\\d\\s\\d)(?: / \\s \\d)?",
        "passed": false
    },
    {
        "id": 117,
        "completion": "The string \"14:42 / 09:17 / 08:53 / 09:03\"        Explanation: / is the separator, the numbers, A-Z, 0-9 are character classes, and : is used to match a space.",
        "passed": false
    },
    {
        "id": 117,
        "completion": "^(0[1-9]|1[0-2]) \\d\\d\\/\\d\\d / \\d\\d\\/\\d\\d / \\d\\d\\/\\d\\/\\d\\d$",
        "passed": false
    },
    {
        "id": 117,
        "completion": "pattern = re.compile(r\"(\\d{2}):(\\d{2}) / ((\\d{2}):(\\d{2})) / ((\\d{2}):(\\d{2}))\")",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: ^\\d{1,3}[,.!\\$]?[ \\.\\$]?Next example provided below (or at http://www.regular-expressions.info/syntax.html) is related to US dollar",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: (\\.\\S*\\?)?$",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer:%(#^[a-z].*)([a-z0-9]*)([0-9]*)([#$]|\\.$)",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: Regex101, https://regex101.com/r/eRmWlM/1Code to generate regex using the RegEx posted by http://regxlib.com/Redetails.aspx?regexp_",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: $\\\\.",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer:  ^[,.-]?$US\\.+I don't know how this really works, because it isn't generating the right regex. I just need a string to test with to see if it matches US currency.",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: (\\.{0,1})([$,]?[0-9]{1,3}(,[0-9]{3})?)?$",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: %\\d+\\.\\d{1,2}",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: $([\\d,.\\-]+)\\.([\\d,.\\-]+)",
        "passed": false
    },
    {
        "id": 118,
        "completion": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the. (period) to ensure that no other characters may be used in it's place.Generate a RegEx for this description. Answer: /-?\\d+(,\\d+)?\\.\\d+/",
        "passed": false
    },
    {
        "id": 119,
        "completion": "",
        "passed": false
    },
    {
        "id": 119,
        "completion": "\\$\\d+",
        "passed": false
    },
    {
        "id": 119,
        "completion": "[0-9]*.?,*?,*?,*?*? in a positive look ahead context is a wildcard.*?,*:?",
        "passed": false
    },
    {
        "id": 119,
        "completion": "(([0-9]{3})X?[0-9]{3})This RegEx matches any amount of money which has either 3 or 3 digits then an optional 'X' after the 3. To not match a zero, you would remove the optional 'X' that follows the 3 digit section and instead do ^(\\d{3})XXX?$That will match any amount of money where the 3 digits are 0 or greater, then an optional",
        "passed": false
    },
    {
        "id": 119,
        "completion": "([^$]\\d+)$Explanation:",
        "passed": false
    },
    {
        "id": 119,
        "completion": "(?:\\d\\.\\d{2}|\\d{3}) - $",
        "passed": false
    },
    {
        "id": 119,
        "completion": "/\\$?[\\d]{1,50}@/i",
        "passed": false
    },
    {
        "id": 119,
        "completion": "\\d+.*",
        "passed": false
    },
    {
        "id": 119,
        "completion": "^\\d+\\.?\\d*$",
        "passed": false
    },
    {
        "id": 119,
        "completion": "(?i)(?m)[+-]{1}[0-9]{1,3}(?:\\.[0-9]{3})?",
        "passed": false
    },
    {
        "id": 120,
        "completion": "DateRegex = // 1D + MM/YY, checks month is 1-12 and any 2 digit year.",
        "passed": false
    },
    {
        "id": 120,
        "completion": "[0-1][0-9][0-9][a-zA-Z]/[0-9][0-9]",
        "passed": false
    },
    {
        "id": 120,
        "completion": "^(?:[1-9][0-9]??|1[0-2])\\/([2-9][0-9]{3}|03|04|05|06|07|08|09|10|11|12)\\/([0-2][0-9]{3}|03|04|05|06|07|08|09|10|11|12)$",
        "passed": false
    },
    {
        "id": 120,
        "completion": "^(1?[3-9]|[12][0-9]|0?[1-9])/(?:1[3-9]|2[0-9]|[12]0?|[120]?[0-9])$",
        "passed": false
    },
    {
        "id": 120,
        "completion": "^(((1[0-9]|1[0-2])\\/)(((20[0-9])|([0-9]?[1-9])\\/(0?[1-9]))|((18)|((19)|((20)|((21))$)))2)$",
        "passed": false
    },
    {
        "id": 120,
        "completion": "^.*\\d{2}/\\d{2}$Note that some users may provide two digit years.  However it may be easier to accept them separately.",
        "passed": false
    },
    {
        "id": 120,
        "completion": "\\d{1,2}/\\d{2,4}",
        "passed": false
    },
    {
        "id": 120,
        "completion": "^(((?:0?[0-9]|1[0-2])-(?:0?[0-9]|3))|(?:3?[1-9]|4[0-2]))/(?:Jan(?:t)?|Feb)?$Explanation: (?:0?[0-9]|1[0-2]):- matches 01-12.             (?:0?[",
        "passed": false
    },
    {
        "id": 120,
        "completion": "\\d\\d\\/\\d\\d/\\d\\d\\dExplanation: the above RegEx can be used to match either MM/YY or MM/YYYY",
        "passed": false
    },
    {
        "id": 120,
        "completion": "^((11|12)\\/(0[1-9]|1[012])\\d{4})$",
        "passed": false
    },
    {
        "id": 123,
        "completion": "(\\(?:00\\d{2}\\-)?[0-9]{3}\\-(0[1-9]|1[012])[0-9]{3}|0049)\\(?999)?$ It's easier to",
        "passed": false
    },
    {
        "id": 123,
        "completion": "%d+[-0123456789]([-0123456789]{3}){3}%",
        "passed": false
    },
    {
        "id": 123,
        "completion": "\\+\\d{3}\\ (\\d{3})\\ (+\\d{3}\\ (\\d{4}))?This code will match the DDD or DDD/9999 and the DDD 99 plus. It would also match the DDD",
        "passed": false
    },
    {
        "id": 123,
        "completion": "r[^0-9]99(??{9})\\s*([-0-9]\\d+)(??{0}(\\+\\d{0,2})?)(-0-9\\d+)\\s*([-0-",
        "passed": false
    },
    {
        "id": 123,
        "completion": "(?<ddd>\\d{3})^(?!\\d$)(?<local>[-\\(\\)]?\\d{3}(?:[-\\(\\)]?\\d{4}?)?)",
        "passed": false
    },
    {
        "id": 123,
        "completion": "[1]+[0-9]{3,4}$",
        "passed": false
    },
    {
        "id": 123,
        "completion": "([+]?[0-9]{3,4})Now it is necessary for you to write a program to validate phone numbers in your email. In this exercise you should write email validation for your own emails. I will provide information on how to code this",
        "passed": false
    },
    {
        "id": 123,
        "completion": "^9(9|96)0(0|0)2$",
        "passed": false
    },
    {
        "id": 123,
        "completion": "([[:digit:]])([\\+\\-])?[[:digit:]]{3}|[[:digit:]]{4}(?:\\s([+\\-]\\s)*\\s([\\+\\-]\\s)*\\s([\\",
        "passed": false
    },
    {
        "id": 123,
        "completion": "[&quot;[a-zA-Z0-9+][0-9][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9][-]?",
        "passed": false
    },
    {
        "id": 125,
        "completion": "import refilePathPattern = \"^/home/path$\"fileNamePattern = r\"^([a-zA-Z]*)-([a-zA-Z]*)$\"",
        "passed": false
    },
    {
        "id": 125,
        "completion": "validTextPath($pathOrFileRegExp) ; $pathOrFilePattern$pathOrFileRegExp: \"(\\\\\\\\?[rR]\\/)([a-z0-9]+[a-z0-9]+[a-z0-9_\\-./",
        "passed": false
    },
    {
        "id": 125,
        "completion": "using System;using System.Collections.Generic;using System.Linq;using System.Text;",
        "passed": false
    },
    {
        "id": 125,
        "completion": "",
        "passed": false
    },
    {
        "id": 125,
        "completion": "You can use this RE to get the full path to your file:        \"^.*$\" -- All files must be located within this directory and be of the specified extension,         for example:./files/file.txt        You can use this RE to filter all",
        "passed": false
    },
    {
        "id": 125,
        "completion": "This RE validates a path or file of type json (JSON file)This RE can be used as a filter on certain file types, while insuring the entire string is a fully qualified path and file. The filter value can be changed or added to when using this RE.",
        "passed": false
    },
    {
        "id": 125,
        "completion": "@\"^[a-zA-Z0-9._-]*$\" // valid-path(.txt)|> = false@\"^(?:[Uu][Aa][Uu][Aa])?$|\" // valid-path(",
        "passed": false
    },
    {
        "id": 125,
        "completion": "https://regex101.com/r/h0qF4V/1",
        "passed": false
    },
    {
        "id": 125,
        "completion": "/\\w+.txtQ:",
        "passed": false
    },
    {
        "id": 125,
        "completion": "",
        "passed": false
    },
    {
        "id": 126,
        "completion": "# (?i)^(?:[a-z\\-][a-z0-9]+[a-z\\-]|[a-z0-9]-[a-z\\-]|[a-z0-9]-[a-z0-9][a-z]|[a-z0-9][a-z0-9\\-]|",
        "passed": false
    },
    {
        "id": 126,
        "completion": "(?i)\\b(?!^|\\.)[-a-z0-9]+\\.[-a-z0-9]+(?:\\.[-a-z0-9]+){2,6}\\b",
        "passed": false
    },
    {
        "id": 126,
        "completion": "(?!\\A[^-\\s]+-\\s[^\\-\\s]+.[^-\\s]+\\z)",
        "passed": false
    },
    {
        "id": 126,
        "completion": "@.+[\\s-](?:\\s*\\.?[\\w.]+)*+",
        "passed": false
    },
    {
        "id": 126,
        "completion": "^[a-zA-Z0-9-_\\.]+$",
        "passed": false
    },
    {
        "id": 126,
        "completion": "d-(?![a-zA-Z0-9].*$)",
        "passed": false
    },
    {
        "id": 126,
        "completion": ".+?[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]",
        "passed": false
    },
    {
        "id": 126,
        "completion": "(see http://www.regular-expressions.info/unicode.html for some of the unicode issues)^[\\\\w\\\\d\\.-]+?(?:\\.[\\\\w\\\\d\\.-]+?){0,2}$",
        "passed": false
    },
    {
        "id": 126,
        "completion": "[a-zA-Z0-9._-]+\\/[a-zA-Z0-9_./-]+",
        "passed": false
    },
    {
        "id": 126,
        "completion": "(^[A-Z0-9-]{1,63}\\.[A-Z]{1,6}\\.[A-Z0-9-]{1,6}$)",
        "passed": false
    },
    {
        "id": 127,
        "completion": "x^2-[1-3z], where x will accept decimal points and z will accept floating point values.",
        "passed": false
    },
    {
        "id": 127,
        "completion": ".*?[^eE][0-9a-zA-Za-z\\._]*\\.[^eE][^\\.']",
        "passed": false
    },
    {
        "id": 127,
        "completion": "(?<!\\d)(?:^|(?=(?!x)(.+)x))\\d*(?=(?![a-z])(?=(?![A-Z])))",
        "passed": false
    },
    {
        "id": 127,
        "completion": "0.25^n{0,1}",
        "passed": false
    },
    {
        "id": 127,
        "completion": "(?!\\d+)[ \\.-\\,]*(?=:.+([2-9]\\d*))*",
        "passed": false
    },
    {
        "id": 127,
        "completion": "*\\.?\\d+$For example, a string could be of this type: 15.5, 15.5.5 or 15.5.5.0. All match because 15.5 matches the pattern exactly. For the second example 15.5.5.0 - 15 is an integer",
        "passed": false
    },
    {
        "id": 127,
        "completion": "\\d+\\.\\d*(?:\\^\\d+\\.\\d*)?",
        "passed": false
    },
    {
        "id": 127,
        "completion": "^(?:[1-9]\\d?|1\\d\\d)\\.([1-9]\\d?|3[0-3]|40|50|60|70|80|90|100)$",
        "passed": false
    },
    {
        "id": 127,
        "completion": "[0-9]*[.](0|[1-9][0-9]*)*e[0-9]+",
        "passed": false
    },
    {
        "id": 127,
        "completion": "\\.?[0-9]*[0-9]$",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer: (    [0-7]{1,2}[01],  # hours 01-23 AM or PM    00[0-5]?[0-9]  # hours 00-59)",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer: (00|[1-2]\\d|3[0-1])[0-23]|[1-9]\\d|10[0-2]|1[1-9]|[2-9]\\d|100[0-9])[0-59]|[0-59",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer: \\d{1,2}:\\d{2}(?:-?\\d)\\d{2}(?::?\\d)?\\d{2}Exercise 2: Identify the PatternYour phone number should be one US number followed by a local prefix. Write this in a pattern that identifies a US number",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer: ^(19|20|21|22)[0-9]?[0-9]?[0-9] [0-59][0-9]?[0-5][0-9]?[0-5]?[0-9]$",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer: 0:[0-5][0-9][0-5][0-9][0-5]\\.[0-9] or 0:[1-9][0-9]",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer:var hours = 0;var minutes = 0;var seconds = 0;",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer: (?:\\w+|\\.(?:\\d|:)){1,2}:(?:\\d{1,2}|:){1,2}(?:\\w|\\s?)?(?:\\w\\.){0,1}([\\d\\.\\, ]+)?",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer:string pattern = \"/((01[01]|2[03][01]|22[1-9])-(02\\d|3[01]))/(:|.|am)(0[1-9]|[3-9]\\d|10)([012]|0[1-9])(",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer:^([0-5][0-5]|6)[0-9]?[0-9]|(1[012])[0-9]:[0-5][0-5]|1[0-2]\\d:?[0-5][0-5]$",
        "passed": false
    },
    {
        "id": 132,
        "completion": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.Generate a RegEx for this description. Answer: [0-9]{0,2}:[0-9]{2}[.,:] [0-9]{2}:[0-9]{2}-matches a 12 hour time;[1-9]{0,2}:[0-9]{2}:[A-Z]",
        "passed": false
    },
    {
        "id": 133,
        "completion": "[^\\s'][a-zA-Z0-9-\\s]+",
        "passed": false
    },
    {
        "id": 133,
        "completion": "[^a-zA-Z0-9']",
        "passed": false
    },
    {
        "id": 133,
        "completion": "(?:\\w|-|\\')\\s*(?:\\w|-|\\')",
        "passed": false
    },
    {
        "id": 133,
        "completion": "\\p{AlphaNumeric}+[\\s-,](\\p{Alpha}+[\\s-,])+",
        "passed": false
    },
    {
        "id": 133,
        "completion": "[a-zA-Z\\d\\s\\-|\\(|\\)]+",
        "passed": false
    },
    {
        "id": 133,
        "completion": "_0-9a-zA-Z\\-\\s'_.",
        "passed": false
    },
    {
        "id": 133,
        "completion": "'a-z, A-Z, 0-9 -,., -'",
        "passed": false
    },
    {
        "id": 133,
        "completion": "`([^A-Za-z0-9\\ -\\(\\),\\:]+)`",
        "passed": false
    },
    {
        "id": 133,
        "completion": "(?i)(^[-a-z]+)*?[a-zA-Z0-9\\s?-\\']*?",
        "passed": false
    },
    {
        "id": 133,
        "completion": "[\\w-\\s] [a-zA-Z-] (hyphen) [0-9] (hyphen)",
        "passed": false
    },
    {
        "id": 139,
        "completion": "^\\d{1,2} \\d{1,2} \\d{1,2},\\d{1,2} \\.{1}$ or ^(\\d)$",
        "passed": false
    },
    {
        "id": 139,
        "completion": "/^\\d+?(\\.\\d+)?\\s*[0-9]+\\.(0?[1-9]|[0-9]\\d|1[0-2]):[0-5]?[0-9]?\\s*$/",
        "passed": false
    },
    {
        "id": 139,
        "completion": "[1-9][0-9]{0,2}|[0-9]{1,2}[/][0-9]|[0-9]{1,2}\\.[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 139,
        "completion": "[0-9]\\d,\\d[0-9]\\d",
        "passed": false
    },
    {
        "id": 139,
        "completion": "r'\\d{1,5}(?:\\.[\\d]{1,2})?(?:\\.[\\d]{1,3})?\\d*'",
        "passed": false
    },
    {
        "id": 139,
        "completion": "\\\\d{1,2}[\\.:/]?\\d{1,2}(?:[eE][+-]\\d+)*",
        "passed": false
    },
    {
        "id": 139,
        "completion": "(?<!\\^)(?P<int1>\\d{1})(?P<dec1>[\\.,]?\\d{1})(?<![.,]|\\^)(?!=)(?P<int2>\\d{2})(?P<dec2>[\\.,]?\\d{2})(?![.,]|\\",
        "passed": false
    },
    {
        "id": 139,
        "completion": "(\\d{1,2}\\.\\d?){3,}[\\d.\\s]",
        "passed": false
    },
    {
        "id": 139,
        "completion": "^(0|[1-9][0-9]*)?\\.(0|[1-9][0-9]*)?$",
        "passed": false
    },
    {
        "id": 139,
        "completion": "`^\\s(?:[-+]?\\d(?:\\.\\d\\d*|\\.\\d\\d+)(?:\\s|$)?)\\s?$`",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer: egrep -E '[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer:^(   (?:[0-9A-Fa-f]{1,2}:){5}   [0-9A-Fa-f]{1,2}   |   [0-9A-Fa-f]{1,4}:   [0-9A",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer: python validate_mac.py <test_case_1> <test_case_2>",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer:[0-9A-Fa-f]{2}[0-9A-Fa-f]{2}[0-9A-Fa-f]{2}[0-9A-Fa-f]{2}[0-9A-Fa-f]",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer: [A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa-f0-9]{2}:[A-Fa",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer:^([0-9a-fA-F]{2}[:-]){5}([0-9a-fA-F]{2})$",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer:^[0-9a-fA-F]{2}:{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}$[f]eg:./",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer:\\b(?:[0-9a-fA-F]{2}[:-]){5}[0-9a-fA-F]{2}\\b",
        "passed": false
    },
    {
        "id": 141,
        "completion": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.Generate a RegEx for this description. Answer:grep -E '[A-Fa-f0-9:.]+'",
        "passed": false
    },
    {
        "id": 142,
        "completion": "(\\d{3})(,\\g<1></g>)*.",
        "passed": false
    },
    {
        "id": 142,
        "completion": "[00]\\d{3}[-\\s]?[0-9]{2}[0-9]|[0-9]{2}[\\s-]?[0-9]{3}[0-9]",
        "passed": false
    },
    {
        "id": 142,
        "completion": "[0-9]+%.",
        "passed": false
    },
    {
        "id": 142,
        "completion": "A regex could be generated with something like [^1], meaning that anything that is not a 1 should be included, such as the number \"3\". This pattern could then be run in a Python engine to generate a new string that includes the number \"3\"",
        "passed": false
    },
    {
        "id": 142,
        "completion": "\"^(\\d{2,}).{3}$\"",
        "passed": false
    },
    {
        "id": 142,
        "completion": "(.*?[^.,])(?=,)",
        "passed": false
    },
    {
        "id": 142,
        "completion": "[0-9]{2}\\.\"[0,9]{3}\"",
        "passed": false
    },
    {
        "id": 142,
        "completion": "[0,1,2-3]",
        "passed": false
    },
    {
        "id": 142,
        "completion": "{1}(\\,{0}?%){9}",
        "passed": false
    },
    {
        "id": 142,
        "completion": "^[^,](\\d{1})([$\\/]\\d{1})$ *%\\b\\d{1}(\\.\\d\\d){1}(\\.\\d\\d){1}\\b",
        "passed": false
    },
    {
        "id": 143,
        "completion": "(?<!\\d)0[0-9]{2}(?:-[0-9]{2}){1,2}?\\d{4}",
        "passed": false
    },
    {
        "id": 143,
        "completion": "^\\d{2}/\\d{2}/\\d{4}$",
        "passed": false
    },
    {
        "id": 143,
        "completion": "\\d{2}/\\d{2}/\\d{4} OR \\d{2}/\\d{2}/\\d{4} \\d{2}:\\d{2}:\\d{2}",
        "passed": false
    },
    {
        "id": 143,
        "completion": "",
        "passed": false
    },
    {
        "id": 143,
        "completion": "YYYY/MM/DD|DD/MM/YY",
        "passed": false
    },
    {
        "id": 143,
        "completion": "dd/mmm/yyyy OR dd/mmm/yyyy hh:mm:ss 8. Exercise: Create a Python program that accepts a parameter name and generates a regular expression using this parameter as a delimiter to parse a string of dates. Answer:import re",
        "passed": false
    },
    {
        "id": 143,
        "completion": ".{0,2}\\d{1,13}\\d{1,2}(?:[ /.-]\\d{1,2}){0,25}",
        "passed": false
    },
    {
        "id": 143,
        "completion": "\\1\\2",
        "passed": false
    },
    {
        "id": 143,
        "completion": "[Regular expression]",
        "passed": false
    },
    {
        "id": 143,
        "completion": "https://regex101.com/r/pHj4z6/1",
        "passed": false
    },
    {
        "id": 145,
        "completion": "$2[a-zA-Z0-9.][a-zA-Z0-9./]{1,61}$&$2()&lt;/?[^:/]+\\.([a-zA-Z]{1,2}|[a-zA-Z0-9]|[a-",
        "passed": false
    },
    {
        "id": 145,
        "completion": "^([^\\.\\s]+(\\.[^\\s]+)+)(\\.([a-z]{1,6})?)?$/;\"\"\"",
        "passed": false
    },
    {
        "id": 145,
        "completion": "/^.{1,63}\\.[a-zA-Z0-9\\-]{1}$/.",
        "passed": false
    },
    {
        "id": 145,
        "completion": "/^.+\\.([A-Z][a-z]|[A-Z][a-z][0-9]|[A-Z][a-z][0-9][A-Z]|[A-Z][a-z][0-9][A-Z][a-z]|[A-Z][a",
        "passed": false
    },
    {
        "id": 145,
        "completion": "^/^\\W*(?:\\.[a-zA-Z]{0,63}){0,19}(_[a-zA-Z0-9]{0,61}|[a-zA-Z]{2,})$/",
        "passed": false
    },
    {
        "id": 145,
        "completion": "/[a-zA-Z0-9\\.][a-zA-Z0-9\\,\\.]{2,63}[a-zA-Z]$/.Explanation: Validating the domain name includes several more requirements. The. is the standard domain separator in this case.1. All characters must contain",
        "passed": false
    },
    {
        "id": 145,
        "completion": "/^[a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)*$/i; /^[a-zA-Z0-9]{63,}$/; \\D should never be used inside a character class.",
        "passed": false
    },
    {
        "id": 145,
        "completion": "(/^[^.]*\\.[.a-z]+/$or, using the above RegEx,/^(?!.*[.a-z]+$).*[.a-z]{51,}$/",
        "passed": false
    },
    {
        "id": 145,
        "completion": "/^[a-z0-9.][a-z0-9.-]{0,61}[a-z0-9.]+$/i and  /[a-z0-9.-]{0,62}(\\.edu|[a-z0-9.]+\\.[a-z]{3})$",
        "passed": false
    },
    {
        "id": 145,
        "completion": "^(?=.*?[a-z])(?=.*?[A-Za-z0-9])(?=.*?[0-9$|@&!#?]).?(?!\\-).\\S{63}($2)",
        "passed": false
    },
    {
        "id": 146,
        "completion": "(.{5,20})(?!\\1).",
        "passed": false
    },
    {
        "id": 146,
        "completion": "",
        "passed": false
    },
    {
        "id": 146,
        "completion": "(.*?)\\.'",
        "passed": false
    },
    {
        "id": 146,
        "completion": "(?<![^']+')[^']+",
        "passed": false
    },
    {
        "id": 146,
        "completion": "x(?!']",
        "passed": false
    },
    {
        "id": 146,
        "completion": "/[^\\'\\'']+/",
        "passed": false
    },
    {
        "id": 146,
        "completion": "`[^(\"]*`",
        "passed": false
    },
    {
        "id": 146,
        "completion": "(?<!\\(\")\".*?(?!\\))",
        "passed": false
    },
    {
        "id": 146,
        "completion": "(?!')(?!.*')(?!.).*",
        "passed": false
    },
    {
        "id": 146,
        "completion": "^[^\"']*$",
        "passed": false
    },
    {
        "id": 147,
        "completion": "\"^[1-4][0-9][0-9]x[0-9]$\"",
        "passed": false
    },
    {
        "id": 147,
        "completion": "ip_addr = r'^(\\d{1,3}\\.){3}\\d{1,3}$'.match(host)",
        "passed": false
    },
    {
        "id": 147,
        "completion": "r`^[1-9]\\d|1([0-2])(1\\d|2\\d)\\d{1,2}$`",
        "passed": false
    },
    {
        "id": 147,
        "completion": "r\"(0|[1-9]\\d?|1[0-9]{2}|2[0-4][0-9]|25[0-5])\"",
        "passed": false
    },
    {
        "id": 147,
        "completion": "(?!\\s*\\d+\\s*:\\s+\\d+\\s*)?\\d+[.:]\\d+[.:]\\d+",
        "passed": false
    },
    {
        "id": 147,
        "completion": "/^\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}$/",
        "passed": false
    },
    {
        "id": 147,
        "completion": "[1-255].[0-9][0-9]|[0-9][0-9][0-9][0-9]|[0-9][0-9][0-9]",
        "passed": false
    },
    {
        "id": 147,
        "completion": ".*[0-9]{1,2}.[0-9]{3}.[0-9]{3}.[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 147,
        "completion": "^((10|192|11)\\.0{1,3}|192\\.0{1,3}\\.0{1,3}|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})$",
        "passed": false
    },
    {
        "id": 147,
        "completion": "0x[0-9A-Fa-f]+$",
        "passed": false
    },
    {
        "id": 149,
        "completion": "^\\d{0,2}.?(.{0,2})\\d[0-9.]+$",
        "passed": false
    },
    {
        "id": 149,
        "completion": "^(?:\\d+\\.)?[0-9]+(?:\\.\\d+,)*[0-9]+$I am not sure how to use this to find all numbers that the user input does not end in.",
        "passed": false
    },
    {
        "id": 149,
        "completion": "\\d+(\\.\\d+)+",
        "passed": false
    },
    {
        "id": 149,
        "completion": "(?<!\\w)(\\d+?)\\.?(?!\\.)",
        "passed": false
    },
    {
        "id": 149,
        "completion": "^[\\+^-]?\\d*[.\\d]*$",
        "passed": false
    },
    {
        "id": 149,
        "completion": "(\\\\d+(?:\\.\\\\d+)?)(\\\\+)?((\\\\d+(?:\\.\\\\d+)?)(\\\\+)?((\\\\d+(?:\\.\\\\d+)?)(\\\\+)?((\\\\d+(?:\\.\\\\d+)?)(\\\\+)?((\\\\d+(?:\\.\\\\d+)?)(\\\\+)?((\\\\d+(?:\\.\\\\d+)?)(\\\\+)?((\\\\d+(?:\\.\\\\d+)?)(\\\\",
        "passed": false
    },
    {
        "id": 149,
        "completion": "\\d*\\.?\\d*|^\\d+[,-]\\d+\\.?\\d*5. Create and use a RegEx to search for words that consist of at least 6 letters and 1 number. Answer: (?i)\\b[A-Z]\\d{1,5}\\b",
        "passed": false
    },
    {
        "id": 149,
        "completion": "(?<!^)(?<!$)(?<=\\d\\.\\d+)(?!\\d)",
        "passed": false
    },
    {
        "id": 149,
        "completion": "\\b(?:\\d*(?:\\.\\d+){1}\\d+)\\b",
        "passed": false
    },
    {
        "id": 149,
        "completion": "1+\\s*[^.\\d]+",
        "passed": true
    },
    {
        "id": 153,
        "completion": "",
        "passed": false
    },
    {
        "id": 153,
        "completion": "(([0-2]?[0-9]|0[1-9])-(1[0-2]|0[89])|[1-9]?",
        "passed": false
    },
    {
        "id": 153,
        "completion": "function myExp(str){    return str       .split(' ')       .filter(function(value, index, a){            var day = parse",
        "passed": false
    },
    {
        "id": 153,
        "completion": "",
        "passed": false
    },
    {
        "id": 153,
        "completion": "\\[(\\d\\d)\\-(\\d\\d)-(\\d\\d)]. *",
        "passed": false
    },
    {
        "id": 153,
        "completion": "/(^[0-9]{4}|[1-3][0-9]|4[0-9])(\\/([1-9][0-9])",
        "passed": false
    },
    {
        "id": 153,
        "completion": "r'^[0-9]{4}[-/.][0-9]{2}[-/.]1\\d{2}\\d{2}$",
        "passed": false
    },
    {
        "id": 153,
        "completion": "\\d\\d\\d\\/\\d\\d\\/\\d\\d",
        "passed": false
    },
    {
        "id": 153,
        "completion": "^\\((0[1-9]|[12][0-9]|3[01])/(1[0123])/(\\d{1,2})([-",
        "passed": false
    },
    {
        "id": 153,
        "completion": "[a-zA-Z]{40}\\d{1,2}{a-zA-Z]{11}",
        "passed": false
    },
    {
        "id": 156,
        "completion": "The regular expression \"^(^[\\d] \\d* \\. \\d{0,5})?$\"",
        "passed": false
    },
    {
        "id": 156,
        "completion": "^[+\\-]?\\d{5,3}.{+\\-}\\d{0,4}.\\d?$",
        "passed": false
    },
    {
        "id": 156,
        "completion": "\\(\\d+\\.?\\d{0,3}\\)\\d+",
        "passed": false
    },
    {
        "id": 156,
        "completion": "([^0-9]*|0[^0-9]*[1-9]|1[0-9]*[2-9]|2[0-8]|32[0-9])",
        "passed": false
    },
    {
        "id": 156,
        "completion": "[^.]5[0-9]{,3}$",
        "passed": false
    },
    {
        "id": 156,
        "completion": "^[0-9]+(0\\.[0-9]{0,1})?$|^[0-9]+(0\\.[0-9]{0,4})?$|^[0-9]+(0\\.[0-9]{0,6})?$|^[0-9]+(0\\.[0-9]{0,8})?$",
        "passed": false
    },
    {
        "id": 156,
        "completion": "0[1-9]",
        "passed": false
    },
    {
        "id": 156,
        "completion": "[0-9]{0,4}\\.?$|^[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,5}$",
        "passed": false
    },
    {
        "id": 156,
        "completion": "([1-9]\\d{6,3})",
        "passed": false
    },
    {
        "id": 156,
        "completion": "0\\.{6,3}",
        "passed": false
    },
    {
        "id": 158,
        "completion": "HelloWorld",
        "passed": false
    },
    {
        "id": 158,
        "completion": "Hello,Youre a great name.",
        "passed": false
    },
    {
        "id": 158,
        "completion": "If you dont want to use the @@ change the @ to whatever the characters you want.Generate a RegEx for this description. Example: regrex : @Name\\bwill return all the names that begins with the letter 'Name' and ends with a Space.",
        "passed": false
    },
    {
        "id": 158,
        "completion": "If you dont want to use the @@ change the @ to what ever characters you want.The regex will be generated from @",
        "passed": false
    },
    {
        "id": 158,
        "completion": "@@@@*Generated by:/usr/include/generator.h",
        "passed": false
    },
    {
        "id": 158,
        "completion": "import retext = '@This is a test@.Another test... and a test!@'regex = re.compile('@(This|This is|This is a test|This is a test...)@')for line in text.split('\\n'):",
        "passed": false
    },
    {
        "id": 158,
        "completion": "This answer contains the python code that generates the RegEx. This answer is generated using Django and you have to copy it to your template and then to a view as follows:from django import templateregister = template.Library()",
        "passed": false
    },
    {
        "id": 158,
        "completion": "@@@Name@@''",
        "passed": false
    },
    {
        "id": 158,
        "completion": "",
        "passed": false
    },
    {
        "id": 158,
        "completion": "@[{@,@%=?^&_~;`\"]*@\"`\".",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer:  ^strFirstName(?:Name)?)$",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: ^([A-Z][a-z]*)([A-Z][a-z]*)([A-Z][a-z]*)$",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: ~^str[A-Z][A-Za-z0-9_.-]*$~",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: str.length() <= 30 || /^FirstName-$/;",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: strFirstName = (^[A-Za-z][A-Za-z0-9 ]*)",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: /(\\w+)\\s(\\w+)\\s(\\w+)\\s\\b((\\w+)$)/",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: ^(?P<strFirstName>(?<=[A-Z])([a-z])|[a-z]+)[a-z0-9$ -]*$This expression was developed to match Camel cased words within a Camel cased variable name. So it will match '[FirstName]' and 'Name' within'strFirstName'.Generate",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: \\w*[\\s-][\\w]+[\\s-][\\w]+",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: @([a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)?)$",
        "passed": false
    },
    {
        "id": 161,
        "completion": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within'strFirstName'.Generate a RegEx for this description. Answer: ^FirstName(.*?)([Ss]t)([r]r)(0[1-9]|1[0-2]):(\\\\d*)$",
        "passed": false
    },
    {
        "id": 162,
        "completion": "\\d*([eE][+\\-]?\\d+)?.",
        "passed": false
    },
    {
        "id": 162,
        "completion": "^\\d+(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 162,
        "completion": "[0-9]+.1\\.[0-9]{1,}",
        "passed": false
    },
    {
        "id": 162,
        "completion": "\"\\d+[.]\\d+?\"",
        "passed": false
    },
    {
        "id": 162,
        "completion": "\\d+|[\\d.]+[eE][+-]?\\d+",
        "passed": false
    },
    {
        "id": 162,
        "completion": "\\d+(\\.\\d+)?3. Use the following list of numbers to find the total weight of apples in kilograms: [0.3, 0.2, 0.5, 0.1, 0.4, 0.6]. Parse each item into a float, use a loop to sum the numbers, and print the result.Answer: 0.5",
        "passed": false
    },
    {
        "id": 162,
        "completion": "?(\\d+)(\\.\\d+)?2. Create a Python function that takes a string parameter and a RegEx object. The function returns all the email addresses found in the string using the RegEx.Generate a RegEx for this description. Answer: def find_emails(text, regex):           emails = re.findall(regex, text)           return emails3. Generate RegEx for this Description",
        "passed": false
    },
    {
        "id": 162,
        "completion": "re.pattern = r'^-?(?:0|[1-9]\\\\d*\\\\.)?[0-9]+\\\\.(?:e|x)$'",
        "passed": false
    },
    {
        "id": 162,
        "completion": "^\\d+(\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 162,
        "completion": "\\d+\\.\\d{1,2}e[a-zA-Z]{1,2}",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 169,
        "completion": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:$date = &quot;2003-12-03&quot;;if (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)){echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003",
        "passed": false
    },
    {
        "id": 170,
        "completion": "^(.{3}|\\d+).{3}$",
        "passed": false
    },
    {
        "id": 170,
        "completion": "(0|[1-9])(0|[1-9]|[1-2][0-9]|2[0-4",
        "passed": false
    },
    {
        "id": 170,
        "completion": "^(?:(?!0)\\d{1,3}(?!255))+$Demo regex",
        "passed": false
    },
    {
        "id": 170,
        "completion": "(^.{12}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})/$",
        "passed": false
    },
    {
        "id": 170,
        "completion": "([0-9]{1}\\.[0-9]{1}\\.[0-9]{1}\\.[0-9]{",
        "passed": false
    },
    {
        "id": 170,
        "completion": "^(?:(?:\\d[0-9]{2,}\\.){3})\\d{1,3}$What about the",
        "passed": false
    },
    {
        "id": 170,
        "completion": "(?<IPPrefix>^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.",
        "passed": false
    },
    {
        "id": 170,
        "completion": "^(?:[0123456789]|2[13579]?(4[01])?)\\.[0-9]{1}",
        "passed": false
    },
    {
        "id": 170,
        "completion": "^(([0-9]|1[0-9]{2})(\\.[0-9]{1,3}){3}",
        "passed": false
    },
    {
        "id": 170,
        "completion": "(\\d)\\.(d)\\.(d)\\.(^\\d{1,4}$)",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer: @\\$[0-9]{1,}(([0-9]{1,3}(, [0-9]{3})*)|([0-",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer: ^(0|\\.\\d+)?(?:,[0]?\\d{1,5})?(?:,\\d+)?$Explanation:^",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer: ^\\$?0\\d{3}[,\\.]?\\d+$ 0x?$?\\d+00?$?\\d$?",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer: \\$?(([0-9])([0-9]*)(\\.[0-9]*))Code to test:",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer: (?<=^.*)\\$.*\\d{1,3}(,?:\\.\\d*)+($|,?\\.d*)?$",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer:(?<=\\$)(?:\\d(?:\\.\\d|\\,))?(?:[eE][+-]\\d(?:\\.\\",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer:  \"^$([0-9]\\d{0,2}(,\\d{0,3})?(\\.[0-9]{1,2})?",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer:^[0-9,]{0,1}(?:\\.1[0-9,]*)$Expression: \"^[0-9,]{",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer: r\"\\$[0-9\\,\\.]?\\s*?[0-9]?[,\\.]?\\s*?[0-9",
        "passed": false
    },
    {
        "id": 172,
        "completion": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and.0 Keywords: money dollar currencyGenerate a RegEx for this description. Answer: (?:(?<=\\W)\\.\\w*\\.?\\S+)|(?<=\\W)\\.\\d{2,}\\.*|(?<",
        "passed": false
    },
    {
        "id": 173,
        "completion": "%e-%d-%Y",
        "passed": false
    },
    {
        "id": 173,
        "completion": "[0-9]\\d{2}-(0[1-9](|[1-9]\\d))-(17|2)\\.",
        "passed": false
    },
    {
        "id": 173,
        "completion": "[\\d]{2}[-,]?\\d{2}[-,]\\d{4}",
        "passed": false
    },
    {
        "id": 173,
        "completion": "\\b(\\d{2})/(\\d{2})/(\\d{4}\\b)",
        "passed": false
    },
    {
        "id": 173,
        "completion": "r'[0-9]{1,2}\\s[a-zA-Z] \\4{3}'",
        "passed": false
    },
    {
        "id": 173,
        "completion": "dd(\\d)?-\\d\\d-\\d\\d.",
        "passed": false
    },
    {
        "id": 173,
        "completion": "https://www.w3schools.com/html/html_validate_date.asp",
        "passed": false
    },
    {
        "id": 173,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 173,
        "completion": "(\\d{2}|0)[/.-](\\d{1,2})",
        "passed": false
    },
    {
        "id": 173,
        "completion": "^(([0-9]{2}|1[0-2])/(0|[1-9]|1[012]))/(\\d{2})$",
        "passed": false
    },
    {
        "id": 174,
        "completion": "This is permit all decimal number except 3 alphanumeric character[^\\d.-]+",
        "passed": false
    },
    {
        "id": 174,
        "completion": "(?:\\d+)",
        "passed": false
    },
    {
        "id": 174,
        "completion": "regex101.com/r/1u0sDQ",
        "passed": false
    },
    {
        "id": 174,
        "completion": "",
        "passed": false
    },
    {
        "id": 174,
        "completion": "(^.+?[\\d\\w.]{1,6}$|^[^\\w\\s]+(\\w+)$).*?(^.+?[\\d\\w]{1,6}$|^.+?[^\\w\\s]*$).*?",
        "passed": false
    },
    {
        "id": 174,
        "completion": "[0-9]{2}[0-9]{3}[0-9]{0,3}\\\\-?[0-9]{0,2}[0-9]{0,3}\\\\-?[0-9]{0,3}",
        "passed": false
    },
    {
        "id": 174,
        "completion": "1.2  <-->  1.2.                    ^                  $     # 1 to end of string.",
        "passed": true
    },
    {
        "id": 174,
        "completion": "^a[0-9]*.[0-9]*$|^[0-9]+$",
        "passed": false
    },
    {
        "id": 174,
        "completion": "(?i)(?:\\\\d+.?\\\\d*|[^\\\\d\\\\s]+)",
        "passed": false
    },
    {
        "id": 174,
        "completion": "\"\\d+\".",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegExp",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegExp",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 176,
        "completion": "Checks whether the string specified is in the same format as the UK postcode format defined on:http://www.magma.ca/~djcl/postcd.txtIt allows:A = LetterN = NumberAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAAIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.(restriction is set to all-capitals)Generate a RegEx",
        "passed": false
    },
    {
        "id": 183,
        "completion": "/<img[^>]*?([<:alt=\".*\">]?)>/g",
        "passed": false
    },
    {
        "id": 183,
        "completion": "\\&lt;img(a|b|file)(.*?)\\/&lt;/img\\2/\\2/",
        "passed": false
    },
    {
        "id": 183,
        "completion": "^\\s\\S",
        "passed": false
    },
    {
        "id": 183,
        "completion": "&lt;img[^><]*/>",
        "passed": false
    },
    {
        "id": 183,
        "completion": "var regEx = /<a *>(.*)<\\/a>/gi;",
        "passed": false
    },
    {
        "id": 183,
        "completion": "\\w{7,}[^&><>]or\\w{7,}[*=:]Explanation:\\w{7,}    - matches any letter (a-z, A-Z, 0-9) between 7 and 9 characters long. []     - A single character (from the range a-z, A-Z, 0-9, _",
        "passed": false
    },
    {
        "id": 183,
        "completion": "<img\\1 />|^<img\\2 /&gt;$",
        "passed": false
    },
    {
        "id": 183,
        "completion": "",
        "passed": false
    },
    {
        "id": 183,
        "completion": "[@img, <img\\1 />], which replaces the images with <img\\1 />.</li>",
        "passed": false
    },
    {
        "id": 183,
        "completion": "img\\[^A-Za-z0-9\\(\\)]* (?)\\/\\[\\/\\]([^\\/]*)\\/",
        "passed": false
    },
    {
        "id": 184,
        "completion": "([0-9 ]+)",
        "passed": false
    },
    {
        "id": 184,
        "completion": "[0][1-9],[3][0][1-9]| [1, 2][1-4], [5][0][1-9].",
        "passed": false
    },
    {
        "id": 184,
        "completion": "m/0?1[1-9]\\/[0-3]?[1-9]\\/20(.+)\\.([0-3]?)\\/4(.+)/But this doesn't work for the year. So I thought I had to escape the 0 and the 4. But how do i escape the 0, the 9, the 4, the / and the. and still have the correct expression? It also seems that when I use the backslashes, it",
        "passed": false
    },
    {
        "id": 184,
        "completion": "^([3-9] \\d\\d)$|^2-29$|^31$|^360$",
        "passed": false
    },
    {
        "id": 184,
        "completion": "0[1-9]|1[0-2]).The RegEx will match any day of the month. If for some reason your month name is two characters long, you might want to replace 0[1-9]|1[0-2] with 1[0-2]|2[0-9].",
        "passed": false
    },
    {
        "id": 184,
        "completion": ".*?[1-9]\\d?|[1-9]\\d|9(?:\\d\\d) \\d?[1-9]]$",
        "passed": false
    },
    {
        "id": 184,
        "completion": "(0?)?1\\.0-2",
        "passed": false
    },
    {
        "id": 184,
        "completion": "0?..12. What would be the day of the month for August 14, 2008?Answer: August 14, 2008 is a non-leap year3. How would you go about using a regrex statement to parse the date for the current day in a Unix-style shell environment.Answer: (^[01][0-2]|JAN|FEB|MAR|APR|MAY|Jun|Jul|Aug|SEP|OCT|",
        "passed": false
    },
    {
        "id": 184,
        "completion": "\\d(0|[12])[0-9]{3}\\. Match a digit 0-9 at least once. Match the start of the string and an upper or lower case month (0, 1 or 2), and repeat that three digits times.",
        "passed": false
    },
    {
        "id": 184,
        "completion": "[^/m/d01]",
        "passed": false
    },
    {
        "id": 185,
        "completion": "/<li>(.*?)<\\/li>/g",
        "passed": false
    },
    {
        "id": 185,
        "completion": "var match = /#(\\d+|##\\d+)/g;var re = new RegExp(match, 0) // g stands for globalvar text = '#mynum, #mynum2, #mynum'var matches = re.exec(text);if (matches) // loop over the results to get only the first match{    alert('Found'+ matches[1] + '.');}",
        "passed": false
    },
    {
        "id": 185,
        "completion": "function htmlGenerate_Comment_Exclamation_Count_Regex(string){  string = string.replace(\" \", \"+\");  var charList = \"[\\u0060-\\u007B]\";  var countChar=0;  var regex = new RegExp(charList+\"\\\\w{3,}\", \"gi\");  var text = string.replace(regex,\"\").replace(\"[^\\w\\/\\s]\",\"\");  var",
        "passed": false
    },
    {
        "id": 185,
        "completion": "htmlGenerate <input class='input' data-regexp=\".*<(.+?)>(.+?)</(.+?)>.*\"",
        "passed": false
    },
    {
        "id": 185,
        "completion": "^[^>]*(<!--.*? -->.*?>)?$",
        "passed": false
    },
    {
        "id": 185,
        "completion": "<p.class=\"title\"><!-- remove any comments --> {title}</p><p.class=\"summary\"><!-- remove any commented lines --> {summary}</p>",
        "passed": false
    },
    {
        "id": 185,
        "completion": "var x=\"<!---*/'|//><\\/!--></html>\"var xRegExp = /(<|\\!(/[^<>]*?(?:<!|>))*\\>)|(([^<>]*?)<a[^>]*?>(.*?)</a[^>]*)<\\/a[\\s\\S]*>)|(\\/a[^<>]*?>(.*?)</\\/a\\/[^<>]*)<",
        "passed": false
    },
    {
        "id": 185,
        "completion": "var REGEX = /<(?:script|style|iframe)>.*?</\\1>/g",
        "passed": false
    },
    {
        "id": 185,
        "completion": "I used the regular expression function, re.sub(r\"<[^>]*>\", \"\", HTML) which extracts all text from the HTML file, that is before the first comment.",
        "passed": false
    },
    {
        "id": 185,
        "completion": "I had to learn how to use negative lookahead, lookbehind and named groups to generate the correct matching expression. \"\"\"",
        "passed": false
    },
    {
        "id": 187,
        "completion": "(^[a-f]{8}-[a-f]{4}-[a-f]{4}-[a-f]{4}-[a-f]{12})",
        "passed": false
    },
    {
        "id": 187,
        "completion": "(^(?:[^-]*-){0,}\\8[^-]*$)",
        "passed": false
    },
    {
        "id": 187,
        "completion": "(([0-9a-f]{8})+)(-(([0-9a-f]{4})+)(-([0-9a-f]{4})+)(-(([0-9a-f]{4})+)))",
        "passed": false
    },
    {
        "id": 187,
        "completion": "(([0-9a-fA-F]{8,4})-[0-9a-fA-F]{4,4}-[0-9a-fA-F]{4,4}-[0-9a-fA-F]{8}))",
        "passed": false
    },
    {
        "id": 187,
        "completion": "^[A-Fa-f]{8}-([A-Fa-f0-9]{4}-){4}[A-Fa-f0-9]{4}$",
        "passed": false
    },
    {
        "id": 187,
        "completion": "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12,-}",
        "passed": false
    },
    {
        "id": 187,
        "completion": "(?=\\[12(?:\\d\\d){3}\\])\\s*\\[\\d{4}\\]((?:-?[0-9a-f]{8}){3})\\]\\([0-9a-f]{4}\\)(?:-?[0-9a-f]{2}){3}$",
        "passed": false
    },
    {
        "id": 187,
        "completion": "(8-4)(4-4-4-4)(4-4-4-4)+(12-8)",
        "passed": false
    },
    {
        "id": 187,
        "completion": "[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-12 hex characters seperated by dashes.--^ (not optional)",
        "passed": false
    },
    {
        "id": 187,
        "completion": "^([0-9A-FaF]{8})([-0-9A-FaF]{4})([-0-9A-FaF]{4})([-0-9A-FaF]{4})([0-9A-FaF]{12})$2. Validates a string with a single dot. Validate a string with a",
        "passed": false
    },
    {
        "id": 191,
        "completion": "r'[1-9][0-9]\\d|10|11|12|13|14|15|16|[1-3][0-9]|40|41|42|43|44|45|46|47|1,20,31,4,50|1'",
        "passed": false
    },
    {
        "id": 191,
        "completion": "```pythonimport repattern = re.compile(\"^(\\d+)(.+$)$\")```",
        "passed": false
    },
    {
        "id": 191,
        "completion": "(?P<ft>\\d{1,3})([-,.])(?P<in>\\d{1,2})",
        "passed": false
    },
    {
        "id": 191,
        "completion": "r'([^(\\s)]*)(\\s(\\d+))'",
        "passed": false
    },
    {
        "id": 191,
        "completion": "\\d+ inches (where 0 to 9 digits denote any number less than or equal to 100).",
        "passed": false
    },
    {
        "id": 191,
        "completion": "/^[1-9]\\d?[0-9]\\d\\d?$/",
        "passed": false
    },
    {
        "id": 191,
        "completion": "r'^\\d+\\.?\\d*\\s[a-zA-z]\\d*$'",
        "passed": false
    },
    {
        "id": 191,
        "completion": "r'[\\d\\.]+(\\+|-|\\*)\\s*\\d+\\s*(inches)(miles|yards).*?(feet)(inches)'.",
        "passed": false
    },
    {
        "id": 191,
        "completion": "\\d{1,2}[ \\. ]?[ \\d]{1,2}[ \\. ]?\\d{1,2}'        3. Given an input containing a date in \"mm-dd-yyyy\" format, write a regular expression to extract the date in only \"yyyy-mm-dd\" format.Answer: '[0-9]{4}-[0-9]{2}-[0-9]{2}'",
        "passed": false
    },
    {
        "id": 191,
        "completion": "import refeet_match = re.search('\\d{1,2}', feet)inches_match = re.search('\\d{1,2}', inches)print(feet_match.group())  # prints \"1\"print(inches_match.group())  # prints \"2\"",
        "passed": true
    },
    {
        "id": 192,
        "completion": "^(/w|/W|[^&lt;&gt;])+$",
        "passed": false
    },
    {
        "id": 192,
        "completion": "^(/w|/W|[^&lt;&gt;])+$",
        "passed": false
    },
    {
        "id": 192,
        "completion": "(/w|/W|[^&lt;&gt;])+\\r\\n+",
        "passed": false
    },
    {
        "id": 192,
        "completion": "r'^(/w|/W|[^&lt;&gt;])+$'",
        "passed": false
    },
    {
        "id": 192,
        "completion": "/([^&lt;&gt;]+)/(?=&.&gt;.&lt;/)",
        "passed": false
    },
    {
        "id": 192,
        "completion": "(/w|/W|[!~`@#$%^&*()+=|,\\\\\\/\\\\-\\\\:\\\\?\\\\;\\\\<=>\\\\>\\\\/\\\"\\\\^\\\\<>\\\\=\\\\|\\\\.\\\\/])+$",
        "passed": false
    },
    {
        "id": 192,
        "completion": "(.+)",
        "passed": false
    },
    {
        "id": 192,
        "completion": "^(\\/w|/W|[^<&gt;])+$",
        "passed": false
    },
    {
        "id": 192,
        "completion": "^(/w|/W|[^&lt;&gt;])+$",
        "passed": false
    },
    {
        "id": 192,
        "completion": "\\/w|\\W|[^&lt;\\gt;]Explanation:",
        "passed": false
    },
    {
        "id": 197,
        "completion": "\\d{0,2}\\/\\d{2}\\/\\d{4}",
        "passed": false
    },
    {
        "id": 197,
        "completion": "[0-9]{2}\\/[0-9]{4}",
        "passed": false
    },
    {
        "id": 197,
        "completion": "(01/12|02/12|03/12|04|05|06|07/12|08/12|09/12|10/12|11/12|12/12)",
        "passed": false
    },
    {
        "id": 197,
        "completion": "/^(0[1-9]|[12][0-9]|3[01])[0-9]{4}$/",
        "passed": false
    },
    {
        "id": 197,
        "completion": "*(0[1-9]|1[0-2])/(0\\d\\d|-?\\d\\d)\\d\\d\\d*.*",
        "passed": false
    },
    {
        "id": 197,
        "completion": "(\\d{2})/(\\d{2})Exercises 5-10:",
        "passed": false
    },
    {
        "id": 197,
        "completion": "\\b(1[0-2]|0\\d)?/[0-9]{4}Explanation: \\b ensures that the regex starts with a beginning of the string or an existing word. The character class says: (1[0-2]|0\\d)? (Match 1 to 2 or a digit from 0 to 9). The question mark makes it optional. Since we know",
        "passed": false
    },
    {
        "id": 197,
        "completion": "/\\d{1,2}\\/\\d{4}/",
        "passed": false
    },
    {
        "id": 197,
        "completion": "\\b([12][0-9]|1[02])\\/([2][0-9]|[0-2][0-9]|30)$",
        "passed": false
    },
    {
        "id": 197,
        "completion": "[1-2][0-9][0-9]{2}/[1-9]\\d\\d{3}",
        "passed": false
    },
    {
        "id": 202,
        "completion": "NINO Validation (^[A|B])([A-Za-z]{3,7})([A-Za-z]?).",
        "passed": false
    },
    {
        "id": 202,
        "completion": "NINO (\\w{1,3}).{1,2}.NINO (\\w{1,2})(.)\\d{9}(,?)\\d{1,1} (\\d{4})",
        "passed": false
    },
    {
        "id": 202,
        "completion": "N|A|M|N|H",
        "passed": false
    },
    {
        "id": 202,
        "completion": "regEx = \"^[A-D]{1,2}[A-D]$\"; Exercise 2: Write a script that generates a RegEx pattern to check if an email address is valid. Answer: emailPatternMatcher = new RegExp(  \"",
        "passed": false
    },
    {
        "id": 202,
        "completion": "((?=^[ABD]{6}\\d{8})(?=^[0-9A-D]{6})[A-D]{1,4}$|[FMW])(?=^\\d{1,5}[CFM]$",
        "passed": false
    },
    {
        "id": 202,
        "completion": "[^a-zA-Za-z0-9 ]*[a-z0-9]*[AeEe]\\d{2}\\b",
        "passed": false
    },
    {
        "id": 202,
        "completion": "^[A-DN]0[0-9]([A-Z]{1}[0-9]{2})$",
        "passed": false
    },
    {
        "id": 202,
        "completion": "^[A-D][a-d]\\d{2}[a-z]$",
        "passed": false
    },
    {
        "id": 202,
        "completion": "You should add the following modifications to the Regular Expression: First, the NINO should be in uppercase. Second, the Letters that you are permitting should be in uppercase.",
        "passed": false
    },
    {
        "id": 202,
        "completion": "^[A-D]?\\d{1,4}[AC]\\d{3}$",
        "passed": false
    },
    {
        "id": 204,
        "completion": "^[+]?\\d{2}/\\d{2}/[T]+\\d{4}$Gener",
        "passed": false
    },
    {
        "id": 204,
        "completion": "\\d\\d\\/\\d\\d\\/\\d\\d\\d?:\\d\\d:\\d\\d",
        "passed": false
    },
    {
        "id": 204,
        "completion": "^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2",
        "passed": false
    },
    {
        "id": 204,
        "completion": "^\\d{4}[/-](\\d{2}[/-](\\d{4})/\\d{2}",
        "passed": false
    },
    {
        "id": 204,
        "completion": "\\d\\d/\\d\\d/\\d\\d \\d\\d \\d\\d \\d\\d:\\d",
        "passed": false
    },
    {
        "id": 204,
        "completion": "(.{3})([0-12])([0-9]{4})\\s(([0-9]",
        "passed": false
    },
    {
        "id": 204,
        "completion": "^(\\d{4})\\-(\\d{1})\\-(\\d{2})\\ (\\d{1}):",
        "passed": false
    },
    {
        "id": 204,
        "completion": "(?:\\d+)/(?:-[012 ]*)\\d{4}\\s\\s(?:\\d{1,",
        "passed": false
    },
    {
        "id": 204,
        "completion": "(\\d{4})\\s-\\s(\\d{2})\\s-\\s(\\d{4})<|",
        "passed": false
    },
    {
        "id": 204,
        "completion": "\u201c(19\\d\\d\\d\\d\\s)?(0?[1-9])?([\\s",
        "passed": false
    },
    {
        "id": 209,
        "completion": "^(0[1-9]|1[012])\\/(3[01])\\/(19|20)\\d{3}$",
        "passed": false
    },
    {
        "id": 209,
        "completion": "[0-9]{2}\\/[0-9]{2}\\/[0-9][0-9]/\\3[0-9]+[0-9][1-2][0-9]\\/[0-9]{2}\\/[",
        "passed": false
    },
    {
        "id": 209,
        "completion": "A date of format YYYY-MM-DD or MM-DD-YYYY or MM/DD/YYYY may be allowed (although if both MM:DD and YYYY are present, YYYY-MM-DD should be accepted -- though this would make your RegEx quite hard to",
        "passed": false
    },
    {
        "id": 209,
        "completion": "[0-9]{2}\\.[0-9]{2}[\\/ \\-.]?[0-9]{4}",
        "passed": false
    },
    {
        "id": 209,
        "completion": "\\d{1,2}\\s?(?:,?|[ap]\\.?e|\\.?)?[ap]\\d+",
        "passed": false
    },
    {
        "id": 209,
        "completion": "\\d{4}/\\d{2}/(\\d[a-zA-Z]){1,4}\\d{2,2}",
        "passed": false
    },
    {
        "id": 209,
        "completion": "([0-9]{2})/([0-1][0-9]|2[0-9][0-9])/((jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))\\s*((",
        "passed": false
    },
    {
        "id": 209,
        "completion": "m(0)(0)(0)$|m(0)(0)[1-7]$|^m[0-9]$|^m$",
        "passed": false
    },
    {
        "id": 209,
        "completion": "((0[1-9]|1[012])\\/(0[1-9]|[12]\\d|3[01])\\/[12]\\d\\d\\d\\d|01(?:1\\d|[12]\\d|3[01])\\/",
        "passed": false
    },
    {
        "id": 209,
        "completion": "(?P<mmddYYYY>[12]?[0-9]\\d{2}[0-9]/[01]\\d/[04]\\d\\d) or | (?P<mmddYYYY>[01]?[0-9]\\d",
        "passed": false
    },
    {
        "id": 211,
        "completion": "[\\d]{2}[:\\d]{0,2}",
        "passed": false
    },
    {
        "id": 211,
        "completion": "[0-9]|10[0-9]|11[0-2][0-9]|[1-4][0-9]|[5-9]",
        "passed": false
    },
    {
        "id": 211,
        "completion": "%m:%[1-9]\\d?",
        "passed": false
    },
    {
        "id": 211,
        "completion": "((20|1[0-9]|2[0-3])[0-5]|(4[0-9])([-07]|[0-9])[0-9])|((1[0-9]|2[0-2])([3-9]|[1-9][0-",
        "passed": false
    },
    {
        "id": 211,
        "completion": "https://regex101.com/r/0cK9mX/1",
        "passed": false
    },
    {
        "id": 211,
        "completion": "(?P<hours>[01]\\d|0[1-9])-(?P<minutes>[0-5]\\d) (?P<am_pm>[AM|PM])",
        "passed": false
    },
    {
        "id": 211,
        "completion": "/^0[1-9] | 0[0-2]| 1[0-9] | 2[0-3]$/",
        "passed": false
    },
    {
        "id": 211,
        "completion": "(?:^|[1-9][0-9]|1[0-2]):[0-5][0-9]",
        "passed": false
    },
    {
        "id": 211,
        "completion": "hourValidator: /^([01][0-9]|2[0-3])$/;minuteValidator : /^((5[0-9])|0?[0-9])$/;",
        "passed": false
    },
    {
        "id": 211,
        "completion": "\\d{1,2}:\\d{1,2}(:\\d{1,2})?",
        "passed": false
    },
    {
        "id": 212,
        "completion": "\\b\\d{1,2}:\\d{2}(?::\\d+)?(?:AM|PM)\\b",
        "passed": false
    },
    {
        "id": 212,
        "completion": "\\d{1,2}(?:\\d{2})?(?:\\s|[AP]M)?\\s\\d{1,2}\\.\\d{1,2}\\.\\d{4} | \\d?\\d:\\d\\d:?\\d\\d(?:p|am)",
        "passed": false
    },
    {
        "id": 212,
        "completion": "(0?[1-9]|1[012]) [ap]m",
        "passed": false
    },
    {
        "id": 212,
        "completion": "^(1[012]|[012][013-5]) am|pm$",
        "passed": false
    },
    {
        "id": 212,
        "completion": "import repattern = re.compile(r\"(\\d{1,2})([a-zA-Z])\", re.I) # validates 12-hour time in two-digit hours with am/pmmatches = pattern.findall(\"12 AM\")print(matches)",
        "passed": false
    },
    {
        "id": 212,
        "completion": "r'((\\d:)|(AM|PM)) | (\\d) (AM|PM)'",
        "passed": false
    },
    {
        "id": 212,
        "completion": "(example) AM\\s+\\d{1,2}\\s+PM\\s+\\d{1,2}:\\d{1,2}",
        "passed": false
    },
    {
        "id": 212,
        "completion": "^\\s*\\d{1,2}:\\d{2}[-|/][1-5]\\d?$",
        "passed": false
    },
    {
        "id": 212,
        "completion": "\"((1|2)\\d{2}([AP]M))([0-2]?[MD]T)?|(\\d{2}[AP]M){1,2}|((\\d+)\\d{2}([AP]M))(?::(\\d+)(?:\\1)?)\"",
        "passed": false
    },
    {
        "id": 212,
        "completion": "\\d{1,2}(st|nd|rd |th)?\\s?AM\\s?\\w+,\\s?\\d{2,4}[-.]\\d{1,3}[A-Z]M(?:\\s?AM\\s?)?",
        "passed": false
    },
    {
        "id": 217,
        "completion": "@\\w+",
        "passed": false
    },
    {
        "id": 217,
        "completion": "[a-z][A-Z]\"",
        "passed": false
    },
    {
        "id": 217,
        "completion": "^([A-Za-z]+) (\\S+)\\((.*)\\)$",
        "passed": false
    },
    {
        "id": 217,
        "completion": "[A-Z][A-Z][A-Z][ ]",
        "passed": false
    },
    {
        "id": 217,
        "completion": "(.(?=\\b\\w\\w).*)( *)+",
        "passed": false
    },
    {
        "id": 217,
        "completion": "(.+)\\s\\1\\s\\1",
        "passed": false
    },
    {
        "id": 217,
        "completion": "/A[^\\sA][^\\s ]*B|A[^\\sA][^\\s A ]|[^\\sA][^\\s]B",
        "passed": false
    },
    {
        "id": 217,
        "completion": "^([^a-z]*)\\w*$",
        "passed": false
    },
    {
        "id": 217,
        "completion": "\\w+[\\\\w-]*\\w+",
        "passed": false
    },
    {
        "id": 217,
        "completion": "/^[a-zA-Z]{1} +[a-zA-Z]{1}[a-zA-Z]{1}.$/",
        "passed": false
    },
    {
        "id": 222,
        "completion": "SELECT * FROM schedule_validatorWHERE TIMESTAMP_SUBSTRING(\"2022-12-22 11:30:00\", 0, INSTR(\"2022-12-22 11:30:00\", ':') - 1) > 12",
        "passed": false
    },
    {
        "id": 222,
        "completion": "`24[0-2]|3[1-9]|1[012]|",
        "passed": false
    },
    {
        "id": 222,
        "completion": "^\\d{2}:\\d{2}:\\d{2}(\\.\\d+)$",
        "passed": false
    },
    {
        "id": 222,
        "completion": "The answer could be `timeColonRegx` such as time:1234",
        "passed": false
    },
    {
        "id": 222,
        "completion": "import reregex=r\"(\\d{1,2})(:(\\d{1,2}))(\\.\\d+)$\"",
        "passed": false
    },
    {
        "id": 222,
        "completion": "\\|((^|\\|)\\d{1,2}(?:\\|\\d{1,2}(\\|\\d{1,2}))?)",
        "passed": false
    },
    {
        "id": 222,
        "completion": "^([0-1][0-9]|2[0-3]):([0-5][0-9])$",
        "passed": false
    },
    {
        "id": 222,
        "completion": "*([0-2]?[0-9]|[0-1][0-9]):[0-5][0-9]:[0-5][0-9])*\"\"\"hour = re.compile(r\"^([0-2]?[0-9]|[0-1][0-9]):([0-5][0-9]:[0-5][0-9])",
        "passed": false
    },
    {
        "id": 222,
        "completion": "[^:][0-9]:[0-9]:[0-9]",
        "passed": false
    },
    {
        "id": 222,
        "completion": "([0-9]{1,2}):([0-9]{2}:){2}([0-9]{2})",
        "passed": false
    },
    {
        "id": 223,
        "completion": "(\\d+)([01])",
        "passed": false
    },
    {
        "id": 223,
        "completion": "```yaml```expression = \"^[0-3][0-9]\\\\d:\\\\s[0-5][0-9]\\\\.\\\\s\\\\S+\\\\s[0-5][0-9]\\\\.\\\\s[0-5][0-9]$\"",
        "passed": false
    },
    {
        "id": 223,
        "completion": "\\d{1,2}:\\d{2}}(?:(am|pm\\s?)|\\.\\s)",
        "passed": false
    },
    {
        "id": 223,
        "completion": "This expression will allow a time value with 14 and a half minute increments. It will not accept seconds. A possible expression would be '^\\\\d{1,2}\\\\s\\\\d{2,2}\\\\s\\\\d{2}$'.",
        "passed": false
    },
    {
        "id": 223,
        "completion": "\"^(19|20)\\d{2}[-.]\\d{2}[-.]\\d{2}$\"",
        "passed": false
    },
    {
        "id": 223,
        "completion": "^((\\d+)(?:st|nd|rd)?)(?:(\\d+)?)$",
        "passed": false
    },
    {
        "id": 223,
        "completion": "(?<!\\d\\d\\d\\d\\d-)\\d{1,2}.*\\d{1,2}(:\\d+)?",
        "passed": false
    },
    {
        "id": 223,
        "completion": "^00[1-9]?\\.?[0-9]?[2-9]\\.?[0-9]$",
        "passed": false
    },
    {
        "id": 223,
        "completion": "t (\\d{1,2}):(\\d{2})?.(?:AM|PM|AMPM).",
        "passed": false
    },
    {
        "id": 223,
        "completion": "(((\\d{1,3})\\d{1,2})(?:-((\\d{1,2})\\d{1,2})(:\\d{1,5})((am|pm)'))?)",
        "passed": false
    },
    {
        "id": 226,
        "completion": "(\\\\d+)\\\\.\\\\d([a-zA-Z0-9]+)+",
        "passed": false
    },
    {
        "id": 226,
        "completion": "",
        "passed": false
    },
    {
        "id": 226,
        "completion": "\\d{1}(?:\\.\\d)0(?=\\.)",
        "passed": false
    },
    {
        "id": 226,
        "completion": "(?<= )[1-9](?:\\.(?=[1-9]))",
        "passed": false
    },
    {
        "id": 226,
        "completion": "^(0)*(?:\\.\\d+(?:\\.\\d+)?(?:\\.\\d*)?(?:\\.\\d*)?(?:\\.\\d+)?(?:\\.\\d+)?(?:\\.\\d+)?){4}$",
        "passed": false
    },
    {
        "id": 226,
        "completion": "Regex: ^[0-9]+(?:\\.[0-9]*){1,3}$",
        "passed": false
    },
    {
        "id": 226,
        "completion": "/^(0+)?((-\\d+)(\\.\\d+?(e\\+)?(?:\\+|-))+(\\d*))|((-)\\d+\\.\\d+?(e+)?(?:\\+|-))+$/",
        "passed": false
    },
    {
        "id": 226,
        "completion": "",
        "passed": false
    },
    {
        "id": 226,
        "completion": "r'^-?\\d*\\.\\d*\\s(?!$),(?!,$)\\d*$'Exercise 2: Create a function to check if a string matches this RegEx. Answer: def checksum(s):    return bool(re.search(r'^-?\\d*\\.\\d*\\s(?!$",
        "passed": false
    },
    {
        "id": 226,
        "completion": "(-?[0-9]\\.[0-9]+[a-z][0-9a-z][a-z][0-9a-z][a-z])\\.([a-z][a-z0-9])",
        "passed": false
    },
    {
        "id": 228,
        "completion": "[^0-9]\\.?[1-9](?:[0-9]|[1-9]\\.[1-9])?|0[1-9]|[1-9][0-9]",
        "passed": false
    },
    {
        "id": 228,
        "completion": "r'^\\d,?\\d+(\\.\\d+)?$'",
        "passed": false
    },
    {
        "id": 228,
        "completion": "((\\d\\.)?(\\d*\\.)?)?\\s*([^\\d.,])",
        "passed": false
    },
    {
        "id": 228,
        "completion": "[-+]?([0-9]?[0-9].?[0-9])?(\\\\.[0-9]{1,3})?To make it a bit more compact I've written it as (*FAIL)?!((\\\\.[0-9]{1,3})?)",
        "passed": false
    },
    {
        "id": 228,
        "completion": "^\\s*|\\d+(\\.\\d*)?$",
        "passed": false
    },
    {
        "id": 228,
        "completion": "^[2-9]\\d*\\.?\\d*(,\\s*\\d+)?$",
        "passed": false
    },
    {
        "id": 228,
        "completion": "^\\d+(,\\d{1,3})?$",
        "passed": false
    },
    {
        "id": 228,
        "completion": "[0-9]+(.[0-9]+)?\";[a-zA-Z]+:[0-9]+: [0]+;[0-9]+:[0-9]+,(?= *$)|(?<= +$)(?<= - [0-9]+[0-9\\.]): *(?=[0-9]+[0-9]\\.)((0)|[0",
        "passed": false
    },
    {
        "id": 228,
        "completion": "\"^[0-9,]+(?:\\.[0-9]+)?$\"",
        "passed": false
    },
    {
        "id": 228,
        "completion": "(?<![^0-9\\(\\.\\))\\d+(?:,\\d+)?\\.\\d{2,3}",
        "passed": false
    },
    {
        "id": 231,
        "completion": "^[4]\\1*$",
        "passed": false
    },
    {
        "id": 231,
        "completion": "((?:s|n|o)&#227;e&#227;r)",
        "passed": false
    },
    {
        "id": 231,
        "completion": "(?<=\\(|$)\\d+",
        "passed": false
    },
    {
        "id": 231,
        "completion": "s\\d+,\\d+,\\d+,You can try other patterns first like s\\d+-\\d+-\\d+ but it is not correct.RegEx demoAlso you should be able to avoid the + sign in the pattern.You can try s\\s+\\d+,\\s+\\d+ instead, for example (there might be some more correct patterns).RegEx demo",
        "passed": false
    },
    {
        "id": 231,
        "completion": "\\d{1,2}\\s[0-9]{2}\\s[0-9]{4}\\s",
        "passed": false
    },
    {
        "id": 231,
        "completion": "s\\&#27\\;",
        "passed": false
    },
    {
        "id": 231,
        "completion": "rr.{0,3}(\\d|1\\d\\d|2\\d\\d\\d|3\\d\\d\\d|4\\d\\d\\d\\d|5\\d\\d\\d\\d|6\\d\\d\\d\\d\\d|7\\d\\d\\d\\d\\d|8\\d\\d\\d\\d\\d|",
        "passed": false
    },
    {
        "id": 231,
        "completion": "^[05]\\d{7}$",
        "passed": false
    },
    {
        "id": 231,
        "completion": "\\d|\\s?\\d|\\s?|\\d|\\s?",
        "passed": false
    },
    {
        "id": 231,
        "completion": "\\b\\d{1,2}\\s?[-+]?\\d{1,2}\\bS&#227;o numeros s&#227;o requeridos!Generate a RegEx for this description. Answer: \\b\\d{2,3}\\s?[-+]?\\d{2,3}\\bS&#227;o numeros s",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9][",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9]",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9][",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9][",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9]",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9]",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9]",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9]Second",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9][",
        "passed": false
    },
    {
        "id": 234,
        "completion": "Regular expression to match valid UK postcodes.In the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.Details of the rules:First half of postcodeValid formats[A-Z][A-Z][0-9][A-Z][A-Z][A-Z][0-9][0-9][A-Z][0-9][0-9][A-Z][A-Z][0-9]",
        "passed": false
    },
    {
        "id": 235,
        "completion": "^([0-2]?[0-9]|3[01]):(0[0-5]|[6-9])I believe this is quite self explanatory.",
        "passed": false
    },
    {
        "id": 235,
        "completion": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9]){2}$",
        "passed": false
    },
    {
        "id": 235,
        "completion": "/^[0-1]?[0-9]|[2][0-3]?:[0-5][0-9]{2}$/",
        "passed": false
    },
    {
        "id": 235,
        "completion": "#([2][0-3]:[0-9]{2}[0-9]|[2][0-3]:0{1}[0-9]|[2][0-3]:0[",
        "passed": false
    },
    {
        "id": 235,
        "completion": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])(:?s|$)",
        "passed": false
    },
    {
        "id": 235,
        "completion": "^0(?:[0-9]|1[0-9]):[2-5][0-9]$(Note: for hours)or to generate for a data with an hour/min/",
        "passed": false
    },
    {
        "id": 235,
        "completion": "[0-9]{2}:[0-5][0-9]|[2][0-3]:[0-5][0-9] This allows a valid HH:MM date, and HH:",
        "passed": false
    },
    {
        "id": 235,
        "completion": "preg_match('/^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$/i',$string);",
        "passed": false
    },
    {
        "id": 235,
        "completion": "^([2][0-3]\\d|2[0-3]):([0-5][0-9])$",
        "passed": false
    },
    {
        "id": 235,
        "completion": "^([0-1]?[0-9]|24):([0-5][0-9])$",
        "passed": false
    },
    {
        "id": 236,
        "completion": "You could use the regular expression `(?P<day>\\d{1,2})(?P<month>\\d{1,2})[,/]?(?P<year>\\d{4})` for MM/YY, where \\d{1,2} represents single digits followed by a space (to split the date into month and year), {1,2} represents 0 or 1, [,/]? represents an optional comma and slash,",
        "passed": false
    },
    {
        "id": 236,
        "completion": "MM/YY|YY|MM/YY",
        "passed": false
    },
    {
        "id": 236,
        "completion": "The RegEx to validate MM/YY is: mMMy.yy",
        "passed": false
    },
    {
        "id": 236,
        "completion": "",
        "passed": false
    },
    {
        "id": 236,
        "completion": "\\d{4}\\.\\d{2}\\.\\d{2}\\.\\d{4}",
        "passed": false
    },
    {
        "id": 236,
        "completion": "```(?<=\\d{2})/(\\d{4})   (?:(?<=[0-9])\\w|[^\\w\\d])(?[1-9])/\\d{4}```",
        "passed": false
    },
    {
        "id": 236,
        "completion": "\\d{4}-\\d{2}-\\d{2}$",
        "passed": false
    },
    {
        "id": 236,
        "completion": "r\"(\\d{4})/(\\d{2})\"",
        "passed": false
    },
    {
        "id": 236,
        "completion": "r'(20|22)\\d{1,2}': MM",
        "passed": false
    },
    {
        "id": 236,
        "completion": "r'(?<=\\d\\.(\\d\\d))\\(.*\\) (\\d\\d\\/\\d\\d)'",
        "passed": false
    },
    {
        "id": 244,
        "completion": "\\d:\\d+:\\d+ --> HH:MM:SSThanks.",
        "passed": false
    },
    {
        "id": 244,
        "completion": "(?:(?:(?<=[0-9:\\s])(?=(?:[0-9]|[1-9][0-9]|1[0-2]):[0-5][0-9])|)(?=(?:[0-",
        "passed": false
    },
    {
        "id": 244,
        "completion": "\\b([01]?[0-9]|2[0-3]):([0-5][0-9])\\s(?:[0-9]|:)(?:[0-9]|$)\\bNote that '9:' or '",
        "passed": false
    },
    {
        "id": 244,
        "completion": "I believe that the regex must be something like the following:Regex: [0-5][0-9][0-9]:[0-9] [0-5][0-9]",
        "passed": false
    },
    {
        "id": 244,
        "completion": "(60\\s|\\:\\s|\\s-|\\^\\^|^|)",
        "passed": false
    },
    {
        "id": 244,
        "completion": "0(?=^.{4,5}\\s?$)(0\\+?)?60The zero's in the regex aren't to be included in the result. Some clarifications:",
        "passed": false
    },
    {
        "id": 244,
        "completion": "^\\|?[0-9a-zA-Z]{1}-[0-9a-z]{4}-[0-9a-z]{1} ([0-9a-zA-Z]{4}\\s)??:",
        "passed": false
    },
    {
        "id": 244,
        "completion": "\\d{1,2}:\\d{0,2}[a-z]{1}, [a-z]{1,2}, [a-z]{0,3}Example:",
        "passed": false
    },
    {
        "id": 244,
        "completion": "0?[1-9](?:\\d\\d)?:[0-5]?[1-9](?:\\d\\d)?$ Replace with \\1:00,\\2:00,\\3:00,\\4:00,\\5",
        "passed": false
    },
    {
        "id": 244,
        "completion": "\\b((?:[0-9]{2}:\\d{2})\\s+)?(?:[\\+0-9]{1,3}):(?:[0-9]{2}:\\d{2})\\s\\b(?:",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer:public static boolean CurrencyValidator(char[] text,char[] format){    bool ValidText = false;    if (Regex.IsMatch(\"^(?!,)([",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer: \"^\\$([0-9,]+(.[0-9]{1,})?)(?: [$]{0,1}?)?$\"Sample code:public static",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer:var RegexForCurrency = new Regex(@\"^(?P<$1>\\p{L}\\p{Number}:)?(?P<$2>\\d{",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer: ((?<![^0-9.])$|^[^ ]+[ -]?\\d+)(\\,([0-9.]{2})([eE",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer:\\$(\\d+[.,])?[0-9]{0,3}[, ]?[0-9]{0,2}[,]?[0-9",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer:double CVal = CDbl(RegEx.Replace(txtBtnCurrency, \"USD \", \".00\"))",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer: (^[1-9][0-9]*)([,.00])?(E|Ee)$",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer:    Dim regexObj As New Regex",
        "passed": false
    },
    {
        "id": 249,
        "completion": "Expression to handle US currency entry in.NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.Generate a RegEx for this description. Answer: private static readonly Regex USExpression = new Regex(\"^(.*?)(\\\\?(\\\\d*)(\\\\.\\\\d*))?(,000)?$\", Re",
        "passed": false
    },
    {
        "id": 251,
        "completion": "a combination of letters, numbers, and dashes. [Any letter, any number, any dash at least once]",
        "passed": false
    },
    {
        "id": 251,
        "completion": "(at least 1 letter and a number). ```pythonpattern = r\"[A-Za-z0-9]{6}print(pattern)",
        "passed": false
    },
    {
        "id": 251,
        "completion": "(?=.*[a-z])(?=.*[A-Z]).*(?=.*[0-9]).",
        "passed": false
    },
    {
        "id": 251,
        "completion": "^[a-zA-Z0-9]{6}$",
        "passed": false
    },
    {
        "id": 251,
        "completion": "&quot;(\\\\w+){5}\\\\&quot;(\\\\w+){1}",
        "passed": false
    },
    {
        "id": 251,
        "completion": "/^([a-z!@#$%^_`]*)(\\d)[a-z]/",
        "passed": false
    },
    {
        "id": 251,
        "completion": "^[a-zA-Z0-9]{6}$",
        "passed": false
    },
    {
        "id": 251,
        "completion": "\\b[A-Za-z0-9]{6}[A-Za-z]\\b",
        "passed": false
    },
    {
        "id": 251,
        "completion": "[A-z]\\w+\\d|\\d[A-z]\\w",
        "passed": false
    },
    {
        "id": 251,
        "completion": "(\\d+|[a-z])(?=\\s(\\d+|[a-z]))",
        "passed": false
    },
    {
        "id": 255,
        "completion": "[0-9]{3}[- ]?[0-9]{3}[- ]?[0-9]{4}",
        "passed": false
    },
    {
        "id": 255,
        "completion": "/\\(?([2-9]{1})\\)?\\s0?[789]'",
        "passed": false
    },
    {
        "id": 255,
        "completion": "(\\\\d{3})[ - -]?(\\\\d{3})[ - -]?(\\\\d{4})?",
        "passed": false
    },
    {
        "id": 255,
        "completion": "^\\(\\d{3})\\s\\(?\\d{3}\\)?-?\\d{4}-?$",
        "passed": false
    },
    {
        "id": 255,
        "completion": "^(?:\\(\\d{3}\\))?(?:[-] \\d{3}[- ]?){2,5}$",
        "passed": false
    },
    {
        "id": 255,
        "completion": "([0-9]{3} - [0-9]{3} - [0-9])",
        "passed": false
    },
    {
        "id": 255,
        "completion": "((^\\(?[0]\\d{2}\\)?[ 0-9]{3}\\([0-9]{4}[ -]\\d{6}))",
        "passed": false
    },
    {
        "id": 255,
        "completion": "\\(\\d{3})\\s\\d{3}\\s\\d{4}\\-\\d{4}\\-\\d{4}",
        "passed": false
    },
    {
        "id": 255,
        "completion": "\\(\\d{3}\\)\\s\\d{3}\\s\\d{4}|\\(\\d{5}\\)\\s\\d{3}\\s\\d{4}|\\(\\d{3}-\\d{3}-\\d{",
        "passed": false
    },
    {
        "id": 255,
        "completion": "`\\d{3}(\\s|-|\\-|\\s)*\\d{3}(\\s|-|\\-|\\s)*\\d{4}`5)Write a Python script that takes a string as argument and outputs all the phone numbers that are in",
        "passed": false
    },
    {
        "id": 262,
        "completion": "I checked my code the first time, it did not detect the upper case letters, but now I have tested it again, and it did detect them. Also, I removed the if-statement, the function is now tested with three names and three types of capitals (upper, small and small-capitals).",
        "passed": false
    },
    {
        "id": 262,
        "completion": "",
        "passed": false
    },
    {
        "id": 262,
        "completion": "const validate = (data, searchTerm, allowCase) => {  let hasFirstMarks = function() {    return /^M/  }  let hasLastMarks = function() {    return /^L/  }  let allFirstMarks = function() {    return /^[A-Z]/.test(data[0])  }",
        "passed": false
    },
    {
        "id": 262,
        "completion": "function hasName(name) {\r  if (name.split(\" \")[0].match(/^[a-zA-Z ]+$/) === false || name.split(\" \")[name.split(\" \").length -1].match(/^[a-zA-Z ]+$/) === false) {\r    return false;\r  }\r  const the",
        "passed": false
    },
    {
        "id": 262,
        "completion": "var valid = /^\\w+-(\\w+-|\\(\\S+\\))\\w+$/i.test(item.name.title()) || /^\\w\\W+\\w\\W+$/i.test(item.name.capitalize())console.log(\"Valid: \" + valid);",
        "passed": false
    },
    {
        "id": 262,
        "completion": "",
        "passed": false
    },
    {
        "id": 262,
        "completion": "",
        "passed": false
    },
    {
        "id": 262,
        "completion": "function checkNameForm(name, letterCapital = /[A-Z]$/) {    return name[0].toUpperCase() === name[name.length - 1].toUpperCase() && letterCapital.test(name);}checkNameForm('test'); //  true",
        "passed": false
    },
    {
        "id": 262,
        "completion": "",
        "passed": false
    },
    {
        "id": 262,
        "completion": "var pattern = new RegExp(/^.+\\s\\.?$/);",
        "passed": false
    },
    {
        "id": 263,
        "completion": "[1-9][0-9]/[0-9]?[1-9]/[0-9]?[0-9]/[0-9][0-9][0-9][0-9][0-0]",
        "passed": false
    },
    {
        "id": 263,
        "completion": "/[+-]?[0-9]+(?:\\/[0-9]+)?\\/[01]12[0-9][0-9][0-9][0-9]\\S{8}$. So now that we have a great regex, how would that be used with the $ and?, if I wanted to match a start date and an end date without any special rules? Let\u2019s say",
        "passed": false
    },
    {
        "id": 263,
        "completion": "^[1-8](1[0-9]|0[1-9])/[1-9][0-9]/[1-9][0-9]/[1-2][0-9][0-9]$",
        "passed": false
    },
    {
        "id": 263,
        "completion": "Regex: (1(.001)?){24}/(([0-9]{3})/([0-9]{2})/((20[2][0] | 0[2][0])){3})Note: If the range is a couple of days above, you need to change the \"24\" to the number of days after the start date and use \"/(([0-9]{3}",
        "passed": false
    },
    {
        "id": 263,
        "completion": "^\\d{4}-\\d\\d-\\d\\d \\d\\d\\/\\d\\d\\/\\d\\d$",
        "passed": false
    },
    {
        "id": 263,
        "completion": "1/1 | 2/1 | 3/1 |... | 31/12 | 22/12 | 23/12 |... 22/12 | 11/15 | 06/15",
        "passed": true
    },
    {
        "id": 263,
        "completion": "(?:\\w+\\s?\\w+\\s\\w+\\s\\w+\\s\\w+)",
        "passed": false
    },
    {
        "id": 263,
        "completion": "/dd/yyGenerate RegEx",
        "passed": false
    },
    {
        "id": 263,
        "completion": "(1[012])|(23[0-9])|[3][01][0-9]|202[0-9][0-9]|20[0-2][0-9]Now we're going to show you how to use regular expressions in PHP! Here's an example to start you off:<?$regex = preg_quote('-', '/'); preg_match('!\\",
        "passed": false
    },
    {
        "id": 263,
        "completion": "[^0-9] - Check for a character not a number from the start until the end of the string. The output should be something like below. \"1 Jan 2020 11:00:16 AM\" \"1 Jan 2020 11:01:01 AM\" ....etc...",
        "passed": false
    },
    {
        "id": 271,
        "completion": "^\\d{4} [A-Za-z] \\d {1,2}$",
        "passed": false
    },
    {
        "id": 271,
        "completion": "^\\d(\\d\\d\\s)\\d{2}\\s\\w{2}",
        "passed": false
    },
    {
        "id": 271,
        "completion": "^\\d{4}\\s\\d{2}[a-zA-Z]$",
        "passed": false
    },
    {
        "id": 271,
        "completion": "^\\d{4}\\s[ ]{2}\\w{2}$",
        "passed": false
    },
    {
        "id": 271,
        "completion": "^\\d{4}\\s\\s\\d{2}$",
        "passed": false
    },
    {
        "id": 271,
        "completion": "\\b([\\d]{1,2}\\s{1,2}\\w{1})\\b",
        "passed": false
    },
    {
        "id": 271,
        "completion": "\\d{4} \\S {2}[a-zA-z]{2}$",
        "passed": false
    },
    {
        "id": 271,
        "completion": "p\\d\\s\\w{2}\\s\\d{2}",
        "passed": false
    },
    {
        "id": 271,
        "completion": "/^\\d{4}\\.\\s+\\d{2}/g;   Explanation",
        "passed": false
    },
    {
        "id": 271,
        "completion": "([\\d]{4}[\\s]?[\\d])+",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^\\(\\d{3}\\)?[ |",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^([(](?:[0-9]",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^[0-9]{3}",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^(([0-9]{",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^(\\(?[0-9]{",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^((\\(\\s|-)\\d{",
        "passed": false
    },
    {
        "id": 273,
        "completion": "[\\(]{1}[0-",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^\\(?(([0-9]",
        "passed": false
    },
    {
        "id": 273,
        "completion": ".*([\\(]{1}[",
        "passed": false
    },
    {
        "id": 273,
        "completion": "^([(0[0-9]|",
        "passed": false
    },
    {
        "id": 278,
        "completion": "h.mmPossible formats for timezone:E.e.g. Wien:05.20 - Central Europe TimeE.e.g. +05:20 Central Europe TimeE.e.g.",
        "passed": false
    },
    {
        "id": 278,
        "completion": "Pattern:(?<d>\\d{2})\\.(?<H>\\d{2})",
        "passed": false
    },
    {
        "id": 278,
        "completion": "h{0,1}[1-9]\\d{0,2}(AM|PM)",
        "passed": false
    },
    {
        "id": 278,
        "completion": "h:(?P<hours>.{6}) | hh:(?P<minutes>.{2}) | h(?P<milliseconds>[0-9]+)Possible formats of timezone part:",
        "passed": false
    },
    {
        "id": 278,
        "completion": "hh:mm (24-hour clock)h:mm:ss or hh.mmss or hh.mm.ssTime parts can then be used in a RegReEx for the date and time.The",
        "passed": false
    },
    {
        "id": 278,
        "completion": "I need to parse strings such as \"H:05:12pm\" as time object. It gets \"0:05:12pm\" to \"12:05:12pm\" using this pattern:^\\d+",
        "passed": false
    },
    {
        "id": 278,
        "completion": "h hh or h hh:mm hh or h hh:mm:ss or h hh:mm or h hh:mm:ss:mmhttps://gist.github.com/Bjellie",
        "passed": false
    },
    {
        "id": 278,
        "completion": "// for the format \"dd.mm.yyyy\"D_MM_YYYY or D_MM_YY in REGEX_PATTERN// or  for the format \"hh.mm\"",
        "passed": false
    },
    {
        "id": 278,
        "completion": "hh:mm (6 hours, 30 minutes) | hh:mm:ss (3 hours, 30 minutes and 54 seconds) |DD.MM.YYYY (d.m. y.y. like 17",
        "passed": false
    },
    {
        "id": 278,
        "completion": "m:ss or mm:ssD.M:M or D.MM:MW.M:W or W.M:Wm:s or mm:ss or h:mm or hh:mm",
        "passed": false
    },
    {
        "id": 282,
        "completion": "(?:\\d+?)[A-Z]{1,2}\\.\\d+(\\.\\d+)+",
        "passed": false
    },
    {
        "id": 282,
        "completion": "c-pnj [0-9][0-9][0-9][0-9][0-9][0-9][0-9]",
        "passed": false
    },
    {
        "id": 282,
        "completion": "\\([A-Z0-9]+[\\.\\b]?[A-Z]\\d{4}\\b\\s*)",
        "passed": false
    },
    {
        "id": 282,
        "completion": "[a-z].*[0-9] {2}[a-z].*[0-9]{2}[a-z].*[0-9].*[1-5] (where [A-Z] is a character class to denote a capital character).",
        "passed": false
    },
    {
        "id": 282,
        "completion": "\\d{3}[R-Z]{1}[A-Z]{2}\\d{4}",
        "passed": false
    },
    {
        "id": 282,
        "completion": "/([a-9])(\\d{4})-(\\2\\d{4})-(\\d{2})-(\\d{2})$/",
        "passed": false
    },
    {
        "id": 282,
        "completion": "\\b[A-C]{1}[0-9]{12}\\b",
        "passed": false
    },
    {
        "id": 282,
        "completion": "(r'^[A-Z]{4}[0-9]{2}[\\d]{3}[\\d]{4}$')",
        "passed": false
    },
    {
        "id": 282,
        "completion": "\\w \\d \\w \\d \\d",
        "passed": false
    },
    {
        "id": 282,
        "completion": "^\\w+\\[(\\d{2})\\] (\\d{9}) ([^\\]]+)$",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer: YMMDD, YYYY",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer: [2018|1919|2021|2022|2300|2400|2501|2510|2601|2610|2701|2710|2801|2810|2901|2911|3010|3010 |3011] or year must be between",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer: [1-9][0-2]?[0-9]",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer:(^|(?<=\\.))\\d{4}(?=(\\s\\S+\\s\\S+))Description:",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer: \\d\\d\\d? (yyyy) YYYY.",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer:(0|1[01]){2}[0-9]{2}(y|$)",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer: (?!(\\d{4}-01))(?!(20([0-3][0-9])|21[0-2]))(?!2([0-4][0-9]|49)|4[0-9]|9(0{3})|10))",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer: YY([0-2][0-9])",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer:(?<=\\b\\d{4}\\b)(0?[1-9]|1[012])\\b",
        "passed": false
    },
    {
        "id": 285,
        "completion": "Date expression validator with format YYMMDDValidates leap years.Of course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years!Generate a RegEx for this description. Answer: ^(18|19)(0[3-9]|[1-2][0-9]|[1-2][0-3]):(0[1-9]|[12][0-9])(\\.[0][1-9]|1[0-",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself in",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself,",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "passed": false
    },
    {
        "id": 287,
        "completion": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.comSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself (",
        "passed": false
    },
    {
        "id": 288,
        "completion": "function formatExpression({value: number, exponent: integer, decimalPoint: string.numberString}) {    var exponentString = '';    if(exponent) {        var exponentString += exponent.split('.')[1];    }    return (exponentString + '^(' +value.toFixed(decimalPoint) +')')}",
        "passed": false
    },
    {
        "id": 288,
        "completion": "",
        "passed": false
    },
    {
        "id": 288,
        "completion": "^-?([0-9]{1,2})(,([0-9]{1,2}))?(\\.([0-9]{1,2})?)?$",
        "passed": false
    },
    {
        "id": 288,
        "completion": "\\\\b[1-9]\\\\d{0,2}\\\\b or \\\\b[1-9]\\\\d\\\\.\\\\d{0,2}\\\\b",
        "passed": false
    },
    {
        "id": 288,
        "completion": "if (numbers) {    valueString = numbers.nextInt(\"1\"+numbers.nextInt(\"9\")).toString().trim()+numbers.nextInt(\"0\"+numbers.nextInt(\"9\")).toString().trim()+numbers.nextInt(\"9\"+numbers.skip(1)).toString().trim();} else {    valueString =  \"",
        "passed": false
    },
    {
        "id": 288,
        "completion": "\\b[0-9]+(,\\.([0-9]{0,1}))?.\\b",
        "passed": false
    },
    {
        "id": 288,
        "completion": "",
        "passed": false
    },
    {
        "id": 288,
        "completion": "pattern = '\\'(?P<decimals>\\d+\\.+)\\'|\\'(?P<deciseness>\\/|,)\\s+\\'(?P<float>.*)\\'|\\'(?P<integer>.*)\\' '",
        "passed": false
    },
    {
        "id": 288,
        "completion": "\\b([1-9]\\d*|1\\d\\d|10)\\b,",
        "passed": false
    },
    {
        "id": 288,
        "completion": "# generate a regex for a number that is a multiple of 3 and has at least two digits, up to 20 digits, and can optionally have a decimal point. - \"^(3\\d{2,20})(,([3-9]\\d+))?$\"    # match the first capturing group    pattern = \"^\" + re.escape(r\"(3)\\d{2,20}(,([",
        "passed": false
    },
    {
        "id": 289,
        "completion": "([+-])((\\b[\\d].*?)\\b)",
        "passed": false
    },
    {
        "id": 289,
        "completion": "^(([+-])?(0|\\d)i?(0|\\d)$",
        "passed": false
    },
    {
        "id": 289,
        "completion": "1.25(1-5^x)- 2.5d(2*5^-5)-.1r^9 + b- 2d^3 - 7",
        "passed": true
    },
    {
        "id": 289,
        "completion": "^(0|(\\+|-)[0-9])+$",
        "passed": false
    },
    {
        "id": 289,
        "completion": "\\b(0|[1-9][0-9]*)\\b",
        "passed": false
    },
    {
        "id": 289,
        "completion": "^\\d+$",
        "passed": false
    },
    {
        "id": 289,
        "completion": "([+0-9 ]*[\\d]+|[\\d ]+[+0-9])",
        "passed": false
    },
    {
        "id": 289,
        "completion": "[0-9]+",
        "passed": false
    },
    {
        "id": 289,
        "completion": "1|\\d+\\.?\\d*   ^-?\\d+\\.?\\d*$  ^-?\\d+  ^[0-9]+    ^[+-]?[0-9]{1,3}",
        "passed": true
    },
    {
        "id": 289,
        "completion": "\\d+(, \\d+(, \\d+(, \\d+(\\))?)?)+\\((-?\\d+(, -?\\d+)*)?\\))?",
        "passed": false
    },
    {
        "id": 294,
        "completion": "classname\\s\\w+",
        "passed": false
    },
    {
        "id": 294,
        "completion": "[a-zA-Z0-9._-]",
        "passed": false
    },
    {
        "id": 294,
        "completion": "",
        "passed": false
    },
    {
        "id": 294,
        "completion": "&quot;\\w+\\.(?:Test|Method)\\&quot;, &quot;(\\w+)\\.(?:Test|Method)\\&quot;",
        "passed": false
    },
    {
        "id": 294,
        "completion": "Classname\\b",
        "passed": false
    },
    {
        "id": 294,
        "completion": "&quot;java\\\\.test\\\\.\\\\.Test&quot;",
        "passed": false
    },
    {
        "id": 294,
        "completion": "(?i)^\\w+(?:\\.(?:android|javac))?\\w+",
        "passed": false
    },
    {
        "id": 294,
        "completion": "(test.|java|.)+\\.+)(com|org|net)$",
        "passed": false
    },
    {
        "id": 294,
        "completion": "(?:\\Q(?P<quote1>\\\\')[^')]*(?:\\Q\\([^(]+\\)[^)]*\\)|\\((?P<quote2>[^(]+)\\))[^)]*\\))([^&#=,]+)",
        "passed": false
    },
    {
        "id": 294,
        "completion": "(?:[a-zA-Z0-9_]|[A-Z][a-zA-Z0-9_]|[0-9][a-zA-Z0-9_]|[a-zA-Z0-9_]{1,})",
        "passed": false
    },
    {
        "id": 295,
        "completion": "public static Regex NameRegex = new Regex(\"[a-zA-Z0-9_.-]*[a-zA-Z]{2,}[a-zA-Z0-9_-]*\");",
        "passed": false
    },
    {
        "id": 295,
        "completion": "C#: /@id[0-9]/; Java: /([a-z][a-zA-Z0-9]+)@/",
        "passed": false
    },
    {
        "id": 295,
        "completion": "\\w{1,5}(?:[a-z]\\.)*",
        "passed": false
    },
    {
        "id": 295,
        "completion": "(^http-equiv\\\\=)(\\\\w*[\\\\w\\-,\\\\]\\\\S*)*('+quote+'(\\\\)\\\\S*)?$",
        "passed": false
    },
    {
        "id": 295,
        "completion": "Matches all words within the description and also matches a word starting with an underscore. Example: 1_2_3",
        "passed": false
    },
    {
        "id": 295,
        "completion": "Regex.Escape(Regex.Escape(...))",
        "passed": false
    },
    {
        "id": 295,
        "completion": "^(?=.*\\d)[a-zA-Z_!@\\$%^&*(.)](?!.*\\s*\\/|\\s+)",
        "passed": false
    },
    {
        "id": 295,
        "completion": "^[a-zA-Z_0-9_]{1,20}$",
        "passed": false
    },
    {
        "id": 295,
        "completion": "",
        "passed": false
    },
    {
        "id": 295,
        "completion": "(?<prefix>.*?)(?<term>.+)$The '?' in your regex will allow 0 or more characters (for example '...'.). The '*?' is a 'greedy', allowing them to be consumed before reaching the end of the string. The '$' at the end, will make sure they complete the entire string, and that a match has been made.So, in your case, the RegEx will be something like this:",
        "passed": false
    },
    {
        "id": 299,
        "completion": "(^[4-5]?[1-9]|[4-9][0-9]|5[1-9]\\d|6[0-4][0-9]|6[5-8][0-9]|7[0-6",
        "passed": false
    },
    {
        "id": 299,
        "completion": "(a)[+\\s]?\\(?[1-4][0-9]{3}\\)?[+\\-\\s]?\\(?[5-5][0-9]{2}\\)?[+\\-\\s]?\\(?[6\\",
        "passed": false
    },
    {
        "id": 299,
        "completion": "(^\\s{4}\\s?\\s{4}\\s?\\s?\\s?\\d{4}\\s?\\s?\\d{4}\\s?-\\d{4}\\s?-\\d{4}\\s?-\\d{4",
        "passed": false
    },
    {
        "id": 299,
        "completion": "/^(?:\\s|-)?\\d{4}-(?:\\s|-)?\\d{4}-(?:\\s|-)?\\d{4}$/i2. What method can be used to extract data from a string?Answer:.",
        "passed": false
    },
    {
        "id": 299,
        "completion": "[\\d\\s]{4}\\s[\\d\\s]{4}\\s[\\d\\s]{4}\\s[\\d\\s]{4}",
        "passed": false
    },
    {
        "id": 299,
        "completion": "^[0-9()][A-Z 0-9()-]{13,}$",
        "passed": false
    },
    {
        "id": 299,
        "completion": "(?=(([0-9]{4}[\\-]?[0-9]{4}[\\-](?!\\+)\\d*[0-9]{4}))*((\\d)[\\+]?)([\\+]?:[0-6]",
        "passed": false
    },
    {
        "id": 299,
        "completion": "(4[0-9][ -\\-]4[0-9][ -\\-]4[0-9]$|4[0-9][ -]4[0-9][ -]4[0-9]$|4[0-9][ -]4",
        "passed": false
    },
    {
        "id": 299,
        "completion": "^((?:(?:4[\\d]|(?:30)\\d|(?:3[0-1])\\d|200)\\d|0[\\d]|1[0-9]|2[0-9]|3[0-1]|4",
        "passed": false
    },
    {
        "id": 299,
        "completion": "card=\"^4[6][4-4-4]5$\",",
        "passed": false
    },
    {
        "id": 300,
        "completion": "-?\\\\d+(,\\\\d+)?(?: \\\\.\\\\d+)?",
        "passed": false
    },
    {
        "id": 300,
        "completion": "/[-+]?\\d*\\.?\\d+/,Generate the Regex",
        "passed": false
    },
    {
        "id": 300,
        "completion": "([\\d.]+)",
        "passed": false
    },
    {
        "id": 300,
        "completion": "[0-9]{1,}  (?:\\.[0-9]{1,})?",
        "passed": false
    },
    {
        "id": 300,
        "completion": "\\d+(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 300,
        "completion": "^-?\\d+(?:,\\d+)?$.*",
        "passed": false
    },
    {
        "id": 300,
        "completion": "^[0-9+\\-\\/\\*\\/%]*$",
        "passed": false
    },
    {
        "id": 300,
        "completion": "1+(?:\\.\\d+(?:\\.\\d{1,2})?),",
        "passed": true
    },
    {
        "id": 300,
        "completion": "(?<!\\()[0-9]+(?:\\.\\d+)?(?:(?:\\.\\d+)?(?:\\.\\d+)?)?(?!\\))Example uses:C#        MatchMatch  = Regex.Matches(value,@\"\\((?<!\\()[0-9]",
        "passed": false
    },
    {
        "id": 300,
        "completion": "\\b-?\\d+(\\.\\d+)?\\b",
        "passed": false
    },
    {
        "id": 308,
        "completion": "",
        "passed": false
    },
    {
        "id": 308,
        "completion": "[^\\r\\n]",
        "passed": false
    },
    {
        "id": 308,
        "completion": "<input type=\"text\" name=\"name\" max-length=50, newline=\"\\n\">",
        "passed": false
    },
    {
        "id": 308,
        "completion": "[Regex required]",
        "passed": false
    },
    {
        "id": 308,
        "completion": "length = [max(9, 200) to 9999]",
        "passed": false
    },
    {
        "id": 308,
        "completion": "I can generate a Regex to prevent a line from being longer than 256 characters.textbox = $(\"input:focus\").val()",
        "passed": false
    },
    {
        "id": 308,
        "completion": "[^\\n:]+[ \\t]+",
        "passed": false
    },
    {
        "id": 308,
        "completion": "%{$myTextBox:<50}4. Create a function which generates a list of words based on the text data in a list and prints all the words in the list.5. Modify the text generator application, so it uses functions instead of creating functions individually for every new text.",
        "passed": false
    },
    {
        "id": 308,
        "completion": "This code generates code that contains a textbox, a limit on the number of characters and generates a RegEx for this description.",
        "passed": false
    },
    {
        "id": 308,
        "completion": "The best way to store user input is to get the text from the input box and store it as a string. Create a new string variable that stores the text string that was entered. Check to see if the length of the string is larger than the specified limit. If it is, display a message to the user that the limit has been reached and prompt the user to input again. The resulting text string should be stored in the new string variable. In addition, you may",
        "passed": false
    },
    {
        "id": 312,
        "completion": "(\\b[A-Z]{2}(\\D?|[A-Z]{2}\\D?){3}\\b)\\s?\\d{9}\\bDescription:  ^(?:\\b[A-Z]{2}\\D?|[A-Z]{2}\\D?){3}$   PATTERN - (?:\\b[A-Z]{2}\\D?|[A-Z]{",
        "passed": false
    },
    {
        "id": 312,
        "completion": "[^/]+\\.((?P<extension>\\w+)$)|(?P<extension>\\.jpg$)|(?P<extension>\\.gif$)|(?P<extension>\\.ico$)|(?P<extension>\\.js$)|(?P<extension>\\.mp3$)*/",
        "passed": false
    },
    {
        "id": 312,
        "completion": "A file with either the same number of files and rows as the original will be created.- file_1 (2,000 rows) with: a.csv file- file_10 (3,000 rows) with: a.csv file- file_15 (3,000 rows) with: a.csv file",
        "passed": false
    },
    {
        "id": 312,
        "completion": "/^(([A-Za-z0-9-]+(.[A-Za-z0-9-]+)*)(?:/([A-Za-z0-9-]+(.[A-Za-z0-9-]+)*)*)$/",
        "passed": false
    },
    {
        "id": 312,
        "completion": "This will not work...It works only of type 1 and only if the line below it begins with 2 lines. (\\\\d{1,4}\\\\s)+(\\\\d{1,4}\\\\s)[,.]*  Example:123.2234,   2234,   NA,  1,   0.1  123.2234,   2234,   NA,  1,   0.01  123.22",
        "passed": false
    },
    {
        "id": 312,
        "completion": "[a-zA-Z0-9.\\-+\\*\\_\\.^~\\s][a-zA-Z0-9.\\-+\\*\\_\\.^~\\s]{0,10}\\.(a-zA-Z0-9.\\-+\\*\\_\\.^~\\s]{0,10}",
        "passed": false
    },
    {
        "id": 312,
        "completion": "/.*_?(\\(\\d{1,4}\\).*\\.)*(_\\d{3})?_*$/ # or *\\d{2}\\.*?[_](\\d{3})?[_](\\d{3})?[_](\\d{3})$ if there is no period",
        "passed": false
    },
    {
        "id": 312,
        "completion": "// the desired pattern     (?<=^[^]*)(?=\\.)\\w+\\.         \\w+    // word to be matched          (?<=^\\.)    // next whitespace          \\w+    // word to be matched",
        "passed": false
    },
    {
        "id": 312,
        "completion": "#define UNSEEN  (/^[0-9]{8}\\-$/)#define PATTERN \"((?=(?:\". UNSEEN. \")?\" $)\"#define FILENAME(name)   ((?<=^(?&name)).(?<!(?:\\\\\\/\\\\\\/)$))#undef UNSEEN  #undef PATTERN",
        "passed": false
    },
    {
        "id": 312,
        "completion": "^[a-zA-z0-9 \\- ]*((\\+\\d+\\.)(\\+\\d+)?)?[a-zA-z0-9 \\- ]*$If you want that matches files which have any numbers on the end, then it can be rewritten like:^[a-zA-Z0-9 ]*((\\+\\d+.\\+\\d+))?[a-zA-",
        "passed": false
    },
    {
        "id": 315,
        "completion": "([a-zA-z]{0,9}):([0-1]\\d{3})",
        "passed": false
    },
    {
        "id": 315,
        "completion": "\\b(\\d{1,2}):(\\d{2})\\b",
        "passed": false
    },
    {
        "id": 315,
        "completion": "H:\\times.+M",
        "passed": false
    },
    {
        "id": 315,
        "completion": "([0-9]{2})-[0-9]{2}:0[0-5][a-d]:[0-5][0-9]) and (0[0-5][a-d]):[0-5][0-9]",
        "passed": false
    },
    {
        "id": 315,
        "completion": "^(0|1|2|3|4|5|6|7|8|9|10|11|12)\\d{0,2}(:|0{1,2})\\d{0,2}$",
        "passed": false
    },
    {
        "id": 315,
        "completion": "(0[1-9]|[1-2][0-9]|[3-9])[0-9]:(0[1-9]|[1-2][0-9]|[3-9])' ```",
        "passed": false
    },
    {
        "id": 315,
        "completion": "^(?:0{0,1}\\d|1\\d|2[01]):(0{1,2}\\d|1\\d|20)\\s?$Exercise 9:Given the below sample of a sample I am using to parse time based on a colon separator, use a regular expression to parse time from a single string:time=\"10:05:59-06:\\08:\\03:02:34\"",
        "passed": false
    },
    {
        "id": 315,
        "completion": "/[0-9]{2}:[0-9]{2}[T]{2}[/T]?$/i",
        "passed": false
    },
    {
        "id": 315,
        "completion": "(?<HOUR>\\d{2}):?(?<MIN>\\d{2}).",
        "passed": false
    },
    {
        "id": 315,
        "completion": "",
        "passed": false
    },
    {
        "id": 317,
        "completion": "[0]*- To validate the above pattern, replace the REGEX \"\\d{1,}\\d{9}\" with the same pattern, and it will work.",
        "passed": false
    },
    {
        "id": 317,
        "completion": "",
        "passed": false
    },
    {
        "id": 317,
        "completion": "\u02da(\\\\d{2}\\\\.){4}\\\\d{7}$",
        "passed": false
    },
    {
        "id": 317,
        "completion": "https://regex101.com/r/zf4Nz8/3",
        "passed": false
    },
    {
        "id": 317,
        "completion": "^\\+91\\d{11}$",
        "passed": false
    },
    {
        "id": 317,
        "completion": "/^\\+([01]?[0-9]{1,2})\\.[(0]{1,3}\\)\\s*(23|0)\\-\\d{3}$/",
        "passed": false
    },
    {
        "id": 317,
        "completion": "\"^(?=1\\d\\d)\\d{10,11}\\-?1\\d\\d\\d?$\"",
        "passed": false
    },
    {
        "id": 317,
        "completion": "(^[0-9]{11,14}$|^[0-9]{10}[1-8]\\d{1,3}$)",
        "passed": false
    },
    {
        "id": 317,
        "completion": "([[A-Z][0-9]{3}-]{3})",
        "passed": false
    },
    {
        "id": 317,
        "completion": "\\d{3}(?:[-\\. ]|[\\-\\s][0-9]{3})",
        "passed": false
    },
    {
        "id": 318,
        "completion": "(0-19)",
        "passed": false
    },
    {
        "id": 318,
        "completion": "0-19",
        "passed": false
    },
    {
        "id": 318,
        "completion": "^([1-9]|[1-2][0-9]|19)$",
        "passed": false
    },
    {
        "id": 318,
        "completion": "0-19.*",
        "passed": false
    },
    {
        "id": 318,
        "completion": "[1-19]",
        "passed": false
    },
    {
        "id": 318,
        "completion": "\\b(1|2|3-19)\\bExample: The number of apples in a basket is 15.",
        "passed": false
    },
    {
        "id": 318,
        "completion": "\\d[2-9]\\d",
        "passed": false
    },
    {
        "id": 318,
        "completion": "\\b[1-9][0-9]\\b",
        "passed": false
    },
    {
        "id": 318,
        "completion": "[0-19]+",
        "passed": false
    },
    {
        "id": 318,
        "completion": "^[1-9]|20$",
        "passed": false
    },
    {
        "id": 320,
        "completion": "\\b(1[5-9]|[2-9][0-9]{1,2}|100[^_][0-9]{1,2}\\b)\\.",
        "passed": false
    },
    {
        "id": 320,
        "completion": "^([0]?1[0-9][0-9])?$",
        "passed": false
    },
    {
        "id": 320,
        "completion": "(\\d{3}[a-z])\\d\\d\\d",
        "passed": false
    },
    {
        "id": 320,
        "completion": "^(([1-9]\\d|1[0-9]{2}|[2][1-9]\\d|200)\\.){3}([1-9]\\d|1[0-9]{2})$",
        "passed": false
    },
    {
        "id": 320,
        "completion": "(?<![0-9].[0-9])(?![0-9])([0-9]000|[0-9])",
        "passed": false
    },
    {
        "id": 320,
        "completion": "I.E., /^[8-9]\\d{2}(\\.\\d{1,9})?$/",
        "passed": false
    },
    {
        "id": 320,
        "completion": "(\\d{3}[-\\.\\s]??)(\\d{2})",
        "passed": false
    },
    {
        "id": 320,
        "completion": "(?:[-+]?(\\d)\\d{1,2}|\\+\\d)\\d{4,9}This RegEx describes the dutch postal code format. That is:",
        "passed": false
    },
    {
        "id": 320,
        "completion": "\\b(([0-9]{2}[0-9]|[0-9]{3}[0-9]|[0-9]{5}[0-9]))\\b",
        "passed": false
    },
    {
        "id": 320,
        "completion": "\\b0+([a-z]{0,1}[a-9]{1,4}|0[a-9]{3}|1[0-2]",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer:^[0-9]+(\\.\\d+)?$Regex Demo(link to regex)",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer:  [0-9]+(\\.[0-9]?|[0-9]*).*[$]+",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer: ^[0-9]\\.[0-9][0-9]$Where [0-9] matches a number between 0 and 9 and [0-9][0-9] matches two numbersexample 1: 7.99example 2: 7.9999Example 3: 0.0007",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer:  \\d{0,3}\\.?\\d{0,2}(,\\d{3,4})*",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer:^(0-9)|(1[01])*[0-9]\\.[0-9]{1,2}$",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer: [0-9](\\.[0-9]|[0-9])*",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer:(?P<number>\\d+)(\\.?\\d*)?(?P<decimal>[1-9][012])",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer:^[0-9]$|^[0-9]\\.(0[1-9]|1[0-9]|2[0-8])?$",
        "passed": false
    },
    {
        "id": 321,
        "completion": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money relatedfields or decimal fields.Generate a RegEx for this description. Answer: /(?<=\\d\\.)[1-9]|[1-9](?:\\.\\d)/Example:mystr = '123'.split('.')[0]; // 1mystr = '123'.split('.')[1]; // 12",
        "passed": false
    },
    {
        "id": 322,
        "completion": "[insert Regex here]",
        "passed": false
    },
    {
        "id": 322,
        "completion": "'^M'4. Using the generated Regular Expression, write a function named `get_date_from_string()` that takes in a string `date_str` and returns a datetime object if `date_str` is within the proper format.Answer:```pythondef get_date_from_string(date_str):    if re.fullmatch('\\d{4}-\\d{2}-\\d{2}', date_str):        return dat",
        "passed": false
    },
    {
        "id": 322,
        "completion": "\\d{1,4}[ -]\\d{1,4}[ -]\\d{1,4}",
        "passed": false
    },
    {
        "id": 322,
        "completion": "\\A((10,00)?[\\/\\- ]*)([\\/\\- ]*)(\\d{4},\\d{2})\\A",
        "passed": false
    },
    {
        "id": 322,
        "completion": "(5)..*At.*(.+)(.+)",
        "passed": false
    },
    {
        "id": 322,
        "completion": "[0-9]{4}-[0-9]{2}-[0-9]{2}",
        "passed": false
    },
    {
        "id": 322,
        "completion": "[a-z][A-Z][0-9]{4}-[a-z]\\d{3}-[0-9]\\d{3}|[A-Z][a-z]\\d{4}-[0-9]{3}-[a-z]\\d{3}",
        "passed": false
    },
    {
        "id": 322,
        "completion": "A date format validator that requires both year-month and day-hour formats, with optional leading and trailing spaces, to be validated via an input field.",
        "passed": false
    },
    {
        "id": 322,
        "completion": "\"^[a-zA-Z][a-zA-Z0-9_.-]*[a-zA-Z\\./-_]$\"",
        "passed": false
    },
    {
        "id": 322,
        "completion": "\"^(0|[1-9][0-9]|1?[0-9][0-9]|2[0-4][0-9])(st|nd|rd|th)\"",
        "passed": false
    },
    {
        "id": 323,
        "completion": "\\b(?P<hours_past>[0-2]\\d|3)\\s*([AP]M)?:\\s*([1-8]\\d)|(2[0-3])([0-9])(:[0-5]\\d)?$",
        "passed": false
    },
    {
        "id": 323,
        "completion": "^((?:\\d(?:\\.\\d+)?)?|.)*$",
        "passed": false
    },
    {
        "id": 323,
        "completion": "([A-Za-z0-9]{2,})[ ][0-9]{4}[ ](GMT|CST|EST)[ ]([1-2]?[0-9]:[0-5][0-9])(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 323,
        "completion": "[a-z]{4,}\\d{2}\\p{L}{2}\\d{4}",
        "passed": false
    },
    {
        "id": 323,
        "completion": "(\\d+):?Explanation: It matches one digit and it repeats optionally for a min of 0 times.",
        "passed": false
    },
    {
        "id": 323,
        "completion": "[0-9]{5}:[0-9].*:[0-9]",
        "passed": false
    },
    {
        "id": 323,
        "completion": "Time(?P<ts>[0-9a-z]{2}:[0-9a-z ]{2}:[0-9a-z ]{2})",
        "passed": false
    },
    {
        "id": 323,
        "completion": "r\"\\d\\d-\\d\\d-(?:\\d\\d){3}-\\d\\d-\\d\\d-(?:\\d\\d){3}Z\"",
        "passed": false
    },
    {
        "id": 323,
        "completion": "`[0-9]{4}-[0-9]{2}-[0-9]{2}`",
        "passed": false
    },
    {
        "id": 323,
        "completion": "\\b\\s\\d{1,2}\\s\\d{1,2}\\s\\d{4},\\d{4}\\b",
        "passed": false
    },
    {
        "id": 325,
        "completion": "\\x1B\\[[0-9;-]{3}[0-9;-]{3}\\s\\]'",
        "passed": false
    },
    {
        "id": 325,
        "completion": "\\b#([a-fA-Fa-f0-9]{3})([0-9]{0,1})([a-z ]?)?\\b",
        "passed": true
    },
    {
        "id": 325,
        "completion": "<(?<!\\([^\\d\\W]*[Hh]?[Tt]?\\))[RGrPn]{7}[RGBY]*>",
        "passed": false
    },
    {
        "id": 325,
        "completion": "r'#'+ ''.join(['(?P<%s>\\w)' % colorCode[i:i+2] for i in range(0, 6, 2)])",
        "passed": true
    },
    {
        "id": 325,
        "completion": "A match for white (#FFFFFF) will have an alternation of characters like #FFFFFF which has all the 6 characters (6 groups of 3 characters). A match for black (#000000) will have nothing but its 6 characters (6 groups of 3 characters) and the same for red (#FF0000).",
        "passed": true
    },
    {
        "id": 325,
        "completion": "",
        "passed": false
    },
    {
        "id": 325,
        "completion": "The hex code is \\x00 (0x0) for #0000FF and \\xffff (0xffff) for #FFFFFF; so the two regex expressions would be ^#([0-9a-fA-F]{4})([0-9a-fA-F]{4})$ and ^#([0-9a-fA-F]{4})$ respectively",
        "passed": false
    },
    {
        "id": 325,
        "completion": "#[0-9A-Fa-f]{3}|#[0-9A-Fa-f]{6}|#[0-9A-Fa-f]{3}.[0-9A-Fa-f]{2}|#[0-9A-Fa-f]{4}|#[0-9A-Fa-f]{6}|",
        "passed": false
    },
    {
        "id": 325,
        "completion": "",
        "passed": false
    },
    {
        "id": 325,
        "completion": "^([1-9][0-9]|[1-3][0-9]|[4-9][0-9]|100)$",
        "passed": false
    },
    {
        "id": 327,
        "completion": "[DD/MM]{4}[/([A-Z])]{2}/\\d{4}$",
        "passed": false
    },
    {
        "id": 327,
        "completion": "\\b\\d{1,2}\\/\\d{1,2}\\/[A-Z]{4,}\\d{0,3}\\.$",
        "passed": false
    },
    {
        "id": 327,
        "completion": "(\\\\d{2})/(\\\\d{2})(\\\\d{4})",
        "passed": false
    },
    {
        "id": 327,
        "completion": "(?<number>\\d{2}(\\/\\d{1,2}|[^/]*\\b\\/\\d{2}){3})(?<unit>\\S+)(?<string>.+)",
        "passed": false
    },
    {
        "id": 327,
        "completion": "[0-9]{2}-[0-9]{2}-[0-9]{4}",
        "passed": false
    },
    {
        "id": 327,
        "completion": "([^\\/]+)/(\\d{2})/(\\d{2}/\\d{4})",
        "passed": false
    },
    {
        "id": 327,
        "completion": "dm[DD]/[MM]/[AAAA]",
        "passed": false
    },
    {
        "id": 327,
        "completion": "(?:(?!\\d{4}-)|(?![0-9]))(?!\\d)(?:(?!\\d)[a-z]){4,}\\.\\d+$",
        "passed": false
    },
    {
        "id": 327,
        "completion": "\\d{2}/\\d{2}/\\d\\d",
        "passed": false
    },
    {
        "id": 327,
        "completion": "(^\\d{2}/\\d{2}/\\d{4})",
        "passed": false
    },
    {
        "id": 332,
        "completion": "/(.*)(\\d\\.)(\\d+)$/",
        "passed": false
    },
    {
        "id": 332,
        "completion": "(?<=\\d\\d\\.)\\d{0,2}",
        "passed": false
    },
    {
        "id": 332,
        "completion": "x\\d{1,2}\\.\\d{1,2}|x\\d{1,2}\\.[0-9]{1,5}",
        "passed": false
    },
    {
        "id": 332,
        "completion": "\\b\\d{1,2}(?:\\.\\d{0,2})?\\b",
        "passed": false
    },
    {
        "id": 332,
        "completion": "^\\d{1,8}((?:.{0,2}\\d)?)(?:\\.\\d{0,2})$",
        "passed": false
    },
    {
        "id": 332,
        "completion": "^(?=.*\\d|.\\d){0,7}(?:([0-9]\\.[0-9]){,2}|)(?:\\.[0-9]\\.){0,8}$",
        "passed": false
    },
    {
        "id": 332,
        "completion": "Here is my final solution,^\\d{3}\\.\\d{0,2}$",
        "passed": false
    },
    {
        "id": 332,
        "completion": "^[0-9]{1,2}\\.[0-9]{0,2}$",
        "passed": false
    },
    {
        "id": 332,
        "completion": "^([0-9]{2,8})\\.?[0-9]{2,}",
        "passed": false
    },
    {
        "id": 332,
        "completion": "((?:\\d+[^. ]){3}\\d+)\\.Here is a Matched string from the RegEx.",
        "passed": false
    },
    {
        "id": 333,
        "completion": "/^\\A(?:[A-K]|[K-W]|[W-N])(\\d{0,3})([+-]\\d{0,2})(\\d{0,3})$/i",
        "passed": false
    },
    {
        "id": 333,
        "completion": "[AW]\\s[1-9][0-9]\\d{2}",
        "passed": false
    },
    {
        "id": 333,
        "completion": "(A\\d|N\\d|W\\d\\d)\\d",
        "passed": false
    },
    {
        "id": 333,
        "completion": "AKNWWN1E0.",
        "passed": false
    },
    {
        "id": 333,
        "completion": "R/A(K)?N[0-9]$/x",
        "passed": false
    },
    {
        "id": 333,
        "completion": "A-K-N-W \\d\\d-\\d{3}-\\d{2}$3. How many zones should have been preffered in the example above?How would this RegEx description be modified to allow for two zones with this prefix?",
        "passed": false
    },
    {
        "id": 333,
        "completion": "A[KNDW]\\d{1,3}",
        "passed": false
    },
    {
        "id": 333,
        "completion": "73[AKW]?[1-9][0-9]This regex will generate any numbers that fulfill the search criteria. However, it does not work for U.S. Amateur radio call signs. When I run this in the Python module, I get a back",
        "passed": false
    },
    {
        "id": 333,
        "completion": "(A|K|N|W).[0-9]+Z[0-9]{3}",
        "passed": false
    },
    {
        "id": 333,
        "completion": "@[^A-Z][A-K][0-9]{1,2}\\.[0-9]{1,3}",
        "passed": false
    },
    {
        "id": 338,
        "completion": "\\d{1,2}(?:[ -](?=[a-z])|(?<=[a-z])(?:[ -](?!j)[A-Z])|(?<!j)-(?=[a-z])|(?<!j)j)",
        "passed": false
    },
    {
        "id": 338,
        "completion": "(\\w|s|t|a|e|r|i|n|d) **Exercise 4**: Use a RegEx to generate a REGEX to match the \"The Cat in The Hat\" song in the string \"Beat It\". Answer: (The Cat in\\ The Hat)",
        "passed": false
    },
    {
        "id": 338,
        "completion": "(\\b(?:MO|TU|WE|TH|FR|SA|SU|ON|ET|AT|MO|DT|SA)|(?:WE|DT))+",
        "passed": false
    },
    {
        "id": 338,
        "completion": "(\\b)?[a-z]:(?:\\s*{0})?[a-z_][a-z0-9_]*[a-z]?",
        "passed": false
    },
    {
        "id": 338,
        "completion": "(\\d{1}[a-zA-Z]|\\+1[a-zA-Z\\-]{1})",
        "passed": false
    },
    {
        "id": 338,
        "completion": "\\b[a-z]{1,3}\\s\\+\\w{2,2}\\b",
        "passed": false
    },
    {
        "id": 338,
        "completion": "`^W(1|2|3|[4-9])$`",
        "passed": false
    },
    {
        "id": 338,
        "completion": "(\\w+)(\\s+[A-Z]*)(\\s+(of|and|the))3. Search for patterns with the start character, and uppercase in the first word, that match a sentence. Answer: (\\w+)(-*\\s?\\w+)(\\.|\\.\\S|\\w+)(\\s+)",
        "passed": false
    },
    {
        "id": 338,
        "completion": "days=0-31|Mo|Tu|We|Th|Fr|Sa|Su",
        "passed": false
    },
    {
        "id": 338,
        "completion": "\"^|(\\s|\\t)\\w+\\W(.)_\\w+_(\\w+|)\\d(_\\d|(\\d\\d))$\"",
        "passed": false
    },
    {
        "id": 342,
        "completion": "^.*\\d.*$Thanks again!",
        "passed": false
    },
    {
        "id": 342,
        "completion": "@\"^[a-zA-Z0-9\\W\\s]+\\s+[a-zA-Z0-9\\W\\s]*$\"",
        "passed": false
    },
    {
        "id": 342,
        "completion": "^(?!0\\b)[\\w\\s-]*$",
        "passed": false
    },
    {
        "id": 342,
        "completion": "^[\\w.-]+$",
        "passed": false
    },
    {
        "id": 342,
        "completion": "^[0-9a-zA-Za-z_\\-~@#\\$%\\^& *?=\\+,-/:;=\\|\\[\\]\\{\\},]*$",
        "passed": false
    },
    {
        "id": 342,
        "completion": "^\\d+$Example 1: http://www.regexr.com/3d7caExample 2: http://www.regexr.com/33f22",
        "passed": false
    },
    {
        "id": 342,
        "completion": "(^[A-Za-z][A-Za-z0-9_]*)",
        "passed": false
    },
    {
        "id": 342,
        "completion": "\\s([a-zA-Z0-9]+[a-zA-Z0-90-9,.]*)(?:, or ) and I added. to the end of the string to allow more than one comma in the input.",
        "passed": false
    },
    {
        "id": 342,
        "completion": "(?=^\\S+)(?:\\d[a-zA-Z][a-zA-Z0-9]*[a-zA-Z])(\\S+$)",
        "passed": false
    },
    {
        "id": 342,
        "completion": "This would work fine.^(?!.{0}(?:|,)$).*$This would also work but, the output would not be like you want it.",
        "passed": false
    },
    {
        "id": 343,
        "completion": "yyyy-(\\d+)-(\\d+)-(\\d+)\\s+(\\d+):(\\d+):(\\d+)\\s+am/pm$",
        "passed": false
    },
    {
        "id": 343,
        "completion": "\"^[1-9][0-9][1-9][0-9]{3}-([1][0-2])[0-1][0-9][0-3]\\:00AM\\/([1][0",
        "passed": false
    },
    {
        "id": 343,
        "completion": "^([2][0-3]|3[01]) \\d{1,2} \\d{2}:\\d{2}(am|pm)?$http://regexr.com?38j2v",
        "passed": false
    },
    {
        "id": 343,
        "completion": "SET datefmt('%Y-%m-%d H:i:s AM/PM');SET datefmt('%Y-%m-%d');",
        "passed": false
    },
    {
        "id": 343,
        "completion": "(    ^    (?P<FullDate>(?:\\d\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d\\d)-?\\d\\d)    (?P<Hour",
        "passed": false
    },
    {
        "id": 343,
        "completion": "^(0[1-9]|1[0-2])\\/(3[01]|[1-9]|[1-2])\\/(0[1-9]-0?[1-9]|1[",
        "passed": false
    },
    {
        "id": 343,
        "completion": "/^\\d{4}-\\s\\d{1,2}-\\d{1,2} \\d{1,2}:\\d{2}([apm]\\d{2})?$/",
        "passed": false
    },
    {
        "id": 343,
        "completion": "^[0-9]{1,2}\\-([0-9]{2}-){2,4}\\-([1-9]?[0-9])(:[0-5][0-9])?( (?",
        "passed": false
    },
    {
        "id": 343,
        "completion": "\\d{4}(-\\d{2}|\\d{2})\\d{2}([^\\d]|[aeiou][^aeiou]|[aeiou]\\4)",
        "passed": false
    },
    {
        "id": 343,
        "completion": "SELECT           (                   '$date\\s+(\\d{4}-\\d\\d-\\d\\d)\\s+(\\1)\\s+(\\d+:\\d+:\\d+[ -]\\d",
        "passed": false
    },
    {
        "id": 346,
        "completion": "^[AB]{2}[A-T]{2} (\\d|\\w)$",
        "passed": false
    },
    {
        "id": 346,
        "completion": "^[AB]{1}\\w{1}\\w{1}\\w{8}$",
        "passed": false
    },
    {
        "id": 346,
        "completion": "^(?P<h1>(?<!\\.)\\{0,\\}(?<\\w|\\.)(\\d+)(?!\\w){\\})*?$",
        "passed": false
    },
    {
        "id": 346,
        "completion": "^[A-Z]{2}\\,?[A-Z|\\s]{2}\\,?[A-Z|\\s]{2}\\,?[A-Z|\\s]{2}$",
        "passed": false
    },
    {
        "id": 346,
        "completion": "(?=.*AR).(?=.*AS).(?=.*CI).(?=.*CN).(?=.*ES)\"",
        "passed": false
    },
    {
        "id": 346,
        "completion": "\\b(?=[R][D][I][N-Y] | N-Y,\\s[R][D][I][N-Y]|[R][D][I][N-Y]\\b)Explanation:",
        "passed": false
    },
    {
        "id": 346,
        "completion": "([A-Z]{2}\\w){3,}",
        "passed": false
    },
    {
        "id": 346,
        "completion": "\\b[A-Z]{2,}\\b should do it. The \\b before the string means beginning/ending of a word (a word is two or more letters). This validates states/territories in a 2 character uppercase format.",
        "passed": false
    },
    {
        "id": 346,
        "completion": "^([A-Z]{2}|[A-Z]{3}|[A-Z]{4})\\.([A-Z]{2}|[A-Z]{3}|[A-Z]{4})$",
        "passed": false
    },
    {
        "id": 346,
        "completion": "\\b((^[A-Z]{2}\\b)|(([A-Z]{2}),|(\\)|[A-Z]{3}$))* I'm thinking the RegEx can be simplified and be made work, but it doesn't do what it's supposed to at all.",
        "passed": false
    },
    {
        "id": 347,
        "completion": "\\(\\d{3}\\) ###-####",
        "passed": false
    },
    {
        "id": 347,
        "completion": "/^(###) ###-####$/",
        "passed": false
    },
    {
        "id": 347,
        "completion": "[1-6]{3}-([1-9][012]|1[012])[- ](0[1-9]|1[012])",
        "passed": false
    },
    {
        "id": 347,
        "completion": "(\\d{3}-\\d{3}-\\d{4})",
        "passed": false
    },
    {
        "id": 347,
        "completion": "^\\(###) ###-####$",
        "passed": false
    },
    {
        "id": 347,
        "completion": "(\\(\\d{2} \\d{3}\\))\\s?(\\d{3}-\\d{4}-\\d{3})",
        "passed": false
    },
    {
        "id": 347,
        "completion": "(\\d{3})\\s\\1\\s\\2",
        "passed": false
    },
    {
        "id": 347,
        "completion": "(\\d{3})\\s?\\d{3}-\\d{4}\"\"\"",
        "passed": false
    },
    {
        "id": 347,
        "completion": "(###) #?[0-9]{8}-####Description: Phone number with area code in parentheses. The format is \"(###) ###-####\".",
        "passed": false
    },
    {
        "id": 347,
        "completion": "\\(###) ###-\\d{3}",
        "passed": false
    },
    {
        "id": 348,
        "completion": "^\\d{4}(-?\\d{1,2}\\d{1,2})\\s+([1-1]?\\d|24)\\s*(?:P|AM|",
        "passed": false
    },
    {
        "id": 348,
        "completion": "[0-9]{4}\\[0-2]([0-9]{1})?\\[0-23]([0-9]{1})?\\[0-59](",
        "passed": false
    },
    {
        "id": 348,
        "completion": "\\b(19[2-9]\\d|20\\d|21[0-2])[a-z][a-z0-9]{3}\\bor\\",
        "passed": false
    },
    {
        "id": 348,
        "completion": "^(\\d{4})-(\\d{1,2})-(\\d{1,2})-(\\d{1,2})-(\\d{2}):(\\d{2}):",
        "passed": false
    },
    {
        "id": 348,
        "completion": "Date_Time = ^[0-9]{4}-[0-9]{2}|[0-9]{4}|[01]?[0-9]|19",
        "passed": false
    },
    {
        "id": 348,
        "completion": "^(?:(([0-2]\\\\d|3[01])?\\\\d)(-(0[1-9]|1[0-2]))?([\\\\d:\\\\s",
        "passed": false
    },
    {
        "id": 348,
        "completion": "[A-Z]{3}\\d{2}, [KK]\\d{2}(?:\\d{2}|\\d{0,2})\\d{5}, [",
        "passed": false
    },
    {
        "id": 348,
        "completion": "^(0[1-9]|1[012])\\/([1-9]\\d|1\\d\\d|2[0-4])\\/((1[6-9])",
        "passed": false
    },
    {
        "id": 348,
        "completion": "/^([0-9]{4})-([0-9]{2})$/i.",
        "passed": false
    },
    {
        "id": 348,
        "completion": "/((\\d|1[89]|2[01]) /)([0-2]\\d) [(0\\d|[1-9][0-9]|1[012])",
        "passed": false
    },
    {
        "id": 349,
        "completion": "\\d{1,3}$",
        "passed": false
    },
    {
        "id": 349,
        "completion": "0[1-9]99|1[02]",
        "passed": false
    },
    {
        "id": 349,
        "completion": "0-999.",
        "passed": false
    },
    {
        "id": 349,
        "completion": "\\d{3}",
        "passed": false
    },
    {
        "id": 349,
        "completion": "^(0|[1-9]|[1-2][0-9]{2}|[2][0-9]{3}|[3][0-9]{3}|400|800|1000000|10000000)$",
        "passed": false
    },
    {
        "id": 349,
        "completion": "\\d{1,3}(,\\d{3}\\d{4})",
        "passed": false
    },
    {
        "id": 349,
        "completion": "/([0-9]{2}[0-9][0-9])/([0-9]{2}[0-9]{2})/|([0-9]{3}[0-9][0-9][0-9])/(...)/",
        "passed": false
    },
    {
        "id": 349,
        "completion": "\\b[0-9]{1}\\s\\w+\\b",
        "passed": false
    },
    {
        "id": 349,
        "completion": "[0-9](?<!a.|p.|o.|q.|n.|t.|r.|s.)",
        "passed": false
    },
    {
        "id": 349,
        "completion": "^[0-9][0-9][0-9][0-9]$",
        "passed": false
    },
    {
        "id": 350,
        "completion": "r\"([0-3][0-9])([/-])([0-9]{4})\"",
        "passed": false
    },
    {
        "id": 350,
        "completion": "\"^[0-9]{1,2}[A-Z]{3}/[0-9]{4}$\"",
        "passed": false
    },
    {
        "id": 350,
        "completion": "(\\d{4}-\\d{1,2})\\s(\\s\\d{1,2})?",
        "passed": false
    },
    {
        "id": 350,
        "completion": "(?(?P<day>\\d+)?-?\\s?-(?(?P<month>\\w)\\s?-?\\d+)/?)",
        "passed": false
    },
    {
        "id": 350,
        "completion": "([01]?[0-9]?[0-9]-(?:\\.[0-9]{2}){3}|{4})",
        "passed": false
    },
    {
        "id": 350,
        "completion": "/^[0-9][0-9]-[0-9][0-9]-(?P<day>\\d+)??(?P<month>AM|PM)?-(?P<year>\\d{4})?$/",
        "passed": false
    },
    {
        "id": 350,
        "completion": "/^([A-Za-z0-9 -\\/]*)([0-9]{4})/",
        "passed": false
    },
    {
        "id": 350,
        "completion": "/^(?:[1]\\s?|0[1-9]|20)\\d{4}$/",
        "passed": false
    },
    {
        "id": 350,
        "completion": "\\d+[ \\\\/-]\\d{2}\\/\\d{4}",
        "passed": false
    },
    {
        "id": 350,
        "completion": "r'(?P<month>\\s?M)((?P<day_first>\\d+)(?:\\.(?P<day_last>\\d+))?)?(?:\\(?(?P<year>\\d+)))?'",
        "passed": false
    },
    {
        "id": 351,
        "completion": "\\d{4} [A-Z]{2} \\d{2} (?=\\D|$)",
        "passed": false
    },
    {
        "id": 351,
        "completion": "1[2-9][0-9]\\s1[2-9][0-9]\\s[A-Z][2-9][A-Z]",
        "passed": true
    },
    {
        "id": 351,
        "completion": "^[0-9][0-9][0-9][A-Za-z]$",
        "passed": false
    },
    {
        "id": 351,
        "completion": "(?<prefix>\\d{1,2})(?<suffix>[A-D])$Explanation:(?<prefix>)\\d{1,2} - One or two digits(?<suffix>([A-D])$ - a uppercase letter and a digit (end of string)",
        "passed": false
    },
    {
        "id": 351,
        "completion": "[0-9]{4}[ -]?[0-9]{2}",
        "passed": false
    },
    {
        "id": 351,
        "completion": "0[1-9]|[1-9][1-9]|(2[01]|0[1-9]|1[012])[0-9]",
        "passed": false
    },
    {
        "id": 351,
        "completion": "\\d{2}[a-zA-Z]\\d{2}",
        "passed": false
    },
    {
        "id": 351,
        "completion": "^\\d{4}[A-Za-z]{2}$. Here's one example of a match test, with some possible outputs and matching groups. $ perl -lne 'push @matches, \"23A7M41A6\"; print join(\"- \", grep /^\\d{4}[A-Za-z]{2}$/, @matches));' file.txt22-34-61",
        "passed": false
    },
    {
        "id": 351,
        "completion": "*\\b[A-Za-z]\\d{3}[A-Za-z]\\d\\b.",
        "passed": false
    },
    {
        "id": 351,
        "completion": "\\d{3}[-]\\d{4}[a-z]{2}",
        "passed": false
    },
    {
        "id": 353,
        "completion": "(,\\s)",
        "passed": false
    },
    {
        "id": 353,
        "completion": "[, \\s]",
        "passed": false
    },
    {
        "id": 353,
        "completion": ".*",
        "passed": false
    },
    {
        "id": 353,
        "completion": "[^A-Za-z0-9\\S]",
        "passed": false
    },
    {
        "id": 353,
        "completion": "^[^\\s,][^,]*[^\\s,]$",
        "passed": false
    },
    {
        "id": 353,
        "completion": "\\s|,|\\s.",
        "passed": false
    },
    {
        "id": 353,
        "completion": ",\\s",
        "passed": false
    },
    {
        "id": 353,
        "completion": "[,: ;-_][0-9a-zA-Z_]",
        "passed": false
    },
    {
        "id": 353,
        "completion": "\\s,\\s",
        "passed": false
    },
    {
        "id": 353,
        "completion": "(\\s|,)",
        "passed": false
    },
    {
        "id": 354,
        "completion": "```pythonimport calendar",
        "passed": false
    },
    {
        "id": 354,
        "completion": "(^[A-Z]\\s)(\\d{1,2}?\\d?(\\s)(\\d{4",
        "passed": false
    },
    {
        "id": 354,
        "completion": "mm/dd/yyyy",
        "passed": false
    },
    {
        "id": 354,
        "completion": "^([A-J]|JAN|FEB|MAR|APR|MAY|JUN|JUL|A",
        "passed": false
    },
    {
        "id": 354,
        "completion": "\\d\\d([A-JAN-M]|[A-JAN-M]\\s[1]-\\",
        "passed": false
    },
    {
        "id": 354,
        "completion": "(\\\\w|Jan\\\\w|Feb\\\\w|Mar\\\\w|Apr\\\\w|May\\\\w|Jun\\\\w|",
        "passed": false
    },
    {
        "id": 354,
        "completion": "^[a-z][0-9]{3} [a-z]{2}\\s[0-9]{",
        "passed": false
    },
    {
        "id": 354,
        "completion": "Here I did it : ^[A-Z][a-z][0-9]{3}$ {0,2}",
        "passed": false
    },
    {
        "id": 354,
        "completion": "^0[1-9][0-9]|1[0-2]?[0-9]|3[",
        "passed": false
    },
    {
        "id": 354,
        "completion": "(((|janf|feb|mar|apm|mrd|jul|aug|oct|nov|dec)",
        "passed": false
    },
    {
        "id": 355,
        "completion": "(3[0-9][0-9])|(1[6-2][0-9])|(19[1-9])|(20[2-9])",
        "passed": false
    },
    {
        "id": 355,
        "completion": "(?:\\d[ \\t\\n]*(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))",
        "passed": false
    },
    {
        "id": 355,
        "completion": "dd ([0-9]{2}) MMM ([0-9]{2})\\ [0-9]{4}Generator: /[0-9]{2}/ # day number\\s # space\\([0-9]{2}\\) # month  \\ 2 \\  [0-9]{4} # year  /",
        "passed": false
    },
    {
        "id": 355,
        "completion": "\\b\\d{1,2}\\s\\d{2}[yY]\\s\\d{4}\\b (3) Write a Python code that uses the regular expression to validate dates in \"dd/mm/yyyy\" format.Answer:",
        "passed": false
    },
    {
        "id": 355,
        "completion": "^\\d{2} [a-z] \\d{4}$ Exercise 3: Suppose a job posting requires applicants to include a phone number consisting of 10 digits. Write a Regular Expression that validates phone numbers in the format xxx-xxx-xxxx.",
        "passed": false
    },
    {
        "id": 355,
        "completion": "The RE will be [1-9]|0[1-9]|1[012]",
        "passed": false
    },
    {
        "id": 355,
        "completion": "",
        "passed": false
    },
    {
        "id": 355,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 355,
        "completion": "\\b(?P<month>\\d{1,2})\\s(?P<day>\\d{1,2})\\b(?P<year>\\d{4}\\b)```",
        "passed": false
    },
    {
        "id": 355,
        "completion": "[09/01/\\d{4}/\\d{2}]",
        "passed": false
    },
    {
        "id": 356,
        "completion": "\\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\b",
        "passed": false
    },
    {
        "id": 356,
        "completion": "This RE is designed to validate month name without a number or the special character /.",
        "passed": false
    },
    {
        "id": 356,
        "completion": "/\\m{1,2}\\.\\d?[0-9]? /",
        "passed": false
    },
    {
        "id": 356,
        "completion": "https://www.regex101.com/r/jY8hKi/2",
        "passed": false
    },
    {
        "id": 356,
        "completion": "\\d{2}[/-]\\d{2}[/-]\\d{4}",
        "passed": false
    },
    {
        "id": 356,
        "completion": "\\b1{1}2{1}, \\b1\\d{2}\\b, \\b1\\d{1}(?:, \\d{2})+\\b, \\b1\\w{3}\\b \\b1\\w{3}\\b \\b1\\w{2}\\b \\b1\\w{2}\\b \\b1\\w{2}\\b",
        "passed": false
    },
    {
        "id": 356,
        "completion": "[a-zA-Z]+(?:\\s+[0-9]{1,3})(\\\\s*)([a-zA-Z]+)",
        "passed": false
    },
    {
        "id": 356,
        "completion": "\\b(\\w{3,13}\\s?[-\\s]?)(january?|february?|march?|april?|may?|june?|july?|august?|september?|october?|november?|december?)(\\d{1,2})$",
        "passed": false
    },
    {
        "id": 356,
        "completion": "```r'.*\\d(.)?\\s*\\d'.replace('\\w*(?<!\\W)', '\\\\1').replace('(?<!\\\\.)', '\\\\.') + '.*'# Replace the alphanumeric symbols within months list with their respective regexes.```",
        "passed": false
    },
    {
        "id": 356,
        "completion": "\\d{4}\\/\\d{2}\\s\\d{1,2},",
        "passed": false
    },
    {
        "id": 358,
        "completion": "\\b1(00|11)\\d{1,3}\\b",
        "passed": false
    },
    {
        "id": 358,
        "completion": "^1(\\d)\\0*1^",
        "passed": false
    },
    {
        "id": 358,
        "completion": "^[01]{11}$",
        "passed": false
    },
    {
        "id": 358,
        "completion": "^[01]*\\d$",
        "passed": false
    },
    {
        "id": 358,
        "completion": "^1\\d*0+1$",
        "passed": false
    },
    {
        "id": 358,
        "completion": "^(?:\\b1[0-9]*\\.\\d{1}\\b|\\b0[0-9a-fA-F]{1,6}\\b)$",
        "passed": false
    },
    {
        "id": 358,
        "completion": "^[01]*[1]*0*[01]*$",
        "passed": false
    },
    {
        "id": 358,
        "completion": "(?:\\.)\\d{1,3}(?!.)\\d{1,3}(?:\\.)\\d{1,3}(?!.)\\d{1,3}",
        "passed": false
    },
    {
        "id": 358,
        "completion": "(^1[01]|0{0,7})",
        "passed": false
    },
    {
        "id": 358,
        "completion": "^1(0|1)*$Since this question isn't clearly defined you can't know if it's just a regular expression, a method for extracting a substring, or if it's just an example of the question.",
        "passed": false
    },
    {
        "id": 359,
        "completion": "/^\\d{1,2}(JJ|JR)Y$/ # year in's' (or 'j') separated by 'y'",
        "passed": false
    },
    {
        "id": 359,
        "completion": "^([4][0-9]{5}\\d{2}(?:\\.\\d+)?)|([1][6-9]\\d{3}\\d{3})|((19\\d{2}\\d{4})|(19\\d{2}\\d{3}\\d?))$",
        "passed": false
    },
    {
        "id": 359,
        "completion": "^(?=\\\\d{3}(?:100|1000|10000)$)(\\\\d{2})(?=0\\\\d|2[789])(\\\\d{2})?$",
        "passed": false
    },
    {
        "id": 359,
        "completion": "/^[0-9]{4}(?: [0-9]{2} )?\\d{2}[-/ ]?\\d{4}$/",
        "passed": false
    },
    {
        "id": 359,
        "completion": "0%[-\\d].%[-\\d]",
        "passed": false
    },
    {
        "id": 359,
        "completion": "\\d{2}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 359,
        "completion": "https://regex101.com/r/3J8w9H/1Valid Dates:",
        "passed": false
    },
    {
        "id": 359,
        "completion": "([1-9][0-9]|1[012])[/](/([0-9]))?(/(\\+/)?([0-9]))?(\\+/)?([0-9]))([MD]Y[a-z]{3})",
        "passed": false
    },
    {
        "id": 359,
        "completion": "^\\\\d{4}[-\\\\/]\\\\d{2}[-\\\\/]\\\\d{4}$ (all together)EditI edited the answers to match the new requirement, although I'm aware this is probably not what is wanted by some.",
        "passed": false
    },
    {
        "id": 359,
        "completion": ".*\\d{1,2}\\/\\d{1,2}\\/\\d{4}(?:\\s.*\\d{5}|(?:\\s\\d{4}|4\\d{1,2})\\s[12])?$Note the (?:\\s.*\\d{5}|(?",
        "passed": false
    },
    {
        "id": 360,
        "completion": "^[0-9]{5}\\d*\\.\\d?$",
        "passed": false
    },
    {
        "id": 360,
        "completion": "^[0-9]{5}\\.[0-9]{2}$",
        "passed": false
    },
    {
        "id": 360,
        "completion": "xxxx.xxx Now write a regex for it. Now use the regex to validate all these strings. If the validation passes (using Pytest) then do some things with the data and you're done. If it doesn't then you'll need to go back and find a better regex or work something else out, but hopefully you can make it pass.",
        "passed": false
    },
    {
        "id": 360,
        "completion": "^[0-9]{5}\\.[0-9]{2}$",
        "passed": false
    },
    {
        "id": 360,
        "completion": "\\d{5}\\.\\d{2} Exercise 2:  Replace all occurrences of the regular expression in the pattern string with the substitution that the user has provided in the substitution string. Answer:  Replace all occurrences of \\d{5}\\d{2} with num12.345",
        "passed": false
    },
    {
        "id": 360,
        "completion": "^[0x20-0x3F]=(?:\\.[0x200-0x3FF])?\\d{0,3}.\\d{0,2}$Sovar s = \"0.005x0.000\";var expected = \"^[0x20-0x3F]=(?:\\.[0x200-0x3FF])?\\d{0,3}.\\d{0,2}$\";",
        "passed": false
    },
    {
        "id": 360,
        "completion": "*\\d{5}$|\\d{5}\\.\\d*|\\d{5}\\.\\d0*",
        "passed": false
    },
    {
        "id": 360,
        "completion": "\\A\\d{5}\\.\\d{2}$)",
        "passed": false
    },
    {
        "id": 360,
        "completion": "^[5]\\d{2}\\.\\d{2}$",
        "passed": false
    },
    {
        "id": 360,
        "completion": "\\d{5}\\.\\d{2}",
        "passed": false
    },
    {
        "id": 361,
        "completion": "(?#regex).+?\\K\\d{5}(?:\\.\\d{2})?$",
        "passed": false
    },
    {
        "id": 361,
        "completion": "^(0\\.[0-9]{5,2}(,0[012]|[1-9][0-9]{3},0[1-9])?)?$",
        "passed": false
    },
    {
        "id": 361,
        "completion": "^[a-zA-Z][\\w\\d\\s]{4}\\.([0-9][0-9.]{2})$https://regex101.com/r/YwFcwk/8",
        "passed": false
    },
    {
        "id": 361,
        "completion": "r'^[0-9]{0,2}\\.[0-9]{0,2}$'",
        "passed": false
    },
    {
        "id": 361,
        "completion": "[^0].{5,2}",
        "passed": false
    },
    {
        "id": 361,
        "completion": "^\\d{5}\\.\\d{2}$",
        "passed": false
    },
    {
        "id": 361,
        "completion": "-?[0-9]\\d{3}\\.[0-9]{2}",
        "passed": false
    },
    {
        "id": 361,
        "completion": "-?0,5[0-9]), -?0.1,5[0-9]), -?, 0), -)?0.1,5[0-9])",
        "passed": false
    },
    {
        "id": 361,
        "completion": "var regex = new Regex(@\"^[\\d\\.]{5}$|^[\\d\\.]{2,}$\")",
        "passed": false
    },
    {
        "id": 361,
        "completion": "\\\\d{5}\\\\.\\\\d{2}",
        "passed": false
    },
    {
        "id": 362,
        "completion": "`^[a-zA-Z0-9<>?*+._&amp;=|{}\\']+$`",
        "passed": false
    },
    {
        "id": 362,
        "completion": "",
        "passed": false
    },
    {
        "id": 362,
        "completion": "\"^[a-zA-Z+0123456789!@$%\\s\\[\\]\\{\\~\\(\\)_&",
        "passed": false
    },
    {
        "id": 362,
        "completion": "\\(\\*+.>&amp;#*/^-${&lt;;$}&amp;){}~!@\\#}",
        "passed": false
    },
    {
        "id": 362,
        "completion": "r'(?!&lt;&gt;\\s+\\.|\\(|\\)|\\{\\|\\w+\\}|' + [r'",
        "passed": false
    },
    {
        "id": 362,
        "completion": "/^[a-zA-Z0-9&#x2B;]{4,16}$/.^[a-zA-Z",
        "passed": false
    },
    {
        "id": 362,
        "completion": "[a-zA-Z0-9\\!\\@\\#\\}$%:\\;\\(\\)\\\\\\^\\.\\-_=\\+",
        "passed": false
    },
    {
        "id": 362,
        "completion": "",
        "passed": false
    },
    {
        "id": 362,
        "completion": "[^a-zA-Z0-9\\.!@\\#\\$%:;<>{}\\(\\)&^\\*\\+@\\",
        "passed": false
    },
    {
        "id": 362,
        "completion": "^/[\\d\\.\\s-]*$/",
        "passed": false
    },
    {
        "id": 363,
        "completion": "(a|b|c|d|e|f|g|i|o|u|0|1|2|3|4|5)|(0|1|2|3|4|5)|(6|7|8|9))Example: The same site would require a regex with (a|b|c|d|e|",
        "passed": false
    },
    {
        "id": 363,
        "completion": "/(^[0-9]{3,9}[-]?[0-9]{3,9}|[0-9]{3,}[1-9]?)[0-9].[0-9]{2}\\z/",
        "passed": false
    },
    {
        "id": 363,
        "completion": "/#[0-9]+.[0-9]+/",
        "passed": false
    },
    {
        "id": 363,
        "completion": "^(?=.{15}$)(?=.*[a-z])and the regex in Python in that form would be:pattern = r'^(?=.{15}$)(?=.*\\d)\\d{10}$'",
        "passed": false
    },
    {
        "id": 363,
        "completion": "\\b[09][0-9]{10}(?:\\[\\d*\\])?\\b",
        "passed": false
    },
    {
        "id": 363,
        "completion": "/^(?=.*[0-9][5-9])(?=.*[3-9])(?=.*[7-9])(?=.*[0])([0-9]{8})($/im)//",
        "passed": false
    },
    {
        "id": 363,
        "completion": "([(2,4)|(3,5)|(3,6)|(3,7)|(3,8)|(3,9)|(4,0)|(4,1)|(4,2)|(4,3)|(4,4)|(4,5)|(4,6)|(4,7)|(4,8)|",
        "passed": false
    },
    {
        "id": 363,
        "completion": "",
        "passed": false
    },
    {
        "id": 363,
        "completion": "([\\(]([\\s-]*)?\\s)([\\(\\)\\d-]+)([\\))]",
        "passed": false
    },
    {
        "id": 363,
        "completion": "^([01]?[2-9]\\d|[1-9]\\d{1,2})(\\s\\(\\d\\d\\))*$",
        "passed": false
    },
    {
        "id": 364,
        "completion": "r'\\((.+?)'",
        "passed": false
    },
    {
        "id": 364,
        "completion": "(((?:\\d{4}[\\/\\-]\\d{4})|(?:\\d{4}))(?:\\-\\d?\\d?)?)",
        "passed": false
    },
    {
        "id": 364,
        "completion": "(\\d{4})(?:, (\\d{4})?)+",
        "passed": false
    },
    {
        "id": 364,
        "completion": "\\d{4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 364,
        "completion": "\\d{4}\\,\\s\\d{4}\\,\\s\\d{2}",
        "passed": false
    },
    {
        "id": 364,
        "completion": "(\\d{4})```python# The code snippet looks for a comma-separated list of year(s).```",
        "passed": false
    },
    {
        "id": 364,
        "completion": "\\d{4}(?:-\\d{2})?\\.",
        "passed": false
    },
    {
        "id": 364,
        "completion": "\\d{4}\\-\\d{2}\\-\\d{2}",
        "passed": false
    },
    {
        "id": 364,
        "completion": "([0-9]{4})-[0-9]{2}",
        "passed": false
    },
    {
        "id": 364,
        "completion": "[A-Z0-9]{4}(-[A-Z0-9]{3})??[A-Z0-9]{2}(-[A-Z0-9]{1})",
        "passed": false
    },
    {
        "id": 366,
        "completion": "Regex101",
        "passed": false
    },
    {
        "id": 366,
        "completion": "Regex Pattern: ^(12|13)\\d{2}$|^100000$|^(1111|2222|3333|4444|5555|6666|7777|8888|9999|0[0-9]|1[0-2])$",
        "passed": false
    },
    {
        "id": 366,
        "completion": "r^([01\\d]|3\\d[01])[0-9]{6}",
        "passed": false
    },
    {
        "id": 366,
        "completion": "[0-9]{2}[0-9]{2}[A-Za-z]{4,}",
        "passed": false
    },
    {
        "id": 366,
        "completion": "(0)(1)([01])(0*|[01])(0*|1*|2*|3*|4*|5*|6*|7*|8*|9*|0*)$",
        "passed": false
    },
    {
        "id": 366,
        "completion": "^\\d{2}-(0[1-9])\\d{2}-\\d{2}\\d{4}$",
        "passed": false
    },
    {
        "id": 366,
        "completion": "(\\d{8})[-/]\\d{4}[-/]\\d{2} [a-zA-Z]{3}\\-[0-9]{2}",
        "passed": false
    },
    {
        "id": 366,
        "completion": "^(?=(?:.*[0-9]{4}).*(?:.*[0-9]){3}).*\\b(?!0{2})\\d{1,18}$",
        "passed": false
    },
    {
        "id": 366,
        "completion": "String regexPattern =     \"\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d\\\\.\\\\d{4}\";",
        "passed": false
    },
    {
        "id": 366,
        "completion": "^((0[1-9]|1[0-9]|2[0-8])?\\d{3}-){3}[0-9]{4}-(\\d{2}?)-\\d{4}$",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description by",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 367,
        "completion": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 369,
        "completion": "!(?![A-Za-z][A-Za-z0-9_\\\\+\\-\\\\.]*$))",
        "passed": false
    },
    {
        "id": 369,
        "completion": "\\s\\w+\\sExplanation: This expression matches a whitespace character followed by one or more word characters. In our usecase, we're only dealing with C# and C++ identifiers, so this pattern should not match.",
        "passed": false
    },
    {
        "id": 369,
        "completion": "",
        "passed": false
    },
    {
        "id": 369,
        "completion": "\\b([A-Za-z0-9_]\\w*)(\\s*[.,:][A-Za-z0-9_]\\w*)*\\b",
        "passed": false
    },
    {
        "id": 369,
        "completion": "(?![a-zA-Z_0-9]\\w+-)[a-zA-Z_0-9A-Z_]([a-zA-Z_0-9._-])*",
        "passed": false
    },
    {
        "id": 369,
        "completion": "",
        "passed": false
    },
    {
        "id": 369,
        "completion": "(?<![a-z])(?:[a-z0-9]|[0-9][a-z0-9]|[a-z0-9][0-9][a-z0-9]|[A-Za-z][A-Za-z0-9]|[A-Za-z][A-Za-z0-9_]{1,15})|(?<![0",
        "passed": false
    },
    {
        "id": 369,
        "completion": "[a-z][a-z0-9_.-]+",
        "passed": false
    },
    {
        "id": 369,
        "completion": "(?<!\\\\d)[\\w.-]+(?![\\d\\\\^]*$)",
        "passed": false
    },
    {
        "id": 369,
        "completion": "\\A    [a-zA-Z0-9_.]+    [a-zA-Z0-9_.]+    ([a-zA-Z-][a-zA-Z0-9_.]*(?:[a-zA-Z]|\\.[a-zA-Z])[a-zA-Z0-9_.]*)*",
        "passed": false
    },
    {
        "id": 370,
        "completion": "[1346][0-9]How would you do things if you are matching these numbers in multiple chunks for example, for example [1346][0-9][1-4] - that the first number be in this block [1346], then the second number in [0-",
        "passed": false
    },
    {
        "id": 370,
        "completion": "^((1|[2-9])[0-9])+$",
        "passed": false
    },
    {
        "id": 370,
        "completion": ".(?=(?:.*[1346])(?:.*[1-5])\\b).",
        "passed": false
    },
    {
        "id": 370,
        "completion": "/(\\b[1-5]|6))/But not sure if this is more readable then the first one.",
        "passed": false
    },
    {
        "id": 370,
        "completion": "(6|10) [1-9][1-9][1-9][1-9][1-9]Using this RegEx: /6[1-9]$/",
        "passed": false
    },
    {
        "id": 370,
        "completion": "(?i)(?:1|3|4|6|5)(?:-?(?=(1?2|3?[1-9]|[1-9]{0,2}),2?|3?[0-9]|[0-9]))",
        "passed": false
    },
    {
        "id": 370,
        "completion": "^(?:[1346][1-5]|[1-5])(?:\\D*\\d)(?:\\D*\\d)$",
        "passed": false
    },
    {
        "id": 370,
        "completion": "[1346]\\1*?(?=1346)",
        "passed": false
    },
    {
        "id": 370,
        "completion": "^[\\d]*(?:[1-5])[\\d]*(?:0|1|2|3|4|5)$.*?(?:1/2 | 1/4 | 1/8 | 1/16 | 1/32 | 1/64",
        "passed": false
    },
    {
        "id": 370,
        "completion": "\\d(?=[0-9]*1|[0-9]*2|[0-9]*3|[0-9]*)[0-9](?=\\.?|^|$)",
        "passed": false
    },
    {
        "id": 371,
        "completion": "[A-Z]",
        "passed": false
    },
    {
        "id": 371,
        "completion": "^([a-zA-Z]){1}$",
        "passed": false
    },
    {
        "id": 371,
        "completion": "[A-Z]",
        "passed": false
    },
    {
        "id": 371,
        "completion": "[A-Z].{6}",
        "passed": false
    },
    {
        "id": 371,
        "completion": "\\s[a-zA-Z](?:[A-Z]+[a-z]?)*",
        "passed": false
    },
    {
        "id": 371,
        "completion": "[a-zA-Z]{1}",
        "passed": false
    },
    {
        "id": 371,
        "completion": "https://www.freecodecamp.org/community/learn-patterns-with-regexes/match-capitalized-letter",
        "passed": false
    },
    {
        "id": 371,
        "completion": "[A-Z]+[a-z]+ [A-Za-z ]{1}",
        "passed": false
    },
    {
        "id": 371,
        "completion": "",
        "passed": false
    },
    {
        "id": 371,
        "completion": "a-zA-Za-z0-9",
        "passed": false
    },
    {
        "id": 374,
        "completion": "/\\d{1,8}(?:\\.\\d{0,2})*/g<1>",
        "passed": false
    },
    {
        "id": 374,
        "completion": "^[+\\-]?\\d(\\.?\\d\\d)",
        "passed": false
    },
    {
        "id": 374,
        "completion": "-([0-9]{2,}\\,?)?",
        "passed": false
    },
    {
        "id": 374,
        "completion": "^-0(?:\\d+)?(\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 374,
        "completion": "/\\d+(\\.\\d\\d?)*(-?\\d+)?$/",
        "passed": false
    },
    {
        "id": 374,
        "completion": "(?!0{2,2})[0-9]+(?:\\.[0-9]+)+/",
        "passed": false
    },
    {
        "id": 374,
        "completion": "^[-+]?\\d*\\d{0,2}(,\\d{3})*$",
        "passed": false
    },
    {
        "id": 374,
        "completion": "([0-9].{0,2})(\\\\.$|,|,|/|-)([0-9]*)(\\\\d+)",
        "passed": false
    },
    {
        "id": 374,
        "completion": "(^(?!0)[0-9.]+(?!(?:$))|0[0-9.]*(?:\\.[0-9.]*)?$)[0-9]{1,3}(?:,[0-9]{3})*$)",
        "passed": false
    },
    {
        "id": 374,
        "completion": "\\d*\\.\\d\\d[Ee]?\\d{0,2}$",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close of",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close tag",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close?",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close of",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close tags",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close of",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close tags",
        "passed": false
    },
    {
        "id": 381,
        "completion": "HTML Pattern MatchingPLEASE HELP/&lt;[^&gt;]*&gt;/igThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.How do you write a pattern that will pass all these tag so that the pattern will match from the open to the close of",
        "passed": false
    },
    {
        "id": 382,
        "completion": "( &quot; ) ( [0-9]{1,3}[-\\. ]?)? ([0-9]{2}[-\\. ]?)? ([0-9]{4})",
        "passed": false
    },
    {
        "id": 382,
        "completion": "040-000, 0111-0000, 012-0000 or null",
        "passed": false
    },
    {
        "id": 382,
        "completion": "(\\+20\\)|20(1[5-9]?)|20(2[0-9]?)|20[1-9]?)",
        "passed": false
    },
    {
        "id": 382,
        "completion": "^(?:1501)?([0-9]{1,3}\\s)?[0-9][0-9]? - [5-9]\\s?[0-9]{4}$)I hope, that helped you. Just remember - it never hurts to go back to the basics before you jump into something new.",
        "passed": false
    },
    {
        "id": 382,
        "completion": "@prefix([a-zA-Z0-9_]{0,6})+\\-(?:\\[\\d{5}\\]|&quot;-)+@(\\d{3}(\\-\\d{4})?)?[0-9]The following will match in most RegEx situations. @prefix will match",
        "passed": false
    },
    {
        "id": 382,
        "completion": "This link could be used by a company in Italy to add an Italian text to its website. It could be a phone number with local prefixes or any other part of its website.",
        "passed": false
    },
    {
        "id": 382,
        "completion": "(0[47]|[06])/\\d\\.?\\d?(/.|-)",
        "passed": false
    },
    {
        "id": 382,
        "completion": "/^(00\\s[1-9]\\d\\s)*\\.[a-zA-Z]{1,3}$/",
        "passed": false
    },
    {
        "id": 382,
        "completion": "This exercise is more of a research exercise and you may create your own",
        "passed": false
    },
    {
        "id": 382,
        "completion": "\\b(?:/&quot;|-&quot;-&quot;?){7,}[+-](?:\\b(?<numeric1>\\d\\d\\d-)\\d\\d-\\d\\d\\d\\d\\d|\\d\\d\\d-\\d\\",
        "passed": false
    },
    {
        "id": 386,
        "completion": "( [A-Za-z]){3,}The problem: Is it possible to use \"3 or more\" in the middle? I tried to use a quantified character in the middle part ([A-Z",
        "passed": false
    },
    {
        "id": 386,
        "completion": "(.*)(?={1})Description:  (.*)                    (?= {1})I can see from the site a similar explanation for how to construct RegEx for:",
        "passed": false
    },
    {
        "id": 386,
        "completion": "",
        "passed": false
    },
    {
        "id": 386,
        "completion": "^\\d*(?:\\.[0-9]+)?$",
        "passed": false
    },
    {
        "id": 386,
        "completion": "[0-9]*",
        "passed": false
    },
    {
        "id": 386,
        "completion": "[A-z][a-zA-Z][a-zA-Z0-9][a-zA-Z0-9\\s]This may be extended to include numbers",
        "passed": false
    },
    {
        "id": 386,
        "completion": "[A-Za-z0-9]|[0-9A-Za-z]Description: All letters",
        "passed": false
    },
    {
        "id": 386,
        "completion": "'[A-Z0-9\\.\\]\\ ]'Tests for numbers (0-9)( posted from WebService - http://regexlib.com/webservices.asmx",
        "passed": false
    },
    {
        "id": 386,
        "completion": "[A-Za-z0-9_]+Description: match any character between a single alphanumeric (uppercase or lowercase)  or _ (underscore) (only one in your string)",
        "passed": false
    },
    {
        "id": 386,
        "completion": "(^[\\w.]*$|^[A-Z][A-Za-z][A-Za-z0-9.-]*$) You are correct! Great job, and",
        "passed": false
    },
    {
        "id": 392,
        "completion": "/(^| \\s+ )http://aspalliance.com/[12-9][0-9][0-9]\\.aspx?",
        "passed": false
    },
    {
        "id": 392,
        "completion": "/\\b\\/(?:m|(?:article|image)|(?:image|image\\/))\\/\\/(?:123|(?:article|image|image\\/)|(?:article|image\\/)|(?:article|image\\/)/)",
        "passed": false
    },
    {
        "id": 392,
        "completion": "https://aspalliance.com\\/([0-9]+).aspx$",
        "passed": false
    },
    {
        "id": 392,
        "completion": "[0-9]+The best regex of all seems to be /(?:\\[(?:[0-9]+\\/)|\\])+$/.This pattern will catch requests to AspAlliance.com that doesn't have a",
        "passed": false
    },
    {
        "id": 392,
        "completion": "\\bAspAlliance\\.com\\.[\\d]{3}\\b",
        "passed": false
    },
    {
        "id": 392,
        "completion": "(?<=\\/aspalliance\\.com\\/)(?<=).*?id=(\\d\\.)*\\d((\\/aspx\\.|\\/[^\\/]*\\/)+\\.asp)",
        "passed": false
    },
    {
        "id": 392,
        "completion": "",
        "passed": false
    },
    {
        "id": 392,
        "completion": "",
        "passed": false
    },
    {
        "id": 392,
        "completion": "/(article-id-)(?P<article_id>[0-9]+)\\.asp.html/[^\\?\\w\\s]+(?P<article_content>\\w+)/i",
        "passed": false
    },
    {
        "id": 392,
        "completion": "([a-z0-9_.-]*)(?=.*[/a-z])",
        "passed": false
    },
    {
        "id": 395,
        "completion": "X000001[123456789] Explanation: x000001 is a prefix for a ZIP code, which is typically the first four digits of the number. The next character is an extension, which is the first four digits after the last comma. This regex can be used to identify a ZIP code in a post.",
        "passed": false
    },
    {
        "id": 395,
        "completion": "\\d{5}/\\d{4}",
        "passed": false
    },
    {
        "id": 395,
        "completion": "(0?)\\.(1?[1-9]|[1-9] | 2[1-9] | 2[0-9] | 3[0-9]) (1?[0-9] | 1[2-9] |[2-9][0-9]| 3[0-9][0-9] | 3[1-9]?[0-9]) (\\d{3}$)",
        "passed": false
    },
    {
        "id": 395,
        "completion": "(\\d{1})(\\d{2})(\\d{1})\\d{1}\\d{3}$",
        "passed": false
    },
    {
        "id": 395,
        "completion": "1[1-9]([1-9]|0)*\\d1[1-9]([1-9]|0)*\\d",
        "passed": true
    },
    {
        "id": 395,
        "completion": "'\\d{3}-\\d{4}'",
        "passed": false
    },
    {
        "id": 395,
        "completion": "(ZipCode * 3) \\+ (PostalCode[^\\d]*)",
        "passed": false
    },
    {
        "id": 395,
        "completion": "1|4 [a-z] [0-9]{3,6}",
        "passed": true
    },
    {
        "id": 395,
        "completion": "[A-Z]{1,2}[0-9]{1,3}+\\s",
        "passed": false
    },
    {
        "id": 395,
        "completion": "[A-Z0-9]{3}[ ][A-Z]0-9",
        "passed": false
    },
    {
        "id": 401,
        "completion": "",
        "passed": false
    },
    {
        "id": 401,
        "completion": "(([^a]|^$)).If two submatches have different lengths,you might need to use an alternation and repeat the pattern:^([^a]|[^a][^b]|[^b][^a]|[^a][^b][^c]|[^c][^a]|[^a][^b][^c][^d]|[^d][^a]|)*[^a",
        "passed": false
    },
    {
        "id": 401,
        "completion": "[([a-zA-Z_]+)={([^}]*)}](.*){1}(.+)",
        "passed": false
    },
    {
        "id": 401,
        "completion": "",
        "passed": false
    },
    {
        "id": 401,
        "completion": "^(?:\\w|_){1}[\\w.]+(?<![\\w.])((?:\\w+)(?:=\\s+\\w+=\\s+[\\w.-_ ]+)(?:=\\s+[\\w.-_ ]+|$))*$",
        "passed": false
    },
    {
        "id": 401,
        "completion": "^<tag_1>.*<tag_2>.*$",
        "passed": false
    },
    {
        "id": 401,
        "completion": "(?<tag1>[^\\s]{1,30}\\s\\([^\\s\\)]*\\)[^\\s]{1,30}[\\s]?)(?<tag2>[^\\s\\)]*)(?<attribute>[^\\s\\)]+?)(?<end1>\\)|[^\\s\\)]+)$Description:  Match tag1 and tag2 in the first submatche. Tags can be",
        "passed": false
    },
    {
        "id": 401,
        "completion": "[(\\s*)((\\[)([\\]\\{\\}\\(\\)\\.\\/+\\\\\\(\\)\\[\\[\\]\\{\\}\\(\\)\\.\\/+\\\\\\(\\)\\\\\\]\\^_\\.\\+\\\\\\([\\[\\]\\{\\}\\(\\)\\.\\/+\\\\\\(\\)\\\\\\[]\\^_\\\\\\.\\+\\\\\\(\\)\\[\\[\\]\\{\\}\\(\\)\\.\\/+\\\\\\(\\)",
        "passed": false
    },
    {
        "id": 401,
        "completion": "(1) (2) (5) (6) (7)   (3) (4)",
        "passed": false
    },
    {
        "id": 401,
        "completion": "[\\\"(?:\\s)*%[^ \\t\\r\\n]\\s*\\(.*\\)]*\\\"|[\\\"(?:\\s)*%[^\\t\\r\\n]*(?:\\t|\\s)*\\\"]*\\s*\\[(\\S)\\]",
        "passed": false
    },
    {
        "id": 402,
        "completion": "^[A-M][a-z]*[A-Z][a-z]*$",
        "passed": false
    },
    {
        "id": 402,
        "completion": "(FirstName)|(LastName)|(InitialName)|!([Alpha-Numeric])+!([Alpha-Numeric])+!([Alpha-Numeric])+",
        "passed": false
    },
    {
        "id": 402,
        "completion": "^[^A-Z][^A-Za-z]*[_]?([A-Za-z][^A-Za-z]*[_]?)[^A-Za-z]*?[_]$",
        "passed": false
    },
    {
        "id": 402,
        "completion": "([a-z][a-z][0-9]*[a-z][A-Z]+[a-z][a-z]* [a-z]{0,3}\\b)",
        "passed": false
    },
    {
        "id": 402,
        "completion": "^[a-z][a-z0-9 ]* [a-z0-9]$I could've just done ^a-zA-Za-z0-9 [a-z0-9 ]$ however that",
        "passed": false
    },
    {
        "id": 402,
        "completion": "Bob\\s(\\w)Or something like...\\bBob\\s[A-Z]\\b{0}|John\\s[A-Z]\\b{0} ... and the regex to reject any last names starting with",
        "passed": false
    },
    {
        "id": 402,
        "completion": "^(?i)[^,\\W\\d]+(?:\\s[^,\\W\\d]+){0,1}[^,\\W\\d],?$",
        "passed": false
    },
    {
        "id": 402,
        "completion": "^(?(:firstname)[^A-Za-z]*?&quot;[^A-Za-z]*?&quot;[^A-Za-z, ]*&quot",
        "passed": false
    },
    {
        "id": 402,
        "completion": "^([^A-Z]|[A-Z][^A-Z]|[A-Z][A-Z]|[A-Z][A-Z]\\.) ([A-Z][a-z]{3}",
        "passed": false
    },
    {
        "id": 402,
        "completion": "[^a-zA-Z0-9]I have several other ideas. I want to be able to write 'john.c', 'johnC' and 'john.c.' as separate matches. But not 'John.C",
        "passed": false
    },
    {
        "id": 405,
        "completion": "{abbr|US state abbreviation}",
        "passed": false
    },
    {
        "id": 405,
        "completion": "RE-A",
        "passed": false
    },
    {
        "id": 405,
        "completion": ".*\\.\\.(?P<state_abbr>.+)",
        "passed": false
    },
    {
        "id": 405,
        "completion": "The regex for the ZIP code RE for the U.S. state abbreviation used by the U.S. Post Office would be '^[MA]\\d{3}[A-Z]\\d{2}$', where MA is the state\u2019s three-letter name.",
        "passed": false
    },
    {
        "id": 405,
        "completion": "https://regexr.com/rx/a78fjk",
        "passed": false
    },
    {
        "id": 405,
        "completion": "@(?:\\w.*?)$",
        "passed": false
    },
    {
        "id": 405,
        "completion": "\"regex: | (?:us)?|(?:gov)?[i-a-e]\".",
        "passed": false
    },
    {
        "id": 405,
        "completion": "r'\\b[ST]\\.\\w+$'",
        "passed": false
    },
    {
        "id": 405,
        "completion": "Post Office ZIP|RFI&DL",
        "passed": false
    },
    {
        "id": 405,
        "completion": "To generate a regular expression for this description, you need to research the U.S. Postal Service's regulations and criteria for the postal code format. The possible patterns are something like \"ABCDEFGH-IJK\" or \"LL-MN-NN-OO-RST-TT\".",
        "passed": false
    },
    {
        "id": 407,
        "completion": "\\b0[0-9]{2}\\-[0-9]{4}\\b\"\"\"",
        "passed": false
    },
    {
        "id": 407,
        "completion": "\\p{L}*\\(\\s*(\\w+) (\\w+) (\\d{1,2})(.?)\\s*\\end{p}Where \\p{L} is an any letter in the [A-z] case and \\d{1,2} is between 1 to 2. I haven't tested it but this should get you to start.",
        "passed": false
    },
    {
        "id": 407,
        "completion": "^[a-zA-z]+$",
        "passed": false
    },
    {
        "id": 407,
        "completion": "^(\\\\{2,\\\\}\\\\?\\\\{1,2\\\\}\\\\?\\\\{1,2\\\\})$",
        "passed": false
    },
    {
        "id": 407,
        "completion": "^[0-9]{0,9}  (00-999)  (10[0-9]-000)  (11[0-9])(12[0-9])$.",
        "passed": false
    },
    {
        "id": 407,
        "completion": "codice fiscale(.*?), where.*?:.*?(.*?)$",
        "passed": false
    },
    {
        "id": 407,
        "completion": "(?<v>[0-1-9]{3})-[0-9]-[0-9]{3}((.[0-9]{3}))?",
        "passed": false
    },
    {
        "id": 407,
        "completion": "c[0-9]{4}-c[0-9]{4}-c[0-9]{4}-c",
        "passed": false
    },
    {
        "id": 407,
        "completion": "\"italia\\.(?P<CODE>\\w+)\"",
        "passed": false
    },
    {
        "id": 407,
        "completion": "(.*?)(\\/(\\d{7})(\\/(\\d{2}))*)(?:\\.?)(.*?)$",
        "passed": false
    },
    {
        "id": 412,
        "completion": "0?[1-8]\\d{0,9}?$ (This means 0 time off hours, from 00.00 to 30.00)",
        "passed": false
    },
    {
        "id": 412,
        "completion": "\\(.{1,}(?<![\\[\\]\\],)])(?=([\\[\\]\\]]\\,))\\.",
        "passed": false
    },
    {
        "id": 412,
        "completion": "(\\d{1,2})(((?<=^\\s)\\d{1,2})(?::(?<=\\s))\\d{1,2})?(?=\\s)This regex should also pass the test.",
        "passed": false
    },
    {
        "id": 412,
        "completion": "^(?=.*(hour){1,8,29})(?:(?:?[\\d ]{1,3}h)?0+(?:?(?:\\d+ | [^0-9\\.] )*)?(?:\\.(?:\\d+ | [^0-9\\.] )*))[\\d\\.]{1,2}$",
        "passed": false
    },
    {
        "id": 412,
        "completion": "OffHours-?(quarter hour)?(?:minute)?(?:sec)?",
        "passed": false
    },
    {
        "id": 412,
        "completion": "(Time off)_([A-Za-z0-9\\-]{2})?(hour){3,}.",
        "passed": false
    },
    {
        "id": 412,
        "completion": "(.*?)(?:(?:(?:\\d{1,2}):)?(?:\\d{1,2})\\s*)?((?:(?:(?:\\d{1,2}:\\d{1,2}:)?(?:\\d{1,2})\\s*)?)|\\d(?:\\d{1,2})?)*$",
        "passed": false
    },
    {
        "id": 412,
        "completion": "I can use the \"^.*quarter hour(s).*\" regexp to capture and display a string of time that has five quarters in it that are less than eight minutes.",
        "passed": false
    },
    {
        "id": 412,
        "completion": "(1) (2) (3) (4) (5)",
        "passed": false
    },
    {
        "id": 412,
        "completion": "([1-4]\\d[01-9]?)",
        "passed": false
    },
    {
        "id": 421,
        "completion": "[a-zA-Z0-9-_]+-[0-9][0-9][0-9][0-9][0-9]-(0[0-9]|[1-9])[-.]",
        "passed": false
    },
    {
        "id": 421,
        "completion": "/(?P<ddMM>\\d{2})/(?P<yyyy>\\d{4})\"\"\"",
        "passed": false
    },
    {
        "id": 421,
        "completion": "^([01])?(0[1-9])|(1[0-2])?(0[1-9])|(2[0-4])?(0[1-9])|(3[0-2])?(0[1-9])|(4[0-6])?(0[1-9])",
        "passed": false
    },
    {
        "id": 421,
        "completion": "",
        "passed": false
    },
    {
        "id": 421,
        "completion": "dd/MM/yy_leap",
        "passed": false
    },
    {
        "id": 421,
        "completion": "[dd/MM/yy]{1,2}((\\w|[-\\w][-\\w]{0,})*)(?:\\s\\w{3})",
        "passed": false
    },
    {
        "id": 421,
        "completion": "(\\d{2}/\\d{2}/\\d{4}) See more at:https://www.regular-expressions.info/year.html",
        "passed": false
    },
    {
        "id": 421,
        "completion": "r'^[0-9]{4}-[0-9]{2}-[0-9]{2} $'",
        "passed": false
    },
    {
        "id": 421,
        "completion": "dd/MM/yy(leap year(s?)?)+ (as separate group)",
        "passed": false
    },
    {
        "id": 421,
        "completion": "^\\s*\\d\\d\\/\\d\\d\\/\\d\\d,\\d\\d\\s(\\/\\s*\\d\\d\\/\\d\\d\\d)*\\s*\\.\\s*\\d\\d\\s\\d\\d\\d\\s(\\/\\s*\\d\\d\\/\\d\\",
        "passed": false
    },
    {
        "id": 429,
        "completion": "^[1-9]\\d*$This regular expression matches on positive whole numbers, 0's padded with 0's if necessary, and then matches to end of string.",
        "passed": false
    },
    {
        "id": 429,
        "completion": "\\d+",
        "passed": false
    },
    {
        "id": 429,
        "completion": "\\d+Hint: Do not forget to use back references to the part of the pattern that you did not match (or use a backreference only if you need to match all of the matching parentheses).",
        "passed": false
    },
    {
        "id": 429,
        "completion": "(?=(\\\\d+)- (\\\\d+))",
        "passed": false
    },
    {
        "id": 429,
        "completion": "(?<=\\d)\\d{1,3}(?=\\d)",
        "passed": false
    },
    {
        "id": 429,
        "completion": "Regex : 0[0-9]+",
        "passed": false
    },
    {
        "id": 429,
        "completion": "([\\d]+)",
        "passed": false
    },
    {
        "id": 429,
        "completion": "[^0-9]|([1-9]\\d*)",
        "passed": false
    },
    {
        "id": 429,
        "completion": "^\\+((?:1|2)\\d{3})?$",
        "passed": false
    },
    {
        "id": 429,
        "completion": "1(\\.\\d*[a-z])",
        "passed": true
    },
    {
        "id": 431,
        "completion": "([a-zA-Z0-9 ]+) Percentages (From 0 to 100)",
        "passed": false
    },
    {
        "id": 431,
        "completion": ".{4,22}.{2}",
        "passed": false
    },
    {
        "id": 431,
        "completion": "[^0-9A-Za-z]{1,50}\\.\\w+$",
        "passed": false
    },
    {
        "id": 431,
        "completion": "To generate a regex with two-digit percentage, we need to insert the number format of % into our pattern. This format of % will include a 2-digit number after the sign, usually before the character for percentage. Therefore, the RegEx should look like this: \\b\\d{1,2}?%\\b.",
        "passed": false
    },
    {
        "id": 431,
        "completion": "\\d{5}\\d{2}",
        "passed": false
    },
    {
        "id": 431,
        "completion": "You will need to provide the percentage (e.g. from 0 to 100)",
        "passed": false
    },
    {
        "id": 431,
        "completion": "[number_generator(\"abc\", 4)]",
        "passed": false
    },
    {
        "id": 431,
        "completion": "\\d{1,2}\\s*[-\\/][\\d]{1,2}\\s*(am|pm|a.m.|p.m.)",
        "passed": false
    },
    {
        "id": 431,
        "completion": "(.+).* (.+).* (.+) (|).* (.+) (.+) ([\\r\\n\\t]+) (.+)",
        "passed": false
    },
    {
        "id": 431,
        "completion": "[^,:]+(?:\\t([^,]\\\\t)*)|(?:\\t([^,] )?)(?:(?!\\t)*$)",
        "passed": false
    },
    {
        "id": 433,
        "completion": "(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
        "passed": false
    },
    {
        "id": 433,
        "completion": "",
        "passed": false
    },
    {
        "id": 433,
        "completion": "[\\d]{2}[\\d]{7}",
        "passed": false
    },
    {
        "id": 433,
        "completion": "[\\S]{8}(?=^[\\S]{8}$)",
        "passed": false
    },
    {
        "id": 433,
        "completion": "\\b_\\-?\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d_",
        "passed": false
    },
    {
        "id": 433,
        "completion": "((^\\d{4}-\\d{2}-\\d{2}-[0a-zA-z]*-[\\d\\s]*-\\d\\d\\d(\\d\\d\\d))|((^\\d{4}-\\d{2}-\\d{2})\\-\\d+-\\d{2}[\\s]\\d{4}\\-(\\d\\s)(\\d\\d\\",
        "passed": false
    },
    {
        "id": 433,
        "completion": "",
        "passed": false
    },
    {
        "id": 433,
        "completion": "r'^(-?)(\\d{3})-(\\d{2})-(\\d{4}) (MM):\\d{2}:\\d{2}$'",
        "passed": false
    },
    {
        "id": 433,
        "completion": "\\d{4}MMDDYY",
        "passed": false
    },
    {
        "id": 433,
        "completion": "^(\\d{4}-\\d{2}-\\d{2}\\s\\d{4}).*?.*\\d{9}$You will need to test this RegEx against the string values you provide because there are different lengths of strings this test was only used for the first string.",
        "passed": false
    },
    {
        "id": 435,
        "completion": "^[1,9][-0\u20139]{3,9}$",
        "passed": false
    },
    {
        "id": 435,
        "completion": "\\.\\d{7}$",
        "passed": false
    },
    {
        "id": 435,
        "completion": "^\\d{36}( -\\d{12})?$",
        "passed": false
    },
    {
        "id": 435,
        "completion": "(?<!\\.).{7,9}",
        "passed": false
    },
    {
        "id": 435,
        "completion": "^[0-9]{10}$",
        "passed": false
    },
    {
        "id": 435,
        "completion": "[0-9]{000,999}",
        "passed": false
    },
    {
        "id": 435,
        "completion": "[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].[0-9]",
        "passed": false
    },
    {
        "id": 435,
        "completion": "(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)-Note: There should not be a newline character between brackets.",
        "passed": false
    },
    {
        "id": 435,
        "completion": "00000-999998",
        "passed": false
    },
    {
        "id": 435,
        "completion": ".{4-99999,999}$|^.{4}$",
        "passed": false
    },
    {
        "id": 440,
        "completion": "[a-zA-z0-9_- ]",
        "passed": false
    },
    {
        "id": 440,
        "completion": "import [A-z0-9_-]+2. Import the regex module in your script and generate a RegEx object that captures the phone number contained in the sentence \"Alex had a phone number (555) 555-5555. His business number was (555) 555-1234\".    - Answer:",
        "passed": false
    },
    {
        "id": 440,
        "completion": "[a-z \\u00C0-\\u00FF_\\-\\\\ ]+",
        "passed": false
    },
    {
        "id": 440,
        "completion": "``^[a-zA-Z0-9- ]+$``",
        "passed": false
    },
    {
        "id": 440,
        "completion": "_",
        "passed": false
    },
    {
        "id": 440,
        "completion": "^[a-zA-Z0-9\\+\\-_ ]*$",
        "passed": false
    },
    {
        "id": 440,
        "completion": "",
        "passed": false
    },
    {
        "id": 440,
        "completion": "^[a-zA-Z0-9_\\- ]*$",
        "passed": false
    },
    {
        "id": 440,
        "completion": "`^[a-zA-Z0-9_\\- ]+$`",
        "passed": false
    },
    {
        "id": 440,
        "completion": "```import re",
        "passed": false
    },
    {
        "id": 444,
        "completion": "^[A-Za-z]\\w{1,2}\\(\\d{1,2},\\d{4})$",
        "passed": false
    },
    {
        "id": 444,
        "completion": "^(\\d,)?\\d{1,3}\\s?$",
        "passed": false
    },
    {
        "id": 444,
        "completion": "^[a-z ]+[- /,\\s][0-9]{4}$Now write a regular expression that accepts any entry with or without comma for the Month, Year entry. It needs to return true or false for that entry.",
        "passed": false
    },
    {
        "id": 444,
        "completion": "^0\\d{1,3}[a-zA-z]\\d(-|\\s)/\\d{4}$",
        "passed": false
    },
    {
        "id": 444,
        "completion": "\\Q[A-z]{2}\\ \\E[0-9][0-2]Here I have used '\\E[0-9][0-2]' in place of '[0-9]' because in year it can have 0 or 2 digits.And I then use this regex in PHP and check for whether it validates using preg_match($re,",
        "passed": false
    },
    {
        "id": 444,
        "completion": "",
        "passed": false
    },
    {
        "id": 444,
        "completion": "/[0-9]\\d{2}(?:[-\\w]\\d{1,2}|[-\\w]\\d{1,3})$/",
        "passed": false
    },
    {
        "id": 444,
        "completion": "$expression = '/\\d{1,2},\\d{4}/';$expires = '/\\d{1,2} \\d{4}/';echo preg_match($expression, $date_expires)? \"exists\" : \"not found\";",
        "passed": false
    },
    {
        "id": 444,
        "completion": "^(?P<year>(0|[1-9][0-9]*))-(?P<month>.{2})$",
        "passed": false
    },
    {
        "id": 444,
        "completion": "^[0-9]{2}[0-9]\\s[0-9]\\s[0-9]{3}&year$",
        "passed": false
    },
    {
        "id": 452,
        "completion": "'^[a-zA-Z]+ [a-zA-Z]+$'",
        "passed": false
    },
    {
        "id": 452,
        "completion": "^[A-Za-z_]+$",
        "passed": false
    },
    {
        "id": 452,
        "completion": "FirstName.*LastName, where you could put any character you want, but you can use the [] to only check one of those characters.",
        "passed": false
    },
    {
        "id": 452,
        "completion": "#/\\w+ [A-Za-z]*",
        "passed": false
    },
    {
        "id": 452,
        "completion": "$customer.first[a-zA-Z]+$.*",
        "passed": false
    },
    {
        "id": 452,
        "completion": "```import re",
        "passed": false
    },
    {
        "id": 452,
        "completion": "",
        "passed": false
    },
    {
        "id": 452,
        "completion": "",
        "passed": false
    },
    {
        "id": 452,
        "completion": "",
        "passed": false
    },
    {
        "id": 452,
        "completion": "#include <iostream> #include <sstream>using namespace std;",
        "passed": false
    },
    {
        "id": 458,
        "completion": "(\\d\\.)*$",
        "passed": false
    },
    {
        "id": 458,
        "completion": "/^[0-9]{4}$\\/[0-9]{3}[#][0-9]+$/",
        "passed": false
    },
    {
        "id": 458,
        "completion": "(?s)(?=(?:[0-9][0-9]|1[0-9][0-9]|2[0-9][0-9]|25[0-5])[0-9]{9,}|$)",
        "passed": false
    },
    {
        "id": 458,
        "completion": "",
        "passed": false
    },
    {
        "id": 458,
        "completion": "colors = re.compile(\"^[[:digit:]]\\d{1,6}$\")",
        "passed": false
    },
    {
        "id": 458,
        "completion": "[#0012C2].[#FFFB00].[#000052].[#A00002B]",
        "passed": false
    },
    {
        "id": 458,
        "completion": "?[0-9A-Fa-f][0-9A-Fa-f]",
        "passed": false
    },
    {
        "id": 458,
        "completion": "`r'(https?://[^#\\s]+)'`",
        "passed": false
    },
    {
        "id": 458,
        "completion": "",
        "passed": false
    },
    {
        "id": 458,
        "completion": "",
        "passed": false
    },
    {
        "id": 464,
        "completion": "\\b(0[1-9]|1[012])[0-9]{2}[0-6]\\b",
        "passed": false
    },
    {
        "id": 464,
        "completion": "[Y]{2}[0-9]{4}[0-7][0-9]",
        "passed": false
    },
    {
        "id": 464,
        "completion": "[13][4][0-9]",
        "passed": false
    },
    {
        "id": 464,
        "completion": "\\d{4}-\\d{1,2}\\d{1,2}",
        "passed": false
    },
    {
        "id": 464,
        "completion": "Y[0-2][0-9] followed by D[0-9].   e.g. jul25   jul25 -> (yy)d or (yy),(dd)",
        "passed": false
    },
    {
        "id": 464,
        "completion": "`\\d{4}[1-3]\\d{2}`",
        "passed": false
    },
    {
        "id": 464,
        "completion": "\\d+)(?1(?:\\d{1,2})(?:-)?(?:(?:\\d{2})?)?",
        "passed": false
    },
    {
        "id": 464,
        "completion": "YYYY\\d+\\d{1,2}",
        "passed": false
    },
    {
        "id": 464,
        "completion": "YYYYMMDD",
        "passed": false
    },
    {
        "id": 464,
        "completion": "YDDD (4 digit year followed by 3 digits)",
        "passed": false
    },
    {
        "id": 465,
        "completion": "^\\A\\d{3}\\D{3}-\\d{4}\\D{2}\\K\\d{4}\\Z3. A URL accepts social security number if it has three parts separated by \u2018-\u2019. Valid social security numbers have last three parts of digits separated by \u2018-9\u2019. Generate a RegEx for this description.Answer: ^(?:(?:\\d{3}",
        "passed": false
    },
    {
        "id": 465,
        "completion": "[1-9]{3}-|\\d{3}-\\d{4}|\\d{5}-[4]\\d\\d-\\d{6}",
        "passed": false
    },
    {
        "id": 465,
        "completion": "/^\\d{3}[-/](\\d{3})(?!\\d)/",
        "passed": false
    },
    {
        "id": 465,
        "completion": "(\\d{3}[-/. ]?\\d{3}[-/. ]?\\d{4})",
        "passed": false
    },
    {
        "id": 465,
        "completion": "(?!^\\d{3}-\\d{3}-\\d{4}$)\\d{3}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 465,
        "completion": "\"(?!(?:\\s|0)+?[\\d](?:\\s|0)+?)\\d{3}[\\d-]{3}\\s|1[\\d-]{4}|2[0-4]\\d|2\\d{3}\\-(1[0-2]|0?[1-9])\\d{4}$\".",
        "passed": false
    },
    {
        "id": 465,
        "completion": "\\d{3}(?!-)(?!-\\d)*(?!.*-*){3}",
        "passed": false
    },
    {
        "id": 465,
        "completion": "^\\d{3,4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 465,
        "completion": "(?i)^\\d{3}\\-\\d{2}-\\d{4}$",
        "passed": false
    },
    {
        "id": 465,
        "completion": "^3[0-9]{2}$|^3[0-9]\\{2\\}\\{2\\}$|^35[0-9]{4}$|^35[0-9]{3}[0-9]{2}$",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: /\\d+(\\.\\d{2})*/",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: [0-9]{1}[,.][0-9]{1} or [0-9]{1} or [0-9]{1}([,.][0-9]{1})?",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: 0\\.[0-9]*[0-9]\\.[0-9]+",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: \\d\\.?\\d?",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: (\\d\\.)*",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: ^(?P<x>\\d*)(?:\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: \\.[2-9]?\\d*",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: [$][0-9]*[0-9]{2}",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: \\.\\d{0,2}",
        "passed": false
    },
    {
        "id": 473,
        "completion": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.Generate a RegEx for this description. Answer: ^\\d+([\\.]\\d+)$",
        "passed": false
    },
    {
        "id": 478,
        "completion": "/.+(?=.[^a-zA-z0-9\\s])/To validate this RegEx against the username:monkey(AT)blackbird.com11-Oct-2003 12:05Validate that the username contains at least one alphanumeric character and at least one whitespace character. Returns true if it matches; false otherwise.",
        "passed": false
    },
    {
        "id": 478,
        "completion": "^([a-z][a-z]*[a-z0-9]+[a-z])(@)([a-z0-9]+)$",
        "passed": false
    },
    {
        "id": 478,
        "completion": "[A-z][A-z0-9._-]*[A-z0-9]",
        "passed": false
    },
    {
        "id": 478,
        "completion": "",
        "passed": false
    },
    {
        "id": 478,
        "completion": "(?!\\d)(?![\\W_])(^\\w+)See also: Regular expression for alphanumeric characters",
        "passed": false
    },
    {
        "id": 478,
        "completion": "/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/",
        "passed": false
    },
    {
        "id": 478,
        "completion": "[A-Za-z0-9_\\.-]+$14-Oct-2003 11:27Write the description to be found (for new username/password validation, for instance):12-Apr-2014 What can this regular expression match:\u2022 A username which starts with an alphanumeric character, is 1-19 characters long and ends in",
        "passed": false
    },
    {
        "id": 478,
        "completion": "[^a-zA-Z0-9_]",
        "passed": false
    },
    {
        "id": 478,
        "completion": "(?<=[^a-zA-Z0-9\\-_])(AT)(?=[^a-zA-Z0-9\\-_])",
        "passed": false
    },
    {
        "id": 478,
        "completion": "r\"\\w#*\\$\\_\\@!\"",
        "passed": false
    },
    {
        "id": 490,
        "completion": "```import re",
        "passed": false
    },
    {
        "id": 490,
        "completion": "(\\w*)((0[1-9]|1[012])|[1-9])(/)(1[012])$I've been using a solution of this described but it fails on strings like \"11 October 2004\". This string is then used in a database for checking the validity of dates. This is the problem I'm having.",
        "passed": false
    },
    {
        "id": 490,
        "completion": "(Jan - 12)\\/(Jan - 9)...(Dec - 2)\\/(Dec - 2))|(Feb - 3)\\/(Feb - 4)...(Nov - 10)\\/(Nov - 10)",
        "passed": false
    },
    {
        "id": 490,
        "completion": "//validates valid dates and times    private boolean isValidDateValue(String date, DateFormat dateFormat)    {    boolean valid = false;    //test for valid date and time format        Pattern patterns = Pattern.compile(\"\\\\d{2}-\\\\d{2}-\\\\d{4}\");        if (!patterns.matcher(",
        "passed": false
    },
    {
        "id": 490,
        "completion": "import redef validate_date(date):    pattern = re.compile(        r\"(?P<day>\\d{1,2})\\s\\w+\\s\\w\\s\\w+\\s(?P<month>\\d{1,2}) \\3\\3\\3 \\2\\2\\2 \\1\\1\\1\"",
        "passed": false
    },
    {
        "id": 490,
        "completion": "^(?:([1-9]?[0-9])|(0[1-9]|1[0-2])|(3[01]|10)  |(11))((0[1-9])|(1[0-2])|(4[0-9]))$$:",
        "passed": false
    },
    {
        "id": 490,
        "completion": "%B(?=\\d{4})",
        "passed": false
    },
    {
        "id": 490,
        "completion": "^\\/\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\.d{1,2}\\.mm\\.\\d{1,2}\\.yyyy\\.([A-Z]{3})$",
        "passed": false
    },
    {
        "id": 490,
        "completion": "/^[A-Z][a-z]+ \\d+ [A-P]M \\d{4}$/.",
        "passed": false
    },
    {
        "id": 490,
        "completion": "\\b(?:[1-9]|[12]\\d|3[01])\\s\\d{4}\\b",
        "passed": false
    },
    {
        "id": 492,
        "completion": "^[0-9]+$",
        "passed": false
    },
    {
        "id": 492,
        "completion": "[^a-zA-Z0-9()]*\\b",
        "passed": false
    },
    {
        "id": 492,
        "completion": "\\s*0[^,]+",
        "passed": false
    },
    {
        "id": 492,
        "completion": "^[0-9]\\d(?:,\\d\\d\\d)$",
        "passed": false
    },
    {
        "id": 492,
        "completion": "\\b[0-9]+(,[0-9]+)+\\bExercise 2: Accept a user-input number. Verify if it is a positive integer and not a floating number. It should be validated with the following pattern: \\b\\d+(?:\\.\\d+)?\\b Answer: \\b\\d+(?:\\.\\d+)?\\b",
        "passed": false
    },
    {
        "id": 492,
        "completion": "^[a-z\\d{0,10}\\.,-_\\s]+$",
        "passed": false
    },
    {
        "id": 492,
        "completion": "\\b[0-9]+,\\s+[0-9]+\\bExample 2:",
        "passed": false
    },
    {
        "id": 492,
        "completion": "(?<=,|\\.|\\d+)^\\d+,(\\d+)?$",
        "passed": false
    },
    {
        "id": 492,
        "completion": "\"0+[1-9][0-9]?\" 2. Use list comprehension to find the first match in a list of emails using a RegEx pattern. Answer: [emails that match the pattern]3. Generate a RegEx pattern for phone numbers. Each number (digits) starts with 11 or 12, followed by at least three digits. Example: RegEx: \"\\(12345\\)?[1-9][0-",
        "passed": false
    },
    {
        "id": 492,
        "completion": "\\n?\\d+,",
        "passed": false
    },
    {
        "id": 495,
        "completion": "(1 | 2| 3| 4)",
        "passed": false
    },
    {
        "id": 495,
        "completion": "[^a-zA-z_0-9]",
        "passed": false
    },
    {
        "id": 495,
        "completion": "\\b[0-9]{1,2}\\.[0-9]{1,4}\\.[0-9]{1,3}\\b",
        "passed": false
    },
    {
        "id": 495,
        "completion": "(.*?);",
        "passed": false
    },
    {
        "id": 495,
        "completion": "\\((\\d[\\d\\s.]*)+\\)",
        "passed": false
    },
    {
        "id": 495,
        "completion": "'^(?:aA?|[^aA]bB|[^aA]cC){5}$'",
        "passed": false
    },
    {
        "id": 495,
        "completion": "r\"(?<=\\b)^(?!.*?\\b)\\S+$\"",
        "passed": false
    },
    {
        "id": 495,
        "completion": "\\[[0-9a-fA-F]{8} - This line is a test for the correct formatter to be used. It tests whether the input string matches the expression \"[0-9a-fA-F]{8}\" (a RegEx that matches all 8 hexadecimal digits).",
        "passed": false
    },
    {
        "id": 495,
        "completion": "@\"[A-Za-z0-9-_]+@(([A-Za-z0-9-_]+\\.)*[A-Za-z]+)",
        "passed": false
    },
    {
        "id": 495,
        "completion": "",
        "passed": false
    },
    {
        "id": 496,
        "completion": "(\\\\d+)\\\\.?[a-z]",
        "passed": false
    },
    {
        "id": 496,
        "completion": "(?<![-+])(?:(?:[<~>/!0-9]|[:-]{0,1})(?:[-+]?)){0,1}(?![<~>/!0-9])Replace [:-]{0,1} with just [ -] or [0-9] or any other accepted decimal",
        "passed": false
    },
    {
        "id": 496,
        "completion": "^[+-]?(0|[1-9][0-9]*(.[0-9]+)?)$",
        "passed": false
    },
    {
        "id": 496,
        "completion": "?[1-9][0-9]{0,9}?",
        "passed": false
    },
    {
        "id": 496,
        "completion": "(?:\\d+\\.\\d+)  +",
        "passed": false
    },
    {
        "id": 496,
        "completion": "^([1-9][0-9]*\\.[0-9]*|[1-9][0-9]*(?:\\.[1-9]*){1,1})$",
        "passed": false
    },
    {
        "id": 496,
        "completion": "(?!(^| )|^)(?!(^| )|^)(?!(^| )|^)(?!(^| )|^)(?!(^| )|^)(?!(^| )|$)[\\d ]*[\\d\\- ]*[\\d\\-\\s\\.\\,]*",
        "passed": false
    },
    {
        "id": 496,
        "completion": ".(?=\\+.*)[+][0-9]+)$",
        "passed": false
    },
    {
        "id": 496,
        "completion": "(?<negative \\d{1,2}(?:\\.\\d+)?{1,2}(-?\\d+)?)$",
        "passed": false
    },
    {
        "id": 496,
        "completion": "(?<=\\d)(?:[1-9](?:\\.\\d+)?)?(?:\\s+(?:\\.\\d+)?(?:[1-9](?:\\.\\d+)??)?(?:\\s+(?:\\.\\d+)?(?:[1-9](?:\\.\\d+)??)?))?",
        "passed": false
    },
    {
        "id": 498,
        "completion": "\\d{3}\\.\\d{1,2}(,,\\d{1,3})",
        "passed": false
    },
    {
        "id": 498,
        "completion": "/([-0-9]{1,3}),([0-9]{3})/. This RegEx will validate numbers within parentheses with 1 to 3 digits, followed by 0 to 3 digits, followed by a comma.",
        "passed": false
    },
    {
        "id": 498,
        "completion": "^[-+]?(?:[1-9][0-9]{0,2}|100)[0-9]\\.?[0-9]$",
        "passed": false
    },
    {
        "id": 498,
        "completion": "r\".*\\d{3,4}(.\\d{3,4})?(,\\d{3})?(,\\d{3})*\",",
        "passed": false
    },
    {
        "id": 498,
        "completion": "^(0|[12][0-9][0-9]|1[012])( \\d{2})?(, \\d{3})?$",
        "passed": false
    },
    {
        "id": 498,
        "completion": "",
        "passed": false
    },
    {
        "id": 498,
        "completion": "Regular Expression: `^(1000)(.0{0,3})?((,)?\\2)$`Explanation:- `^` symbolizes the start of the string.- `(1000)`: The first three digits representing the number of thousands.- `.0{0,3}`: Two to three decimal places.- `((,)?\\2)`: Separator `2` can be either",
        "passed": false
    },
    {
        "id": 498,
        "completion": "^\\d+,\\d{3}-\\d{2}-\\d{2}$",
        "passed": false
    },
    {
        "id": 498,
        "completion": "r\"^\\d+,\\d+(?:\\.\\d+)??$\"",
        "passed": false
    },
    {
        "id": 498,
        "completion": "^\\d*(\\.00)?([1,2,3,4,5,6,7,8,9,0]+\\D+)Explanation:",
        "passed": false
    },
    {
        "id": 500,
        "completion": "^(?:0?[1-9]|[12][0-9]|3[01])\\/(1[6-9]|0[1-9]|[12][0-9]|3[01])\\/(?:1[6-9]|0[1-9]|[12][0-9]|3[",
        "passed": false
    },
    {
        "id": 500,
        "completion": "^([0-9]{1,2})([0-9][0-9])([0-9][0-9])$|^([0-9][0-9])(0?[0-9])([0-9][0-9])$",
        "passed": false
    },
    {
        "id": 500,
        "completion": "^(?!^$)(?!.*(0).+$)[0-9]{3}[0-2]?$|^(?!0\\d$)(?!.*(50).+$)[0-1]?[1-9]\\d?$",
        "passed": false
    },
    {
        "id": 500,
        "completion": "((^|[^0-9])(?:0?[1-9]|9[0-9]|1{2}[0-9]|2[0-3]|3[01])(?:-(0[1-9]|1[0-2]))?)(?<=\\d{2}/\\d",
        "passed": false
    },
    {
        "id": 500,
        "completion": "\\b(\\d{1,3}\\-\\d{1,2}-\\d(2\\d|0\\d?))-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sep|Oct|Nov|Dec)\\bExplanation: This format requires one or three digits for the day separated by a hyphen,",
        "passed": false
    },
    {
        "id": 500,
        "completion": "\\d\\d$|[\\d]{3}\\-\\d{3}-\\d{4}(st|nd|rd|th), 0$||[\\d]{1,2}$",
        "passed": false
    },
    {
        "id": 500,
        "completion": "(?i)(^(?:19|20)(?:[11]|0?[1-9])-(?:1|[2-9])[0-9]{3}(?:0|(?:1[6-9]|[12]))?$)\\b",
        "passed": false
    },
    {
        "id": 500,
        "completion": "var patternDate = \"/([0-9]\\d|1[012]\\d)[-/\\s]*([0-9]{4}|1[012]\\4)\";",
        "passed": false
    },
    {
        "id": 500,
        "completion": "",
        "passed": false
    },
    {
        "id": 500,
        "completion": "^(?:20[0-9]\\d|20[1-9]|0[1-9]\\d)\\d{3}(?:(?:(?<!)(?:0?3)\\d{1,2},)?\\d{1,2}(?::\\d+)?(?:(?:(?<!(",
        "passed": false
    },
    {
        "id": 501,
        "completion": ".*([0-9]+)|([,.]*)(0[0-9]*(,0[0-9]*)*[$])",
        "passed": false
    },
    {
        "id": 501,
        "completion": "^\\$\\d+(?:\\.\\d+?)?%$",
        "passed": false
    },
    {
        "id": 501,
        "completion": "",
        "passed": false
    },
    {
        "id": 501,
        "completion": "```import re",
        "passed": false
    },
    {
        "id": 501,
        "completion": "",
        "passed": false
    },
    {
        "id": 501,
        "completion": "",
        "passed": false
    },
    {
        "id": 501,
        "completion": "I can use the [$] and [%] notation in the form of \"[%$]$\" to get both dollars and percent out of the user's input.",
        "passed": false
    },
    {
        "id": 501,
        "completion": "import redef validate(price):    return (re.compile(r\"^\\d+(\\.\\d+)?%|\\$\\d+(\\.\\d+)?\"))",
        "passed": false
    },
    {
        "id": 501,
        "completion": "#^[0-9]*\\.([0-9]*|[1-9]\\d)$",
        "passed": false
    },
    {
        "id": 501,
        "completion": "regex_percentage = \"^[0-9]+(?:\\.[0-9][0-9]?)?(?:%[0-9]+)?$\"",
        "passed": false
    },
    {
        "id": 507,
        "completion": "\\b[A-Z]+\\b",
        "passed": false
    },
    {
        "id": 507,
        "completion": "^[A-Z].*",
        "passed": false
    },
    {
        "id": 507,
        "completion": "\\A[A-Z]+\\Z",
        "passed": false
    },
    {
        "id": 507,
        "completion": "^[A-Z][a-z]*",
        "passed": false
    },
    {
        "id": 507,
        "completion": "\\(^[A-Z][A-Za-z0-9-_\\.]+([a-zA-Z0-9-_\\.]+)*$\\)",
        "passed": false
    },
    {
        "id": 507,
        "completion": "[A-Z] +. # 2.9.3 Using the * Operator for Greedy Matching",
        "passed": false
    },
    {
        "id": 507,
        "completion": "^[A-Z]",
        "passed": false
    },
    {
        "id": 507,
        "completion": "{new String(list.get(0).toUpperCase().toBytes(), encoding=\"utf-8\")}",
        "passed": false
    },
    {
        "id": 507,
        "completion": "\\B(A)(?!\\d)",
        "passed": false
    },
    {
        "id": 507,
        "completion": "^[A-Z]",
        "passed": false
    },
    {
        "id": 512,
        "completion": "(?<!\\.)\\d{3,3},(?!\\.)(?<!\\d)(?!\\.\\d)",
        "passed": false
    },
    {
        "id": 512,
        "completion": "[1-9][0-9]*([1-9][0-9]*)",
        "passed": false
    },
    {
        "id": 512,
        "completion": "[0-9]+([.,][0-9]*)? (1 or more digits before comma or point, then possibly a period, followed by one or more digits after the comma or point)",
        "passed": false
    },
    {
        "id": 512,
        "completion": "(\\d{1,3}(,\\d{3})*(?:\\d{3})?(?:\\,\\d{3})*(?:[N\\D]|$))Explanation: (In this example the '?' after the number groups of digits (1-3, and 3) after the decimal point was only there to get a",
        "passed": false
    },
    {
        "id": 512,
        "completion": "(^[\\d\\.,]{1,3}(?:\\,|[\\d.,]*)((?M:))\\d+$)",
        "passed": false
    },
    {
        "id": 512,
        "completion": "\\d{1,3}(,\\d{3})*(\\.\\d*)? 2.What will be the result of following pattern: \\d{2}(,\\d{2})*?Answer: It will generate a value of 12.2. In this pattern, the expression \\d{2}(,\\d{2",
        "passed": false
    },
    {
        "id": 512,
        "completion": "r\"^[0-9,]+$|(?:[0-9])?\\..?[0-9]{3,}|[0-9,]{3}[0,9]?(?=.[0-9]{0,3})$|(?<=[0-9])?[0-9,]+$|[",
        "passed": false
    },
    {
        "id": 512,
        "completion": "^(\\d{6,3}|(\\d{4,3}|\\d{9,3}))$|[N/A]",
        "passed": false
    },
    {
        "id": 512,
        "completion": "\\d{1,3}(,\\d{3})? N/A",
        "passed": false
    },
    {
        "id": 512,
        "completion": "^[\\d.,]{1,3}$",
        "passed": false
    },
    {
        "id": 519,
        "completion": "(((?<=[a-zA-Z:])(?:(?<=.,)[1-9][1-9]|([1-9],)?[1-9][1-9])|(?<=^)[1-9]{8,9})[a-zA-Z:,]?)+",
        "passed": false
    },
    {
        "id": 519,
        "completion": "^([0-9]{1,8})(?:,|$)$",
        "passed": false
    },
    {
        "id": 519,
        "completion": "(Regex101)^(\\d{1,5}|999[1-9]|999999[1-9])|(999[1-9]{0,6})|(999999[1-9])|(999[1-9][0-9]{0,5})|(999[1-9]{4,5})|(999",
        "passed": false
    },
    {
        "id": 519,
        "completion": "[09,9999999].",
        "passed": false
    },
    {
        "id": 519,
        "completion": "^([1-9](\\d{9})*|(?:9[0-9]|1[0-9]{0,7})?)\\s?$",
        "passed": false
    },
    {
        "id": 519,
        "completion": "/^\\d+,\\d+,\\d+,\\d+,\\d+$/",
        "passed": false
    },
    {
        "id": 519,
        "completion": "'{1,99999999}\\\\d*'",
        "passed": false
    },
    {
        "id": 519,
        "completion": "{1,9}\\d{9}",
        "passed": false
    },
    {
        "id": 519,
        "completion": "^\\d{0,7}|(([1-9]\\d{3,5})|((1[012])[0-9]{2}))",
        "passed": false
    },
    {
        "id": 519,
        "completion": "(?:-[1-9]{8,19}|[0-9]+)[,][0-9]{1}",
        "passed": false
    },
    {
        "id": 523,
        "completion": "\\D{0,100}[a-zA-Z]\\s*",
        "passed": false
    },
    {
        "id": 523,
        "completion": "[a-zA-Z0-9.-]{4,}",
        "passed": false
    },
    {
        "id": 523,
        "completion": "\\d(?:[a-zA-Z]|\\s)*",
        "passed": false
    },
    {
        "id": 523,
        "completion": "(\\d+)\\.?(\\W+)",
        "passed": false
    },
    {
        "id": 523,
        "completion": "This can be done by specifying any combination of alphanumeric and other basic characters, while allowing spaces to be included.",
        "passed": false
    },
    {
        "id": 523,
        "completion": "",
        "passed": false
    },
    {
        "id": 523,
        "completion": "\"Alphanumeric expression: [a-zA-Z0-9 ]\"",
        "passed": false
    },
    {
        "id": 523,
        "completion": "/^\\d[\\w ]*$/",
        "passed": false
    },
    {
        "id": 523,
        "completion": "\\d+ \\w+ $.",
        "passed": false
    },
    {
        "id": 523,
        "completion": "r\"(^[a-zA-Z]+\\s[a-zA-Z]+\\s[a-zA-Z]+\\s[a-zA-Z]+$)\"",
        "passed": false
    },
    {
        "id": 525,
        "completion": "[0-9]{2}\\-[0-9a-f]{5}\\-[0-9a-f]{4}\\-[0-9a-f]{3}[0-9]{2}",
        "passed": false
    },
    {
        "id": 525,
        "completion": "|\\d{3}-\\d{3}-\\d{4}| Exercise 3: Validates a phone number that includes a special symbol (e.g.-5555-5555 or 555-5555 or a hyphen (-)). Write a RegEx for this description. Answer: -?\\d{3}-\\d{3}-\\d{",
        "passed": false
    },
    {
        "id": 525,
        "completion": "^[1-9]\\d{,3}(?:[- ]\\d{3})*$",
        "passed": false
    },
    {
        "id": 525,
        "completion": "(\\d{3})-(\\d{4})",
        "passed": false
    },
    {
        "id": 525,
        "completion": "/(^[-\\d\\.]{0,3}$)([-\\d\\.]{0,3}[-\\d\\.]{2,4}$)/",
        "passed": false
    },
    {
        "id": 525,
        "completion": "[a-zA-Z0-9]*",
        "passed": false
    },
    {
        "id": 525,
        "completion": "The regular expression must match any of the following numbers that have at least 1 dash in the middle, for example, '999-9999-9999' or '999-9999-0999' or '999--9999-0999', and the dash must be the only character in each of these number formats.",
        "passed": false
    },
    {
        "id": 525,
        "completion": "One possible RegEx that validates the any of the new formats of cellular phones numbers in Peru, allowing an optional dash is (^\\d{3}\\-?\\d{2}$|^\\d{3}-?\\d{4}$|^\\d{4}\\s?\\d{5}$)",
        "passed": false
    },
    {
        "id": 525,
        "completion": "|(?:\\d{3}(?:[-\\s]\\d{3}))|(?:\\d{3}(?:[-\\s]\\d{4}))|(?:\\d{5}(?:[-\\s]\\d{4}))Explanation: Regex101 Demo",
        "passed": false
    },
    {
        "id": 525,
        "completion": "^[A-Z]{2}(?:-[0-9]{2})?[A-Z0-9]{4}$",
        "passed": false
    },
    {
        "id": 526,
        "completion": "/[\\d\\$]{3-9}:USD[\\,\\s]?/",
        "passed": false
    },
    {
        "id": 526,
        "completion": "^.*[1,.].*[1,].*[1].*[1].*(,|$)$",
        "passed": false
    },
    {
        "id": 526,
        "completion": "^(?![\\d,\\.])((?!\\d$)(?!\\.$)(?!$)\\d[,]'\\d'\\d)(?=\\d)(^$)",
        "passed": false
    },
    {
        "id": 526,
        "completion": "$[\\d,]{2,}(,){2}\\$",
        "passed": false
    },
    {
        "id": 526,
        "completion": ".*\\,*/\\$\\.*The * inside [^...].* will take anything that is not the character inside the square square brackets. In this case, that is [^././$]The.* will take any character including dots.The / matches any of /.The * will take any character including ( and ) from the outside.All these characters",
        "passed": false
    },
    {
        "id": 526,
        "completion": "(?:[A-Za-z0-9 \\-]{2,}[0-9]{3}(?:, [0-9]{1,2})?[0-9]{8,}$).",
        "passed": false
    },
    {
        "id": 526,
        "completion": "\\d+[\\,]\\d+\\.\\d{2,}",
        "passed": false
    },
    {
        "id": 526,
        "completion": "?\\d{1,2}[,.]?(?:(\\$)|[0-9]{1,2}(?:\\.?\\d*))?$",
        "passed": false
    },
    {
        "id": 526,
        "completion": "^(?:\\d{0,3}\\.)?(?:\\d{2})?(?:,\\d{2})?\\$",
        "passed": false
    },
    {
        "id": 526,
        "completion": "(?i)(?:-?\\d{2,5})(?P<currency>\\$|[,.],?)(?:-?[,.\\d]{2,5})\"\"\",        re.VERBOSE | re.IGNORECASE    )",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms. One",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms. If",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms. You",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.",
        "passed": false
    },
    {
        "id": 527,
        "completion": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.Technically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555- 12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 529,
        "completion": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12",
        "passed": false
    },
    {
        "id": 531,
        "completion": "/^([0-2][0-9])([3-9][0-9])[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$/",
        "passed": false
    },
    {
        "id": 531,
        "completion": "-(\\\\d{4})(-\\\\d{2})(-\\\\d{2})(|[A-Z])\\1\\3.Use the re.match() call to look at the contents of the string to see whether it matched.import re",
        "passed": false
    },
    {
        "id": 531,
        "completion": "^(0(?:/(1|2|4)(?:/4))(0)?$",
        "passed": false
    },
    {
        "id": 531,
        "completion": "(CCYY)_(MM)%2, (CCYY)_(DD)%2, (CCYY)___(DD)%2",
        "passed": false
    },
    {
        "id": 531,
        "completion": "/(([0-9]{4}|[1][0-9]{3})[0-9]{2})([0-9]{2})([0-9]{2})(\\/[0-9]{4})/",
        "passed": false
    },
    {
        "id": 531,
        "completion": "(\\d{4})-(\\d{2})-(\\d{2})[\\s:.](\\d{2})[\\s:.](\\d{4})\\\\1?[\\s:\\.](\\d{2})[\\s:]I'm a bit lost...",
        "passed": false
    },
    {
        "id": 531,
        "completion": "((\\d{4})-(\\d{2})-\\d{2}(?:\\d{2})?([MDDY]{1})?",
        "passed": false
    },
    {
        "id": 531,
        "completion": "((\\d{4}\\s*\\-\\s*\\d{1,2}\\d{1,2}\\s*\\-\\s*\\d{1,2}\\d{1,2})+) Lecture Script: 4.4.2 The Datetime package and its functions",
        "passed": false
    },
    {
        "id": 531,
        "completion": "(?:\\D?\\d\\d\\d\\d\\d\\d\\d\\d\\)\\s\\d{2}(?:\\D?\\d{2}){0,2}(?:\\D?\\d{4}){0,2}$",
        "passed": false
    },
    {
        "id": 531,
        "completion": "(yyyy\\s*mm\\#*dd\\s*[A-Z][a-z\\ ]+)\\s*[:A-Z][a-z\\ ]+.*$",
        "passed": false
    },
    {
        "id": 537,
        "completion": "^(?:\\d|1[5-9]\\d|200[3-9])0?(?:\\.\\d)$",
        "passed": false
    },
    {
        "id": 537,
        "completion": "^([0-9]+)[\\.,]([0-9]+)$",
        "passed": false
    },
    {
        "id": 537,
        "completion": "[^1-3\\.\\d{1,3}]",
        "passed": false
    },
    {
        "id": 537,
        "completion": "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,2}[0-9]{0,3})\\.([1-9][0-9]{0,3})You can use this RegEx to match the three values in order and then extract the number from the fourth position in every match.",
        "passed": false
    },
    {
        "id": 537,
        "completion": "(?P<result>\\d+.\\d{3})",
        "passed": false
    },
    {
        "id": 537,
        "completion": "[0-9.]{3}[0-9,]",
        "passed": false
    },
    {
        "id": 537,
        "completion": "^[0-9]{0,3}(\\.|\\,){0,2}[0-9]{0,3}$",
        "passed": false
    },
    {
        "id": 537,
        "completion": "",
        "passed": false
    },
    {
        "id": 537,
        "completion": "0.000-999.999.(0|[1-9])/[012](0|[1-9])(0|[1-9]\\.)(0|[1-9]\\.)",
        "passed": false
    },
    {
        "id": 537,
        "completion": "[^0-9]{3,}\\.?[0-9]{3,}",
        "passed": false
    },
    {
        "id": 538,
        "completion": "^[ -]?[0-9]+\\.[0-9]{1,3}(?:[0-9]|[e-\\/])([0-9]+)$",
        "passed": false
    },
    {
        "id": 538,
        "completion": "\\b((?:[1-9][0-9]*)|[0-9]{1,2}[1,8]))(?!0)",
        "passed": false
    },
    {
        "id": 538,
        "completion": "\\[(?:\\d+(?:\\.\\d+)?)?\\]",
        "passed": false
    },
    {
        "id": 538,
        "completion": "([-1000\\s,]*\\d+,\\s*[-1000\\s,]*\\d+,\\s*[-1000\\s,]*\\d+)",
        "passed": false
    },
    {
        "id": 538,
        "completion": "(?<!\\d)\\d{,3}\\d(\\d)\\.(\\d{3})",
        "passed": false
    },
    {
        "id": 538,
        "completion": "0\\.0+(-((\\d+)\\.\\d+)\\.)+",
        "passed": false
    },
    {
        "id": 538,
        "completion": "-?[0-9]{1,2}\\.[0-9]{0,3}\\.[0-9]{0,3}",
        "passed": false
    },
    {
        "id": 538,
        "completion": "/(-?0\\d+\\.\\d{3}(?:[eE][-+]?\\d+)?)/",
        "passed": false
    },
    {
        "id": 538,
        "completion": "^(0|[1-9][0-9]*)([.][0-9]+(?:[eE][+-]?[0-9]+)?|[1-9][0-9]*)(?=[eE][+-]?[0-9]*([0-9]|1[0-9]\\d*)*)$",
        "passed": false
    },
    {
        "id": 538,
        "completion": "```\\d{1,3}[\\d-\\.]{0,2}\\d{1,3}```Example 3:",
        "passed": false
    },
    {
        "id": 547,
        "completion": ".*99%|.*%",
        "passed": false
    },
    {
        "id": 547,
        "completion": "\\d+\\.[1-9]\\d*",
        "passed": false
    },
    {
        "id": 547,
        "completion": ".*(99\\.9\\%|00\\.00%)",
        "passed": false
    },
    {
        "id": 547,
        "completion": "0.+99?((1[0-9]|2[0-9]|3[01])%)",
        "passed": false
    },
    {
        "id": 547,
        "completion": "|[^01]|(?=0?.|99?.?)",
        "passed": false
    },
    {
        "id": 547,
        "completion": "[0-9]*%, [0-9]{3}",
        "passed": false
    },
    {
        "id": 547,
        "completion": "1% and",
        "passed": true
    },
    {
        "id": 547,
        "completion": "0\\.001%.",
        "passed": false
    },
    {
        "id": 547,
        "completion": "The regex for between 99.99% and 00.00% would be (?:0[01]|1[0-2][0-9]){2}%, which will match any binary number with 1 in the second bit and the rest of the number is 0's.",
        "passed": false
    },
    {
        "id": 547,
        "completion": "[0-6.5%]:",
        "passed": false
    },
    {
        "id": 550,
        "completion": "J K S R B 33 yo yo 654 ma",
        "passed": false
    },
    {
        "id": 550,
        "completion": "&quot;aE&quot; =",
        "passed": false
    },
    {
        "id": 550,
        "completion": "JK, S, R, B, 33, Yo",
        "passed": false
    },
    {
        "id": 550,
        "completion": "\"j|rk|br|v|n5",
        "passed": false
    },
    {
        "id": 550,
        "completion": "&quot;J K&quot; &amp",
        "passed": false
    },
    {
        "id": 550,
        "completion": "[0-9]|&quot;[J",
        "passed": false
    },
    {
        "id": 550,
        "completion": "&quot;(James|Kramer)(&ap",
        "passed": false
    },
    {
        "id": 550,
        "completion": "[a-z][a-z][a-z",
        "passed": false
    },
    {
        "id": 550,
        "completion": "( [a-zA-Z0-9]+",
        "passed": false
    },
    {
        "id": 550,
        "completion": "&quot;[&quot;a;][",
        "passed": false
    },
    {
        "id": 571,
        "completion": "Regex is: ^(\\d{1",
        "passed": false
    },
    {
        "id": 571,
        "completion": "(and maybe more regexes..)",
        "passed": false
    },
    {
        "id": 571,
        "completion": "",
        "passed": false
    },
    {
        "id": 571,
        "completion": "https://stackoverflow.com/a",
        "passed": false
    },
    {
        "id": 571,
        "completion": "\\d \\w+ - \\w stands",
        "passed": false
    },
    {
        "id": 571,
        "completion": "@B.taylor I know",
        "passed": false
    },
    {
        "id": 571,
        "completion": "(?i)(?!0)[",
        "passed": false
    },
    {
        "id": 571,
        "completion": "@DanMack's answer would do this",
        "passed": false
    },
    {
        "id": 571,
        "completion": "^[0-9]+(-?",
        "passed": false
    },
    {
        "id": 571,
        "completion": "[a-zA-Z]{",
        "passed": false
    },
    {
        "id": 578,
        "completion": "(A-F)+)",
        "passed": false
    },
    {
        "id": 578,
        "completion": "^[A-F]+[ -]?[1-9]\\d*\\.\\d{1,2}$",
        "passed": false
    },
    {
        "id": 578,
        "completion": "",
        "passed": false
    },
    {
        "id": 578,
        "completion": "[0-9][A-M]?[0-9]\\d[A-D\\-M\\?]",
        "passed": false
    },
    {
        "id": 578,
        "completion": "(regexp) [A-F]{1,2}\\d[A-F-]{1,2}\\d[A-F][\\d-]?[A-F]{1,2}\\d[A-F][\\d-]?[A-F]{1,2}\\d[A-F][A-Z]?[\\d]*$",
        "passed": false
    },
    {
        "id": 578,
        "completion": "A-F +, -1, 2, 4, 5, 6, C+ or D+",
        "passed": false
    },
    {
        "id": 578,
        "completion": "",
        "passed": false
    },
    {
        "id": 578,
        "completion": "```Degree: 4+0Major: EnglishMinor: Composition```",
        "passed": false
    },
    {
        "id": 578,
        "completion": "[Character sets and repetition can be used]",
        "passed": false
    },
    {
        "id": 578,
        "completion": "A(A/A-A/A-A/A-A-A/) [or A-F]",
        "passed": false
    },
    {
        "id": 583,
        "completion": "\"D(((0|1\\d)|(0?\\d)|(2[0-9]|0?[1-9]))/(0\\d)|((0\\d)|(0?\\d)|(29((1\\d2?)|(3[01]))))))+\" is your expected regex.",
        "passed": false
    },
    {
        "id": 583,
        "completion": "(\\d+)\\.(\\d+)\\.\\d? or (\\d+)\\.(\\d{2})\\.(\\d{3}) or (\\d{4}) or (\\d{1,2})(?=\\d)(\\d)\\d",
        "passed": false
    },
    {
        "id": 583,
        "completion": "\\b(\\d{2}(?:,\\d{3})?)?(?:[012]\\d)([0-3]\\d|100)([1-9])\\b",
        "passed": false
    },
    {
        "id": 583,
        "completion": "regex-yy(?:\\.[0-9]{2}(?![0-9]))|regex-mm(?:\\.\\.[0-9]{2}(\\-[0-9]{3})*)\\.(?:\\.\\.[0-9]{4}(\\-[0-9]{2})?",
        "passed": false
    },
    {
        "id": 583,
        "completion": "r\"^\\d{1,2}\\.\\d{1,2}\\.\\d{2}$|^\\d{1,2}\\.\\d{2}\\.\\d{2}[\\-\\.\\/]\\d{4}$|^\\d{2}$|^00$\"",
        "passed": false
    },
    {
        "id": 583,
        "completion": "[0-3]+[0-9]{2}:(0[1-9]|[12][0-9]|3[01])??",
        "passed": false
    },
    {
        "id": 583,
        "completion": "\\d{1,2}\\.\\d{1,2}\\.\\d{4}|\\d{1,2}\\.\\d{2}\\d{2}|\\d{4}",
        "passed": false
    },
    {
        "id": 583,
        "completion": "\\(\\d\\d\\.\\d\\d-\\d\\d\\.\\d\\d\\d/\\d\\d\\.\\d\\d-\\d\\d\\.\\d\\d%?\\d%?\\d%?\\d+",
        "passed": false
    },
    {
        "id": 583,
        "completion": "(^\\d|[12][3-9]|30[2-8]\\d)(/[0-9])($|[0-9]\\d)\\\\(?:[0-3]\\\\d|25\\\\1)\\\\([0]|1[012])\\\\0$",
        "passed": false
    },
    {
        "id": 583,
        "completion": "This is not something I am ready to test, but this is my best attempt: ^\\d{1,2}\\s?\\d{1,3}\\s?(\\d{1,4}|[1-6]\\d{2})\\s?(\\d{4}|\\d{2})\\b",
        "passed": false
    },
    {
        "id": 590,
        "completion": "",
        "passed": false
    },
    {
        "id": 590,
        "completion": "[0-9a-fA-F]{16}-[0-9a-fA-F]{",
        "passed": false
    },
    {
        "id": 590,
        "completion": "[xx-xx-xx-xx-xx];[xx-xx-xx-xx-xx]",
        "passed": false
    },
    {
        "id": 590,
        "completion": "The RegEx is [0-9a-z-]{32}\\(.*?\\)[0-9a-z",
        "passed": false
    },
    {
        "id": 590,
        "completion": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx-(\\\\d{32})-(-\\\\d{32})-(-\\\\d{32})\\\\-",
        "passed": false
    },
    {
        "id": 590,
        "completion": "[{[0-9a-f0-9]{32}]-(?=-[0-9a-f",
        "passed": false
    },
    {
        "id": 590,
        "completion": "(x)(?:\\d{32}-(\\d{32})-(\\d{32})){0,1}",
        "passed": false
    },
    {
        "id": 590,
        "completion": "[{8-12-1995}]{6}-[0-9]{6}-[0-9]{6",
        "passed": false
    },
    {
        "id": 590,
        "completion": "",
        "passed": false
    },
    {
        "id": 590,
        "completion": "A32 - A hyphen",
        "passed": false
    },
    {
        "id": 607,
        "completion": "(222 )^[ +",
        "passed": false
    },
    {
        "id": 607,
        "completion": "Accepts optional parens",
        "passed": false
    },
    {
        "id": 607,
        "completion": "^\\d{9}\\",
        "passed": false
    },
    {
        "id": 607,
        "completion": "(((555-",
        "passed": false
    },
    {
        "id": 607,
        "completion": "/^.{2}\\",
        "passed": false
    },
    {
        "id": 607,
        "completion": "(\\\\d{2}",
        "passed": false
    },
    {
        "id": 607,
        "completion": "The RegEx for this description",
        "passed": false
    },
    {
        "id": 607,
        "completion": "If a user entered the phone",
        "passed": false
    },
    {
        "id": 607,
        "completion": "(222)?[ -]",
        "passed": false
    },
    {
        "id": 607,
        "completion": "\\(123)-([",
        "passed": false
    },
    {
        "id": 610,
        "completion": "10:30-11:15",
        "passed": true
    },
    {
        "id": 610,
        "completion": "12/15/18:02:01AM",
        "passed": true
    },
    {
        "id": 610,
        "completion": "(.*)\\.?\\s*((\\d{1,2})\\d{0,2})?(\\d{1,2}\\s*(am|am\\.|pm))?\\.?\\s*(\\d{1,2})\\d{0,2}",
        "passed": false
    },
    {
        "id": 610,
        "completion": "^(\\d?\\d)(?:[a-zA-Z])(\\d?)(\\d{2})?$ 1. 2d10m2. 1m5h...I don't want to do this by writing every RegEx for every case in one string and then comparing to the input (for input validation purposes, for example). Is there a way to come up with a function with this description?Tried",
        "passed": false
    },
    {
        "id": 610,
        "completion": "^[1-9]\\d|1[0-2]?\\d|20",
        "passed": false
    },
    {
        "id": 610,
        "completion": "http://ideone.com/oW9lL9/h1.html#ix3oP/i1$H1$iO$t3$gR",
        "passed": false
    },
    {
        "id": 610,
        "completion": "a1(\\d)(?:(\\s|\\-|\\,|\\/)(\\d)[a-z]|(\\d\\d[a-z])).* Here are a couple of examples:",
        "passed": false
    },
    {
        "id": 610,
        "completion": "(\\d{1,2}):?(\\d{2})\\/(\\d{2}) (\\d{0,2})h (\\d{0,2})(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 610,
        "completion": "",
        "passed": false
    },
    {
        "id": 610,
        "completion": ".*\\d{1,2}(?:[ap](?:m|pm))?\\d{1,2},\\d{2}",
        "passed": false
    },
    {
        "id": 619,
        "completion": "(0[1\\-9]{1,2}\\b | 555[0-9]{2}[\\-\\s]*[0]?[1-9]{4})+",
        "passed": false
    },
    {
        "id": 619,
        "completion": "^6[1-9][-0-9]{3}[-0-9]{3}[-0-9]{4}$",
        "passed": false
    },
    {
        "id": 619,
        "completion": "^$|^\\d{3}-\\d{3}-\\d{4}$",
        "passed": false
    },
    {
        "id": 619,
        "completion": "^(\\+)?(\\d{3})-(\\d{3})-(\\d{4})$",
        "passed": false
    },
    {
        "id": 619,
        "completion": "^-?([2-9]\\d{3}|[1-9]\\d{1,2}-)\\s(\\d{1,4})$",
        "passed": false
    },
    {
        "id": 619,
        "completion": "[0-9]{1,3}-[0-9]{0,3}-[0-9]{0,4}[0-9]{0,3}-[0-9]{0,4}[0-9]{0,3}-[0-9]{0,4}[0",
        "passed": false
    },
    {
        "id": 619,
        "completion": "1\\D*(\\(\\+1\\))\\D*[0-9]{3}\\D*(\\-[0-9]{4})?",
        "passed": true
    },
    {
        "id": 619,
        "completion": "^\\+?\\d{1}-\\d{3}-\\d{3}-\\d{4}$",
        "passed": false
    },
    {
        "id": 619,
        "completion": "\\d{3}\\-\\d{3}\\-\\d{4}$",
        "passed": false
    },
    {
        "id": 619,
        "completion": "[0]{3}-\\ \\[0-9](\\ \\d{3})(?:-\\s\\d{3})?\\.(\\s\\d{4})$",
        "passed": false
    },
    {
        "id": 623,
        "completion": "^\\d{4}\\D{2}$",
        "passed": false
    },
    {
        "id": 623,
        "completion": "[A-9][A-Z]{3}[A-Z]",
        "passed": false
    },
    {
        "id": 623,
        "completion": "(.*)_(.*)JavaScript: http://jsperf.com/zip-code-regex",
        "passed": false
    },
    {
        "id": 623,
        "completion": "\\d{4}[a-z]{2}",
        "passed": false
    },
    {
        "id": 623,
        "completion": "/^([1-9]\\d{1,2}[a-z]){2}$/i",
        "passed": false
    },
    {
        "id": 623,
        "completion": "^[1-9][]?[1-9][-]?[1-9]([a-z]{2})$",
        "passed": false
    },
    {
        "id": 623,
        "completion": "\\b\\d{4}[a-z]{2}\\b",
        "passed": false
    },
    {
        "id": 623,
        "completion": "\\d{4}[a-d]{2}",
        "passed": false
    },
    {
        "id": 623,
        "completion": "(4[0-9])([a-z])(2[0-9])My regex pattern is: (([4][0-9])([a-z])(2[0-9])), I would need to know how to replace this so that when it gets matched to a specific number, it will return that 2 numbers.",
        "passed": false
    },
    {
        "id": 623,
        "completion": "4-digits, 2 lowercase, 2 uppercaseExample:dutchzipreg = '^[a-da-da-d][a-da-da-d-a-d-c-c-c-c-c-c-c]$'",
        "passed": false
    },
    {
        "id": 626,
        "completion": "/^(19|1[6-9]|2[0-9]|275) [0-9]{4}[0-9]/",
        "passed": false
    },
    {
        "id": 626,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 626,
        "completion": "\\d{2}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 626,
        "completion": "",
        "passed": false
    },
    {
        "id": 626,
        "completion": "r\"(0\\\\d\\\\d|1\\\\d\\\\d|2\\\\d\\\\d)\\\\/1\\\\d\\\\/2\\\\d\\\\/3\\\\d\\\\/4\\\\d\\\\/5\\\\d\\\\/6\\\\d\\\\/7\\\\d\\\\/8\\\\d\\\\/9\\\\d\\\\/10\\\\",
        "passed": false
    },
    {
        "id": 626,
        "completion": "(0[0-9]|1[0-2])\\/(0[1-9]|[12][0-9]|3[01])\\/(19|200[0-9])",
        "passed": false
    },
    {
        "id": 626,
        "completion": "\\d{2}(?:\\/\\d{2}(?:\\/\\d{4})?|\\d{4}(\\/\\d{2}))(?: (\\d{2}(?:\\.\\d+)?)|X(?:D(?:M(?:Y(?:S(?:[",
        "passed": false
    },
    {
        "id": 626,
        "completion": "(?<year>\\d{2})/(\\d{2})/(\\d{4})",
        "passed": false
    },
    {
        "id": 626,
        "completion": "```regObj = re.compile(    r'^(?:        \\d{2} (?:(?:[MOM]|[APR]|[BM])) )? (?:\\d{1,2}) (?: / (?:, (?: \\d{4})?)",
        "passed": false
    },
    {
        "id": 626,
        "completion": "^19\\d{1,2}(\\/\\d{1,2})\\d{1,2}(\\-(\\d{2}))? \\d{4,}.+$",
        "passed": false
    },
    {
        "id": 627,
        "completion": "[1-4][0-9][1-9][0-9][0-9][0-9][0-9]/[0-9][1-9][0-9][0-9][0-9]/[0-9][0-9][0-9][0-9][0-9]Notice that it does not",
        "passed": false
    },
    {
        "id": 627,
        "completion": "((\\d+)/(\\d+))/(\\d+)",
        "passed": false
    },
    {
        "id": 627,
        "completion": "[0-9][0-9][0-9][0-9]/[0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9]",
        "passed": false
    },
    {
        "id": 627,
        "completion": "DATE(19*(m+(month%4))-((year/4)-((year/100)/4))+1/31)This one should be easy.DD/MM/YYYY with a different number of days per month.Dates &gt;=1901 &lt;=2999.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 627,
        "completion": "[0-9]\\d{2}[/\\-\\w]|20\\d[7-9]/[0-9]\\d{4} - 2019I hope these examples were useful.",
        "passed": false
    },
    {
        "id": 627,
        "completion": "/^(?:[01]\\d|2[0-3])\\d{1,2}-\\d{1,2}-\\d{4} \\d{2}:\\d{2}:/",
        "passed": false
    },
    {
        "id": 627,
        "completion": "ddd-mm-yyyyDates &gt;=2800 &lt;=2999.Generate a RegEx for this description.Answer: dd-mm-yyyyDates &gt;=31000 &lt;=2999.Generate a RegEx for this description.Answer: dd-mm-yyyyDates &",
        "passed": false
    },
    {
        "id": 627,
        "completion": "DD/MM/YYYY \\d/\\d/\\d\\d",
        "passed": false
    },
    {
        "id": 627,
        "completion": "\\d{1,2}(\\/)?\\d{1,2}(\\/)?\\d{4}.*$",
        "passed": false
    },
    {
        "id": 627,
        "completion": "(?!(?:[0-9]{3})(?=[1-8][0-9])|(?=[1-9][12345])[12]\\d{3})This is the Japanese Month Format. Generate a RegEx for this description. Answer:(-?[9]\\d*)\u5e74[0-",
        "passed": false
    },
    {
        "id": 634,
        "completion": "^(0|1|2|3|4|5|6|7|8|9)|([1|2]|[3|4]|[5|6|7|8|9])([0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|[8]|[9])$",
        "passed": false
    },
    {
        "id": 634,
        "completion": "\\b[1-9][0-9]*\\b",
        "passed": false
    },
    {
        "id": 634,
        "completion": "^((|)(0([0,1]{1}[0-9]{3})|1([0,1]{2}[0-9]{4})|2([1,2]{3}[0-9]{3})1|3([1,2]{3}[0-9]{3})|40[0-1]{8})|101[0,1]{2}$",
        "passed": false
    },
    {
        "id": 634,
        "completion": "(\\d+)",
        "passed": false
    },
    {
        "id": 634,
        "completion": "(1?|2?|3?|4?|5?|6?|7?|8?|9?) and a counter for its occurrence which you increment by 1. As you progress in your studies, you will notice the intricate role of patterns and sequences in problem-solving and mathematical reasoning. They are not just a tool for manipulation but a fascinating journey towards understanding the intricacies of our world. So, embrace the power of patterns and unlock a world of mathematical wonders that lie within.",
        "passed": false
    },
    {
        "id": 634,
        "completion": "\\d{1,100}.",
        "passed": false
    },
    {
        "id": 634,
        "completion": "1|2|3|4|...|100",
        "passed": true
    },
    {
        "id": 634,
        "completion": "This pattern matches any digit from 0-9.          ([0-9])$",
        "passed": false
    },
    {
        "id": 634,
        "completion": "[1-9]\\d[89] (explanation included)",
        "passed": false
    },
    {
        "id": 634,
        "completion": "/^\\d+(?:\\.\\d+)$/",
        "passed": false
    },
    {
        "id": 635,
        "completion": "\\d{1,2}:[0-]\\d{2}(?:[.]\\d{1,2})",
        "passed": false
    },
    {
        "id": 635,
        "completion": "[0-9]{1,}, [0-9]{1,}, 00:00:00)",
        "passed": false
    },
    {
        "id": 635,
        "completion": "\\d{2}:\\d{2}((\\s|-)\\d{2}(\\s|-)\\d{2})",
        "passed": false
    },
    {
        "id": 635,
        "completion": ".[0123456789abcdef]{2}:[23456789abcdef]{2}[1-9][0-9]*",
        "passed": false
    },
    {
        "id": 635,
        "completion": "(^[0-9]{2}:[0-9]{2}[:][0-9]{2}.[0-9]{2}[Tt]$|^[0-9]{4}-[3][0-9]/[1]$|^[0",
        "passed": false
    },
    {
        "id": 635,
        "completion": "//create a function to create a regex that will test this query.//this function is a function of a class with 2 methods. The //  first method to test this function needs to return one or the //  other. This should be true iff the query passes and false otherwise//",
        "passed": false
    },
    {
        "id": 635,
        "completion": "[0-9]{0,2}:[0-9]?[0-9]{0,4}((?)(pm|Pm|a.m|A.M)? )\\/[0-9]{4}My guess is this could be written much more simply as0-",
        "passed": false
    },
    {
        "id": 635,
        "completion": "\\d(\\d?:\\d)|\\d\\d[:\\s](\\d\\d)Sample code...CREATE FUNCTION DATEDIFF (    @date1 datetime,    @date2 datetime,    @time zone    AS NVARCHAR(100))",
        "passed": false
    },
    {
        "id": 635,
        "completion": "",
        "passed": false
    },
    {
        "id": 635,
        "completion": "(30,00)MS-SQL is also more strict than RDBMS, e.g. it will reject dates that are less than 31 days old except for leap years. If you are using RDBMS it will ignore the time and accept this format however if you are using MS-SQL will reject dates like 30",
        "passed": false
    },
    {
        "id": 637,
        "completion": "\\b[a-z]{1}[ -][a-z]{1}[ -][a-z]{1}[ -][a-z]{1}\\b",
        "passed": false
    },
    {
        "id": 637,
        "completion": "^[^a-zA-Z]* [-a-zA-Z]*$",
        "passed": false
    },
    {
        "id": 637,
        "completion": "[a-zA-z ]+-?[a-zA-Z ]*",
        "passed": false
    },
    {
        "id": 637,
        "completion": "NAME_REGEX = r'^[a-zA-Z ]*$|^[a-zA-Z-]+$'",
        "passed": false
    },
    {
        "id": 637,
        "completion": "[A-Za-z 0-9]{1,}(-[A-Za-z 0-9]+)[A-Z][A-Za-z0-9]",
        "passed": false
    },
    {
        "id": 637,
        "completion": "^",
        "passed": false
    },
    {
        "id": 637,
        "completion": "\\b(?:(A-Z[a-z]|[A-Z][a-z]|[A-Z]S[A-Z][a-z])(\\-| )?[A-Z](?:[a-z]|[A-Z])?)\\b",
        "passed": false
    },
    {
        "id": 637,
        "completion": "^(?=.{1,15}$)[A-z0-9 -]{1,128}$",
        "passed": false
    },
    {
        "id": 637,
        "completion": "`^[a-zA-Z0-9 ]+$`.",
        "passed": false
    },
    {
        "id": 637,
        "completion": "\\b([A-Z][a-z]+( [A-Z][a-z]+)*)\\.?\\b",
        "passed": false
    },
    {
        "id": 639,
        "completion": "[01/01-29/99] - [01/01/1900 - 01/01/1930]I hope this helped.",
        "passed": false
    },
    {
        "id": 639,
        "completion": "[0-9]+(M|Y)(st)|[0-9]+(M|st)th|(M|S)(th)|[0-9]+(M|st)th(rd)|[0-9]+M(st)(rd)th(st)th(st)th[0-9]",
        "passed": false
    },
    {
        "id": 639,
        "completion": "[M-m-y]{2}[0-9]{4}",
        "passed": false
    },
    {
        "id": 639,
        "completion": "^[0-9]{3,}-[0-9]{1,2}$",
        "passed": false
    },
    {
        "id": 639,
        "completion": "\\d{4}/\\d{2}",
        "passed": false
    },
    {
        "id": 639,
        "completion": "var regEx = new RegExp(\"(0?[1-9]\\d?)/$|(1?[0-2]\\d?)/$|(.{4,})(?!.*\\d)\",                      \"i|x|a\");",
        "passed": false
    },
    {
        "id": 639,
        "completion": "[M|Mm|Mt|Mc|Th|Tu|Ww|Thw|Ff|Gg|Gh|Ii|Ja]{1,}/{1,2}[0-9]{1,2}[0-9]{1,2}/[0-9]{4}",
        "passed": false
    },
    {
        "id": 639,
        "completion": "\"^([0-9]{2})/([0-9]{4})$\"",
        "passed": false
    },
    {
        "id": 639,
        "completion": "\\d{2,4} (date)  \\d{4}-\\d{3}-\\d{2,4} (years)",
        "passed": false
    },
    {
        "id": 639,
        "completion": "%Y/%m/%d",
        "passed": false
    },
    {
        "id": 640,
        "completion": "[^-]*-[0-2][0-9]|[0-2][0-9]",
        "passed": false
    },
    {
        "id": 640,
        "completion": "(\\+0?[1-9][0-9]|1[0-2]0|[1-9])[0-9]{3}Z|-11[0-2]0$",
        "passed": false
    },
    {
        "id": 640,
        "completion": "\\[\\d{1,2}:\\d{1,2}:\\d{2}\\]",
        "passed": false
    },
    {
        "id": 640,
        "completion": "[(2.*)\\+(2.*)\\s*(0.*)]",
        "passed": false
    },
    {
        "id": 640,
        "completion": "\\d{1,2}:\\d{2}:\\d{2}",
        "passed": false
    },
    {
        "id": 640,
        "completion": "The pattern should start with any minute from 0-59, followed by a colon, then the number of hours from 1-24 (0-23) followed by a colon, then the minutes from 0-59.",
        "passed": false
    },
    {
        "id": 640,
        "completion": "(^(0[1-9][0-9]|1[0-2])(0[1-9]|[12][0-9]),([A-Z]{2})([/|.?!])?\\d$",
        "passed": false
    },
    {
        "id": 640,
        "completion": "(2[0-9][1-9]|1[012]|[1323][0-9]):[0-5][0-9]",
        "passed": false
    },
    {
        "id": 640,
        "completion": "\\d:\\d\\d(AM|PM)",
        "passed": false
    },
    {
        "id": 640,
        "completion": "",
        "passed": false
    },
    {
        "id": 641,
        "completion": "^(0[1-9]|1[012])\\.?(0?[1-9])$",
        "passed": false
    },
    {
        "id": 641,
        "completion": "(.*)",
        "passed": false
    },
    {
        "id": 641,
        "completion": "\\d{1,2}  |  \\d{1,3}  |  \\d{1,4}",
        "passed": false
    },
    {
        "id": 641,
        "completion": "^[0-9]*(( [0-9]|1[0-2])?([03]?)[0-9]|0[1-9]):( [0-9]):[0-9]([0-9])$",
        "passed": false
    },
    {
        "id": 641,
        "completion": "12 hour time format: (\\d{2})\\s*([ap]m)(\\d:\\d{2})",
        "passed": true
    },
    {
        "id": 641,
        "completion": "[[:digit:][:digit:][:]digit](:[.\\s][:digit:][:digit])*",
        "passed": false
    },
    {
        "id": 641,
        "completion": "1. ^[0-9]+ \\s+:$; 2. ^[0-9]+:; 3. ^[0-9]+ \\s+:$; $",
        "passed": true
    },
    {
        "id": 641,
        "completion": "10:45PM",
        "passed": true
    },
    {
        "id": 641,
        "completion": "/^([0-9]{0,2}):([0-9]{0,2}):([0-9]?)(am|pm)?$/",
        "passed": false
    },
    {
        "id": 641,
        "completion": "(00|12) [0-9]{2} ([0-9]{2}) ([0-9]{2})",
        "passed": false
    },
    {
        "id": 645,
        "completion": "r'^\\d+(ft | in)$';",
        "passed": false
    },
    {
        "id": 645,
        "completion": "\\d+ \\w*(\\w+ \\w* \\w*)?",
        "passed": false
    },
    {
        "id": 645,
        "completion": "\\d?(?:(?=\\bfeet\\b)|(?<=\\binches\\b))\\sI hope this helped.",
        "passed": false
    },
    {
        "id": 645,
        "completion": "(?:(\\d{1,2}) *[ft-in])?",
        "passed": false
    },
    {
        "id": 645,
        "completion": "((\\d{3})[.\\d]?)(inch|foot)",
        "passed": false
    },
    {
        "id": 645,
        "completion": "^(\\d{1,2}\\[)(\\d{1,2})\\[/(\\d{1,2})\\]$",
        "passed": false
    },
    {
        "id": 645,
        "completion": "\"([A-Za-z]+)([0-9]+)[\\\\/?:,!@#$%^&*()]*(?:\\\\.[0-9]+)?\"",
        "passed": false
    },
    {
        "id": 645,
        "completion": "^([0-9]{1,2})([0-9]{2})([0-9]{,2})(\\s.*\\(.*\\))$",
        "passed": false
    },
    {
        "id": 645,
        "completion": "^\\s*\\d((?:(\\d)\\ 2)?|(\\d)\\s\\d*)\\sIN($& / &quot;)|(?:(?:(\\d) \\d\\,)+)|(?:^\\s*\\d\\s*\\sIN$&)$|(?:^\\s*\\d\\s*: \\d$&)|(^\\s*\\d\\:\\d\\ s$&)|(^\\s*\\d",
        "passed": false
    },
    {
        "id": 645,
        "completion": "\\d{1,2}[ft\\s]?[in\\s]?",
        "passed": false
    },
    {
        "id": 647,
        "completion": "([1-9]?\\d*\\.?|0)",
        "passed": false
    },
    {
        "id": 647,
        "completion": "/%d[\\.]\\d*%/gm",
        "passed": false
    },
    {
        "id": 647,
        "completion": "[\\d+\\.]*([\\+\\-]\\d+(?:[.][\\d+\\-]*)*).*",
        "passed": false
    },
    {
        "id": 647,
        "completion": "^(?=.*\\d+)(?=.*\\.\\d+).*$Explanation",
        "passed": false
    },
    {
        "id": 647,
        "completion": "^(?=0(?:\\.1*)?[0-9a-fA-F]{1,64})(?![0-9]*\\.\\.\\.[0-9-])(?=0x)?(?=0[xX][0-9a-fA-F]{1,4})$",
        "passed": false
    },
    {
        "id": 647,
        "completion": "",
        "passed": false
    },
    {
        "id": 647,
        "completion": "/[-+]?\\d*\\.?\\d+(e-\\d+)?/gu",
        "passed": false
    },
    {
        "id": 647,
        "completion": "^[-+]?\\d(0|[1-9]\\d*)([\\./]\\d+)?$",
        "passed": false
    },
    {
        "id": 647,
        "completion": "^[1-9][0-9]{0,2}[0-9]\\.?[0-9]\\.[0-9]?$",
        "passed": false
    },
    {
        "id": 647,
        "completion": "@\"-?\\d*\\.?\\d*$\"",
        "passed": false
    },
    {
        "id": 652,
        "completion": "\\b[1-9]?[0-9]*(?:\\.[0-9]+)?(?![0-9])\\b",
        "passed": false
    },
    {
        "id": 652,
        "completion": "int.TryParse(string);",
        "passed": false
    },
    {
        "id": 652,
        "completion": "r\"(^\\d+$)|(^[^.0-9]+$)|(^0+$)|(^[^.0-9]$)\"",
        "passed": false
    },
    {
        "id": 652,
        "completion": "0(\\\\d+)(\\\\.)(\\\\d+)",
        "passed": false
    },
    {
        "id": 652,
        "completion": "^\\d*$",
        "passed": false
    },
    {
        "id": 652,
        "completion": "\"^([0-9]|[1-9][0-9]|1[012])[0-9]*$\"I got my brain twisters wrapped, thank you.",
        "passed": false
    },
    {
        "id": 652,
        "completion": "",
        "passed": false
    },
    {
        "id": 652,
        "completion": "\\d+|\\+?\\d+|\\d|\\D+",
        "passed": false
    },
    {
        "id": 652,
        "completion": "/^[0-9]+$/You can read more about this here : http://www.regular-expressions.info/floatingpoint.html",
        "passed": false
    },
    {
        "id": 652,
        "completion": "\"^\\d+$\"Then take the number that is captured, if its not captured, it wont get the numbers after the dot, so it makes the code less repetitive:\"^\\d+(?:\\.\\d+){0,1}$",
        "passed": false
    },
    {
        "id": 654,
        "completion": "(\\\\s|-|\\\\.)?\\d{3}(?:\\(..\\)\\d{3}|\\s)?\\d{3}(?:\\-\\d{3})?)",
        "passed": false
    },
    {
        "id": 654,
        "completion": "/^\\+(?:\\(?[1-9][0-9]?)?(?:[- ]?[1-9][0-9]?)?$|\\+?[1-9][0-9]?$/i",
        "passed": false
    },
    {
        "id": 654,
        "completion": "\\d[a-zA-Z-]*[-a-zA-Z]*",
        "passed": false
    },
    {
        "id": 654,
        "completion": "^(\\+?)([0-9]{3})(\\s[0-9]{2})?$ if area code is entered, else match any amount of digits that is not preceded by a space, the only allowed character to follow is a digit(0-9).3. Write and test a RegEx for a title. The",
        "passed": false
    },
    {
        "id": 654,
        "completion": "[a-z]{3,13}[-\\\\ ]?[0-9]{3}",
        "passed": false
    },
    {
        "id": 654,
        "completion": "'([ \\d.]+)'",
        "passed": false
    },
    {
        "id": 654,
        "completion": "^(\\d{3})-?\\d{3}-?\\d{4}$",
        "passed": false
    },
    {
        "id": 654,
        "completion": "\\b(?:25|254)\\d{6}\\b|\\(25|254\\)?\\d{6}\\b 2. You are writing a program that matches any file name that fits in the following format. \"file.ext\" where \".\" represents a file extension. Generate a RegEx for this description.Answer: ^",
        "passed": false
    },
    {
        "id": 654,
        "completion": "/(?:[2-9]\\d?|1[5-9]\\d|2[5-8][0-9]|25(?:2[5-8])?)\\d{9}/",
        "passed": false
    },
    {
        "id": 654,
        "completion": "^(\\d\\d-)?\\d{3}(\\s?\\(|\\)|\\d)$ | #(?<area_code>(|-)*\\d{3}(?<spaces>)?\\(?|\\))    | (?:^\\d{3}(\\s?)\\d\\d$|",
        "passed": false
    },
    {
        "id": 655,
        "completion": "^(?:[\\+\\-\\.]|\\.0{0,1})[\\d]*$",
        "passed": false
    },
    {
        "id": 655,
        "completion": "(\\d\\.\\d+|\\d+\\.\\d|0+\\.\\d+|\\d+)",
        "passed": false
    },
    {
        "id": 655,
        "completion": "\\+.+\\.",
        "passed": false
    },
    {
        "id": 655,
        "completion": "[0-9]\\.[0-9]\\.[0-9]+\\.|[0-9]\\.",
        "passed": false
    },
    {
        "id": 655,
        "completion": "(?>-?\\d*(?:\\.\\d+)?)(?:\\s*\\-)?",
        "passed": false
    },
    {
        "id": 655,
        "completion": "^[-+]?((0)(0.)?)$",
        "passed": false
    },
    {
        "id": 655,
        "completion": "(\\d+\\.)?[0-9.]+(?:\\.[0-9.]+)This is exactly",
        "passed": false
    },
    {
        "id": 655,
        "completion": "r\"\\d+(\\.\\d+)?(-\\d+)?$\"",
        "passed": false
    },
    {
        "id": 655,
        "completion": "/([-+]?\\d+\\.\\d+)/gm",
        "passed": false
    },
    {
        "id": 655,
        "completion": "^[\\d.-]*$",
        "passed": false
    },
    {
        "id": 656,
        "completion": "I did. Here it is. ^\\d{2}\\.\\d{4}$",
        "passed": false
    },
    {
        "id": 656,
        "completion": "\\d",
        "passed": false
    },
    {
        "id": 656,
        "completion": "\\d+.*",
        "passed": false
    },
    {
        "id": 656,
        "completion": "(\\w+)(\\d)?\\s*(\\1?)$",
        "passed": false
    },
    {
        "id": 656,
        "completion": "^[0-9]*$",
        "passed": false
    },
    {
        "id": 656,
        "completion": "(.+)$",
        "passed": false
    },
    {
        "id": 656,
        "completion": "(.{1,5})\\s",
        "passed": false
    },
    {
        "id": 656,
        "completion": "\\d\\d$Exercise 2: Use your RegEx to get the value of \"C3H8O2\" for Hydrogen Peroxide. Answer: C3H8O2",
        "passed": false
    },
    {
        "id": 656,
        "completion": "(^|$)(?:\\d+)",
        "passed": false
    },
    {
        "id": 656,
        "completion": "(([0-9]+)%$)(?=\\s[^\\n\\r]*$)",
        "passed": false
    },
    {
        "id": 660,
        "completion": "^0x[0-9a-fA-F]{1,16}$",
        "passed": false
    },
    {
        "id": 660,
        "completion": "r'^[0-9A-Fa-f]+\\s[0-9A-Fa-f]+\\s[0-9A-Fa-f]+\\s[0-9A-Fa-f]+\\s[0-9A-Fa-f]+$'",
        "passed": false
    },
    {
        "id": 660,
        "completion": "re.compile(r'^[a-fA-F0-9]{2}\\s?[a-fA-F0-9]{2}\\s?[a-fA-F0-9]{2}\\s?[a-fA-F0-9]{3}$')",
        "passed": false
    },
    {
        "id": 660,
        "completion": "^\\s*(?:[0-9a-f\\s]*){6}$",
        "passed": false
    },
    {
        "id": 660,
        "completion": "^[0-9a-fA-F ]{8}$",
        "passed": false
    },
    {
        "id": 660,
        "completion": "\\d{2}[a-fA-F6-9]\\s$",
        "passed": false
    },
    {
        "id": 660,
        "completion": "[0-9A-Fa-f]{1,6}",
        "passed": false
    },
    {
        "id": 660,
        "completion": "^\\s*[A-Fa-f0-9][A-Fa-f0-9 ]{14}\\s*$",
        "passed": false
    },
    {
        "id": 660,
        "completion": "`^[a-f0-9ab-f0-9]{6}$`",
        "passed": false
    },
    {
        "id": 660,
        "completion": ".{3,6} (3 or 5 digits) followed by a space, followed by three more digits (hex code representation).",
        "passed": false
    },
    {
        "id": 673,
        "completion": "(?i)[^\\.][^\\+\\s]\\w+ (.*?) \\+ [^\\+\\s]\\w+",
        "passed": false
    },
    {
        "id": 673,
        "completion": "/^\\d{1,3}\\.\\d{1,3}\\.\\d{2}$/",
        "passed": false
    },
    {
        "id": 673,
        "completion": "r\"([^\\d.]+@[^\\d.]+)\"",
        "passed": false
    },
    {
        "id": 673,
        "completion": "re_description = \"^SMTP Server|SMTP_Handler|SMTP_Port|SMTP_IP\\|SMTP_TLS|SMTP_Encoding\\|SMTP_Authentication$\"",
        "passed": false
    },
    {
        "id": 673,
        "completion": "[A-Za-z\\w\\_]{1,20}",
        "passed": false
    },
    {
        "id": 673,
        "completion": "[(\\w).*?(\\w)]",
        "passed": false
    },
    {
        "id": 673,
        "completion": "",
        "passed": false
    },
    {
        "id": 673,
        "completion": "r'^s[a-z0-9_\\-]+(\\.smtp)$'",
        "passed": false
    },
    {
        "id": 673,
        "completion": "\\b(test[.-]+?@[.](com|edu|org|gov)+?)\\b",
        "passed": false
    },
    {
        "id": 673,
        "completion": "$(\"#[a-z]{3})([A-Z]{1})([0-9]{1})$",
        "passed": false
    },
    {
        "id": 676,
        "completion": "",
        "passed": false
    },
    {
        "id": 676,
        "completion": "^([0-9]{9})\\/([0-1][0-9]|2[0-3])\\/([0-3][0-9]|4[0-9]) ([0-9]{2}",
        "passed": false
    },
    {
        "id": 676,
        "completion": "var regex = new RegExp(\"((?:19\\d{4})|(?:(?:1?:0?\\d{2}|1:0?\\d{0,2})?(?:30|31|[01])",
        "passed": false
    },
    {
        "id": 676,
        "completion": "/(\\/\\d{1,2}\\/\\d{1,2}\\/\\d{4})(\\d{1,2}:\\d{1,2}:\\d{2,4})(\\s|\\,|",
        "passed": false
    },
    {
        "id": 676,
        "completion": "/(?P<year>[0-9]{4}[0-9]{2}[0-9]{1,2})(?:-)?(?P<month>[0-9]{1,2})(?:",
        "passed": false
    },
    {
        "id": 676,
        "completion": "/(\\d{4}\\-\\d{1,2}\\-\\d{1,2}\\T\\d{1,2}\\h:\\d{1,2}\\:\\d{1,2}|[0-1][0",
        "passed": false
    },
    {
        "id": 676,
        "completion": "\\d\\d[.]\\d\\d\\/[.]\\d\\d\\/\\d\\d[:]\\d\\d\\dZ/\\d\\d\\d\\d\\d-\\d\\d\\d-\\d\\",
        "passed": false
    },
    {
        "id": 676,
        "completion": "var match = testDate.match(new RegExp(descRegex, 'g'));if (!match || (match.length!= 8 || match[0].length!= 4 || match[6].length!= 2) || match[0",
        "passed": false
    },
    {
        "id": 676,
        "completion": "(?<![A-Za-z0-9._-])-?\\d\\d(?![A-Za-z0-9-])?(?<![A-Za-z0-9",
        "passed": false
    },
    {
        "id": 676,
        "completion": "var dates = [ \"1940-09-10\", \"1952-00-01\", \"1907-08-01\"];var pattern = \"/([\\-\\d]\\d\\d)([\\-\\d]\\d\\",
        "passed": false
    },
    {
        "id": 678,
        "completion": "([0-9]{7})([0-9]{3})(",
        "passed": false
    },
    {
        "id": 678,
        "completion": "^\\+[+]?[1-9]\\d{3}-",
        "passed": false
    },
    {
        "id": 678,
        "completion": "[A-ZZ]{4}[A-Za-z0-9",
        "passed": false
    },
    {
        "id": 678,
        "completion": "\\(?[1-9][0-9]{7,9}\\)?",
        "passed": false
    },
    {
        "id": 678,
        "completion": "^(\\d{1,3}\\s\\d{3,5})\\s",
        "passed": false
    },
    {
        "id": 678,
        "completion": "\\((-?(1[47]\\d|2[01]\\d",
        "passed": false
    },
    {
        "id": 678,
        "completion": "^\\d\\s?\\d{3}\\s?\\d{2",
        "passed": false
    },
    {
        "id": 678,
        "completion": "(^\\(?((1|2)\\d\\)?[0]?[",
        "passed": false
    },
    {
        "id": 678,
        "completion": "^((1[9]|2[0-9]|3[01])",
        "passed": false
    },
    {
        "id": 678,
        "completion": "\\d{7,12}",
        "passed": false
    },
    {
        "id": 684,
        "completion": "^(?=.*\\d)(?=.*[a-z])[a-zA-Z]{>6}$",
        "passed": false
    },
    {
        "id": 684,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{6,}$",
        "passed": false
    },
    {
        "id": 684,
        "completion": "^[a-zA-Z\\d]{6,}\\z",
        "passed": false
    },
    {
        "id": 684,
        "completion": "^(?=.*[a-z])(?=.*\\d)(?=.{7,}).*$",
        "passed": false
    },
    {
        "id": 684,
        "completion": "^[a-zA-Z]+[0-9]{6,}$",
        "passed": false
    },
    {
        "id": 684,
        "completion": "(^[a-z]*\\d[a-z]{5,}$)",
        "passed": false
    },
    {
        "id": 684,
        "completion": "https://regex101.com/#/qJ1Y5d1C/7",
        "passed": false
    },
    {
        "id": 684,
        "completion": "^[a-zA-Z0-9]{8,50}$",
        "passed": false
    },
    {
        "id": 684,
        "completion": "[a-zA-Z\\d]{6,100}",
        "passed": false
    },
    {
        "id": 684,
        "completion": "[a-zA-Z]\\d{5,}.",
        "passed": false
    },
    {
        "id": 688,
        "completion": "(?<![^\\d\\.])(?:29|30)\\d\\d?(?![^\\d\\.])(?<!20\\d)\\d(?!00[12])[A-Za-z]{3}\\d{4} (Jan|Feb|Mar|",
        "passed": false
    },
    {
        "id": 688,
        "completion": "/(0[1-9]\\d|1\\d\\d|2[0-3])[.-](0[1-9]|1\\d|2[0-3])/gm",
        "passed": false
    },
    {
        "id": 688,
        "completion": "\\d{1,2}[-/.]\\d{1,2}[-/.?]\\d{4}",
        "passed": false
    },
    {
        "id": 688,
        "completion": "\\d{2}\\.\\d{2}\\.\\d{4}(, \\d{2}\\.\\d{2} (?:[+-][0-9]\\d{4})?|24)\\d{4}",
        "passed": false
    },
    {
        "id": 688,
        "completion": "^[1-9][0-9]*(\\.[0-9]+)?[0-9]{2}[0-9]{3}$",
        "passed": false
    },
    {
        "id": 688,
        "completion": "[0-9]{2}.?:[0-9]{2}.?:[0-9][0-9](-[0-9])[0-9](-[0-9](-[0-9]))[0-9]([0-9])([0-",
        "passed": false
    },
    {
        "id": 688,
        "completion": "(^0+0+|0+|(0?[01][12]|1?[0-2]))-0(0?[1-9])|18{1,2}(\\/\\d{4})    For German periods from 1.1.2000 to 31.",
        "passed": false
    },
    {
        "id": 688,
        "completion": "(0[1-9]|1[012])/(0[1-9]|[12][0-9])/(2000[0-9][0-9]|2099[0-9])/([0-9]{3})([.][0-9]{3",
        "passed": false
    },
    {
        "id": 688,
        "completion": "((?<!\\\\d.*?\\\\d\\\\d.)|(?<!\\\\d.\\\\d.)|(?<!\\\\d.)|(?<!\\\\d\\\\.\\\\d.)|(?<!\\\\.\\\\d.)|(?<!\\\\d.\\\\.)|",
        "passed": false
    },
    {
        "id": 688,
        "completion": "^(([0]|1[0-9])([/ 0-9\\-_ ]){0,4}[0-9]|25|(\\\\1)|\\\\D)|(2[0-4][0-9]|20[0-2])$",
        "passed": false
    },
    {
        "id": 689,
        "completion": "/((\\\\w\\\\s*){1}[,\\\\s*]+\\\\(([\\\\w\\\\s]+){1}\\\\))*|(?<!/*)(^|\\\\*/)(\\\\*/)(?!\\\\*/)|//((\\\\w\\\\s*){1}\\\\s*|\\\\s*(([\\\\w\\\\s]+){1}))*)/gm/y;",
        "passed": false
    },
    {
        "id": 689,
        "completion": "/(?:[\\s=])?",
        "passed": false
    },
    {
        "id": 689,
        "completion": "^[!\\s]*(?:\\n|[^\\s]*)\\n[!\\s]*$",
        "passed": false
    },
    {
        "id": 689,
        "completion": "/(?:\\n|\\r|//)\\S+/g",
        "passed": false
    },
    {
        "id": 689,
        "completion": "/(//)(\\s+\\*/|[^\\n]+)\\n?(//|\\Z|[^\\n]|\\n)+/g",
        "passed": false
    },
    {
        "id": 689,
        "completion": "(?!.*\\?\\.)(?:[^\\r\\n?]*\\?.*\\?)(?:(.*?\\#)(?:[^\\r\\n?]*\\?.*\\?)(?:(.*?\\;)(?:[^\\r\\n?]*\\?.*\\?)(?:(.*?)(?:;)(?:[\\r\\n?]*\\?.*\\?)(?:[\\",
        "passed": false
    },
    {
        "id": 689,
        "completion": "^#(\\s|\\S)+(?!#|\\s)",
        "passed": false
    },
    {
        "id": 689,
        "completion": "[\\s\\S]*?(?=(\\n|\\r|\\r\\n)[^\\s\\n]*$)I'm posting the answer as an example for explanation of regex rather than post to this forum as you can find plenty of other examples here.The regex is explained with demo on regex101:(?=(\\n|\\r|\\r\\n)[~]*$)",
        "passed": false
    },
    {
        "id": 689,
        "completion": "^((*\\s*[^\\n]*+\\n|[^\\t]*+\\t)+)+$",
        "passed": false
    },
    {
        "id": 689,
        "completion": "\"//.*\\\\n.*\"; (In the same regexp the. will also match new lines)",
        "passed": false
    },
    {
        "id": 693,
        "completion": ".|\\![a-zA-z]+(\\.[a-zA-z]+)?$",
        "passed": false
    },
    {
        "id": 693,
        "completion": "",
        "passed": false
    },
    {
        "id": 693,
        "completion": ".*\\.\\([a-zA-Z0-9]+\\)\\.([a-zA-Z0-9]+\\.\\).*\\.\\([a-zA-Z0-9]+\\)\\.([a-zA-Z0-9]+\\.\\).",
        "passed": false
    },
    {
        "id": 693,
        "completion": ".net\\..*4. Write a RegEx pattern to match a string that starts with a number, followed by alphanumeric characters or underscores. Hint: Use a string literal to specify your pattern, and escape the backslashes if needed.```pythonimport re",
        "passed": false
    },
    {
        "id": 693,
        "completion": ".*jpeg.*",
        "passed": false
    },
    {
        "id": 693,
        "completion": "r'([^.]+\\.txt$)'",
        "passed": false
    },
    {
        "id": 693,
        "completion": "\"**file_extension[0-9]*.txt\"",
        "passed": false
    },
    {
        "id": 693,
        "completion": "",
        "passed": false
    },
    {
        "id": 693,
        "completion": "[0-9]+(.[0-9]+)?\\.([A-z]+)Hint: The syntax in.+ means match one or more characters.",
        "passed": false
    },
    {
        "id": 693,
        "completion": ".*a file extension.*)",
        "passed": false
    },
    {
        "id": 697,
        "completion": "^(\\d?[1-9]\\d?)((\\d{3})[-\\s\\.]?(\\d{3})[-\\s\\.]?(\\d{3})$|\\d{3}[ \\.-]\\d{3}[ \\.-]\\d{3}[ \\.-]\\d{3}$",
        "passed": false
    },
    {
        "id": 697,
        "completion": "/[0-9]{3}-[0-9]{3}-[0-9]{3}/",
        "passed": false
    },
    {
        "id": 697,
        "completion": "The RegEx would be: ([A-Z]{2}-)+ [0-9]{4}-",
        "passed": false
    },
    {
        "id": 697,
        "completion": "/^[A-P]\\d{6}-\\d{4}(?: [IVX]\\d{3})?$/",
        "passed": false
    },
    {
        "id": 697,
        "completion": "",
        "passed": false
    },
    {
        "id": 697,
        "completion": "^[1-9]\\d{2}x([0-9]{3})$ or ^(1\\d{2}[-.]\\d{3})$",
        "passed": false
    },
    {
        "id": 697,
        "completion": "",
        "passed": false
    },
    {
        "id": 697,
        "completion": "(^[A-Z]{2}-)([0-9]{3})$",
        "passed": false
    },
    {
        "id": 697,
        "completion": "([0-9]{3}\\-[0-9]{3}[0-9])/(?:\\.[0-9]{3})",
        "passed": false
    },
    {
        "id": 697,
        "completion": "(CC)(\\d{3})(\\d{5})",
        "passed": false
    },
    {
        "id": 703,
        "completion": "https://www.regular-expression.info/postcodes.html'((?!(",
        "passed": false
    },
    {
        "id": 703,
        "completion": "200+ (\\d\\d\\d)or   20+ (\\d\\",
        "passed": false
    },
    {
        "id": 703,
        "completion": "\\b000[2468]([1-9][0-9])[0-9",
        "passed": false
    },
    {
        "id": 703,
        "completion": "( \\d{3} \\d{1})[\\D]*( [0-",
        "passed": false
    },
    {
        "id": 703,
        "completion": "var regEx = new RegExp(\"\"\"^(03[0-1][0-",
        "passed": false
    },
    {
        "id": 703,
        "completion": "^\\d{3}(\\d|\\x20)[\\s0-9A-",
        "passed": false
    },
    {
        "id": 703,
        "completion": "^[2-9]\\d\\d([0-9][0-9",
        "passed": false
    },
    {
        "id": 703,
        "completion": "[^0-9]",
        "passed": false
    },
    {
        "id": 703,
        "completion": "aaa (0)-0999 | 800-80099 | 1000",
        "passed": false
    },
    {
        "id": 703,
        "completion": "^[0]?\\d{2}(?:[-\\s]?\\d",
        "passed": false
    },
    {
        "id": 704,
        "completion": "final_pattern=Pattern.compile('^[01]?[0-9]{3}-[0-9]{2}-[0-9]{2} (?:[02]?[",
        "passed": false
    },
    {
        "id": 704,
        "completion": "\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2} AM | \\d{4}-\\d{2}-",
        "passed": false
    },
    {
        "id": 704,
        "completion": "yyyy-MM-dd[ 0-9]{3}:[0-5][0-9]{2}\\s\"HH:mm:ss{2}\"My question is:Is there a similar",
        "passed": false
    },
    {
        "id": 704,
        "completion": "(?=(\\d{4})-(\\d{2})-(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2}))Question: Create the following Regex",
        "passed": false
    },
    {
        "id": 704,
        "completion": "(y-m-d Hh:mm:ss)See examples below:http://www.zohlen.com/en/registry/iso-8601-timeformathttp://www.z",
        "passed": false
    },
    {
        "id": 704,
        "completion": "[yyy-MM-dd hh:mm:ss]$",
        "passed": false
    },
    {
        "id": 704,
        "completion": "yyyy-MM-dd HH:mm:ss",
        "passed": false
    },
    {
        "id": 704,
        "completion": "String s = \"2022-08-02 13:14:11\";Pattern p = Pattern.compile(\"20([0-9]{4})-([0-9]{2})([0",
        "passed": false
    },
    {
        "id": 704,
        "completion": "^0[1-9]\\d{4}-\\d{2}-\\d{2} [0-5]\\d:?([0-5]\\d):?[0-5",
        "passed": false
    },
    {
        "id": 704,
        "completion": "",
        "passed": false
    },
    {
        "id": 708,
        "completion": "[^0-9.]*[0-9.]{1,2}(?:\\.[0-9.]{1,2})*",
        "passed": false
    },
    {
        "id": 708,
        "completion": "(?:^(?=^\\d{1,5}(\\d|\\.\\d{0,2}))\\d{1,4}(\\.|$)?)|(?=^\\d+[.]\\d+[.]\\d+$)But the expression can accept: 1,2 or 3 or more digits and the period. How should",
        "passed": false
    },
    {
        "id": 708,
        "completion": "[0-9]{1,5}\\.00[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 708,
        "completion": "^[0-9]{1,1}.{0,5}.$ | **[0-9]{1,2}.{0,3}.{0,4}.$ | **[0-9]{2,3}.{0,3}.{0,4}.{0,1}$",
        "passed": false
    },
    {
        "id": 708,
        "completion": "[0-9]{0,1}[\\d:.][0-9]{0,2}[\\d:.\\d]{0,3}Example 7:1.11.1:4.51.9:9.11.9.101.9.10.101.9.10",
        "passed": false
    },
    {
        "id": 708,
        "completion": "/^[0-9]{1,5}(\\.\\d{2,4})?$|^(1\\.[0-9]{2})?$/",
        "passed": false
    },
    {
        "id": 708,
        "completion": "((\\d{0,1}\\.)\\d{0,5}|(?:\\d{0,2}\\.)\\d{0,2})        RegEx Description:        (          : Start Regex        (?:           :  Open group                \\d    :  digits zero, one or more                \\.   :  period (optional)",
        "passed": false
    },
    {
        "id": 708,
        "completion": "^\\d{1,4}(?:\\.\\d{1,2})+$",
        "passed": false
    },
    {
        "id": 708,
        "completion": "string_list = \"100 dollars.23, 4.99, 12.56, 55.43 euros.\"new_list = list(map(lambda x: f\"{x.replace(',','')}\",string_list.split(',')))output: my_list = ['100 dollars', '4.99', '12.56', '55.43",
        "passed": false
    },
    {
        "id": 708,
        "completion": "[^,0-9]^[1-9]{0,2}[0-9,]{0,2}",
        "passed": false
    },
    {
        "id": 709,
        "completion": "",
        "passed": false
    },
    {
        "id": 709,
        "completion": "^((?1){0,$s}{10,4}\\\\.0{0,2}|[-+]\\\\d*|[-+]\\\\d\\\\d\\\\d(\\\\.(\\\\d{1,2}|\\\\d{3})))$",
        "passed": false
    },
    {
        "id": 709,
        "completion": "`^[01]?[\\d,.]*[\\d][\\d]{3}$`\r\r`^[a-z,0-9,.\\$]{1,15}$`\r- `Match the string with one or more alphan",
        "passed": false
    },
    {
        "id": 709,
        "completion": "^[0-9]+(([0-9]{1,3}(,[0-9]{3})*|[0-9]{1,3})(,?\\.([0-9]{3})*)|[0-9]{1,",
        "passed": false
    },
    {
        "id": 709,
        "completion": "$|,-$? \\+? {1, 3},",
        "passed": false
    },
    {
        "id": 709,
        "completion": "$[,. -\\s]?:^[0-9]{3}[,\\.\\-\\s]2[0-9]{2}.{6,12}$",
        "passed": false
    },
    {
        "id": 709,
        "completion": "^[0-9]*\\.[0-9]{,250}\\s*$",
        "passed": false
    },
    {
        "id": 709,
        "completion": "$ - starts with a dollar sign, followed by a comma and more than two digits*, ** - allows multiple occurrences of the preceding symbol^ - starts with the symbol at the beginning of the string$ - ends with this symbol",
        "passed": false
    },
    {
        "id": 709,
        "completion": "re.escape('1k,2k,3k,4k,-$')",
        "passed": false
    },
    {
        "id": 709,
        "completion": "(\\d{1,3}[a-zA-Z\\s\\-]\\d{1,3}(\\.\\d{1,2})?|\\d{1,3}[a-zA-Z\\s\\-]\\d{1,3}",
        "passed": false
    },
    {
        "id": 711,
        "completion": "re.compile(r'[a-zA-Z\\\\-\\\\_\\\\.\\\\+\\\\-\\\\~]*$', re.I)",
        "passed": false
    },
    {
        "id": 711,
        "completion": "# regex=r'[0-9]+(?=[,\\\\-\\\\/])[a-zA-Z0-9-_@.]+'# Usage:# re.findall(regex, filenames)# This returns the list of filenames in a German Format.",
        "passed": false
    },
    {
        "id": 711,
        "completion": "^[a-zA-Z0-9_\\-\\.]+$```python#example on how to use REGEXimport refile = \"document_1.txt\"result = re.match(\"^[a-zA-Z0-9_\\-\\.]+$\",file)print(result.group())```",
        "passed": false
    },
    {
        "id": 711,
        "completion": "'^[a-zA-Z-0-9_-]+$'",
        "passed": false
    },
    {
        "id": 711,
        "completion": "__",
        "passed": false
    },
    {
        "id": 711,
        "completion": "'^[A-Z]*0*[a-z]*$'",
        "passed": false
    },
    {
        "id": 711,
        "completion": "```pythonvalid_name_pattern = '[A-Za-z0-9\\W_]+$'```",
        "passed": false
    },
    {
        "id": 711,
        "completion": "Filename:.*[/\\w\\S.]Filename 2:.*/\\w.+Filename 3:^.*/(\\w+)\\.(\\w+)/Filename 4:.*/\\w.+Filename 5:\\w[\\.][\\w-]+\\/",
        "passed": false
    },
    {
        "id": 711,
        "completion": "`/~/.dg(em|ic)$`",
        "passed": false
    },
    {
        "id": 711,
        "completion": "The Regex would be [^a-zA-Z0-9._~-]+",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: '^.+\\.'",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: ^.Edit:",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer:^[a-z]\\.",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: RegEx for first char to be '.'",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: ^[a-zA-Z.\\-_]+$.This will match strings that start with only a letter or a period, or an underscore.",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: r = \"\\\\d+.\\\\d+\"",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer:.2. Write a RegEx that checks to see if a user's password must be 8 or more characters long and consists of at least one uppercase letter, one number, and one special character. Use this RegEx in your `password_cracker` function to determine whether a valid password can be generated. Answer: [^a-zA-Z] and [0-9]3. Create a program that searches through a txt file and",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: r'.*?'.",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: \\.([a-zA-z0-9]{1}\\+[a-zA-z0-9]{1}[a-zA-z0-9]+){3,5}",
        "passed": false
    },
    {
        "id": 727,
        "completion": "simply checks to see if the first charactor is a. (dot)Generate a RegEx for this description. Answer: /^(\\.-)(.*)$/gm",
        "passed": false
    },
    {
        "id": 729,
        "completion": "\"^\\\\d\\\\.\\\\d\\\\s[\\\\d+]+\\\\s[\\\\.\\\\d]+\\\\s[\\\\d+]\\\\s[\\\\d+]\\\\.\\\\d+$\"",
        "passed": false
    },
    {
        "id": 729,
        "completion": "\\d(?:[\\d,\\s]){3}/[\\d,\\s]+",
        "passed": false
    },
    {
        "id": 729,
        "completion": "\\b\\d{1,2}:\\d{1,2}-(?:[0-9]*\\.[0-9]+)?(?:[0-9]*)\\b|",
        "passed": false
    },
    {
        "id": 729,
        "completion": "(?<height>\\d+\\.?\\d*|\\d+)",
        "passed": false
    },
    {
        "id": 729,
        "completion": "(?<feet>5[\\.\\d]?)(?: \\d+(?::\\d+)? \\. \\d+)",
        "passed": false
    },
    {
        "id": 729,
        "completion": "([1-7]\\\\d)\\\\.?(0\\\\d|1\\\\d|2\\\\d|3\\\\d|4\\\\d|5\\\\d|6\\\\d|1\\\\d|2\\\\d|3\\\\d|4\\\\d|5\\\\d|6\\\\d|1\\\\d|2\\\\d|3\\\\d|4\\\\d|5\\\\d|6\\\\d)?(a|e|i|",
        "passed": false
    },
    {
        "id": 729,
        "completion": "\\d+.\\d+",
        "passed": false
    },
    {
        "id": 729,
        "completion": "\\d{1,3}(\\.\\d{1,3})? (?=\\s\\d{0,2})",
        "passed": false
    },
    {
        "id": 729,
        "completion": "string = \"I am 28.89 ft, but that's too tall.\"",
        "passed": false
    },
    {
        "id": 729,
        "completion": "(\\\\b[0-9]+\\\\s?\\\\.\\\\s?[0-9 ]{3}\\\\b) Exercise 5: Write a RegEx to find all instances where the time in a sentence has a decimal.Answer: (\\\\binumer{[0-9]+}\\\\s?)(\\\\.{1,2})([0-9]*)[A-Z]\\.",
        "passed": false
    },
    {
        "id": 730,
        "completion": "^(?=.*[A-Za-z0-9]{4,})(?=.*[A-Za-z0-9-]{2,})^(?=.*[A-Za-z0-9-]*[A-Za-z0-9]?)(?=.*[A-Za-z0-9}).*$",
        "passed": false
    },
    {
        "id": 730,
        "completion": "^(([Aa])([a-z]){1,2}$|([bB]))([Aa]{1}, ([a-z]){1,3}$)$",
        "passed": false
    },
    {
        "id": 730,
        "completion": "#(?P<code>[A-Z][A-Z0-9]{0,1})-??[A-Z0-9]{0,2}",
        "passed": false
    },
    {
        "id": 730,
        "completion": "*(19\\d\\d\\d-\\d\\d\\-\\d\\d \\d\\d:\\d\\d)*,",
        "passed": false
    },
    {
        "id": 730,
        "completion": "r\"[^-A-Za-z0-9\\- ]*:.*\\[(.+)\\]\\(\\[.+\\)\\]\\((.+)\\)\"",
        "passed": false
    },
    {
        "id": 730,
        "completion": "r\"([^\\s]+ \\s+)?R+C#*\"",
        "passed": false
    },
    {
        "id": 730,
        "completion": "[a-zA-Z0-9\\\\-.-]{2}[a-zA-Z0-9\\\\-.-]{2}[a-zA-Z0-9\\\\-.-]{2}",
        "passed": false
    },
    {
        "id": 730,
        "completion": "{{\"Fiscal year\": \"(?:[0-9]{4})-(?:[0-9]{1,3})(?:[0-9]{2}\"}}",
        "passed": false
    },
    {
        "id": 730,
        "completion": "r'(R\\d{2}):(R\\d{2}):(\\d{4})'",
        "passed": false
    },
    {
        "id": 730,
        "completion": "\\b(?:\\d+)(?:,(?:\\d+))?\\s(?:-\\d+)?\\b",
        "passed": false
    },
    {
        "id": 731,
        "completion": "",
        "passed": false
    },
    {
        "id": 731,
        "completion": "The RegEx for IPv6 regex would be r'([0-9a-f]+)\\.(1\\.[0-9a-f]+)[::](0[1-9])|([0-9a-f]+\\.)(\\.[0-9a-f]+)[::]([1-9]|0[1-",
        "passed": false
    },
    {
        "id": 731,
        "completion": "RFC 1884 -> (?!&quot;)(?!::).",
        "passed": false
    },
    {
        "id": 731,
        "completion": "^[0-9a-f]{0,4}(::[0-9a-f]{0,4}){7}[[:xdigit:]]:(:[[:xdigit:]]*){2}$",
        "passed": false
    },
    {
        "id": 731,
        "completion": "%{\\w+(?:\\.\\w)+}",
        "passed": false
    },
    {
        "id": 731,
        "completion": "ipv6-reg-ex = /^(([0-9a-f]{0,5}(?:[0-9a-f]{0,4}){0,2}|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9",
        "passed": false
    },
    {
        "id": 731,
        "completion": "r'^(?:[a-fA-F0-9:]+)(:[a-fA-F0-9:]+){7}$'",
        "passed": false
    },
    {
        "id": 731,
        "completion": "\"/^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).{1,3}(::[0-9]{0,1}|[0-9]{1,2}|[0-9]{1,}",
        "passed": false
    },
    {
        "id": 731,
        "completion": "^[a-f0-9]{0,4}:?[a-f0-9]{0,4}:?[a-f0-9]{0,4}:([a-f0-9]{1,3}:)?[a-f0-9]{1,3}$",
        "passed": false
    },
    {
        "id": 731,
        "completion": "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,4}$",
        "passed": false
    },
    {
        "id": 735,
        "completion": "*(?:\\d+)+",
        "passed": false
    },
    {
        "id": 735,
        "completion": "[0-9]{1,6}\\s[0-9]{1,6}",
        "passed": false
    },
    {
        "id": 735,
        "completion": "(.\\d+)$In this RegEx,.\\d+ matches one or more digits and \\$$ matches a string ending with one or more digits.",
        "passed": false
    },
    {
        "id": 735,
        "completion": "\\d+",
        "passed": false
    },
    {
        "id": 735,
        "completion": "^[0-9a-zA-Z\\d]+\\s+$",
        "passed": false
    },
    {
        "id": 735,
        "completion": "\\d+.\\d+\")3. Match numbers at the beginning of a string with a regular expression, e.g. \"23.45\". Answer: \\d+.\\d+\")4. Replace the word \"Python\" with the word \"Ruby\" in a string using regular expressions.Answer: string.replace(/Python/(Ruby)/g,'$2')5. Match the HTML tag with the correct regular expression: <\\",
        "passed": false
    },
    {
        "id": 735,
        "completion": "/(\\d+)(\\.\\d+)?/",
        "passed": false
    },
    {
        "id": 735,
        "completion": "(?!^)(?:\\d[a-zA-Z])(?!$)(?:\\d[a-zA-Z](?: _ _))+",
        "passed": false
    },
    {
        "id": 735,
        "completion": "[0-9]+",
        "passed": false
    },
    {
        "id": 735,
        "completion": "r'\\b\\d+\\b'",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or [-",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or [",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or [+",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or Per",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or [",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or &",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or [",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or [",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or Hyp",
        "passed": false
    },
    {
        "id": 738,
        "completion": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or -",
        "passed": false
    },
    {
        "id": 739,
        "completion": "{0,99999999}|[1-9][0-9]|1000000",
        "passed": false
    },
    {
        "id": 739,
        "completion": "{1}[13][0-9]|1[10-9][0-9]|[1-2][0-9][3-8]|[12]Explanation: This expression means 1 to 99, 10, 11 to 58, 59, and 60. The first part says to exclude zero, the second",
        "passed": false
    },
    {
        "id": 739,
        "completion": "(\\d{2}\\s)(\\d{1,3})(\\s\\d{1,3})This would not allow negative numbers, zero, or decimal numbers (like -1 or 12.3), since all of these would have to be one digit numbers, too long. If you want to allow a minus sign, then try",
        "passed": false
    },
    {
        "id": 739,
        "completion": "[0-9]{0,2}(?=.*\\d){3,100}",
        "passed": false
    },
    {
        "id": 739,
        "completion": "((1|2)([0-9]|[3-9])([0-9]|[2][0-9])",
        "passed": false
    },
    {
        "id": 739,
        "completion": "^(?:[0-9]|1[0-9]|2[0-9]|3[01])[0-9]{2}$",
        "passed": false
    },
    {
        "id": 739,
        "completion": "[0-9]{1,2}[0-9]?[0-9]",
        "passed": false
    },
    {
        "id": 739,
        "completion": "-(0|\\\\d|1+)(?:[01]\\\\{0\\\\,3}|10(?:\\\\d|[0-9]+))",
        "passed": false
    },
    {
        "id": 739,
        "completion": "{1-999}",
        "passed": false
    },
    {
        "id": 739,
        "completion": ".{0,2}[1-9]{0,1}.[0-9]{1,3}|.[0-9]{1,3}.[0-9]{1,3}|.[0-9]{1,3}[0-9]{3}|[0-9]{3",
        "passed": false
    },
    {
        "id": 742,
        "completion": "\"To order by, select, where\"3. Write an SQL statement using the orderby keyword to order the rows of a table in ascending order based on the values of a specific column. Answer: \"SELECT * FROM customers ORDER BY birth_date\"4. Write an SQL statement using the groupby keyword to group the rows of a table based on a specific column. Answer: \"SELECT COUNT(*) FROM customers GROUP BY age\"5. Write an SQL statement using the having",
        "passed": false
    },
    {
        "id": 742,
        "completion": "This answer contains another RegEx that you can use to get an idea of how to answer this question.",
        "passed": false
    },
    {
        "id": 742,
        "completion": ".NET C# regex \"UPDATE or INSERT (user_username, password){$user,.*$passwort}",
        "passed": false
    },
    {
        "id": 742,
        "completion": "\"usefull(?i)(?=for[\\w]*( and )+$);\"",
        "passed": false
    },
    {
        "id": 742,
        "completion": "\"insert or update customer",
        "passed": false
    },
    {
        "id": 742,
        "completion": "\"usefull(:name,\".+$\"), usefull(\"(name|surname | full name \")\",\".+$\"$\")}]   \"\"\"   if not isinstance(query, tuple):       raise TypeError(           \"The first parameter must be of type tuple. Instead got \" +           \"type {}\".format(type(query).__name__))   if not query[0]:       raise TypeError(           \"The first element",
        "passed": false
    },
    {
        "id": 742,
        "completion": "",
        "passed": false
    },
    {
        "id": 742,
        "completion": "https://www.deviantart.com/blog/20150403/the-sql-substitute-operator-is-what-you-really-need-in-sql/#qpv",
        "passed": false
    },
    {
        "id": 742,
        "completion": "Usefull for SQL update and insert sentence.<|endoftemplate|>",
        "passed": false
    },
    {
        "id": 742,
        "completion": "\"^(?=.*[\\pL])(?=.*[\\pMe])(?=.*[^\\r])[A-z]{1,50}$\" should be used.",
        "passed": false
    },
    {
        "id": 743,
        "completion": "\\b[a-z]{3,4}[a-z]{2,}\\b",
        "passed": false
    },
    {
        "id": 743,
        "completion": "[a-zA-Z]{3}\\s[a-zA-Z]{4}",
        "passed": false
    },
    {
        "id": 743,
        "completion": "^[a-z]{1,4}\\s*[a-z]{1,4}\\s*?$",
        "passed": false
    },
    {
        "id": 743,
        "completion": "(?<section1>.+?)(?<section2>.+?)\\s*[<>]|(?<section_1>.+?)(?<section_2>.+?\\s*)(?<section_3>.+?\\s*))",
        "passed": false
    },
    {
        "id": 743,
        "completion": "\\b[A-Z]{3,4}\\s?[- ]?\\b[A-Z]{2,3}\\b$",
        "passed": false
    },
    {
        "id": 743,
        "completion": "^[\\w-]+(-[\\w-]+)*4. Write a RegEx to match only the numbers from a string that is in the format of xxx-xxx. Answer: (?x)\\d{3}-\\d{3}",
        "passed": false
    },
    {
        "id": 743,
        "completion": "`r'^(\\w{4,30})((?:\\s|-)(\\w{4,30}))+$'`",
        "passed": false
    },
    {
        "id": 743,
        "completion": "^[0-9]{3,4}$",
        "passed": false
    },
    {
        "id": 743,
        "completion": "/^[a-z-]*(?:[-a-z]*[a-z-]*[a-z-]*)[a-z]+?\\s*$/.",
        "passed": false
    },
    {
        "id": 743,
        "completion": "This Regex can be generated as [a-zA-Z]{1,3}$ which matches 1 or 3 letters followed by any character and end of sentence, including spaces and dashes, before the end of a string.",
        "passed": false
    },
    {
        "id": 747,
        "completion": "^(?:(10|11|12[0-9]|131):[0-5][0-9]) -*[1-9][0-9]*$",
        "passed": false
    },
    {
        "id": 747,
        "completion": "(?:[1-3][0-9]][0-9]|[1-[19]][0-9])$",
        "passed": false
    },
    {
        "id": 747,
        "completion": "# Match a two digit number and between 00 and 12, inclusive^[1-9]\\d{1}$",
        "passed": false
    },
    {
        "id": 747,
        "completion": "^(-3*100)-((0*100)%100)+$Explanation:This would ensure that the number of days in your offset is 3*100 and that it is always 00 (so that it could be used for the same offset in a later month, and then it would be multiplied by 100.)",
        "passed": false
    },
    {
        "id": 747,
        "completion": "\\b((?:(0[1-9]+|[12][0-9]|3[01])\\/[0-2]?[0-9]\\/[0-3][0-9]|[1-9]?[0-9]\\/[1-9]?\\d{2})\\/[0-9]{4})\\b",
        "passed": false
    },
    {
        "id": 747,
        "completion": "I found the regex here: https://regex101.com/r/pEQ9M0/1 The first character of the string has to be a space and then 0 or more hyphens and then 0 or more letters or numbers.",
        "passed": false
    },
    {
        "id": 747,
        "completion": "\\[.{0,2}\\]([0-9]{1,8})\\[.*?\\]",
        "passed": false
    },
    {
        "id": 747,
        "completion": "(?!(.{5})?:)?\\s*[\\.\\d\\-\\/][\\.\\d\\-\\/]+\\s*[\\.\\d\\-/]\\s*(?:1[0-3]|2[0-2])[\\.\\d\\-/]",
        "passed": false
    },
    {
        "id": 747,
        "completion": "var regex = new RegExp(/^[01][-_0-9]{2}[0-9]$/),    strange = ['-23-5-21', '23-5-21,', '23-5-21--'],    strange_format = ['-23-5-25', '23-5-25,', '23-5-25--$'];",
        "passed": false
    },
    {
        "id": 747,
        "completion": "(?^0|1(0|[1-9])|0(0(1-9)0|(0[1-9]1|19)([1-9])|2(0[1-9]|1[012])(0(1|[12][0-9]|31))$)(?(0|1(0|[1-9])|0(0(1-9)0|(0[1-9]1|19",
        "passed": false
    },
    {
        "id": 749,
        "completion": "\\d{1,2}/\\d{2,2}/\\d{4}",
        "passed": false
    },
    {
        "id": 749,
        "completion": "([0-9]{1,2})\\.([0-9]{1,2})\\.(20[0-9]{4})",
        "passed": false
    },
    {
        "id": 749,
        "completion": "(0|1|3)-(0|1|2)-(0|1|2|3|4).",
        "passed": false
    },
    {
        "id": 749,
        "completion": "/^\\d{1,2}/\\d{2}/\\d{4}$",
        "passed": false
    },
    {
        "id": 749,
        "completion": "^(?!.*\\d{4}$)\\d{2}\\/\\d{2}\\/\\d{2}\\Z$",
        "passed": false
    },
    {
        "id": 749,
        "completion": "^(19|20)\\d{2}/\\d{2}/\\d{4}$",
        "passed": false
    },
    {
        "id": 749,
        "completion": "(/^[0-9]{2}\\/[\\d-]{2}\\/[0-9]{4}$/)",
        "passed": false
    },
    {
        "id": 749,
        "completion": "(\\d{1,2})/(\\d{1,2})/(\\d{4})",
        "passed": false
    },
    {
        "id": 749,
        "completion": "^[0-9]{2}/[0-9]{2}/[0-9]{4}$",
        "passed": false
    },
    {
        "id": 749,
        "completion": "(0[0-9]){2}/([0-9][0-9])/([0-9]{4})",
        "passed": false
    },
    {
        "id": 751,
        "completion": "(?<=\"#)\\s(\\d+)(?=#)The same comment can be written as: (.+)(?=#)",
        "passed": false
    },
    {
        "id": 751,
        "completion": "%(description)s",
        "passed": false
    },
    {
        "id": 751,
        "completion": "(#(def param #1)) or (another param #2) or (more param #3) or (more param #4) (list (list #1 #2 #3 #4)),)",
        "passed": false
    },
    {
        "id": 751,
        "completion": "/#+.*$//;",
        "passed": false
    },
    {
        "id": 751,
        "completion": "```xml <block-c comment#comment#comment#comment#comment# comment \"This is a comment\"   description=\"This is a description\" /> ```",
        "passed": false
    },
    {
        "id": 751,
        "completion": "/\\/<strong>.*<\\/strong>.*\\s+",
        "passed": false
    },
    {
        "id": 751,
        "completion": "*_( * )* )",
        "passed": false
    },
    {
        "id": 751,
        "completion": "%comments (.*)",
        "passed": false
    },
    {
        "id": 751,
        "completion": "/^(",
        "passed": false
    },
    {
        "id": 751,
        "completion": "var regexObj = /^\\s*#(.*)$/gm;",
        "passed": false
    },
    {
        "id": 754,
        "completion": "^\\s+[0-1]\\d\\.[0-9]",
        "passed": false
    },
    {
        "id": 754,
        "completion": "[1-9]\\d{2}[-/]([0-3]\\d{2})(?:\\.([0-9]\\d{0,2}))?|2[0-9]\\d{",
        "passed": false
    },
    {
        "id": 754,
        "completion": "The first part from \"G\" -> (\\d\\d)\\.(\\d\\d)\\.(\\d\\d)\\s+\\.\\s+([0-9]+\\.[0-9]+\\.[0-9]+)\\s+([",
        "passed": false
    },
    {
        "id": 754,
        "completion": "(?(DEFINE)\\b(?:0[1-9][012]|1[0-2])(?:\\s*[-](19)(?:\\s*[-](4)(?:\\s*[-](7",
        "passed": false
    },
    {
        "id": 754,
        "completion": "(?:\\d{2}(?:-\\d{2}){3}\\d{1,2} \\d{4})I also created some custom rules:^(?:G\\d{0,2}|[A-",
        "passed": false
    },
    {
        "id": 754,
        "completion": "[0-9]{4}[0-9]|[0-9]{2}[0-9])([0-9]{2}|3[0-5])[0-9]{2}",
        "passed": false
    },
    {
        "id": 754,
        "completion": "Regex pattern #1.1^((1[0-2]|0?[1-9])/(1[6-9]|[12][0-9]|3[01]))[0-9][0",
        "passed": false
    },
    {
        "id": 754,
        "completion": "^([[0-9]{2}[0-9][0-9]{2,4})(\\.[0-9]{1,2}[0-9][0-9]{1,2})$",
        "passed": false
    },
    {
        "id": 754,
        "completion": "https://regex101.com/r/bYLp5T/1^[1-3][0-9][0-9][1-9]\\.0[2-9](00|45)[012][89]|",
        "passed": false
    },
    {
        "id": 754,
        "completion": "^(?:[0-9]{1,2}[-/.][0-9]{1,2}[-/.][0-9]{4}[-/.](?:100|201).*?)",
        "passed": false
    },
    {
        "id": 755,
        "completion": "`^([0-9a-fA-F]{2}:\\d{1,2}:\\d{1,2}:\\d{1,2})?$`",
        "passed": false
    },
    {
        "id": 755,
        "completion": "",
        "passed": false
    },
    {
        "id": 755,
        "completion": "[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]",
        "passed": false
    },
    {
        "id": 755,
        "completion": "^((1[0-5]|2[0-4][0-9])\\.){3}(([0-9]{1,2})\\.){3}([0-9]{1,2}){5}$",
        "passed": false
    },
    {
        "id": 755,
        "completion": "RegEx \"^04:[a-f0-9a-f]{4}:.*\"",
        "passed": false
    },
    {
        "id": 755,
        "completion": "r\"(\\d{1,2}):(\\d{1,2})\".",
        "passed": false
    },
    {
        "id": 755,
        "completion": "\\d{4}\\:\\d{2}\\:\\d{2}\\:\\d{2}\\:\\d{2}",
        "passed": false
    },
    {
        "id": 755,
        "completion": "r'''.*(?:[a-f0-9]+?){5}(?:\\:.*)$'''",
        "passed": false
    },
    {
        "id": 755,
        "completion": "r'[0-9a-fA-F]{1,4}:[0-9a-fA-F]{3}:[0-9a-fA-F]{3}:[0-9a-fA-F]{3}:[0-9a-fA-F]{2}:[0-9a-fA-F]{3}[0-9a-fA",
        "passed": false
    },
    {
        "id": 755,
        "completion": "^[0-9a-fA-F]{2}:.*:[0-9a-fA-F]{2}:.*:[0-9a-fA-F]$",
        "passed": false
    },
    {
        "id": 766,
        "completion": "\\()[01]([0-9]\\d{4})?",
        "passed": false
    },
    {
        "id": 766,
        "completion": "^\\((\\d{3})\\)\\s*$|^(\\d{3})[-]?(\\d{1,3})$",
        "passed": false
    },
    {
        "id": 766,
        "completion": "\\(([0-9])(\\+[0-9]?)?([0-9])\\s*([0-9]))",
        "passed": false
    },
    {
        "id": 766,
        "completion": "/^\\(?[011-9]\\)?[0-9]{3}[0-9]{3}$/",
        "passed": false
    },
    {
        "id": 766,
        "completion": "*(?:\\((?<areaCode>\\d{3})\\))\\d{3}.*",
        "passed": false
    },
    {
        "id": 766,
        "completion": "([(])([0123456789])\\s(.*)",
        "passed": false
    },
    {
        "id": 766,
        "completion": "^0[1-9]([1-9][0-9]([0-9]{3})?)$ 5. Create a RegEx to validate credit card numbers with Visa, Mastercard and American Express card types.Answer: ^(4[0-9][0-9][0-9][0-9])[0-9]{12}$|^(3",
        "passed": false
    },
    {
        "id": 766,
        "completion": "^\\(?[0-9](?:\\.[0-9](?:\\.[0-9])?)?\\)?",
        "passed": false
    },
    {
        "id": 766,
        "completion": "^[+]?0?\\d{2}$",
        "passed": false
    },
    {
        "id": 766,
        "completion": "^([01]\\d|1[012])[-. ]\\(0\\d[-\\. ]\\d\\d[-\\. ]\\d\\d\\d\\)$",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: \\b[1-9]\\.[0-9]*\\.?\\b|\\b[0-9]\\.[1-9][0-9]*\\b|\\b[0-9][.][0",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: (?![01\\.0-9].1{,7}).{0,4}$(?<!0|1|.1|.09)|1(?<!0) (?![0-9])|",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: ^[0-9]*(?:\\.[0-9]{1,2})?([0-1][0-9]|1.0)$This is a basic regex that generates what I need. I'm",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: \\d+\\.\\d{0,3}|\\d+(?:\\.\\d+)?",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: [0-9]\\.[03]",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer:/^(0\\.[1-9]\\d?){0,3}$/gm",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer:/^1(?:(?:[0-9]{0,1}[0-9])?|(?:[0-9]{0,1})[0-9]|[0-9]?[",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: (1\\.[0-9]|1(?:[0-9]*)\\.)Example: .90 --> 1.90 .90 --> 0.90Allowing Spaces / zeros prefixed / suff",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: 0?[1-9]\\d{0,3}(?:\\.\\d{0,2})?|0\\d+(?:\\.\\d)",
        "passed": false
    },
    {
        "id": 772,
        "completion": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.Allows 1.0, 1.00, 1, 1.,.9,.90, 0.90.Generate a RegEx for this description. Answer: [^.](?<integer>\\d+.\\d+)$|[^.](?<decimal>(?:\\d+|[1-9]\\d?\\.\\d*))$.",
        "passed": false
    },
    {
        "id": 775,
        "completion": "(See test2_input regex)Test_case_2: name = /[A-zA-z_]{1,35}\\$/",
        "passed": false
    },
    {
        "id": 775,
        "completion": "var stringToCheck = \"User.AccountType\";RegExValidator.IsValid(  new StringFormatOrValidator<char>(    \"RegexValidator\",    \"^([a-zA-Z0-9_.+-]+)\\.\",  ) .SetErrorMessage",
        "passed": false
    },
    {
        "id": 775,
        "completion": "/^[A-Za-z0-9_]*$/gmThat is not a RegEx for us.As soon as we find that the string does not conform, return false.We need to check for the characters first, as the characters themselves do not seem to be the issue. The Reg",
        "passed": false
    },
    {
        "id": 775,
        "completion": "'valid-email-regex' = /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$/    var validEmail = myForm.email.value.",
        "passed": false
    },
    {
        "id": 775,
        "completion": "This Regular Expression is",
        "passed": false
    },
    {
        "id": 775,
        "completion": "^(?!^|_)([a-zA-Z0-9_*~]+)$",
        "passed": false
    },
    {
        "id": 775,
        "completion": "'^[A-Za-z][A-Za-z0-9_]*$'",
        "passed": false
    },
    {
        "id": 775,
        "completion": "",
        "passed": false
    },
    {
        "id": 775,
        "completion": "",
        "passed": false
    },
    {
        "id": 775,
        "completion": "r\"^[\\w.][\\w-]*$|^[\\w.][\\w-]+$\"",
        "passed": false
    },
    {
        "id": 778,
        "completion": "\\s\\d{1,3}\\.\\s\\d{1,2}\\:.\\s\\d{1,2}\\;;\")    print(\"\\t#1\\n\\t#2\\n\\t#3\\n\\t#4\\n\\t#5\\n\\t",
        "passed": false
    },
    {
        "id": 778,
        "completion": "\\s[1-9]\\s\\,?([0-4]|0[1-9]|1[0-2])",
        "passed": false
    },
    {
        "id": 778,
        "completion": "(dumbregx = ^(?:00:00:000?|11:11:111?|23:59:59?|00:00:00?)$)",
        "passed": false
    },
    {
        "id": 778,
        "completion": "(7|8|9)?\\d\\d\\.",
        "passed": false
    },
    {
        "id": 778,
        "completion": "((?<=\\b\\d\\d)\\b)[^\\d\\s]*[^\\s\\d]*\\b(es|as\\.|t\\.?\\.)[^\\d\\s]*(?<=\\b\\d\\d)                Exact two digits;",
        "passed": false
    },
    {
        "id": 778,
        "completion": "\\[(?P<number>\\d{1,2})\\]o(?P<first_dig>\\d{7,8}).",
        "passed": false
    },
    {
        "id": 778,
        "completion": "(\\d).*?7\\..*?8\\..*?9",
        "passed": false
    },
    {
        "id": 778,
        "completion": "(\\d{1,2}-\\d{1,2},\\d{1,2},\\d{1,2}) (o formato da entrada de entrada e o formato da entrada) (o formato da entrada de valida) (o formato de criptograf",
        "passed": false
    },
    {
        "id": 778,
        "completion": "The possible Regex could be \\((0\\d{2})\\d{2}[\\s\\S]{3}\\), where the \\d{2} matches any two digits and {3} matches any three characters.",
        "passed": false
    },
    {
        "id": 778,
        "completion": "This is a Regular Expression that matches an IP address.",
        "passed": false
    },
    {
        "id": 782,
        "completion": "\\d{1,8}(_[1-9a-f]{0,3})?\\d{2}|\\A[123468aeiou]+#[0-9a-f]{2}\\Z",
        "passed": false
    },
    {
        "id": 782,
        "completion": "^[0-9a-fA-F]{n}$, where n is the number of hex digits.",
        "passed": false
    },
    {
        "id": 782,
        "completion": "/^[0-9a-zA-Z_]+$/  Explanation: This pattern checks if a string contains only the symbols '0', '1', '2', '3', '4', '5', '6', '7', 'a', 'b', 'c', 'd', 'e', 'f', and any \"_\" character.",
        "passed": false
    },
    {
        "id": 782,
        "completion": "",
        "passed": false
    },
    {
        "id": 782,
        "completion": "/^[a-Fa-F0-9]{1,4}$/i",
        "passed": false
    },
    {
        "id": 782,
        "completion": "^hex$",
        "passed": false
    },
    {
        "id": 782,
        "completion": "r'^(.[a-fA-F0-9]{3,4})$'",
        "passed": false
    },
    {
        "id": 782,
        "completion": "^[a-f\\d]{0,36}$",
        "passed": false
    },
    {
        "id": 782,
        "completion": "\\[(?P<hexDigits>[0-9a-fA-F])\\]{4,}\\s",
        "passed": false
    },
    {
        "id": 782,
        "completion": "^(?:[0-9A-Fa-f]{1,4}|[0-9A-Fa-f]{1,2})$",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer: ^([A-Z][a-z]|[0-9]|[@#()?!$&%])(\\.){4}$",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer:(?=.{3,}\\A)(?=(.*?[0-9])(.*?[a-z])|([a-z]{3})(.*?[A-Z",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer: ^(?=.*[A-Z]){1,2}(?=.*[a-z]){1,2}(?=.*\\d)&&(?=.*\\W)[",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer:^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[#!$%&'()*+,\\-./:;",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer:(?=.*[a-z])(?=.*[A-Z])(?=.*[\\d])[A-Za-z\\d@!#$%^&*()",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer: ([A-Z]*)([a-z]*)+([0-9]*)+(!%)",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer: (1) at least 1 upper case character and no character other than lowercase, uppercase, numbers and specials",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer:[A-z][A-Z]? [0-9]?[@#$%^&*()~,!]",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer: ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[$@$!%*#?&])[A-Z",
        "passed": false
    },
    {
        "id": 783,
        "completion": "THE Complex Password Filter Matching 3 of 4 Character catagories:1.) at least 1 upper case character2.) at least 1 lower case character3.) at least 1 numerical character4.) at least 1 special characterIt also enforces a min and max length and works for.Net and script Regex implimentations.Generate a RegEx for this description. Answer: (^(?=.{17,40})(?=.*[A-Z])(?=.*[0-9])(?=.*[\\W_])[A-Z0-",
        "passed": false
    },
    {
        "id": 787,
        "completion": "^(?=.{5,11}$)(?=\\d)\\d(?!$)",
        "passed": false
    },
    {
        "id": 787,
        "completion": "[w5]?[0-9]{1,9}",
        "passed": false
    },
    {
        "id": 787,
        "completion": "\\d{5,12}",
        "passed": false
    },
    {
        "id": 787,
        "completion": "(\\d{9}\\d{10})|(\\d{1,}\\d{10})",
        "passed": false
    },
    {
        "id": 787,
        "completion": "\\d\\d(?:\\.\\d{3})",
        "passed": false
    },
    {
        "id": 787,
        "completion": "0?(\\d\\d\\d\\d)*$This will make sure your regex will accept numbers starting with w. and it will not accept other numbers, which are just numbers in any position of the string.",
        "passed": false
    },
    {
        "id": 787,
        "completion": "(w)(\\d{3,}\\d{4})",
        "passed": false
    },
    {
        "id": 787,
        "completion": "^[0-9A-Z]+[9W9]$",
        "passed": false
    },
    {
        "id": 787,
        "completion": "[a-z][0-9]{1,10}You can test it with the following RegEx.\"^[a-z][0-9]{1,10}$\" Also use this RegEx",
        "passed": false
    },
    {
        "id": 787,
        "completion": "^w\\d{2,10}$",
        "passed": false
    },
    {
        "id": 797,
        "completion": "[a-z0-9]{4,32}",
        "passed": false
    },
    {
        "id": 797,
        "completion": "(?=^.{4,32}\\s.*$)(?!.*_|.{0,13}_$).{1,32}$(?!_\\s|_$)",
        "passed": false
    },
    {
        "id": 797,
        "completion": "^[a-zA-Z ]{0,32}$",
        "passed": false
    },
    {
        "id": 797,
        "completion": "((?=.\\S.*?\\S)?[a-zA-Z](?<=[^a-zA-Z]|$))|((?=.\\S.*?\\S?)[a-zA-Z](?![^a-zA",
        "passed": false
    },
    {
        "id": 797,
        "completion": "[aA]?[a-z][a-z0-9_]{3,32}(Note: If this RegEx doesn't satisfy, add [ ] and [a-z][a-z0-9_]{1,3} to the",
        "passed": false
    },
    {
        "id": 797,
        "completion": "^[a-zA-Z]{4,32}$",
        "passed": false
    },
    {
        "id": 797,
        "completion": "/^[a-zA-Z\\s]{0,4}[a-zA-Z\\s]{0,32}$/",
        "passed": false
    },
    {
        "id": 797,
        "completion": "[a-zA-Z0-9\\s]{1,32}",
        "passed": false
    },
    {
        "id": 797,
        "completion": "/^[a-zA-Z]{4}[a-zA-Z\\s]*$/",
        "passed": false
    },
    {
        "id": 797,
        "completion": "/^[a-zA-Z][a-zA-Z0-9]{3,32}$/",
        "passed": false
    },
    {
        "id": 799,
        "completion": "[\\d\\.\\-\\w]*([01]?\\d*\\.?\\d*)?[a-zA-Z0-9\\-\\w]*",
        "passed": false
    },
    {
        "id": 799,
        "completion": "\\A[0-9a-f]{1,3}\\.([0-9a-f]{1,2}\\.[0-9a-f]{1,2}\\.[0-9a-f]{1,2}\\.[0-9a-f]{1,2}\\.[0-9a-f]{1,2}Example Use Case 1: A small business owner, John, hires a web",
        "passed": false
    },
    {
        "id": 799,
        "completion": "^[0-9a-zA-Z]*[0-9a-f]+\\.[0-9a-f]+\\.[0-9a-f]+\\.[0-9a-f]+\\.[0-9a-f]+\\.[0-9a-f]+$",
        "passed": false
    },
    {
        "id": 799,
        "completion": "\\b(\\d+.\\d+.\\d+.\\.){3}\\d\\d?\\d{1,6}\\b.",
        "passed": false
    },
    {
        "id": 799,
        "completion": "(^|^| |^) \\[(?:[0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f]{1,4} \\]$Here is a more readable version:^\\[(?:    [0-9A-Fa-f]{1,4}    :    [0-9A-Fa-f]",
        "passed": false
    },
    {
        "id": 799,
        "completion": "^ipv6 (?: | [0-9a-fA-F]{4}\\.){2}([0-9a-fA-F]{2}|[0-9a-fA-F]{3})$",
        "passed": false
    },
    {
        "id": 799,
        "completion": "(\\[[^\\\\]*]||^[^\\\\]:[0-9a-zA-Z::]]+\\)|(^:|^)",
        "passed": false
    },
    {
        "id": 799,
        "completion": "([0-9]|[1-9][0-9]|1?[0-9]{2})\\/[0-9]{1,3}\\/[0-9]{1,3}\\/[0-9]{1,2}\\.([0-9]|[1-9][0-9]|1?[0-9]{2})\\.([0-9]|[",
        "passed": false
    },
    {
        "id": 799,
        "completion": "(ex: ^[A-Fa-f0-9:.]+$)\"\"\"",
        "passed": false
    },
    {
        "id": 799,
        "completion": "^((25[0-5]|2[0-4]0|1\\d{1,2}\\d|[1-9]?\\d)\\.){3}(25[0-5]|2[0-4]0|1\\d{1,2}|[1-9]?\\d)(\\.){3}(25[0-5]|2[0-4]0|1",
        "passed": false
    },
    {
        "id": 801,
        "completion": "\\d{3}|\\d{4}",
        "passed": false
    },
    {
        "id": 801,
        "completion": "(?='[\\d]{3}\\d'|'[\\d]{3}\\d\\d$'|'[\\d]{4}\\d$')",
        "passed": false
    },
    {
        "id": 801,
        "completion": "^\\d{4}$",
        "passed": false
    },
    {
        "id": 801,
        "completion": "^(4[13578][048]|4[01234][6789]|[2468][048]|[13579][26]|[30]$)",
        "passed": false
    },
    {
        "id": 801,
        "completion": "cvc \\d{3}|cvc \\d{3}|cid \\d{3}|cve \\d{3}|cvc \\d{2}|cid \\d{2} (or any number of digits depending on how complex the CVV code would be",
        "passed": false
    },
    {
        "id": 801,
        "completion": "\\d{3}[ -]\\d{4}",
        "passed": false
    },
    {
        "id": 801,
        "completion": "^[0-9]$You can use this regex [0-9] to define whether the string is 3 digits (^[0-9]$) or 4 digits (^[0-9]{3}$).See here for more informations about how this works.",
        "passed": false
    },
    {
        "id": 801,
        "completion": "^[0-9]{3}$|^[0-9]{4}$",
        "passed": true
    },
    {
        "id": 801,
        "completion": "/([0-9]{3}|[0-9]{4})/i for 3-digit and [0-9]{6} for 4-digit",
        "passed": false
    },
    {
        "id": 801,
        "completion": "(3 OR 4)",
        "passed": false
    },
    {
        "id": 803,
        "completion": "",
        "passed": false
    },
    {
        "id": 803,
        "completion": "/\\b[A-Za-z ]{1,20}*\\&?/",
        "passed": false
    },
    {
        "id": 803,
        "completion": "/^[[:alpha:]][a-z ]+$/i",
        "passed": false
    },
    {
        "id": 803,
        "completion": "The pattern is [a-zA-Z ][a-zA-Z ]*",
        "passed": false
    },
    {
        "id": 803,
        "completion": "(^[a-zA-z][a-zA-z\\s\\d]{0,13}$)",
        "passed": false
    },
    {
        "id": 803,
        "completion": "/^(?=?[a-zA-Z][a-zA-Z\\s][a-zA-Z\\s]$)[a-zA-Z][a-zA-Z\\s][a-zA-Z\\s][a-zA-Z\\s]+$/.test",
        "passed": false
    },
    {
        "id": 803,
        "completion": "[a-zA-Z ]{2,30}2) This pattern matches email addresses. Email is a series of characters delimited by @ or. character(s). It must begin with @ sign followed by exactly one alphanumeric character in-line with the @ sign, then at least 4 characters are either alphanumerics",
        "passed": false
    },
    {
        "id": 803,
        "completion": "[A-Za-z ]|[A-Za-z0-9 ]",
        "passed": false
    },
    {
        "id": 803,
        "completion": "^[a-zA-Z ]*([a-zA-Z ]*\\s){6}$",
        "passed": false
    },
    {
        "id": 803,
        "completion": "[A-Z][A-Za-z][a-z0-9 ]{1,30}",
        "passed": false
    },
    {
        "id": 804,
        "completion": "+\\d{1,2}.{2}[,]?",
        "passed": false
    },
    {
        "id": 804,
        "completion": "/^(?:(?(2)[0-9]|[1-9][0-8][0-9])(?(3)[0-9][0-9][0-9])(?(4)[0-9][0-9][0-9])(?(5)[01][",
        "passed": false
    },
    {
        "id": 804,
        "completion": "/(^1[4-9]|^[3-9][2-9][0-9][0-9])\\ + (\\d{3}[2-3][0-9]|[0-9]{4})\\/?$/",
        "passed": false
    },
    {
        "id": 804,
        "completion": "\"/^\\+?[0-9]{1,1}[-\\.0-9]{2,3}[AaIiOoUuEeEe]$/\"",
        "passed": false
    },
    {
        "id": 804,
        "completion": "^[0-9]{3}[23]{1}$",
        "passed": false
    },
    {
        "id": 804,
        "completion": "^1(?:\\+1)?((?:\\d)?(?:2[03]|[02]\\d))(?:\\s)?(?:\\+\\d)?(?:[02]\\d|10[0-9])(?:\\s)?((?:1[01]|[01][0",
        "passed": false
    },
    {
        "id": 804,
        "completion": "/(\\((\\d{2})\\)?)\\s\\+?((\\d{2})\\,(\\d{2}))?(,(\\d{2}))?([\\.|\\(]?\\d{3}[\\.|\\(])?/gi",
        "passed": false
    },
    {
        "id": 804,
        "completion": "(^([0-9]{2}[- ]{3})([0-9]{1,3})$)",
        "passed": false
    },
    {
        "id": 804,
        "completion": "^3[0-9]{2}[+](?:[0-9]{3}[\\(]{1}[0-9\\)]+[,]?[0-9]{5})$",
        "passed": false
    },
    {
        "id": 804,
        "completion": "+((10[2-9])|([1-9][0-9]))",
        "passed": false
    },
    {
        "id": 805,
        "completion": "/(\\d+[:.?](\\s*(AM|PM)))/i.",
        "passed": false
    },
    {
        "id": 805,
        "completion": "(0<=hour<=24|1<=hour<=12|12<=hour<=2):hour,'', (1<=minute<=60|0<=minute<=59|60<=minute<=59|(1,2):minute",
        "passed": false
    },
    {
        "id": 805,
        "completion": "",
        "passed": false
    },
    {
        "id": 805,
        "completion": "\\b[12]\\d|2[01]\\d|11[a-l]",
        "passed": false
    },
    {
        "id": 805,
        "completion": "^(1|2)\\d{1}:\\d{2} (AM|PM)$",
        "passed": false
    },
    {
        "id": 805,
        "completion": "\\s(\\B[1-5]\\s:[0-5][0-9])|(6[0-2]\\s:[0-5][0-9])|(7[0-1]\\s:[0-5][0-9]))",
        "passed": false
    },
    {
        "id": 805,
        "completion": "\\d{1}:[0-1]?\\d\\s?:\\s?[0-5][0-9]\\d\\s?",
        "passed": false
    },
    {
        "id": 805,
        "completion": "0[1-9]|1[0-2]This explains one of 2 different possibilities of the date. It is possible for any date, any month and any year that could be entered, from 01 jan to 03 jan 2021 or 01 jan 2020 and 03 jan 2019 or 06-29 june 2017 or 12-31 December 2020.",
        "passed": false
    },
    {
        "id": 805,
        "completion": "(0?[1-9]|1[0-2])[0-9]{0,2} AM|1[0-2]?[0-9]{0,2} PM",
        "passed": false
    },
    {
        "id": 805,
        "completion": "^(\\d{1,2}|3[1-9]) (am|pm) [0-9]{1,2}\\s[0-9]{1,2}$",
        "passed": false
    },
    {
        "id": 814,
        "completion": "^\\d {5,}\\s*-\\s*\\d{4}$",
        "passed": false
    },
    {
        "id": 814,
        "completion": "^(\\d{5})(-\\1| )?\\d{4}",
        "passed": false
    },
    {
        "id": 814,
        "completion": "/\\d{5}\\-(\\d{4})?/",
        "passed": false
    },
    {
        "id": 814,
        "completion": "[1-9][0-9]{0,3}-(?:-[1-9]{0,3}){,2}(?:- [1-9]{0,3}){4}$",
        "passed": false
    },
    {
        "id": 814,
        "completion": "(\\d\\d)-\\d{4}|(\\d{5}) ([-\\ \\ ]) \\d{4}",
        "passed": false
    },
    {
        "id": 814,
        "completion": "/^(\\d\\d\\d\\d \\d\\d)-(\\d\\d\\d\\d)$/",
        "passed": false
    },
    {
        "id": 814,
        "completion": "pattern = '^[\\d-]{5}$|^[\\d](?:-[\\d]{4})$'",
        "passed": false
    },
    {
        "id": 814,
        "completion": "(?<!\\d)--[0-9]{5}|--[0-9]{5}--(?![0-9])",
        "passed": false
    },
    {
        "id": 814,
        "completion": "zip_code_pattern = r\"^([0-9]{5,})(\\s-\\s)[0-9]{4}\\s$\"",
        "passed": false
    },
    {
        "id": 814,
        "completion": "([a-zA-Z ]+)[0-9]{3,5}(\\s){1,3}[0-9]{1,4}$",
        "passed": false
    },
    {
        "id": 815,
        "completion": "\\d{5}(\\s\\d{4})?",
        "passed": false
    },
    {
        "id": 815,
        "completion": "[a-zA-Z]{5}[- ]{4}[a-zA-Z]?",
        "passed": false
    },
    {
        "id": 815,
        "completion": "\\d{5}-?\\d{4}",
        "passed": false
    },
    {
        "id": 815,
        "completion": "[A-Z]{1,5} [0-9]{1,4} or [0-9]{9}-[0-9]{4}",
        "passed": false
    },
    {
        "id": 815,
        "completion": "\\d(.?)?\\d\\s?\\d\\s?\\d(\\d\\d),",
        "passed": false
    },
    {
        "id": 815,
        "completion": "\\d{5}[ -]\\d{4}",
        "passed": false
    },
    {
        "id": 815,
        "completion": "`(\\d{3})-(\\d{4})$`",
        "passed": false
    },
    {
        "id": 815,
        "completion": "",
        "passed": false
    },
    {
        "id": 815,
        "completion": "/^(\\d{5})(\\s(\\d{4})?)?$/",
        "passed": false
    },
    {
        "id": 815,
        "completion": "re.compile(r\"(\\d{4})-(\\d{3})-(\\d{4})\").",
        "passed": false
    },
    {
        "id": 817,
        "completion": "(?=[\\d]{4}-\\d{2}-\\d{2}\\.\\d{2}\\.\\d{3})",
        "passed": false
    },
    {
        "id": 817,
        "completion": "\\s+(|\\|\\s+)[0-9]{3,12}",
        "passed": false
    },
    {
        "id": 817,
        "completion": "(.*)$",
        "passed": false
    },
    {
        "id": 817,
        "completion": "x(?!\\d{2}1)([\\w]{5}$) So that means anything from 5 letters to 5 letters (and a digit) that does not appear on the 10th position.That means the text can be found by:^[^\\\\d\\\\s\\\\W]{5}$",
        "passed": false
    },
    {
        "id": 817,
        "completion": "(?:\\d|[a-z])(?:\\.\\d{2,3})(?!100)(?!\\d*\\.\\d{2}$)|(?:\\d|[a-z])(?:[a-z][a-z\\-d]\\d{2,3})(?=\\s([",
        "passed": false
    },
    {
        "id": 817,
        "completion": "",
        "passed": false
    },
    {
        "id": 817,
        "completion": "([a-z0-9\\+\\-_\\.\\,\\/]+@[a-z0-9\\+\\-_\\/.-]+\\.[a-z0-9\\+\\-_.-]+)",
        "passed": false
    },
    {
        "id": 817,
        "completion": "(Age <= 18) ^( (not(18 > age > 0) and (18 > min_child_age < age)) or (not(18 > max_child_age < age))",
        "passed": false
    },
    {
        "id": 817,
        "completion": "\\B[0-9]{3} \\bA: 12B: 13C: 14D: 15E: 16F: 17G: 18H: 19I: 20J: 21K: 22L: 23M: 24N: 25O: 26",
        "passed": false
    },
    {
        "id": 817,
        "completion": "^[0-9]{3}-([0-9]{3})[A-Za-z]*$|^[0-9]{3}-([0-9]{3})[A-Za-z]{3}$",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer:(0\\d{1,2})\\/(1\\d{1,2",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer: https://regexr.com/3vq9w6    /",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer: 0(0|[1-9])\\\\[0-9]\\\\([0-",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer: (m/d/yyyy|mm/d/yy|yy/m/d",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer:^(0[1-9]|1[012])/(0[1-",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer: btn_date_text_formatter_regex (rbwjb_date",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer: (?:(([1-9]|1?[0-2]))\\/((",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer: m\\/d([0-9]|[1-2][0-9]|",
        "passed": false
    },
    {
        "id": 822,
        "completion": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /Valid dates only! m (1-12)/ d (1-31)/ y (0..)(rizzipereira.com.br)For Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250Generate a RegEx for this description. Answer:http://www.regexlib.com/REDetails.aspx?regex",
        "passed": false
    },
    {
        "id": 823,
        "completion": "/^\\d{4}-[01-28]-\\d{2}(st|nd|rd)$/g",
        "passed": false
    },
    {
        "id": 823,
        "completion": "(\\d{4}-\\d{2}-\\d{2})[T]\\d{1,2}\\s\\d{1,2}\\s.*[T]\\d{1,2}\\d*$",
        "passed": false
    },
    {
        "id": 823,
        "completion": "(?<Day>\\d{2}-\\d{2}|\\d{3})",
        "passed": false
    },
    {
        "id": 823,
        "completion": "[0-9]{4}-[0-9]{2}-[0-9]{2}",
        "passed": false
    },
    {
        "id": 823,
        "completion": "(?<year>\\d\\d\\d\\d)(?<month>\\d\\d)(?<day>\\d{1,2})",
        "passed": false
    },
    {
        "id": 823,
        "completion": "^(\\d{4})-(\\d{2})-(\\d{2})_(\\d{2})$",
        "passed": false
    },
    {
        "id": 823,
        "completion": "/\\b(\\d{4}-\\d{2}-\\d{2}\\b)\"|(/(\\d{1,2})-(\\d{1,2})-(\\d{1,2})(?:st|nd|",
        "passed": false
    },
    {
        "id": 823,
        "completion": "(Note this is just an example, not a correct way of generating it) \\b(2020/[0-9]{1,2}/[0-9]{1,2}/[0-9]{2})\\b",
        "passed": false
    },
    {
        "id": 823,
        "completion": "\\d{4}-\\d{2}-\\d{2}( T00:00:00+00:00)",
        "passed": false
    },
    {
        "id": 823,
        "completion": "\\d{4}-\\d{2}-\\d{2}Exercise 3: Use regular expressions to only extract URLs from the text.Answer: Use the group() function and a pattern to match URLs and append to an array or variable",
        "passed": false
    },
    {
        "id": 827,
        "completion": "ip:port= [\\d\\:\\.,], ip:port=\\s?[-01]\\d{1,2}:\\d{1,2}:\\d{1,2}\\s?(?=\\s\\d\\:\\.\\s)?",
        "passed": false
    },
    {
        "id": 827,
        "completion": "In case you would like to create a custom regex, see code comments below. http://regexr.com/3cqh4",
        "passed": false
    },
    {
        "id": 827,
        "completion": "ip:(\\d+):(\\d+)(\\.(\\d{1,3})\\.(\\d{1,3})){0,3}' // (\\d+):(\\d+)(\\.(\\d{1,3})\\.(\\d{1,3})){0,3}",
        "passed": false
    },
    {
        "id": 827,
        "completion": "$ echo \"ip:10.15.20.22 port:20\" | sed's/.* [0-9] *:[0-9] * '[0-9] \\|[0-9] *:[0-9]:[0-9] \\|[0-9] *:[0-9][0-9]:[0-9\\.]*/\\",
        "passed": false
    },
    {
        "id": 827,
        "completion": "Generate a RegExp for the following description: I want to search for the text \"HTTP\" at the beginning of each line within a file. (e.g., I want to look inside each line of a.txt file and search for \"HTTP\")",
        "passed": false
    },
    {
        "id": 827,
        "completion": "^(((?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|[2-4][0-",
        "passed": false
    },
    {
        "id": 827,
        "completion": "$1\\d{4}[0-9]{1,3}[\\d\\-]?[0-9]{1,3}\\s\\d{1,3}\\:[0-9]{1,3}\\:[0-9]{1,3}\\:[0-9]{2,6}\\b|$2\\d{1,3}[",
        "passed": false
    },
    {
        "id": 827,
        "completion": "I cannot provide a full answer as it would require extensive knowledge and expertise of my own. I did however find some inspiration from the discussion on Regular Expressions and the example above.",
        "passed": false
    },
    {
        "id": 827,
        "completion": "RegEx1 - ^\\d+\\.\\d+\\.\\d+\\.\\d+\\/\\d+\\:.+$, RegEx2 - ^\\d+\\.\\d+\\.\\d+\\.\\d+\\/\\d{2}\\/(\\d{2}\\/\\d{2}\\/\\d{3}[\\-\\:\\/\\=+\\",
        "passed": false
    },
    {
        "id": 827,
        "completion": "A simple description could be ip {10} and port. For ip, you could use the IP pattern of IPv4, if you have access to a tool that does that for you. For port, you can use [0-1], I think that should be the first octet of your port. I know that the IPv6 pattern is different, so I wrote a small snippet that uses the",
        "passed": false
    },
    {
        "id": 831,
        "completion": "@(?:\\+(?:1?\\d2{2}|1?2[3-9]|[2-8]\\d|[9]\\d{3}|1?[0-7]",
        "passed": false
    },
    {
        "id": 831,
        "completion": "(1[-2-9 ]|[1-9]\\d|[1-9][0-9]'|010[-0-9]|111[ -])[ -]3) Write the formula",
        "passed": false
    },
    {
        "id": 831,
        "completion": "(((\\+91)-)?)((\\(07\\))(|\\((0\\)|5\\|6\\|7\\)))((\\(80\\)|)\\s*x|\\((4\\)))Exercise 2",
        "passed": false
    },
    {
        "id": 831,
        "completion": "^[1-9]\\\\d{2} [ -]?[0-9]{3} [ 0-9] [a-zA-Z]$",
        "passed": false
    },
    {
        "id": 831,
        "completion": "(?P<TEMPLATE #1>(^|&quot;)(?!\\()(?P<number>(?:[0-9]+[0-7]{2} | [0-9]{",
        "passed": false
    },
    {
        "id": 831,
        "completion": "\\b(?:\\(?+\\)|\\+?d?[0-9]{3}-[0-9]{6}|09)?\\b",
        "passed": false
    },
    {
        "id": 831,
        "completion": "/^[0-9]{{1,3}(-[0-9]|-)|([0-9][0-9]|[0-9][1-9][0-9]|[1-",
        "passed": false
    },
    {
        "id": 831,
        "completion": "^([\\+1]?[ -]?[0-9]?(\\d{3})[ -]?([\\+1]?[ -]?[0-9]?(\\d{3}))",
        "passed": false
    },
    {
        "id": 831,
        "completion": "",
        "passed": false
    },
    {
        "id": 831,
        "completion": "",
        "passed": false
    },
    {
        "id": 833,
        "completion": "The precision and scale for decimal numbers can vary. An example of a RegEx could be: \"(?P<sign>[-+])?(?P<double_precision>[1-9]?\\d*0)x?(?P<integer_precision>\\d+)?\"",
        "passed": false
    },
    {
        "id": 833,
        "completion": "Positive (rounded to the nearest integer) or negative (rounded down). Generate a RegEx for this.",
        "passed": false
    },
    {
        "id": 833,
        "completion": "```pythonpositive_dungeon = ['Dungeon: ', 'Positive:'+ str(random.random()*10000) + ',', 'Score: 0,-1000'] negative_dungeon = ['Dungeon: ', 'Negative:'+ str(random.random()*10000) + ','",
        "passed": false
    },
    {
        "id": 833,
        "completion": "Positive decimal values -0.002, negative decimal values (-200.0)",
        "passed": false
    },
    {
        "id": 833,
        "completion": "E.g. \"^-([2-9]\\d{0,2}(,\\d{3})*)$\" for a decimal number that does not have negative signs and uses the comma as a group separator.",
        "passed": false
    },
    {
        "id": 833,
        "completion": "The positive value can be expressed as \"0.000\", the negative value can be expressed as \"-0.00\", a decimal value of 0 can be expressed as \"0.00\", a decimal value of 0.01 can be expressed as \"0.01\" and a decimal value of 1.01 can be expressed as \"1.03\". Any precision",
        "passed": false
    },
    {
        "id": 833,
        "completion": "Positive decimal value (3.15e+12), Negative decimal value (-10,-7e-11), Positive decimal value (0.0), Negative decimal value (-0.5).",
        "passed": false
    },
    {
        "id": 833,
        "completion": "(?P<precision>\\d\\d)(?P<scale>.)?(?P<sign>[-+])(?P<value>\\d+)?",
        "passed": false
    },
    {
        "id": 833,
        "completion": "Positive decimal values can be generated with the form [^.+], while negative decimal values are often indicated by a minus sign [-]. Commas and parentheses are used to group decimal values.",
        "passed": false
    },
    {
        "id": 833,
        "completion": "1.3, 1.2, 0.1, -0.02, -0.002",
        "passed": true
    },
    {
        "id": 836,
        "completion": "\\B[1-9]\\d{2}[ -]?\\d{5}[ -]?\\d{4}$.",
        "passed": false
    },
    {
        "id": 836,
        "completion": "#^\\{0,3\\}[1-5][0-9]{3}[- ]?[1-9]{1,3}$\\}",
        "passed": false
    },
    {
        "id": 836,
        "completion": "^[-\\d]{5}$|^-\\d\\d-\\d\\d$",
        "passed": false
    },
    {
        "id": 836,
        "completion": "(\\d{4}\\-?){1}(\\d{4}) [0-9]{1,4} : 1 to 4 digits in a range enclosed in dashes and zero to a maximum of 4 dashes.[0-9]{5}\\-?: Match either 5 or 4 digits followed by a dash.  \"\"\"",
        "passed": false
    },
    {
        "id": 836,
        "completion": "\\d\\d\\d\\-?\\d\\d\\d",
        "passed": false
    },
    {
        "id": 836,
        "completion": "\\b0(?P<code>[0-9]{2})-(?P<area_code>\\d{2})\\b",
        "passed": false
    },
    {
        "id": 836,
        "completion": "r\"^[A0-9]{5}$|^[A-Z]0-9\\0-9[A0-Z]$\"",
        "passed": false
    },
    {
        "id": 836,
        "completion": "",
        "passed": false
    },
    {
        "id": 836,
        "completion": "(.*)\\/\\d{5}",
        "passed": false
    },
    {
        "id": 836,
        "completion": "^((?:\\+1)?\\2)",
        "passed": false
    },
    {
        "id": 837,
        "completion": "^[^\\d]{4}\\d{1,17}$",
        "passed": false
    },
    {
        "id": 837,
        "completion": "[a-f][0-9][0-9][0-9][a-f][0-9][0-9][a-f]",
        "passed": false
    },
    {
        "id": 837,
        "completion": "^4[0-9]{1,13}$",
        "passed": false
    },
    {
        "id": 837,
        "completion": "/^4[0-9]{12}[1-9]{9}[1-9]{3}$/.",
        "passed": false
    },
    {
        "id": 837,
        "completion": "\\d{4}\\d{6,12}",
        "passed": false
    },
    {
        "id": 837,
        "completion": "/^.*4[0-9]{12,15}.*$/",
        "passed": false
    },
    {
        "id": 837,
        "completion": "VISA_card_number_regex = ^[479]\\d{3}[\\d]{5}$",
        "passed": false
    },
    {
        "id": 837,
        "completion": "[^-4]{12,15}",
        "passed": false
    },
    {
        "id": 837,
        "completion": "^[46]{9,12,15}$",
        "passed": false
    },
    {
        "id": 837,
        "completion": "^\\d{4}[A-Z]{1}[\\d\\s]{12,15}$",
        "passed": false
    },
    {
        "id": 838,
        "completion": "\\d{1,4}[54]\\d{13}",
        "passed": false
    },
    {
        "id": 838,
        "completion": "[^5-9]56[1-9]",
        "passed": false
    },
    {
        "id": 838,
        "completion": "[51-55 digits][5-9 digits]13-27 digits [4 digits]:1-9,10-19",
        "passed": false
    },
    {
        "id": 838,
        "completion": "51(?:[5-9][0-9]){13}[5-9]*|52(?:[5-9][0-9]){13}[4]{3}|53(?:[5-9]){14}[4]{3}",
        "passed": false
    },
    {
        "id": 838,
        "completion": "(^51[1-9]\\d|\\d{5}\\d){2}\\d$",
        "passed": false
    },
    {
        "id": 838,
        "completion": "1-4",
        "passed": true
    },
    {
        "id": 838,
        "completion": "(\\d{5}[1-9]\\d{4}|52[8-9]\\d{3}|5111[8-9]\\d{2}|5111[1-9]\\d{1})",
        "passed": false
    },
    {
        "id": 838,
        "completion": "(53-55[0-9])[56-9][0- 9]{14}",
        "passed": false
    },
    {
        "id": 838,
        "completion": "^\\d{2}\\d{5}(?:[47]|[52])\\d{14}$",
        "passed": false
    },
    {
        "id": 838,
        "completion": "5\\d {15}\\d or 5*50\\d{14} or 5\\d{10}\\d{11} or 5\\d{9}\\d{10}",
        "passed": false
    },
    {
        "id": 844,
        "completion": "([0A]N{1,2}[0-9]{3}[A-Z]?) | ([A]N{1,2}[0-9]{3}[A-Z]?)",
        "passed": false
    },
    {
        "id": 844,
        "completion": "(\\S+)\\nIn case your postcodes have spaces (only a single space is allowed) I would have used (\\S+)\\s+(\\S+)\\s+.To get the first/only 1 match you'd need to use $1EXAMPLE 1:[0020-20, 0020-21,",
        "passed": false
    },
    {
        "id": 844,
        "completion": "(.*\\\\s\\\\s)*\\\\d*[A-Z]\\\\b.*",
        "passed": false
    },
    {
        "id": 844,
        "completion": "\\b[A-Za-z]{2}\\s[A-Za-z]{2}\\s\\d{1,10}\\b",
        "passed": false
    },
    {
        "id": 844,
        "completion": "\\d\\d[\\s-]\\d\\d$(I had been looking at the answers here: \\d{1}\\d{3}-\\d{3}\\d{3}{2}|\\d{2}\\s\\d{4}$To clarify, \\s- means \"space,dash or hyp",
        "passed": false
    },
    {
        "id": 844,
        "completion": "NAA+N+AnAN+AA+AnAN+ANAN+AnAn",
        "passed": false
    },
    {
        "id": 844,
        "completion": "\\d-\\d\\d-\\d\\d",
        "passed": false
    },
    {
        "id": 844,
        "completion": "AANA NAA|AANN NAA|AANA NAA|AANA NAA|AANN NAAGenerate a RegEx for this description.AAN NAA|ANN NAA|AIN NAA|AIN NAA|AIN NAA|AIN NAAGenerate a RegEx for this description.AANN N",
        "passed": false
    },
    {
        "id": 844,
        "completion": "A[G-Z][A-Z]\\d?[A-Z]",
        "passed": false
    },
    {
        "id": 844,
        "completion": "^([0-9A-Z])([A-Z]|[a-z]|[0-9]|[A-Z]?\\\\.[A-Z]?){7}$",
        "passed": false
    },
    {
        "id": 848,
        "completion": "%&quot;[^\\\\s]*%&quot;\\\\S*I am learning a few new things, including how to use regular expressions with text. I am interested in knowing how to use this pattern with an input file with spaces only. Here is my try so far.while true {echo",
        "passed": false
    },
    {
        "id": 848,
        "completion": "String = myname          RegEx = &quot;(\\w+)\\s+\\1 &quot;",
        "passed": false
    },
    {
        "id": 848,
        "completion": "(?<=(?<!\\\\ ).)(?= &quot;$1 &quot;?|&quot;$1 &quot;&quot;$1 )(?<!\\\\ ) &quot;$2 &quot; &quot;$2 &quot;",
        "passed": false
    },
    {
        "id": 848,
        "completion": "",
        "passed": false
    },
    {
        "id": 848,
        "completion": "[\\s\\']+",
        "passed": false
    },
    {
        "id": 848,
        "completion": "(?<!(^[A-z]))[^A-z!&quot;]+(?![A-z])",
        "passed": false
    },
    {
        "id": 848,
        "completion": "(?i)((.)\\s((?i)1|2[A-Z]){2,4,7})",
        "passed": false
    },
    {
        "id": 848,
        "completion": "To generate the RegEx for this, we need to find the pattern that removes all consecutive spaces between characters: (?<= ) and (?= ). This pattern will match any spaces, but only if they are surrounded by characters. We then need to replace these spaces with a single space using a regular expression: [ ]+ to",
        "passed": false
    },
    {
        "id": 848,
        "completion": "[ \\t]*?[^ \\t]+",
        "passed": false
    },
    {
        "id": 848,
        "completion": "&quot;([a-zA-Z0-9_]+)\\s+([a-zA-Z0-9_]+)\\s*([a-zA-Z0-9_]+)$&quot;",
        "passed": false
    },
    {
        "id": 851,
        "completion": "^",
        "passed": false
    },
    {
        "id": 851,
        "completion": "(\\d\\d\\d\\/\\d\\d\\/\\d\\d\\d\\d\\d00|\\d\\d\\d\\/\\d\\d\\d\\d\\d\\d)\\D(\\d\\d\\d\\d\\d)",
        "passed": false
    },
    {
        "id": 851,
        "completion": "The pattern is: \\d{4}/\\d{2}/\\d{2}",
        "passed": false
    },
    {
        "id": 851,
        "completion": "(see example below)",
        "passed": false
    },
    {
        "id": 851,
        "completion": "(a) [\\d]{3}\\+[a-z]{1}\\+[0-9][a-z]{1}\\+[\\d]{4}            (b) [\\d]{2}\\+[a-z]{1}\\+[0-9][a-z]{1}\\+[\\d]{4}             (c) (\\d{4}),(\\d{10})",
        "passed": false
    },
    {
        "id": 851,
        "completion": "(\\d\\d\\d\\s[a-z]{4}\\s\\d{4}\\s\\d{2})",
        "passed": false
    },
    {
        "id": 851,
        "completion": "\\w is the pattern for a word char (only letters, digits, and underscores) of length 1 to unlimited. \\d is the pattern for a digit. \\W is the pattern for any character outside a letter, digit, or underscore. \\S is the pattern for non-whitespace. \\b is the boundary, to make sure that it matches the start or end of a word, and not the part of itself. [A-Za-z] is a character class for",
        "passed": false
    },
    {
        "id": 851,
        "completion": "(?:C(?:M{0,3})(?:[0-9]{1,2})(?:[0-9]{1,2})?)(?:Y[0-9][0-9])(?:[0-9]{4})",
        "passed": false
    },
    {
        "id": 851,
        "completion": "[YYYYMM][0-9]{2}-[0-9]{2}",
        "passed": false
    },
    {
        "id": 851,
        "completion": "\\d{4}-\\d{2}-\\d{2} \\d{2}/\\d{2}",
        "passed": false
    },
    {
        "id": 859,
        "completion": "^[1-9][.0-9]|1[0-8]$",
        "passed": false
    },
    {
        "id": 859,
        "completion": "|(?!0.00)\\b\\d{1,2}%.",
        "passed": false
    },
    {
        "id": 859,
        "completion": "(1|0)\\d{0,2}\\.\\d{1,2}",
        "passed": false
    },
    {
        "id": 859,
        "completion": "The regex pattern should be `^0-100$|^-100$|^100/-100$`.",
        "passed": false
    },
    {
        "id": 859,
        "completion": "{number range}%",
        "passed": false
    },
    {
        "id": 859,
        "completion": "",
        "passed": false
    },
    {
        "id": 859,
        "completion": "\\\\b0\\\\d{0,2}(\\\\.\\\\d{0,2})\\\\b",
        "passed": false
    },
    {
        "id": 859,
        "completion": ".{0,2}(\\,|\\.\\)*",
        "passed": false
    },
    {
        "id": 859,
        "completion": "(?<!\\w)(-(?:\\d+(\\.\\d+)?|\\.\\d+)(?!\\w)?)",
        "passed": false
    },
    {
        "id": 859,
        "completion": "^0[1-9]+\\d*([\\+\\-])0[1-9]+[\\.]\\d{1,2}$",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer: '([A-Z][a-z0-9]*[A-Z]|[a-z][A-Za",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer:\\b(\"diligendolores\")*\\.",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer:?????   OR  ?(?:ST)?ARG?OR\t?(?:LEARNT)?ARG??OR?",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer: (.*)\\?(.*)Example from your post: *&quot;The number of searches in the past decade has",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer: This one works for my use case. But maybe not for yours.",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer: (?:&(?=(?:[^-\\s]*)-)?[^,]*-(?:\\s|[^,",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer:/<[a-zA-Z0-9-_]+\\.[a-z]{1,8}/",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer: ((\\b\\w+\\s\\w+)|(\\b\\w+\\s\\w+\\.))",
        "passed": false
    },
    {
        "id": 861,
        "completion": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.I've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.Generate a RegEx for this description. Answer:(([^\\dA-Za-z\\, \\. ])+)Explanation(             # Match capture group",
        "passed": false
    },
    {
        "id": 862,
        "completion": "(?<![^01])([01]{0,6})[01]",
        "passed": false
    },
    {
        "id": 862,
        "completion": "To validate a Binary string, we should use the \u2018^[01]+$\u2019 pattern which will mean \u2018Binary strings must have 0\u2019, 1\u2019, or an empty string\u2019 as the first character\u2019.",
        "passed": false
    },
    {
        "id": 862,
        "completion": "(?P<length>\\d+)$  All occurrences in the expression must match a digit.",
        "passed": false
    },
    {
        "id": 862,
        "completion": "^[a-zA-Z0-9_\\-\\.]+$",
        "passed": false
    },
    {
        "id": 862,
        "completion": "r\"(?=(a|b)+{1})(?:ab|ba).*\"",
        "passed": false
    },
    {
        "id": 862,
        "completion": "^[0-9a-f]{1,4}$",
        "passed": false
    },
    {
        "id": 862,
        "completion": "a valid binary string must contain only '1' and '0'. You can use a character class and a literal character to match each character.```pythonimport re",
        "passed": false
    },
    {
        "id": 862,
        "completion": "^(0|1)(0|1){0,3}$",
        "passed": false
    },
    {
        "id": 862,
        "completion": "(\\\\d)\\\\d*",
        "passed": false
    },
    {
        "id": 862,
        "completion": "/^((1{1,})|(0{1,}))?((1{1,})(1{1,})|((0{1,})(0{1,})))?$/",
        "passed": false
    },
    {
        "id": 865,
        "completion": "Regex: (0|[1-9][0-9]*)([a-f0-9]{6})\\\\.([a-f0-9]{2})\\\\.([a-f0-9]{4})[- ](\\\\d+)",
        "passed": false
    },
    {
        "id": 865,
        "completion": "",
        "passed": false
    },
    {
        "id": 865,
        "completion": "https://www.regquery.com/hsearch?q=(\\w+).+?-([0-9-]*)",
        "passed": false
    },
    {
        "id": 865,
        "completion": "esn = /^([0-9A-Fa-f]{12})$/gi",
        "passed": false
    },
    {
        "id": 865,
        "completion": "\"^([0-9A-Fa-f]{3}\\.){3}\"",
        "passed": false
    },
    {
        "id": 865,
        "completion": "r\"^ESN:(0[1-9]|3[01])[ 0-9][0-9]{6}$\"",
        "passed": false
    },
    {
        "id": 865,
        "completion": "r'[a-zA-Z0-9]{7}-\\d{3}-\\d{3}-\\d{4}'",
        "passed": false
    },
    {
        "id": 865,
        "completion": "*(\\\\d{3})(\\\\d*)\\\\s\\\\d(\\\\d*)[-/\\\\.\\\\+\\\\*]?!",
        "passed": false
    },
    {
        "id": 865,
        "completion": "\\b#[0-9a-fA-F]{16}\\b",
        "passed": false
    },
    {
        "id": 865,
        "completion": "```pythonESN_REGEX = r\"^\\s*(0)?-?\\d{7}-?\\d{3}$\"```",
        "passed": false
    },
    {
        "id": 869,
        "completion": ".*(?:0[9]{2}[1-9])[.][0-9]",
        "passed": false
    },
    {
        "id": 869,
        "completion": "^0[1-9]\\d{9} (?: )\\d{3}1[1",
        "passed": false
    },
    {
        "id": 869,
        "completion": "((?=(\\s|^)^(19))|(?=(\\s|^)^(",
        "passed": false
    },
    {
        "id": 869,
        "completion": "r'^[0-9]\\s|\\s|\\(|\\)|\\^|\\",
        "passed": false
    },
    {
        "id": 869,
        "completion": "/^\\(01[9][9][9][9]|0[9][9]\\d",
        "passed": false
    },
    {
        "id": 869,
        "completion": "(\\d{3}?)?(\\d{3})?((() | \\s)?\\d",
        "passed": false
    },
    {
        "id": 869,
        "completion": "The first 2 lines contain valid formats.Now create an instance variable \"phonenumber_valid\". Set it to",
        "passed": false
    },
    {
        "id": 869,
        "completion": "^[0-9][0-9]{4}[0-9][0-9",
        "passed": false
    },
    {
        "id": 869,
        "completion": "(?<=\\d{3})\\s?\\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 869,
        "completion": "^[0-9]{3}([0-9]{7})?$|^[0",
        "passed": false
    },
    {
        "id": 870,
        "completion": "([0]{3})([79]|80)?([0-9]{4})",
        "passed": false
    },
    {
        "id": 870,
        "completion": "regex = r'[077]?(\\d{7})?[\\s]?(?:7)\\",
        "passed": false
    },
    {
        "id": 870,
        "completion": "^[0-9][0-9]{8} (?=.*[1-9]$)[0-",
        "passed": false
    },
    {
        "id": 870,
        "completion": "`(^[0-9]{1,2}\\[(78|90)\\] [0-9]{",
        "passed": false
    },
    {
        "id": 870,
        "completion": "[077[0-9] 4[3-9][0-9]]",
        "passed": false
    },
    {
        "id": 870,
        "completion": "`^[^ ]* [0]?7[0]?7?$ | [0]?0?7",
        "passed": false
    },
    {
        "id": 870,
        "completion": "^(077|078|079)[ 0-9]{4} (07|08)?[",
        "passed": false
    },
    {
        "id": 870,
        "completion": "{4,5}[0-9]{4}[ 0-9]{3}\\s{1,3",
        "passed": false
    },
    {
        "id": 870,
        "completion": "[0-7][7-9][0-9]Exercise 3: Rewrite the given phone number in the",
        "passed": false
    },
    {
        "id": 870,
        "completion": "(077|078|079) {8}",
        "passed": false
    },
    {
        "id": 876,
        "completion": "^[0-39]-[0-9][a-z]?",
        "passed": false
    },
    {
        "id": 876,
        "completion": "^(0[1-9]?[|]0?)[0-9]|([1-9]?[0-9])([|]0)?(0[1-9]?[|]0?)[0-9]$ Examples:0040707  0111  00",
        "passed": false
    },
    {
        "id": 876,
        "completion": "0(1[12]|[1-9])\\/Month 0 has a leading 0 so we need only add 0 at the beginning.",
        "passed": false
    },
    {
        "id": 876,
        "completion": "(\\d+\\b)([a-zA-Z]{2}\\d+)?\\s?(\\w+))? Note that this regex will match the days from 1-31, in any order and in any combination of cases with and without leading 0. It will also match any leading zeros in names like Jan 23 or Jan 10",
        "passed": false
    },
    {
        "id": 876,
        "completion": "\\D(0+|1+|2+|3+|4+|5+)",
        "passed": false
    },
    {
        "id": 876,
        "completion": "^[a-z0-9]{3}\\1{3}\\1",
        "passed": false
    },
    {
        "id": 876,
        "completion": "^(0|[12])(1[0-2])$",
        "passed": false
    },
    {
        "id": 876,
        "completion": ".0011|.0001",
        "passed": false
    },
    {
        "id": 876,
        "completion": "(^\\d{1,2}\\d?$)",
        "passed": false
    },
    {
        "id": 876,
        "completion": "\\b(?:(?:0(?:[1-9])|(?:[12]))\\d?\\d?)\\W?\\d\\b",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating a",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating a",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating a",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating a",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating milliseconds",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating \"",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating before",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating an",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating a",
        "passed": false
    },
    {
        "id": 877,
        "completion": "This should be the pattern described in the documentation for the.NET TimeSpan.Parse method - generally parses time spans.From the.NET docs:public static TimeSpan Parse(string s);The s parameter contains a specification of the form:[ws][-][d.]hh:mm:ss[.ff][ws]Items in square brackets ([ and ]) are optional, colons and periods (: and.) are literal characters, and other items are as follows.Item Descriptionws optional white space&quot;-&quot; optional minus sign indicating an",
        "passed": false
    },
    {
        "id": 879,
        "completion": "^\\s*(-?[0-9]*(?:\\.[0-9]*)?|(?:[0-9]*)(?:\\.[0-9]+))([\\+\\*]\\s?)?(?:[0-9]*(?:\\.[0-9]*)?|(?:[0-9]*)(?:\\.[0-9]+))\\s*$",
        "passed": false
    },
    {
        "id": 879,
        "completion": "^\\d+((\\.\\d+)?(e[-g+])?|(1?[0-9])([eE][-\\d]?[0-9]?)?)$",
        "passed": false
    },
    {
        "id": 879,
        "completion": "(\\b[1-9][0-9]?\\.[0-9]{1}\\b)",
        "passed": false
    },
    {
        "id": 879,
        "completion": "[0-9]+\\.?[0-9] ([\\d\\-\\.]+)Match numbers 0 through 99.9Allows only one preceding zero and does not require the decimal pointGenerate a RegEx for this description.Answer: [0-9]+\\.?[0-9]( [\\d\\-\\.]+ )Match numbers 0 to 99.99Allows only one preceding zero and does not require the decimal pointGener",
        "passed": false
    },
    {
        "id": 879,
        "completion": "^00-?[1-9][0-9]*$",
        "passed": false
    },
    {
        "id": 879,
        "completion": "[0-9]\\.[0-9]|0\\.[0-9]|9[0-9]|99[1-9][0-9]",
        "passed": false
    },
    {
        "id": 879,
        "completion": "\\d{0,99}(?:\\.\\d\\d)?",
        "passed": false
    },
    {
        "id": 879,
        "completion": "(\\d)102. Match any of the following three formatsa.  Zero (0)  b.  Zero (0)sc.  Zero (0)-   d.  Zero (0)-   e.  No-Zero (0)sAnswer: (\\d)0?|(\\d)[-.]0?|(\\d)[\\-.]0?3. Match any of the",
        "passed": false
    },
    {
        "id": 879,
        "completion": "0[1-9]\\d?|0[1-9][0-9]I know that this will work, but am I missing any important information regarding generating this regex.  This is due to the way I have to handle numbers 0-99 before 100.",
        "passed": false
    },
    {
        "id": 879,
        "completion": "^(0[1-9])|(0[1-9][0-9])|(0[1-9][0-9][0-9])|((([1-9][0-9]{0,2}[0-9])|([1-9][0-9]{0,3}.[0-9])))?|(0)$",
        "passed": false
    },
    {
        "id": 880,
        "completion": "```python# validating a device name with a regeximport re",
        "passed": false
    },
    {
        "id": 880,
        "completion": "^(?!_)(?!.*^(\\\\/|:|\\\\| |\\\\-|\\\\\\+|\\\\-|\\\\:|\\\\|):\\\\|:|\\\\|)|(?P<devices>[a-zA-Z0~-]+)::(?P<names>.*$)(\\d{1,2}[\\\\-/\\\\+]?\\d{1,2}[\\\\-/",
        "passed": false
    },
    {
        "id": 880,
        "completion": "(\\D+:\\d+.)\\:([A-Fa-f0-9]{2}):([A-Fa-f0-9]{2})",
        "passed": false
    },
    {
        "id": 880,
        "completion": "",
        "passed": false
    },
    {
        "id": 880,
        "completion": "\\b[A-Za-z0-9\\-\\.]+\\b",
        "passed": false
    },
    {
        "id": 880,
        "completion": "(this is just an example) ^[A-D0-9:.]+$",
        "passed": false
    },
    {
        "id": 880,
        "completion": "/^\\d+.\\d+.\\d+/.*$/.",
        "passed": false
    },
    {
        "id": 880,
        "completion": "^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
        "passed": false
    },
    {
        "id": 880,
        "completion": "Ifregex = r'[a-zA-z\\-\\_0-9]+'           This RegEx will match any alphanumeric-dash-underscore character. It will work fine for most cases in unix filesystems.",
        "passed": false
    },
    {
        "id": 880,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: r\"[r9,0-9]+/s[0-9]+\\.([z]{1}|[z]?[r7a-fa-9][0-9]{0,3}|[r7a-fa-9][0-9]{0,",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer:.*r\\d{1,2}\\s*\\.rar.*r\\d{1,2}$",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: extMatchPattern = new RegExp(\"^([a-z])([0-9])([a-z]?)$\")",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: s##(r#)?Example: If the serie.Generate regex for's##(r#)?', then serie.Part1, serie.Part22,... and serie.Part1011 should be matched; serie.Part2 and serie.Part2",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: (?i)(?P<size>\\d{2,99}\\.){2}\\d{2}  (the whole series, not just the first one)  Pattern matches:1.0 1.012.0 2.003.004.99",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: /r?[(](?=[a-z])([a-z0-9])\\1\\b|[0-9]{1,97})\\s\\w+(\\[)?part[0-9a-z]{2}\\s(\\w+[.])[a",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: (r0[a-z]{1,5}00[0-9]{2}),(r09[a-z]{3}xr[0-9]{2}),(r0[a-z]{2}[0-9]{4})",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: (.rar)* (/.0?1)",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer:This tool requires rarfile and python to operate successfully```sh",
        "passed": false
    },
    {
        "id": 881,
        "completion": "RAR file extensions.Works also with '*.part01.rar' given '.rar' to be the file extension.Does not support volumes exceed 101 for s## (r99, s00, s01,...) serie.Generate a RegEx for this description. Answer: [a-z0-9\\-+]*([a-z]([ A-Z]|0-9)*[A-Za-z])\\.",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, whites",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, comm",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, digits",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, digits",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, spaces",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, etc",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, spaces",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, etc",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, spaces",
        "passed": false
    },
    {
        "id": 882,
        "completion": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.Format CIF: [1 letter][7 numbers][1 number or letter]Format NIF: [8 numbers][1 letter]Format NIE: X[possible 0][7 numbers][1 letter]Note that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.Generally I always strip out any non-alphanumeric characters (hyphens, periods, etc",
        "passed": false
    },
    {
        "id": 885,
        "completion": "[a-z0-9]+(\\.[a-z0-9]+){19}$",
        "passed": false
    },
    {
        "id": 885,
        "completion": "(?<![^-])[\\b-\\b](?!-)[^-\\.](?!-)",
        "passed": false
    },
    {
        "id": 885,
        "completion": "^\\^\\^?(?:[^\\^\\^\\^].*[^\\^\\^\\^])?\\$?(?:[^\\$\\^\\$].*[^\\$\\^\\^]))?$",
        "passed": false
    },
    {
        "id": 885,
        "completion": "^\\-=\\-=\\-\\?\\-\\?\\?\\-\\b_\\-\\_\\-\\+\\-\\-\\-\\+\\-\\-\\-\\-\\+\\-\\-\\-\\-\\+\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-",
        "passed": false
    },
    {
        "id": 885,
        "completion": "^\\[IPv6_IPv6Addr[^\\]]*](?:\\s|$)",
        "passed": false
    },
    {
        "id": 885,
        "completion": "[\\b(?:^|\\-$)(A+[\\b0-9A-Fa-f\\s]+[\\b0-9A-Fa-f\\s]+)\\b-\\b](?:[\\s\\-])(.[\\",
        "passed": false
    },
    {
        "id": 885,
        "completion": "$.*$",
        "passed": false
    },
    {
        "id": 885,
        "completion": "([a-zA-Z0-9]+)=(\\$|^[-_:.,%!~*#_'=_\\\\+?&%#@^-`$+=\\\\{\\\\}\\[\\\\]\\-\\\\|\\\\;",
        "passed": false
    },
    {
        "id": 885,
        "completion": "(?<!\\d-)(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\. | [\\da-fA-F]{1,4}\\.[0-9a-",
        "passed": false
    },
    {
        "id": 885,
        "completion": "([A-Fa-f0-9]{1,4}\\.){3}\\[A-Fa-f0-9:]{1,4}$",
        "passed": false
    },
    {
        "id": 890,
        "completion": "\\d*(?:\"\\d\"\\s*){1,2}(?:\"\\d\"\\s*)|(\\d+)\\.(\\d+",
        "passed": false
    },
    {
        "id": 890,
        "completion": "*1* $\\\\d{1,4}$ with the condition that $\\\\d{1,4}$ must be followed by 1 or 0 digit and the",
        "passed": false
    },
    {
        "id": 890,
        "completion": "(^[1-9][0-9]!|[1-9][0-9]*(,[0-9]\\d?)(\\.?",
        "passed": false
    },
    {
        "id": 890,
        "completion": "(?![0-9]*$)^[1-9][0-9]*[.,][0-9]*[.,][0-9",
        "passed": false
    },
    {
        "id": 890,
        "completion": "&quot;(\\d{1,3}(,\\d{3}){3})|[\\-]&quot;(\\d{0,2",
        "passed": false
    },
    {
        "id": 890,
        "completion": "(^[123-9][0-9]?[0-9.]+([0-9]+)?)+Using this RegEx, you can accept",
        "passed": false
    },
    {
        "id": 890,
        "completion": "\\$ + (?:\\. - \\d{0,3} [.] \\d{0,2} [.] \\d{0,4})",
        "passed": false
    },
    {
        "id": 890,
        "completion": "\\$?[\\d.e-e]{3,16}(,[\\d.e-e]{3,16})?(,[\\d",
        "passed": false
    },
    {
        "id": 890,
        "completion": "(?<=^\\d+)(?:,|&quot;)(?=\\d+$)",
        "passed": false
    },
    {
        "id": 890,
        "completion": "[$\\\\|\\\\d,\\\\d\\\\d\\\\d\\\\d\\\\.?\\\\d\\\\d\\\\d] *** Additional test case:    Input",
        "passed": false
    },
    {
        "id": 891,
        "completion": "Flintstone, Stan, Flinty",
        "passed": false
    },
    {
        "id": 891,
        "completion": "",
        "passed": false
    },
    {
        "id": 891,
        "completion": "Mickey Mouse, Ronald Knute, Barney Rubble, and Betty Boop.",
        "passed": false
    },
    {
        "id": 891,
        "completion": "Fred Flintstone, Barney Rubble, Betsy, and Denny.",
        "passed": false
    },
    {
        "id": 891,
        "completion": "Fred Flintstones (F), Barney & Ted (B), Larry (L), and Betty (B).",
        "passed": false
    },
    {
        "id": 891,
        "completion": "Tom, Jerry, Daffodils, and Flintstones.",
        "passed": false
    },
    {
        "id": 891,
        "completion": "Leonardo (R)Bartlett (W)Walter (W)Bartlett (W)",
        "passed": false
    },
    {
        "id": 891,
        "completion": "The four main characters of The Flintstones are Barney and Friends (RegEx: \"^.*Frank.*\"), Fred and Friends (RegEx: \"^.*Frank.*&.*Fred.*\").",
        "passed": false
    },
    {
        "id": 891,
        "completion": "The Friction Fighters, Frank, Jane, and Jack.",
        "passed": false
    },
    {
        "id": 891,
        "completion": "Fred Flintstone = M.M, Barney Rubble = G.R.",
        "passed": false
    },
    {
        "id": 894,
        "completion": "/^1[2-9]|[2-9]\\d{3}[0-9]$/",
        "passed": false
    },
    {
        "id": 894,
        "completion": "/^0[6-9]\\d{8}$/",
        "passed": false
    },
    {
        "id": 894,
        "completion": "/^(\\d{3})(?!.)(?!-\\-|-|/)(?:6|7)(\\s|-)+$/",
        "passed": false
    },
    {
        "id": 894,
        "completion": "^^([0-9][0-9][0-9][0-9][-])([0-9][0-9][0-9][0-9][-][0-9])([0-9][0-9][0-9][0-9][0-9][-][0-9])$",
        "passed": false
    },
    {
        "id": 894,
        "completion": "^(0\\d{2}|\\d{5}(?:\\.\\d{3})*)$|^(0\\d{6})?$",
        "passed": false
    },
    {
        "id": 894,
        "completion": "newExpression = [    new expression for new expression if newExpression.match(regex)     else None]",
        "passed": false
    },
    {
        "id": 894,
        "completion": "*\\/\\d{4,7}*",
        "passed": false
    },
    {
        "id": 894,
        "completion": "^0[1-9][0-9]*([0-9][0-9]{3})?|^6[0-8][0-9]{3}$",
        "passed": false
    },
    {
        "id": 894,
        "completion": "^[[0-9]{1,2}[0-9]{1,2}][ ]?6([0-6][0-9])[ ]?$",
        "passed": false
    },
    {
        "id": 894,
        "completion": "^(0{1}[1-9]|6[0-9]|7[0-9])$",
        "passed": false
    },
    {
        "id": 895,
        "completion": "[1-2][0-7](|[0-9][0-9]|AM|PM|AM|PM|)",
        "passed": false
    },
    {
        "id": 895,
        "completion": "((?<=(\\d|\\p{Z}))(?:(?:H|h)?:){2,}((?=\\d)|$))",
        "passed": false
    },
    {
        "id": 895,
        "completion": "var regEx = /-\\+([0-1]?[0-9])?([0-9]+)\\s([0-9:]{2})\\S*(?:[ap]m)?/",
        "passed": false
    },
    {
        "id": 895,
        "completion": "\"^([1-9][0-9]|1[012]) [a-zA-Z]$\"",
        "passed": false
    },
    {
        "id": 895,
        "completion": "(^\\d|1?\\d|[1-9]\\d)$",
        "passed": false
    },
    {
        "id": 895,
        "completion": "(\\d{1,2}(?:[:-](\\d{1,2}))?)? (ap)\\.?m\\.?",
        "passed": false
    },
    {
        "id": 895,
        "completion": "/^(\\d{1,2})\\:(\\d{2})\\:(\\d{2})\\/(\\d{1,2})/        /\\1\\2:\\3\\4:\\5/",
        "passed": false
    },
    {
        "id": 895,
        "completion": "^(\\d{2})(:?)(\\d{2})(:?)(\\d{2})$",
        "passed": false
    },
    {
        "id": 895,
        "completion": "(0,0): (0) 0:00(0, 30): (0) 0:30(1, 0):  (1)  00:00(1, 30):  (1)  30:00(2, 0):   (2)  00:00(2, 30):  (2)  30:00",
        "passed": false
    },
    {
        "id": 895,
        "completion": "^([01][0-9]|2[0-3]):[0-5][0-9)([ap]m)?\\.$",
        "passed": false
    },
    {
        "id": 898,
        "completion": "(.*)",
        "passed": false
    },
    {
        "id": 898,
        "completion": "^[a-zA-Z0-9].*$",
        "passed": false
    },
    {
        "id": 898,
        "completion": "\\w",
        "passed": false
    },
    {
        "id": 898,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 898,
        "completion": "\\w",
        "passed": false
    },
    {
        "id": 898,
        "completion": ".*\\d{3}-\\d{2}-\\d{4}$",
        "passed": false
    },
    {
        "id": 898,
        "completion": "(\\d{1,9})(\\s+)?(alpha|anumeric|symbol",
        "passed": false
    },
    {
        "id": 898,
        "completion": "(\\w+)\\_[A-Za-z][0-9]_{1,9}\\_?",
        "passed": false
    },
    {
        "id": 898,
        "completion": "/^[A-Z0-9]+$/.",
        "passed": false
    },
    {
        "id": 898,
        "completion": "This exercise can be solved by combining the basic syntax for a regular expression (^.$) with other relevant concepts to construct a RegEx that can capture alphanumeric substrings.",
        "passed": false
    },
    {
        "id": 901,
        "completion": "$re = '/(?i)((?:(?:4[123]|5[012])?(365|366)?(?:-44|0)([1-9]|[1-9]\\d|200(?",
        "passed": false
    },
    {
        "id": 901,
        "completion": "[01]\\d{1,6}[\\-\\.\\)]MM[/-\\.\\d{1,6}]This can also be simplified to : [01]\\d{1,6}\\D\\/d\\/Y",
        "passed": false
    },
    {
        "id": 901,
        "completion": "public static Regex GetDateTimeExpression(DateTime date, bool allowLeapYear = true)    {        // This is probably easier, but it also takes 2 seconds, so use it        // if the user is",
        "passed": false
    },
    {
        "id": 901,
        "completion": "\"^(?:0|[1-9][0-9]{0,2}(?:,\\s*[0-9]{1,3}[0-9]{3}|[1-9][0-",
        "passed": false
    },
    {
        "id": 901,
        "completion": "^(0((1[6-9]|2[0-4][0-9])|(3[01]))-(0[5-9]|1[012])-(0[13578]|[01])-(19",
        "passed": false
    },
    {
        "id": 901,
        "completion": "@\"\\d{4, \\d\\d}\\/\\d{1,3}\\/\\d{2,4}\\s*\"",
        "passed": false
    },
    {
        "id": 901,
        "completion": "^M/\\d{3}\\/[0-9]{2}/\\d{\" + ( ( 9999 - 1900) + 1 ) + \"}$",
        "passed": false
    },
    {
        "id": 901,
        "completion": "([0-9]{4})-([0-9]{2})-(00|01|02)[0-9]{4}",
        "passed": false
    },
    {
        "id": 901,
        "completion": "(?i)([2][0-9]{8})-(?P<day>\\d{2})/(?P<month>\\d{2})/(?P<year>\\d{4})/",
        "passed": false
    },
    {
        "id": 901,
        "completion": "^(?P<year>\\d{4})(-(?P<month>01|02|03|04|05|06|07|08|09|10|11|12))?(-(?P<day>",
        "passed": false
    },
    {
        "id": 909,
        "completion": "(0|[1-9][0-9]*)([\\.][0-9][0-9]*)?",
        "passed": false
    },
    {
        "id": 909,
        "completion": "^[0-9]+(([.[0-9]][0-9][0-9])?)$        Examples        11.22        -11.22        0.44 -44.44        1.45E2 -1.24E2\"\"\"        self.validateType(\"value\", value, {\"Number\", \"NumberList\", \"String",
        "passed": false
    },
    {
        "id": 909,
        "completion": "/^[0-9]+(?:\\.[0-9]+)?$/uExercise 2:Design a Python function that removes the digits on the left side of a matched match and returns the remaining numbers.Exercise 2 Answer:def extract_decimals(text, pattern):    return re.sub(pattern, '', text)",
        "passed": false
    },
    {
        "id": 909,
        "completion": "^[1-9][0-9]?[0-9]*\\.?(0|[1-9][0-9]*)?[0-9]*$It will not allow.0 after last non  positive decimal place and cannot allow a 0 after last decimal place.",
        "passed": false
    },
    {
        "id": 909,
        "completion": "0.1.{0,4}(?:\\.{0,2}(?:\\d*))?",
        "passed": false
    },
    {
        "id": 909,
        "completion": "^(\\d+\\.)*\\d{1,10}$",
        "passed": false
    },
    {
        "id": 909,
        "completion": "0,1,3,9,100..",
        "passed": false
    },
    {
        "id": 909,
        "completion": "^\\d+(\\.\\d+)?([eE]([+-]\\d+)?)?$",
        "passed": false
    },
    {
        "id": 909,
        "completion": "^(?:\\d+(?:\\.\\d*)?)(?:-\\d+(?:\\.\\d*)?)(?:[eE][+-]?\\d+)$        1st Capturing Group: (?:\\d+(?:\\.\\d*)?)(?:-\\d+(?:\\.\\d*)?)(?:[eE][+-",
        "passed": false
    },
    {
        "id": 909,
        "completion": "\\d+\\.?\\d*(e[+-]\\d+)*/\\d+-g",
        "passed": false
    },
    {
        "id": 911,
        "completion": ".*\\.\\d{3}-\\d{2}-\\d{",
        "passed": false
    },
    {
        "id": 911,
        "completion": "^\\\\d{4}-\\\\d{2}-[\\\\d{2",
        "passed": false
    },
    {
        "id": 911,
        "completion": "(?:^|[^0-9])1{2}[^",
        "passed": false
    },
    {
        "id": 911,
        "completion": "^(\\d{4}-\\d{2}-\\d{",
        "passed": false
    },
    {
        "id": 911,
        "completion": "if (/\\d{4}/ and (regex_replace(number,",
        "passed": false
    },
    {
        "id": 911,
        "completion": "(10|2[0-2]|20|11|4[01",
        "passed": false
    },
    {
        "id": 911,
        "completion": "(\\d{1,2}[.,-](\\d{1,2",
        "passed": false
    },
    {
        "id": 911,
        "completion": "var regex = /^(0[1-9]|1[",
        "passed": false
    },
    {
        "id": 911,
        "completion": "^[2-9][0-9]|1[-9][",
        "passed": false
    },
    {
        "id": 911,
        "completion": "\\d*[-\\.]\\d*[-\\.]\\d*",
        "passed": false
    },
    {
        "id": 913,
        "completion": "[{number:2,format:'mm.dd',length:(2-4)+1,sep:' '},    {number:2,format:'dd.mm',length:(4-2)+1,sep:' '},    {number:4,format:'mm.dd',length:len",
        "passed": false
    },
    {
        "id": 913,
        "completion": "^[0-9]+([0-9]{3})([0-9])-([0-9])(0)$",
        "passed": false
    },
    {
        "id": 913,
        "completion": "^((012)\\d{6}(01|02|03|04|05|06|07|08|09|10|11|120)Y|0123456789)$",
        "passed": false
    },
    {
        "id": 913,
        "completion": "^YearlyExpression(/\\d{4}$|/\\d{4}(?:-\\d{4})?)$",
        "passed": false
    },
    {
        "id": 913,
        "completion": "var regexForValidDate = new Regex(    @\"(0\\d)\\s+(0\\d)-\\s+(0\\d\\d) (0\\d\\d) (0\\d\\d) [^/\\s]+ /\\d [^/\\s]+\",    Regex",
        "passed": false
    },
    {
        "id": 913,
        "completion": "System.Text.RegularExpressions.Regex rx = new System.Text.RegularExpressions.Regex(        \"^(?:(1[01])|(0[13]))/(2[01]|[12]|[13])-(?<year>\\d{4})$",
        "passed": false
    },
    {
        "id": 913,
        "completion": "\\d{4}-(\\d{1,2}[-., ]+\\d{1,2})",
        "passed": false
    },
    {
        "id": 913,
        "completion": "the following should work (also in Javascript)",
        "passed": false
    },
    {
        "id": 913,
        "completion": "^(19[89]|20[1-9]|200)s?(([0-1][0-9])|([0-9][0-9])|200)s?(\\.00)?$",
        "passed": false
    },
    {
        "id": 913,
        "completion": "\\s\\d\\s+\\d\\s+\\d\\s+",
        "passed": false
    },
    {
        "id": 914,
        "completion": "(\\d\\|\\d\\d)\\s+Explanation:(\\d\\|\\d\\d) - Match exactly 2 numbers\\s+ - one or more whitespaces",
        "passed": false
    },
    {
        "id": 914,
        "completion": "/^(?:2000|1800|1600|1400|1200|10|0)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)\\-(?!\\d+20$)\\d{2,4}\\-\\d{2}$/",
        "passed": false
    },
    {
        "id": 914,
        "completion": "16[0-9]/[12][0-9]/[02][0-9]",
        "passed": true
    },
    {
        "id": 914,
        "completion": "[A-Z]{3,5}[0-9]{3}[0-9]{2}Explanation : 4 to 5 alphabets followed by 3 digits, then 2 digits.Example : MARC 2021",
        "passed": false
    },
    {
        "id": 914,
        "completion": "^((1700)|(1720)|(1740)|(1750)|(1760)|(1770)|(1780)|(1790)|(1800)|(1801),(1802),(1803),(1804),(1805),(1806),(1807),(1808),(1809),(1810),(1811),",
        "passed": false
    },
    {
        "id": 914,
        "completion": "\\d{1,3}(X[1-9])\\d{2}\\d{4}",
        "passed": false
    },
    {
        "id": 914,
        "completion": "(1600): \\d{4}-(\\d{2}-\\d{2})Minimum and maximum yearMy Regex.^(?!.*00)[4-9]\\d{2}( |-)(20\\d{2}$)This works as it should.I am not sure if the min year requirement is right.",
        "passed": false
    },
    {
        "id": 914,
        "completion": "^\\d{{4}}\\/\\d{{2}}-\\d{{2}}$, where \\d is used to accept digit characters which is an indication of a number.",
        "passed": false
    },
    {
        "id": 914,
        "completion": "/((20) \\d{4}\u5e74|(2000)\u5e74|2020\u5e74|[20,19]\\d\\d\u5e74)\\((2)\\d\\d\\d\\/\\d\\d\\d\\/\\d\\d\\d)\\((1)\\d\\d\\d\\d\\d\\d)\\((1)\\d\\d\\d",
        "passed": false
    },
    {
        "id": 914,
        "completion": "2 digits followed by 3 digits",
        "passed": false
    },
    {
        "id": 915,
        "completion": "\\d{2}-(\\d{2}):(\\d{2}):(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
        "passed": false
    },
    {
        "id": 915,
        "completion": "[^ ]*:[0-1]\\d\\dA[0-9]|[2][0-3]:[0-5]\\dA[0-9]B",
        "passed": false
    },
    {
        "id": 915,
        "completion": "h[^0-9A-Za-z]{2})([0-5][1-9][0-9]{2})([0-4][0-9][0-9]{2})([0-9]{2})([0-5][1-9][0-9]?)",
        "passed": false
    },
    {
        "id": 915,
        "completion": "[0-9]{1,5}-[0-9]{4}.[0-9][0-9][0-9]",
        "passed": false
    },
    {
        "id": 915,
        "completion": "01.10.14.00",
        "passed": false
    },
    {
        "id": 915,
        "completion": "(\\d{1,2})\\s*:\\s*(\\d{2})\\s*(?=\\s*[AP]M)",
        "passed": false
    },
    {
        "id": 915,
        "completion": "^\\d{2}(\\:?\\d{2}){0,2}(\\.)\\d\\d\\d$",
        "passed": false
    },
    {
        "id": 915,
        "completion": "^(0|[1-9])([1-9]|0?[1-9])?[012]$",
        "passed": false
    },
    {
        "id": 915,
        "completion": "^(0[1-9]|[12][0-9])[0-9]{4}([0-5][0-9])[0-9]{2}([0-9]?(0[0-9]|1[0-9]))[h]$",
        "passed": false
    },
    {
        "id": 915,
        "completion": "\\[([0-9]{1,2})\\s?,([0-9]{1,2}\\s)?([0-9]{1,2}\\s)?([0-9]{4})([0-9]{3})(\\s)?([0-9]{2})(\\s)?([0-9]{1})(\\s)?([0-9]{4})(\\s)?\\]([0-",
        "passed": false
    },
    {
        "id": 916,
        "completion": "(?=\\D)([1-9]\\d?\\d*\\.?)\\d",
        "passed": false
    },
    {
        "id": 916,
        "completion": "",
        "passed": false
    },
    {
        "id": 916,
        "completion": "^[0-9]+\\.[1-9][0-9]*$",
        "passed": false
    },
    {
        "id": 916,
        "completion": "(?<!\\D)(\\d*(-\\d*)|(\\d*)($|^))?",
        "passed": false
    },
    {
        "id": 916,
        "completion": "+[0-9.]{1,9}",
        "passed": false
    },
    {
        "id": 916,
        "completion": "/^(0.+[0-9]*)\\.[0-9]+$/(0+ is a quantifier that allows one or more digits. [0-9] is a digit from A to Z. \\] is a literal ']' that can appear anywhere in a regex. (.*) is anything... and $ is the end of the string. So this matches any decimal value with",
        "passed": false
    },
    {
        "id": 916,
        "completion": "(?<=\\.)\\d+(?!\\.0)",
        "passed": false
    },
    {
        "id": 916,
        "completion": "((^(\\-?0\\.0{3}|[1-9]\\d{0,3})(\\/([1-9]\\d?|1?0))?)",
        "passed": false
    },
    {
        "id": 916,
        "completion": "\\d+\\.\\d+",
        "passed": false
    },
    {
        "id": 916,
        "completion": "@Registers:\\\\d*(\\\\.\\\\d\\\\d+)",
        "passed": false
    },
    {
        "id": 918,
        "completion": "/(?:\\d{1,2}/(?:(?:29|30)|30))\\d{4}\\D?[a-zA-Z]{3,4}/",
        "passed": false
    },
    {
        "id": 918,
        "completion": "^([0-9]{1,})([\\/\\-])?([1-3][0-9])([\\/\\-])([0-9]{4})$",
        "passed": false
    },
    {
        "id": 918,
        "completion": "^\\D*(\\d\\d\\d)\\-(01\\d\\d\\-\\d\\d\\-\\d\\d\\d).(\\d\\d\\d\\d)\\-(\\d\\d\\d\\-\\d\\d",
        "passed": false
    },
    {
        "id": 918,
        "completion": "year|month|day|hour|minute |second",
        "passed": false
    },
    {
        "id": 918,
        "completion": "var a = GenerateDateRange(new Date(2020,06,25), new Date(2021,01,25));",
        "passed": false
    },
    {
        "id": 918,
        "completion": "[1-9][0-9][0-9][0-9][0-9][0-3][0-9][-0-3][0-9][-0-3][0-9][X]where X",
        "passed": false
    },
    {
        "id": 918,
        "completion": "\"^((?:[1-2][0-9])|(?:[0-3][0-9])|(?:19))(?:[1-9]|(?:[12]))(?:[0-9])$",
        "passed": false
    },
    {
        "id": 918,
        "completion": "/^[0-9]+/?[-\\/,\\.\\s]*[0-9]{1,2}/gm",
        "passed": false
    },
    {
        "id": 918,
        "completion": "/^(([0]||[1][0-8][0-9]|29),(0(1[0-9]|2[0-9]|3[02])|3[0-1]))(",
        "passed": false
    },
    {
        "id": 918,
        "completion": "\\d{4}(-[1-9]\\d{3})?|\\d{4}(0[1-9]|[12][0-9]|3[01])",
        "passed": false
    },
    {
        "id": 919,
        "completion": ".*\\$\\d\\d\\.(\\D.*|$)",
        "passed": false
    },
    {
        "id": 919,
        "completion": "0,000,000.001,000,000",
        "passed": false
    },
    {
        "id": 919,
        "completion": "/^(?:[0-9]{0,3}((?:[0-9]{3}[0-9]{2})|(?:[1-9][0-9]{3}[0-9]{2})[0-9])[\\s,](?:\\d{0,3}(?:\\.\\d{3})?|[\\.\\d",
        "passed": false
    },
    {
        "id": 919,
        "completion": "^\\s*((1000$)|(\\.\\d+(,\\d+)?))$",
        "passed": false
    },
    {
        "id": 919,
        "completion": "%s",
        "passed": false
    },
    {
        "id": 919,
        "completion": "(?<=^\\d{3})(\\d{3})(?=\\d)",
        "passed": false
    },
    {
        "id": 919,
        "completion": "^((?:(?:00|0)|1(?:[0-9]?|2[0-3]))(?:0(?:\\.|1[8-9])(?:,0)+0)|(?:(?:00|0)|1(?:[0-9]?|2[0-3]))(?:,[0-9]{3})*0)?$",
        "passed": false
    },
    {
        "id": 919,
        "completion": "[^,.]{1}[^.,]\\d+[^,.]{1}[^.,]\\d+",
        "passed": false
    },
    {
        "id": 919,
        "completion": "*^(?:\\d{1,3}[,.]\\d{3}(?:\\d{1,3})?|\\d{3})$*",
        "passed": false
    },
    {
        "id": 919,
        "completion": "\\d{1,3}\\.\\d+|\\d+\\,\\d+|\\d+\\.\\d+?",
        "passed": false
    },
    {
        "id": 923,
        "completion": "[a-c]",
        "passed": false
    },
    {
        "id": 923,
        "completion": "/[aeiou]+/",
        "passed": false
    },
    {
        "id": 923,
        "completion": "^[aeiou]{3,}$",
        "passed": false
    },
    {
        "id": 923,
        "completion": "/[aeiou][AEIOU]+/",
        "passed": false
    },
    {
        "id": 923,
        "completion": "\"^[Eaeiou].+\"",
        "passed": false
    },
    {
        "id": 923,
        "completion": "Vowel letter, or a group of letters, or a string of letters",
        "passed": false
    },
    {
        "id": 923,
        "completion": "(^.[aeiou]{1}|[aeiou]+$)",
        "passed": false
    },
    {
        "id": 923,
        "completion": "/^[aeiou]\\w*$/   Explanation: /^[aeiou]\\w*/",
        "passed": false
    },
    {
        "id": 923,
        "completion": "/g",
        "passed": false
    },
    {
        "id": 923,
        "completion": "^[aeiouAEIOU]{1}$",
        "passed": false
    },
    {
        "id": 926,
        "completion": "^\\d{1,7}\\.(\\d{3}?)$",
        "passed": false
    },
    {
        "id": 926,
        "completion": "",
        "passed": false
    },
    {
        "id": 926,
        "completion": "r\"\\d+\\.(1|2|3|4|5|6|7)(?:\\.|0*)(\\d+)(?:\\.|0*)(\\d+)(?:\\.|0*)(\\d+)(?:\\.|0*)(\\d+)(?:\\.|0*)(",
        "passed": false
    },
    {
        "id": 926,
        "completion": "^[0-9]0*[3-9][0-9]*[.][0-9]*$",
        "passed": false
    },
    {
        "id": 926,
        "completion": "^(?=.*[0-9])(?=.*\\.\\d+[0-9]?)[0-9]+(?:[0-9])(?:\\.[0-9]+)?$This is what I did to generate the regex.(?=.*[0-9])",
        "passed": false
    },
    {
        "id": 926,
        "completion": "$[4-9][0-9]([.][0-9]{1,7})?$",
        "passed": false
    },
    {
        "id": 926,
        "completion": "^[\\d]*(?:(?:\\.00)?\\d*|(?:\\d(?:\\.\\d)+)?(?:(?:\\.00)?\\d*))?$",
        "passed": false
    },
    {
        "id": 926,
        "completion": "^[0-9]{1,7}|[0-9]{1,9}[0-9]$",
        "passed": false
    },
    {
        "id": 926,
        "completion": "^\\d{4}\\-\\d{1,3}\\-\\d{1,3}-[\\d.]{1,9}$To check if the regex matched with the string, call `\"123-345-5678\".match('^\\d{4}\\-\\d{1,3}\\-\\d",
        "passed": false
    },
    {
        "id": 926,
        "completion": "(?:(?:\\d+)\\.\\d{1,9})|(?:\\d+[.]\\d{1,9})|(?:\\d+\\.)(?:\\d{1,9})",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer: # Import necessary modulesimport re",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer: /(<img \\b>|<img\\/<img\\/>|<img\\/\\\\img\\/>|<img\\.\\.\\image\\/>)\\b/?>",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer: r'text-tag/bookmark[^(]*'",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer:import refilename='doc.RTF'regex='[A-Za-z]+'matching_files=re.findall(regex,'file {}').split('\\n') #split() method will split the match across a new_linefor file in matching_files:    if re.match(file, filename):",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer:import re r = re.compile('^[^\\d]*$') print(r.findall('<b><a>Bookmark 1</a><b>Bookmark 2</b></a></b>'))",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer:    import re",
        "passed": false
    },
    {
        "id": 933,
        "completion": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.Generate a RegEx for this description. Answer: [^\\.#]+2. Use the `find_all()` method to retrieve all text between `<a>` and `</a>`tags within the `paragraph` variable.Answer: `paragraph.find_all('a')`3. Use the `find()` method to retrieve the first instance of the `<title>` tag within the",
        "passed": false
    },
    {
        "id": 936,
        "completion": "'\\d'.*'2.  Given the text:'The world is full of interesting characters.', Generate a regular expression so that for instance, the first character of each word would be captured as a separate part of a matchAnswer: (.)3. How about a regular expression to generate a name matching a person's first name and their last name? Answer: (?<firstname>\\w)\\.(?<lastname>\\w)",
        "passed": false
    },
    {
        "id": 936,
        "completion": "[^>]** indicates zero or more of the preceding character",
        "passed": false
    },
    {
        "id": 936,
        "completion": "\\w*\\s+",
        "passed": false
    },
    {
        "id": 936,
        "completion": "(.*?\").*?Example: (.*?) means any char or char repeated 0 or non-develmental times (and only to the end of the string).I thought: If I use a string between quotes, it will be between the first and the second quote.",
        "passed": false
    },
    {
        "id": 936,
        "completion": "(?=(\\s+[a-z].*[a-z])*[a-z])|(?=(\\s+[a-z])) # 6.1.2 What is a Query and Why is it Important in Python",
        "passed": false
    },
    {
        "id": 936,
        "completion": "^\"#{quotes(2, \"}\")}\"$Example```^\"#{quotes(2, \")}\")}\"$```",
        "passed": false
    },
    {
        "id": 936,
        "completion": "(\"[^]]+\"). (Note that this means any character that isn't a '[' (begin) or ']' (end))",
        "passed": false
    },
    {
        "id": 936,
        "completion": "[^\"]+\\b",
        "passed": false
    },
    {
        "id": 936,
        "completion": "^\"...\"$",
        "passed": false
    },
    {
        "id": 936,
        "completion": "([\\w ]+) \\d+(?:(?:\\.\\d+)?|(?:\\.\\d+)(?:\\/\\d*)?",
        "passed": false
    },
    {
        "id": 937,
        "completion": "",
        "passed": false
    },
    {
        "id": 937,
        "completion": "\\d{4}-\\d{9}-\\d{9}",
        "passed": false
    },
    {
        "id": 937,
        "completion": "r'^\\d{3}-\\d{7}$'",
        "passed": false
    },
    {
        "id": 937,
        "completion": "/(?!\\d.*\\b7|\\d.*\\b8|\\d.*\\b9|\\d.*\\b9A)[-\\d]{3}-([-\\d]{3}|[-\\d]{5})",
        "passed": false
    },
    {
        "id": 937,
        "completion": "^[0-9]0{5}-[0-9]9{6}$",
        "passed": false
    },
    {
        "id": 937,
        "completion": "",
        "passed": false
    },
    {
        "id": 937,
        "completion": "The RegEx is \"^\\d{3}-\\d{3}-\\d{7}\\d$.",
        "passed": false
    },
    {
        "id": 937,
        "completion": "[^0123456789][0-9][0-9][0-9]",
        "passed": false
    },
    {
        "id": 937,
        "completion": "/^\\d{3}-\\d{3}-\\d{6}$/",
        "passed": false
    },
    {
        "id": 937,
        "completion": "(?<no>\\d{3}-\\d{7})|(?<no>\\d{3}-\\d{8})|(?<no>\\d{3}-\\d{9})|(?<no>\\d{1,4}-\\d{5,2})",
        "passed": false
    },
    {
        "id": 940,
        "completion": "[\\d\\.]{6,20}",
        "passed": false
    },
    {
        "id": 940,
        "completion": "[\\+\\d]",
        "passed": false
    },
    {
        "id": 940,
        "completion": "A positive real number greater than zero that occurs anywhere in the string is a regular expression (as opposed to an ordinary number).",
        "passed": false
    },
    {
        "id": 940,
        "completion": "(at least 8 characters)^?[0-9]?[ ]?[a-zA-Z]{1,200} (at least one number and at least one whitespace)",
        "passed": false
    },
    {
        "id": 940,
        "completion": "\\d+\\/\\d+.",
        "passed": false
    },
    {
        "id": 940,
        "completion": "[1-9]\\d*|\\d?[1-9]\\d*",
        "passed": false
    },
    {
        "id": 940,
        "completion": "1/(4+3\\*2) = 2/13",
        "passed": true
    },
    {
        "id": 940,
        "completion": "n_[^\\W\\d_]*: 0+(\\d+)",
        "passed": false
    },
    {
        "id": 940,
        "completion": "A positive real number greater than zero.Exercise: Generate a RegEx for this definition. Answer: A single word or character after a dash (-).",
        "passed": false
    },
    {
        "id": 940,
        "completion": "(\\d+(\\.\\d+)?)(,\\d+|\\d{1,3})(,\\d+|\\d{1,3})(\\s\\d+)",
        "passed": false
    },
    {
        "id": 946,
        "completion": "# \\d{1,3}\\d{1,3}\\d{1,3}\\d{1,3}\\d{1,3}\\d{1,3}\\d{1,3}",
        "passed": false
    },
    {
        "id": 946,
        "completion": "[your answer here]",
        "passed": false
    },
    {
        "id": 946,
        "completion": "tcp.*([0-9].*?\\.)[0-9]{1,}[a-zA-Z0-9\\-]",
        "passed": false
    },
    {
        "id": 946,
        "completion": "(^[a-zA-Z0-9_.+-]+@[a-zA-z0-9-]+\\.[0-9a-zA-Z.-]+$)",
        "passed": false
    },
    {
        "id": 946,
        "completion": "a port that supports HTTP, HTTPS or FTP",
        "passed": false
    },
    {
        "id": 946,
        "completion": "(\\s|\\|) # of (\\d{1,3}\\.?)\\s(\\d{1,3}\\.?)\\s(?P<port>[0-9]+)[, ] # of (\\d+)",
        "passed": false
    },
    {
        "id": 946,
        "completion": ".+\\.[^.]+",
        "passed": false
    },
    {
        "id": 946,
        "completion": "(.*)\\s\\d+(\\.\\d+)*$",
        "passed": false
    },
    {
        "id": 946,
        "completion": "(\\d{1,3}\\.){3}\\d{1,3}$",
        "passed": false
    },
    {
        "id": 946,
        "completion": "(^(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$).*",
        "passed": false
    },
    {
        "id": 947,
        "completion": "M/d/yyyy with 00% leap years",
        "passed": false
    },
    {
        "id": 947,
        "completion": "^\\d{1,2}\\d{1,2}\\d{2,4},\\d{4}$",
        "passed": false
    },
    {
        "id": 947,
        "completion": "\"^(2[0-3]|[01]?[0-9]|[1-9])/(0?[1-9]",
        "passed": false
    },
    {
        "id": 947,
        "completion": "^(?:\\d{1,2})?[M]m/d?[0-9]?[0-9]?[0-9",
        "passed": false
    },
    {
        "id": 947,
        "completion": "/^[0-9]{4}-[0-9]{2}-[0-9]{2}$/",
        "passed": false
    },
    {
        "id": 947,
        "completion": "\\\\[0-9, /d/y\\\\][0-9, /d/.y\\\\][0-9, /d/.y/.y\\\\][",
        "passed": false
    },
    {
        "id": 947,
        "completion": "^[0-9]{1,2}/[0-9][0-9]/[0-9]{3}$",
        "passed": false
    },
    {
        "id": 947,
        "completion": "/(%[0-5]?[0-9])%1|%[0-5]?[0-9]%2|%[",
        "passed": false
    },
    {
        "id": 947,
        "completion": "Regex RegexObj = new Regex (  @\"^(0[1-9]|1[012])/(0[13578]",
        "passed": false
    },
    {
        "id": 947,
        "completion": "^(02)?(?P<month>[0-9])(?P<day>0?)$",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: ```.*(.(jpeg|bmp|gif))+```",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: file(s): (?<!\\.txt|^)",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: ^\\.([a-zA-Z0-9_]+)$",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: ^[a-zA-Z0-9._-]+(\\.(jpg|gif))$",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: r\".*[^.jpg.]+$\"",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: ```^[a-zA-Z]\\.(jpg|gif)$```    3) Write a RegEx that generates numbers between 1 and 5000000 with a digit after the comma.Answer: ```^[0-9]{5,9}[,](\\d+)?$```",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer:.*\\.jpg|.*\\.gif|.*\\.png",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: The Regex for this specification will be [.,]+files which will match any of these two types.",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: ^[\\w\\s\\-]+\\.([\\w\\s]-\\w+)$",
        "passed": false
    },
    {
        "id": 949,
        "completion": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.Generate a RegEx for this description. Answer: \"^[A-Za-z0-9\\-\\.]+.[jpg|gif]$\"",
        "passed": false
    },
    {
        "id": 952,
        "completion": "~\\$[1-9]{1}[0-9]{1}(\\.0[9]{0,2})?$",
        "passed": false
    },
    {
        "id": 952,
        "completion": "[0-9\\.\\,\\,\\-\\ ]?[1-9\\,\\,\\|\\-\\ ]?[0][0-9]{1,4}[0-9]+( ( [0-9]{4}\\.[0-9]{",
        "passed": false
    },
    {
        "id": 952,
        "completion": "-?\\d{1,4}(?:\\.\\d{1,4})?",
        "passed": false
    },
    {
        "id": 952,
        "completion": "/(  [0-9]*[\\.][0-9]{0,4})/",
        "passed": false
    },
    {
        "id": 952,
        "completion": "$.{:f34}?\\d{2,4.0}$",
        "passed": false
    },
    {
        "id": 952,
        "completion": "(^\\$[0-9]*\\.\\d{1,4}\\$ )([^ ]+)(0|[ ]+0[0-9]{2}$))",
        "passed": false
    },
    {
        "id": 952,
        "completion": "(^[^]?[0-9]{0,7}\\.$|%^[0-9]{0,4}\\%|%[0-9]{0,3}\\%|\\d{0,4}\\.){1,4}[0-9",
        "passed": false
    },
    {
        "id": 952,
        "completion": "(^0([-]?[0-9]*\\.?[0-9]{0,4}(E{1,2}\\b)|0(E{1,2}\\.?[0-9]{0,4}))$)",
        "passed": false
    },
    {
        "id": 952,
        "completion": "\\$([0-9, ][0-9.]*)",
        "passed": false
    },
    {
        "id": 952,
        "completion": "if(!(number.match( /^[\\d][.]?[\\d]{6,}/?(?!-)$/mg) && number >= 0 && number <= 400000) || $(number.toString().split('.').reverse().join('.').length",
        "passed": false
    },
    {
        "id": 954,
        "completion": "[insert your answer here]Exercise 2: Match the product function with its corresponding RegEx. Matching these two together will give a user perspective of how to approach these two in your app. Product Function 1: A",
        "passed": false
    },
    {
        "id": 954,
        "completion": "(\\d*\\.)*\\d{9}",
        "passed": false
    },
    {
        "id": 954,
        "completion": "^(Microsoft product key):\\d{5}$",
        "passed": false
    },
    {
        "id": 954,
        "completion": "\"^[0-9a-f]{20}$\"",
        "passed": false
    },
    {
        "id": 954,
        "completion": "(.*)\\s*with\\bproduct key\\b.*$",
        "passed": false
    },
    {
        "id": 954,
        "completion": "r'^(1234)-(abcd)-[3456]$'.3. Which RegEx does NOT match the pattern used in pattern matching of the format \"firstName.lastName\".Answer: r'^[^\\.\\s]+(\\.)[^\\.\\s]+$'4. Write a RegEx to check for the presence of a single dot character in a string.Answer: r'\\.'5. How would you modify the patterns in the examples above to match all",
        "passed": false
    },
    {
        "id": 954,
        "completion": "You might be looking for something like [A-Z0-9\\\\][A-Z0-9\\\\._,:?!/\\\\-\\'\";]+3. A customer reports they have lost their mobile device with a storage capacity of around 500GB. Use RegEx to search for any device with this capacity.Answer: You might be looking for something like [500\\d]\"\\..*4. A user posts on a forum that they used a specific product to troubleshoot a technical problem. Use Reg",
        "passed": false
    },
    {
        "id": 954,
        "completion": "This answer will vary depending on the product name.",
        "passed": false
    },
    {
        "id": 954,
        "completion": "This could vary according to your imagination, but for example, a possible RegEx is \"([a-zA-Z0-9_]+)$\"",
        "passed": false
    },
    {
        "id": 954,
        "completion": "`^(?=.*a)[a-zA-Z0-9]{5}-[a-zA-Z0-9]$`",
        "passed": false
    },
    {
        "id": 957,
        "completion": "^\\s*[-+]?(\\d*)([ \\t\\\\])*?(?![\\\\t\\\\n\\\\r\\f",
        "passed": false
    },
    {
        "id": 957,
        "completion": "([\\x20-\\x7E\\x9F]+)",
        "passed": false
    },
    {
        "id": 957,
        "completion": "(.*[^\\x01-\\x7f\\r\\n0-9]+[^\\x09])?.*",
        "passed": false
    },
    {
        "id": 957,
        "completion": "/[^\\x00-\\x1F\\r\\t]/g",
        "passed": false
    },
    {
        "id": 957,
        "completion": "\\p{So}|\\p{Zn}|\\u00B2|\\u2018|\\u2019|\\u201A",
        "passed": false
    },
    {
        "id": 957,
        "completion": "/[^\\s(`~`\\x9F]*/",
        "passed": false
    },
    {
        "id": 957,
        "completion": "(?i) (?:(\\s|\\t|\\r\\n|\\f|\\v|\\x0B|\\x",
        "passed": false
    },
    {
        "id": 957,
        "completion": "/[0-1A-F\\r\\t]+/i",
        "passed": false
    },
    {
        "id": 957,
        "completion": "regex\\s+=((?<printable>\\A(?!\\1)[\\d-\\s]*)(?<=\\z)-",
        "passed": false
    },
    {
        "id": 957,
        "completion": "^[^\\\\p{Cllc}\\\\p{Inp}\\\\\\\\0-9\\\\ ]*",
        "passed": false
    },
    {
        "id": 965,
        "completion": "[\\d.]+",
        "passed": false
    },
    {
        "id": 965,
        "completion": "\\d{5} \\. [ ]{2,4}\\d",
        "passed": false
    },
    {
        "id": 965,
        "completion": "[^\\[\\^a-z\\.-\\d]+?",
        "passed": false
    },
    {
        "id": 965,
        "completion": "(?<=\\[[\\d.-]{32}\\]).",
        "passed": false
    },
    {
        "id": 965,
        "completion": "\\[^\\[]* \\d{3}\\.[^\\",
        "passed": false
    },
    {
        "id": 965,
        "completion": "(0[ \\-\\.]0{9})\\.(1[",
        "passed": false
    },
    {
        "id": 965,
        "completion": "(^|,)(\\d+.*-)\\s+(",
        "passed": false
    },
    {
        "id": 965,
        "completion": "[0+.[0-9]][0-9][0-",
        "passed": false
    },
    {
        "id": 965,
        "completion": "[0\\.00.-0.01\\s*[0.]",
        "passed": false
    },
    {
        "id": 965,
        "completion": "",
        "passed": false
    },
    {
        "id": 971,
        "completion": "The regular expression will be: *[0-9]+(\\.[0-9]{2})*",
        "passed": false
    },
    {
        "id": 971,
        "completion": "(\\$\\d+(\\.\\d{1,2})?)(\\.\\d{2})?",
        "passed": false
    },
    {
        "id": 971,
        "completion": "<input type=\"range\" min=\"0\" max=\"1000\" name=\"money\" regex = \"#(?(x)([0-9])|(?<=\\.)(?(x)([0-9]\\.){2})#(#(x)([0-9])|",
        "passed": false
    },
    {
        "id": 971,
        "completion": "^[-+]?\\d*(\\.\\d{2})?$",
        "passed": false
    },
    {
        "id": 971,
        "completion": "# -*- coding: utf-8 -*-import re",
        "passed": false
    },
    {
        "id": 971,
        "completion": "",
        "passed": false
    },
    {
        "id": 971,
        "completion": "^(1\\d{3}\\.\\d{2})|(500\\.\\d{2})|(1000\\.\\d{2})$",
        "passed": false
    },
    {
        "id": 971,
        "completion": "\\d{1,3}\\.\\d{1,3}\\.\\d{1,2}",
        "passed": false
    },
    {
        "id": 971,
        "completion": "^[\\d*\\.]{0,2}$",
        "passed": false
    },
    {
        "id": 971,
        "completion": "%[\\d.]$",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer:^\\w[\\w.]+,\\s\\d+,\\s\\d{0,2}\\.\\d{0,2},\\",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer: max.latitude [^.]?[\\d\\-]?[\\d]?[\\d\\-]?[ \\d]?[",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer: ^[A-Z][0-9]{3,4}(\\.\\d{1,2})?$",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer:var regex = new RegExp(\"([0-9]{1}[.]){1}([0-9]{1}){4",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer: (\\d+) (minutes)??: (?:\\.0*)?(degree){,} (?:,\\d+) (longitude)?",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer:minlatitude 0.00,minlatitude 0.00,2.60m,minlatitude 90.00,minlongitude 180",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer:var string = '/validate location, latitude: S,longitude: S,minutes: 0,seconds: 0,max.latitude",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer: \\((-10\\.00-9\\.00(, -(6.00-0.00(, 4.00-20.",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer: max.latitude - min.latitude.min.length + max.longitude - min.longitude.length/2.0",
        "passed": false
    },
    {
        "id": 972,
        "completion": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.Range check for minutes and seconds (0-59),max.latitude 90.00.00, max longitude 180.00.00Generate a RegEx for this description. Answer: 0-59, E90.00.00, W180.00.00",
        "passed": false
    },
    {
        "id": 977,
        "completion": "1.  // /* Comments */    2.  /* Regex comments */    3.  /* Whitespace */    4.  /* Parse */    5.  /* Any input */    6.  /* Parse */    7.  /* Whitespace */    8.    9. /**/* Comments */*/    10.    11. /* whitespace",
        "passed": true
    },
    {
        "id": 977,
        "completion": "var a = [\"\\\\aBc123\", \"hello\\\\a\" +    \"\\tworld\" +    \"\\ngood\\nby\\n\\nworld\"];",
        "passed": false
    },
    {
        "id": 977,
        "completion": "The RegEx for \"text that can contain spaces or tabs\" that contains a comment, but is not a whitespace (since it starts and ends with a comment). /* This regex allows text that can contain spaces or tabs.   * But it's not a whitespace.\"   */Match re = new Regex(@\"(?s)^#.*$\");",
        "passed": false
    },
    {
        "id": 977,
        "completion": "(?s)//.*//(.*)",
        "passed": false
    },
    {
        "id": 977,
        "completion": "/* regex for text which does not begin with a comment */\\S*(?=\\*{1}[^*]\\*\\Z)",
        "passed": false
    },
    {
        "id": 977,
        "completion": "A good RegEx for this is /^.*\\/\\/\\s+.",
        "passed": false
    },
    {
        "id": 977,
        "completion": "/\\*(?:.*?)\\*/                 # anything but leading *. Use a variable capture group to make it easier to reuse in other parts of the code./\\*                                  # leading *.(?:\\s*\\K                                  # ignore everything that comes after this. (this is actually what \\K is, with [^<>] but for this purpose, I'm using $)",
        "passed": false
    },
    {
        "id": 977,
        "completion": "%[^\\r\\n]*(?<comment>(//|/*))[^\\r\\n]*(?=%[^\\r\\n]*$)",
        "passed": false
    },
    {
        "id": 977,
        "completion": "I found one.[\\[|\\]]*",
        "passed": false
    },
    {
        "id": 977,
        "completion": "/^\\s*(.*?)\\s*$/",
        "passed": false
    },
    {
        "id": 984,
        "completion": "(0\\d|[1-9]\\d{0,2}|[1-9]\\d{0,5}|10[0-1]?[0-9]|10|111?|22|222?|333?|44|444?|555?|666?|777?|888?|999?|[1-9]\\d{0,3}|101[",
        "passed": false
    },
    {
        "id": 984,
        "completion": "(0+|1|2|3|4|5|6|7|8|9|[1-9][0-9]*|0{13})(?:\\.(0+|1|2|3|4|5|6|7|8|9|[1-9][0-9]*|0{13})(?:\\.){3}|([0-9]+\\..",
        "passed": false
    },
    {
        "id": 984,
        "completion": "\"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\"",
        "passed": false
    },
    {
        "id": 984,
        "completion": "0?[1-9][0-9]?\\d$|12[1-9]0$|1[0-2][0-9]\\d|2[1-9]0[0-9]|25[0-5]\\d|2[6-8]\\d$",
        "passed": false
    },
    {
        "id": 984,
        "completion": "[0-9]?[0-9]?[0-9]?[0-9][0-9][0-9]  (note the? makes it optional)",
        "passed": false
    },
    {
        "id": 984,
        "completion": "[0-8],[^0-9A-F0-9]",
        "passed": false
    },
    {
        "id": 984,
        "completion": "^([1-9][0-9]|[0-2][0-9]|29)(\\d|[3-9][0-9])\\s?$",
        "passed": false
    },
    {
        "id": 984,
        "completion": "^0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|aa|ba|bb|bb|cc|cc|dd|dd|ee|ee",
        "passed": false
    },
    {
        "id": 984,
        "completion": "[0-9]{1,3}[0-9]{3}[0-9]{3}",
        "passed": false
    },
    {
        "id": 984,
        "completion": "([0-9A-Fa-f]{1,4}:){1,5}",
        "passed": false
    },
    {
        "id": 985,
        "completion": "/p[0-9]{1,3}(\\+|-|\\*)?(\\d{1,3}[0-9]{3})([0-9]{4})/",
        "passed": false
    },
    {
        "id": 985,
        "completion": "",
        "passed": false
    },
    {
        "id": 985,
        "completion": "r\"[0-9][A-Z][A-Z][^0-9]\" matches numbers in range of 1000 through 49157.",
        "passed": false
    },
    {
        "id": 985,
        "completion": ".*[0-9]{1,9}\\s[0-9]{5}.*",
        "passed": false
    },
    {
        "id": 985,
        "completion": "r'(1024|49151)\\.'",
        "passed": false
    },
    {
        "id": 985,
        "completion": "(1024)(\\d*?)[\\d -]+",
        "passed": false
    },
    {
        "id": 985,
        "completion": "\\b(6589|2963)\\d+\\b",
        "passed": false
    },
    {
        "id": 985,
        "completion": "",
        "passed": false
    },
    {
        "id": 985,
        "completion": "\\d++|\\d++[45]\\d--1\\\\d++|\\d++[32]\\d--2\\\\d++|\\d++[0] \\d++[1]\\d++[2]\\\\d++[0]\\d++[1]\\d++[2]\\\\d++[0]\\d++[1]\\d++[2]\\\\d++[0]\\",
        "passed": false
    },
    {
        "id": 985,
        "completion": "The RegEx is \".*[0-9]\\d*[A-Za-z\\s]*(?:[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})|(.*[0-9]{1,3}\\.[0-9]{1,3}\\.[0-",
        "passed": false
    },
    {
        "id": 986,
        "completion": "(49152-65536)|([a-zA-Z0-9][a-zA-Z0-9\\-_]{0,}[a-zA-Z0-9]+)\\.The dynamic ranges are described by the \"|\" symbol or the \"-\" symbol, the example given for a dynamic range was \"(49152-65536)\" and for a range in between the",
        "passed": false
    },
    {
        "id": 986,
        "completion": "[a-zA-Z0-9_-]{2,13}\\.[a-zA-Z0-9_-]{2,13}|[a-zA-Z0-90-9]{12}Examples:- Matches a user ID such as John Doe123 or Jane Doe145.- Matches a private port such as 13443.-",
        "passed": false
    },
    {
        "id": 986,
        "completion": "[0-9]{10}\\.[0-9]{4}",
        "passed": false
    },
    {
        "id": 986,
        "completion": "^49152$ | ^65535$",
        "passed": false
    },
    {
        "id": 986,
        "completion": "49152-(?:\\d{3})*65535",
        "passed": false
    },
    {
        "id": 986,
        "completion": "[^0-9][a-zA-Z0-9-]{3,}[^0-9]",
        "passed": false
    },
    {
        "id": 986,
        "completion": "A RegEx for this description starts with a number between 49152 and 65535, followed by one or more digits.",
        "passed": false
    },
    {
        "id": 986,
        "completion": ".*[a-zA-Z0-9]{1,3}$ |.*[a-zA-Z0-9]{4,6}$, |.*[a-zA-Z0-9\\-]{7,}$ These will match these numbers: 0, 1-3 characters, between a-z and A-Z, between 0-9",
        "passed": false
    },
    {
        "id": 986,
        "completion": "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\/\\d{1,2}\\.\\d{1,2}\\/\\d{1,2}\\/\\d{1,2}\\.\\d{1,2}\\/\\d{1,2}\\.\\d{1,2}\\/\\d{1,2}",
        "passed": false
    },
    {
        "id": 986,
        "completion": "[1-9][048]|[12][048]|2000,2001,2002,2004,2006,2008,2010,2011,2012,2014,2016,2020",
        "passed": false
    },
    {
        "id": 987,
        "completion": "1-3",
        "passed": true
    },
    {
        "id": 987,
        "completion": "(10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36)",
        "passed": false
    },
    {
        "id": 987,
        "completion": "(9.*[23]);*",
        "passed": false
    },
    {
        "id": 987,
        "completion": "port|registered ports|Well known portsMatches any number in the range (0 to 50) inclusiveExamples:",
        "passed": false
    },
    {
        "id": 987,
        "completion": "(0|[1-4][0-9][0-9]?|[1-9][0-9][0-9]?|[1-9][0-9][0-9]?|[0-9][0-9][0-9]?|[1-9][0-9]?\\d|49[1-9][0-9]|",
        "passed": false
    },
    {
        "id": 987,
        "completion": "[0-49151\\\\d]",
        "passed": false
    },
    {
        "id": 987,
        "completion": "(?<digits>\\d{1,18})+\\.([\\p{L}\\p{M}]*)(\\.|-)+([\\d]{1,18})+$",
        "passed": false
    },
    {
        "id": 987,
        "completion": "Generate a RegEx that matches numbers in range (0000-49151) and does not match numbers between 49155 and 49174. This can include the ports 0, 1, and 32. RegEx matches numbers between 0001-9999999, or numbers between 0 and 99999.",
        "passed": false
    },
    {
        "id": 987,
        "completion": ".*?-50",
        "passed": false
    },
    {
        "id": 987,
        "completion": "(\\d+)(.+?)\\[(.+?)\\]\\s*",
        "passed": false
    },
    {
        "id": 988,
        "completion": "\\[0-9]",
        "passed": false
    },
    {
        "id": 988,
        "completion": "",
        "passed": false
    },
    {
        "id": 988,
        "completion": "PortNumberPattern = /0(?=([0-9a-zA-z_-]|[0-9]{0,2})(?![0-9a-zA-z_-]))\\d{1,17}(?=\\s|$)/",
        "passed": false
    },
    {
        "id": 988,
        "completion": "\"Port 0|[0-9]?[1-9][0-9]?|1[0-4][0-9]|5[0-5][0-9]|6[0-6][0-9]|7[0-7][0-9]|8[0-9]?[0-9]|9[",
        "passed": false
    },
    {
        "id": 988,
        "completion": "well known ports, registered ports &amp; dynamic and private ports: [well-known-1],[well-known-2] through [well-known-65536]",
        "passed": false
    },
    {
        "id": 988,
        "completion": "^((0|[1-9][0-9]+)|[1-9][0-9]+)[0-9]$",
        "passed": false
    },
    {
        "id": 988,
        "completion": ".*?[0-65535]?[0-9a-f]{2}$",
        "passed": false
    },
    {
        "id": 988,
        "completion": "[0-9][0-9][0-9][a-zA-Z0-9?=?!\\-]Exercise 2: Identify All the RisksAs future Network Administrators, it is vital to understand and manage risks. Match the risks with their proper descriptions:- Risk: Unauthorized Access- Risk: Password Change or Reset- Risk",
        "passed": false
    },
    {
        "id": 988,
        "completion": "[a-z][0-9]{8}[a-z]?[0-9]{8}[a-z]?[0-9][a-z]?[0-9]",
        "passed": false
    },
    {
        "id": 988,
        "completion": "0|[1-9][0-9]",
        "passed": false
    },
    {
        "id": 991,
        "completion": "\\b[0-9]{1,3}\\b 5. You are given a string of alphanumeric characters of length 4. Use Regex to check if the original string starts with the character 'Q'. - Solution:  ^Q",
        "passed": false
    },
    {
        "id": 991,
        "completion": "[\\d{5}]*  // any 5 digits in a row",
        "passed": false
    },
    {
        "id": 991,
        "completion": "[0-9]{1,3}```",
        "passed": false
    },
    {
        "id": 991,
        "completion": "\\d\\d\\d\\d\\d",
        "passed": false
    },
    {
        "id": 991,
        "completion": "[0-9]{5} Exercise 2: How would you describe this phone number format to your team of designers? Answer: This phone number format is 5 characters in length and only uses digits 0 through 9.",
        "passed": false
    },
    {
        "id": 991,
        "completion": "```python# ValidPhone numbers: (0-3)999-[0-9]{4}(-1[0-9]\\d{1,4})?match = re.match(\"^(0-3)999-[0-9]{4}(-1[0-9]\\d{1,4})?$\", phone)if match:    print(\"The phone number is valid!\")else:    print(\"",
        "passed": false
    },
    {
        "id": 991,
        "completion": "\\d|\\D (Any digit or any non digit character)",
        "passed": false
    },
    {
        "id": 991,
        "completion": "r'\\b(2[5-9]\\d|3[01]\\d|\\d[1-9]\\d|[1-9]\\d|10[1-9]|20[1-9]|\\d{2}\\d)|(\\d{2})\\.(\\d{5})\\.(\\d{3})\\.(\\d{4}\\b)'",
        "passed": false
    },
    {
        "id": 991,
        "completion": "{0,1,2,3,4,5,6,7,8,9}",
        "passed": false
    },
    {
        "id": 991,
        "completion": "((0[5-9]|1[0-2])[0-9]{9}|1[9-]\"a0b\"0c\"d)\"",
        "passed": false
    },
    {
        "id": 996,
        "completion": "\\*?(\\s*%\\s*,\\s*\"\\s*)+",
        "passed": false
    },
    {
        "id": 996,
        "completion": "^[^#]*.?[^;]'\", where ',' will remove comments on a multiline path. The ';' will remove comments on a single line path.",
        "passed": false
    },
    {
        "id": 996,
        "completion": "%[^\\s\\n]*%|",
        "passed": false
    },
    {
        "id": 996,
        "completion": "'^[^\\s]*#.*'",
        "passed": false
    },
    {
        "id": 996,
        "completion": "[\\s\\S]*//[^\\s]+|'[^']*'",
        "passed": false
    },
    {
        "id": 996,
        "completion": "%s\\%s%s.",
        "passed": false
    },
    {
        "id": 996,
        "completion": "RegEx: (%\\n|\\t)",
        "passed": false
    },
    {
        "id": 996,
        "completion": "",
        "passed": false
    },
    {
        "id": 996,
        "completion": "(?<=\\#\\s*)(.+)([\\r\\n])",
        "passed": false
    },
    {
        "id": 996,
        "completion": "`.*\\[(.*?)\\].+`",
        "passed": false
    },
    {
        "id": 998,
        "completion": "(^V(N|N{3})[0-9]{12}$) *",
        "passed": false
    },
    {
        "id": 998,
        "completion": "[5-5]{3}-([0-9]{4})([A-Z]{2})",
        "passed": false
    },
    {
        "id": 998,
        "completion": "https://developer.google.com/maps/documentation/transportation?version=20180517&hl=en&tq=rest",
        "passed": false
    },
    {
        "id": 998,
        "completion": "([\\w-]+)([a-zA-Z]+)Generate an RegEx for this description",
        "passed": false
    },
    {
        "id": 998,
        "completion": "VIN Regular Expression = \"^[0-9A-Fa-f]{1,12}-{1}([0-9A-Fa-f]{2})-{1}(0{4})([0-9A-Fa-f]{4})$\"",
        "passed": false
    },
    {
        "id": 998,
        "completion": "GVW |lt; 10k lbs')",
        "passed": false
    },
    {
        "id": 998,
        "completion": "^([0-9]*[0-9][0-9][0-9][0-9][0-9])|^([0-9]*[0-9][0-9][0-9][0-9][0-9])&lt;10^3lbs",
        "passed": false
    },
    {
        "id": 998,
        "completion": "\\d{3}-\\d{1,2}-\\d{4}",
        "passed": false
    },
    {
        "id": 998,
        "completion": "VIN \\d{3}[a-z]{1,2}/([1-9] \\d{3})*Explanation: The regex pattern for VIN 4563A/12B7CD is [3]{3}-[a-z]{1,2}/[0-9]{3} \\d{2}\\d{3}.",
        "passed": false
    },
    {
        "id": 998,
        "completion": "<10[K]W| <10[lb]^0.5| <11[lb]^0.5|```",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "var phoneRegex = /^([+]?0?[4-9]|5[1-5])(|\\([0-9]\\))([0-9]{3})\\s(.*?)$/;",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "^0(\\\\ +[0-9]){3,}[0-9]{6}$",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "^(([00])1\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)$|^(?:\\s+([\\A-Z]{2}[0-5][-]\\d{9})\\d{3})\\s+",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "(?:[\\+](?! )(?:1(?: 2(?: 3(?: 4(?: 5(?: 6(?: 7(?: 8)? 1(?: 2(?: 3(?: 4(?: 5(?: 6(?: 7(?: 8)? 1(?:",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "0+0-9[0-9]{3}( [0-9]{2}|[0-9]{2} )[0-9]{4}",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "\\\\b([0-9]{3 }){3} +[ ]+ [0-9]{10}\\\\b",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "^([ +)(22|[A-Z]([+])?)[12]([^)]+)$Example:  Phone number: 002211623314 = should not validate as this can also be ( 00)12345678Phone number: (12)33-",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "+\\d{2}(\\s?(\\d{2,4})\\s?)?\\([\\d\\p{L}.]+\\)",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "^\\+00\\s?([0-9]{3,3})[ ]([0-9]{2})([0-9]{4})([0-9]{4\\})?$",
        "passed": false
    },
    {
        "id": 1000,
        "completion": "[0-9]{2}[ +][0-9]{4} | 00( +)[0-9]{3}[ +][0-9]{3}[ +]",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "<input name=\"txtarea\" type=\"textarea\" size=\"20\">",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "^([a-z]|-|[0-9]|[A-Z]|[\\\\-\\\\_]){19,21}$",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "[^>]+                    [^<]*(< |>)    # This matches anything on first half of the text area                    [^>]+         # This matches anything on second half of the text area                (?<!\\s)  # This will make the lookbehind be non-greedy            )                   # End lookbehind",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "[0-9]{0,19}",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "[A-J]A[0-9]*",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "<input type=\"Textarea\" id=\"textarea\" width=\"20\" maxlength=\"100\" />",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "^.{1,20}$",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "(<input id=\"text\"><br/>).{20,}$",
        "passed": false
    },
    {
        "id": 1001,
        "completion": "^\\s*$",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "[0-9][0-9]|[1-9][0-9]|[1][0-9]|[2][0-9]|",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "^(0|[1-9]\\d|1\\d\\d|2\\d\\d\\d|3\\d\\d\\d\\d|4\\d\\d\\d\\d|5\\d\\d\\d\\d)\\.\\.(0|[1-9]\\d|1\\d\\d|2",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "^(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "[0-9][0-9].[0-9.]+ - [0-9][0-9].[0-9][0-9].[0-9]",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "(^(?:(?:1?\\d\\d0?|2[0-4]\\d|25[0-5])\\.?)+$",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "/^(?!0)\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "/^[01]?[0-9]?[0-9]?[0-9]\\.[0-9]?[0-9]?[0-9]?[0-9]\\.[0-9]?[0-9?][0-9]\\.[0-9]?[0-9]\\.[",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "#RegEx = (^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[1-9]?[0-9])\\.){3}(?:25[0-5]|2[0-4][0-",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "^(\\d{1,3}\\.){3}\\d{1,3}$The first capturing group (\\d{1,3})\\d{1,3} and the last capturing group are the same as before.",
        "passed": false
    },
    {
        "id": 1003,
        "completion": "^(0|[1-9]?\\d?|25[0-5])\\.\\d\\d\\d\\d$I am sure there are some more complex cases but these should get the job done.",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "(?<!\\d)(?!\\d)[1-9](?!\\d)\\d*$",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "+",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "^[1-9][0-9]*(\\.0{0,1})?$",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "(5|[1-9][0-9]|0)+",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "^\\d+,^\\d+,^\\d+$",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "The formula would be:",
        "passed": false
    },
    {
        "id": 1008,
        "completion": ".{0,1}.{0,1}.{0,1}.{0,1}(?=[.!?])",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "(0|[1-9]\\d*)",
        "passed": false
    },
    {
        "id": 1008,
        "completion": "^(?![0-9]*.[0-9]*$)\\d+",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer: ^([a-z]|[A-Z]{1,24}[0-9])([A-Za-z0-9`-])?[a-z]+($[a-z]{1,25})*\\\\",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer:^[A-z][A-z0-9\\-_!\\&\\s#\\$?\\^\\&\\*]{5,50}$",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer: ^[A-Za-z0-9]{1,50}[A-Za-z0-9\\s$%\\&\\,\\*\\?<>#\\^!\\'\\-_()=\\+\\\\]+$",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer:!@#$%&^+*/()~[]<>?QwAaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTt",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer:[a-zA-Z0-9!@#$%^&+=][a-zA-Z0-9!@#$%^&+=\\\\-_?=,\\.]*",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer: [A-Za-z0-9!@#$%^&&amp;-]{6,50}",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer: (^[A-Z{3,9} \\d\\.\\w]+ | [A-Za-z.]+)",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer: (^[a-zA-Z]{1}[a-zA-Z0-9]{5,30}$)[a-zA-Z0-9!@#$%^&&*-\\_\\?]+(?",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer:^(?=.{7,12})(?=[A-Za-z0-9_])(?=\\S)[A-Za-z0-9_!@#$%^&amp;*][A-Z!@",
        "passed": false
    },
    {
        "id": 1009,
        "completion": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:! @ # $ % ^ &amp; * -. _?Generate a RegEx for this description. Answer: { [A-Z][a-z]{0,5}\\d{0,5}\\~\\~\\#\\!\\@\\#\\$\\%\\^&\\*\\-\\_\\^\\&\\?}$",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "Regex.Replace(InputStr, \"\\\\A[!@#$%^&*()_=-/\\\\{}:;<>,.?[]\\|~][",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "(?=^([a-zA-Z0-9_]))",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "(?<![a-zA-Z0-9])[^{a-zA-Z0-9]*",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "@\"\\p{L}+\"",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "public static string CleanData(string inp){    Regex r = new Regex(@\"([^A-z0-9])\");",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "([^_a-zA-z0-9.]+)Next to replace all such occurrences, use another Pattern.Replace(RegExp, _, \"\",",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "Regex.Replace(input, @\"([^a-zA-Z0-9_])\", \"\")Or simplyRegex.Re",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "[a-zA-Z0-9]",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "@\"([^A-Za-z0-9_\\s%\\.!|\\?]+)/g\"This will find one or more groups of",
        "passed": false
    },
    {
        "id": 1010,
        "completion": "Regex: [^\\w]The pattern this expression matches is anything but a digit or a letter. The character youprovide in brackets, [^\\",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "[a-z, A-Z, 0-9\\\\.-]",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "\\b\\w+[\\.\\-]\\w*\\b",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "\\~(\\w-)\\s|~",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "[a-zA-Z0-9\\s\\.]{3}",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "[^A-z]{1,12}[A-z]",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "^[a-zA-Z0-9 -.]+$",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "letters.*?punctuation.*?dashes",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "(([A-Za-z0-9]+('s[^']*'[^']*))*). You can learn more about regex in regex101.com, this string matches letters, lower case or upper case, numbers, hyphens, apostrophe, or dashes and multiple of these characters.",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "letters?.",
        "passed": false
    },
    {
        "id": 1011,
        "completion": "^(?=.*\\.)[aeiou]*-?[aeiou]*$",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "(?:get[^}]*\\{[^}]*?\\}([^{};]*?)(?:\\;[^}]*)?|(?&)To put it simply, it should capture the values within curly braces and any that come after the curly braces. If the braces are not to be part of the statement, it should not be a part of the first match.",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "(.\\s|$)(?=(.*\\))(.*)",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "{(.+?), (.+?)}({([^}]*?)})$This regex is more complicated because it is capturing the nested braces. Notice the first capturing group is for the whole section of the string. The first captured group contains the contents of the open braces.  Then it looks at the content of the second capturing group and looks for a close brace to begin its own parse.  For example, if the description is:hello {hello",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "[^()]*((?([a-zA-Z]+)(\\s*)([^()]*))*|([a-zA-Z]+)(\\s*)(\\s*)([a-zA-Z]+))(this is the complete example)",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "(^|\\s*)(^|\\s*)(get|[^{}\\\\\\)]*)(\\s*)((return)?(?:(?:[\\0\\-\\w\\-_\\n]*\\=)(?:[\\0\\-\\w\\-_\\n]*)?)*)($|\\s*)($|\\s*)($|\\s*)($ or more new lines)",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "(?<!\\\\)([^{\\(]*)(?<!\\\\)([=]+)I also am taking into consideration any braces that may be after the get command and if the get command is preceded by a regex which matches to the (?<!\\\\[\\\\])[^\\\\[\\\\]]* (which would include multiple spaces) I'm adding [^\\[\\\\]]* at the end of the above regex. This should be",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "/(\\[((?:[^]]+)\\]\\s*)*)",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "if (line.indexOf(\"{\") > -1) regex = new RegExp(...); This means that if you have brace braces that are not on inside the string, regex will be equal to true and that will catch this line.",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "([(a-zA-Z)]?[0-9][a-zA-Z0-9]?)",
        "passed": false
    },
    {
        "id": 1012,
        "completion": "\\}[ ]*\\w*\\{",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "(^[0-9]{12}$)|(^[1-9]\\d{11}$)|(^[4]\\d{11}$)|(^[3]\\d\\d\\d\\d$)|(^[2]\\d\\d\\d\\d-\\d\\d\\d$)|(^[",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "^(^\\d+\\s+)?((?![4-9]\\d?)[4-9][\\s-]\\d[\\s-]\\d)?$     Student Question:    Hi everyone,    I'm currently taking the \"Mastering Python: Advanced Techniques via Python\" course and I'm having trouble understanding how to perform",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "^([\\w\\s\\-\\.]+)([\\d]*)(\\w)((?=(\\s+){2}))$\\1(\\2)\\3(?=(\\s+){2})$",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "(1|2(3|4(5|6|7)|8|9)|0)T(1|2((3|4(5|6|7)))|8|9)     Match 1 of one of the 3 patterns.             2 matches either one of the 4 patterns or zeroT((4|5|6|7)|8|9)",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "(?P<number1>\\d+)(-(?P<number2>\\d+)?|-(?P<number3>\\d+)?|/(?P<dividend>\\d+)(?:/?)(?P<divisor>\\d+)?(?P<match>)?)",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "\"^(1-9)\\d{1,10}$\"",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "(^\\s*\\d{4}-\\s*\\d{4}-\\s*\\d{4}-\\s*\\d{4}-\\s*\\d{4}$|^\\s*\\d{4}-\\s*\\d{3}-\\s*\\d{4}$|^\\",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "^[a-z][a-z\\-\\d]{6,16}|^[a-z\\-]+$|^\\s(?P<visa>[4]{3}|5[1-5]\\d|6(?:0\\d(?:\\d{1,2})?|1[3-5]\\d|",
        "passed": false
    },
    {
        "id": 1062,
        "completion": "r'(\\d{3}\\s{1,3}\\d\\d)&&(?=.{4}\\d{4})==||(?=.{4}\\d{3}\\d\\d)&&(?=.{4}\\d{3}(\\d{4}))'",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "^0+(\\.\\d{1,})?$",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "^[12]\\d{3}\\-\\d{2}\\-\\d{4}$",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "ip_in_tcp[0-89123]\"",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "\"^0[0-9]{1,5}$\"",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "^[0-9]{1,2}\\s\\d{6,10}$",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "\\d{1,6}\\.?\\d{2}\\.?\\.?\\d{2}",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "^\\d+$",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "'[0-9]\\d{3}\\.?[0-9]\\d{3}\\.?[0-9]\\d{4}' (explanation: matches the format of a 3-digit number, followed by a hyphen, followed by another 3-digit number, followed by another hyphen, and finally by the year)",
        "passed": false
    },
    {
        "id": 1094,
        "completion": "^[1-9][0-9]{0,2}[0-9]$",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "(0[9]\\d|1[5-9]\\d|\\([1-9]\\d\\))(\\)[1-9]\\d|[0-9]+",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "/^([0]{1}\\.)[1]{3}\\d{10}$/",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "^((011?[5-9]\\d|2[048]\\d|25[0-5])\\d{10}|((011?[5-9]\\d|02[09]\\d|25[02])){2})(-)(\\d)(\\d{3})$",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "pattern = '(^0{5}0[(])[1234\\x20-\\x2f]{3}$|^[+\\xa0]0?\\d{9}[+\\xa0]0?$|^\\+[0]'",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "\\n^0\\d{18}$",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "@(0(?=\\d{1,10}))",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "0[1-9]\\d{3,3}[^\\s]|0\\d{3,3}\\s|0\\d{10},|\\d{10}",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "^([1-9]\\d)(\\d{3})?$",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "/0?[7-9]\\d{7,10}/|0?[3-9]\\d{9}[-0]\\d{4}",
        "passed": false
    },
    {
        "id": 1103,
        "completion": "/^0.\\d{7}$/",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "\\d{3}-{3} (08)9999999999I used the following Regex for a match on a telephone number:[000-]?\\d{1,3}-?\\d{5}-{0,2}A few years ago",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "(09)99999999[0-9][0-9]A phone number with an international country code may have the same format, but not a prefix. An international country code is a prefix like +1 for France.",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "999999|9999999 (07)99999999 9999999999999, 99999999999,000 generate a RegExp for this description. Answer: 999999999 (07)000099999Thank you.",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "(\\d{9})\\s?(?=\\(\\d{3}\\))? The regex should be broken up by its two patterns. The first is to make sure the start and end digits have 9's. The second pattern is for anything in the parentheses to match.",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "(09)99999999.",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "(?:\\d{7}\\d{9}(?:-\\d{3})?$)",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "[^0-9(]999999999999",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "[^0-9 ]+([0-9]*)[^0-9 ]+([0-9]*)[^(]",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "(09)?[0-9]999999999",
        "passed": false
    },
    {
        "id": 1104,
        "completion": "(11)[0-9][1-9][0-9]",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "\\b[C]anada\\s\\d{1,2}\\b",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "(?P<C1>\\d+(?:\\.\\d+)?)(?:-(?=\\d+(?:\\.\\d+)?))*",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "#{regex.escape(match.group(1).toLowerCase().replace(/x/, /e/g))}",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "\\D(?=\\b[A-Za-z]{1}(?:\\s+[A-Za-z0-9][^_]*)*\\b)(?! )",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "^(?=.*\\d)(.{3,30}\\.)\\d{2}\\b",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "^((?:00|1|[2-9][0-9]|[2-9][1-9][0-9])\\.[0-9]+$)",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "http://regex-tester-online.com/?regex=^\\s*(\\d*,){0,2}%[^\\s%\\d%\\n]\\s*$",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "(?i)(?:^(?D.*)(:.*\\b)(?:,|\\b(\\d\\d\\d\\d\\d\\d)(\\d\\d\\b)(\\d\\b):(\\d\\d)(\\:\\d\\d)(\\d))|(?i)(?:.*\\b(?:,|\\b",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "^[1-9]{5}-[0-9]{5}-[1-9]{4}$",
        "passed": false
    },
    {
        "id": 1105,
        "completion": "re.match(regex, code) (or just re.match(regex,code))",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "\\d{0,2}",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "\\d\\s\\d\\s\\s\\w+\\s\\d{1,2}$",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "\\d{1,2}/",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "(?P<month>\\d|10)\\s?(\\d{2})(?:st|nd|rd|th)",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "/(?:\\d|0)\\d[,.]\\d[,.]?/",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "^[12][1-9]\\d$",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "\\d{1,2}/\\d{1,2}/\\d{1,4}",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "^[0-9]{1}([\\d,.]){3}[0-9]{4}$",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "\\d{1,2}\\/\\d{1,2}?",
        "passed": false
    },
    {
        "id": 1107,
        "completion": "^0?[1-9]",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "pattern = \"^(19[1-9])\\d{2}\\-(1[0-1]\\d|0[1-9]|1[012])\\/(19\\d)$\"",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "RegEx: (^[0-5]|[0-9]|1[0-9]|20[0-9])(\\/[0-13])(\\/[0-9])((\\/[0-9])*))",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "\\b[1-9]\\d\\d\\d\\d\\d\\d\\d\\b.",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "data >= 1850 && data <= 2100```",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "[^a-zA-Z ]+",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "_\\b[1-9][0-9]?[0-9][0-9]\\b_",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "^18\\d{2}\\-\\d{2}\\d{2}$",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "\\d{4},\\d{2},\\d{2},\\d\\d,\\d\\d,\\d\\d",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "[1850-2100]",
        "passed": false
    },
    {
        "id": 1109,
        "completion": "^[1-9][0-9]?[0-9][0-9]?[0-9][0-9] [0-9] [0-9]\\.$",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "(.*)=(.*)",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "key(\\s*,\\s*)?: value",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "^^([^,(]*),(.*)$",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "|key1, value1|key2, value2|...|keyn, valuen|",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "([a-zA-Z0-9]\\\\.)*",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "((\\w+ : \\w+).+)",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "(key/value)(,key/value)*",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "\\d{3}/\\d{3}/\\d{4}",
        "passed": false
    },
    {
        "id": 1121,
        "completion": "[^\\s\\t]+([^,\\s\\t]+)|[^,\\s\\t]+[^0-9]+",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "(\\d{2})/(\\d{2})/(\\d{4})",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "(d/m/yyyy)+(h)?",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "\\d{2}[+\\/-](\\d{2}[+\\/-]){2}\\d{4}",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "(\\d{2}/\\d{2}/\\d{4})",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "(^\\d{2}/\\d{2}/\\d{4}$);4. Create a RegEx to extract and display the domain name of the 'http://www.example.com' Domain name. Answer: ((\\.[a-z]{2,3}$)|(\\.[a-z]{2,}))+([-a-z0-9]*)+\\.[a-z]{2,3}",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "/\\b(0?[1-9]|1[0-2])\\/([1-3]?[0-9]|[120])\\/([3-9]\\d?|1\\d\\d|2\\d\\d\\d)\\b/.",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "(\\d\\d/\\d\\d/\\d+)\\. Exercise 2: If you were to extract the date, year, and month from a text in dd/mm/yyyy  using Regular Expression, what would be the pattern that you use?Answer: (\\d+)|(\\d+)/(\\d+)\\. (\\d+)|(\\d+)/.",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "^(?:(19|20)\\d\\d)-(?:1[6-9]|2\\d)\\/\\d{4}$",
        "passed": false
    },
    {
        "id": 1124,
        "completion": "https://reg.rubular.com/r/kd7j6Kp9k9CnJrQ[^a-zA-Z0-9()] matches any character other than a-z, A-Z, 0-9, or ( ).",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "[REGEX1]@[a-zA-z0-9]\\.[^A]?",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "Regex=^[A-Za-z0-9\\\\W]+$",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "@([a-zA-Z][0-9][\\W]){2}\\sMy own try, this is not working well:^(@[a-z]+[0-9]+[a-zA-Z0-9\\^\\*`!\u00a3#?",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "@*\\w*\\[[a-zA-Z0-9\\.]*\\]$\\s*|\\s*@\\w*\\[[a-zA-Z0-9\\.]*\\]$",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "Hello my name is xample.I have a name.",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "^[a-zA-Z\\d\\W]*$This describes a string which only contains letters and numbers and contains no special character.",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "[email protected]",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "The Regex should look like:^[a-zA-Z][0-9]",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "",
        "passed": false
    },
    {
        "id": 1134,
        "completion": "\"Regular Expression for Password must have atleast 1 letter (a-z), 1 number (0-9), Special Character (\\W)The Password must contain no repeated characters.Sample of correct Password Regex:\"[a-z][0-9][!@#$%^&*",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "(^|(?<=,)|(?<=\\.))(\\d{1,3})[,\\s]*\\d{1,3}",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "(^[0-9]{1,3}(,[0-9]{1,3})*[0-9]{1,3}$|^[0-9]{1,3}$)",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "(?=\\s|,|\\.)(?=[0-9]+\\.[0-9]+)",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "[1-9][0-9]{3}[0-9]{3}[0-9]{3}",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "/\\d{3}(?:[\\,.]\\d{3})?/",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "\\b(?=^(?:[0-9]+,)\\*)(?<=,)\\d{4}\\b",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "0+\\s*((\\d+(,\\d{3})*) | 0+(,)+)000)",
        "passed": false
    },
    {
        "id": 1135,
        "completion": ".* 0,000[\\s,].*",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "You can get the regex with this. ^0*(?:\\d{3}(?:,|\\.))?\\d{3}$",
        "passed": false
    },
    {
        "id": 1135,
        "completion": "",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "#include <iostream>#include <string>#include <regex>#include <vector>#include <iterator>",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "//+/*?#public static string[] CodeGenerer(string codeToGenerate){           string cComment;    int cCommentStart = 0;    int cCommentStop = 0;            int cRegExp = 0;",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "public static void main(string[] args){    string cfile = \".\";     // Default: current path    string cfileArg = @\"c:\\\\\";   // Default: C file argument    string cfileArgDashes = @\"--\"; // Default: -D arguments    if (args.Length)    {        cfile = args[",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "Pattern p = new Regex(@\"\\//.*?(\\s*#\\s*)*(\\s*/*)\");",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "(\\s*/*\\n\\s*\\n)(.*)\\s*#Here's a working sample of code:using System;using System.Collections.Generic;using System.Linq;",
        "passed": false
    },
    {
        "id": 1139,
        "completion": ".*\\/\\/.*\\s*\\/\\*.*\\s*\\/.* (with.* matching any non-space character until /) Edit: The other answers are more or less correct, but in any case don't forget to comment out /\\*.* if you are using.NET 4 or later, which has it's own regex engine.",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "// The expression below matches all comment lines (starts with //) and regions beginning with //\"(/\\*\\/\\s*)(.*)\"",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "^//.*?\\s(\\*\\s?)(#.*)$",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "\\//.+\\||\\*#.+I think we can generalize this pattern to any input string, including C# strings that have # as an actual word (e.g. \"myname#isbob\". This is not really a regex, but I don't know enough about it to solve this one anyway.",
        "passed": false
    },
    {
        "id": 1139,
        "completion": "var regex1 = new Regex(@\"//[^\\n]*\\n(?P<regions>/*[^\\n]*\\n)*#(?P<args>.+)\");var regex2 = new Regex(@\"//(*[^\\n]*\\n)+#(?P<args>.+)\");var regex3 = new Regex",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-7",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-7",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-76",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-69",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-65",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-69",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-79",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-88",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-69",
        "passed": false
    },
    {
        "id": 1145,
        "completion": "Accurate Australian postal code verification.Australia has 4-digit numeric postal codes with the following state based specific ranges.ACT: 0200-0299 and 2600-2639.NSW: 1000-1999, 2000-2599 and 2640-2914.NT: 0900-0999 and 0800-0899.QLD: 9000-9999 and 4000-4999.SA: 5000-5999.TAS: 7800-7999 and 7000-7499.VIC: 8000-8999 and 3000-3999.WA: 6800-66",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "*",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "(",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "(",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "L",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "^",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "To",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "/",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "C",
        "passed": false
    },
    {
        "id": 1146,
        "completion": "[",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "GIR (letter D digit 0) and letter or letters after zero (G, L, D, DLL, LLD, LDD)",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "\\d{4}\\s[L:][L:]?.{3}\\s[lL,Ll]\\s[LD,LDD][dd]\\s\\d{3",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "[My answer for this exercise is also not an accurate example. Because the UK postal code format is irregularly formatted with no specific rules. But a possible example is ]DDD.DC.",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "^[a-z]D[a-z0-9]{5}[a-z0-9]$",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "^\\d{2}[A-Z][\\d]{3}0[A-Z]$Example: RegEx1: https://regex101.com/r/m",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "(?<!\\d)(D.*[D](LL|LD|LDD|LDLL|LDL |LDD))(?!\\d) (?<=^\\dG)(",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "GIR\\d{2}(?:(1[0-5]|[2-9][0-9]))?",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "^\\D*(\\d?)(\\d?){2}{\\D}{\\d?\\D*$",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "",
        "passed": false
    },
    {
        "id": 1148,
        "completion": "^\\d+[A-D|A-G]\\d{1,3}[A-D|A-G]\\d{1,3}[A-D|A",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "https://www.regex101.com/r/nH0gD4/2",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "RegEx: /^[A-Za-z]{2}[0-9]{3}[0-9]{2}(?:[A-Za-z]{2}\\.[A-Za-z]{2}\\.[0-9]{3})[\\s\\S]*$/gm",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "[A RegEx describing the format of VAT numbers.]",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "/(?:\\d{4}-)?(?:\\d{2}-)?(?:\\d{2}-)?/",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "^(?P<country>[^A-Z\\s]{1}(\\s|-|\\.)[A-Z0-9]+([A-Z{1}\\s]{1})?){6,18}$",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "(1-15).*([0-9]|[1-9][0-9]|1[0-3][0-9])$",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "In our context, the VAT Number would be [^0-9]*([1-9]\\d?) and the VAT member state must be defined as [^a-zA-Z0-9\\n]",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "(\\d+?)_(\\d+)",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "[a-zA-Z][0-9]{0,8} [a-z]{0,5}",
        "passed": false
    },
    {
        "id": 1164,
        "completion": "This exercise is an exercise where you have to use a RegEx to create a pattern that will match all VAT numbers and return a valid regex. You can use regex pattern builders in Python re2, or you can create a regex manually and use your knowledge of VAT numbers and string formatting.",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer: (\\[\\s?\\d{7}-\\d\\d-\\d\\d\\]\\s?)?[-.][\\s?\\d{9}-\\d\\d-\\d\\d]{3}(?:\\s?\\d{3})?[-.][\\s?\\",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer: 0/0-9",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer:(?=\\D*(\\d\\d?){4})-?(?:\\(?\\d{3}\\)\\)?(?:\\[?\\d{3}\\])?\\s",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer:  \\[(?:\\d{1,}\\.\\d?|\\d{1,}\\.){1} \\d{1,}-\\d{4}\\]Exercise 3:*Requires Email Address*Brackets optional, supports: () and []*seperators optional, supports: - and.",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer:The regex for a ten digit phone number is (\\d{1,3}\\s)(\\d{3})\\s\\d{3}(\\s\\d{3})\\s\\d{4}[- ]\\d{4}.",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer: \\[([\\d\\.]+),\\s*-\\s*(\\d\\d\\d?)\\s*-\\s*(\\d\\d\\d)\\]",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer: ([0-9]{3})(-)?[0-9]{3}(-)?[0-9]{2}",
        "passed": false
    },
    {
        "id": 1165,
        "completion": "US 10-Digit Phone number matching.*Requires Area Code*Brackets optional, supports: () and []*seperators optional, supports: - and.*whitespace optionalGenerate a RegEx for this description. Answer: (\\d{3} \\d{3}-?){4}\\d{4}",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "/^([a-z]|\\d)[a-z\\d ]*$/i",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "^([a-z][a-z0-9]*|[a-z0-9]*)$",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "/^(?=.*[a-z])(?=.*\\d).*$/",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "[^\\w] must have at least 1 letter (regardless of case) and at least 1 number followed by a letter (regardless of case)",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "password = /^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]{8,}$/",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "/^(?=.*[a-z])(?=.*[0-9]).{8,24}$/",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "^(?=.*\\d)(?=.*[a-z]).{8,}$",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "^(?=.*[a-zA-Z])(?=.*[0-9])",
        "passed": false
    },
    {
        "id": 1177,
        "completion": "",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "^(?=.{6,20}$)(?=.*\\d)(?=.*[a-z])+$",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "[a-z]{6,20}[0-9]{2,20}|[0-9]{2,20}[a-z]{2,20}",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "(?=^.{6,20}$)(?=.*\\d)(?=.*[a-z])",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "/^(?=.*\\d)(?=.*[a-z]).{6,20}$/",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "^(?=.*\\\\d)(?=.*[a-z])(?=.*\\\\D)(?=.*\\\\S)(?=.*[A-Z]).{6,20}.{2,2}.{2,2}.$",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{6,20,10,20}$",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "^(?=.*?[A-Za-z])(?=.*?\\d)(?=.*?[0-9])[A-Za-z\\d]{6,20}$",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "(?=^.{6,20})(?=.*[A-Z])(?=.*[0-9])",
        "passed": false
    },
    {
        "id": 1189,
        "completion": "(?=^.{6,20}$)(?=.*a)(?=.*d)(?=.*3)(?=.*5)(?=.{6,19})(?=.*\\d){2,17}$",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "[0-9]+",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "[0-9]\\D*[0-9]+",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "r'^[-]?\\d{5,9}$^[-]?\\d{5,9}$^[-]?\\d{5,9}$^[-]?\\d{5,9}$^[-]?\\d{5,9}$[-]?\\d{5,9}$'Example 2: Validating phone numbers in United States FormatThe national phone numbers in the United States follow a specific format:",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "[0-9]+",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "[\\d]+([.])?",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "^(\\d*)(\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "(^[1-9][0-9]*$) (the [1-9] will check for the character between 1 and 9. The [0-9] will check for numbers starting from 0 and going up to 9. The * will ensure that the number of digits are any given and nothing less. The $ will ensure the end of the string is reached)In fact, your example is not valid because you will be matching \"0\" to \"9\" after [1-9] matches",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "^[1-9]\\d*$",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "^\\d+(\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 1199,
        "completion": "(?i)(\\d{3}\\.)?\\d{3}|\\d{3}\\.(\\d{4})Note That in case of a decimal value like 123.45 then you will require a different RegEx.",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "([0-9\\.]+)(\\.\\d)?(%)",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "\\\\d{1,2}(.\\\\d{1,2}){0,1}",
        "passed": false
    },
    {
        "id": 1209,
        "completion": ".*[0-9]{1}.*The second one gets two decimal places and the first one gets only at most one. .*[0-9]{2}.*/100",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "(0..100).{9,2}3. Write the regular expression which searches for a string containing letters from a, b, and c in this order. The string cannot contain a space, a comma, or a tab character and does not need to be a word. Generate the RegEx for this description. Answer: (a|b|c).*4. Write the regular expression which searches for a string containing a number with 1 decimal place.",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "([0-9]{0,2})/([0-9]{0,2})",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "/0..999/.",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "$value = @(\"55.55\", \"45.5\", \"50.44\", \"90.55\", \"45.75\", \"56.89\", \"21.12\");$pattern = \"(?<![0-9])((?:(?<decimals>\\.[0-9]{1,2}))(?![0-9]))\"SelectPattern = \"Value = \" + $value.Insert(@",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "10.0, 0.1, 0.1.",
        "passed": true
    },
    {
        "id": 1209,
        "completion": "I want my password to: Start with a letterEnd with a numberHave 4 digits. Min. length is 6.4 characters in length.",
        "passed": false
    },
    {
        "id": 1209,
        "completion": "(?<count>\\d{1,2})-(?<total>[0-9])(\\.[0-9])",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "(from @regexp) (\\?xml[^>]*>.*?)</note></?xml",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "<?xml version=\"1.0\" encoding=\"utf-8\"?><?xml version=\"1.0\" encoding=\"UTF-8\" mediaType=\"xml\" xmlns=\"http://www.w3.org/2006/Atom\" xmlns:xsi=\"http",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "[\\x15\\x06](.*?</([^<]++>)+>|.+)[\\x15];",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "\"<!DOCTYPE note.*?<\\/note></?xml>\"",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "(regex example) /<?xml(?<!\\s)start=\\s*\\/notes(?<!\\s)/>/This should take some time to compile. Once the regex is compiled, just search within it:if re.search(regex,",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "<!DOCTYPE test  <test>    <tag x=\"123\">hello</tag>    <note>some xml</note>  </test>",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "^/?([A-z0-9\\.\\_\\-\\s]*)(?<!\\s)(\\/note)$",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "```<![CDATA[                    <note>                        <field name=\"name\"/>                        <field value=\"John Doe\"/>                    </note>                ]]]></?xml>```",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "",
        "passed": false
    },
    {
        "id": 1212,
        "completion": "<html>.*?<!DOCTYPE html><html><body><note>....</note></!DOCTYPE html><?xml>",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "^(\\d|\\d\\d|\\d\\d\\d|\\d\\d\\d\\d)/(\\d{4})/(\\d+)$",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "(([\\d/])){2}(\\d\\d\\d\\d)\\/(\\\\d\\d\\d)\\d\\d",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "[^0-9/]+/\\d{4}",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "r'^(?P<weeks>\\d{1,2})-(?P<year>[1-9]\\d{3})[\\-/]?(?P<week_year>\\d{4})$'",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "/(\\d{4})/((0[1-9]|[12][0-9]|3[01])\\/\\d{1,2})",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "(\\d)/(\\d{4})",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "(^[1-5][0-9]/[1-9][0-9]/[1-9][0-9]\\s/[1-4][0-9]/[1-9][0-9])",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "(\\d{1,2}|5[012])/\\d{3}",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "WW(/)?\\d{4}-\\d{4}",
        "passed": false
    },
    {
        "id": 1213,
        "completion": "(\\d{2})/(\\d{4})(\\/)(\\d{4})",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "(^(.*)\\/(.*)\\/(.*)$)",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "^\\d{4}\\D\\d{2}-\\D\\D\\d{2}$",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "\\b \\d{4}-\\d{2}-(\\d{2}):(\\d{2})\\.(\\d{2})[tT]\\b",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "\\d{4}(?:[-\\s]?\\d{1,2}|\\d{1,2})-(\\d{1,2})",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "%Y-%m-%dT%H:%M:%SZ",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "(\\d\\d\\d-\\d\\d-\\d\\d|(20[1-9]|0[1-9]|1[012])-\\d\\d-\\d\\d\\d",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "^[0-9]{4}\\-[0-9]{1,2}\\-[0-9]{4}T[0-9]+$.",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "%Y[\\d]{3}[-\\s]?[Dd]{1,2}[Tt]?",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "[0-9]{4}-[0-9]{2}[0-9]",
        "passed": false
    },
    {
        "id": 1221,
        "completion": "Pattern regex = Pattern.compile(                    Pattern.quote(                        \"([\\\\w]+)\\\\s+((?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "^[0-9]{4}-?[0-9]{2}-?[0-9]{2}[0-9]{2}[0-9]{2} [0-9]{2}[0-9]{2}$ This will match any string which has 4 digits, - one optional, second optional, third optional, and so on... at the end",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "([0-9]{4}-[0-9]{2}-[0-9]{2})|([0-9]{4}-[0-9]{2})-([0-9]{2}:[0-9]{2}:[0-9]{2})|([0-9]{4}-[0-9]{2})-(([0-9]){",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "%Y-%m-%dT%H:%M:%S %Z(You may have forgotten the %Z!)Example 2",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "//This will match a valid date & time in the following formats 01/01/2006 01:59:59^([0-9]{4}[0-9]{2}[0-9]{2})[0-9]{2}[0-9]{2}:[0-9]{2}:[0-9]{2}(Z|[\\+\\-](\\",
        "passed": false
    },
    {
        "id": 1224,
        "completion": ".*([0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2}T.*)This will match any time between \"06-31-2006\" and \"11-31-2006\" and \"12-31-2006\". The part after the colon (.*) matches any number of time Then comes the 'T'. So [",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "(\\d{4}-\\d{2}-\\d{2})[:](\\d{2})(\\s|\\.)(00\\d\\d)$",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "\\\\d{4}-[[:digit:]]{2}[[:digit:]]{2}-[[:digit:]]{2}\\s\\\\:\\s\\\\:\\s\\\\s[[:digit:]]{2}[[:digit:]]{2}[[:digit:]]{2}\\\\s[[:digit:]]{2}[[:digit:]]{2}",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "2006-12-31T23:59:59",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "(?<-year>\\d{4})-(?<- month>\\d{2})-(?<- day>\\d{2})\\s+\\d{2}:\\d{2}:\\d{2}(|\\S)(?=.?\\2\\s+(?<-hour>\\d{2}\\.)?\\d{2})?(?<-minute",
        "passed": false
    },
    {
        "id": 1224,
        "completion": "?([0-9]{4}-)?([01][0-9]{3})[0-9]{2}[0-9][0-9]",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "^(?!0+$)[+-]?\\d*\\.?\\d*e[+-]?\\d+$|^[-+]?\\d+\\.?\\d+$",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "^[1-9]\\d*(\\.[1-9]\\d*)?(E[+-]?[0-9]*)?$",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "^[+-]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$So basically it matches on a pattern '-?[0-9]*\\.[0-9]+([eE][-+]?[0-9]+)?'. This will give you a valid RegEx in javascript. Hope this is not too confusing. You can look at more examples on the site:http://",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "[0-9.]",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "[-+]?(?:\\.\\d*)?[eE]\\d+",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "^-?\\d+)(\\.\\d+)?(\\s*$|(([-+\\/]\\s*)(\\d+)?))?$",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "\\d{1,3}.",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "^(\\d+\\.?\\d*)|(\\d+)\\.?\\d+$,  ^\\d+\\.?\\d*$Regex explanation: Match 1 or 2 groups of a string or number, followed by either an optional decimal point and several digits or digits only. Explanation:^        Start of line (\\d+\\.?) Matches 1 or more digits optionally followed by an optional decimal point and several digits.$        End of line",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "\\.*0\\+0\\.\\d+\\.\\d+That way you're able to generate a custom RegEx to filter your file.",
        "passed": false
    },
    {
        "id": 1230,
        "completion": "^           #line start(?P<number1>[0-9]{1,2})(\\.|\\b\\.\\d*){0,1}[0-9]*\\b  $               #line end",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description:",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description:",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description (",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description that",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description as",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description and",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description or",
        "passed": false
    },
    {
        "id": 1239,
        "completion": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.Generate a RegEx for this description:",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "^[1-9]\\d{3,3}(\\.\\d+)$",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "[^\\d\\s]",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "inputNum.match(/^[1-9][0-9]*$/)",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "(0[1-9]|1[0-9]), the numbers can be anything between zero and nine.",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "1.^[13])|]{3}This Regex is only a simple validation for the length of the provided string before validating all of the values further in the function.",
        "passed": true
    },
    {
        "id": 1242,
        "completion": "",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "(0|1|2|3|4|5|6|7|8|9|[1-9]|0|[1-9]|1[0-9])",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "^[1-9]?[0-9]?[0-9]{3}$",
        "passed": false
    },
    {
        "id": 1242,
        "completion": ".{0,16}[1-9][0-9]{3}[0-9][0-9]{3}/[0-4[0-9]][0-4][0-9]/.5. Generate a RegEx that ensures the email adress is in the format of username@domain.com whereusername is a string (letters, numbers, underscore) and domain is a string (also letters, numbers, underscore,",
        "passed": false
    },
    {
        "id": 1242,
        "completion": "input_str = re.escape('positive (\\d+)'.format(value))",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "[[OPEN GROUP]]",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "(^\\\\+)(%[0-9]{1,})([- ]*(%[0-9]{1,}))?([- ]*(%[0-9]{1,}))?$",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "#######(#######)#########",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "To generate a RegEx for this description, follow the same format as the OAGIS standard.",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "The format is plus (###) ### ### ### ###.",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "^(\\+)(\\d{3})[.](\\d{3})$\"",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "Phone: (^\\+\\d{1,3}\\)){5}(\\()(.*)Fax: ((\\+\\d{1,3}\\)){5}(\\()(.*)/(\\d{4}/\\d{2}/\\d{2})))$",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "The format is (###)#######",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "(?<![a-z])[0-9][0-9][0-9][0-9]+(?=,)",
        "passed": false
    },
    {
        "id": 1244,
        "completion": "(\\+\\(\\d{3}\\))",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "^(?:[1-9]\\d?|1\\d?\\d|2[0-4]\\d|25[0-5])\\.(?:[1-9]\\d?|1\\d?\\d|2[0-4]\\d|25[0-5])$.*$",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "r'\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b|([0-9]+[a-f]{2})'",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "(((([a-f0-9]\\d*).)+\\..)*1)",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "*(?i)[0-9]+(?:-[0-9]+){3}|[0-9]+|0|[1-9]|[1-9][0-9]*|([0-9A-Fa-f]{1,4}:){7,7}|[^0-9A-Fa-f]{1,4}",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "((\\d|((\\.)(\\d|\\.))+){3}\\d{1,6})",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "[a-zA-Z\\\\\\u0040-\\\\u0060\\\\\\u0061-\\\\u0074\\\\\\u0075-\\\\u007e\\\\\\u0077-\\\\u0079\\\\\\u0087-\\\\u0091\\\\\\u0093-\\\\u0096\\\\\\u0102-\\\\x80\\\\\\u0807",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "^((((0|[1-9]\\\\d){0,2}|2[0-4]\\\\d|25[0-5])\\.){3}(((0|[1-9]\\\\d){0,2}|2[0-4]\\\\d|25[0-5])|((2[0-4]\\\\d){1,",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "r\"^(?:[01]?[0-9]??[0-9]):?(?:[0-9]{1,2})(?::(?:[0-9]{1,2})(?::(?:[0-9]{1,2}))?(?:[0-9]{1,2})))?\"",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "@1[0-9]{1,3}\\.[1-5]{1,2}\\.[0-9]{1,3}|\\[(24[0-9]|25[0-4])\\/(1|2)\\d\\](5[0-5]|[0-4][0-9]|[0-9])\\.(25",
        "passed": false
    },
    {
        "id": 1246,
        "completion": "(?:\\d{1,3}\\.){3}\\d{1,3}",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "gm-g2070-2-m20.",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "```python    grid_num_re = r'^(?P<os>[0-8])(?P<s>[0-9]",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "(?=\\d{4}-\\d{2}-\\d{2})[A-Za-z0-9]{5}",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "r\"[0-9]{3}[0-9]{3}[0-9]{6}[0-9]{3}[0-",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "/r[^\\s]/",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "re.compile(r\"(|^)((10)(00)-(10)(\\d)(\\d\\d)(\\d))((-0)(-0))",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "\\d{1,2}(\\s?X|W|WNW|NWNW|SWSW|SWSW|SSWS|SSE|SE|SE",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "R{900005,0,900007} - 900005 Grid Ref, Tile Ref, Sheet Ref, 0,900007 Zone. The grid reference for",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "The pattern is (?:[0-9][0-9]?[0-9][0-9]|0[1-9]?[0-9",
        "passed": false
    },
    {
        "id": 1251,
        "completion": "(\\d\\.?\\d?)(\\.\\d{1,2})[a-zA-Z0-9_-]?[a-zA-",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "*`(tag)title=([^\\\\s\\n]*)$`",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "Use the format \\w+=\\s+\\w+ where \\w=[_a-zA-Z0-9_ ]+ and \\s represents a whitespace character. It creates a regular expression to capture the word between the two semicolons in between the phrase '='.",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "r\"(?=\\$\\d+\\/)\"",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "($1\\d{1,2}\\s?\\w*$).",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "The pattern: ^#*.*",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "We can use a combination of backreferences to capture the repeated sequence of characters (e.g. `[A-Za-z]{2,}`).",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "\\(\\[(.+?)\\]",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "_",
        "passed": false
    },
    {
        "id": 1254,
        "completion": "(\\S+)",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "\"<\" (\"[\") and \">\" (\"]\")",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "(?<=\\s*)(<((h*)(\\d|\\w))|[^>])((?=[\\s>]))",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "{#h1 h2 h3 h4 h5 h6#} can be used in any order, but they have to be separated by a literal space. {#} means that {h6} is the only content that is part of the range (1 to 6).",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "/<(?:^|\\s)(?:[^>()]*?)</.+?>/Exercise 2: Write a program that accepts a string and a regular expression. The program should then use the re.search function to find all the matches of the regular expression in the string. If a match is found, display the position of the match. Answer:import re",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "\\S+?<(h1-6)\\s(.+?)\\bExplanation",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "^\\h[1-6]\\s+$Exercise 5: Write a RegEx to check if a string starts with a certain character and ends with another characterAnswer: ^[a-zA-Z]\\w[a-zA-Z]+$",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "/\\S*\\[\\s*([^\\]]+)\\]\\s*/",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "^h1-(?P<tagname1>.+)-[>](?P<tagname2>.+)$How many valid <h1-6> tags are there in this sentence? Answer: 7",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "/<h1[1-6]>(.*)$/But do this: /<h1>([1-9][0-9]*)</h1-6>(.*)/It matches the first occurrence of only <h1,<p> and <p>, not more with a single <h1-6>. I'm not sure why I thought I have to add more capturing parentheses, just don't know why I was doing that.",
        "passed": false
    },
    {
        "id": 1257,
        "completion": "^\\s*(<h1-6>(.*?))\\b$Example: $re = '/^\\s*(<h1-6>(.*?))\\b$/'; $str = '<h1-3> this is a <h4>head</h4> and this is <a h2>anh2</a> this is another <a h3>anh3</a> and this is a <b",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "CAS=(0|[1-9]\\d*)([\\.]\\d{0,3})?(c[012]-?\\d+)",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "(\\d{2,8}),([a-z]|[A-Z][a-z]?)*",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "(?:^\\s|\\s.|[\\W_]|['!~\\(\\)\\*\\+\\-\\?,\\/\\\\\\*\\+\\-\\/%\\*\\?\\'\\(\\)\\{\\;}\\.\\d{3}\\,\\d{3}\\,\\d{4}$)",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "[\\w+-]{5}\\([\\w]*\\)(\\w{3}\\+\\w{2}(\\-?\\w+){2})?",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "CASNumberRegex = re.compile(r\"^CAS\\d{4,8}$\")",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "[0-9A-Fa-f]{4}\\-?[0-9A-Fa-f]{4}",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "https://www.freecodecamp.org/news/casp-regex-for-string-formatting-python/",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "[a-z]{3}\\-[0-9a-zA-Z]{3}\\-[0-9a-zA-Z]{3}",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "\\b(CAS|CAS|CAS|CAS|CAS|CAS|CAS|CAS|CAS)(\\d+)\\b",
        "passed": false
    },
    {
        "id": 1260,
        "completion": "\"CAS ([A-Z]{1,3}[0-9]{3}[A-Z]{1})?\"",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^\\d*[ ]*\\(?\\d{3}[ ]?\\)?(x|ext",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^\\(\\d\\)?[ ]*[\\(\\.\\-]?(\\d{3})?[\\)",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^(\\d)*[ ]*[.-]?(\\d{3})([ \\.-]?",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^\\d{1,5}\\s(x|ext\\.?)? \\d{1,4} \\",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "\\(\\\\d?[ \\t\\r\\n])|((\\\\d{3}[.])+[",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^(\\d)?[ ]*(\\.\\-)?(\\d{3})?[\\.\\- ]?(\\",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^(\\d)?[ \\-\\d]?\\(?[0-9]{3}[\\",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^\\s?[a-z]\\s?\\d{3}[-\\.\\s]?",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^(\\d)?[ ]*(?=(\\d\\s|\\s|[^\\w]){",
        "passed": false
    },
    {
        "id": 1267,
        "completion": "^(\\d)?[ ]*[\\-\\. ]?(\\d{3})?[ ]*[\\-\\.",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "```pythonimport reinvalid_extensions = ['.', '..']def validate_extension(uploaded_file):    pattern = '|'.join(invalid_extensions)    if re.search(pattern, uploaded_file.filename):        return True    return False",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "If the uploaded file's extension is not (jpg, gif, or png), the Django Comment form should display an error message. Otherwise, mark the file as valid.",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "[\\'jpeg\\'|\\'gif\\'|\\'png\\']{1,3}\\s(.)?2. Write a basic regular expression expression to check if an uploaded file's size is within a certain range.Answer:x\\d{1,2}y[\\'mb\\'|\\'kb\\'|\\'mb\\'].{1,18}$3. Write a RegEx pattern to ensure that a",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "```pythonextension = re.search(\"^(.+)$\", uploaded_file.filename) #Extract the file extension using RegEx.",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "re.compile('.*\\.(jpg|gif|png)$')",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "^(.+?)(j?g?|i?p?)",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "(.*): any number of any characters. Then wrap the.* with square brackets. The expression could be:^.(?:jpg|gif|png)$",
        "passed": false
    },
    {
        "id": 1268,
        "completion": "import reextension_regex = \"[0-9a-zA-Z]+(?:\\.[0-9a-zA-Z]+)*\"",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "\\d(,\\d|\\.\\d)",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "(^|,)([+-]?\\d{1,2})\\d{3}",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "^\\+(([-\\+\\d]{1,3}\\d{3})?(,\\d{1,2})?$",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "\\(-?\\d{1,3}(?:\\,\\d{3}){0,3})(?:\\s?\\-?\\d{1,3})?$",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "(?:\\s*(\\+|-)[0-9]{1,3},?\\d{3}){5,}",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "^(([\\+-]0+)\\.?[0-9]{3,})$",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "(^|[+\\-])(-?[1-3]\\d{1,3})(?:,\\s+)?(?=\\d{3})",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "1?((-?)(0|[1-9])?)",
        "passed": true
    },
    {
        "id": 1278,
        "completion": "([-+]?\\d{1,3})(,)\\d{3}",
        "passed": false
    },
    {
        "id": 1278,
        "completion": "\\s*(.*),\\s*(.*)?",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "[^,\\.]{0,2}Examples (in a set)[1.1, 2.3, 3.2, 4.4][1, -2, 0, 10]",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "\\d+\\.\\d{2}|\\d{3}\\.\\d{2}|\\d{4}Hint: \\d represents any digit digit (0-9).",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "\"(\\d(\\.\\d{2})?)?(([\\,\\.])\\d{2})?([\\,\\.])\\d{2}\"",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "^((?<hour>0)[1-9](?::(?!00)([1-9][0-9]|1[012]))?|2[0-3](?::(?!00)([1-9][0-9]|1[0-2]))|(?<hour13>3",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "([0-9\\.]+).*",
        "passed": false
    },
    {
        "id": 1284,
        "completion": ".*^(0\\.0|0\\.1|1\\.0|1\\.1|2|2.0|2.1|2.2|2.3|2.4|2.5|2.6|2.7|2.8|2.9|2.999|3|3\\.0|",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "\\([0-9.]*[Ee]s\\/[0-9.]*\\(.+\\)",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "(?<!^[\\-\\+/])([-+]?\\.(?![\\-\\+/])[\\d]*)([\\-\\+/])([\\-\\+/\\?\\!\\0-9]*))",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "(?:(?=(\\(\\d+,\\d*\\))|(?=(\\d+\\.?\\d*))),(?=(\\d+,)|(\\d+\\.?\\d*))).*(?=,|$)",
        "passed": false
    },
    {
        "id": 1284,
        "completion": "/^(0\\.0|2\\.0)$/",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "^[A-Za-z0-9 -]+(?:\\s[A-Za-z0-9 -]+)*$",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "/^([a-zA-Z0-9 ].*){1,}$/",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "^[a-zA-Z0-9\\s]+$",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "[a-zA-Z0-9\\s]+",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "/^[a-zA-Z0-9 ]+$/gm",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "@\"^[a-zA-Z0-9 _]+@\"",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "^(?i)(?=\\S*$)(?=\\b[A-Z]\\s)*\\S+$",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "/[a-zA-Z0-9 \\-\\. ]+/g",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "/^[\\w\\s]*$/",
        "passed": false
    },
    {
        "id": 1313,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d ]+$",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "\\b\\d{2,7}(\\,?\\d{0,3})?\\.\\d{1,2}\\.\\d{1,2}\\bThis has been done using two Regexes: one to accept 2-7 digits with or without the comma and decimal portion and another to",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "^(?<digit>\\D*\\d)(?<decimal>\\d*([.,]*\\d*)?)(?<commas>[,]*){0,1}(?<total>\\d+)$",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "^(0|(?:\\d{1}(?:\\.\\d{1})?|(?:\\d{1,2}\\.)\\d{1,2}))[\\d.,]+$",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "^[0-9,][0-9]?\\,?0?[0-9]{3}$                \"^[0-9]{0,1}([,\\.)][0-9]*[0-9]([,\\.])?[0-9",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "^([1-9]\\d*\\.)?([1-9]\\d{0,2})(, | x)$",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "(^|\\s)(\\d{1,3})(,)(\\d{2})?\\.?(0|\\d)?$",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "|^\\$0+(\\d{7}\\.\\d+)?|^\\$0+(0\\.\\d+)?|^\\$0+(\\d{2}\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "^\\b\\d{1,7}(?:\\.[0-9]{0,2}\\b|\\b[\\d.]{0,2}\\b)$",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "\\d{1,3}(?:\\.\\d{1,2})?",
        "passed": false
    },
    {
        "id": 1314,
        "completion": "[^\\d.]+,\\d*\\.\\d{2}",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "\\s\\1\\s?\\+?Thanks very much for all the help!",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "\\A |\\([a-z_0-9]{1,6}\\)\\.[a-z]{1,3}\\s?[a-z](?:_[a-z]|[a-z0-9]\\s?)?\\Z",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "(?![ \\d]*\\()[ \\d](?=\\))[^ ]*[^ \\/ \\t\\v\\^\\ \\a\\z]*[^ \\/ \\t\\v\\^\\ ]*",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "(^\\s*\\d{3}(?:\\D|$)){0,2}$",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "^(\\+\\d{1,3}\\?)?|(?:(?<area>[0-9]{1,3}\\-)?[0-9]{1,9})$",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "\\b[789]\\d[5-9]\\d\\b",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "(\\(.+?\\)?|).+, this should only match a region code and the extension. Note I was using '?' instead of using '*' so it would allow for an optional extension even if it is required. This might get you thinking: given that so many variations exist on what is and isn't in a cell phone",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "This one is more difficult, since it's more complex and has more variables. Here's what I have so far:public const string Cmd1Excel(string input, string delimiter){    if (input.Length < 0)        return \"Invalid\";",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "[^ ]{3}[, ]?[0-9]{3}[,]?\\-?[0-9][^ ][0-9][ ][0-9]",
        "passed": false
    },
    {
        "id": 1317,
        "completion": "\\b([2-9]\\d\\s?){2}\\s(2-9)\\b + (\\S\\S\\S)",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "^[1]\\d\\d\\d[0-3]\\d\\d$If n is any number between 00 to 99 it should work fine.Example: if we have a variable X = 0110, it should match but X = 2222 would not match",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "[0-9][0-9][0-9][0-9]\\-[0-9][0-9][0-9].[0-9]",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "[^\\\\d\\\\.\\\\-]\\\\d{1,3}",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "(?:\\d{1,2}.\\d{1,2}.\\d{1,2}.\\d{4})",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "(?<date>[0-9]+).(?<year>[0-9]{1,2}).(?<month>[0-9]{1,2}).(?<day>[0-9]{1,2})\"\"\"",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "(?<=\\d.*)(?<!\\d[0-9])(?<![0-9](\\.[0-9]){3})",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "ddn[{0,2}[0-9]?|[1-2][0-9]3]Note: This regex is an edge case which can't exist because if it exists then, no need to create regex for a string of string of 2 digit numbers [00.23..0099][00.9..0099]",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "((?<![a-zA-Z0-9\\-\\s])[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,3}\\.[0-9]{1,4}(-)?([a-zA-Z0-9\\-\\s]*([a-zA-Z0-9\\-\\ ][",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}\\.\\d{1,3}.\\d{0,4}",
        "passed": false
    },
    {
        "id": 1326,
        "completion": "^(1\\d{2}\\.\\d{2}\\.\\d{2}(\\d{3})\\d|\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}.\\d{3})$",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "(.0+)\\.0*\\.\\d*$",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "[0, 100.]+[^,.;]",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "(?<=\\b\\d+(?:\\.\\d{0,2}\\b)\\s+#))|(?<=\\b\\d+(?:\\.\\d{0,2}[.,]\\d?\\b)\\s+$)",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "(?:[^a-zA-Z])?[ ][\\d]*\\.[\\d]*",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "(?:^|\\s)((-?(?:0,\\d{1,2})\\/)?(?:0,\\d{1,2})?)+(?:\\.(?:0,\\d{1,2})?)?(?:$|\\s)*This will make sure comma is first and only in last three places as well.",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "'^[0-9]{0,3}.\\,|0.00[1-9,][0-9]{0,2}\\.[0-9]{0,2}$'",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "https://regex101.com/1011T3jR/2/",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "[\\$]+(?:\\.[0-9]{1,2})[,.][0-9]{1,2}|100",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "(?<!\\d)^(?:\\d{1,2}(?:[,.]\\d*)?)(?!\\d)",
        "passed": false
    },
    {
        "id": 1333,
        "completion": "^(?:[\\$.][0-9]{1,2}[\\.][0-9]{1,2}[\\$.][0-9]{1,2}|[0-9]{1,3}[\\.][0-9]{1,2}[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "^(?:[0-9]{2}[ -][0-9]{4}[ -][0-9]{6}[ -][0-9]{4})-([0-9]{8}[ -]{1}[0-9]{3})$In this regex we used the \"",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "(?:\\d{2}-\\d{4}-\\d{2}\\.?\\d{5})",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "d\\d\\d\\d-\\d\\d-\\d\\d (where d is any digit, \\d is any digit, \\d is any digit, - is the special character)However, if we look at our string, it was mentioned that all the characters are numeric even after the dash.If any character is entered as",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "\\b\\d{2}[-\\s]+\\d{2}[-\\s]\\d{4}[-\\s]\\d{3}\\b",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "/^[0-9]{3}-[0-9]{4}-[0-9]{2}-[0-9]$/The character class '-' is used to ensure we only keep the characters '-'. The numeric characters {3}, {4}, {2} are optional, meaning we can either put them in",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "^[0-9]{2}[0-9]{2}[0-9]{4}-\\w{3}$",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "^[0-9]{10}-|[\\w\\-]{4}The word'special' and '-', so that this answer doesn't count as it is already there.",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "^[0-9]{2}-[0-9]{4}-[\\d\\-]{7}$",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "^\\d{2}-(\\d{2})-(\\d{4})-.*",
        "passed": false
    },
    {
        "id": 1334,
        "completion": "(.*)[a-zA-Z0-9-]*",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: /[MSFT]|[TTHS]\\b/",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: \\b[M|T|W|TH|F|S|SU]\\b",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: \"M or T or W or TH or F or S or SU\"",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: ([MTWFTHFS])",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: (?MWF? $) or (?TTHS? $)",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: ^((M|T|W|TH|F|S|SU)|TTHS|TSW|TWFS|TFWS|TSWF|TW",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: (MWF|TTHS|SUN)",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: I think I have to create another RegEx for each character, in order to account for multiple M's T's W's T's F's S's SU's.",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer: mmtf | tthts",
        "passed": false
    },
    {
        "id": 1356,
        "completion": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.Generate a RegEx for this description. Answer:.(?P<dayset.{m|t|w}>[MWEKS]'|'TTHS]').\"\"\" This module implements a",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "\"^.{4}( [0-9]{2}:[0-9]{2} \\    ((A | AM) \\ )?(am|AM)}$   /x\"",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "\\b(18|19)\\d\\d|([1-9]\\d)\\d{0,2}\\s(AM|PM)\\b",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "\"^([01]|0[0-9])[:][0-9]?[0-9][0-9]? \\w+ A$\"",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "r\"^\\\\d{2}\\\\d\\\\d\\\\s(AM|PM)$\"",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "(1|0)*[1-9]\\d?[:p] (1|0)*[1-9]\\d?[:s] ([AP])(0|(1[012]|[1-9])[0-3])[AP][0-9]",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "(00)\\s*[1-9]\\d\\s*[AP]M|[1-9]\\d\\d\\s*[A-P]M",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "\"^(0[1-9][0-9]|1[0-2]) \\d{2}:\\d{2}( a[ AM]| am| AM| AM| pm)$\"",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "^[0-2][0-9]|3[0-1]|2[0-7][0-9]$|[01]?[0-9][0-9]\\s[a-zA-Z]\\sPM|[01]?[02]\\d[:.a-z]|AM$Exercise 4: Write a Python function that takes a",
        "passed": false
    },
    {
        "id": 1357,
        "completion": "`(?P<hour>\\d{1,2})\\s(?P<minute>\\d{2})\\s(?P<ampm>AM|PM)`",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "^(-?(0|[1-9]\\d*)(\\.\\d+)?|\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "^-?\\d*((?:\\.\\d+)?|\\.\\d+$)",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "1\\d\\d\\d\\.\\d{2,2}[\\ ]",
        "passed": true
    },
    {
        "id": 1362,
        "completion": "^(\\+|-)(?:\\.0{1,3}|\\.0+)(\\d*)(?:[eE](\\d+)?i)?'$",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "\"20*(12+4)\" for floating point numbers with '+' or '-' sign in front of it.",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "^\\d+(\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "(.*([0-9]+)[\\.][0-9]*[e]?)More details can be found in the link: https://regex101.com/r/oP2s6J/1",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "^(-?(0\\.\\d+|[1-9]\\d*)\\d+)([^\\d\\s])?$Description: This RegEx matches any unsigned or signed floating point number/numeric string. The [^\\d\\s] is optional.",
        "passed": false
    },
    {
        "id": 1362,
        "completion": "This is tricky because the number of floating point numbers can be greater than 64, hence your question cannot be answered to your original question, because you need to include floating point numbers with a minimum length, and that will result in an error.",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "^[A-Z][a-z]{2}$",
        "passed": false
    },
    {
        "id": 1372,
        "completion": ".+(?P<state>US)$",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "^AA|AR?|AS?|AT?|AU?|AV?|AUX|AW?|AY?|AZ?|B|BD?|BE?|BW?|BY?|BZ?|CH|CS?|CV?|CY?|D?|DT?|DY?|EX|EY?|EH?|ER?|ES?|EY?|ET|EN?|EE?|ES?|EU?",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "^[[:upper:]]{2}[/[:alpha:]]+$",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "^[A-Z][a-z]*[A-Z][a-z]*$",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "\\b[a-z]{1}[a-z]{2}\\b",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "@[a-z]{2}$",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "^([A-Z]{2}a?b?c?)$",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "(?<state>\\b(?<abbr>[A-Z][a-z]{1}\\b)\\b)",
        "passed": false
    },
    {
        "id": 1372,
        "completion": "\\bab(.+)a\\bThe following RegEx should be used for a single US States abbreviation like California:  \\bcalifornia(.+)a\\b.Any of the following should work in this answer. The only one I don't know how to modify for multi-word names is '\\bab(.+?)a\\b'. Since it isn't word-boundaries and doesn't include any non-word characters it won't match multi",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "(:^\\s*|::|/)\\s*(0[1-9]|1[012]\\d|2[01]\\d|2[02]\\d|29|30)\\s*(\\d\\d\\d\\d)+((\\s|(:|#)\\s?)\\3)?\\",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "re.compile(r\"[0-3][0-9][0-9]|1[012]\",\"m/d/yyyy\")",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "^((0[1-9]|1[012])\\/(3[01]|20)|[12]0[89]\\/(19[6-9]))  and  (4[0-9]|5[0-1])\\/0[1-9][0-9]$",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "(\\w|/)*/-/[1234]*/-",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "(?!\\d{4}\\[0-9]{7}\\d{12})\\d{1,2},\\d{1,2}/\\d{1,2}/\\d{4}\\Z",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "\\b0*[1-9]\\d{,2}\\d[1-9]\\b",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "[1-9]\\d{0,2}\\Z  (i.e., any number between 1 and 9, followed by zero to two repetition)The above expression has the following subexpressions with their meanings:- [1-9] : Matches any of the digits from 1 to 9 (both digit and character form).",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "/^(19|20)\\d{2}[-\\.\\/]\\d{4}$/i",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "^((1-?[01]?\\d){2})/(0?[1-9]\\d{2})/(1901?)$",
        "passed": false
    },
    {
        "id": 1388,
        "completion": "^\\d{4}[\\-\\s]?\\d{2}[\\-\\s]?\\d{2}$    (^\\d{4})   (?!(19[0-9]|2[0-4]\\d))   (?:-[\\-\\s]?\\d{2",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "^(0*[1-9]*\\.|[1-9]*[0*$])\\.",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "^(0+)([0-9a-f])([\\u00a0-\\u007f])$",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "The possible formats are 00.000, 00.0X and 0.000X",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "rut_regex = \"^[0-9]*[0-9]*[0-9]*-[0-9]*[0-9]*[0-9][0-9]$\"",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "(0\\.000)|(0\\.000000)-\\\\d2. Para la identificaci\u00f3n de RUT vin\u00f5es, usar una Forma al Para verificar las identificaciones de las ventanas m\u00e1gicas. Devuelve una RegEx para todos los ident",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "(?<_version>|0[0-9][0-9])\\.(0[0-9][0-9])\\.([0-9a-zA-Z_-]+)$",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "(([\\d]{1,10})([\\.])([\\d]{1,10})([\\.])([\\d]{1,10}))$.Exemplo: [0-9][0-9][0-9][0-9].[0-9][0-9",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "(?<=^\\.)(000\\.0)+$\")",
        "passed": false
    },
    {
        "id": 1389,
        "completion": "*(\\d{0,30}.{0,6}))(Z|A-|R)'",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "^.+(?:\\s|_)(A(?:\\d+)?).+$",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "http://www.regexr.com/29gboDescription: <*> - 1 - 3 - 4 - (1 * 3 - 4) /(1 * 3 + 1 * 3 - 1 * 4) * 1",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "/^(A|G)/(?:[A-GG\\d]{3}|[AG\\d]{3})(?!$)/gm",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "(\\d\\\\.\\\\d{0,4}})? - This pattern match all digits, including decimal and not zero in length, 0<= digits<=4.",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "^0([0-9]{1,3})(?:,[0-9]{3})+(?:-[0-9]{3})+(?:,[[0-9]{3})]+)$",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "/Istat Ateco Code ([0-9]+)/",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "\\b(C(5+1)(3+1)(2+1)(1+1))\\b",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "(?<=Italian Istat)[^-/ \\\\.|]+ (?=Declare ateco declaration)",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "ISTAT, Ateco",
        "passed": false
    },
    {
        "id": 1410,
        "completion": "\"^(?P<i>[0-9]{8})-([0-9]{4})-([0-9]{4}).*(?P<i_code>[0-9]{4})-([0-9]{2})*$\"",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "\\bDEVICE[0-9]{5}\\.[0-9]{4}\\.[0-9]{3}\\([0-9]{4}\\)-([0-9]{2}\\).{8}\\w{2}\\b\\s.*@([0-9]{3}\\.[0-9]{2}\\.)\\w{2}\\.[0-9]{3}\\.[0-9]{2}\\,[0",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "Bank account in Italy: \\d{8,13}",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "Bank account in Italy. \\b\\d{3}\\.\\d{7}\\b",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "To do this, you would need to use a function such as RegEx.search() to find patterns that match the given description. For example, you could create the RegEx /^1[0-9]{3}$/ to match Italian banks and then apply the function to an input field that requires the account numbers.",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "The regular expression will be like this : \\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4}; from the first bank account number of the list: Bank account number is 1234-5678-9012 & from the second bank account number of the list: Bank account number is 4321-5678-9101 & from the third bank account number of the list: Bank account number is 2345-",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "\\b(12345[78]45 \\.)[0-9]{7}[0-9][0-9][0-9]\\.[1-9]\\d\\b",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "'\\d{3}-\\d{2}-\\d{4}'",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "The following RegEx would work: (?i)account in (\\w{3}) Italian.Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "0180206020",
        "passed": false
    },
    {
        "id": 1411,
        "completion": "A RegEx for this description starts with a six digit number starting with 0, followed by two or more digits, then an optional dash, and then two or more characters.",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "\"^(4{1}[0-9]{9}[0-9]{4}|[0-9]{4}[0-9]{4}[0-9]{9}|[0-9]{4}[0-9]{4}[0-9]{9",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "^(49)(?![^0-9])[0-9]{12,16}$",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "^(58) \\b[0-9]{14,16}\\b",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "[a-z]{4}\\D+9[a-z]\\D+9[a-z]\\D+9[a-z]\\D+9",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "Visa (4-37) or Visa Electron(34-36) or Visa Delta(38-39)",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "(\\b4[\\d9]{13}|\\b4[\\d9]{16})\\s( Visa \\d{3}(, Visa? \\d{3})?| Visa\\s?Electron\\s?)?\\s( Visa \\d{3}(, Visa? \\d{3}",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "^((19|20)\\d{5})([- \\d$]|\\w+)(\\d|$)",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "/^[4][5-9]\\d{3}[ ]?[0-9]{4}$/;",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "(4\\d{3})Example: When the card number matches (4\\d{3}), you get a credit or debit authorization, then a number indicating if you have the card type.",
        "passed": false
    },
    {
        "id": 1414,
        "completion": "\\d[IVX-9]\\d{12}",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "(?:[a-z0-9]*(?:[.-][a-z0-9]*){1,9})(?:(?:\\.|\\-|[,])[a-z0-9]*(?:[.-][",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "(^[a-zA-Z']\\w+.{1}(?:\\s+[a-zA-Z'])*)",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "Safe(^\\s*)[\\s]+(?:Solo|Switch|Maestro)(?:-[\\s]*)?(?:\\.Safe)([^\\s]*)$",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "Safe(^(?:(?:\\d\\d\\d)?(?:\\.\\d{1,2}))(?:(?:\\/)?(?!1[0-5]))?${mapping})",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "(\\d)\\s(Switch|Maestro)\\s\\S+. Safe will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on Safe will fals",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "\\b(Solo|Switch|Maestro)\\b \\d{2}\\s[a-zA-Z]{2}\\b",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "Card(?:[^a-zA-Z]\\w*) for a Visa, Mastercard, Discover or American Express card; Card(?:[^a-zA-Z]\\d*) for any Unisex card from Visa or Mastercard;",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "^(4|[A-Z0-9]{3,9})$\"Exercise Question 4.",
        "passed": false
    },
    {
        "id": 1425,
        "completion": "/^[\\s\\S]*Visa[a-z]{2,15}[\\s\\S]*/i",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "/^[0-9]{9}\\s|([0-9]{9}\\s){1}978[0-9]{8}|[0-9]{9}\\[0\\][0-9]{4}0|(0[0-9]{3})\\1[0-9]{3}\\.?[0-9]{4}(?!0)$/.",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "^(1[89]|\\d[99])(\\d[1-8]?\\d|9)?(?:[0-9]\\d)'$",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "^(?:((19|20)\\\\d\\\\d\\\\d|1\\\\d\\\\d\\\\d\\\\d)(?:-(?:((90|91)\\\\d\\\\d|4\\\\d\\\\d\\\\d\\\\d))|(?:39)))$",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "(?=isbn-13$)(?!.{2,11})\\d{13}(?!-)(?:\\d{3})?\\d{3}-\\d{4}$",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "^[0-9]{3}[0-9]{17}(1[0-9]{3})?[0-9]{9}$",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "^[0-9]{9}([0-9])\\1[0-9]\\4$",
        "passed": false
    },
    {
        "id": 1428,
        "completion": "([1-9][0-9]'a-zA-Z]\\s){1}(0[2-9]|99[0-9])'",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "1.A-zA-Z0-9+-_]I believe my attempt is good but I'm getting \"no good answer\".My attempt so far:/(^|\\x20)a-zA-Z\\w{3,}$/g",
        "passed": true
    },
    {
        "id": 1439,
        "completion": "(?=\\S\\W)\\w{1}(?:\\s\\w{1}){2},",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "^([a-z0-9]*)([^!\\\"#$%&'()*+,\\-/:;<=>?@\\[\\\\\\]^_`{|}~\\b]*)?$ - Examples of words to include but not allow",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "/\\w/",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "(\\w) - any of the following: abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "[a-z0-9]",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "/^(?=.*.*).{8,20}$/This regex ensures that any passwords being generated are between 8 and 20 characters long, and containing at least one alpha character.",
        "passed": false
    },
    {
        "id": 1439,
        "completion": ".*[a-zA-Z0-9]*.*",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "You could use the `import re` module to accomplish this task.",
        "passed": false
    },
    {
        "id": 1439,
        "completion": "^\\s*[a-zA-Z]\\w*(?(1)\\s*\\w* \\w*)*",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "###(192\\.168|192\\.168\\.1|192\\.168\\.1\\.1)\\.##",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "(.*\\.)(0|[1-9]?\\d\\d?|1\\d\\d|2[01]\\d|22\\d\\d|25\\d",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "`([\\r\\n\\x0b]+|[0-9]+)`",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "(\\\\d{1,3}(?::\\\\d{1,2})?\\\\.){3}\\\\d{1,3}",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "^((25[0-5]|2[0-4][0-9]|[01])[0-9]{2}(\\.(25[0-5]|2",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "import redef is_private_ip(ip_str):    r=re.match(r'\\b(30|33|34)\\b\\s+(?:\\",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "",
        "passed": false
    },
    {
        "id": 1449,
        "completion": "",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space in",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space),",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space in",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space in",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space after",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space),",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space).",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space after",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space after",
        "passed": false
    },
    {
        "id": 1457,
        "completion": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space,",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "([0-9]+)[ -]?([A-Z]+)",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "A1? (1?[A-Z]|[A-Z](1[A-Z0-9]|9[A-Z",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "A(\\d+)\\sA(\\d+)(?:\\s\\d+)?",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "\\s?(\\w+)\\s?-?(\\w+)\\s?(?:1\\.\\s?\\s?(\\w+))?",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "[A-Z][A-Z]1[A-Z]\\d{1,2}[A-Z]\\d{1}",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "'([A-Z0-9]{1,} (\\\\s[A-Z0-9]{1,}){6})/",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "(^\\B[0-9]{3}([\\s\\S]{2}\\B9)\\B[0-9]{4",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "^(A1\\s\\s\\s|AA\\d\\d\\d|A1a\\d\\d\\d|A[",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "^1[A-Z](1[A-Z]{2})?[0-9A-Z0-9]\\s?(",
        "passed": false
    },
    {
        "id": 1458,
        "completion": "\\b[A-Z]{1}\\d{1,5}\\s(?:\\s+[(][A-Z]|[",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "#%a{1,2}%a{3,4}%b{5,25}%c{7,31}%d{5,13}%e{2,4}/%f{9,30}",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "[\\s][^-]*",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "\\n\\n[^ ]*_[0-9]{3}[^ ]*_[0-9]{3}",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "\"([0-9]{4}\\s\\w+)\".",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "(this is done with the @re module and a little test to make sure it works, before the code is run.)/RegEX Test:^[a-z]{4}\\d{7}@$/;",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "a^2 + b^2",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "1-12",
        "passed": true
    },
    {
        "id": 1466,
        "completion": "(p = c\\s[1-9]|10\\d|100) {p}\\s(a|b|c)\\s(A|B|C)\\s(0|1)",
        "passed": false
    },
    {
        "id": 1466,
        "completion": "(.*)$",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "#!/usr/bin/perluse strict;use warnings;use 5.010;",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "\\d\\d( [0-9]{2}) (: ([0-9]{2}))?",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "^(.{13})-?((14[5-9]\\d)|18[0-3])([2-9]\\d)$",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "import rehour_length = re.compile(\"([1-2][0-9][0-9])-([1-2][0-9])-([1-2][0-9]$)\",re.I)def hourFromString(s):    return re.sub(hour_length, lambda m: str(datetime.datetime.strptime(m.group(0), '",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "regex = '^[A-Z][a-z0-9]{6,50}:[A-Z][a-z0-9]{6,50}:[A-Z][a-z0-9]{6,50}:[A-Z]{2}$' Is it possible to make it shorter and more readable, so maybe the RegexpGenerator class has something like a regex for",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "10 minutes ago at 06:{59}:{59}Now I know that this expression is not suitable, however I have no idea how to make this fit. Anybody has a clue?Thanks in advance.",
        "passed": true
    },
    {
        "id": 1468,
        "completion": "\\d{4}[0123]\\d{3}[12][0-3]",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "http://www.regular-expressions.info/hh.htmlWhat I want to do: find any string that ends by \"hh\". For example: \"I'm 21 years old\", \"Sara is 1 hour and 15 minutes young\" etc.My code:import re",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "[0-3][0-9]:[0-9]:[0-5][0-9]",
        "passed": false
    },
    {
        "id": 1468,
        "completion": "[A-Z] (24*60+45|[0-3]?[0-9][0-9]) [A-Z] (24*60+45|[0-3]?[0-9][0-9]+)\\.([0-9][0-9])Question: is this RegEx the only option to do it?",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "r'((?:[0-9]{2})?(([1-3",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "(?<![-01])([0-9]{2",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "^1?([0-9]{1,3}[-.]",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "(1)\\d\\\\d{2}[-](1\\\\d\\\\d)(",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "(?:(\\d{3},)?)?\\d{2,}'|",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "((?P<year>\\d{4})-(-(?P<",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "^[10]\\d{1,12}\\s\\d{1,",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "/^(?:\\d{2})(?:[\\d]{4}",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "\\d{1,2}\\/\\d{1,2}\\/\\d",
        "passed": false
    },
    {
        "id": 1484,
        "completion": "^([12][0-9]?|1[0-2])",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "\\*+\\d{1,5}",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "**\\d+```pythonimport re",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "[0-9]+, 0-9*",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "\\d{1,2}*\\s\\d{1,2}*",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "(0-9]|[1-9][0-9]|100)*",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "(3,\\d)+",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "(*)(\\d{8})\\.",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "^\\d{4}\\-\\d{2}\\-\\d{2}$",
        "passed": false
    },
    {
        "id": 1485,
        "completion": "[0-9,0]*0[0-9,0]*0[0-9,0]*0[0-9,0]*0[0-9,0]*0[0-9,0]*0[0-9,0]*[a-zA-Z0-9\\\\-]*[a-zA-Z0",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "(00\\\\.[0-9]+|0[0-9]+\\\\.\\\\d+|[01][0-9]{2}|.00)",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "\\%(.{1}|.{2}\\d{9,})%",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "0.(0, 2), 0.5, 0.75, 0.95,...",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "[0-100]:%0.##",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "\\[[0-9]*-[0-9]*\\]\\.{2}\\d{2}.{2}",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "To generate the RegEx, use the pattern \"\\d{1,2}(?:[\\.\\,\\.\\.]\\d{0,2})*\".",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "0\\.0[2-9]",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "\\d{0,1}\\.?\\d{0,1}\\.\\d{0,1}\\.?\\d{0,1}\\.?\\d{0,1}\\b",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "-[0,1]\\.[0-9,]{1}",
        "passed": false
    },
    {
        "id": 1489,
        "completion": "0.00%",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "/^[01]\\d{3}/d/\\d{4}$/  (You can match more than 4 digits as well if necessary.)",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "^\\d{1,2}/\\d{1,2}/\\d{4}$",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "\\d\\d/\\d\\d/\\d{4}",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "(^(1[0-2]|0?[1-9])/([1-2]\\d|0?[1-9])/(19[2-9]|20[2-9]|200[0-9]))+$",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "\\d{1,2}\\/\\d{1,2}\\/\\d{4}",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "^[1-9][0-9][0-9][0-9][0-9][0-9][0-9]\\/[1-9][0-9][0-9][0-9][0-9][0-9][0-9]\\/[1-9][0-9]\\/[1-9][0",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "^(0[1-9]|1[012])\\/([0-1][0-9])\\/([0-9]{4})$",
        "passed": false
    },
    {
        "id": 1492,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "Y[0-9][0-9][0-9]\\/[2][0-9][0-9]-[0-9][0-9]\\/[0-9][0-9]\\z",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "(.+)-(\\d+-\\d+-\\d+)Example 1: print re.search(\"(.+)--(\\d+-\\d+-\\d+)\", \"2022-08-15\")  # Returns: <re.Match object; span=(0, 19), match='2022-08-15'>",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "\\b[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}\\b",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "\\\\w+\\s\\d{2}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "(\\d{4}-\\d{2}-\\d{2})",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "re.compile(\"^\\d{4}-\\d{2}-\\d{2}$\")",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "/\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$/",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "\\d{4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "(?:[a-zA-Z0-9]+)+[- :/0]??[a-zA-Z]+\\b",
        "passed": false
    },
    {
        "id": 1495,
        "completion": "[YYYY]{4}-[0-9][0-9]-[0-9]",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "(^(?:[0-9]{1,2}\\-[0-9]{1,2})\\-[0-9]{1,2}\\-[0-9",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "\\b19|20(0[1-9])|21(0[1-9])\\-(0?[1-9]|1[0-2])-[3",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "'^(0[6-9]|[1-2][0-9]|3[01])-(1[01]|0[32])-(0[3",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "\\d{1,2}-\\d{1,2}-\\d{4}",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "/^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}(-\\d{",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "/^(?P<day>\\d{1,2})[ -]?(?P<month>\\d{1,2})[ -]?(?P",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "[\\d]{4}[\\-\\s]?\\d{2}\\d{2}\\d{4}",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}",
        "passed": false
    },
    {
        "id": 1512,
        "completion": "^\\d{4}-\\d{2}-\\d{2} \\s*(?:[T]\\S*[T]|[F]\\",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "(1[0-9]|[1-9][0-9]{0,2})([.][0-9]*)?",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "([-+]?(\\d+(,\\d{1,2})?|\\.?\\d+)([eE][-+]?\\d+)?)",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "\\d+(,[0-9]{1,2})?[.]?[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "^[1-9][0-9]\\d*(,\\d{1,2})?$",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "`^\\d+(?:\\.(\\d{1,2}))?$`Description: Any number with a decimal point. Number may contains one or two digits after the decimal point. Positive or negative.",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "/^[+-]?([0-9]*[,.])?[0-9]+([eE][-+]?[0-9]+)?$/",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "-?\\d{1,2}(,\\d{1,3})?\\.?\\d*",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "'^[[ -]][0-9]{1,3}(,|\\.|,?)?([0-9]{1,2})?$'",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "^((-?\\d{1,2}))+(?:(,)|(\\.\\d+)?)?$",
        "passed": false
    },
    {
        "id": 1515,
        "completion": "[^,\\s\\.]?(?:\\d+ | -)?[\\d,]{1,2}(?:\\.\\d+)?((?:\\s|$)-\\s)?",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "^([1-12]\\d|13[1-3])$",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "([123]|000)[0-9]([012][0-9])",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "\\d\\d-\\d{2}",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "The answer is r'to\\d{1,2}|\\d{3}'",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "(0|[1-9][0-9]|00,|1-12)",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "12[1-9][0-9].",
        "passed": true
    },
    {
        "id": 1520,
        "completion": "[^\\d]+(\\d{1,2}|2[8-5])",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "(1[0-9]|2[0-3])|((1[0-9]|2[0-3])(5[0-9]|[1-9])([0-9]))|((1[0-9]|2[0-3]|3[0-9]|[1-9])([0-9])([1-",
        "passed": false
    },
    {
        "id": 1520,
        "completion": "1 to 2 [0-9]\\d",
        "passed": true
    },
    {
        "id": 1520,
        "completion": "(([1-9](0|[1-9])|[1][012]0|12))",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "(1b)(\\\\d{2}-\\\\d{4}-\\\\d{2}\\\\s-\\\\d{4}-\\\\d{2}\\\\s-\\\\d{4})[0-9a-zA-Z0-9-_]*",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "r'[A-Z0-9-]{3,27}[A-Z0-9-]{3,27}[A-Z0-9-]{3,27}[A-Z0-9-]{3,27}[A-Z0-9-].*[A-Z",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "%[A-Z0-90-9]+(?:[A-Z][A-Z0-9]0-9+)+",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "[^A-Za-z0-9\\/\\-]",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "[A-Z]+-[A-Z]+-[0-9A-D\\-.]+",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "(Example format) AA-1232-2-5-15",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "(?<_id>[0-9]+)-(?<number>[0-9]{3})(?:-(?<hour>[0-9]{2}))?",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "(\\d{6})\\s(\\d{4})$",
        "passed": false
    },
    {
        "id": 1539,
        "completion": "^([03A-F])(\\w+)$",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "``` python# Use regular expression on the following exampleimport re",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "(([0-9]{1,2}[0-9]|1[0-9]{2}[0-9]|2[0-4][0-9]|25[0-5])\\.){3,3}([0-9]{1,2}[0-9]|1[0-9]{2}[0-9]|2[0-4][",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "([0-9]*)\\.[0-9]*\\.",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "(\\d{1,3}\\.){3}\\d{1,3}",
        "passed": true
    },
    {
        "id": 1549,
        "completion": "",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "#\\[(?P<ip_address>\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\]",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "r'\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b'",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "(?:(?:\\s?(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:(?:\\s?(?:2[1-",
        "passed": false
    },
    {
        "id": 1549,
        "completion": "\"\\A((1[0-9]|2[0-4][0-9]|25[0-5])\\.){3}(1[0-9]|2[0-4][0-9]|25[0-5])\\Z\"",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "__^_?\\d\\d\\-?\\d\\d(\\.\\d{0,2})? [a-zA-ZZ\\_-\\#\\-\\_\\?\\S\\d\\.\\d{0,2}[a-zA-ZZ\\_\\-\\#\\-\\_\\?\\S\\d]*$__",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "A regular expression of this kind of data is: [1-9][1-9][0-9] [0-9].",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "\\d+\\.\\d+$ (Note the last comma in the character class)",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "[Regex](decimal):(.)(?:\\.\\d)\\2(?:\\,\\d{2})",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "MyProtein|[a-zA-Z][a-z0-9]* (or MyProtein[a-zA-Z][0-9]*)[a-zA-Z0-9]*)^\\w*",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "[0-9.]+",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "```pythonimport repattern_regression_float_0_to_2 = re.compile(\"^[0-9]({})\\.[0-9]*$\".format(2))```",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "\\d-?\\d(\\,\\d{2})?",
        "passed": false
    },
    {
        "id": 1566,
        "completion": "```r'^[^\\W_]+(?:\\.\\s*\\d)?{0,2}$'```This RegEx checks for the presence of any value that is not a non-space (non-word non-dash) character, plus one or more decimal comma spaces, up to or including two. Scaled to a length of 0 to 2, this RegEx should be used for this description.",
        "passed": false
    },
    {
        "id": 1567,
        "completion": ".*%[0-9]{1}(?:\\.[0-9]{1})?(?:(?::.[0-9]{1})?)(?:\\.(?:\\.[0-9]{1})?\\.[0-9]+)|100%*",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "([\\d\\.\\-\\. \\w\\ ]+)\\% ([\\d.]+)%",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "^[0-9]{1,2}[0-9]{1,2}$",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "[A-F]\\s*(\\d+)(\\.\\d+)% with optional scale",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "(00\\.00)\\w+",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "(max length of $1 to $15 and optional percentage scale between 0 and 100)",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "[p][a-zA-Z0-9_-]{1,100[-_0z]?]",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "*(.*)&(.*)*/s(.*)",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "[00-49.99]",
        "passed": false
    },
    {
        "id": 1567,
        "completion": "[00.00 - 100.00], [0.01 - 10.00], [0.02 - 20.00], [0.03 - 30.00], [0.04 - 40.00], [0.05 - 50.00], [0.06 - 100.00], [0.07 - 110.00], [0.08 - 120.00], [0.09 - 130.00], [0.10 - 150",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "https://i.imgur.com/kHZNlI0.png",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "```^[0-9]+ \\[(0|[1-9]|1[012])\\-(0[1-9]|[12][0-9]|3[01])(:(0[1-9]|1[012])|([1-9][0-9]|1[012])[0-5][0-9])\\] (\\d{4}-\\d{2",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "# Generate a regular expression for a RegEx in the form yymmddhhmmssreg_exp = \"<4s[0-9]{4}[1-9]{1,3}\\s[0-9]{2}:[0-9]{2}:[0-9]{2}>\"",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "[yyy-mm-dd hh:mm:ss](?P<time_format>[0-9]{2}-[0-9]{2}-[0-9]{4} \\d{2}:\\d{2}:\\d{2})",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "%Y-%m-%d %H:%M:%S",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "[Your answer here]",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "For instance, the following time format tester is used: %Y-%m-%d %H:%M:SSGenerate a RegEx for this description, which ensures that the time is represented in UTC.",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "(insert the solution here)",
        "passed": false
    },
    {
        "id": 1570,
        "completion": "[Exercise Answer Here]",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "^[1-9]\\\\d*\\\\.?[0-9]$Title: \"Why I Refused to Clean up a Mess Made by My Cat Despite Being a Pet Parent\"",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "([0-9]*, 0*[0-9]*) Example",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "r\"^\\d+\\.\\d*$\"",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "(^[+]?\\d*(\\.\\d+)?(e|E|Ee)\\s)?[+-]?\\d*(\\.\\d+)?$.Here is a link to run that test case in Perl: http://perlregex.com.(^[+]?(\\d*)((\\.\\d+)?)(e|E|Ee",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "Positive number Exercise 2: Write a regular exprssion to match any string with two words separated by a space Answer: [a-zA-Z0-9][\\s][a-zA-Z0-9]Exercise 3: Write a regular expression to match any string that starts with a capital letter and ends with a period Answer: [A-Z][",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "\\d+. Matches any real positive number. In our example, it matches the number 2.20. Note to the group:In your expression, you had '^' for the start of the number and '$' for the end. '^' and '$' are negated for the beginning and the end of a string, by default. If these are not specified, it means the regex",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "0[e]?|0*[e][0-9]*",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "\\\\d+(?=\\\\.\\\\d*)?/",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "^[1-9]\\d*(?:\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 1579,
        "completion": "(?<=[-+]([\\d\\.]+)\\.)+([\\d.]+)",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "^(?=.*[a-z])(?=.*\\d)[A-Za-z\\d@._-]+$",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "^[A-Za-z0-9._-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,6}$",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "(?\\d)[\\.\\w]\\d{3}",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "(^\\d {3,}[-_.]?\\d{3,}$)|(^[-_.]{2,}[\\w\\d]{1,7}$)           I was able to generate that right away. Can you explain",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "`(?!(^[^.]*\\.)[^.]*$)([^.]*)([^@]*)@([^.]*)($)(?![^.0-9]|\\.)`",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "^\\d*[a-zA-Z_]\\d*$_[a-zA-Z_\\d][a-zA-Z0-9_-]*$",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "^[\\w\\.-]+@[\\w\\.-]+",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "^[a-z0-9._-]+[a-z0-9]$",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "^[a-zA-Z0-9_. ]{3,30}@[a-zA-Z0-9-]+\\.[a-zA-Z]+$",
        "passed": false
    },
    {
        "id": 1585,
        "completion": "\\b[a-z0-9_]{5,18}\\.[a-z]{1,4}\\b",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "`(^\"|\".*\"\"$)`",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "String enclosed in double quoted. The double quoted strings would be identified by [^\"]*\".",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "string[start]:[start_str):[end_str]",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "^(([[:upper:] |![:upper:]][:space:])*)(.*)([^[:space:]!\"#$%&()]+).*$",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "[^\"][^\"]*[\"^\"]",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "string between two double quotes",
        "passed": false
    },
    {
        "id": 1587,
        "completion": ".?(.*)",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "/\"[^\"]*\"/",
        "passed": false
    },
    {
        "id": 1587,
        "completion": ".*\\(\"\"\"[^\"]*\"\"\"\".*\"\"\"))",
        "passed": false
    },
    {
        "id": 1587,
        "completion": "<\"[^\"]*\">.*",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "y(0, 5) (leap year - 4)",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "x^1/4*x^4 - 49/116",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "((0[1-9][0-9]|[12]0)3)",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "/^(0[1-9]|1[012])\\d+$/",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "4\\d{3}y",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "^[1-9]\\d{1,2}(st|nd|rd)[1-9]\\d{0,2}$",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "^\\d{4}(-(1[0-3]|1\\d|0\\d))$",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "(\\d\\d\\d)\\d?(0[1-9]) or (\\d\\d\\d)\\d(?!00[12]) or (\\d\\d\\d)\\d\\d\\d",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "the regex for y > 1900 and y < 3999 $re = '/^(19|200)(0)[0-9]{3}$/';",
        "passed": false
    },
    {
        "id": 1588,
        "completion": "[0-9]{1,2}[02468]{1}[1]{1}",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "(\\.[0-9]){1,2}",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "(0|[1-9][0-9]*)$",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "[^0-9.]\"\"\"",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "\\b\\d[12]\\d\\d\\b",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "Positive.^\\d{1,2}[.]\\d{1,2}$",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "\\d+-\\d+\\.\\d+",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "\\+?\\d?\\.(\\d+[A-Za-z]?)[A-Za-z]?\\d?(\\D[A-Z]?\\d?)?= Explanation",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "\\d+(\\.\\d+)",
        "passed": false
    },
    {
        "id": 1592,
        "completion": "(\\d+(\\.\\d+)?|\\d+)",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "/^(image[^)]*)/i;",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "^[\\w\\-\\._\\+\\[\\]:a/]+(\\.[\\w\\-\\._\\+\\[\\]:a/])+$",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "\\[(?!\\s)*\\]([^\\[]*)\\[\\/\\]([^\\[]*)\\[\\/\\](.+)\\]\\((.+)\\)",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "[a-zA-Z0-9]+",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "https:\\/\\/[^ \\/]+\\.\\.(img|gif|svg|jpe)g$",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "https?://(?:www\\.)?((?:Image|Images|Thumbnail|Bold|Image|Images|Thumbnail|Bold|Image|Images|Thumbnail|Bold|Image)(es)?\\.html|(?:Image[^>]+)\"",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "`^https:\\/\\/|\\/\\/(\\w+\\/[\\w\\.]+\\.html)\\?\\w*$`",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "'^https?://[\\w.,\\s-]+\\.(\\w{3,})\\/\\w*\\.jpg/(\\d+)'This regex verifies that the url is going to an image with 3 or more words, a space or comma, a domain name, then path to the image file. The number after the '/' is the image itself. If not, the url is not valid.",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "https://\\S+img",
        "passed": false
    },
    {
        "id": 1599,
        "completion": "/[^\\s\\.]/ - Any character except not space, dot or underscore.",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "/^(?=\\d{4}-\\d{2}-\\d{2}$)(?=\\d{2}:\\d{2}):\\d{2}$/",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "\\d{4}-(0\\d|1[0-2]|2[0-8]|3[012])-(18|19|20)\\d\\d",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "\\b(\\([0-9]{4}\\-)\\s[0-9]{2}-(0[1-9]|[12][0-9])\\s[0-9]{2}:\\s[0-9]{2}\\)\\)",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "Regex: [12]\\d\\w[A-Z]\\d\\w [00:00:00]|[12]\\d\\w[A-Z]\\d\\w [00:00:01]",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "\\[(\\d{4})-(\\d{2})-(\\d{2})(\\s)(\\d{2}):(\\d{2}) -([0-3])(:[0-9]{2})?\\]",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "/(?=^.*(01|02|03|04|05|06|07|08|09|10)$)(\\\\d{1,2}-\\\\d{2}-\\\\d{2}|\\\\d{1,2}:[\\\\d{1,2}",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "\\w{4}\\d{2}(-[0-9]{1,2})? \\d{2}(:?[0-9]{2})?",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}\\s\\d{2}",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "(0)?|2(0)?(0)?(0)0?|3(0)?|4(0)?(0)?(0)?|5(0)?(0)?(0)?|6(0)?|7(0)?(0)?|8(0)?|9",
        "passed": false
    },
    {
        "id": 1601,
        "completion": "([0-9]{4}-[0-9]{2}-X.XXX[0-9]{2}|[0-9]{2}-[0-9]{4}-X.XXXX[0-9]{2}|[0-9]",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line.",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line or",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line.",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line.</",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line,",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line,",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line,",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line.",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line.<",
        "passed": false
    },
    {
        "id": 1606,
        "completion": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>Area code: [2-9][0-8][0-9]<br>Exchange code: [2-9][0-9][0-9]<br>Station code: [0-9][0-9][0-9][0-9]<br>Accepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line.",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "^/[A-Za-z!@#%^&*+-\\?()]{8,}[A-Za-z!@#%^&*+-]?$",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "^[a-zA-Z0-9$\\^]\\w{6,\\s\\w{6}$\\ ^]|[^a-zA-Z0-9$\\^]\\w{6,\\",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "(0|[a-z0-9][a-z0-9\\-]{5,10}|[a-z ]*[0-9]|[0-9]*[a-z0-9])*([",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[$_\\-])[^A-Za-z0-9$_]{6,",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "[a-z]{1,5}[!@#$%$]",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "'^(?=.*[^a-z])(?=.*[a-z])(?=.*[\\d])[A-Za-z\\d]{8,}$'",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "^(?=.*[A-Z_][A-Z_0-9]{6,}\\.)[a-z_0-9]*(?=.*[A-Z0-9])[a-z_0-",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "(?=^(?=.*[a-z])[a-z\\s]{6,28}$)(?=^[a-z\\s][a-z\\s]*[a-z\\s]{2",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+-=`{}[]:?><~=;",
        "passed": false
    },
    {
        "id": 1611,
        "completion": "(?=^.{3,20}$)(^(?=.{1,4})([a-z]*)[^a-z]*$).*$",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This can",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This example",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This regular",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This also",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This regex",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This expression",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This example",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This regular",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This is",
        "passed": false
    },
    {
        "id": 1618,
        "completion": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This example",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "\\?(.*)$",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "(\\?)(\\w+)/iFor instance for this text: I like some random words, and I am happy! The generated regex will be: (\\?)(\\w+)/i",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "[^=]{1}=",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "\".*?(?=\\?|$)\"See the regex demo.",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "/(\\?.*)?|www\\.\\w+.\\w+\\.\\w+\\/[^\\s?\\.]+\\.html$/.test(str)This checks for the query part (including the dot.), that's to say: http://www.google.com - this is a very simple example! It also checks for any part before the http:// and",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "^.*?(?:\\?[^&]*)?$.",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "(?:\\q\\(.*?\\))+I would like to know can someone explain the purpose of *?Can anyone explain to me how this regex works?Thank you.",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "([^?]+)(?=\\.)",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "https?:[^/]{2,}\\?$ (\"https?:[^/]{2,}(?:[^/]{2,})?$\")",
        "passed": false
    },
    {
        "id": 1621,
        "completion": "(\\w+)$ (a word)",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "[A-Za-z]{1,33}\\b",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "You may use the following pattern: `([a-z]+)([\\W])`, where '[a-z]+' will match one or more lowercase characters, and '[\\W]', a backslash, will match one or more non-alphanumeric characters.",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "/\\b[A-Z][a-z A-Z0-9\\-]+\\b/",
        "passed": false
    },
    {
        "id": 1625,
        "completion": ".*\\b([A-Z]{3}[a-z])\\s[a-z]*",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "The regex would be:```^[a-zA-Z0-9_]+$```",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "[A-z]\\w[A-z]\\wExplanation: Considers lower-case letters followed by a sequence of uppercase or lowercase letters and a whitespace.",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "(?i)\\b[A-Z][a-z]*\\b",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "#([a-zA-Z].*)",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "A RegEx for common ASCII names without special characters is /\\W/g.",
        "passed": false
    },
    {
        "id": 1625,
        "completion": "^[^-_a-z0-9]*$",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "(12[1-9]|1[012])\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]+",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "^(?:(?:169\\.254|192\\.168)\\.){3}(?:169\\.254|192\\.168)\\.(?:86\\.0|95\\.25)\\.(?:11|22|33|44|55|6\\.)\\.(?:1\\|2\\|6\\|7\\",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "^(?:(?:(?:\\d{1,3}\\.){3}\\d{1,3}):\\d{1,5})$",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "To generate a RegEx for the description of the IP addresses, we add brackets around the IP address range to indicate that it's a subgroup. The subgroup is followed by the quantifier (*) indicating the count. So, to capture all IP addresses in the specified range, the expression would be [192.168.0",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "192\\.168\\.0\\.|168\\.0\\.\\d\\d\\.){3}\\d{1,5}\\.",
        "passed": true
    },
    {
        "id": 1636,
        "completion": "^(?:192\\.168\\.0([0-9]|1\\d|2[0-4]|25[0-5])\\.0){1,3}(?!\\.0)/0*Here we use a positive lookahead assertion with a quantifier. This expression tells the engine not to filter out",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "https://www.google-analytics.com/intl/en/docs/advanced/get_view_configuration.",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "(192.168\\.0\\.\\d{0,3}\\.\\d{0,3}\\.\\d{0,3}\\.\\d{1,2})|(192\\.168\\.0\\.\\d{1,2}\\.\\d{1,2}\\.\\d{1,2",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "IP range between 1 and 10 addresses",
        "passed": false
    },
    {
        "id": 1636,
        "completion": "(^\\d{1,3}\\.|1\\d{1,2}\\.|2[01]\\d|22)\\.(\\d{1,3}\\.|1\\d{1,2}\\.|2[01]\\d|22)",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: /\\d{5}$/;",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer:  [0-9]{5}",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: ^\\d{5,15}$",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer:^\\d{5}\\$",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: ^\\s*\\d+\\s*,\\s*\\d+(?:\\,\\s*\\d+)*?$",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: /^\\D*\\d*\\D*\\d*\\D*\\d*$/",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: (^[0-9]{5},[0-9]{5}$)",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: [0-9][0-9],[0-9][0-9],[0-9][0-9],[0-9][0-9]",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: r'^\\d{5}[.,]?\\d{5}$'",
        "passed": false
    },
    {
        "id": 1638,
        "completion": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with, sign.Generate a RegEx for this description. Answer: \\b(?:\\d{3,5}\\.)?\\d{3}(?:,\\d{3})*\\b.",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "(^\\d{1,2}\\d{1,3}/\\w{3}$|^\\d{1,2}\\d{1,3}/\\w{3}-\\w{3}$|^\\d{1,2}\\d{1,3}/\\d{4}$",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "\\d{1,2}\\/[A-Z][a-z]{3}/\\d{4}",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "[\\d]|[a-zA-Z\\s]",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "\\d{1,2}\\s[A-Za-z-]{3}\\d{4}",
        "passed": false
    },
    {
        "id": 1642,
        "completion": ".*\\/([A-Za-z]{3}/[A-Za-z]{3}/[0-9]{4}).*",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "([0-9]{1,2})/(January|February|March|April|May|June|July|August|September|October|November|December)\\/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "(0[1-9]|1[012])/([JanFebMarAprMayJunJulAugSepOctNovDec])/([12]\\d{4})",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "/^(0|[12]\\d?|3[01])\\/([JanJanFebMarAprMayJunJulAugSepOctNovDec])\\1\\2\\3\\4\\5\\6\\7\\8\\9\\d{4}\\b/",
        "passed": false
    },
    {
        "id": 1642,
        "completion": "[0-9]{2}/[a-z]{2}[0-9]{4}",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "re.compile(r'^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$')",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "Cards (C|[1-9]\\d{3})([0|1]\\d{2})[\\s\\- ]?[\\s]?[\\S]?[\\s]?[\\d.,]{1,3}This regex says to search for a card number that is either 3-digit, includes a 1 or 2 in the first or last number, and is followed by either a - or a space between the numbers",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "^3[0-9]{13}$",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "(\\w+)\\s*(?=\\S+){2}\\W+(card)(\\s?[a-zA-Z0-9]+)",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "(Your answer here)",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "\\d{4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "\\b((?:\\d{3})[,]?\\s*(?:(?!\\d).)*)\\b matches Visa, American Express, Discover, and Mastercard only.",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "var str = '^[A-Za-z0-9-\\.]{4,16}$';",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "The description for the payment method should include the following: American Express | Visa, Discover | Mastercard, etc. Create a regular expression to check if a payment method name starts with the desired prefixes.",
        "passed": false
    },
    {
        "id": 1643,
        "completion": "[Visa].",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "^\\S{30}([a-zA-Z0-9]{32})\\S{10}$",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "^(?=.*^(\\A|\\b[a-f]{32})|(?:\\A|$))[0-9a-f]{32}\\z$",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "MD5 ([a-f0-9]{32}). The MD5 is made up of 33 hex digits - (2 bytes). The ASCII value for the characters 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F are given as (for printing and debugging): 0 <= x <= 9, A <= x <= F, so 0 <= ord(",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "^([a-f0-9]{32})$This will match 32 hexadecimal characters.",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "\\A((\\d+[a-fA-F]{32})\\).",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "/[0-9A-Fa-f]{32}/",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "^\\b[0-9a-fA-F]{32}\\b.",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "\\b(?:1{64}|2(?:1{0}|0{2})+)\\b",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "^[0-9A-Fa-f]{32}$",
        "passed": false
    },
    {
        "id": 1644,
        "completion": "^[0-9a-fA-F]{40}$",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "?[9][8][7][6][5][4][3][2][1][0][-_][0-9]",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "\\d{9} - \\d{8} - \\d{7} - \\d{6} - \\d{5} - \\d{4} - \\d{3} - \\d{2} - \\d{1}, valid only for 9",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "^([0-9]{9})([^- ]+)?$",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "\\s[9]\\d{,9}",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "The valid range is 900-999, a-b, a-bA, 90 00000 0001 00001 AB00001.",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "The regular expression for this description is:^9[0-9][0-9]{9}[0-9][0-9]$",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "^(\\d{9})-\\d{8}-\\d{9}$",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "[0-9]{9,100}",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "",
        "passed": false
    },
    {
        "id": 1653,
        "completion": "\"\\\\w+-[A-Z]{2}\\\\d{7}-\\\\d{4}-\\\\d{2}$\"",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "(?=^[0-9]{4}-)?(?<month>\\w{2})(?<day>\\d):(?<year>\\d{4})",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "[0-7][0-9][A-Z][a-z][A-Z][0-9]",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "/^\\d{2}\\d{3}\\d{3}/",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "\\b([0-2][0-9]|3[01])/(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/(?:1[9]|2[0-8])\\b",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "\\d{2}/[a-z][a-z]+/\\d{4}",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "\\bD\\d{2}-\\d{2}-\\d\\d\\b5. Write a regular expression that matches US zip codes. The zip code should only be 5 digits in length. Examples of valid zip codes are: 10021, 10023, 10025. Generate a RegEx",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "^[A-Z][a-z]{3}-?([0-9]{3})(\\s(JJ))?(\\s(YY))?$",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "/(\\d\\d?)/(?:\\s*[a-z]){2}\\2/i",
        "passed": false
    },
    {
        "id": 1654,
        "completion": "([0-9][a-z][a-z]{1,2})/(\\w{1,2})/(\\d{4})",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "var validEmail = /^(?![.\\W]*$)(?:[\\w.,-]+(?:\\.[\\w.,-]+){1,})$/gm;",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "[^,]{5,100}@[a-zA-z0-9.!#$%&'*+/=?^_`{|}~-]+",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "/^[\\w\\d\\s,]+@([\\w\\d]+(?:\\.[\\w\\d]+)+)$/I did not do a script for you. I have given you some suggestions to help you get started.",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "@[A-Za-z0-9._-]*@",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "[A-Z0-9-._%+^=\\\\s]+,",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "[^\\w,]+@[^\\w,]+[^\\w,]*",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "public static void Main(){    Regex regex = new Regex(\"^[a-zA-Z0-9, ]+$\", RegexOptions.Compiled);    string[] emailArray = { \"jenni,.name@name",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "[a-zA-Z0-9 -_\\.]+",
        "passed": false
    },
    {
        "id": 1656,
        "completion": "/^[\\w\\.-]+@[\\w\\.-]+\\.com$/s",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+-=\\[\\]\\{\\}\\|])(?=.",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[A-Za-z\\d]{8,}$",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "The password should be eight characters long, contain at least one uppercase letter, one lowercase letter and one digit. Allowed special characters are underscore, `,!\u00a3$%^&*.()/,;?<>,[]}|{\\\\:`.",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "'^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[^\\w]).{8,}$'",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[^A-Za-z0-9 ])",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[A-Za-z\\d]{8,}$",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "(?=.*[a-z].*)(?=.*[A-Z].*)(?=.*\\d.*)[A-Za-z\\d$]{8,}",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "^(?=.*[a-z].*)(?=.*[A-Z].*)(?=.*\\d.+)(?=.*[!@#$%^&*()_+-=\\[\\]].*).{8,",
        "passed": false
    },
    {
        "id": 1657,
        "completion": "(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "https://regex101.com/r/6k4yX5/27",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "'<\\{(.*?)\\}' This will find a RegEx without any capture groups specified.  This regex assumes there will only ever be a key-value pair separated by curly braces.  So as an example:  '<{key=\"value\">' This Regex will return 'value'. I hope this exercise helped give you a",
        "passed": false
    },
    {
        "id": 1658,
        "completion": ".*",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "_",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "`^\\[body\\](\\s)+?\\[/body\\]$`",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "(P(<div(tag[^>]+?)>)(.+?)(<\\/div>)",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "^\\/?(?P<tag_id>\\d+).*$",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "",
        "passed": false
    },
    {
        "id": 1658,
        "completion": "```pythonfrom datetime import datetimenow = datetime.utcnow()html = f'<body time=\"{now}\"><html><!-- body tag --></html></body></html></html>'print(re.findall('<body>(.*?)</body>', html))```",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:  [a-zA-Z0",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:RegExp(\"\\w+\");I",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:^[a-z][a-z",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:^(?=.*[A-Z",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer: [A-Za-z0-9",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:((?<![A-Za",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer: A-A9-A9-_",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:I was asked this by my client for example",
        "passed": false
    },
    {
        "id": 1660,
        "completion": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _I was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.Generate a RegEx for this description. Answer:([Aa-z]{1}[",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "\\s*",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "^\\s*$Q:",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "\\s*",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "\\s{2,}",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "^\\\\s*$",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "\\s+",
        "passed": true
    },
    {
        "id": 1662,
        "completion": "^[a-zA-Z][0-9a-zA-Z-\\s]*$Examples: abc, a b c, ab cd a bThe expression above matches string abc, a b c, and ab cd but excludes abd which is a string composed of a space. It also allows for strings that also contain single spaces (such as ab, a",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "^\\s{0,59}$",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "\\S",
        "passed": false
    },
    {
        "id": 1662,
        "completion": "\\s+",
        "passed": true
    },
    {
        "id": 1663,
        "completion": "^\\d*$",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "^([1-9]\\d*[.](180|181|182|189|190|191|192|193|194|195|196|197|198|199|2))|(\\d+)|$",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "\\d^*?([.-]?\\d)\\d^*",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "^(?:[0-9]),(?:[0-9]|\\.[0-9]){18,19}$",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "(?:(.+?)%(.+)\\s\\d+),(.+?)(?<=%)\\d+",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "^[0-9]+(.[0-9]+)$",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "/^(\\d+).*?\\/(\\d+)$/",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "^(?=.{9})(\\d{1,18}\\.\\d+)([+-]\\d+)$",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "(?<!%)\\d{18,1}, (?<!%)\\d+",
        "passed": false
    },
    {
        "id": 1663,
        "completion": "(Regex only)",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "([0-6]+ \\d+H?)",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "r\"^[A-Z]{2}[0-9]{7}\"",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "l[i]===\"[Gm][E][N][D]\"? l[i]===\"[Gm][E][N][H]\"?",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "license_plate_regex = r\"^(1[-2-9]|2[0-3]|3[0-7])[- ]\\d{7}$\"",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "\\b[0-9]{4}-\\d{2}-\\d{4}[Hh]? [0-9]{3}[Mm]\\b",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "*(\\d*H\\d{2})+(.*)",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "(\\d{4})-(H?\\d{3})* ([a-z]\\d*)?",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "(H.*)[H-].*/i",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "[00][0-9][0-9][0-9][0-9]H[0-9][0-9][0-9].*",
        "passed": false
    },
    {
        "id": 1665,
        "completion": "\\b[0-9]+(\\(H|T|D)(\\)))$",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "[Big|Small|Medium] letter.",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "[small]",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "A-1-10 A-1-100a-1-10",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "small",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "[The size of the letters]",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "Big/small",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "a-A, b-B, e-E, i-I, t-T, u-U, u-U, l-L, s-S, r-R, c-C, s-S",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "A(1-8|9{1}[0])|B(1-8[0-9]|9){1}[0]",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "Large; Small.2) Large A letterGenerate a RegEx for the descriptions of big and small letters, A or O, R or L.Answer: Large A, big O (large), small A (small).3) Small and large A letterGenerate a RegEx for a small letter and a large letter, all A, all O, all R and all L. Answer: Small letter a, big letter Aa.4) Abc and defg and hi Answer: [",
        "passed": false
    },
    {
        "id": 1668,
        "completion": "[\\u0040-\\u0039]{3}  - This matches 3 of any uppercase letter.",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "(^[A-Z]\\\\w*)([A-Z]\\\\w*\\\\s?[^A-Z]*)$        RegEx 1:     ^[A-Z]    Start of Name               ([A-Z]\\\\w*)([A-Z]\\\\w*\\\\s?[^A-Z]",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "[a-z][a-z][A-Z]\\w",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "/^(?=[A-Z]{3} )(?=[A-Z][a-z] )[A-Z]?\\w*$/gm",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "\\b(?<!\\\\w)(Name)[A-Z]{2,}(?<![A-Z])(?:[a-zA-Z]\\\\w*)?\\b(?!\\w)",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "\\\\w+(?:\\\\.\\\\w+)+ would work.",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "[A-Z][a-z][a-z]\\s",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "[^A-Za-z0-9\\-_]   # allow only capital letters and the following: alphanumeric (underscore) and dash^\\S+\\s*\\S+       # allow any arbitrary number of alphabetical characters, followed by any number of spaces$               # terminate with a non-alphabetical",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "const validNameRegex = /^[A-Z][a-z]{1,29}\\.[A-Za-z0-9]*$/; ValidNames = [    \"Adam Smith\",    \"John Doe\",    \"Smith Smith\",    \"John doe\"];invalidNames",
        "passed": false
    },
    {
        "id": 1683,
        "completion": "",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "^(?:\\s*)[0-9]{4}\\-(?:\\d{2))$2. Using the same regex pattern, what is a valid date and time for a European date range like '05-06-2023 - 06-07-2023'?Answer: '05-06-2023' and '06-07-2023' are both valid dates within the range.",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "time=\"(23:59|00:00)\";",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "[0-9:]",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "/((\\d+):(\\d+))\\.((\\w+)\\).*\\.((\\w+)\\).*/",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "xPath = '//time[@pattern=\"(.*)\"]/@value'",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "([0-2]\\d|3[0-1])(:[0-5]\\d)",
        "passed": false
    },
    {
        "id": 1690,
        "completion": "x\\s*(?P<hour>\\d)\\s*:\\s*(?P<minute>\\d)\\s*",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "(?:([0-9]{4})-(?:1[0-2])-(?:1[0-2]|3[01])-(?:[0-9]{4}))|([0-9]{4})-(?:[0",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "[00][0-9][-]?[0-9][0-9]?[-]?[0-9][0-9]?[-]??[0-9][0]?[0-9]?[-]?",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "[\\-]%Y-%m-%d[T\\h]%H:%M:%S[\\.ssss\\[zZ]Z",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "/^ \\[?-?-?-?- \\d{4}-\\d{2}-\\d{2}T? :?-?:? \\] \\[?-?- \\d{2}-\\d{2}:\\",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "(\\d\\d)-(\\d\\d)-(\\d\\d)-(\\d\\d)-(\\d\\d)-(\\d\\d)-([T|Tt|Z]H:[\\d\\d]\\d[AP][ST][FT][OM]",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "/[0-9]{0,4}-[0,3][0-9]{2}-(0-3)[0-9]{2}[0-9]{2}T00:00:00-0500/([+|-",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "-\\d{1,2}[-/]\\d{1,2}[-/]\\d{1,2}\\s\\d{1,2}[:|:]\\d{2,4}[SSS]",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "^[+-]\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d[\\s]+",
        "passed": false
    },
    {
        "id": 1693,
        "completion": "",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "(^\\$[\\d\\.][\\d\\.]+[0-9]$)\\s*(-)?\\d+(\\.\\d+)$",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "^(?:\\d{1,2}\\.)?\\d{1,2}[0-9]{1,3}(?:\\d[0-9]+){3}$",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "0[\\d.,]+0",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "^\\d{1,3}[\\.,]\\d{1,3}$",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "/^(25.0)?$/.",
        "passed": false
    },
    {
        "id": 1696,
        "completion": ".{0,11}[0-9.]{0,2}\\s0{0,1}",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "\\b0.0|0.25",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "([0\u20135]\\d{0,2})",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "^\\d{1,3}.\\d{1}",
        "passed": false
    },
    {
        "id": 1696,
        "completion": "0-9, 0-9, 0-9]",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "(?i)(^(?!\\s*\\s*$)(\\w+\\W*\\w+)(?!_*$)(?:\\S+\\S*$|\\s+\\S+\\s+\\S+)$)",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[\\w\\.@-]{8,}$/",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "const regex = /^(?=.*\\w+)(?=.*\\d)(?=.*[@.-])(?=.{11,})\\S+$|^(?=.*\\w+)(?=.*[@.-])(",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "[a-zA-Z\\w_]*",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "(I use a RegEx and a custom regex that replaces the allowed_chars with a-zA-Z[a-zA-Z_]*and remove the double spaces only, at last)",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "/^(?=.*?[a-zA-Z])(?=.*?\\w)\\S+$/g",
        "passed": false
    },
    {
        "id": 1697,
        "completion": "[A-Za-z_ ]{2,}",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "(\\+1[1-9]\\d{2})|(00[1-9]\\d{2})|([0-8]\\d{3})-([0-9]{3})|([0-9]{3})",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "[[0-9]\\s\\s*(?:\\(?[555]\\d{2}\\)\\s?)?[\\-0-9]+?\\s([0-9]{3})?[-.0-9]*[1][-.0-9]*](:[0-9]{3",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "^\\+[1-9][0-9]*\\s([1-9][0-9]*|[0-9])\\s?(\\(800\\))?[-0-9]{10}$",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "^\\s*(0[\\d\\s]{1,6}|1[\\d\\s]{1,5}|2[\\d\\s]{1,4}|3[\\d\\s]{1,3})\\s*\\(?[0-9][\\s]",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "[^0-9]|[^0-9]$|[^0-9]\\d[^0-9] | [^0-9]{3}[^0-9]|\\d{3}[^0-9]|\\d[^0-9]{4}",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "\"^\\s*(0?1\\([0-9]\\)/[0-9][0-9] \\)\\s*+0?$\"",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "`[0-9]{1}\\\\-[0-9]{3}\\\\ [0-9]{3}-[0-9]{3}-3[0-9]{3}`",
        "passed": false
    },
    {
        "id": 1698,
        "completion": "US\\s+\\((0[1-9]|1[0-9]\\d|2[0-4][0-9]|22)[0-9\\-\\s]*PBX\\s*\\(\\d{3}\\)\\s*[0-9\\-\\s]*PBX\\s",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "^[0-9]{0,1}(,|\\.?|\\)(0|[1-9])?$",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "\\B1a\\s\\d{4}\\s=\\s\\d{4}\\B",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "\\d{3}(\\.,\\d{3})?",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "(?<=^|[,\\.])([1-9]{3} \\d*(?:-[0-9]{3}+)?)(\\.[0-9]{3})?$Usage:    Matches: 123.45, 1234, 1234.50    Rejects: abc12345, 12, 3..",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "^([0-9]{1,2})[.,]([13579]{3}|{1}\\d)\\1([.,2345,6789]|{1}\\d)\\1([.,]{3})?$In this example, we have used RegEx to recognize a valid number, with one or two digit, at the start, separated with commas [.,]. The comma is the most",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "\\b(1000|1000\\.\\d|1[0-3]\\d|1\\.\\d\\d|2[0-4]\\d|2\\.\\d\\d\\d|3[0-1]\\d|3\\.\\d\\d\\d).*Example:  Input:  \"abc.45\"         Output: True",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "(?:\\d+,\\d+)\\.(00\\d{1,2})$",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "^\\d((?:\\d*\\,\\d*)(?:\\.\\d+)?|\\.(?:\\.\\d{3})\\d|\\d{4})\\b",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "",
        "passed": false
    },
    {
        "id": 1704,
        "completion": "\\d{1,7},\\d{1,1}",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "[0-9A-F]?[0-9A-F]?[0-9A-F]?[0-9A-F]?\"",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "[^a-zA-Z\\s]+",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "/^[A-Z]{2}\\s[A-Z1-9]{2}\\s[A-Z]{2}$\\.",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "^(?![\\d\\s]*_)([A-Z]{2}\\d{2})([0-9\\s]*)$",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "\"^([A-Z]{7} )(?!(|\\1|[^0-9\\s]))|(?!\\1)\\1|([\\d.\\s]",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "(?i)(?![a-z])[0-9]{5}-[a-z]{2} [0-9]{2}-[a-z]{2}",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "https://regex101.com/r/j2a2T9/1",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "[I-0-9][0-9 - ]?[0-9]|[I-0-9][0-9 0-9-]?[0-9]|[",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "^(?P<prefix>\\w{1,2}\\d{1,2})\\ /(?P<plate>\\d{1,2})\\$/.",
        "passed": false
    },
    {
        "id": 1706,
        "completion": "(?(^\\s)\\w{2}(?:\\s\\w{2})?$)[^ ]+",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "(?<=\\s+|\\bst)\\s+\\d\\d\\d\\s*--\\s+\\d\\d\\d\\s*-\\s+\\d\\d\\d\\s*,?(?<=\\s+|\\byear)\\d\\d\\d\\d,?(?<=\\s|$)",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "(?=.{3}-)[0-9]{1,2}-(0[1-9]|1[0-2])-(0[1-9]| [9][0-9]|[1-9][0-9])$",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "```^(03)(0)$|^(04)(1)$|^(05)(2)$|^(06)(0)$|^(07)(1)$|^(08)(2)$|^(09)(0)$|^(10)(1)$|^(11)(2)$|^(12)(0)$```",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "date = {YYYY-MM-DD}",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "(1)- [2]: (2)\\d\\d\\d [0-1]\\d\\d[:][0-9]\\d[:]. The above RE will give results that start with day, month, and year, optionally followed by hours and minutes.3. Write a regular expression that matches IP addresses in the format 192.168.0.[0-9]{1,3}. The regex should also ignore the port and",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "```pythondate_regex = \"(?P<day>\\d{1,2}[- /.]\\d{1,2}[- /.]\\d{4})\"```",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "DATE(?P<date>\\d{4}-\\d{2}-\\d{2})",
        "passed": false
    },
    {
        "id": 1709,
        "completion": "```pythondate_format = '[0-9]{4}-[0-9]{2}-[0-9]{2}'# '[01]..[12].'# '...[-23][-9]',# '[0-2][0-9][0-9][0-9][0-9]',# '[0-3][01][0-9",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1715,
        "completion": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62",
        "passed": false
    },
    {
        "id": 1716,
        "completion": "[a-zA-Z0-9.-]{0,3}\\.\\S+",
        "passed": false
    },
    {
        "id": 1716,
        "completion": ".+\\.[.]{1,3}$",
        "passed": false
    },
    {
        "id": 1716,
        "completion": ".{0,3}www",
        "passed": false
    },
    {
        "id": 1716,
        "completion": "Regex: (^(?=.{1,3}\\.$)(?=.*\\.$)(?![a-zA-Z0-9-]*\\.\\.).+)",
        "passed": false
    },
    {
        "id": 1716,
        "completion": "[a-zA-Z]\\w{1,3}\\.\\w{1,3}\\.\\w{1,3}",
        "passed": false
    },
    {
        "id": 1716,
        "completion": "/[a-z].[a-z]\\.[a-zA-Z]/ and/or /\\.([a-z])[a-z]/",
        "passed": false
    },
    {
        "id": 1716,
        "completion": "(\\w+\\.){2,3}\\.",
        "passed": false
    },
    {
        "id": 1716,
        "completion": ".\\w*\\..*",
        "passed": false
    },
    {
        "id": 1716,
        "completion": "^[A-z0-9](\\.[A-z0-9]{2,3})$",
        "passed": false
    },
    {
        "id": 1716,
        "completion": ".(?=.*[a-z]+$)(?=.*[A-Z]+)[a-zA-Z0-9.-]+\\.[a-zA-Z][a-zA-Z0-9\\-_]*        3. Write a regex for validating email addresses. Email addresses should start with a period, then be between 1 and 3 characters long, and should end with exactly one",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "^(?P<tags>[A-Z][A-Z0-9-_]*)(\\ <\\?)(?P<title>.*)[^$]$",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "\\d{1,4}(\\.\\d{1,2})?",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "^(\\[[^\\(]+\\])+$|^\\/(\\[^\\>]+\\])+$')",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "^([ ]+[\\#\\d\\.,]+)$Exercise 4: Create a regular expression that matches any IP address in the format XXX.XXX.XXX.XXX. Return a list of matched IP addresses. Answer: \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}Exercise 5: Create a regular expression that matches any URL with a path or query string. Return a list of matched URLs",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "(?P<description>(.+))-?(?P<version>[\\d]+\\.[\\d]+)",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "r\"([[:alpha:]])(?:[^a-zA-z\\s()]+)+([^a-zA-Z\\s()]+)((?[^a-zA-Z\\s()]|$))\"",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "{    \"x\": \"[a-zA-Z][0-9]*[/\\.]*[a-zA-Z]\",    \"x/\": \"\\/(?P<tag>[^/]+)\\/\",}",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "[#a-zA-Z0-9_]",
        "passed": false
    },
    {
        "id": 1723,
        "completion": "(.*)\\.",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "^(?:(?P<id>\\w+)\\W*\\s*)?(?P<title>\\S+).*$ The $ at the end tells the regex engine to match at the end of the line. The?P<> syntax helps us catch information contained in named capture groups, which are returned in later portions of the.*$ match.",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "(#1) ([^,]+), ([^,]+), ([^#])\\/? ($3)",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "A = 1-3 pB",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "^[0-9]{4}-[0-9]{4}-[0-9]{2}\\ \\\\d{4}-\\d{3}-\\d{2}-\\d{2}$",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "'regex: mykeyword'",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "#\\Q[a-zA-Z0-9\\.\\_\\-\\:]+\\Q[a-zA-Z0-9+\\*\\&\\_\\=\\(\\)]*$#",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "\"p\\d+,c\\d+,m\\d+,g\\d+,s\\d+$\"",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "?(?P<key>[^: ]+):\\s([^: ]+)",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
        "passed": false
    },
    {
        "id": 1726,
        "completion": "/([0-9]{3})C[3-9]{3}\\.\\w+$",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: \\d+,?\\d*",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: ^(0|[1-9]\\d\\.)?{0,3}[1-9]$",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: (^-?(0|([1-9][0-9]*)\\.)0+\\.[0-9]{2}$|[1-9])$",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: re.compile(r'^\\d+(?:\\.\\d{1,2})?$/' )",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: (.{,3})(\\d+(,\\d{3})?)\\s",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: ``` Pythonnum_regex = '^([-0-9]+(,([-0-9]+)?)?)?\\\\.([0-9]{2})?\\\\.([0-9]{3})$'```",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: #(?:\\d+(,\\d+)?|\\d+(\\.)\\d+)$",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: +3,000.00",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: ^[a-zA-Z0-9.-]*$",
        "passed": false
    },
    {
        "id": 1736,
        "completion": "matches numeric value with optional +/-, optional decimal point, and optional commasGenerate a RegEx for this description. Answer: (([-+]).+)$",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "#\\n(?:\\s*#+\\s*)+# Explanation: (?:\\s*#+\\s*)+ starts with any number of whitespaces or # spaces that followed by 1 or more #",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "[_\\w\\s]*|(?<=\\s)\\w|(?=\\s)",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "(?<=^ *).*(?<!\\*\\*)(#.*)?",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "^ # single-line comment.*$",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "RegEx for capturing comments (^#.*$)",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "re.compile(\"#(.*?)$\")",
        "passed": false
    },
    {
        "id": 1739,
        "completion": "# single line of code",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "/[^a-z]+[a-z]/i",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "var s1 = @\"this is string #1.\";var s2 = @\"this is string #2.\";",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "new System.Text.RegularExpressions.Regex(@\"\\d+\");",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "(?i)(?<=^|[\\W_])[\\w\\.]*",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "r\"[-A-Za-z\\ \\\\/\\_\\$\\:,.!?&\\s\\(\\)\\*\\#\\+]\".",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "[\\(]\\w[\\)|]\\w[\\)]\\S",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "You cannot create a valid RegEx that searches for \"a string literal.\"",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "(.*)",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "(?i)(    [a-z]+(?::[0-9]+)? |     # match a standard English colon    [A-Za-z]+ |    (?<=[a-z])[A-Za-z0-9]+)",
        "passed": false
    },
    {
        "id": 1740,
        "completion": "\\w|\\d",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "[A-Za-z]",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "([A-Za-z])",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "(?=[A-Z]*[a-z])",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|f|g|h",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "^([A-Z]|[a-z])$",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "Upper-case ASCII letters.",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "^[A-Z][a-z]*$ (One upper-case ASCII Letter.Any number of lower-case or upper-case letters)",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "^[A-Z][a-z]*$",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "A-Z. Generates ^[A-Z]*$",
        "passed": false
    },
    {
        "id": 1742,
        "completion": "[A-Za-z0-9]",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "(\\d\\d)-(\\d\\d)-(\\d[0-9])",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "part[0]",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "1.3.2 (with any additional text, number of digits and/or alphanumeric characters allowed)",
        "passed": true
    },
    {
        "id": 1744,
        "completion": "^r{p-3:[a-d]{3}}$",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "(\\d{1,3})\\s(\\d{1,3})\\d*",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "(^(?=\\d(?:\\.\\d+){1}$)^)(?=\\d{%\\s(\\d){2,3}%}$)^)(?=\\d{1,2}$)\\s(?=\\w+$)",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "(?<!\\.)0*(?<=\\.)\\d{2}",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "1.1.1 (only the main part)4 part Version Numbers  #(the rest can come after) (not a fixed value!)",
        "passed": true
    },
    {
        "id": 1744,
        "completion": "(?:Part|Unit)\\s+([0-9*]+)",
        "passed": false
    },
    {
        "id": 1744,
        "completion": "/^(?P<name>...)%3D(?P<version>.+)$/",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "/(0|[1-9]|[1-2][0-9])\\/(0|[1-9]|[1-2][0-9])(0|[1-9]|[1-2][0-9]|1[0-2]|",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "(?!\\d+)   \\d{2}            # Year   (?:-?\\d{2})?     # Month   (?:\\d{3}-)?       # Day   (?:                     # Hour (00..23) (optional)      [1",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "^(0[1-9]|1[0-2])\\/[0-9]{1,2}\\/([0-9]{4})[0-2][0-9]$",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "(19|20\\d\\d|21|22|23|0|1|2)\\d\\d\\dYour regex here.",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "^((0[1-9]|1[012])\\/)?(1[0-2]|0[1-9])\\/(3[01]|20[1-9]|19)((2[0-3]))|(3[01]|20[1",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "[0-9]{2}\\.[0-9]{2}\\.[0-9]{4}(?::[0-9]+)?\"",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "\\w{1,2}\\d{1,2}\\d{4}\\d{2}([1-9][0-9]|[0-3])\\d\\d",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "\"^(19|20)\\d{2}(-?\\d{1,2})?[a-zA-Z.]?\"",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "^(0|1)?[1-9]\\d{0,2}(st|nd|rd|th)?$",
        "passed": false
    },
    {
        "id": 1751,
        "completion": "\\d{1,4}\\/\\d{1,2}\\/\\d{4}|\\d{1,2}[0-1]\\d?[0-9]:[0-5]\\d:[0-5]\\dThere are 8 test cases.",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "To validate if server is valid you can use the pattern `^[A-Za-z0-9\\-\\.]+$`. For port, you can make use of the pattern `^\\d+$`.",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "(.*)\\. (.*)",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "Valid URL Pattern is http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+\\.[^\\s()<>]+",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "The regex is \"^https?://.*?(:443)?(?=(5[1-9][0-9]|1[0-9]2|2[01]\\d|25[0-5])\\.)(?:[-\\w.]+\\.)+[a-zA-Z0-9](\\.[a-zA-Z0-9]{1,3})$",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "`re.match(r\"^127.0.0.1:((1,5|1,5\\d|2,7)[0-9]|192|208|240)$.*\\d{1,5}$\")`",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "The example description is a regular expresison of a host name and a port number, both following the standard format: 'hostname://port' where the hostname can be anything, except a port number.",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "pattern = r'^[0-9](\\.[0-9]+)*$'",
        "passed": false
    },
    {
        "id": 1756,
        "completion": "",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "([0-9.]+)",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "This will return true if and only if all numbers found by search-and-replace \"^(\\d+)(\\.[0-9]*)?$\"2. In which two methods to add up even numbers in a string, if the string contains both numbers, separated by a symbol, (e.g., 2,3,6,7), the two methods to add even numbers in a string.  Solution: The two methods are",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "The pattern may consist of either one or two real numbers, in which:- the first number is between 0 and 1- the second number is one or more hexadecimal digits, optionally enclosed in bracketsAn example Regex for positive and nonzero real numbers includes: [0-1e].[0-9a-f]+, [0-9a-9]+.",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "^\\d*\\.\\d$",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "^[0-9]*[1-9]?(\\\\.[1-9]?\\\\d*)?$",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "^(?=.*[1-9][0-9][0-9])?([0-9][1-9]|1[012])\\.([0-9][0-9])$",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "/[-+]?[0-9]*\\.?[0-9]+(\\.[0-9]*)?|[-+]?[0-9]*/",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "\\d*\\.?\\d*|[-+]?[0-9]*\\.?[0-9]+",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "(?=.*[1-9]\\.)(?=.*[0-9]*[\\,]|\\.)(?=(?<![\\.])([\\,]\\d)|(?<![\\.\\,]))[0-9:]+$",
        "passed": false
    },
    {
        "id": 1762,
        "completion": "(?:\\d*\\.?\\d*[eE][+-]?\\d*)|\\d|0",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "(0*)([1-9][0-9]|1[0-2])(\\2[0-9]{3})* So the regular expression can be written as:^[1-9][0-9]|1[0-2]?\\d{3}",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "^\\((?:\\d+(?:,\\d+)*){0,99}\\).*",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "^(\\d+(\\.\\d+)?|\\.\\d+)\\d*$",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "var pattern = new Regex(\"+[0-9]*$\");",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "^[0-9,]*$Demo: http://jsfiddle.net/XlNUJ/6/",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "((\\d+) + )?((\\d+)))",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "^[\\d\\.]+$",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "-?[1-9][0-9]*?|0*",
        "passed": false
    },
    {
        "id": 1763,
        "completion": "String regex = \"([-+][0-9]*)?(?:\\.[0-9]+)?\";",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "^((20[0-2]|1[0-9]|1[012])-(0[1-9]|1[012])-(1[0-9]|2[0-9]))\\.[0-9]{2}$",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "[1-9][0-9])[0-4]|([1-9][0-9])[1-9]|([0-9][1-9])[0-9]|([1-2][0-9])[0-9]|([12][0",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "/^(03-04|19/20|20/21|21/22|22/23|23/24|24/25|25/26|26/27|27/28|28/29|29/30|31)/(\\d\\d[ -./]",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "^[13579][0-9]{3}-0$",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "date.toLocaleDateString(undefined, { week: 1, month: 2, year: 4 })) && ((year %4==0) || (year % 100!=0 && year % 400==0))",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "var date = new Date(2019, 02, 28);var dayOfMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];var day = [\"01\",\"02\",\"03\"];var month = [\"Jan\",\"",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "(?:\\d{1,2}(?:\\s+\\d{1,2}(?:,\\d{2})?)?)\\s+(?:\\d{4}(?:\\s+\\d{2})?)",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "^[0-9]{0,2}-?[0-9]{0,2}-?[0-9]{4}$",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "var regex = new RegExp(/(^\\d\\s\\d-\\s\\d-\\d\\s\\d\\d)|(^\\d\\s\\d-\\s\\d-\\d\\s\\d\\s-\\d\\s\\d$)|(^",
        "passed": false
    },
    {
        "id": 1776,
        "completion": "Expression:.*/{3}-{1}-{1}-{4}\\d{2}/Code (explanation below the code):<body>    <div>        <h1>Flexible Date Format</h1>        <",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "import restring = \"The date is 2022-05-11 and the date is not valid\"pattern = \"\\[20\\d-\\d-\\d\\] and is only valid for the years between1900 - 1999[\\.\\ ]\\w+\"print(re.findall(pattern",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "[(\\d\\d)-(0[1-9]|1[012])-(0[1-9]|[12][0-9])]` This will not be able to work for cases such as a date in the format of YYYY-MM-DD where there are multiple options for numbers in",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "\\d{2}-\\d{2}-\\d{4} and \\d{1,2}-\\d{1,2}-\\d{4}",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "import restring1 = \"You are 25 years old!\"regex = re.compile(r'\\b\\d{1,2}-[\\d-]+-\\d{4}\\b')if not regex.fullmatch(string1):    print('The date format provided",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "/(\\d{1,2})-(\\d{1,2})-(\\d{4}|\\d{2}-\\d{2})/",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "r'((01|12|23)\\d|(02)\\d|(03)\\d)\\d-\\d-\\d{4}'",
        "passed": false
    },
    {
        "id": 1777,
        "completion": "",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "/^\\d{4}-\\d{3}[\\s\\d-]?(\\d{3})\\d*$/",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "(\\b)(\\d{3}[ -]?){3}\\d{4}",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "\\d{3}(?:[-\\s]?\\d{3}){5,11}",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "[1]?[8-9]\\d{3}[-]?[8-9]\\d{3}",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "^\\d{3}[ -]?\\d{3}[ -]?\\d{4}$",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "^[6]\\d{5}\\d{2}[\\s\\d]*$5. Write a Python script that generates a RegEx to match email addresses with a suffix of '.edu' or '.org' or '.net'. Answer: [^\\W_]*@[a-zA-Z0-9_\\-\\.]+\\.(",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "(^0[8-9][0-9].(0|[1-9])[0-9]{3}$)|^3[1-9]{2}[0-9]{4}$|^\\(?(?:\\d{3}\\)?\\)?[\\-\\.\\,\\s]0[8-9]\\d{",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "[^800-900-]\\d{6}",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "\\d{3}-\\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 1780,
        "completion": "(\\(\\d{3}\\)\\s-)?([0-9]{4})$",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "/[^\\\\-\\\\_\\\\d]*.(Note, I use this to prevent the pattern /userdir/subdir/foo/ file from matching, and not foo/.)Then you could use this to convert the",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "^(.*\\/)?([a-zA-Z0-9_-\\+\\*\\/\\?]+)\\/$.",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "[^/]*/",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "/^[a-z0-9-]+(?::[a-z0-9-]+)*$",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "/([^\\x<>]+)[_.-]",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "\\w+[\\s_\\-]\\w+-[\\s_\\-]\\w+-",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "/([A-Za-z0-9_\\-]+(.)(.))/",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "^[A-Z0-9_.-]+[/\\\\_.-]/[A-Z0-9_.-]+",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "^[a-zA-Z0-9_-]*(-[a-zA-Z0-9_-]*)",
        "passed": false
    },
    {
        "id": 1785,
        "completion": "^\\/?[^_\\-\\.]*\\/",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "^\\w+$",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "/^[^ ]+[a-zA-Z0-9 ]+$/",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "\\b[A-Za-z][a-z]+\\s+[,.!?]",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "^\\S+$",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "/^[a-zA-Z ]+(?:\\.+)?$/",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "[A-Z][a-zA-Z0-9 ]*",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "(?<=^|\\s|_)[a-zA-Z0-9]*(?= \\s|$|_).",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "(^(?=\\S\\s)(?:[a-zA-Z]+(?:\\s[a-zA-Z]+)+[a-zA-Z])$ )|((?=\\p{S})\\p{P}{1,3}.)|((?=\\p{S})\\p{P}{9,}.)",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "(^[\\w\\s]+$)",
        "passed": false
    },
    {
        "id": 1786,
        "completion": "(?<word>\\w+)(?=\\s)",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries (",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries.",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries for",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries to",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries of",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries and",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries.",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries of",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries of",
        "passed": false
    },
    {
        "id": 1793,
        "completion": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the.Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries for",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "^0*([01]\\d|[01-9]\\d|3[1-9])[-.]0*([01]\\d",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "([0-9]{3})([ -]?)[0-9]{3}|([0-9]{3})[. -",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "^(0[1-9]),\\s*(0[0-9]|1[0-9]{2})[ -](\\d",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "/^(\\+\\d{1,3}\\)?(\\d{3})(\\s\\d{3}$)/",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "(?!^| )(?:^|-|\\s)(1[789][0-9]){6}\\s((5[1-5]?)",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "^(?:\\d{1,3}[-\\s]?\\d{3}[-\\s]?\\d{4}[",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "([(]0?\\)?[-.])?[0-9]{3}[-.][0-9]{3}[-",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "(\\(?\\d{3}\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "((\\\\d{3})-)?\\\\s*((\\\\d{3})\\\\.)(\\\\d{4})",
        "passed": false
    },
    {
        "id": 1799,
        "completion": "/^\\(?([2-9]|1\\d{2})\\)?[1-9]{2}-$?([0-",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "(\\\\w|^)\\\\d{4}\\\\s(\\\\d{2}|\\\\d{3}) Here \\\\w|^ means an alphanumeric character or an underscore. The \\\\d{4} matches 4 digits. If the zip has 5-9 digits then a space is required before the final 4 digits, this is the fifth-to-last digit. The \\\\d{2}",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "[A-Z]{2,3}\\d{5,11}(-\\d?\\d{4})?",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "\\d{4}-\\d{2}-\\d{2} (OPTIONAL)",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "\\b((1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|7[0-9]|8[0-9]|9[0-9]|0[1-9]|[1-9])(\\.\\s){1,2}\\",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "The number should be 5 to 9 digits long.",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "#((\\(\\d\\(),(\\d\\s\\(),(\\d\\s\\()?(\\d\\s\\(),(\\d\\|)\\))?)?)?) For the numbers that need to be returned.The post office number is optional. Generate a RegEx for this description.Note: The numbers may not all contain the correct number of parentheses. For example the numbers 201 and 001 would have",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "/^\\d{5}\\-\\d\\d$/",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "(.{3})-?\\d{4}Example Code for Matching Zip Codesimport re",
        "passed": false
    },
    {
        "id": 1800,
        "completion": "\\d{2}\\-\\d\\d\\d\\d-?\\d{4}|\\d{4}\\-?\\d\\d\\d$",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "[\\s\\S0-9](\\d[\\s\\S0-9]{11})[\\s\\S0-9]",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "This regex is as follows. \\b(?P<year>\\d\\d\\d)(-?)(?P<month>\\d\\d)(-?)(?P<day>\\d\\d) [ap]m(?P<hour>\\d\\d)\\:(?P<minute>\\d\\d)\\.\\d\\d\\d\\b",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "^\\d\\d:\\d\\d:\\d\\d [A-Za-z]+$",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "'^(\\d|\\d\\d) hours (?:(AM|PM) \\d) (:?(?:\\d\\d\\d?)\\d )\\.?(\\d{1,2})\\/(\\d{4})$'",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "^\\d{4}-\\d{2}-\\d{2}$",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "\\b(\\(\\d\\d\\d\\d,\\d\\d\\d,\\d\\d\\d\\d)\\))",
        "passed": false
    },
    {
        "id": 1803,
        "completion": ".*[0-9a-f]{3}:[0-9a-f]{3}[a-f]{3}.[0-9a-f]{12}",
        "passed": false
    },
    {
        "id": 1803,
        "completion": "/^(\\d{2})-(\\d{2})-(\\d{4})$/;",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "^([1-9][0-9]?)*[0-9][1-9][0-9][0-9][1-9]",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "(n)\\b(0|[1-9][0-9]*)?$",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "[0-100]",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "[0-100]\\\\d",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "\\d{1,100}.",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "0|[1-9]\\d*|100$",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "[0-9]{1,100}",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "0+[1-9] -0?[1-9]|[1-9][0-9a-d]",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "([0-9\\s]+)\\s.*([0-9\\s]+)",
        "passed": false
    },
    {
        "id": 1808,
        "completion": "(\\d\\d?|1[0-9]\\d|2[3-9]\\d|25[1-5])$",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "(?!^|_|,|\\.0+$)0$([,-])?[0123456789]\\.?[0123456789]*[,\\.\\?\\!\\$\\%\\^\\&\\(\\)\\/\\+\\-\\",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "^(\\+|-)(0\\.){0,2}([1-9]\\d{3}|3[1-9]\\d|1\\d{2}\\d|0)$",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "/(^\\d+\\.\\d{1,2}$)|^\\d{1,2}$,/",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "(^-?[0-9]+(?:(?:\\.[0-9]{1,2})?|(?:[0-9])))$",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "\\d{1,2}(?:\\.\\d{1,2})?(?:-)?\\d{0,2}",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "[^\\d,-]*",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "/(?<! -)\\d{1,3}(,\\d{3})*\\z/",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "^(?:[+-]?\\d+(?:\\d*\\.)?\\d\\d?[Ee][+-]?\\d+)$",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "/^[0-9(]*(,?[0-9]+)?)[.][0-9]*$/",
        "passed": false
    },
    {
        "id": 1810,
        "completion": "(?!\\d{2,})\\/(?:\\.\\d{0,2})?(?:\\,\\d\\d\\d{0,3})",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "import redef phone_number():\tregex = re.compile(r'(\\d{3})[-.]\\d{3}\\d{4}')\tphoneNoExample = 'Call me at 0612345678 at 890-765-4321.'     # The above phoneNo can appear\treplacementPair = ('\\s', \" \")\tprint(regex.sub(",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "[Phone number filter]/[Phone number replacement character]/([Phone number replacement character]*) (number)",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "[RegEx Pattern]",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "\\b[789]\\s[0-9]\\d{3}-\\d{2}\\d{4}\\b",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "(\\b[0-9]|[-][0-9]|[.])([0-9][0-9.]*)*/",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "^(\\d{3}-\\d{3}-\\d{4}|\\() \\d{3}\\s*\\d{3}\\s*-\\d{4})(?:\\s*[-()_\\d]+)*$",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "Use (^\\d{3}-){3}\\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "^[0-9]{3}[-.][0-9]{3}[-.][0-9]{4}$;",
        "passed": false
    },
    {
        "id": 1811,
        "completion": "/(^[^.]*|\\.{0,1}[^.]*.[^.]*$)/g",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "[^a-zA-Z0-9\\s\\/\\.]",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "(.|\\s)+",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "(.{1,100})(?!\\.|[^0-9\\s])",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "\\w\\s*",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "preg_quote('(\"This is a string with punctuation\")')",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "(?<!\\d)^\\d+(?![^A-Za-z\\s]*\\.)^\\d+$",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "@\"(?<=\\b.+?<![\\w,]{}\\b)\".",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "^(?!([a-zA-Z0-9_&-]).)*([a-zA-Z0-9_&-])=$",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "^\\s*((?:\\w(\\w){7,}\\w)\\+)?(\\*\\/)(\\w)\\*$$Description: A regex to match something like this.  *_*_*_*_**_*_*_*              ^ = Start of string*       *          *",
        "passed": false
    },
    {
        "id": 1813,
        "completion": "\\w+(?:[^\\w\\s]|_)+Explanation: \\w matches a (valid) word character, and then allows one or more 'non-word' characters or two or more hyphens before the next word character in the next regex match group.Explanation of the second regex:\\w",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "\\d{4}$",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "\\d{4}\\-\\d{2}\\-\\d{2}",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "(\\d{4})\\,(\\d{4})\\,(\\d{4})\\,(\\d{4})",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "`(?:0|[1-9])(?:[1-9]|1[012]){3}`",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "[0-9]{4}",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "^\\d{4}$",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "r\"\\b(?:\\d{4},){0,2}\\d{4}\\b\"",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "regEx = \"(\\d\\d\\d)\\,\".format(year)",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "^\\d{4}$",
        "passed": false
    },
    {
        "id": 1815,
        "completion": "\\d{4}Exercise 5:Suppose you are writing a function to convert a string of data consisting of a list of numbers separated by commas into a list of integers. Use list comprehension with the RegEx pattern you came up with in Exercise 4. Example: Input: '22,33,44,55' returns [22, 33, 44, 55]. Solution: ``",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "[0123456789]{2}/[012][3456789]{2}/[0-9]{4}The above code will have a date range (2000-08/01 to 2008-12/31).",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "(?P<Month>\\d/\\d/\\d+)-(?P<Day>\\d/\\d+)-(?P<Year>\\d\\d\\d\\d)$",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "^(02[0-6])(0[1-5]|1[012])[ \\/.-](\\d{4})/([01][0-9]|2[1-9])$Example:Jan 2002Mar 01 2008Apr 12 201210 Feb 2008Apr 11 200621 Aug 200819 May 2010",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "M/D/YYYY",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "[^M/dd/CCYY]([0-9][9]|[1-2][0-9])([0-9][0-9]|[3][0-9])/([0-9][0-9])/([0-9][0-9]|[1-2][0-9][0-9])[0123]/",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "/(^\\d{2})\\s*(0?)?(1-3)\\d{4}-?\\d{2}-?\\d{2}/",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "^(0[1-9]|1[0-2])(0[0-9]|[12][0-9])/([3][0-9][0-9])/2000[0-9][0-9]$The answer should contain the values month, date and year, you should take an array of these answers/matches then match the full string",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "(\\d{1,2}\\d{1,2})/(\\d{4})/(\\d{2})/(\\d{2}) - I am thinking this might work. It gives me the date number of the day. preg_match(\"/(\\\\d{1,2})/(\\\\d{1,2})/(\\\\d{2",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "[0-9]{4}-[0-9]{1,2}/[0-9]{1,2}[0-9]{1,4}/(\\d{4})",
        "passed": false
    },
    {
        "id": 1819,
        "completion": "2000/01/*/12/2003/*/2008/*/02/*/03*/2005",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "(00)000221918*/let reg = /^(00)000221918(\\s*\\d{\"1,2}\"|-?\\d{\"1,2}\"|\\s*\\d{\"1,4})\\s+\\d{\"1,2}\"\\s+\\d{\"1,2,\"}/gm;",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "Yymmdd-mm-yyyy{0,9}Generate a Regex which match valid date format MM-DD-CCYY{0,9}My query is, how can we take a user input ddmmyyyy and match the same in this above reqgex?",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "\\b(0[1-9]|1[012])-([3-9])([12][0-9])\\bThe result will be",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "^(\\d{1,1}|[1-9][0-9]|1[0-2])(\\/)?(\\d{1,2})(\\/)?(\\d+)?(?:-(\\d+)?)?(\\/)\\d{4}$",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "20|[0-3][0-9]|[1-2][0-9]",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "\\d{2}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "/^[0-9]{2}-[0-9]{2}-([0-9]{4})\\s([0-9]{1,2}):[0-9]{2}$/",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "01-04-2000|03-04-2000|04-04-2000|04-04-2000|04-04-2001|04-04-2001|04-04-2001|04-04-2002|04-04-2002|04-04-2002|04-04-2003|04-04-2003|04-04-2003|04-04-",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "[^-*][0-9][0-9][0-9]-(?P<year>[0-9]{2})[-](?P<month_range>[0-11]?[0-9]?[0-9])-((?P<day_range>[0-31]?[0-9])|[0-2]",
        "passed": false
    },
    {
        "id": 1820,
        "completion": "^([0-9]|[1-9][0-9])-(0|[1-7])\\d{4}-([1-9]|1[012])$Explained:^   # Begins at the start of the line([0-9]|[1-9][0-9])  # Matches a single digit-",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "This type checks that the supplied domain name follows the basic naming conventions of a domain name in text format.",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "//[a-zA-Z0-9]+(\\?[a-zA-Z0-9]+)+",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "/home/[a-z0-9-_/\\?\\=\\:\\;\\&\\]]+ http[s]?://(?:[a-z0-9-_/\\?\\=\\:\\;\\&\\]]+)([/",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "/^[a-z][a-z0-9-\\._]*$/",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "[^0-9a-z\\.]",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "/foo/bar/42.1 /foo/bar/42.2",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "/user([-a-z0-9_]+)",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "^(http|https):\\/\\/((?:[a-zA-Z0-9_-]+[a-zA-Z0-9_-]*)*\\.)?([wWrW]in\\.)?([wWrW]in?)",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "(?:^|[^-\\d])([-\\d ]+[^a-zA-Z-0-9:@.]+\\.html?$|[-\\d ]+[-\\d ]+[-\\d ]+",
        "passed": false
    },
    {
        "id": 1827,
        "completion": "((https)?:\\/\\/((?:www\\.)?((\\S+)\\.(com\\.)+)|(www\\.)?(www\\.)(?P<tld>[^]+))(\\.com)(\\w+))([^?=]*)?",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "[\\w\\.]+\\/{0,1}[a-zA-Z0-9\\-_\\s]+@[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,}",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "Regex = '^https?://([a-z0-9.-]+(?:\\.[a-z0-9]+)*:)?((\\/)?)([a-zA-Z0-9-=\\._?&\\]\\^~' \\               '?",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "/^[^\\s:/?#]?@[^\\s]+\\.[^\\s]/(?P<client>.*/)://(?P<server>.*)#?(?P<http>[^\\s]+)(?P<method>.*)(?P",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "^[a-zA-Z0-9-_.:/~]*$",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "import re#import urllib.parse",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "^    (?P<protocol>        http|ftp        https    )                                   # protocol    (?P<subdomain>        [a-z0-9.-]{0,63}    )                                   # domain name",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "/^([\\w:/]+)(?:\\?([^\\?\\,]+),)?$/",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "^(www\\.)?[a-z0-9]+\\.[^.]+$",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "/(?<Protocol>\\w+)-(?<Port>\\d)\\+/g  # Specify the protocol     (?<URL>     https?://    # / starts with https or http     [A-Za-z0-9_-",
        "passed": false
    },
    {
        "id": 1830,
        "completion": "((?P<protocol>\\s?\\w+?\\s?)?  # at the beginning  \\s?                   # some whitespaces  (    (                      # start 1st \"tuple\"      (?:                          # start with a comma and a",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "0-39|40|41|42|43|44|45|46|47|48|49|50",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "39(\\/[0-$9][-0-9]?)50|50[\\/0-9][-0-9]I tried it as follows,var reg = /\\A(38|39)\\/[0-9][-0-9]?|49(\\/[0-9][-0-9]?)50|50[\\/0-9][-0-9]?/;",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "[9,10]\\/9[0-9]+",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "40,49#5#Explanation: We generate a regular expression - \\d,$ to match any number but a string that ends with the letters. We must add [^0-9] to make sure we do not capture any substring that contain the digit.",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "\\b(40|49)\\b",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "^(40|49|50)\\.?$",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "(\\d{3}(?:-\\d{3})?[0-2]\\d) (\\d{2}) (\\d{3})",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "\\d{2}-\\d{2}-\\d{2}\\d{2}",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "^\\d{0,3}\\d{1,2}\\d{1,2}-(\\d{2,3}\\s){0,1}\\d{0,3}",
        "passed": false
    },
    {
        "id": 1834,
        "completion": "[39][0-9][19]%",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "rf<([a-zA-Z0-9\\-]+@[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,6})/",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "string = \"This is a < ># character!\";Regex pattern = \"Re[^>]*?\";Regex validator = new Regex(pattern, RegexOptions.IgnoreCase);Match match = validator.Match(string);",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "^(?:\\?|&)(?!\\&\\s+$)[a-z]+[A-Z]+(:|,|\\s)+[a-z0-9-]+[a-z]*$",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "(\\s+?\\d{1,255}(.*?)\\s+)",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "/^[$@#$%^&*()+=]{3}$.{3}[$@#$%^&*()+=]{3}$/g",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "return (^\\({[^;]*[;]\\})+$)",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "var regx = new RegExp(\"[^a-z\\s]\");",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "/(?![0-9])(?![\"\\'.]+$)[a-zA-Z0-9][a-zA-Z0-9_]*[a-zA-Z0-9\\._-]/giDescription: This expression also stops the characters <>/?&{};",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "new RegExp(\"[^<>/?&{}#]\", \"g\");",
        "passed": false
    },
    {
        "id": 1835,
        "completion": "new RegExp(client.value.search(/#/));",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "x = 0.15; percentage(x)",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "const percentagePointGenerate = ((value) => {    return new RegExp(`[^ ]*?([0-9]+.*?)/(m)`, 'g');})(value)const result = Array.from({length: 1}, () => {    return document.getElementById(pointGenerate(value))})",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "(^a^b^c) means a combination of \u201c^\u201d characters (at the start), \u201ca\u201d (one or more), \u201cb\u201d (one or more), \u201cc\u201d (one or more), followed by \u201c^a^b^c$\u201d which means the combination with the order of the characters as given above.",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "[{% load custom_tags %}][% tag_name:%d](.5%)Illustration:         Mary and John both adopted dogs from the animal shelter. Mary adopted a small terrier while John adopted a larger golden retriever. On a hot summer day, Mary and John take their dogs to the park. Mary's terrier, named Max, is panting and trying to find shade, while John's retriever, named Duke, seems to be enjoying the sun. Mary notices that",
        "passed": false
    },
    {
        "id": 1842,
        "completion": ".*\\s%[^|0-9]{2}\\.[^|0-9]*%[^|0-9]{2}",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "```python result = random.SystemRandom().randint(0, 100)decimal = random.SystemRandom().randint(0, 10)",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "\"^([0-9]{1,5}/[0-9]{1,3}/[0-9]{1,2})$\"\"0|[12][0-9]|[0-9][1-9]|3[0-6]\"",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "var pointGenerate = \"-\");        var percentage = %.2f\";",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "You need to first identify what text you need to match. In this case, I assume that you are matching any text between words that may include one or more digits(?=\\w*\\d), which will prevent any digits between words. To be as specific as possible, you can write :\\w++?, which matches any sequence of word characters followed by a digit.",
        "passed": false
    },
    {
        "id": 1842,
        "completion": "(15%)^((1+2)/100);$pointGenerate = \"12:00:00\";$pointTime = new DateTime($pointGenerate);$endTime = new DateTime($pointTime + relativedelta(months =+ 1));$hours1 = round( ($startTime->format(\"HOUR\") / 24) * 60 * 60, 2)$hours2 = round( ($endTime->format(\"HOUR\") / 24) * 60 * 60",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "ftp_https_pattern = /ftp(?:s)?://?(?:[A-Za-z0-9./-]+[:@?%])?(?=.*\\.html)Pattern Matching with ftp_https_pattern will match URLs starting with ftp, http or https. Let's test this pattern on this URL: https://www.example.com/ftp/subdir/file.html",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "ftp [strict]|http[s]?|https[s]?",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "ftp://\\\\/path/\\\\",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "ftp.|http.|https",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "[a-zA-z0-9-\\/\\.\\_\\-](ftp\\)?[a-zA-Z0-9-\\/\\.\\_\\-]",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "ftp://, https://, http",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "r'^([0-9]*\\.|[\\w\\-\\.]+)(\\.hls|\\.mp4).$'",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "```ftp:``` and ```http:``` and ```https:``` can also be included to exclude FTP, HTTP and HTTPS from the valid range of URLs.",
        "passed": false
    },
    {
        "id": 1848,
        "completion": "ftp => $ftphttp => $httphttps \u2192 $https",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "ATU[A-Z]+[0-9]{12}RegEx",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "ATU456Vat number for Finland for FinlandFormat isFx23445678Generate a RegEx for this description.Answer: Fx345Vat number for Sweden for SwedenFormat isSeV4635678Generate a RegEx for this descriptionAnswer: SeV4635",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "[ATU12345678].+I'll provide an example of how to execute this regex:var re = /ATU12345678.*/g;var text = \"This is ATU12345678 text.\";var match = re.exec(text);",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "(A)12A-567-78B-2334-5678-A",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "^[a-z0-9]{6}[a-z0-9]{6}$",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "ATU123-45-78",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "ATU123456789[A-Z0-9][^A-Z0-9]",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "(.*ATU)([0-9]{6})(.*)A number is generated with an ATU prefix for each location.Sample input: ATU12345678Sample output:ATU12345678",
        "passed": false
    },
    {
        "id": 1850,
        "completion": "((ATU)([12345678])+)",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "This can work: /([a-z]{4})[0-9]+[0-9]{9}[0-9]{5}(?=\\D|.$)/i",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "(?<![a-zA-Z]),|(?<![0-9])",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "^[A-Z0-9]{8}-[A-Z0-9]{12}[A-Z0-9]{8}(?:-[A-Z0-9]{12})?$",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "BG[123456789|_]10",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "^[0-9a-zA-Z]{12}$",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "BG(?:\\d{5})?(?:(?!\\d)(?=\\.(?!\\d{4}))(?:\\d{4})(?:\\d{4})(?:\\d{2})(?:\\d))|BG(?:(?!\\d)(?=\\.(?!\\d{4}))\\d{4})(?:\\d)(?:\\d{4})(?:\\d)(",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "The general format can change, so this answer does not provide the answer.",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "[BG]\\d{8}$BG1234567 - Group 0 starts\\d - Digit{8} - {8} times$ - End of string.",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "RegEx = ^bg(?P<year1>\\d\\d\\d)$|^bg(?P<year2>\\d\\d\\d\\d)$Doskureng = a+d+t+k+r+g+m$OiT = 0-9a-fA-F$",
        "passed": false
    },
    {
        "id": 1851,
        "completion": "(^|\\W)(\\d{1,6})((\\W|$)?)",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "The RegEx could look something like [01/12/2008|12/12/2008|2013-06-22|21,31,5|07,25|2020-05-12T00:00:00.0000Z].",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "^([0-9]{1,2}[\\/\\-]?[0-9]{1,2}[\\/\\-]?[0-9]{1,2}[\\/\\-]?)\\.([0-9]|[1-9][0-9]|1[0-9]{2})|",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "dddd-mm-yyyy or dd-mm-yyyy|mm|mmm|yyyy or dddy-mm-yyyy|mm?|mmm?|year",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "The correct RegEx should be (^\\d{10}\\.\\d+$|^\\d{4}\\-\\d{2}\\-\\d{2}\\s\\d{6}[:\\.\\s](\\d{1,2})(\\s\\d{1,2})?)",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "^(\\d{1,2}\\s\\d{1,2}\\s\\d{4})|^(\\d{1,2}\\s\\d{1,2}\\s\\d{4}(-\\d{1,2}\\s\\d{1,5})?$",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "To validate a date with or without time in 24 hour format (01/12/08 and 5/12/1974).",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "\\d{1,2}/[A-Z]{1,2}/\\d{1,2} \\d{1,2}:\\d{1,2}:\\d{1,4} (\\d{1,2} or 15).",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "\\d{2}/\\d{2}/\\d{4}|\\d{1,2}:\\d{1,2}\\s?[AP]M or \\d{1,2}pm|\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{",
        "passed": false
    },
    {
        "id": 1855,
        "completion": "/^\\d{4}-\\d{2}-\\d{2}$|^\\d{2}[T]\\d{2}:\\d{2}[T]\\d{2}(\\d{3}\\d{3})$/gm",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "^[A-Za-z0-9_\\s]*$",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "A[a-z]{2}-\\d[a-z]{2}",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "alphanumericGenerate (word[0-9a-zA-Z])[a-zA-Z0-9_]*",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "/^[a-zA-Z0-9][a-zA-Z0-9 ]{6,}[a-zA-Z0-9]$/",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "\\\\w\\\\w\\\\w",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "[A-Za-z0-9]",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "([a-zA-z0-9]+)\\/\\1/(?:\\*\\/)[a-zA-Z0-9]+(?:\\.[a-zA-Z0-9]+)For our second set of questions let's focus on a bit more complex ones.",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "^[A-Za-z0-9_\\.]+$",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "r'^[^_aA-z0-9\\W]*$'",
        "passed": false
    },
    {
        "id": 1856,
        "completion": "(^[A-Za-z0-9]*$|^[A-Za-z0-9]*$|^[A-Za-z0-9]*[A-Za-z0-9\\-\\_\\.]*[A-Za-z0-9\\-\\_\\.]*[A-Za-z0-9\\-\\_\\.]*$)",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "<_record>(?P<type>[^\\s])(?P<name>[^\\s_][a-zA-Z_0-9]*)(-?\\s(?P<number>[0-9]{4}))?(?P",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "let startName = \"document.\"let endName = (name?: name? :?)?\"let regex = stringToMatcher(startName, endName)",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "<_record name=\"[^:()]+\" id=\"[^:]+\" />",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "[a-z0-9\\w-]*",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "<?xml Version=\"1.0\"?>",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "^([a-zA-Z0-9_]+[a-zA-Z0-9_-]*)$",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "<document [_record]][_document][n].*[_n].*[a-z]$",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "<[-_:.]>",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "(?<!_)                     # Not preceded by _[a-zA-Z0-9][a-zA-Z0-9_]*     # First character must be alphanumeric and there may be zero or more of alphanumeric and underscore",
        "passed": false
    },
    {
        "id": 1866,
        "completion": "\\w[\\w\\d\\_\\-' ]+",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "(^[0-9]{3}:)?(0|1[5|0]).[5-9](\\s?)(0|[1-9][0-9]}[0-9])",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "(\\d{4})|(\\d{3}-\\d{2}),(\\d{3}).",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "^\\(\\d{4}(\\d\\d\\d)\\)(\\(\\d{3}\\))",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "^\\(\\d{5}\\)\\-(\\d{2})$Exercise 5:Create a RegEx to validate zipcode for Sweden given any type of country code.Answer: ^[A-z]{1}[\\s-]?[A-z]{1}\\d{5}$",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "`^[1]\\d{3}[^e]\\d{4}$`",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "https://regex101.com/r/fUoUzj/1/This RegEx should be easy to change to one where it matches one of the forces: ^([0-9]{4}[a-zA-Z]{1})(?:\\+[0-9]{1}[a-zA-Z]{1}))?(?:\\+([0-9]{",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "\\((?:[0-9]{4})?[0-9]{4}[0-9]{3}[0-9]{1}[0]\\)(?![a-zA-Z0-9-]).",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "^1000[A-Za-z0-9]{2,6}$",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "^\\\\d\\\\d\\\\d\\\\d\\\\d \\\\d0\\\\d\\\\d\\\\d\\\\d$",
        "passed": false
    },
    {
        "id": 1867,
        "completion": "/^[1-9][0-9]\\d{0,3}(Korrent/Kassel)|(Kraschlin/Korrent)$|(Korrent/Kassel)",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: ```^.*style.*$```",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: To generate this RegEx, we must use the finditer function. Use \"r\" at the front of the expression and match the longest sequence consisting of only \" or '.",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer:import retext = \"< style='color:red;'>My car is a 2021 Toyota</style>\"pattern = re.compile(\"style='(.*?)'>\")result = pattern.search(text)print(result.group(1))",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: [\"style='](.*?)[/s]\"\"\"",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: \"(?:.*?\\\\(|\\\\['))?\"|\"",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: \"([^\\(]*)\\s*([^)]*)\\s*(style=\\\"[^\\\"]*\\\")?\"",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: (\\|+)\\/\\d{3}\\.  Explanation: [^/]+,//\\d{3}\\.",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer:\"style=[\\'\";]*|('(\\\\w+)\\\\s*(\\\\'\\\\w+\\'\\\\s*)?)\"",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: re.escape(description)",
        "passed": false
    },
    {
        "id": 1873,
        "completion": "Get the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.Generate a RegEx for this description. Answer: This regex can use the '-E' flag to use the Perl-compatible regular expression engine Perl:$style=\"-E\";$line=\":caracter :\";$pattern='^('. $style. ')-\\s*['. $line. ']$';'",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "(Regex example) /(1|2|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)/",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "(0).",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "(\\d{2})\\/(\\d{2})\\/(\\d{4}",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "A RegEx for validating dates is \"0[1-9]\\/[0-9]\\/[0-9][0-9]$\"",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "(?:\\d{1,2}\\/\\d{1,2}\\/\\d{4}|0[1-9]|\\d{1,2}|[12]\\d|30)|0[1-9]|(-?0[1-9]|1[012])|(?:[1-9]\\d|[12]0\\d|30))",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "[re.compile('^01([0-9]+)/')]",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "(1). ^((0?\\d)\\d{2}){3}([/\\s\\.])?(1\\d{2})$|(2)\\d{3}\\d{2}\\d{3}(1\\s)?\\d{4}-\\d{2}-\\d{4}$",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "MM/DD/YYYY",
        "passed": false
    },
    {
        "id": 1877,
        "completion": "Example - \\d{2}/\\d{2}/\\d{4}Exercise 2: Write a Python code that extracts all phone numbers from a webpage using Python RegEx. Answer: HTML table with phone numbers:```<tr><td>1-800-FLOWERS</td><td>555-1234</td></tr><tr><td>212-555-1111</td><td>456-7890</",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "\\b(?:(?!^)^[a-zA-Z0-9]*(?:/[a-zA-Z0-9-]*)+[a-zA-Z0-9])\\b.  Generate a RegEx for this description.Exercise 5:Generate a RegEx which filters out all URLs ending",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "(.*?)\\/((.*)\\..*)*$'''",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "r\\b(?:http|ftp)s?://(?:(?:www\\.)?[^\\s/$.?$+-]+(?:\\.[^\\s/$.?$+-]+)+)(\\.[^\\s/]*)?(?:/(\\S+))*/s'",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "'/(\\w+\\.)*(www\\.)*(\\w+)/'",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "echo \"http://www.example.com/hellohttp://www.example.com/my_username\" | awk -F\"[/]/\" '{print $2 | \"^\" | \":\" | $3}'# example.com/hello: www.example.com/my_username$",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "(.*)(/.*)?(\\w+)$",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "Example: To extract the domain name from a given URL ending with '/', concat $2 and $3 as shown below.echo \"www.mydomain.com/.w3c/mydomain.com\" | grep -oP '^(.*/)[^/]*.'",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "sed $IFS=/:;s/\\(//;s/.$//;s/^./^/g;/[^./]*$/d;x;s/.*//2d;s/.//g;p $1 $2;break",
        "passed": false
    },
    {
        "id": 1881,
        "completion": "/\\d{1,3}(?:\\.\\d{1,3})+/",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "https",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "^",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "Re",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "https",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "(",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "",
        "passed": false
    },
    {
        "id": 1884,
        "completion": "[",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "/\\d*\\.\\d{1,2}([e|E]\\d?)?$/",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "\\d('###.\\d{2}'.{2})|(\\.\\d\\d)|([0-9]\\d(\\.\\d{2})?)2. Write a regular expression to match any string of text, up to 20 characters long.Answer: [A-Za-z0-9._%+-]+3. Write a regular expression to match any string of text, containing only letters and numbers.Answer: [",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "/^[0-9]*\\.[0-9]{0,2}(|[/]\\-[0-9]{1,2}|x)[0-9]*$",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "^.*([1-9]([0-9]|0?\\.[0-9])|100)$",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "0?[1-9][0-9]?[0-9]? or 0?[0-9]*([01][01][0-9]?)|0?[1-9]\\d?(\\.\\d{1,2})?",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "re.compile(r\"^\\d+\\.\\d{1,2}$|^\\d+(\\.\\d{1,2})?$\")",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "re.compile(r'^\\d+\\.\\d{1,3}$(?:,\\d{1,2})?$')",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "(?:[-+]?\\d*\\.\\d+|[+-]?\\d+\\.\\d) \\.\\d+",
        "passed": false
    },
    {
        "id": 1886,
        "completion": "^[0-9]*(\\.?[0-9])?(?:\\.[0-9]{0,2})$",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "[0-3][1-9][0-9][0-9][0-9][*][0-9]{2}",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "[0]{1}[1-2][0-9]{2}[3-9|0][0-9]{2}'So, here is how I did to generate the RegEx: const validDateRegex = new RegExp(`^\\d{1}[1-2][0-9]{2}[",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "^(10) (0|[1-9]|1[012])[0-9]\\s\\d(0[5-9])|([0-1]\\d?[0-2])[0-9]|([1-9]\\d?[0-2])[02]\\d$",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "\\b[1-9][0-9]?[0-9]\\?[0-9][0-9][0-9][0-9][0-9][0-9]\\ (0) ([0-9]{4}-01) (0)",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "20/12/2008",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "^(0[1-9]|1[012])\\/([1-9][0-9]|0?[1-9])\\/([0-9]{4})$",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "^[0-9]{3}/[0-9]{2}/[0-9]{4} [0-2][0-9]$",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "(?<Year>\\d{2})/(?<Month_string>\\d{1})/(?<Day_string>\\d{1}) (?<Year_only>\\(|\\)) (?<Month>\\b[a-zA-Z]{1}[a-zA-Z]{0,2",
        "passed": false
    },
    {
        "id": 1894,
        "completion": "\\b(2\\d|1[1-9])\\d\\d\\/\\d\\d(0[1-9]|1[012]) \\d\\d (0[1-9]|1|2[0-9])\\b",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "\\s?:(\\d{1,2}|3):(\\d{2}):(\\d{2}),\\s\\d{4}",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}).",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "+([0-9]{2})([0-9]):([0-5])([0-9]):([0-9]()\\).",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "00(-?:(\\d[0-5]|1[0-2])|(2[0-4][0-9])|(0?[1-9]|[12][0-9]))\\/(\\d{1,2}):(1\\d[0-5]):(\\d[0-5]):(\\d[0-5])\\/23:59:59",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "^([0-9]:[0-9]) ([0-9]):(0[0-9]):[0-9]$",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "\\s[0-9]{1,2}:\\s[0-9]{1,2}:\\s[0-9]{3,4} **4.** How about the URL: https://www.example.com/?Now, you have URL and a pattern to find all three periods, but this time we are looking for the presence of text before the query section.Answer: https?://www\\.example",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "0(1[0-9][0-9])[:][0-9]|[1-9][0-9]:[0-9][0-9]",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "(\\d[\\d:])(\\d)?[\\d:]",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "\\d\\d:\\d\\d(?:\\:|,) \\d\\d(?:\\:|,) \\d{2,2} \\d\\d:\\d\\d",
        "passed": false
    },
    {
        "id": 1896,
        "completion": "(00:00\\.)|(23:59\\.)|(59:)\\.Explanation: This RegEx makes sure that between a 00:00 to 23:59 it will find a colonThe Importance of Dental Check-ups, Brushing Techniques, and Allergies in Daily Life",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "^[a-zXa-z0-9._-]+\\s:[\\d\\d][:a-zA-Z]*$",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "\\d{2}:\\d{2}:\\d{2}\\,\\d{3}$",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "(\\d{2}:\\d{2}:\\d{2})\\s+to\\s+(\\d{2}:\\d{2}:\\d{2})(\\s+to\\s+(\\d{2}:\\d{2}:\\d{2}))+",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "(0[1-9][0-9]|1[012])[.:](AM[PPM]|PM[AP])",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "^(0[1-9])|(1[0-2])|[4-9][0-9] |[0-3][0-9][0-9] |[7-9]^ [0][0-5][0-9]: [0-5][0-9]:[5-9][0-9]$",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "[1-3][0-9]:[0-9]:[0-9] to 11:59:59Examples:",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "(0?[1-9])?[0-9]:[0-5][0-9]:[0-5][0-9]",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "^\\d{1,2}:?[0-2]?\\d?[0-9]:[0-5][0-9]:[0-5][0-9]$",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "01h:00m:00s, 22h:00m:00s, 13h:00m:00s, 21h:00m:00s, 11h:00m:00s, 09h:30m:00s, 09h:00m:00s, 15h:00m:00s, 05h:00m:00s, 07h:00m:00s, 04h:00m:",
        "passed": false
    },
    {
        "id": 1897,
        "completion": "[0-9:]{2}[0-9] [0-9] [0-9][0-9][0-9][0-9]T[0-9] [0-9]:[0-9] [0-9]:[0-9][0-9]:[0-9][0-9]:[0-9][0-9]Z. Do this to 11:53:58",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "The standard format is [12][0-9][0-9][0-9][0-9] [0-9]:[0-9][0-9],[0-9][0-9:[0-9],[0-9]:[0-9])",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "^([0-2][0-9][0-9])|([0-2][0-9](:|[0-6]))$",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "^(\\d{1,2}\\:\\d{2}:\\d{2})[ -]*$",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "(\\d\\d:\\d\\d:\\d\\d)",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "^0[1-9]|[1-9][0-9]|1[012]|[12345][0-9]) (:[0-9|:)] ([0-9]{2}[0-9])$",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "[12-5]:00[0-9]|6[0-9][0-9]",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "\\d{2}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "10/12/2016",
        "passed": true
    },
    {
        "id": 1898,
        "completion": "(^(?:(?P<after11:0)(?:\\D|^)(?P<amPM):0\\d)|(^(?P<Afternoon13:0)(?:\\D|^)(?P<amPM):0\\d)|(^(?P<Afternoon17:0)(?:\\D|^)(?P<amPM):0\\d)|(^(?P<Afternoon23",
        "passed": false
    },
    {
        "id": 1898,
        "completion": "(^[0-9]{2}:[0-9]{2}:[0-9]{2}(?:AM|PM)$).*This expression will match 2 digits for the hour, 2 digits for the minute, and a colon or dash. I will use this regex to check if our datetime string matches the format.",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "%m/%d/%Y [a-zA-Z-0-9_]*",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "([a-zA-Z]+) (\\d{2}).{4}.+",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "(0+)([A-z]{2}[0-9]{3}[A-Z]{1}[0-9]{1})(:[0-9]{2}[A-Za-z0-9]{3}[A-z0-9]{3})+",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "(?P<dd>\\d \\d{4});(?P<mm>\\d \\d{2});(?: (?P<yyyy>\\d \\d{2}))?, (?P<fullmonth_year>.+)",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "\\d{2}\\D?(?<month>\\w{3}\\w{3})\\D?(?<day>\\d{2}\\d{2}) \\D?(?<year>\\d{4}\\d{2})",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "\\d{4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "YMDTH",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "r'^[A-Za-z]+\\s[0-9]{4}\\-[0-9]{1,2}\\s[A-Za-z]{3}$'",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "((\\d{4}|(?: \\d{1,2}\\,)? \\d{1,2})\\s.\\s|\\d{4} \\d{1,2},|\\s\\d{1,2},\\s\\d{2})",
        "passed": false
    },
    {
        "id": 1899,
        "completion": "\\D+\\/\\D+\\/\\d{3},(0..9)\\d\\d\\d\\d/\\d{4}",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "(0-9)(1-31)(0-2)[01] [0-9][0-9]",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "(\\d{3}[\\-\\ ]\\d{2}[\\-\\/]\\d{4}\\/\\d{2}\\/\\d{2}) \\s\\d{2}\\-\\d{2}\\s\\d{2}",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "r\"(0[1-9]|1[012])/(0[1-9])|([1-9][0-9])-(3[01])|([01])[0-9](-[0-9])\"",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "*\\\\d{1,2}\\\\s+\\\\d{1,2}\\\\s+\\\\d{1,2} [ABDIY]+\\\\d{4}.*",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "\\b([0-2]?[1-9])\\s+,\\s([0-9]{1,2})?\\s*y([0-9]{4})?",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "[0-9]{4}[0-9]{2}[0-9]{2}, [0-9]{2}[0-9]{2} [0-9]{4}[0-9]{1}([0-9]{1}[0-9]{4})[0-9]{2}",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "(?:(?<=\\d{4}-)?\\d{2}-)(?:19|20) (?=\\d{2}\\.??) (?!\\d{2})\\d{2}\\.?? # 7.2.6 Validating the Date Format for Phone Numbers",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "^\\d{2}[-/.]\\d{3,4}$",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "\\b((0|1[01])|(2[0-3])|(4[0-2])|(5[0-9])|(0?[1-9])|(1[0-2])|(2[0-3])|(3[0-1])|(4[0-9]))\\b",
        "passed": false
    },
    {
        "id": 1900,
        "completion": "^([0-3]|4)?[1][0-9]|[0]",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "\\d{2}([012]\\d|3[01])\\s\\/\\d{4}([012]\\d|3[012])\\s\\/\\d{4}3. Write a RegEx for email addresses that contain no @ sign and may or may not have a domain.Answer:.+@[a-z0-9_-]+\\.[a-z0-9]{2,",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "^[0-1][1-9]|[1-2][0-9]|[2-9][0-9]|[3][0-5][0-9],[0-9][0-9]$",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "\\bJan\\. (?:Jan) (?!(?:(?:(?:1\\s|0\\.)|(?:01\\s)?\\d{0,2}|(?:20\\s)?\\d{0,2}))\\s?\\d{4}\\b)",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "[a-zA-Z][a-zA-Z ]\\s[[0-9]{3}-][0-9]{3}/[[0-9]{4}]",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "re.test(\"([0-9]{1,2}\\s*){1,2}(\\S*)\\s*(([/-]?){0,1}[0-9]{1,2}\\s*)+\", dateString){... }",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "YYYYMMDD-hhmmss                The following function generates a regex string to generate the format for a date.          Format of the date is yyyyMMDD-hhmmss-ddmm                @param date  date to validate        @return the format of the specified date for re.match and re.search        '''        def regex(date):            if '",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4})$/",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "[0-9]{4}.[0-9]{2}.[0-9]{2}.[0-2][0-9] [3-9])The month should not be a 3 digit numberThe days should not be a 4 digit numberThe century should not be a 2 digit numberThe day should not be a 0 digit number",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "([0-9]{2}|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Mon|Tue|Wed|Thu|Fri|Sat|Sun|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Mon|Tue|Wed|Thu|Fri|Sat|Sun)DAY,([0-9]{1,2}|[1-9][0",
        "passed": false
    },
    {
        "id": 1901,
        "completion": "\"([b-d])\\st\\st(0\\d\\d\\d)\"",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "^\\s+\\d{1,2}/\\d{1,2}/\\d{2,4},\\d{2,4}$\")",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "var regEx = new RegExp(\"([0-9]{1,2})([0-9]{1,2})$\", \"i\");  regExp.lastIndex = null;",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "^(\\w+)[-|]?(\\d)?[-|]?(\\d)?[-|]?(\\d)$",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "(August[th] [a]ute|[r]es|[s]hort) (\\d{2})(?:y|(?:a)[th](?:r[es])?)",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "\\A(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\d\\s\\d\\s\\d\\d, \\d\\d\\d \\d\\d\\d)",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "\\bdate\\s+[0-9]+.[0-9]+.[0-9]+\\s+[A-Z]{2}\\sand\\s[A-Z]{2}:[A-Z]{2}$",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "^\\d+ (-03) | ([A-Z])\\w*|\\d\\w*",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "[0123456789]{2}-[0-9]{2}[/] [0-9]{2}[/] [0-9]{4}",
        "passed": false
    },
    {
        "id": 1902,
        "completion": "\\d{1,2}[-/.]\\d{1,2},\\d{4}",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "/\\(\"(?:\\w+ \\w+)*\\\"|[^\"]+/g",
        "passed": false
    },
    {
        "id": 1906,
        "completion": ".+?['](?:(?!').)+['](?:(?!(?<![').)+[^']*('))',)+",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "'(\\s(?:[^\\s\"]+)|[\"\"])|(\\s+\"[^\"]+\")' Regex to match a single field with one of the following possibilities: The string contains spaces which either are not followed by a quote character or are within a quote delimited set of characters: The entire string contains characters which are not quoted: The string contains a quote",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "(?i) (?<=^|\\s|\\,|\\:|\\-|\\*|\\+\\?|\\=|![\\w_-]|&&|\\![\\w_-]|\\'[\\w_-]|\\^[\\w_-]|\\&[\\w_-]|\\",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "(([^\"]*|\"[^\"]*\")*)\"",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "r'(?|^(?:[^\"]*\"[^\"]*\")?[^\"]*$)'",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "re.split(r'\\s+|\"([^\"]+)\"', input)",
        "passed": false
    },
    {
        "id": 1906,
        "completion": "`r\"(?:\\S*(\\+|\\\\S)+\\s*|\\S+)\"`",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "```python    # Base64 string    b64_data = \"WF\\x00\\n\\xf2V\\xabH\\xe4\\x8c\\x3e\\x00\\x82\\xbf\\x0c\\x04\\xf3\\xbe\\x0e\\x80\\xdfM\\x1f\\xeaQ\\x81\\",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "A useful RegEx might look like this:",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "`//(.*)href=[\"\\'](.*?file-system-specific-link)[\"\\']`.",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "This can be solved using the regular expression, (?:(www\\.)|(www\\.))*\\.html/.",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "- (?<=[a-z0-9-])(?:\\.[a-z0-9-])+$",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "r'<img src=\"\\[http://(?:[^\\]]+\\.[^\\]]+)\"\\]\\.jpg'",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "The RegEx pattern for extracting favicon base64 data is: (p\\w+)\\;base64[^>]+",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "```html_pattern =...\\n```",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "See 'Exercise 1 solution'.",
        "passed": false
    },
    {
        "id": 1909,
        "completion": "To generate RegEx, look up what happens when you remove favicon base64 data from a HTML file. For your description, you may want to use the word \"favicon\" to define the starting and ending points of the text you want to capture. For example, a regular expression to find all occurrences of the word \"favicon,\" starting at the beginning of the string, is r\"^favicon.*\"$",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "^[-]?[0-9]\\d*[-]?\\d+[-]?\\d+$",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "(?<!(-90)90)|(-90)90/(?=\\\\d)",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "A latitutde must be between(-90, 180)",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "Latitude must<90 | Latitude|=90",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "^(?=.*[a-z ])(?=.*[A-Z])(?=.*[0-9])(?=.*[/\\-\\#\\$@\\.\\^\\%\\&\\*\\+=\\=\\?\\(\\)\\_\\>\\<\\!])(?=.*\\\\).*$",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "(^[-89.96]?[0-8][0-9]).[0-5][-8]$",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "^^(?=.0(?:\\.0)?|0(?:\\.0){0,1} )[\\+\\-]?\\d\\.\\d*[a-zA-Z]$)$",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "lat>=45/-90g",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "(?P<Latitude>[1-9][ \\.]?[1-9][ ]?[.][1-9][.]?[1-9])",
        "passed": false
    },
    {
        "id": 1912,
        "completion": "(^|\\s)(L/Ln S/Sm N/N)^(?=N$|S$)",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "<12h",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "^(?=\\d*:\\d+\\.\\d+|\\d\\d\\d$|\\d\\d\\d:\\d{2}:\\d).*$",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "(hrs\\.)?\\d{1,2}|\\d{1,2}(?:\\s?):\\d{2}(?:\\s?):\\d{2}\\$|(?:\\d{1,2})\\((am|pm)\\)\\)?(?:-(?:\\d{1,2}))? (?:\\.[0-",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "00\\d{2}:\\d{2}:\\d{2}\\s(?:[apm](?=\\s))(00\\d{2}:\\d{2}:\\d{2})(?:[apm])(?=\\s)",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "(^(\\d{1,2}),(\\d{1,2}),(\\d{2}):(\\d{2},(\\d{1,2}))$)https://regex101.com/r/u9xL3J/2.",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "(hh[0-9]|[1-9][0-9])\\s*-\\d[1-9]\\s*[AP][Mm]\\s*:[\\s.]>12hMatch this RegEx. Answer: 12h Match",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "[3-4][0-9]:[0-9]|[1][0-2]:[0-9]\\d{2}|11:21]|11:21pm(AM|PM)",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "hh:[0-9][0-9]:[0-5][0-9]:[0-5][0-9].[a-zA-Z ]",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "(1[01]|2[0-3]):(0[1-9])|(0[1-9]|[12]?)[0-9](:|\\.)0?24hGenerate a RegEx for this description.Answer:([1-9]|1[012])([0-5])([0-9])",
        "passed": false
    },
    {
        "id": 1913,
        "completion": "\\d{1,2}(\\.\\d{1,2}){2}(e|p)?",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "\\[(.*?)\\][</td](\\[(.*?)\\])<    \\/  \\*",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "<td class=\"bordered bordered-12b\">...</td> or <strong>...</strong>.",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "This expression can be achieved by replacing the first occurrence of <td />, <td > by <td /><h1 /><table /></table></h1/><h1/>",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "you can try this:    (.*<td >.*<td>.*&lt;.*<td >.*</td>.)*",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "<td\\*>***</td>|<th\\*></th>\"\"\"result = re.sub(r'<(td[^>]*)>', '', html) \\        .replace('<th[^>]*>', '<th></th>') \\        .replace('<td[^>]*/>', '<td>') if result and",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "#include<stdio.h>   #include<conio.h>   #include<stdlib.h>   #include<string.h>   #include<ctype.h>",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "(?<!<th>|</td>)<th>(.*?)</td>",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "",
        "passed": false
    },
    {
        "id": 1914,
        "completion": "(?<=<td *)>|(?=</td>)",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "/^(.*)(\\.)+(.*)\\/((\\d+)\\.\\..+)/",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "(?<=^|-)[0-9]+(\\.[0-9]+){3}-[4][0-9]+[0-8]?$|192\\.168[1-9][0-9]?[0-9]?[1-9].[0-9][0-9]|172[0-3]\\.?[0-9]\\.?\\.[0-9]{",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "The RegEx for this description is [^0-9]*\\.[0-9]{3}[^0-9]*\\.4. Exercise: Create a RegEx for a database table name that only contains alphanumeric characters and underscores.Answer: The RegEx for this database table name is [a-zA-Z0-9_]+5. Exercise: Use the RegEx from Exercise 4 to validate an email",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "(?i)([1-9]?\\d\\.)(?=([1-9]|1[012])\\.){2}[1-9]\\d\\.",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "\\[?([0-9a-fA-F]{0,4})\\.] *([0-9a-fA-F]{0,4})\\.] *([0-9a-fA-F]{0,4})\\?",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "\"^[a-z.]*\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\"",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "(\\d+,\\s?\\d{3}\\.\\d{2}\\.\\d{2}\\.\\d{3})",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "(^[^ ]+\\.){3}([0-9]{1,3}\\.){1,3}([0-9]{1,3}\\.[0-9]{1,3})|(^[0-9]{1,3}\\.[0-9]{1,3}.*)$",
        "passed": false
    },
    {
        "id": 1915,
        "completion": "/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "mm/dd/YYYY",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "0[1-6]/0[9-2][0-9]/[0-9]{4}",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "The month should be a month with letters, except for \"J\". The day should be 01-12. The year can be a 4 digit number, an actual or implied",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "MM/DD/YYYY/(\\d*)",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "(\\b(\\d{2})/(\\d{2})/(\\d{4})\\b) or (\\b(\\d{4})(\\/)(\\d{3})(\\/)\\d{4}))",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "\\d/\\d/\\d\\d(?=\\d{4})",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "(\\\\w|\\\\s)*([\\\\d])/([\\\\d]/\\\\d)(\\\\d)$",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "[0-9]{2}/[0-9]{2}/[0-9]{2} \\w{3}",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "\\d{2}/\\d{2}/\\d{4}",
        "passed": false
    },
    {
        "id": 1916,
        "completion": "https://gis.stackexchange.com/a/4733/1176",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "\\b[A-Z][a-z]{0,20}\\s[a-z]{1,30}\\b\\s-\\b[A-Z][a-z",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "```^(?=.*[A-Z].*[A-Z])[A-Z].{3,20}$```2. Write Python code that checks if",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "^[A-Z]{0,1}[a-z]\\. [A-Z]{0,1}[a-z]+[A-Z]{0,5}\\w",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "/^[a-zA-Z0-9][a-zA-Z0-9, -]*[a-zA-Z][a-zA-Z0-9",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "[First_Name][last_Firstname][last_Lastname][optional_extra_letters]*|[A-Z][B-C]",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "/(^[a-z0-9\\\\-]+[a-z0-9\\\\-]+(\\\\.[a-z0-9\\\\-]+)*$|^[\\\\w",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "(?i)\\b(?=[Rd-z]*$)\\b[A-M][a-z]\\s?[A-M]\\s?[a-z]+",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "(?i)^[A-Z].*(?<![A-Z].*)[A-Z]({3,20}[A-Z].*)?$",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "[A-z1-9][A-z0-9][A-z0-9-_!@#$%^&*()`~/]*[A-z0-",
        "passed": false
    },
    {
        "id": 1921,
        "completion": "/^(Last|First).*|(Last|First).([A-Za-z0-9]{2,})*$/i;",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "------------*Month*------------*Day of",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "\\d{4}(?:-\\d{2})?(?:-\\d{2})?(?:-\\d{2})?",
        "passed": false
    },
    {
        "id": 1924,
        "completion": ".{4} or [0-9]{2} or [0-9]{4}",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "^(19)([12][0-2])",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "year(?=\\d{3})-(month(?=\\d{2})-)?(day(?=\\d{2}))+$",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "\\d\\d\\d\\d$|^\\d\\d\\d\\d\\d$|^\\d\\d\\d$|^\\d\\d\\d$",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "To match a date in the format \"MM/DD/YYYY\", we can use the pattern /\\d{1,2}/\\d{1,2}/\\d{4}/. For instance, \"01/12/2022\" and \"12/31/2022\" would match the pattern.",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "\\b\"\\d{4}\\s\\/\\d{2}\\s\\/\\d{2}\\b\"",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "'[0-9]{1,2}[-/][0-9]{1,2}[-/][0-9]{1,2}[-/][0-9]{4}'",
        "passed": false
    },
    {
        "id": 1924,
        "completion": "The date is valid.Illustration: Samantha and John have just finished grocery shopping. Samantha has chosen organic vegetables, which are higher in nutrients and pesticides, while John has opted for conventional vegetables that are cheaper. Later that evening, Samantha cooks a vegetable stir-fry with her produce from the grocery store and shares with John. John eats half of the stir-fry, but complains of a stomach ache and bloating for the rest of the night. Samantha wonders why John reacted so strongly to",
        "passed": false
    },
    {
        "id": 1925,
        "completion": ".*[^*][^(Asterisk)]*.",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "^.**(Asterisk)$",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "The string regex is\\*(Asterisk)(Note: You should use \\* instead of *)Now check the string: $string = \"*(Asterisk)\";if (preg_match('/\\*(Asterisk)/',$string, $result)) {    print_r($result);    echo \"TRUE\\n\";}",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "^A*+$[a-zA-Z]$|^A\\*+$",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "^[*]([A-z ]| | [A-Z])([0-9]+)$",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "^[A-Z]*(\\*(Asterisk))+[A-Z]$",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "`^[A-Z]+(_[A-Z]+)$`.",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "re.match(\".*A*|^A*\", string)",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "^[a-zA-Z0-9\\*]+",
        "passed": false
    },
    {
        "id": 1925,
        "completion": "^`(?!.*[a-z][a-z0-9])*(?!.*$)([A-Za-z0-9]+)\\*(\\*(Asterisk))[^*()%$|^*\\*]$`",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "\\d\\d\\.\\d\\d - This pattern matches digit pairs and. will match 1 character including.. This will enable us to create a RegEx pattern for the time duration. \"d\\d.\"\\d\\d This matches digit string and will enable us to find time string which consists of digits. \"d\\d\" - This will allow us to form a time duration which consists of a string of digits.",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "A(\\.0+)0[5-9]{7}",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "(\\d+\\s\\+\\s)+.{0,1}",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "/^[.\\d]?[0-9]?[\\d]{4}(\\.\\d[\\d]{6})?$/",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "\\d\\d\\d\\d\\d?s\\d*\\.\\d+",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "/(?:[^\\d-]|^[\\d]+\\d*)(?:\\.[^\\d-]|$)/Example: 12:00:00 or 12-01-00",
        "passed": false
    },
    {
        "id": 1927,
        "completion": ".(?:[^0-9]+|0{1}[0-9]+0(?:0){0,4}|[0-9][0-9]*[0-5])",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "[0.0][0-9]\\d*(0+05)?",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "(\\d)\\.(\\d0)\\.(\\d0)([^\\d\\s])(\\s([0-9])) (g)",
        "passed": false
    },
    {
        "id": 1927,
        "completion": "[0-99999],\\d*[,0]?[0-5]?[0-9]?[05][0-9]?[0-9])+",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "((0.[0-9]*)[0-9]*(,)?[0-9]*)?You need to use the + after the first group of numbers.",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "^([0-9]*[1|3-9])([a-z]|$)",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "[0-9]+/(?![a-zA-z ])(?![a-zA-z -\\/0-9])(?!\\^)(?![^0-9#./])",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "(\\s|-|\\[|\\]|,|\\/|\\&|\\(|\\)|<|\\{|\\}|\\$|\\+|=|=|\\*|\\_|\\^|\\@|\\#|\\<|\\>|\\b)+",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "/^\\d+\\/\\d+$/",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "'^(?:(?P<sign>[-+]?)(?P<number>[0-9]+)\\/(?P<denomination>[a-zA-Z0-9._]*))$'",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "[0-9,1,5-19]",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "\\d+/\\d+",
        "passed": false
    },
    {
        "id": 1931,
        "completion": "(^-?\\d+\\.?\\d*|\\d*\\.?\\d+$)",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "\\d+(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "[1-9][0-9]\\d*\\.\\d+|10[0-9]\\d*(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "^(?!$|\\d)([-.]\\d+(?:\\.\\d+)?)*$",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "^[0-9]{3}(?:\\.|[0-9]{3}(?:\\.|[0-9]{2})(?:\\.|[0-9]{1}))$",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "\\d*\\.?\\d*([+\\-*/])\\d*",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "re.compile('(^\\+|\\-)[a-zA-Z](\\d+)?[$]?$')",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "You could use a pattern like [0-9] or (0) or \\d+\\.|[0-9] to match only whole numbers.",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "You can use `^-?\\d*\\.\\d+|100$` (exactly 1000 digits or up to 1 decimal digit).",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "{^\\\\d+.\\\\d+$}$.",
        "passed": false
    },
    {
        "id": 1933,
        "completion": "\\D(\\d+)(x\\.)(\\d+)",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "(?P<amount>\\d{3})\\.?(?:(?:(?:(?:\\d{36})?|3000))\\s*)?,?$",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "(?:0*[1-9]\\d*[0-9])\\.\\d{1,2}.??\\d{4}(?:,\\d+)?\\.\\d{3}[0.0]?[1-9]\\d*[0-9]",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "((?![0-9])0)*[0-9]{1,3}(,{1,3}[0-9])?\\.?[0-9]{1,3}(,[0-9]{1,3})*$",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "0,00.00\u20ac",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "function EuroFormat(amount, thousandsSep = \"\", decimalComma = \".\") {   var reg = new RegExp(\"^('[0-9]{'1'}\"+ (thousandsSep if thousandsSep) + \"?)?(\" + (\"'[0-9]{'3'}\"+ (decimalComma if decimal",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "2 * 0.01,000, 0.01,000Example 2: String: '20,955.99 EUR'",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "\"\\d{1,15}[\\.0-9]*{0,1},?[\\s\u20ac]{0,1}?\"",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "[^\\s,\\.]*\\\\d+",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "|(?<!^)(?<!\\.)\\b[1-9][0-9]{0,3}(?:[Ee][0-9]+)?\\.[0-9]{1,3}(?:[Ee][0-9]+)?$|(?<!^)(?<!\\.)\\",
        "passed": false
    },
    {
        "id": 1941,
        "completion": "?\"$0,000?(?P<Millions>.\\d\\d?)((?:\\.00{1}\\d\\d?)?|0)$\",",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "/^(.*)\\s+(?:\\s*\\d+:\\s+\\d+.*)\\s*[#/0-9a-f]+$/;",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "^0\\s*[A-Z]{2}\\s*:\\s*\\d[A-Z]{2}$",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "^\\d(\\-\\w+\\s+)?po\\s*(?:[#]\\d{9,})$",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "^([A-Z]{1,2})\\s?\\d+\\s?([A-Z]{1,3}\\[)?([A-Z]{1,4}\\]?)?([A-Z]{1,5}\\)\\s?#([A-",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "\"^(?!^(\\s|^|\\s|^|#)^#)(?m)(((\\#?\\d{1,2}):(?:(?:[0-5]|[1-5]\\d|2[4-6])))? \\",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "^\\s*\\+?([0-9]+(\\.[0-9]+)?)\\ *?box[0-9]*\\s*(\\+?|\\/|\\s)?$",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "^.*(\\d+)[A-Z].*( )(.*)",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "\\bP\\d+\\b #matchs PO boxes. e.g. 123 Main St.  \\bPO Box 1234 #matches PO Box #1234 Title: Cleaning and Formatting Email Data with Python",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "^\\D((\\d+ [a-z][a-z0-9]*? \\D{1,3})? | (\\d+ ( )?[a-z][a-z0-9]*?) \\D{1,3})?.*\\",
        "passed": false
    },
    {
        "id": 1943,
        "completion": "\\s*^(?:(?<=^)|(?<=\\W)|(?<=\\s+))(?P<addr>.{4})(?P<number>(1|5)?\\d{2})(?P<extra>\\s{1}",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer: let content = ( \"This website\" + new RegExp( \"^https?://\", \"i\" ) + \".org|www.\" + new RegExp( \"^http?://\", \"i\" ) + \".co.nz/\",\"i\")",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer: var regex = /https?://(?:[^\\s()<>{};:\\'\".,!?\\/\\n\\\\]|(?:%[0-9a-fA-F]{2}))*\\(/; var pattern = \"https?://(?:[^\\s()<>{};:\\'\".,!?\\/\\n\\\\]|(?:%[0-9",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer:var x = document.getElementById(\"url\");var regEx = new RegExp(\"^https?\", \"g\");if(x.value.match(regEx))   alert(\"Entries are ok\");else   alert(\"Entries are not ok\");",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer: [^a-zA-Z /-_/.,:] https:// http:// - \\w[-_.a-zA-Z0-9@+_%~a-zA-Z0-9]",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer:  /^(https?://)((.|[ \\t]*)*(?P<content>A-z)(\\W/|$|$))$/.",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer: [^-/.\\s:]{1,35}",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer: pattern = (?i)\\s(?=\\S)(?<!http)[a-zA-Z0-9.-/]{1,50}\\b",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 1944,
        "completion": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas. - /Generate a RegEx for this description. Answer:https?://[^/]+(?:[^/]*?\\.)+[^/]*?/",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "^[-+]?\\d{1,3}(,\\d{3})*$",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "([-+]?[0-9]?\\d*|\\d+),",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "var integer = ['-0xffffffffffffffff|0xffffffffffffffff', '0xfffeffffffffffff|0xfffeffffffffffff', '0xffffffffffffffff|0xff0000ffffffffcc', '0xffffffffffffffffc|0x2e8a1beefb8dc6fb', '0x00000000ffffffff|0xffffffffffffffff'];var unsigned = ['-0xffffffffffffffff|0x",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "\"R\"(\\d\\d[a-zA-Z]?) (negative?|positive?) |\"R\"(\\d\\d[a-zA-Z]?)\" (with|without commas) 4. What is the length of the shortest possible hexadecimal string?Answer: Length may vary.",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "^\\d{1,3}(,-\\d{3})*$",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "the number [1234567890]",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "The character set is a number from -2147483648 to 2147483647.```python# Exercise 3import restring = \"The value of the expression is 3521\"numbers = re.findall(r'\\d+', string)print(numbers)# Output: ['3521']",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "x.00X123, x.000X123, x.00X1234.",
        "passed": false
    },
    {
        "id": 1950,
        "completion": "r'^[-+]?[1-9][0-9]*(.[0-9]+)?$'",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer:(5?|49|999|9000|999999)?|\\+|\\-?\\*",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer:(?:\\d|[\\w ])+",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer: 1, 2, 3, 4",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer: [0-9]*You can also add more characters in [0-9], but this will still match any numerical value you need..",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer:/\\d*\\s*-\\d+/",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer: \\A[-\\d.+\\s]*\\ZExamples:",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer: ^0(1\\d,3\\d,4\\d|5[0-8]\\d|6(0[1-9]|[1-9]|[1-9]\\d|1\\d|2[0-9]\\d|3[01]))$",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer: { 1 to 10 digits | no digits | no spaces | at least 1 non-zero digit }",
        "passed": false
    },
    {
        "id": 1952,
        "completion": "Match any number, no characters, no empty sets, and accept zero.Generate a RegEx for this description. Answer:^(?=.{7,30}$)(.{0,61})(?:[^\\s\\d]|$)$",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "\\d+\\.0\\.0\\d",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "1\\\\.(0\\\\.0)+",
        "passed": true
    },
    {
        "id": 1954,
        "completion": "\\d+\\.\\d+\\.\\d+\\b",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}$",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "\\d+.\\d+.\\d+\\.(.*)",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "^(1\\.0\\.0.*)\\.(0|1)$ That one is pretty simple, and doesn't require any additional characters. A simpler version would be to use a RegEx of the style 1\\.(0|1) That one will only work if there is only one number between the brackets. I think that this will satisfy your needs for this version of your question.",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "^1\\.0\\.[0-9]\\.[0-9]$",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "/(^(1\\.)?0\\.)*(0\\.)?(\\d+)/",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "^1.*\\d(\\.\\d{0,2})$",
        "passed": false
    },
    {
        "id": 1954,
        "completion": "1\\.0\\.0\\d[^\\d](\\.|\\+|\\-)*",
        "passed": true
    },
    {
        "id": 1956,
        "completion": "(^\\$|-)\\s*?(.*?)(?:,(\\d{1,19}))?$",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "(-[^$,.]+)($|$|,)",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "[^$,-]",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "/[+\\-]?(?:\\d+(?:,?\\d*)?(?:\\.\\d{0,2",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "^\\s*-?(?:\\d+\\s*(?:[eE][\\da-fA-F]+",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "(^|[^$])([+-]{1})([0-9]*[.]{1}){",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "-?\\d+,\\d{2}(\\.\\d+)? *",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "^[0-9]{1,3}\\.[0-9]+$",
        "passed": false
    },
    {
        "id": 1956,
        "completion": ".*(-?\\d+(?:\\.\\d*)?|[1]\\d*[6-9])$",
        "passed": false
    },
    {
        "id": 1956,
        "completion": "([\\d.-]*)(?=\\$|(, |$))",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "ICD-10 codeGenerate(?P<desc>.+)",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "a[A-Za-z0-9]{2}\\-[A-Za-z0-9]{2}[A-Z]{4}",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "(?<name> [A-Z][a-z]*(?! _[A-Z][a-z]*$ ))",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "https://www.regular-expressions.info/icd-10.html",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "[A-Za-z0-9\\-\\(\\)]*",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "(\\d{3}\\s*){10}\\-?(\\d{3}-?\\d{3}-?\\d{4})",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "^[01]?[0-9]$",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "/(b\\/d)(a\\/s)(d\\/x)(s\\/\\d+)/",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "(\\\\d+)",
        "passed": false
    },
    {
        "id": 1958,
        "completion": "(?i)(((?<num>)[A-Z]|[a-zA-Z])\\d{2,7}[A-Z]|[A-Z]{6}\\d|[A-Z]{7}\\d\\d)",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "(\\b[A-Z]{3}\\d{2}[-\\./]\\d{4}\\b|\\b\\d{1,2}/\\d{1,2}\\b)",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "^[A-Z][0-9]{3}-[A-Z]{1,2}$|^[A-Z]{1,2}-[0-9]{2}[A-Z]{1,2}$",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "[D/M/YYYY]\\\\d\\\\d\\\\d/\\\\d{2}$",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "[a-zA-Z]{2}/[-\\/_]{1}[a-z0-9]{3}/[-\\/_]{1}[0-9]{4}|[0-9]{1}/[-\\/_]{1}[a-z0-9]{3}/[-\\/_]{1}[0-9]{4}|[0-",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "r'^([A-Za-z]{3})/([0-9]{2})/([0-9]{2})/19$'",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "[\\d/M][a-z]{3} [A-Z]{2}",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "[\\s+[Dd][Mm][Yy]][0-9]{3}",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "(ex. '(?(1)^(?!00)0(?[1-9]|1[012])/)(0[1-9][0-9]|1[012])'| (ex. '(?(1)^(?!0)0(?[1-9]|1[012])\\/))'| (ex. '(?(1)^(?!0)0(?[1-9]|1",
        "passed": false
    },
    {
        "id": 1960,
        "completion": "(\\d{1,2})/(\\d{1,2}\\s\\d{4})/(\\d{4})",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "^[a-zA-Z0-9\\s\\-\\_\\+\\.\\~\\`\\{\\}\\(\\)\\*\\#\\+=\\!\\[\\]\\^]*$",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "([^xyz]|[xyz]|xyz?)",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "^((?:x?|y?)\\w{{2}})$",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "/(?!xx)(?!yy)(?!zz)\\b(\\w+)\\b/I can also remove the \\b word boundary, adding \\w between the two patterns makes it more likely to match a word in the alphanumeric listDemo on dot-netfiddle",
        "passed": true
    },
    {
        "id": 1962,
        "completion": "([a-z0-9])(?:({{ \\1 }}{2,}),)? {{2,}}To explain for some, the first letter must be lower case alpha, then digit or dash, then again lower case letters (or alpha) or digits (or hyphen)...",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "[^a-zA-Z0-9\\.?_\\-\\/]",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "\\bxx or yy or zz\\b",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "/[^(xx)|(yy)|(z)|(zz)]/gm",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "\\w+",
        "passed": false
    },
    {
        "id": 1962,
        "completion": "^(?![xy].*$).*(?=(?:[^xx]*xx[^x]*)+[^y^]*y[^y]*a(?:[^x]*xx[^x]*)+$).+$",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "[0-9.]{1,100}",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "var validator = (  x % 5 < 5  && x % 10 % 10 == 0    && x % 100 % 100!= 0  && x % 1000 % 1000!= 0  &&!(  x % 10!= 0 || x % 10 % 100!= 0 || x % 100 % 1000!= 0        ))",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "^(?P<value>[{0}]*\\.?[0-9]?{0,2}|\\.?[0-9]*)%(?:(?:\\%20)?[{0}](?: %?[{0}])?)?$\"\"\"# %% [markdown]# ### Regular Expression Validator",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "^(?=(\\d)(?!0)?(?!1?1?100)(\\d)(?!100$)?(\\d(\\.0?\\d)*)?)(\\d+(?:\\.\\d+)?%(?:\\.\\d+)?(?:\\.\\d+)?%)$",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "\\%[0-9]+\\.[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "([0-9]{1,2}\\.){2}[0-9]{1,2}|25\\/99",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "(?:[0-100]{0,2}\\.[0-9][0-9]?)",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "^[0-9]{1}$",
        "passed": false
    },
    {
        "id": 1964,
        "completion": "^[1-9.]?\\d{0,2}\\d(%.*)?$",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "This expression allows you to select 1-365 as a numeric value for the days of the year. Must be between 1 and 365 and must be numeric",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "(1[0-9]|[12]\\d|3[01])|[1-9]\\d|[1-9]",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "[1-365]\\d\\d",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "[[1,365]]",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "(0?[1-9])|1[012]",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "(?!^)(?!$)\\d+([\\s/:.?!;]+)\\d*/",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "(\\d+)(?:-|\\/)(?:[1-9]\\d*(?:0[1-9])?|1[0-2])",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "(1[1-9|2-9]|0[12][0-9]|3[01])\\s",
        "passed": false
    },
    {
        "id": 1972,
        "completion": "0?[1-9]|[12][0-9]|3[01]",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "\\d{3}-\\d{2}-\\d{4}|\\d{5}-\\d{3}-\\d{4} 4. How can the use of a custom function on the database help the user validate their SSN?Answer: The user can define their custom function which takes in their current SSN and compares it to the database SSN which the application can validate using pre-defined methods.",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "^[1-9][0-9]|9[0-9]{2}(?:-[0-9]{4})?$",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "The answer will depend on the user, as the problem requires creating a unique RegEx for the description.",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "^\\d{3}[-\\s]?\\d{2}[-\\s]?\\d[-\\s]?\\d$",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "SSN_Pattern = \"^(?!.*?\\\\d){3}\\\\d{3}-\\\\d{2}\\\\d{4}\"",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "The pattern will be SSN\\(\\d{3}\\)\\d{2}\\-\\d{4}.",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "#3",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "^[a-zA-Z0-9- ]{30}$",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "[\\d-]{3}\\-\\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 1974,
        "completion": "[3][4][-9]{5}(?!\\s+00)",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "\\d{1,4}(-\\d{1,3}, \\d{3})?\\s(in\\s)?(\\d{1,4}(-\\d{1,3}, \\d{3})?)",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "(\\d+(?:\\.\\d*)?)(?![\\s$])",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "(.*[^\\.\\d]?)$",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "(?:\\d+(?:\\.\\d*)?)([$]{1,2}(?:\\.\\d+)?)",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "/(^[0-9]+((\\.[0-9]+)?)*)([kJKlMnOpQrStUvTwXyZ]{0})?([gG][A-R][A-R]*)?(?:(x){0,1})?([a-zA-Z]{6,15})/",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "(?:(\\d+(?:\\.\\d+)?)\\s*|\\s*|')",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "The regex pattern is `^\\$[0-9]*.[0-9]*\\.?[0-9]*$`. The `^` anchor anchors the expression at the beginning of the string. The `[0-9]*` character class matches zero or more digits in the string. The `.?` character class makes the number optionally followed by a decimal point. The `[0-9]*` characters make sure the number has exactly one digit after the decimal point.",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "r'^\\d{1,3} \\d{3}-\\d{1,3}-\\d{1,4}$'",
        "passed": false
    },
    {
        "id": 1977,
        "completion": "(\\d+)\\.\\d+",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "* \\b\\d{3}[ -]\\d{3}[ -]\\d{4}\\b",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "import ressn_regex = '^\\d{3}\\-\\d{2}\\-\\d{4}$'",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "*(?i)(?=.*\\d)(?=.*\\d|\\.\\d)",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "((?=^|)^[^.\\s]+(?:(?=.\\.)[^.])*[.][\\s$]?[^ ]+[a-z]{2}\\s){3,30}",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "[Your example of a valid RegEx pattern]",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "/^[a-z]{3}\\s?([A-Z]{2}\\s?[0-9]?(?:[A-Z]|\\?){1}[.-]?[0-9]{3})$/",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "[0-9]+-([0-9]+)\\K[a-z]+-([a-z]+)-[a-z]+",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "\\b[0-9]{3}\\s[a-zA-Z]{3}\\-[0-9]{4}\\s[a-zA-Z]{3}\\-[0-9]{2}\\.[a-zA-Z]{2}\\.[a-zA-Z]{2}\\s\\w{6,9}$",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "r'\\b(SSN)-?\\d{3}\\-?\\d{2}\\-?\\d{4}\\b'",
        "passed": false
    },
    {
        "id": 1978,
        "completion": "",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "([a-z][a-z0-9-]{5}|[a-z0-9]{6,17}|[a-z]+[0-9]{8})Exercise 3: Match the following passwords:",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "^[a-zA-Z- ]{5}[a-zA-Z-0-9]{7}$",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "/^[a-zA-Z\\d-]{5}$/I'm not sure what you are looking for, yet. Here is a RegEx in Action. See this answer using the text from earlier in this post. If you need an explanation and/or further clarification, just write a comment.",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "^[A-Za-z]{5}\\w{6,17}$",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "^[a-zA-Z][a-zA-Z0-9-]{4}-[[0-9]]{4}[a-zA-Z0-9]$|^[a-zA-Z][a-zA-Z0-9-]{5}-[[0-9]]{5}-[[0-9",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "[A-Za-z][A-Za-z0-9-_]{5,20}[A-Za-z0-9-_]",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "/^[a-zA-Z][a-zA-Z0-9-]+[a-zA-Z0-9](...)(...)(...)(...)(...)(...)(...)(...)(...)(?=.*(\\d|\\-)[a-zA-Z0-9])/",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "/^[a-zA-Z][0-9\\-]{8,17}$/.",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "^[a-zA-Z0-9-]{5}[a-zA-Z0-9-\\d\\.]*[a-zA-Z0-9]$",
        "passed": false
    },
    {
        "id": 1986,
        "completion": "^[A-Za-z]{1,5}[A-Za-z0-9-]{6,17}$",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "^S+.*?SEP.*?S+$",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "$re = '/^[^SEP]+(.*)SEP[^SEP]+$/'; or$re = '/^(.*)SEP(.*)SEP$/';",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "(?:^|(SEP)|.*(SEP)(?!END$))",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "(?<!TODO)TODO( )",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "[^A-Za-z].*Line begins with LINE. and [^A-Za-z].*Line does not end with LINE.  I have to write this in javascript. Thanks!",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "(^|SEP)(?!SEP|$)(.*)",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "^SEP.{{12,.0f}}.SEP.{{12,.0f}}.{{7,.0f}}.{{4,.0f}}.{{4,.0f}}.{{7,.0f}}^",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "(This pattern should match lines that begin with SEP but not the string that follows):  SEP+(.+)) My attempt:",
        "passed": false
    },
    {
        "id": 2008,
        "completion": "[^SEP*]*",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "^0*(?:[01][0-9][0-9]|2[0-3][0-9]):[0-5][0-9]$",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "^([01][0-9][0-9]:){2}[0-9]$",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "The Regular Expression will be something like this:`^(?:[01]?\\d|2[0-3]):([0-5]?[0-9])$",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "var re = /^[1-2][0-9]|3[01][0-9]|0[1-9]|[1-9]\\\\d? [A|p][0-3] [1-9]|[AB][0-9]{2}$/;",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "^[0-5]\\d|[1-9]\\d|20[0-9]|200|21[0-2]$",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "(0[1-9]|[1-9]|1[012])[0-5][0-9]|6[0-1]",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "^([1-2][0-9]|3[0-1])[0-9]?(\\d|\\:)?[0-9]?$",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "myRegex = \"^([0-9]|1[0-2]):([0-5][0-9])$\";",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "^[1-9][0-9]?[0-5][0-9]|1[0-9][0-9]|1800|19[0-9][0-9],https://regex101.com/r/fOmhV0/1(1|0)?[0-9",
        "passed": false
    },
    {
        "id": 2011,
        "completion": "$0[1-9]:\\d[1-9]:\\d (AM|PM)",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "This URL pattern will find an occurrence of \"https://www.example.com/index.html\" before the last slash.",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "(.*?) (.*?)",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "This is an open-ended question that does not have an answer.",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "(?<tld>[\\w\\.]+)```### Exercise 2:",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "``` pythonurl = 'https://example.com/abc/def/ghi'",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "r'/\\b(.*?)\\b(.*?)\\/\\d\\d/'",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "You can build a RegEx pattern from a string literal by putting a '\\' before a string.",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "re.escape(tld)",
        "passed": false
    },
    {
        "id": 2013,
        "completion": "(1) '<tld>', <subdomains>",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "(?:0?\\d,)?\\d{1,3}\\.\\d{1,6}|\\d{3}\\.\\d{3}|\\d{3}.\\d{3}",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "(?<currency>\\$[0-9]+(?:,\\s*\\$[0-9]+(?:,\\s*\\$[0-9]+)*)*)",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "\\$?(?P<amount>[\\d\\.]+)(?:[eE][+-]?(?P<exp>[\\d\\-]*))?",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "^\\d{1,6}(?:,\\d{1,2})?(?:\\.\\d+)?$",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "This question has one optional decimal and two decimal spaces to the right of the whole number.",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "(^[0-9.9999]|(1?[0-9,])[0-9]|(1[0-9]))(?:\\.[0-9]{1,1})?[0-9]{1,6}(?:[,",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "/^\\$\\d+\\.\\d{2}(?:,\\d+\\.\\d{2})?$/",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "[1-9][0-9]?$ |\\.(1+[0-9]{3})?(([Ee][+-]?[1-9][0-9])|([Ee][+-]?[0-9]{",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "(\\d{1,2}.\\d{3})?(?:\\.\\d{2})?",
        "passed": false
    },
    {
        "id": 2014,
        "completion": "`-?\\d+.*\\,?\\d+.*\\,?\\d+.*\\,?\\d+.*\\,?\\d+.*\\,?\\d+$`",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "^(?:\\(\\d{1,3}\\)??\\s*(?:\\d{3}\\)??-?)?(\\d{4})$",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "(1\\s+)([2-9]{3}\\s+[2-9][0-9])(\\s+([2-9]{3}\\s+[2-9][0",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "\\A(?:\\d{2}(?:\\(?\\d{3}\\))?(?:\\(?\\d{3}\\)?\\d{4}\\))$Examples to illustrate the phone",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "^(\\d{3})\\s*(.*)\\s*(?:[-\\s]*\\d{3})?\\s*(.*)$",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "1[23][456]-[567]-[89]{0,3}$In PHP, you can use this code:$phone = '988-555-1234, 987-",
        "passed": true
    },
    {
        "id": 2023,
        "completion": "[^\\s]1[ ]*[(]\\((\\d{3})\\)([+\\-]?)(\\d{3})\\))The problem is that the regex above will not allow",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "\\b(1[2-9]|1[3-9]\\d|2[0-8]\\d)\\d{3}\\b",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "/^\\d{1,3}-\\d{3}\\-\\d{4}$/$Explanation:^  # Begin of line  \\d{1,3}",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "\\(?(\\d{1,3})[ -]?\\d{1,3}\\)(\\d{3})[ -]?\\d{4}",
        "passed": false
    },
    {
        "id": 2023,
        "completion": "\\d{1,3}(?:\\(|\\)|\\[|\\])\\d{3}-\\d{4}Generate a RegEx for this description.Note that it is",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "x-xxxx-0000",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "xxx-xxxx",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "1-2m/2l/h (m and l are characters).",
        "passed": true
    },
    {
        "id": 2025,
        "completion": "",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "+[\\\\s-]+",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "A person who works with the latest technology trends - Tech-Enthusiast",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "export const formatCurrency = (type, value: number) => `${type}{number: '0,000,000'.padEnd(value.toFixed(9), 9) === ''? '.' : ','}`;",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "r'^(?P<service>[a-zA-Z0-9_]+)':Service ID. Note that when generating regex for this description, '_' should be omitted.",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "The pattern above should be used as a regular expression for the 'Description' field of the sample form.",
        "passed": false
    },
    {
        "id": 2025,
        "completion": "",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "\"^[1-9][0-9]{1,2}$|^[0-9]{4,5}$\"",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "([0-9]{3})-([0-9]{3})-([0-9]{3})",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "(0-9)([a-z])([a-z0-9]{3})",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "[1-9][0-9][A-Z]|[0-9][0-9][A-Z]Z",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "The regular expression would be [0-9]\\d{3}\\.\\d{2}.",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "^[1-9][0-9][0-9]|[1-9][0-9]$",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "^1000[A-Z]{2,3}$",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "```pythonzip_codes_regex = re.compile(r'^\\d{10}\\z')```",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "RegEx = \"(?<prefix>\\d{3})(?<suffix>AA|ZZ|DE)(?<zone>\\w{2})\\b\"",
        "passed": false
    },
    {
        "id": 2031,
        "completion": "r'S[0-9]{6}$'",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer:[0-9]{1,3}     //Number[a-z]{0,2}     //Capital letter (Small, big)\\d|[^\\d]     //Digit and non-digit",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: <\"content\" >content</\"content\">",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: Regex.Replace(Html, @\"(<[^>]*>)\", string.Empty)In C# string s = s.Replace(\"<[^>]*>\", \"\");string s2 = Regex.Replace(s,\"<[^>]*>\", \"\")",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer:Regex.Replace(Html, \"<[ \\w\\s]+>\", string.Empty);I hope my explanation was clear enough.",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: Generate a regex that matches any text surrounded by HTML characters (including closing tags).Thanks.",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: <([^>]*)>Now I want to create a RegEx in Python for the same but not sure if there is any existing RegEx in python that is similar to the one I provided above. I have to remove all the html tags and keep only simple plain text.",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: <[^>]*>",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: @\"[a-z0-9_\\.-]+$\"This is a Matcher Object So We used a. in this Pattern to avoid it throwing a match on a blank string.",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: ^[^<>]*The ^ is important, this character startswith the original value, not the Regex.",
        "passed": false
    },
    {
        "id": 2040,
        "completion": "This Regex Will Remove All Html Tags And Return Simple Plain Text.For Example In C#.NET :Regex.Replace(Html, \"<[^>]*>\", string.Empty);Generate a RegEx for this description. Answer: This Regex will Remove All Html Tags And Return Simple Plain Text public static string RemoveAllHtmlTags (string raw){     var regex = new Regex(@\"<[^>]*>\");     var regex1 = new Regex(@\"(<{0,1}\\s*[^",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "^[\\u0600-\\u06FF]{0,1}$",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "[\\u0600-\\u06FF]For C#.NET answer, if you really want to check it without compile, first try to use this regex:^[\\u0600-\\u06FF]*$Then by just calling it:Regex.",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "True",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "true = string is composed by unicode characters.",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "RegEx: ([\\u0600-\\u06FF]|[\\u0601-\\u064F])For more details about Unicode Character, Check this StackOverflow Question",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "(?=.*\\u0600)(?=.*\\u064C-\\u066F)Then replace this regex with this RegExp \"RegExp((?=.*\\u0600)(?=.*\\u064C-\\u066F).*",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "\"hello worlow worl\\u2070rld\"is equal to",
        "passed": false
    },
    {
        "id": 2041,
        "completion": "https://www.regular-expressions.info/unicode.htmlFor javascript:string alpha=[\"\\u3061-\\u318F\",\"\\u309F-\\u309F\",\"\\uFFFD\",\"\\uFFFF\"];",
        "passed": false
    },
    {
        "id": 2049,
        "completion": ".{8,25}$",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "(^[a-z0-9\\s]{8,25}[a-z0-9]\\s.*[a-z0-9\\s]{2}[a-z0-9]?[a-z0-9\\s]{2}[a-z].*$)",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter, 1 number, and at least 1 special character ([A-Z]\\w{1,})(?=\\S)*",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "(.*)[a-z](.*)[0-9]{1,25}(.*[a-z]|.*[i-9]|.*[u-9]|.*)$I found out that the given exercise is to create a regular expression using.*[a-z] and.*[0-9",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])\\S{8,25}$",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "`^(?=.*[a-z])(?=.*[0-9])(?=.*[A-Z])(?=.*\\W).{8,25}$`",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "Password = \"(?=.*[a-z]+)(?=.*[\\d]+[A-Z])(?=.*[A-Za-z ])([a-zA-Z\\s]+)[0-9a-zA-Z$]*\"",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "/^(?=.*[a-z])(?=.*\\d)(?=.*[A-Z]).{8,25}$/",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "[abcdefghijklmnopqrstuvw xyz0123456789]|[a-z]|[0-9]+",
        "passed": false
    },
    {
        "id": 2049,
        "completion": "(?(?=.*\\d)(?=.*\\w)(?=.*[\\!@#$%^&*_`-=~_])(?=.*[a-z])[A-Za-z0-9!@#$%^&*_`-=~_]{8,25})(?",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "grid = (([+1-9]\\d?)x3(0-9)?\\d)* Exercise 5: How can RegEx be useful for a Database Administrator in dealing with data loss? Answer: RegEx is useful for a Database Administrator in dealing with data loss because they can use it to efficiently filter and retrieve data using patterns and regular expressions.",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "^0-?\\d{4}-?\\d{2}-?\\d{2}$",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "ORGN100000|EN100000|ES100000Exercise: Write a Python function that takes a list of countries and returns a list of all US Army installations in the country. Answer: def get_us_army_installations(countries): with open('us_army_counties.txt') as f:     us_army = f.read().",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "[(^0-9]{1,3}[0-2][0-9]{3}) or \\d{1,3}[0-2][0-9]{3} or \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "/^(1\\.0|1\\.)\\d{1,5}$/",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "grid_ref = re.compile(\"grid_ref(?:|;|,|)s\\((.+?)\\((.+?)\\))\")print(grid_ref.search(desc))```",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "Regex: [0, -10]\\d{1}Example 2: Assume that a user has set up a two-dimensional GPS coordinate system using 0-0.01 degrees latitude and 120-000 longitude (also known as N, S, E, and W). Your program must use this information to obtain the correct coordinates from this system.- Use regex to parse the user's GPS coordinates and",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "0-10^0-9, 0-10^1-9, 10^0-9, 10^1-9.",
        "passed": false
    },
    {
        "id": 2069,
        "completion": ".000|.001|.002|.003|.004|.005|.006|.007|.008|.009|.010|.011|.012|.013|.014|.015|.016|.017|.018|.019|.020|.021|.022|.023|.024|.025|.026|.027|.028|",
        "passed": false
    },
    {
        "id": 2069,
        "completion": "gridreference <- paste(\"^0-?\\\\d(\\\\d\\\\d-\\\\d\\\\d)$\", collapse='')",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "\\b([1-9][0-9]{1,2}\\s|01[0-2]\\s?[A-Z][0-9]{3}|22\\d",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "^[1-2][0-9][1-9][0-9][0-9][0-9][0-9]\\/[0-9][0-9][0-",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "http://www.regexplanet.com/simple/date/index.html",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "(?i)(?:([1-9][0-9]|[2-9][0-9]|1[012])\\/[4-8][0-9]{4})",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "\\b(?!.*[0-9]{2}[0-9]{3}\\b)(?!.*[0-9]{4}[0-9]{2}\\b)(",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "^(11|12)(\\d{4})?(?:\\s|-|)/([0123456789]{2}\\d{4})$",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "(?<month>\\d{2})\\D(\\d{2})\\D(\\d{4})$Explanation: ?<month>[0-9]{2}",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "/^(\\d{2})(\\d{4})([A-Z]{3})\\.(\\d{4})$/",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "(0[1-9][0-9]|1[0-2])\\/(19|20[0-9])",
        "passed": false
    },
    {
        "id": 2083,
        "completion": "^[1-2][0-9]\\d{0,2}\\b      # valid MM/YYYY|                       # OR^([0-9]{2})[",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "\\d{3}\\.?[a-z0-9]*",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "[\\x1b\\[(\\d\\d)(\\d\\d?)[A-Fa-f\\+/\\-]?]",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "[a-fA-F0-9]{3,6}",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "/([0-9]{1,3})/(?!\\d)",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "xxx-xx-xx",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "[^0-9a-zA-Z/_-]{0,2}[0-9a-zA-Z/_-]*(#)?[^0-9A-Za-z\\s]  OR [^0-9a-zA-Z\\s/_]{0,2}[0-9a-zA-Z/_]*(#)?",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "#([0-9a-f]{1,4})([A-Fa-f0-9]{2})",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "[0-9a-fA-F]{3,6}",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "r\"^[0-9A-Fa-f][0-9A-Fa-f]{0,2}$\"",
        "passed": false
    },
    {
        "id": 2086,
        "completion": "/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$/",
        "passed": false
    },
    {
        "id": 2087,
        "completion": ".at least one non-captial letter and at least digit. (non-captial \\w)5..at least one non-digit character and at most 10 digits. (non-digit \\d|[1-9]\\d{1,9})",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "([A-Za-z][A-Za-z0-9]{5,9})5-digit random digit Question 1 of 10. What is the sum of all numbers from 1 to 999? Answer: 5,000",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]+",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "((?=^[a-z])(?=^[0-9])) + Exercise 2: Validates a password for at least 8 characters with 1 digit.Answer: (?=.{8,})(?=.*[0-9]) Exercise 3: Matches password that has either digit or at least 3 charactersAnswer: ((?=.{2,})(?=.*",
        "passed": false
    },
    {
        "id": 2087,
        "completion": ".*([a-zA-Z0-9]{1}(?![a-zA-Z0-9])(\\d?)){4,6}.*",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])[0-9A-Za-z]{5,}$",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "#import regexregex=\"(?=.*[a-z])[a-z][0-9]{2,6}[a-z]*\"",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "(?![^a-zA-Z])(?=.*[0-9]).{6,100}",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "[^a-z]([a-z](0|[1-9][a-z]))|[0-9]([a-z]))",
        "passed": false
    },
    {
        "id": 2087,
        "completion": "PasswordOf6Symbol.*8AExercise 4:Describe what the RegEx should match in a password.Answer: at least eight characters long and at most 20 characters long, a mix of uppercase and lowercase letters, digits, and symbols.",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "0-59\\: minutes 0-59 AM,0-59: seconds 0-59,AM|AM|NAM",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "([IoU 0-35]) Description:  the area of a bounding box is greater or equal to 0.35.",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "0([01]?[0-9]|2[0-3]):[0-5]?[0-9]\\.[0-5]?[0-9]\\.[0-5]?[0-9]\\.[0-5]?[0-9]|2[3-1]\\d:[0-5]?[0-9]\\.[0-5]?[0-",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "(00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)|_(01|02|03|04|05|06|07|08|09|10|11|12|13|14|15",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "^^((((1|2)0\\:\\d)?[|](1=AM|PM))|([1|2]\\d))^$",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "^[0-5][0-9]?[0-9][a-zA-z]{0,2},\\s\\d{2},\\s\\d:[a-zA-Z]{2} \\d{4}:[a-zA-Z]{2}$    ^[0-5][0-9]?[0-9][a-zA-Z]{0,",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "(?P<hours>[1-2][0-9]|3[0-1])(?P<minutes>[0-5][0-9]-)?(?P<seconds>[0-5][0-9])(?P<am|pm|AM|PM)?",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "01:00-21:59The colon is used for ranges: [range].I am thinking to do a regex to check for the day of the month, e.g. 01-22. Or 02-26. There are other examples here: Generate Regex to Extract a Date From a StringA day of the month can be also written as a date pattern (such as 01-31, 02-30, etc.).I know",
        "passed": false
    },
    {
        "id": 2090,
        "completion": "^(1|2)\\d{1,2}:\\d{2}:\\d{2}(:?am\\s)?(:?p\\\\u0444)$",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "0.00.01.01.02.03.04.055.06.07.08.00.09.0.2.3.8,0.1-0.2",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "^[9-9][1-9][0-9]*$I don't see a good reason to use this RegEx as it will make the currency detection slower for the user. Anybody has a better example? :/edit: The user has deleted a few posts so this should be considered for a few users./EDIT:You don't need to use regex for this, you just need",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "$(document).ready(function(){  $('#payout').change(function(event){    event.preventDefault();    event = {name: \"payout\",\"value\": \"123456789$\"};    var amountOfCurrency = event.value.replace(/[^0-9]/gi,'');    var regex  = /\\d{8",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "import regex as reexpression = re.compile(r'^\\$([-0-9\\.]+)\\$')",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "(set to decimal(0,9))and(checkstring todec(0,9))and(checkstring not decimal(0,1))and(checkstring not decimal(0,8))",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "'(10k|20k|100k|1000000)'    '''",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "$[\\d\\,.]",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "regex = \"(^\\d{1,3}\\.?\\d{3})\\/?[a-z]{2,6}$\"",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "r'^[0-9]+(.[0-9]+)?$'",
        "passed": false
    },
    {
        "id": 2095,
        "completion": "(?=(\\d\\d,))            |            #OR                 \\d|                  .,       #Period followed by comma and decimal        \\.'       #Period followed by decimal    {4}       #Exactly 4 characters    \\s       #space character",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "[0-9]{2}[.][0-9]{3}[.][0-9]{4}",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "\"^[0-9]{2} [A-Z][0-9]{2}  [[0-9]{1,2}/[0-9]{1,2}/'2021]$\"",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "\\b(?P<month>\\d{1,2})\\s*[-/](?P<day>\\d{1,2})\\s*(?:[a-zA-Z]|(?:\\w)-)?\\s*(?P<year>\\d\\d\\d)-(?P<day_of_week>\\d)",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "rd\\D*m\\D*y\\d\\D*",
        "passed": false
    },
    {
        "id": 2103,
        "completion": ".*([0-9]{2})\\s|([0-9])?[0-9]|[0-9]{4}[0-9]\\s|[0-9]{4}",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "^(0(1[12]|[13][0-9])|[1][2][0-9]|0[1-9])(/(?:[1-9][0-9])|[12]\\d)$3. Use RegEx to validate passwords with at least eight characters, a combination of letters and numbers, and are not all lowercase.Answer: [a-zA-Z\\",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "import reday = 'Wednesday'month = 'March'year = '2023'pattern = '^(19|20)\\d{2}(st|nd|rd)?$'regex = re.compile(pattern)result = regex.match(day +'' + month +'' + year)if(result!= None):    print('A date was formatted correctly!",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "[0-3][0-9]|4?[0-2][0-9]",
        "passed": false
    },
    {
        "id": 2103,
        "completion": "^([0-9]{2}\\s)?([A-Za-z]{1}\\s)?([0-9]{4})$",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "a) \\d+\\.\\d+e1?$  If there isn't a pattern, it will return false for either.",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "/(^|\\s)\\d+(\\.\\d+)?([eE][+-]?\\d+)?$/.test(input)",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "/^\\-?(?:(?:[1-9]|1?\\d*(?:[0-9]|\\.)*)(?:\\.[1-9]+)?|0|\\d+)\\z$/)",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "([-+]?\\d[.]+|\\.\\d+)\"",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "^[0-9.]+$",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "^[-+]?[0-9]*\\.[0-9]*$",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "^[+-]?(?:\\d+)?(:?\\.\\d*)?$",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "-?(?:\\d(?:\\.\\d+)?|\\.\\d+)(?:[eE][+-]?\\d+)?",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "^[+-]?[1-9](\\d*\\.?\\d*)|1(\\.\\d+)|[-+]?(\\.\\d*)(\\d+)Example: \"5e9\" matches.",
        "passed": false
    },
    {
        "id": 2116,
        "completion": "var re =/^\\+?(?:(-?\\d*\\.\\d+)|(?:\\.\\d+))$/s;",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: If it matches any kind of URIs - https://pobox.org, ftp://www.foo.com, mailto:user@foo.com - this is it. You can generalize it with a bit more code - if [a-z] is your character class, and then. is any character except the newline (if you want your regex literal - \\w",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: ^[a-zA-Z0-9.\\-\\?\\:,\\s\\.\\_\\#\\(\\)\\`\\$\\%\\^\\&\\*\\(\\) \\+\\=\\-_\\!\\(\\)/\\(\\)\\:\\\\\\|\\~\\`\\_\\#\\(\\)\\#\\(\\)\\:\\\\\\\\:\\\\\\\\",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: \\b(http|https|ftp|localhost|www)[^\\.]*[^\\.]*\\.[^\\.]*\\/\\S*\\S*",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: (e.g. (?i)^(?:^[^: ;\\n.]*\\.)?[a-zA-Z0-9-_\\\\.]+\\.[a-zA-Z0-9-_\\\\.]{2,6}(?:/[^: ;\\n.]*\\.)?Note the negative lookarounds:",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: (S|s)ftp(\\.[A-Za-z]+)+",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: /([-\\w.]|www)\\.[-\\w.]*?\\.",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: r\"https?://[\\w.,/\\?:\\~\\%\\$\\^\\*\\+\\-\\(\\)\\{\\}\\:\\;\\]<>_`{|\\}~]+\"",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: (http[s]|s/ftp[s]/)(:/)(\\.)+(/.*)",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: \\b[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-.]+)*\\b",
        "passed": false
    },
    {
        "id": 2117,
        "completion": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.Generate a RegEx for this description. Answer: /[^\\s>]*(mailto):[^\\s>]*(http|https):[^\\s>]*(ftp|sftp|https)[^\\s>]*\\b(www|\\w[\\w\\d\\_\\-.]*\\.[^\\s>]*)?/;",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}\\.\\d{3}",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "The pattern should be \"\\d{4}-\\d{2}-\\d{2} (\\d\\d:\\d\\d:\\d\\d)\"",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "*(.*).*",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "[^,]+\\.\\d{4}-\\d{2}-\\d{2}\\.\\d{2}\\.\\d{2}\\/\\d{2}\\/\\d{4}\\s",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "\"^(\\d{4})-(\\d{2})-(\\d{2})\"",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "(00:00-23:59)+M*((00:00-01:00)*24*3600 or 00:00-00:00)*24*3600",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "(?<date-time>((?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d{2})) (?P<time>\\d{2}:\\d{2}:\\d{2}))",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "r'^.{5,15}-(?:[0-9]),([0-9])$'",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "[yyyy_mm_dd_HH_{yyyymmdd}-HH_{hh}_ss]{3}",
        "passed": false
    },
    {
        "id": 2118,
        "completion": "In this exercise, we need to develop a RegEx for the URL of the event. The URL should start with '/', be followed by a letter or underscore, and lastly include a number between 0 and 9.",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "/^[5-9]\\d\\d([A-Fa-f]{2}|\\d{2}|\\d(\\d{3}))[0-9a-f]{2}$/.",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "regex = re.compile(\"([a-f0-9]{3}[:-]){3}([a-f0-9]{3}(\\D|$)){5}\")This generates a line-by-line summary of all MAC addresses that matched the pattern and stores it in the array \"matched_macs\". It also groups MAC addresses by length and stores them in another array \"len_macs\". Finally,",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "#CiscoAddress\\s*(?=\\s*((\\d{3}|[1-9]\\d|1\\d\\d\\d)(?:-((\\d{3}|[1-9]\\d|1\\d\\d\\d)(?:-((\\d{3}|[1-9]\\d|1\\d\\d\\d)\\))?)?)?)?)?)?)?)(\\s*",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "/((\\d{1,3}\\.){3}\\d{1,3}).*\\bmac\\b/",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "(regex='(?P<macaddr>\\S+)[^:]+[^:]+(?P<segments>(:|[^:]+):)|(?P<segments>\\S+)[^:]+[^:]+(?P<interface>[^:]+):')",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "/^(11|12)([1-9][0-9]|[1-9]0)$/",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "This RegEx should match the string \"CiscoIOS1.1.1.1-AP0-1\" in modern MAC addresses.",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "\\b(?=\\[)(?=\\])/\\d{1,2}\\[[0-9a-fA-F:.]+, [0-9a-fA-F]+([:.]+){1,3}/\\d+([:.]+)\\]\\b/",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "MAC\\s\\d+",
        "passed": false
    },
    {
        "id": 2123,
        "completion": "(\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}\\.\\d{1,2})([A-Fa-f0-9]{1,4}|[A-Fa-f0-9]{1,2})",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "\\w{1,}[^\\w{1,}]|^[^\\w{1,}]\\w{1,}",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "/^\\S$|\\S[\\S]*(\\.\\S){4,}$/",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "(?:\\w*[\\w_]?\\w*|\\w+|[^\\w\\s]*|[\\w-]*[\\w-])",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "^\\*\\?([a-zA-z0-9].*?)$",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "^[*=]*",
        "passed": false
    },
    {
        "id": 2130,
        "completion": ".+?(?<=)(?=(.|?.)*$)(?:(\\*)|(?&))",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "r'[^\\W\\d_]{{1,}}[a-z]{{1,}}' will match strings of one or more letters and possibly zero digits or underscores.",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "\\w*(?=.{35})",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "The regular expression would be [a-zA-Z\\.?0-9]. This expression would match up to and exclude any combination of letters, numbers, commas and periods (including at least one of each) in the given search string.\"",
        "passed": false
    },
    {
        "id": 2130,
        "completion": "(?<![^0-9\\-_\\.\\,\\(\\)])([a-zA-Z0-9\\-_\\,\\(\\)\\.]{0,25})Explanation:",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "^(?=.{1,60})(?:.|0)*?(?:\\.(\\d)){2}$",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "^\\d{0,2}\\d{2}(?:\\.\\d\\d)?$Exercise 2: Write a RegEx for a string that will not start with 'aaa'. Answer: A{3,}",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "\\b\\d{0,9}(?:\\.\\d{0,2}\\d{0,2}\\b)",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "/^[1-9][0-9]{0,2}(\\.[1-9][0-9]{0,2})?$/",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "(?=[0-9]{3}$)\\d{3,10}",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "^(?:\\d{1,9} | \\d{3,6}\\.\\d{1,2}$)",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "(?<=\\.[0-9]{10})\\..{2}",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "/^(?=^\\d*$)(?=(^\\d{1,2}(?!\\d)){1})(?=(^\\d{1,2}(?:\\.\\d{1,2})?)(?=^\\d*$))/",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "^[\\d ]{10}(\\.\\d{0,2})?$",
        "passed": false
    },
    {
        "id": 2136,
        "completion": "(^(0+\\d{1,3}(\\.\\d{1,2})?)+)+$Explanation: The above regex will accept an integer greater than 0 and two digits after the decimal point, an integer between 0 and 100 inclusive, and any 0s in between.Example:In:^(0+\\d{1,3}(\\.\\d{1,2})?)+$Out: \"",
        "passed": false
    },
    {
        "id": 2143,
        "completion": "123[.\\d]",
        "passed": true
    },
    {
        "id": 2143,
        "completion": "[01] followed by a space, followed by an integer,then a dot, followed by an integer. i.e. (0[o-o])1[0-9][\\.]0[0-9]",
        "passed": false
    },
    {
        "id": 2143,
        "completion": "123.\\d\\d.\\d\\d.\\d\\d.\\d\\d123.23 and 123.0 are valid, but 123123.123456 is unacceptable since it contains more than 19 characters after the first 2 digits, and not a maximum of 10.In the above case, the expression is generated using the | operator, which means that any one of the specified options is acceptable.However, the expression generated using the + quantifier will",
        "passed": true
    },
    {
        "id": 2143,
        "completion": "(123[.])456(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 2143,
        "completion": ".01,.03,.15,.22,.2345,.3456123123.1234123454565678678998765",
        "passed": false
    },
    {
        "id": 2143,
        "completion": "\\d+\\.\\d+",
        "passed": false
    },
    {
        "id": 2143,
        "completion": "[\\d.]+",
        "passed": false
    },
    {
        "id": 2143,
        "completion": "^(0?9\\\\d+)(0?|\\\\.3\\\\d+)(0?|\\\\.12\\\\d+)|\\\\d+$",
        "passed": false
    },
    {
        "id": 2143,
        "completion": "(\\d{1,2}(\\.\\d+)?){0,18}\\d{0,10}\\n\\nThe example you provided above is the same input that you've been using right up until now. I'd be obliged to update",
        "passed": false
    },
    {
        "id": 2143,
        "completion": "(0|1|2|3|4|5|6|0|1|2|3|4|5|6|8|9)\\\\d*\\\\.(0|1|2|3|4|5|6|0|1|2|3|4|5|6|812|345|456|567|678|9|1)\\\\d+?(0|1|2|3|4|",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "(?: ^[a-zA-Z0-9]\\w*[-._%&()\\[\\]\\^`!{'<>,`<>?|~:]*$ )?(?<![\\w]*\\.)$",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "^[A-Za-z0-9.-_]*$",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "(?<!^[a-zA-Z0-9._-])([a-zA-Z0-9._-]+)(?![0-9])",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "^[a-zA-Z0-9\\s\\(\\)\\-_=\\~\\$]{2,}$",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "Regex:^\\S+$",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "[A-Za-z0-9@#$?\\.\\!]",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "^([a-zA-Z0-9_]|[\\$\\#\\@\\^\\&\\(\\)\\.\\?\\\\!\\-/\\\\\\\\\\)\\{\\}\\]|([a-zA-Z0-9_\\-\\.,\\:;=?\\+\\*\\&%\\$\\{\\}\\(\\]<>",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "(?i)\\b(?!\\w+\\s)\\S+[a-zA-Z0-9\\-_]+\\b",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "/(^(?![^a-zA-Z0-9 ]+$)|(^([a-zA-Z0-9_]+)$)|(^[0-9]$))/Here, (^(?![^a-zA-Z0-9 ]+$)|(^([a-zA-Z0",
        "passed": false
    },
    {
        "id": 2145,
        "completion": "-^[a-zA-Z0-9 -_@\\.]*$",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "^(http\\/(?:www\\.)?[a-zA-Z\\.]+))$Question 9: This regex will break down a domain into an IP-address/port",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "(http|https|ftp)=(?:www\\.)*(www|sub|domain|tld)+(\\.com|\\.net|\\.org|\\.gov)*",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "\\bhttps?://\\S\\.?\\S+\\S*(?:-[A-Za-z0-9\\-]?[A-Za-z0-",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "a+b(?:\\.[a-z]+)+c",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "(?:www\\.)?\\S+",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "(http[s]?|ftp[s]?|www|[a-zA-Z0-9\\-\\.]+\\\\.com)https.Thanks a",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "If the URL starts with http/https/ftp it will probably match it. It will also generally work if the URL is www.example.com, but the www may or may not have",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "^(www[.+\\-a-zA-Z0-9]){1,}\\.[a-zA-Z0-9]+$http:\\/\\/[a",
        "passed": false
    },
    {
        "id": 2149,
        "completion": "\\bhttp[s]?://(?:www\\.)?([\\w\\.-]+(?:\\.[\\w\\.-]+)*$)(?:\\.[a-z][a",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "*?-? Non-Mime Mail Messages -*? */",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "For MIME Mail Message, use (\\\\w+)\\\\s?(?:\\((\\w+),?\\.(\\w+)\\))? to match the mail message content-type. For Non-MIME Mail Message, use \\\\w+\\\\s?\\\\+ to match the content-type of the message that contains the same data but is not a plain email message.",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "[Code](https://regex101.com/r/7s7nG7/1)",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "Content-Type/(\\S+)\\|Non-Mime Mail Message|^",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "(r'MIME:.*\\r\\n\\r\\n(Non-MIME)*')",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "This regex will match ANY MIME message and NON-MIME message, regardless of format. Solution: r'^(Text/plain;|XML;XML-XSLATE;|XML-HTML-XSL;|Image/gif|Image/jpg|Image/jpeg|Image/png|Document/word|Document/spread|Document/tab)|$'",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "Content-Type = text/plain",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "import remail_message_string = \"Hi, my name is Sarah and I like dogs. Thanks for the invitation to my birthday party!\"matching_string = re.search(r'\\b[A-Z][a-z]+[a-z]\\b', mail_message_string)non_matching_string = re.search(r'\\b[^\\s]+[^\\s]+\\",
        "passed": false
    },
    {
        "id": 2152,
        "completion": "- A MIME Mail Message - MIME (message-invocation mediums-intermedia message-element types)- A Non-MIME Mail Message - (anything that's not a MIME mail message -- like a word file or image file)",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "/(\\d{3})\\-(\\d{1,2})/",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "[MM]?? [DD]?",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "\\b\\d{1,2}\\:\\d{1,2}\\:\\d{1,2}\\b",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "\\d{1-3}/\\d{1,2}/\\d{1,2}/\\d{4}",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "[r'^M((\\d\\d|\\d{1,2})(-\\d\\d),(\\d\\d|\\d{1,2})(-\\d\\d))$']import numpy as npfrom sklearn.model_selection import train_test_split, GridSearchCV",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "-?(\\d{4})-?(0?\\d)?-?(\\d{2})?-?(\\d{1})? (AM|PM)Since the question doesn't specify, I assume 'AM' = 12AM, 'PM' = 12PM is correct, so this should work: -?(\\d{4})-?(0\\d)?-?(\\d{2})?",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "(0-2)(1[0-9]|3[1-9]|[12][0-9]|31)-(0?[1-9])|31.",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "^[0-9][1-9]|[1-9][0-9]",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "",
        "passed": false
    },
    {
        "id": 2153,
        "completion": "^(0?[1-9]|1[012])[-0-9]?[12][0-9]|1[012]$",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "^\\s*//$|^![a-zA-Z0-9_.-:~|\\?{}}]*\\n\\s*\\S+",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "[^#]*",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "r'^This is a.*RegEx'",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "\\s+  # Whitespace character",
        "passed": false
    },
    {
        "id": 2155,
        "completion": ">>> rx = re.compile('^(\\s|^)(\"[^\"]*\"|(?<![0-9])\"[^\"]+)($|\\s)', flags=re.MULTILINE|re.MULTICHAR)Explanation: The regex matches one or more of one of two types of quotes (single-quoted or double-quoted) preceded or followed by whitespace or a newline. The flags re.MULT",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "r'^//.+$'",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "re-litre_number = re.compile('(^|,)\\d+(,\\d+)*\\.?\\d*$')",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "r\"^\\s*\\(\\s*#.*\\s*\\)$\"",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "def parse_arguments(arg):  \"\"\"\"Parses an incoming command-line arg for an identifier from the argv, and returns it. Assumes command  was called using ``python script name.py arg_name arg_name``\"\"\"  return 'parse_arguments({})'.format(','.join(arg).strip(' \\n'))",
        "passed": false
    },
    {
        "id": 2155,
        "completion": "You will generate a RegEx that matches either a single line or a multi-line comment followed by an indented comment (starting with \"#\") and a single space.",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "^(?:(?:/)?#{spacingGenerate}).+$",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "[A-Za-z0-9]\\{([A-Za-z0-9])\\}(?!\\.)",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "/(?P<spaced>[^ -<]+)-?(?P<open>[^<>]+)<(?P<close>[^>]+)>Description: A number is allowed where there is at least 1 space between each part of the description except for the first one. It must start with the character \"BFPO\"Explanation: The regex pattern will match from the first space to the first closing tag (even though it should actually be inside",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "(0\\\\d+|1\\\\d{3}\\\\d|2\\\\d{4}\\\\d|3\\\\d{2}\\\\d)",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "^(?:\\d|\\s)*$",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "(\\s|\\s)",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "/^(?P<chars>\\^(?:[^\\^](?!\\^))*)(?P<numChars>\\d+)(?P<spaces>\\s+)?$/",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "/(^|\\s|\\(|\\))[^ ]*[^)]*\\s\\([^)]*\\)/",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "/(A\\d)(B\\d)/g",
        "passed": false
    },
    {
        "id": 2157,
        "completion": "(.*)",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer: For describing minimum password length, use \"^(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\d]{7,}$\" and for minimum non-alphanumeric characters, use \"^(",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer: minRequiredLength = 7, minRequiredNonAlphanumericCharacters = 1, pwRegex = new Regex(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer: ^(?=.*\\d)(?=.*[a-z])(?=.*[@#$%^&+=]+)(?=.{7,20})$",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer: Validating Password for.NET MembershipProvider ValidatePassword. Minimum required password length: 8 characters. Minimum required non-alphanumeric characters: 1 of [P, a-zA-Z0-9] (case-insensitive).",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer: https://regex101.com/r/6KnKH8/21",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer:(?=.{MINReqNonAlphanumericCharacters}$)(?(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&+=",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer: ^(?=.{8,})(?=.*[a-z](?=.*[A-Z])(?=.*\\d)(?=.*[$_@\\`!#\\$%\\^&\\*\\(\\)\\",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer: [^0-9a-zA-Z\\s]{1,6}.[^0-9a-zA-Z\\s]{1,2}",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer:(?=.*([a-z]))(?=.*([A-Z]))(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{7",
        "passed": false
    },
    {
        "id": 2160,
        "completion": "Regex to validate strong password for.NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.Generate a RegEx for this description. Answer:     validatePassword: function() {        var regex = require('regex');",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "[0-9]{2}:[0-9]{2}|[0-9]{2}:[0-9]{2}:[0-9]{0,2}|[0-9]{2}:[0-9]{2}:[0-9]{0,2}|[0-9]{2}:[0-9]{2}:[0-9][0-9]:[0",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "[0123456789]",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "^((\\d{1,2}):(\\d{2}))$",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "var regex = new RegExp(/(\\d{2}):(\\d{2})\\s*$/, 'g');",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "\\d{1}:\\d{1}",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "I can use this Regex: t = \\d{1,2}:\\d{1,2} (Example: 06:23),  where t = 00-07-2021 will pass, t = 01-07-2021 will Not pass (and may be even a valid hour) t = 01-05-2020 (will pass)  Where the upper bound: 2 will be a digit, and the amount of digits before the colon will be between 1",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "```import re def valid_time(time_str):    if re.match('^\\d{2}:\\d{2}$', time_str):        return True    else:        return False print(valid_time('10:15')) # Falseprint(valid_time('12:00')) # Trueprint(valid_time('13:44')) #",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "^\\d{1,2}:\\d{2}\\s\\d{4}$",
        "passed": false
    },
    {
        "id": 2161,
        "completion": "/^([0-1][0-9]?|2[0-3])\\/([0-5][0-9])\\/([0-9])([0-9])$/ (A digit between 00 and 01 is added after ':' to cover even numbers less than 12)",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "d{1,9}\\.9999[,\\d]'",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "Regex will be (\\-?\\d+[.,]\\d{1,2})?",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "[^.\\s\\d]{,3}.{,2}(?:.|[^\\d.\\s])* Exercise 2: Find all email addresses in a paragraph using this RegEx: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-z",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "d[\\d,]{1,21}",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "([1-9]\\.){0,2}[0-9]",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "^\\d{1,2}\\.\\d?[1-9]{0,3}$ or ^\\d{1,2}(\\.\\d{1,2})?$",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "(.*)([0.-][0.,]{1,2})(.*)",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "`^(00\\d{1,2},)?.{1,nGenerate}\\d[,.]\\d{1,2}$`",
        "passed": false
    },
    {
        "id": 2190,
        "completion": "\\d+(?:,\\d{1,2})+\\.\\d{0,4}",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "[ ](7[7-9]|8(91))[ ](0(1[1-3]|2[048]))$",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "(\\+2)?[5-9](0[1-9]|[1-9])[0-9]{0,9}[#0-9]{3}This regex matches both the +2 prefix and the country prefix for a telephone number. It requires the two numbers to be separated by a comma",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "(222)?[0-9]{{3}}[0-9]?(?:[0-9]{3})?[0-9]-9(0-9)|(22[0-9]2)?[0-9]{6?}[0-9]{6-10}",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "(222-555-1111)",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "(\\(\\d{3}\\)|\\(([1-9]\\d|2[0-3]\\d|25[0-5]|2[0-4]\\d|1\\d\\d\\/1[9]\\d|1[0-9]\\d\\/[12])\\)\\",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "^(\\+\\d{1,2}|2[1-9]|[35]\\d{2})[-.\\s]?\\(\\d{3}\\)\\s?(666|666\\d{2,3})[-\\s]?\\d{3}[-\\s]?[",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "5(444)6(3)8(0)XXXX",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "^\\+4[1-9]|[1-9]\\d{2}[- \\w\\d]{0,2}[- \\w\\d]{0,2}$",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "(\\(\\d+\\))\\+2([A-Za-z0-9?.]{5,10}) Explanation: The parentheses capture all the country prefix plus two in the phone number string. The parenthesis with the extension code capture two digits. You can repeat this pattern with either plus two or plus",
        "passed": false
    },
    {
        "id": 2201,
        "completion": "^(\\+22|\\+22\\d{1})\\s(\\d{3})(.\\d{2}|.\\d{4})$",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "(^[+\\-]?\\d{1,3}[.]?\\d{1,4}[.]?\\d{1,4}$)",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "^(00[1-9]|[1-9][0-9])((-)00(1[2-9]|[012])(-)00$",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "\\d{1,3}[.\\s](\\d{3})[.\\s](\\d{3})[.\\s]This example works for any international phone number containing only decimal characters and numbers plus some optional extensions.",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "\\b\\d*\\.?\\d(\\d*)(?:[_-]\\d*)*$",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "[\\D+-](\\d(?:\\.\\d{1,2})?)?(?:-)?\\d{3}$Now that we had our Regex, we needed to make sure that we were generating a random string of country code. To do this, we made use of the random package in Python, which allowed us to generate random codes using the secrets API",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "#(?=\\(\\D+\\D*\\(:\\D*\\)\\D*\\)))",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "[^01]|(?:[^-]|-{3})*$",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "^.+?[\\ +.-](?(1)0[0-9]0[0-9]+$|[0-9]{8}$)(?(2)0[0-9]\\d+[\\+.-]0\\d+)|([0-9.]+[,.]+0\\d+|0\\d+[,",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "^[1-9]{1,2}([1-9])[0-9]{3}(\\.1)?$",
        "passed": false
    },
    {
        "id": 2203,
        "completion": "^(\\+\\d{3}\\.)?((1[\\d]{3}\\.){2}\\d{4}|(1[\\d]{3}\\.))(2[\\d]{3})$",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "(?P<h1>\\d):(?P<min>\\d).(?P<time_type>[am|pm]).",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "hh[0-5]{2}([ap][mM]|am|pm)i",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "/^([1-9][0-9])(?:[0-9]+[0-9][0-9]|2[0-3][0-9]):([0-5][0-9])[ap]$/If we have a string like 0159, the match is ^([1-9][0-9])(?:[",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "hh\\d\\d(:|\\.\\d)?(am|pm)",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "(hh and mm) - hh.*([pm])(m*)?",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "var time = \"01:00 am\";var pattern = @\"\\d\\d:\\d\\d:\\d\\d am (\\d\\d\\.?\\d?) pm\";var matches = Regex.Matches(time, pattern);if(matches.Count > 0) {    if(matches.Item(0).Trim().Length >=",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "/hh:mm(.?|am|pm)/g",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "/^([01]\\d|2[0-3]):([0-5]\\d)$/",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "(04M-00:00) I have started my homework assignment.",
        "passed": false
    },
    {
        "id": 2206,
        "completion": "hh_minutes_tt",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "'((\\(\\s*(\\w+)\\s*\\))+)\\s*' or '((\\([^()]+\\))+)\\s*'",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "(\\d{4})/(\\d{2})/(\\d{2});",
        "passed": false
    },
    {
        "id": 2213,
        "completion": ".*)(?<!\\\\()I got this one working. https://regex101.com/r/eO0wE5/1 I would also appreciate it if people explained why I got it right. I have been trying to wrap my head around it but I can't.",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "(?<p>)(find any text\\s*within\\s*parenthesis)",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "[\\(][ \\t]+ [\\\\d]+ [\\)]",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "\\(([^\\)]+)Explanation: This should find any number of characters (not including ) that are not inside of parenthesis.",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "\\\\(.*\\\\)The. * matches any character within the parenthesis.",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "<.+?>",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "",
        "passed": false
    },
    {
        "id": 2213,
        "completion": "(\\((.*?)\\))\")]",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer:(?xmx)([^.\\s/?;,\\-\\s\\[\\]\\(\\)~\\!\\*]+)",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer:  ^[^/\\\\-_\\.]+(?:\\\\[^/\\\\-_\\.]+)*$",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer:^(?P<root>\\[?.)?(?P<path>[a-zA-Z0-9\\-\\.]*)?(?P<extension>\\",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer: ^(?:-)?(?:\\/|\\|)?[^\\?]*(?:\\?|[\\?]?)$",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer:[A-Za-z0-9]+\\\\.[A-Za-z0-9]{1,2}[-_\\.]?[A-Za-z0-",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer:^(([^\\\\/]*[^\\\\/]+[^\\\\/]*[^\\\\/]+)\\\\.[^\\\\/]+ [^\\\\/]*)/$",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer:^([a-f0-9]*\\.|[a-f0-9]*\\/)?[a-f0-9]{2}[a-f0-9]{3",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer: (^\\S+[^/\\s-]{2,3})(?!.*)(.*$)\\b[\\/\\_.]*$",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer: ^[^\\\\/]*[ \\\\/][a-zA-z0-9]{2,3}[\\\\.\\\\-]?[a-zA-z0-9]",
        "passed": false
    },
    {
        "id": 2215,
        "completion": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _. or - in the path, this will be updated at some point.Generate a RegEx for this description. Answer: /([A-z0-9]*|[A-z0-9]{1,2}|[A-z0-9]{3,4})$/",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "[0-9]{2}[01]|17[012]",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "(MONTH(19\\d)\\d\\d)+(50)The following are the possible answers of this part:| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 2 | 3 | 4",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "(RegEx) [0-2].{3,8}(.+?)1953(.+?)\\r\\n\\r\\n?1.",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "[a-z]{1}-\\d{3}-\\d(?=\\d{3}|$)-Explanation: [a-z] starts with a-z character.-\\d{3} matches up",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "(m/i-1/20).+5/0/1/2",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "[\\d{2}]\\d{0,2}-\\d{0,2}\\d{2}[\\s-\\d]{4}",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "PIN regex = \"\\b(0[0-3])\\d{2}+\\b|\\b(\\d{3}}\\b\"",
        "passed": false
    },
    {
        "id": 2218,
        "completion": "(?P<month=3>[0-9])\\s?(?P<year>[0-9])\\s?(?P<digit>[0-9]{2})(?P<suffix>[M-]\\s?[",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this command",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this.",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this construction",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this number",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this regex",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this construct",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this command",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this one",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this construction",
        "passed": false
    },
    {
        "id": 2222,
        "completion": "SUPPORTED constructions:[*] - all five commands;[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);[*/nubmer] - see construction [number];[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).NON SUPPORTED constructions:[number-number] and[number,number].Generate a RegEx for this,",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "^(?=\\S*[^\\t\\n])(?!^)((?=[A-Z])(?:\\d\\d[A-Z]\\d\\d[A-Z]\\d\\d\\d$)|(?=\\d\\d\\d[^\\t\\n])(?=(?!\\S*[A-Z])(?:[A-Z]*\\d[A-Z]\\d\\d\\d\\d$)))[A-Z",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "[A-Z]+",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "-case sensitive (lower)!Generate a RegEx for this description",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "(c. upper &&!(d.*c)&&e)  or  (c.upper &&!(d.upper && e))",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "[A-Z_0-9]{3}\\! (upper).",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "^A-Z[A-Z]{6,30}$",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "[^a-zA-Z0-9]",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "_",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "\\b(?=.+)[a-z]+\\d+\\b",
        "passed": false
    },
    {
        "id": 2223,
        "completion": "",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "(\\w\\w\\w)(-)(\\d)(?:-?\\d)(?:\\d{3})?(?:\\d{3})?(\\.\\d*)\\.(\\d*)/ig",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "\"^[A-Y]1[0-9]?$|^[a-y][0-9]?[0-9]?$|^[a-z0-9a-z]0[0-9]?$|^[a-z0-9_$][a-z0-9_$]$\" (case insensitive)",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "[1-2a-HJ][1-9][1-8]?[a-f0-9]{2}-[a-z0-9]{2}-[a-z0-9][a-z0-9] {1,2}[a-z]+.[a-z]{5}$(To see a working example, and an explanation of what each part means see here)",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "[a - h]{1,2}(\\d)([a-z]|\\d)([a-z])\\2 {1,2}",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "^(?=.*?[a-z])(?=.*?[A-Z])(?=.*?[1-8])(?=.*).{10}$",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "[a-h]\\\\d+ [1-8]",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "function getRandomAlphaFn(a, h) {  var number = Math.floor((Math.random() * 10 + 1) / 10);  var alphabets = \"abcdefghijklmnopqrstuvwxyz\";  var RegEx = a + \"((\" + alphabets.split(\"\").map(function(e,i) {    return e.toLowerCase()+number.to",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "",
        "passed": false
    },
    {
        "id": 2224,
        "completion": "[a-z]+",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "\\d{1,6}",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "[\\d*\\.]{18}",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "\\d{1,65536}",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "The RegEx for the specification of the communication ports can be \"^[A-Z]{4}-\\d{1,3}\\.*\\w+$\". This RegEx searches for any alphabets in the first three positions of a string, followed by digits less than 6 characters long, followed by any alphabets or other characters, and ends with the same alphabets again.",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "\\b(1 2 3 4 5 6 7 8 9 0|1-127)\\b",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "ports=(\\d){1,6}",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "(?=[A-Za-z0-9_-])[A-Za-z0-9_-]{2,56}",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "(?P<vlan>\\d+)\\.\\d+\\.\\d+\\.\\d+\\.\\d+| (?P<cid>\\d+)\\.(?P<dst_port>\\d+)\\.(?P<protocol>\\w+)",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "/\\b[A-G]{2}:?(\\d|\\d\\.){2}/",
        "passed": false
    },
    {
        "id": 2241,
        "completion": "r'\\d{1,3}|\\d{1,3})(\\-\\d{1,3}|\\d{1,3})(\\-\\d{1,3}|\\d{1,3})?$'",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "(?:\\.\\w+[DE])?",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "\"\\^(\\*|\\$|\\^)\\+?[0-9]+\\,?[0-9]*[^.!\\-]\\/([0-9.]*)$\"",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "r\"[\\u2021\\u2034\\u201c\\u2030\\u2019]\\d{1,4}(,[\\d\\u180c\\u200e\\u2028\\u2029\\u210f\\u2001\\u2021]|,[\\d\\u2030\\u201c\\u2031\\u2022])?(:[\\d\\u180c\\u200e\\u2028\\u",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "(?:\\[(?P<SYMBOL>[\\+\\-\\(\\)]){2}\\]|\\((?P<SYMBOL>[\\+\\-\\(\\)]){2}\\))",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "The code would be '^EURUSD=([0-9]+)([a-zA-Z]?)?'",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "\\b\\w+\\s-?\\$\\,?\\s*",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "{% regExp(r\"\\b[1-9][0-9]*\\.[0-9]\\.[0-9]*\\b\", \"euro\"); %}",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "(\\d+)+(.*?)[+()]",
        "passed": false
    },
    {
        "id": 2246,
        "completion": "(?<=\\d)(?=\\s\\.)\\b(EUR|EURO)\\b",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "\"(?i)\\b([1-31]|[0-2]?[0-9])/(2[0-3]|3[01])/(\\d\\d\\d\\d)(?:[,-]\\d{4})?\\b\"",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "`.*(?:\\d{1,2}/\\d{2}/\\d{4})|(?:\\d{1,2}/\\d{2}/\\d{3})`",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "^.*\\d{4}/\\d{2}/\\d{2} \\d{2}.*",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "string format =@\"\\d{2}/\\d{2}/\\d{4}|\\d{2}/\\d{2}/\\d{4}\";",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "(0|1|2)\\d{2}\\/\\d{2}\\/(0?[1-9])\\/|(0?[1-9])\\/\\d{2}\\/(0?[1-9])\\/\\/\\d{4}(\\\\",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "(^(0[1-9]|[12][0-9]|3[01])[-/.]([0-9]{2})$)",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "#DateField >= '1/1/1753' AND #DateField <= '12/31/9999'",
        "passed": false
    },
    {
        "id": 2259,
        "completion": "string pattern = @\"\\d{1,2}\\/\\d{1,2}\\/\\d{4};\\s*AND\\s*\\d{4}-\\d{1,2}-\\d{4}  <= \\d{4,}",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "`.*\\d{1,3}\\.]{1,3}(:\\d{1,2}){1,5}|(\\d{1,2})\\.(?:\\d{3}){3}\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|\\d)\\.(?:[1-9]|1\\d\\d|2[0-4]|1\\d|[1-9]",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "[v4]",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "```pythonregular_file_path = re.escape(\"file:///Users/JohnDoe/Documents/report/report.txt\")ip_pattern = re.escape(\"(192\\.168\\.){1,3}[10-23]\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.\\d{1,3}\")ip_regex = re.compile(r'^{",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "```\"IPv4 and IPv6 are two different ways to treat and transmit network addresses. Both allow data to move over network and can be used for internet security. They are not the same thing.\"```",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "`ip_addr = r'(?:[\\d\\.]+\\.){3}[\\d\\.]+[\\d\\.]+[\\d\\.]+\\.(?:[\\d\\.]+\\.){3}[\\d\\.]+[\\d\\.]+[\\d\\.]+[\\da-zA-z\\-_.]+\\.'`",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "IP Address Pattern (regular expression)```pythonimport re",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|^(?:(?:[1-9]\\d|1\\d\\d\\d|2[1-9]",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "\"(4|5[0-9]|1[0-9]\\d|2[0-4]\\d|25[0-5])\\.168[.](1[0-9]|2[0-4]|25[0-5])\\.168[.](1[0-9]|2[0-4]|25[0-5])",
        "passed": false
    },
    {
        "id": 2262,
        "completion": "- IP V4: ^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})$- IP V6: ^(?:[0-9A-Fa-f]{1,4}:){1,4}[0-9A-Fa-f]{1,4}$",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "(10) (00-05-2017)|(07-01-2017)|(10-07-2017)",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "^(([^\\w\\s]*[:punct:]{0,3})[^\\w\\s]*[@]\\s[^\\w\\s]*[.])",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "/[A-Z0-9_.-~A-Za-z0-9\\?\\=\\/\\-_]+@[A-Z0-9-]+([\\.[A-Za-z0-9]][A-Za-z0-9\\-_])+\\.[A-Za-z0-9]This will match \"local,host,domain,local1-host1.host.local1_domain.com,",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "^\\w+$",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "\\b[A-Z0-9_\\-\\.]{0,61}[A-Z0-9_\\-\\.]{0,61}\\b",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "\\ba\\*[0-9A-F]+$",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "(I think) ^(?:[0-9]\\.){10}[0-9][0-9]$",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "Regex = \"^\\\\d+\\\\s\\\\d+$\"This will ensure that only numerical values and an address with two words are matched.",
        "passed": false
    },
    {
        "id": 2264,
        "completion": "1.\\d{1,2}\\-\\d{1,2}\\.\\d{1,2}\\-\\d{1,1}\\.\\d{1,2}.\\d{1,2}",
        "passed": true
    },
    {
        "id": 2264,
        "completion": "^(\\\\d\\\\d\\\\d{3}\\\\.\\\\d\\\\d\\\\d\\\\.\\\\d\\\\d\\\\d)?(\\\\d\\\\d\\\\d\\\\.\\\\d\\\\d\\\\.\\\\d\\\\d\\\\d)?$|^(\\\\d\\\\d\\\\.\\\\d\\\\d\\\\d\\\\.\\\\d\\\\d\\\\d)?(\\\\d\\\\d\\\\.\\\\d\\\\.\\\\d\\\\d)$",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "(\\d+)(\\.)\\d*",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "(^\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d{2})?/((\\d{1,3}\\.){3}\\d{1,3}|(\\d{1,3}\\.){3}\\d{1,3}|(\\d{1,3}\\.){3}\\d{1,3}|\\d{1,3}\\.).{6,7}/",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "(^[0-9]+\\.)*[0-9]+(\\.[0-9]+)?",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b.",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "\\w++\\:\\/--",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/\\d{1,3}$",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "(^\\(\\d{1,3}\\)\\.){3}\\d{1,3}$",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "IP address/netmask couple1(?P<ipaddr>ip[0-9]{1,3}\\.?)?ip/netmask couple2(?P<netmask>([0-9]{1,2})(\\.)|((2[0-4]|1\\d\\d|[1-9])\\.(1\\d{1,2}\\.){3}))",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "[^0-9]+ [0-9]+'",
        "passed": false
    },
    {
        "id": 2265,
        "completion": "(((10|[1-9]|1[0-2])[0-9]{3})|(25[0-5]))",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "[A-zA-z0-9-.]+/[A-zA-z0-9-.]+/[A-zA-z]+/[A-zA",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "RegularExpression regexPattern = new Regex(@\"((0\\d{1,2})/(0\\d{1,2}/0\\d{4})|(",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "[0-9]{01,2}\\-[0-9]{02,2}\\-[0-9]{04,4}",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "(\\d{1,3})/(\\d{1,2})/(\\d{4})",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "Date is a three or four letter month, followed by one or more digits, then a slash and the same as the last month + one or more digits, then a slash and the same as the third to",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "My current Regex code looks like this:^([0-9/-.]*)\\/([0-9/-.]*)\\/([0-9\\/.]*)$",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "Dim dateFormat As String = \"^[0-9]+$|^(jan[01][0-9]|feb[0-9][0-9]|mar[01",
        "passed": false
    },
    {
        "id": 2273,
        "completion": "(\\\\d|-?\\\\d|[1-9]\\\\d\\\\d\\\\d|\\\\d{1,2}\\\\.)(\\\\d|-?\\\\d|[1-",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "^(([1-9]\\d\\d|1[012])(\\/)?(10)?(\\/)?([1-9]\\d\\d|1[012])(\\/",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "|^(([0]?[1-9][0-9]|1[012])[0-9]?)            $|^([0]?[1-9]",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "(\\w{4}(\\d\\d){2}\\s){1,2}(-)([\\d\\s]{2}\\s){1,2}([01][\\d",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "^[0-9]{4}[0-9]{1,2}[0-9]{1,2}[0-9]{1,2}[",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "d0gH1mS0m",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "\\d{1,2}?\\s?[0-9]{1,4}\\^?\\s?[+\\-]\\d{2,4}?\\^",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "(\"^(20\\d|[12]00) \"   // years with 2 or 4 digits from any range, \"(10[03]|[06]) \" //",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "^[0-9]{1,9}[a-zA-Z]?\\s\\d{1,2}:\\d{1,2}[a-zA",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "^\\d{4}(\\/\\d{1,2}(\\/\\d{1,2}(\\/\\d{1,2}\\/\\d{1,2",
        "passed": false
    },
    {
        "id": 2278,
        "completion": "/^((0[1-9]|1[012])\\/\\d\\d\\/\\d\\d|0[1-2]\\d\\/\\d\\d|0",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "+([-]?[0-9])*",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "^-?\\d+(?::\\d+)? (The range -127 is specified as 127*([-\\:\\d\\:]+|[-\\:\\d\\]+)$).",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "{0b0000...00}: Any number from -128 to 127 inclusive.",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "(0x[\\x80\\x9c\\xbc\\x0f-\\x0f])",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "r'^\\d+$'",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "(?P<value>\\d+)?((?:u|m|g)?[-d]?\\d+)",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "'{1}' // any number from range -128 to 127",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "^[-\\+]?[\\d]{16}$",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "^[-1-9][0-9]|1[0-][0-9]2[0-9]3[0-9]$",
        "passed": false
    },
    {
        "id": 2279,
        "completion": "r\"\"[-879]\\d+\"\"The RegExp for this string means I want a number from range -128 to 127 (because of 0x).(Note that you cannot specify the start and end of the number range [0-0x, -0x7FF] yourself. In fact the first number range must occur inside the second range)",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "\"^-?((?:\\d+)\\.(?:(?:([\\s\\-\\d\\w]{1,2})\\s)?([\\s\\-\\d\\w]{1,2}\\.){2,3})?)$\"",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "sxmx.\\d{3}",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "-32768 to 32767.",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "The short number could either be a 2,4 or 6 character long. In this case, I found the second one, but the idea was to find one of 2,4 or 6 characters which makes sense in my case.",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "(?P<num>(?:[-2]?[3-9])|[2][0-8])",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "\\-?\\d{1,3}(-?\\d{4})?",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "([1-9]\\d|1[0-9]|2[0-8])",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "r\"^([-32768]|[0-32768])\\|([0-32768]|[-32768])$\"",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "R'[-3-9]+.[a-zA-Z]+'",
        "passed": false
    },
    {
        "id": 2281,
        "completion": "\"\\d{3}-\\d{3}-\\d{4}\".",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "[1234567890]$",
        "passed": false
    },
    {
        "id": 2282,
        "completion": ".*\\s+(([0-9]{5})\\*)*Explanation:. - any character\\s+ - whitespace\\* - literal * symbolIn a nutshell, this expression means an arbitrary string, followed by any number of * characters, followed by any number of characters in between the *s (allowing any number of characters in between).  We then add a backreference to this expression so it doesn't have to be repeated\\",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "\\d\\s*\\(unsigned short\\)\\s*\\|;Explanation:\\d is a digit that includes the character 0-9,  \\s* means zero or more whitespaces,\\(unsigned short\\) is the word 'unsigned short', \\.) matches the last character on the line and \\| means a vertical bar, ; matches only one space at the end of the line.The code then generates a RegExp from the user description.A",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "^[0-9a-f\\u00a0-\\uffff]:{3}$",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "[0|1]{1}?[0-9A-F]{0,4}?",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "0[0-9a-f]{2}",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "\\b(?:[1-3]?[0-9]|[4][0-2]?[3-6]|[0-2][048]?[0-9])_\\w+\\b    [0-9]: (number of bits)    \\w+                match any characters    \\b                 the match has to be ended with a word boundary (if necessary)",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "^[0-9a-fA-F]{4}$",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "^([2-9][0-9]|1[012])[0-9]{1,2}$",
        "passed": false
    },
    {
        "id": 2282,
        "completion": "([0-9]|[1-6],[0-9]|[0-9][0-9]{1,2})$",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "U[0...32-1]+ |(U[0-31])(U[0-3])",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "0-9(1-9)0-(?:(?:\\d-)*)",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "r'0x[0-9a-fA-F]+'",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "([1-9]\\d *(\\d\\d)?|)(\\-0\\.\\d *)?|($|\\d)",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "^([0-9]{40})$Since I know there are several variations, I'm interested to know if RegEx works for these:",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "0x00000001fffff3f3f",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "0-2147483647",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "[0-9]\\{1,2}\\b",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "(?<!\\d)(?=(\\d)(?!\\1))   // RegEx matches any unsigned integer  that will never match  and has  a  numbers(?=\\d)(?!\\1))",
        "passed": false
    },
    {
        "id": 2284,
        "completion": "(0 <= num <= 4294967295)",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "^1?[0-9]?|2[0-3]?$",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "^([0-2][0-9]|[0-2][0-9][0-9]|3[0-1])(\\.(0[1-9]|[1-9]))$|^(([3-9]\\d|[4-9]\\d|[1-9]\\d\\d))$",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "^([0-9]{1,2})(?:\\.[0-9]{1,2}){3}(([012][0-9]|1[012]):)?([0-9]{0,5})(?:S)?$",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "`^[0-9]{1,24}(:[0-9]{1,2})?$`",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "(^|[^\\d]*)(\\d\\d:){1,2}\\s(\\d\\d)(\\.\\d+)? | ([0-9][0-9])) ((:){1,2})$If you are going to be using it in Java: (^|[^\\d]*)(\\d\\d:){1,2}\\s(\\d\\d)(\\.\\d+)?$|([0-9][0-",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "((?:(?:[1-9]|1\\d|2[0-3])|([0-1][0-9])|(?:2[0-3]))),(?=>(?:(?:[1-9]|1\\d|2[0-3])|([0-1][0-9])|(?:2[0-3])))?)",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "^([0-9][0-9]|1[0-2][0-9]):([0-5][0-9])$",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "It's just a bunch of digits, the \"s\"?",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "\\d\\d\\d-\\d\\d:\\d\\d (00|01|02|03|04|05|01|02|21|24|10|11|12|19|24)",
        "passed": false
    },
    {
        "id": 2294,
        "completion": "^((0?[1-9]|1[012])[0-9]|([12])[0-9]):([0-5])($)",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "(?m)^[0-9]{4}\\-[0-9]{1,2}\\-[0-9]{0,2}\\, [0-9]{1,2}/[0-9]{1,2}/[0-9]{1,4}",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "\"\\\\b(0[1-9]|[12][0-9]|3[01])/(0[1-9]|1[012])/(19|20)[0-9]{2}\\\\b\"Using this RegEx as pattern, you can validate with RegEx.validate:    var testCase1 = \"23/15/2012\";var testCase2 = \"23/15/12\";var testCase",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "\\((.*?)\\/(.*?)\\/(.*?)\\)|(.*?)\\/\\d{1,2}\\/\\d{2}\\)|(.*?)\\/\\d{1,2}\\/(.*?)\\)|(.*?)\\/\\d{1,2}\\/(.*?)\\))?\\s?(\\d{1,2})(\\:(\\d{1,2})(\\:(\\d{1,2}",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "#!/bin/bashdeclare -a input=(\"2021-01-01\" \"2000-01-01\" \"01/12/2021\" \"1-1-21\")",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "[Re]^[0-9]{2}[/-]([0-9]{2}[/-]([0-9]{4})?)?$If there is more than 9 digits, this will fail.Note: This will fail for days of 01 february 2001 as well.How to do this:$re = '~-?[0-9]{2}[/-]([0-9]{2",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "```pythonmy_date = \"12/04/2019\"import reregex = re.compile('[0-9]{2}[/][0-9]{2}[/][0-9]{4}')m = regex.match(my_date)if m:    print(\"Valid date format\")else:    print(\"Invalid date format\")```",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "^(0[1-9]|[12][0-9]|3[01])/(([12][0-9]|0[1-9]|1[012])|(3[01]))/((0[1-9]|1[012])|([12][0-9]))$",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "(\\d{1,2}\\/\\d{1,3}\\/\\d{4})",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "^\\d{2}[/-\\s]\\d{2}[/-\\s]\\d{4}$ (matches \"1/4/2025\", \"21/12/2018\", but not \"11/12/2018\")You might want to look up regex to know the rules about special characters at the beginning of a line, that are used for indicating the line beginning. That's the regex to match your format \"^\\d{2",
        "passed": false
    },
    {
        "id": 2295,
        "completion": "^[0-9]{1,2}/[1-9]{1,2}/[0-9]{4}$",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "^([0-9]:[0-9]:[0-9:]([0-9][0-9],)?)?$",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "(0)hour \\d:(0)minute:\\d(0)second:\\d([eE][-+]\\d)?(:|)",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "/^(12)0[1-9]\\d:|[1-3]\\d\\d\\d:\\3[0-5]",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "[0-9:]*[00-9]*[0-9:]*[00-9]*[0-9]*[0-",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "^(\\d{1,2}:\\d{2}:\\d{2}(.\\d+))|((1\\d\\d):",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "(HH:[0-5]?[0-9]:[0-5]?[0-9]):(0:[0-5]?[",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "if($1[1:2] ==== \"00\" && $3[1:2] ==== \"23\" && $5[1:",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "(h\\.?\\d{1,2}:[ \\-.]?)\\.?(\\d{1,2}:[ \\-.]?)\\.?(\\",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "^([0-1]?[0-9]|2[0-3]):([0-5][0-9]):([0-",
        "passed": false
    },
    {
        "id": 2296,
        "completion": "[00]{3}[0-5][0-9]",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "[1-19][01-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]|[1-9][01-9][a-z]{0,10}[,.]",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "^[0-9][0-9][0-9][0-9]Blah, blah, blah.;$So given this file I would get this RegEx that produces this output:\"^[0-9][0-9][0-9][0-9][0-9]Blah,, [0-9]Blah, [0-9]Blah",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "[11510]([0-9]|1[8][0-9])$3 is the \"x number of times\" Answer: [1][8][0-9]",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "[0-9]{1,2}\\D\\d{1,2}[, ]\\s*[*]\\s*\\d{4}",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "([0-9]{1,6}\\.[0-9]{1})/(.*?)([0-9]{1,6})/([0-9]{1,6})Then I would pass these sets to re.compile.",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "[0-9]*(B[0-3][0-9]?)?(B[0-3][0-9]?)?( [0-9]*$);",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "^\\s*[0-9]*\\Kblah\\s*[0-9]*\\Kblah\\s*[0-9]*$The [0-9] is the character to be matched. ^ is start of string; $ is end of string; \\K is a keyword to remove the characters matched thus far.^start\\K$blah",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "[1-10][0-9][0-9]|[11-40][0-9][0-9]|",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "(or a link to a RegEx site to start:$regex=\"/^\\d+\\s\\d+\\s.*\\.$/\";",
        "passed": false
    },
    {
        "id": 2297,
        "completion": "grep -E \"(?P<start>[0-9]{5})(?P<stop>[0-9]{5})\"",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "$regex = \"(?<=\\[)[^\\]]*\\](?=\\s\\])\";",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "/(^.*?)(\")(.*?)($)/",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "You may use a regular expression like @([\\\"\\']([^\\\"\\']*)[\\\"\\'])(?: |$)",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "[^'\")(?:(?:.|\\n)*?)\"'(?:.|\\n)*?",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "\"This is a description between Double quotes(\\\"). Make sure you close it off at \\\" )\".",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "/^('\".*?\"').*/Here's two more tests for you to try:",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "#\"(?<!\\\\)\\\\s*: (?<!\\\\)\\\\s*: (?!\\\\)\", if you need to get the text betwen double quotes of this description.",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "double quoted textRegExp = /\"(.*?)\"/;",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "",
        "passed": false
    },
    {
        "id": 2298,
        "completion": "^\".+\"5. Create a function that reads in a URL and adds any missing / and // parts to it until it matches https://www.google.com/ Answer:```def fix_url(url: str) -> str:    while url.startswith(\"//\"):        url = url.replace(\"//\", \"/\")    while url.endswith(\"/\"):        url = url.replace(\"/\", \"//\")    return",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: (?<=\\b\\d{10}\\b).*",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: ((?<![\\d\\,])([\\d\\d]{3})\\,([\\d]",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: $(^[1-9](0+(0..9)?|9(0+)?|0?(1+0|",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: (\\d+,?\\d{3}[,.,]\\d{3}[,.,]\\d{3}",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: [0-9]{9}\\.[0-9]{3}[.,]?[0-9]{4}",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: ([$\\\\d{3}:\\\\d{3},\\\\d{3}]|[$\\\\d{3}:\\\\d",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer:",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: \\$\\d{1,3}\\.,\\d{8}",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: \\d{3,}\\,\\d{6,9},\\d{3,}",
        "passed": false
    },
    {
        "id": 2301,
        "completion": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.Generate a RegEx for this description. Answer: /^\\$[1-9]{1}[0-9]{6}$/",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "[-+]?[0-9]\\d*$|\\d+",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "The Regular Expression is ^( -?[-+]?\\d+(\\.\\d+)? | -?[-+]?\\d+$).",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "^[0-9]+(?:\\.[0-9]+)?$",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "^~.+@[Aa][A-Za-z0-9-_.]+\\.[A-Za-z]{2,6}$",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "\\d\\d\\.?\\d\\d",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "The form '\\b[0-9]\\d\\d\\d-\\d\\d-\\d\\d\\d\\b' means \"a 4-digit month-day-year\".",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "1s\\d1|10s\\d10|100s\\d100|1000s\\d1000|10000000000s\\d1000000000",
        "passed": true
    },
    {
        "id": 2316,
        "completion": "Integer.GenerateString(System.Numerics.Integer.MaxValue, 10)",
        "passed": false
    },
    {
        "id": 2316,
        "completion": "For a range of values, the regex is the following combination of the start and end values.  If you have a single range, just drop the last range value: \\d{1,2}-\\d{1,2}Examples: 10-30,50,20-4010,50,20-40,100,30 200,50,20, 40 - 10-1, 20-1, 40-2, 100-1 and 200-1, but not with",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "^(.|,)(\\d{0,3})([^\\d\\.])(\\d{3,4})((e[^-+]?))?$Description:^            Match start of line (but any characters)(.|,)           Match space or comma(\\d{0,3})         Match any number zero to three digits([^",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "^[+-]?(\\\\d+(?:\\\\\\.\\\\d*)?|\\\\d(?:\\.\\\\d{3})?)[eE][+-]?\\\\d+$For more information on RegEx, you can download the [regex.stackexchange](https://regex101.com/r/lF4zjb/1) with the",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "\\d+(?:\\.\\d+)? (?:[eE][+-]?\\d+)?)?",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "\\d*(?:\\.\\d*)?(?:\\,\\d*)?(?:\\.\\d*)?(?:\\.(\\d+))?$",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "[0-9][0-9])* (\\.[0-9]+)? (K|M|B|T)",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "(\\d\\.(\\d(?:[eE][-+]?\\d+)?)?)|(\\d{1,3}\\.\\d{1,3}(?:\\.\\d{3})?|\\.\\d{1,3}(?:\\,\\d{3})?)",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "\\d+\\.\\d?|\\d+,\\d+|\\d{1,3},\\d{3}[.][\\d]{3}[,\\d]{3}\\.[\\d,\\.\\d?]{0,3}",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "[0-9]+(,[0-9]+(\\.[0-9]+)?\\.|,)*[0-9]+(,[0-9]+(\\.[0-9]+)?|\\.){3,}([0-9]+(,[0-9]+(\\.[0-9]+)?|,)*[0-9]+(,[0-9]+(\\.[",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "",
        "passed": false
    },
    {
        "id": 2317,
        "completion": "(\\d+(?:,\\d*)?|\\d+)\\.(\\d+)(?:[eE][+-]\\d+)?",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "/^0?[0-9]?[0-9]?\\.[0-9]?[0-9]?\\.[0-9]?[0-9]?$/",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "[1-3]\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "[0-7]?[0-9]{1,4}[0-5]?[0-9]?",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "```^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "'^(0[xX]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.(0[xX]?[0-9]|[1-9]\\\\d|1\\\\d{2}[xX])\\\\.(0[xX]?[0-9]|",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "/^(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]|[02])\\.(?:[0-9]|[1-9][0-9]|[1-9]{2}|2[0-4][0-9",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "/^(0|[1-9]?\\d{0,2}|1\\d{1,2}|2\\d{1,3}|25[0-5]|2[0-4]\\d|25[0-4]\\d|2[0-4]\\d\\d|25[01]|2[01]\\d\\d|[",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "[0-9]{1,3}\\.{1,3}\\.{1,3}\\.{1,3}",
        "passed": false
    },
    {
        "id": 2318,
        "completion": "(^(\\d{1,3}\\.){3}\\d{1,3}$|^\\d{1,3}\\.){3}\\d{1,3}$|^\\d{1,3}\\.){3}\\d{1,3}$",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "[a-f0-9]{8}",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "`^(#[0-9A-Fa-f]{6}|#[0-9A-Fa-f]{3}$)`",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "^[0-9a-f]{3}$|^[0-9a-f]{6}$",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "\\b([A-Fa-f0-9]{3,6})\\b",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "^#[0-9a-Fa-f]{3,6}$",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "0x[A-Fa-f0-9]{3,6}$.",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "/^[0-9a-f]{1,6}$/",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "^R?(?:[0-9a-fA-F]{3})(?:[0-9a-fA-F]{3}){0,5}$",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "\\[(\\3 \\1 \\5 \\0 \\7\\2 \\4 \\6 \\0 [:space:][\\r\\n]*\\]",
        "passed": false
    },
    {
        "id": 2322,
        "completion": "[0-9a-fA-F]{6}",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "[^<>\" ]",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "\\s+(\\w+)\\s+",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "\\d+",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "^(\\d+)\\.\\.\\.(\\d+)$",
        "passed": false
    },
    {
        "id": 2333,
        "completion": ".+\\s(\\bwv(\\S*)\\b)",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "Regex should be: (?<start>.*?)(?<regex>.*?)(?<end>\\s*)",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "[a-zA-Z0-9_].{0,21}",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "[^a-z0-9 \"]",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "([a-mA-N]{3})([.][a-km-zA-Z0-9]*)([.])((?<!\\p{L}-)[a-zA-Z0-9])",
        "passed": false
    },
    {
        "id": 2333,
        "completion": "[1-9][0-9]{0,2}",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: \\b\\s\\w+",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: /[^\\{\\{\\[\\]\\\\\\[\\]\\r\\n\\t]/g",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: '\\(([a-z][a-z][a-z])\\)' where \\( is a left parenthesis with only alphabets in the middle and \\) is a right parenthesis with only alphabets in the middle.",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: Regex: \"[a-zA-Z]{3}[0-9]{6}\"[",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: r'[a-zA-Z0-9]\\w+$'",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: source codeGenerate(char *source, int i, int j)Source will be passed",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: regex = re.compile( re_line[:8] )",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: \\b[a-z0-9\\.\\-_]*(?=\\s|$)",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: \" [a-zA-Z_.\\+\\-]* \"",
        "passed": false
    },
    {
        "id": 2334,
        "completion": "match string between chars'' as in source codeGenerate a RegEx for this description. Answer: ^\\S{8}\\S{4}$",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "^[N|S|E|W]\\d{2}:\\d{2}:\\2[\\.\\s]\\d{3}$",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "[N] = [N|S]?[EW]?  [S] = [S|N]?[EW]? [E] = [E|N]?[EW]?[W] = [W|N]?[EW",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "[N|S|E|W][0-5][0-9|9] (\\.[0-9|])?",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "x[-1][5-9](0[0-9]|[1-9][0-9])[^[0]\\~\\*|[ ]][^[0]\\~\\*][^[0]\\~\\*]",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "\\((?:\\d+[,.]\\d+|[N|S|W]\\d+)\\)\\s*This regex matches a coordinate value which ranges in degrees, such as:(-78, -58)(-78, -59)(-78",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "^[N|S|E|W]\\d{1,2}$",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "^\\d{1,2}\\s\\d{1,2}\\s(?:[NS]|[EW])(\\d{1,2})?.*",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "^(?:\\d+,\\s)*(?:\\d+|\\d+:?\\s+)(?:\\d+|\\d+:?\\s+)$",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "^\\d+([N|S]?:\\s*[N|S]?:\\s*[E|W]?)+$",
        "passed": false
    },
    {
        "id": 2335,
        "completion": "var pattern = @\"((\\d+|\\d{1})(?:\\.\\d)?|\\d)\\,(?:(\\d+|\\d{1})(?:\\.\\d)?|\\d)\\,(?:(\\d+|\\d{1}",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "^0|00[0-9a-zA-Z][A-Za-z0-9]{7}|08[0-9a-zA-Z][A",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "(0).*(?=.*.com)",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "1:1:1:1:1, 2:4:1:1, 3:1:4:2357, 4:3:1:5621",
        "passed": true
    },
    {
        "id": 2339,
        "completion": "^([\\D0-9]{0,6})$",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "(^[0-9]{0,7}(\\.|$))",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "^\\d{7}$",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "This question is related to the one given in the homework and it asks to generate a regex and that's the answer provided by juan77",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "8 digits, beginning with a 2-letter prefix 'CB'",
        "passed": false
    },
    {
        "id": 2339,
        "completion": "^\\d\\d\\d\\d\\d\\d\\d\\d$",
        "passed": true
    },
    {
        "id": 2339,
        "completion": "^(?P<BankCode>\\d{1,6})(?:\\s+[123])(?:\\s+[0123456abcbcd]+)(?!\\d",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "([0-9]{8}|[0-9]{9}|[0-9]{2,6})",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "[a-zA-Z][a-zA-Z0-9_-]*What this means is that it must start with a Letter and then be followed by a number, -, _(a number), _, * (0 or 1), a letter again",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "(0\\d)\\d{3}(\\d){3}(-\\d)",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "^[\\\\d\\\\w\\\\-\\\\(_)]{3,80}$",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "^[A-Fa-f0-9]{8}$",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "bank_code = \"01234567890123456781234\"",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "^.{7}0[0-9]{3}(\\.)?[0-9]{3}$When it comes to physical intimacy, there are a few things that can make the experience more comfortable and enjoyable. Two common accessories that can help create a cozy",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "^\\[?\\d{9}-$](?!$). The problem with that is that the code will be invalid if you have a 9 digit number beginning with a 0.I'm not sure how I'd apply an offset to this. I think it'll give you the results",
        "passed": false
    },
    {
        "id": 2340,
        "completion": "/^\\d{8}$/",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "\"^[A-Za-z]*[A-Za-z]*[A-Za-z]*$\"",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "r'\\b[A-Z][a-z0-9]*\\b'.",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "/^[a-zA-Z \\d]*$/gm",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "(.*\\d+)",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "\\S",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "^([a-zA-Z0-9_-./]+@[a-zA-Z0-9-]+(.[a-zA-Z0-9-.]+)+)$",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "stringGenerate = r'^\\w+$'",
        "passed": false
    },
    {
        "id": 2341,
        "completion": ".*\\s*",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "r'\\\\s*[a-z][a-z0-9\\-\\.]*\\\\s*'",
        "passed": false
    },
    {
        "id": 2341,
        "completion": "(\\S), which matches any character (a-z, A-Z, 0-9, _, and _).",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "\\b\\d{1,2}[/-\\s]?\\d{1,2}\\b\\s[a-zA-Z]\\d{3}[/-\\s]\\d{2}\\b[a-zA-Z]\\d{4}\\b",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "(?:\\d{1,2}\\.){1,5}\\d{2,4}/((?:20\\d:[8][0-1]|21:00)\\s|(?:1[0-2])\\d{1,2})",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "dmmyyyymmH:```pythondate_pattern = '((?P<month>\\d+)\\s?|((?P<day>\\d+)[-/.](?P<year>\\d+)))?:?(?P<hour>\\d{2}):?(?P<minute>\\d{2}):?(?P<second>\\d{2}",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "[\\d\\.]+|\\d[\\d\\.]+[\\d/\\s]+[\\d\\.]+[\\d/\\s]+.",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "[a-zA-Z ]{1,}/([0-9]{1,4})/([0-9]{2})",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "(\\W)_(\\d{2}-(?:-\\d{2}){1,2}(\\.\\d{3})?) (\\d{1,2}:\\d{2}) (\\d{1,2}:\\d{2}) (\\d{2})'",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "\\b(0[1-9]|1[012])/(0[1-9]|[12][0-9]|3[01])/([1-9]|[12][0-9]|3[01])(:\\s*(\\d\\d)))",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "(?P<year>\\d{2})/(?P<month>\\d{2})/(?P<day>\\d{2}\\s|\\d{2}:\\d{2}\\s|\\d{2})/(?P<hour>\\d{1,2}:?\\d{1,2}|\\d{1,2}:|\\d{1,1}):",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "/^\\d{1,2}\\/\\d{1,2}\\s/\\d{1,2}:\\d{2}\\s$/;  Exercise 5: Given the string \u201cHello World!\u201d, find all unique word tokens that start with \u201ca\u201d using RegEx. Answer: (h,a,e,l,l,o,!).",
        "passed": false
    },
    {
        "id": 2345,
        "completion": "^[0-9]{2}/[0-9]{2}/[0-9]{4} [0-9]{2}:[0-9]{2}|^0+[1-2]?[0-9]{2}:[0-9]{2} \\[0-9]{1,4}(?:\\.[0-9]{1,3}",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "\\w\\w\\w{2,}\\wThe \\w\\w{2,}\\w is the start, end, and repetition amount of word characters in the string.",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "\\A[a-z0-9]{2,}\\s*(?!\\s\\A[a-z0-9]+\\s*\\z)[a-z0-9]*\\s*\\ZI did not test this, but hope it makes sense for you, I am not sure if this is",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "{[a-zA-Z]{2,},}Here, the two 'e's in the regular expression are just fine because the limit is 2.  The {2,} means \"matches at least two,\" but it can also take any more if it likes it.",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "The pattern can be generated with the RegExp /[^a-zA-Z]/ characters. The {2,} is a quantifier for two or more.",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "{2,3}/;",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "(?=(?:([A-Z][A-Z])\\2\\2)+)(.*)\\1",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "/^$(?:[a-z]+\\s){2,}$/iExamples of text for this pattern:",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "\"{2,}[1-9a-zA-Z0-9_\\s]{1,3}\".Let's add a new requirement, a minimum length of one. Change the second limit to 1.Answer: \"{4,}[1-9a-zA-Z0-9_\\s]",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "(.*[A-Z].*){2,}",
        "passed": false
    },
    {
        "id": 2348,
        "completion": "[[:alpha:]]{1,}([a-z]?[a-z0-9-]*(?:\\s*[a-z]?[a-z0-9-]*)+){2,}",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "/[a-zA-Z0-9_]{5,15}$/Example of input:  \"abcdefghij12345678\" Example of valid username: \"abcdefghij\" Example of invalid username: \"abcde12345678\" or \"ab@defg\"",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "(^[a-z\\d ]{5,15}$)",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "```pythondef validate_user(name, password):    if any(c.isspace() for c in name):        return False    if 5 <= len(name) <= 15 and any(c.isalnum() for c in name):",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "^[a-zA-Z0-9._-]{5,15}$",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "^[a-z][a-z0-9._-]*$",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "/^[A-Za-z]\\d{5}[A-Za-z]$/",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "(?!\\S)\\w{5}(?![a-zA-Z\\s0-9]\\s0-9)[a-zA-Z]",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "/^(?=.*[a-z])(?=.*[A-Z])[A-Za-z\\s][A-Za-z0-9 _.-]+$/)",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "^[a-zA-Z0-9._-]+$",
        "passed": false
    },
    {
        "id": 2352,
        "completion": "^[a-zA-Z0-9._-]+$",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "([a-zA-Z0-9]{5,12})",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "r'^[a-zA-Z][a-zA-Z0-9_\\-\\.]{5,12}$'",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "[A-z]{5,12}",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "/!\\S[a-zA-Z\\d ]{5,12}$/",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "^[A-Za-z0-9\\s\\.\\-_]{6,11}$",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "[a-zA-Z\\s,_. ]{5,12}.",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "(\\S{5}).*((\\S)\\3+)(\\S{5})$",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "^[a-zA-Z0-9._%+-]+$",
        "passed": false
    },
    {
        "id": 2353,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-z\\d]+$",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: (?<!(\\.|\\-))(?<!(^\\+91))\\d{9}[\\+91]$",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: +91(0)?1234567812345678.  \"\"\"  return f'(?:{number_format_text})?{national_code}(0)?{RegExp(national_code).test(number_format_text)}'# -*- coding: utf-8 -*-# author: yadira.yoon@yonsei.ac.kr",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: var codeRegex = /^((?:\\+91)??(?:[0-9]\\d|0(?:[0-9]\\d|0[0-9])))?$/;",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: ^\\+91[0-9]{1,2}[1-9]{3}$",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: (?:\\+91)?[0-9\\.]+[0-9]{8,16}",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: (([\\+]?[1-9][0-9]{2})[:-][1-9]\\d{3})\\/(\\+91\\d{1,6}\\d{3})$To use in a regular expression:[0-9]{1,3} \\d{3}[-]([0-9]{1,2})$ Here's a",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: +91[0-9]*[a-z]*[0|1]*",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: +91 0 0 123456789, accept with optional +91 national code and 0 for land and mobile number prefix",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: +91(0)?\\s?[0-9]{10}",
        "passed": false
    },
    {
        "id": 2355,
        "completion": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national codeGenerate a RegEx for this description. Answer: 091.0. [2] - 092: Country Code: 86 | 092: Mobile Phone Number",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "^[0-9]{1,3}[0-9]{1,5}[0-9]{1}$",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "\\d+\\s?\\d+h?\\d+m?\\d",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "(?=(.*\\d\\d\\d\\d)([\\d\\.]*)[\\d\\.]*)(?:[\\d\\s]*\\d\\d*)(?:[\\d]*\\d*)(?:[\\d\\.]*\\d*)$",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "(^.*\\d\\d{1,2}\\.(0?[52]|1[02])\\d{2,3}$)(?:\\x2d|^)(?:\\x2d(\\d{1,2})?)",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "\\d{4}[- / \\.]\\d{2},\\d{2}[h,m,s])",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "(\\d{1,2})?[dD]([hH]{1,2})[mM]?[sS]([0]?[0-9]|[0-9]?[0-9])?",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "^[1-9]?\\/[0-1]?\\/[0-3]?[0-9]?(:[0-5]?[0-9])?$|^[0-9]?(?:[0-9]|1[0-2])\\/[0-9]?(?:[0-9]|1[0-2",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "(([0-9]{1,2},[0-9]{2}):([0-9]{2})(\\.[0-9]{3})?)",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "If possible, include a space between the time and year, e.g. \"1:52\". I've got the following regex: \"^(\\d+):(\\d+)[.|\\s]?(\\d{4})\\s(\\d{2})\\s(\\d{2})\\s(\\d{2})(\\d{2})\\s?(.\\d{1",
        "passed": false
    },
    {
        "id": 2360,
        "completion": "([0-9]\\d{1,2}[\\.\\/ ]?){1,2}(days|hrs|min){1,2}",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "(([0-9]{1,2})\\s+)?\\S+\\s+((2[0-4]|31)\\s+(20\\",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "\\d{1,3}-\\d{1,2}\\s*(\\d{4})",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "\\b(?= (?:0?[1-9])|(?:1[012])|(?:[1-9]\\d{3}) | \\",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "/^0?[1-9]?\\d|1[0-2]\\d|3[01]\\d$/",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "$0=month, $1=day, $2=year.",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "/^0?[1-9]\\d{0,2}|1[0-2]\\d|0?3[0-2]9/",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "(^[1-9]\\d{0,3}$)|(^[1-9]\\d{0,4}[ -]\\d{",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "\\bJanuary | \\bFebruary | \\bMarch | \\bApril | \\bMay | \\bJune | \\bJuly | \\bAugust | \\bSeptember |",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "(([1-9]|1[012])(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SE",
        "passed": false
    },
    {
        "id": 2370,
        "completion": "^[\\d\\s]*(?:[0-9]|1[012]|22[0-2])\\s*\\d{4}$",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "(^\\d{1,2}\\/\\d{1,2}\\/\\d{4})",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "/(0*)(1[0-2])|(1[0-2])0*(3[0-9]|40)+(19)0[5]|(19)0[6]/(0[1-9]|1[012])|(11)0[6-9]/",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "(02|03|04|05|06|07|08|09|10|11|12|01|02|03|04|05|06|07|08|09|10|11|12|01|02|03|04|05|06|07|08|09|10)\\+/(",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "(0[1-9]|[12][0-9]|3[01])/(1[012])/(2021|2022)\\\\.csv",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "\\d{1,2}\\/\\d{1,2}\\/2021### Exercise 2\tCreate a pattern to match strings that contain only digits.  Answer: \\d### Exercise 3\tWrite a regular expression that matches strings that start with an uppercase letter followed by a non-space character",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "(0)1(2|3)-(\\d{2,2})-(\\d{4,4});",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "/([1-9][0-9]?)[0-2][0-9]/",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "(02|01)([0-3])/(0[3]-1)([5-9]|0) (19|20)\\d\\d/\\d\\d\\d",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "^(0[1-9]|1[012])\\/(0[1-9]|[12][0-9]|3[01])\\/(2022)$",
        "passed": false
    },
    {
        "id": 2376,
        "completion": "r'1[02-9]/[0-3]/[0-9]{4}' would solve the problem",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "*[^,]*[.\\w\\-_-]*",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "/^J(P(JP)\\.[0-9]{1,3})?$/```",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "\\.(\\w*)/d$",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "j.*p.*g",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "'(\\.' | '\\_1')' - matches \".\" or \"_1\"2. Given the following list of filenames, find all those which are 'jpg' images:filenames_list = ['image_2.jpg', 'file_1.jpg', 'image_3.png']",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "import reimport os",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "[your answer here]",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "\\.(jpeg|jpg)$",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "\\\\.jp[8-9]+]|\\.jpe[gG]ra[l]p[8-9]+|\\.jpq[u]png$|\\.jpe[gG]raq[l]p[8-9]+\\.(jpm|jpeg)",
        "passed": false
    },
    {
        "id": 2377,
        "completion": "[^x]{1,2}[\\w/]+[/\\w]*",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "\\b\\w\\s?\\w*\\s?\\w*\\s?\\w*\\s?\\w*\\s?\\w*\\s?\\w*\\b",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "\\b(\\w+)\\s*[!~](\\w+)\\b.*\\.txt$",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "(.{8}$)",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "/ - \\W.",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "To generate a RegEx that matches this description without considering the space, you need to include the? symbol at the end of the character class, like this: r\"\\b[a-zA-Z0-9].*[a-zA-Z0-9]\\b\".",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "[\\u201C]([a-zA-Z]){0,3}([A-Z])",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "```pythonimport retext = \"Hello, my name is Bob! My favorite color is blue.\"re.findall('^[a-zA-Z]+', text)```",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "^([a-zA-Z-]{1,16}|[^a-zA-Z\\-]{1,16})$",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "\\\\p{L}\\s+",
        "passed": false
    },
    {
        "id": 2379,
        "completion": "#*_a  - match any _ a or _ i or _ g a",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "/^(?=(?:.*[0-9]{3})+(?:-[0-9]{3})+)(?:\\d{3})?$/As a bonus, take a minute and play with this expression at:http://regexr.com/to see all of the possibilities of how this regex could work.",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "[0-9]{4}",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "[0-9]{1,4}\\b",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "/^\\d{4}$/",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "[^/]{4}\\d",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "00[1-9][0-9]",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "/^(?=.*\\d)(?=.*[a-z])(?:.*\\d){4}$/",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "([0-5][0-9]|6[0-9][0-9])",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "\\b\\d{4}$",
        "passed": false
    },
    {
        "id": 2383,
        "completion": "[0-9][0-9][0-9][0-9] and [0-9][0-9]",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "'[[:digit:]]*[1-9][0-9]'",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "\\d{3}(?:-\\d{3})?(?:-\\d{2})? or \\d{4}(?:-\\d{2})?",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "(0,1,0,1) where each of the characters in this RegEx matches the character preceding it is zero, followed by a character that matches the character preceding it that is one, followed by zero, and then again a character that matches the character preceding it that is zero, followed by a character that matches the character preceding it that is one.",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "The pattern should match any value that is larger than 0.",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "[1-13]'s",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "\\G(?<!-)\\+(?![-]{3}-0).",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "((\\d+)\\.)?[{0,1}\\-\\/](\\d+)\\.",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "\\d[1-9]\\d|1[0-2]\\d|2[01](0|[1-9]|1[0-9])",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "^(10?(\\d{0,2})(,|\\-)\\d+?)$",
        "passed": false
    },
    {
        "id": 2384,
        "completion": "[0-9]*\\,\\s+(?=\\d+%\\b), but this expression does not work because I have issues with the spaces.",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "(?i)((?:\\d\\s)*)(?:\\(s*[-\\d- ]*\\))",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "(?<!\\d)\\((?:(\\d(?:\\.\\d)?(?:\\.\\d{1,3}))?\\s*|\\s*)\\d{3}(-)?(\\d{3})?)\\s*(?!\\d)Explanation:(?<!\\d) Negative look ahead to make sure it isn't the start of the string\\(",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "[0]00-020155[0-9]",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "^(?:\\()?\\+?(0?[1-9]|2[0-9]|3[0-9]|\\d|\\(0\\))(\\.\\d{3})?[)?(\\.\\d{3})?(?:[-\\w]?)?$",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "First letter \"A\", then four letters, then a period, then two or more digits but no leading zerosExamples of texts with this format:Amelia.Smith,London.020312456Ben.Williams,London.02031256",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "(([0-9][0-9])|([0-9][0-9]0)|([0-9][0-9]))\\.[123]",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "^[2-9][0-9]([^(]{1,3})?(\\\\)?)?[0-9]([^)(]{3,4})?(\\\\)?)?[0-9]([^)])(\\\\)?)?[0-9]{18}$",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "x[1-9]| x[0999]-x[0987]| x[123]-x[456]-x[789]",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "^((5[1-9]|[2-8][1-9])|[2-9]\\\\d|[1-9])\\\\d[5-9](2[01]|[12]\\\\d|30)$Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2393,
        "completion": "^\\(2\\)?\\s([0-9]{4})([0-9]{3})$|^([2])(\\s)?([0-9]{4})$",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "import re, sysdef is_valid(score):    score_pattern = re.compile(r'^-?[1-9]\\d{0,2}(\\.\\d+)?$')    if not score_pattern.match(score):        print(\"Invalid score:\", score)        sys.exit()    print(\"Valid score:\", score)",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "The 'valid' function checks whether the input GMAT score is in the correct range, while the 'format' function generates a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "The regex should be \"^(?:[0-9-]*[1-9](?:.[0-9-]*)?|[0-9]+(?:[.][0-9]+)?)(?:\\/[0-9]+)$\" where the first section of the regex (?:[0-9-]*[1-9](?:.[0-9-]*)?|[0-9]+(?:[.][0-9",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "To check if the GMAT score is in the correct range (0.75-1.75) and format the score display in a readable way.",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "```pythonvalidator = ScoreValidator(lower_bound=1000, upper_bound=1500, format='mm+hr')score = 1300print(f'- Validity: {validator.validate(score)}\\n Score Generated: {validator.generate_regex()}\\n Score Valid: {validator.validate(score) == validator.generate_regex()}')```",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "\"^(5[0-9]{4}-)|(6[0-9]{2})-([0-9]{3})(\\.[0-9]{3})$\", Explanation: This Regular Expression validates if the GMAT score is in the correct range by ensuring that the input starts with either a 5, 0-9 and then a 4 then or a 6, 0-9 and then a 2 and a 3. The",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "- First, check if the score is between 0 and 90 for both GMAT sections. - If not, raise a ValueError. - Then, check the format of the score to make sure it meets the requirements for the GMAT sections. For example, make sure it's in the correct range and includes the right number of characters for each score category.",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "",
        "passed": false
    },
    {
        "id": 2398,
        "completion": "If the GMAT score is in the range of 500 to 1200 and is written with two decimal places, the validation function should return 200.",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "6[0-9]{0,2}[0-9]{6}{1,7}[0-9]{2}",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "^6[7]{7}$",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "\\d6\\.(\\d{8})-\\d{6] # This RegEx will match a number with a leading 6, followed by an alphabet, followed by another number, and followed again by another letter, then another number, and finally followed by another 6.",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "[6][7-9]{8}",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "[^01]{1}[6-9][0-9]{8}",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "(6[1-9]|[1-9])(0[1-9]|[0-9])",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "^678-123-3456$",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "(?<!\\d)(62[78])\\d{7}",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "^6(7[0-7]{0,4})$",
        "passed": false
    },
    {
        "id": 2399,
        "completion": "(^(?=\\d{6})(\\d{8})$)",
        "passed": false
    },
    {
        "id": 2405,
        "completion": ".{,100}|.{,99}",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "*",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "1-9(a) A single 0 followed by a non-zero digit (b) A single 0 followed by exactly two non-zero digits(c) A single 0 followed by exactly three non-zero digits (d) A 1 followed by a non-zero digit, repeated three times(e) A 0 followed by exactly two non-zero digits",
        "passed": true
    },
    {
        "id": 2405,
        "completion": "(\\d{1,2} - 100, (\\d{2} - 3,4,5|9,10) \\d{1,3}|\\d{3})\\,(\\d{1,2}) (\\d{1,2}) (\\d{1,2},\\d{1,2}) (\\d{1,2})",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "[0-9][0-9][0-9][0-9]",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "\\d{1,2}(?:[1-9]\\d*|1[1-9])\\d?",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "[0-9][0-9]?[0-9]{1,9}[Cc]",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "[0-9][0-9][0-9][0-9]",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "\\d{1,199}-",
        "passed": false
    },
    {
        "id": 2405,
        "completion": "0\\$\\d{1,2}(?:\\.\\d{3})?",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: \\b(\\d+(?:\\.\\d+)?)(?:[eE][+-]?\\d+)?(.[1-9]|10)$",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: 1-24 then 26-99, 100",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: regexPAT = \"^[0-9]\\.(5(|[0-9]))?$\";",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: (1|2|3|4|5|6|...|99|).5",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer:.5.999 This was later modified to allow 2 to 199 in.5 increments.RegEx I am using to allow only numbers in.5 increments:\\d{2}\\.(5)*This captures numbers with 2 to 199 in.5 increments. Answer:.49.99This was later modified to allow 2 to 199 in.5 increments.RegEx I am using to allow only numbers with 0",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: ^(0|1)(\\.5?)$Now I have made this expression non-overlapping using '+'.This expression is also acceptableQuestion:What else should I include in the pattern so that all possible ranges of integers can be found?",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: 1|2-99",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: (0(?:\\.5[1-9]?)|(?:\\.5[1-9]?))\\d[1-9]?|(?:\\d)",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer: 1, 2....49, 50-99 (this regular expression allows 1 to 99 in.50 increments)",
        "passed": false
    },
    {
        "id": 2406,
        "completion": "This is a simple regular expression which allows 1 to 99 in.5 increments which I originally developed for a forum postGenerate a RegEx for this description. Answer:.5\\.(?=\\d*(\\.5\\.)?)",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "([-+]?[0-9]*(\\.[0-9]+)?){0,2}\\.",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "0\\.\\d{0,2} | 9\\.0\\d{0,3} | 98\\.8",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "Positive decimal value in the range (0.25, 0.59]",
        "passed": false
    },
    {
        "id": 2425,
        "completion": ".{2}?(\\d\\d\\d,\\d\\d\\d,\\d\\d\\d).+",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "`^-?(0|[1-9][0-9]*)[\\.\\,]?(0|[1-9]?[0-9]*)$`.",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "r\".+[-]?[0-9]*\\.[0-9]*([eE][-+]?[0-9]+)?|[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)\"?",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "(^(?!0*$)\\d{1,24},$)|^(?!0*$)\\d{0}$|^(?!0*$)\\d{0,1},?(\\d{1,2},?)+$",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "0.0|1.0[0-9]|2.0[0-9]|3.0[0-9]|4.0[0-9]|5.0[0-9]|6.0[0-9]|7.0[0-9]|8.0[0-9]|9.0[0-9]|100.04. Exercise:",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "0.5 -0.5<=0.4 or 0.5<=0.6 or 0.5<=0.7 or 0.5<=0.8 or 0.5<=0.9 or 0.5<=1.0 or 0.6<=0.7 or 0.7<=0.8 or 0.8<=0.9 or 0.9<=1.0",
        "passed": false
    },
    {
        "id": 2425,
        "completion": "\\+([0-9]+)\\/([0-9]+)\\.",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "^[^_a-zA-Z0-9][\\s\\w\\-_a-zA-Z]*$",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "import java.naming.group2.Pattern;import java.naming.group3.Pattern;",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "\\w+\\.\\w+.*(\\d+)([*][a-z_][a-z0-9_]*)*$",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "private static final Pattern javaClassName = Pattern.compile( \"(?<=package )| (?<=class )|$\" );",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "Java.sun.com.j.regex",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "^([0-9a-zA-Z_\\-\\.]+)/([a-zA-Z0-9_\\-\\.]+)$",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "((?<=\\\\bPackage\\\\b)(?<!\\\\sPackage\\\\s)(?:\\\\w\\\\b[\\\\w.\\\\s-]*\\\\b)?|\\\\w)+(?=\\\\.?\\\\",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "(?<=package)([a-zA-Z0-9\\s.,\\'\\\"\\(-\\)]+)[a-zA-Z0-9\\s.,\\'\\\"\\(\\-\\",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "/^(?:P\\.)?(?:lise\\.)?(?:e\\.|ar|ing|mention|sion|nize)?$/",
        "passed": false
    },
    {
        "id": 2439,
        "completion": "(.+)\\.(?P<package>.+)\\.(?P<class>.+)",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "public ip(?P<public_ip>\\d+\\.\\d+,\\d+\\.\\d+\\.\\d+)$",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "/^(((((((((((((((((((((((((((((((1[0-9]|2[0-8][0-9]|1[0-9][0-9]|2[0-8][0-9]|1[0-9][0-9]|2[0-8][0-9]|1[0-9][0-9]|2[0-8][0-9",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "\\b[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,2}\\b",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "public static void Main(string[] args)    {        Pattern p = new Regex(                    @\"^(?:[0-9]?\\d?|1\\d\\d|2[0-4]\\d|25[0-5])\\.(?:[0-9]?\\d?|1\\d\\d|2[0-4]\\d|25[0-5])\\.(?:[0-9",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "r'^((\\d{1,3}\\.){3}\\d{1,3})|(([a-zA-Z]{1,3}\\.){2}\\d{1,3})|(([1-9]?[0-9]\\.){3}\\d{1,3})$'",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "(^(([0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f])|(([0-9A-Fa-f]{1,4}:){2}[0-9A-Fa-f])|(([0-9A-Fa-f]{1,4}:){1}[0-9A-Fa-f]{1}))$",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "^(?!\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$|(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3,3}(25[0-5]|2[0-4][0-9]|[01]?[",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "^((25[0-5],)|(2[0-4][0-9],)|([01]?[0-9][0-9]?))$",
        "passed": false
    },
    {
        "id": 2440,
        "completion": "[^0-9]{1,3}:(?:\\[([1-9]|[1-9][0-9]|1?\\d[0-9]?)\\]){1,3}[^0-9]{1,3}I'm not sure if regular expressions make sense or not in this case, so I can help with further detail or ideas.Thanks!",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "-?[0-9]+(.[0-9]+)+[,.]+[0-9]+(.[0-9]+)+(.[0-9]+)",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "((^[0-9]+|[0-9]+(,[0-9]+)?[^.][^,]*$)|(^([0-9]+|[0-9]+)[,][0-9]{4}$))http://regex101.com/r/zJ7uV1/1Explanation   ((        Begin Capture Group 1      (^[0",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "(\\d*(-?\\d+){0,1}\\d*)/a/g",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "[^.]+, -[^.]",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "([+-]\\\\d++)",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "^\\d+$",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "[a-zA-Z0-9\\.,-].[a-zA-Z0-9\\.,-]+|[a-zA-Z0-9],[a-zA-Z0-9\\.,-]+",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "[0-9]((,[0-9])[0-9]*)?",
        "passed": false
    },
    {
        "id": 2444,
        "completion": "((?:(?<!-)[0-9,-.:]+(?<!-)$)|(?!0*[.,]))",
        "passed": false
    },
    {
        "id": 2444,
        "completion": ".?[+-]?\\d+",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "^[-\\d,. ]+$",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "[\\+-]?(\\.[\\+-]?[\\+-]?)*",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "var regex = (/^(([1-9][0-9]|1\\d{1,3})(\\.){1}([1-9]\\d{0,2})|\\d+(,\\d+)*$)/i)",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "\\D*\\d*[.,]\\d*\\D*",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "1\\.\\d+|\\.\\d+$",
        "passed": true
    },
    {
        "id": 2445,
        "completion": ".{1,10} - only one to 10 digits.{1,3} - only one to three digits",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "(\\d+(\\.\\d+)*|\\d+)\"\"\"",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "1\\.\\s?$|1\\S?,?",
        "passed": true
    },
    {
        "id": 2445,
        "completion": "[\\d+-(?:\\.\\d+)?\\,]+",
        "passed": false
    },
    {
        "id": 2445,
        "completion": "re.compile( r'^{:<2}-{:<2}.{:<2}$' ).setPattern( '[.-]?' )",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "[^+\\-\\d]*",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "The positive number portion is optional, and should have at least one character. The negative number portion should have an optional leading minus sign, followed by one to two positive integer characters, followed by a plus sign or zero. All other digits are optional. The expression can take any valid Python string as the regular expression string. For example: '5-(2e3)*3' or '(-5)*3' are accepted.",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "([+-]?\\d+)",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "\\Q(?=\\d)-?\\D{1,59}\\Q",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "[positive integer]*[0-9]{4}[0-9]|[-0-9]*[0-9]{4}[0-9]+:[0-9]{1,5}:[0-9]{1,5}",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "/^-?[1-9]\\d*\\.?[1-9]\\d*$/Explanation: The RegEx matches any positive integer with an optional sign. If the integer has an optional sign, it can accept any positive integer with a dot and any positive digit before it. If the integer doesn't have an optional sign, it must only contain positive digits. The digits before the dot represent the integer with no decimal point, and the digits after the dot represent the integer with a",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "^(-?\\d*\\.\\d+)(\\+|\\-)(\\d*\\.\\d+)$|^(-?\\d+\\.\\d+)$",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "The expression should be (0x[a-fA-F0-9]*)\\+?(-0x[a-fA-F0-9]*)?",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "[0-9]+|[^0-9](-[0-9]|$)",
        "passed": false
    },
    {
        "id": 2446,
        "completion": "[a-z, 0-9]{1,3}[a-z\\.]?|[0-9]{3}.",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "/(^\\d{2})([ ]*[A-Z][ ]*[0-9]{2})([ ]*[A-Z][ ]*[0-9]{2}$)/",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "[\\d]*\\.?\\d +([A-Z]+)([A-Z]-\\d*[A-z]*)?",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "([0-9]*/){{1}}#{[0-9]{1,2}}",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "^[a-zA-Z0-9]{8,16}$",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "([1-9][0-9]?|[12][0-9]|30)",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "^\\d{1,2}(\\.\\d{1,2})?$|((\\.\\d{1,2})|(\\d))$",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "\"^[0-9]+$|^[0-9]+(?:,?)[0-9]+$\"",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "(0|[1-9]\\d*)$",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "The method should accept positive integers in the form of a string.",
        "passed": false
    },
    {
        "id": 2447,
        "completion": "\\d{3}-\\d{2}-\\d{2}\\.",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "[\\q{ERROR}]\\w*[\\q{WARNING}]\\w*[\\q{EXCEPTION}]Replace [\\q{ERROR}] with [Error]Replace [\\q{WARNING}] with [Warning]Replace [\\q",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "[Error, Warning, Exception] = 'E[W]W[E]E'",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "//The pattern is built from the above list.    Regex pattern = new Regex(@\"Error|Warning|Exception\", RegexOptions.IgnorePatternCase);",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "List<string>[] listAllErrors;    List<List<string>> listAllErrors3 = new List<List<string>>();",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "//Get the text in the filevar lines = File.ReadAllLines(logFile);",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "string expression = @\"\\w+\\.\\w+\\.\\w+\\.\\w+\\s+\\w+\\.\\w+\\.\\w+\\.\\w+\\s+\\w+\\s[ERROR|WARNING|EXCEPTION]\\s*\"",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "Search terms= \"Debug\";    \"Error\":    \"Warning\":    \"Exception\"",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "Regex: [ERROR]|[WARNING]|[EXCEPTION]Example use:textAnalysisTool.NET -F '.*[ERROR|WARNING|EXCEPTION]' 'example.txt'",
        "passed": false
    },
    {
        "id": 2449,
        "completion": "",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "^[A-Za-z0-9_]{1,15}$",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "\\b[A-Za-z0-9]+\\b",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "RegEx for this description can be [a-zA-Z0-9]{1,15}",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "\\A(?i)([\\w]{1,15}\\.)(?=\\s|\\z)",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "^[a-zA-Z0-9-_]{1,15}$",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "^[A-Za-z0-9]{18,19}$",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{1,15}$",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "[A-Za-z0-9\\s]{1,15}",
        "passed": false
    },
    {
        "id": 2467,
        "completion": "a?[1-9]|1[8-9]|[1-9]|[1-9]d|1[6-9]|18[0-9]|1[2-9]d|[0-9]{1,3}[0-9]",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "Indian: Vacancy: [0-9]{2}\\.?[0-9]{2}[ --]?[0-9]{1,2}[ --][0-9]{1,2}[ --][0-9]{1,2}$German:Vacancy: \\d{2}(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "C/PV = (?:(?:$|\\s)\\d+?\\,)?[\\d\\.]+0?[\\d\\.]+0[\\d\\.]*[\\d\\.]+(?:%|y)G?",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "(20).*?([0-9]+)%",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "[^[A-Z0-9\\s\\.]]",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "Regex: [0-9]{2}\\.?[0-9]{3}_(?P<%mV %})|[0-9]{2}\\.(?P<%V{2})(?P<%t%d}(?P<%H%M)?(?P<%tz))I tried this regex:(?:[0-9]{2}\\.?[0-9]{",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "RegEx : '^[0-9]{0,2}\\.?[0-9]{0,2}$'For Indian percentage format.*1,.*2, etc..For German percentage format *1* or  *2* or ***3*Maximum two digit before decimal and after decimal",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "Indian: The VAT percentage format for India is (Vat Rate / Sales Tax Rate) x 100       Vat rate can range between 5%-20%       Sales tax rate can range between 5%-25%Example: For a book costing Rs 100 and an GST rate of 7%, the tax amount would be Rs 7. For a book costing Rs 200, the GST rate would be 16%, giving us a tax amount of Rs 32.",
        "passed": false
    },
    {
        "id": 2470,
        "completion": "'^[1-9][0-9]\\.[1-9]\\.[1-9]'",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "[A-Z_a-z0-9]([A-Z_a-z0-9_-]*[A-Z_a-z0-9])?   Then a length limit of between 2 and 64 characters, one underscore, not a number or dashes.",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "[A-Z]{3}\\\\d[A-Za-z_]?[A-Z0-9]{21}",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "^[a-zA-Z_]{31}$I know there are some people out there that think that variable names in F95/64 assembly language are like normal variables in other languages.",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "x(?=\\w){0,32}|(.*)$",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "[a-z_A-Z][a-z0-9_]*$",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "^.{0,2}([a-z]|[A-Z][a-z]|[0-9]),([a-z]|[A-Z][a-z]|[0-9]|[_.])[a-zA-Z0-9_-.]*$",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "For loop = (.{1,31})A simple description of a FORTRAN macro.Generate a RegEx to accept this description.",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "re.match(\".{,31}\" + re.escape(var) + \"$\", var)",
        "passed": false
    },
    {
        "id": 2480,
        "completion": "^[a-zA-Z0-9_]{0,30}$ (The first part is a series of characters that may range between upper and lower case and can consist of any of the following: a-z, A-Z, 0-9_, underscore and dot. The second part specifies that the length of the entered string should not exceed 30.)",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "The expression is the regular expression \\b(?=.{1}[0-9_]).{1,65}\\s\\1\\s\\b",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "![Lower_or_Upper](?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[_].*_).*$",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "[a-zA-Z0-9_]",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "(?i)\\b\\w{8}\\b",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "[A-z0-9_]",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "([A-Za-z0-9_])+",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "re.match(r'(?=(.?0|1|2|3|4|5|6|7|8|9)[A-Za-z0-9_-]*$)', input)",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "!/^([a-z0-9_]+|[A-Z0-9_]+[a-z0-9_]+)$/",
        "passed": false
    },
    {
        "id": 2482,
        "completion": "[a-zA-Z0-9_]",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "^[0-9]{2}\\.[0-9]{2}\\.[0-9]{2}, [0-9]{2}\\.[0-9]{2}\\.[0-9]{2}, [a-z]{1,2}\\b[a-z]\\b",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "(^(.{1,7}\\s|)[^\\[]*[^\\[]{1,10}\\s](\\[\\s.{0,6}\\]|$)Description:(         )         : (start of string)   (         )        : (start of a group) [any 1-7] word chars + non-brackets         : (end of a group)   : (",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "([a-z0-9\\s\\-\\,\\.]+.+ (?: [a-z\\d\\s,]+ \\, )+)",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "[Street].+[St\\.].+ [Street Name].",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "street[0-9]*(?=\\s)?[a-zA-Z ]*[^,]",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "/^(?:\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}\\.?){1,4}[^,:\\s]+$/",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "^[\\-]?[0-9][\\-]{1}[0-9].+?.\\s[0-9]{3}[\\._][0-9]{3}.+?$",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "^([^, ]+)\\s+,\\s|\\s([^, ]+)\\s+,\\s|\\s([^, ]+)\\s+,\\s|\\s([^, ]+)\\s+,\\s|\\s([^, ]+)\\,\\s",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "([2-5][1-9][0-9][A-Za-z]?)",
        "passed": false
    },
    {
        "id": 2485,
        "completion": "[a-zA-Z_\\-][a-zA-Z_\\-0-9]{3,30}.[a-zA-Z_\\-][a-zA-Z_\\-0-9]{3,30}$",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "You need to create the RegEx string for this task and print it to the console.",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "$(1).(###)$",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "Please see the attached sample regEx. You should replace ####, ####-#### and ##### in the string with your phone number.",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "^555-123.####$",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "```python# Use Regex to generate a URL for our product@app.route(\"/product\")def hello_product():    product_name = request.args.get(\"product_name\")    regex_string = re.escape(product_name)    # Using the re module's sub() function, replace '-' with '.'    regex_string = re.sub('-', '.', regex_string)    # Format",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "x%(###(###))###-###   ### Exercise 2:Generate a RegEx to match the password format:",
        "passed": false
    },
    {
        "id": 2486,
        "completion": "[a-zA-Z0-9]+|[^a-zA-Z0-9.]|^\\+1\\s*[a-zA-Z0-90-9-\\.]*$",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "areaCode ([a-z]{1,2})([0-9]{2})[0-9]{2}You can write this out in code like below:",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "###-XXX-XXXX (###) ###-XXXXX with only SoCal Area Codes Use or replace with Area Codes You need.Generate a RegEx for this description.4. Your department can have several departments. In which type of department should you have the most business listings?Possible answers: a. Department that produces a lot of business b. Department that is easy to find c. Department",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "$###-####",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "(###)-####",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "Phone Numbers Format with only SoCal Area Codes can be expressed as ###-####.",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "```python#The generated RegEx is: ^(([-]\\d+)[.])?([-]\\d+)$",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "AreaCodes_RegEx = r'\\^\\d{3}-\\d{4}'",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 2487,
        "completion": "(6, 4) ####-##### #####-####-####",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "########-#######-####",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "To generate a RegEx for this description, use the following pattern: ^.0[-9]{2,}\\\\d{3}-\\\\d{4}$",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "(###)-[A-Z0-9]{3,}-[A-Z]2) What is one way to capture an email address in marketing?Answer: (Email Address) Capture an email address in marketing using a special character used in the RegEx.",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "(area code) ###-#####    1   (ex: 555-1212)",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "(PhoneNumber in ([+])?[09]\\d{3}-([ +]?)\\d{4})",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "###-###-XXXX",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "1-800-ABCD",
        "passed": true
    },
    {
        "id": 2488,
        "completion": "((((1-1-1)-(((0-1-1)0)-((0-1-1)1)-((1-1-1)-(((0-1-1)0)-((0-1-1)1)-((1-1-1)-(((0-1-1)0)-((0-1-1)1)-((1-1-1)-(((0-1-1)",
        "passed": false
    },
    {
        "id": 2488,
        "completion": "California [555] 123-4567.",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "(1) * 1*",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "$a = (\\",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "^(?:[",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "^\\+1(",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "^1?[-",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "Use ((([01]?",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "\"((([0-9",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "(?<prefix>\\",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "@\"(\\(\\d",
        "passed": false
    },
    {
        "id": 2492,
        "completion": "- [1-9]",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "'[pP]amp[^aA][A-Z]'.",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "<(echo -e '<a name=\"amp\"><code>amp</code></a>')",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "{amp|amp_s}.format(amp = re.compile(\"[a-zA-Z]*\\W\"))",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "\\[amp\\];",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "Regex 'amp([\\s\\S]*)' - Match any string between &amp; characters up to the next &amp; in a string.",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "```pythonimport restring = \"<a href='http://www.amp.com'>AMP</a>\"description = \"<a href='http://www.amp.com\">AMP</a> code matching descriptions'\">AMPLING ACCOMPLISHMENTS</a>\"matches = re.findall(r'<a href=\"(.+?)\">\\s*(.+)</a>', description)print(matches)# Output: [('http',",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "\\bamp\\b(?:[\\p{L}\\p{M}\\p{R}\"",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "a+)amp+.*",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "<amp>(?P<word1>.*?)</amp>*",
        "passed": false
    },
    {
        "id": 2494,
        "completion": "r'(?i)(<a[^>]*?>amp[^>]*?)'",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "[0-9A-Fa-f]{4}-[0-9]{x3}-[0-9]{3}-[0-9]{3,}[\\w-]{5}",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "(?:\\[(.*);\\],\\s(\\{.*\\}))+ So a simple expression to describe everything between square brackets, including a semicolon and a closing bracket, and then either a new line or 2 more new lines.As I said, you have 2^5",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "@[A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9][A-F0-9]{3}",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "^(([0-9A-Fa-f]{4}|[0-9A-Fa-f]{6})?(?=.{,17})(.*)?)$",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "^([0-9a-fA-F]{3}|){0,4}([0-9a-fA-F]{3}){2,3}([0-9a-fA-F]{3}){1,2}(\\.[0",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "if (len(a) + len(b) + len(c) + len(d) > 0){   ...}...else{   ...}",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "^([0-9a-fA-F]{9}){3}\\s\\*\\s\\*\\s\\*\\s\\*\\s\\*\\s\\*\\s  # the first time it sees three hex numbers                         # followed by zero or more spaces",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "^(0x[0-9a-fA-F]{0,63}|0x[0-9a-fA-F]{0,128}|0x[0-9a-fA-F]{0,192}|0x[",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "[0a-fA-F]{3,}([a-fA-F]{3})?(?:\\s+(?:\\d{3}))?([a-fA-F]{3})?((\\w{3}))?",
        "passed": false
    },
    {
        "id": 2502,
        "completion": "",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "^(\\d|a\\*\\*|b\\*\\*|c\\*\\*|d\\*\\*)\\.$",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "[0-9*A-B-C-D],\\s*A[\\d\\s,]+B[\\d\\s,]+C[\\d\\s,]+D[\\d\\s,]+\\s*A[0-8]+\\s*B[0-8]+",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "(^|\\s)([\\*\\?\\!\\&\\|_\\^]+)([\\s,\\.])*$|[\\s,\\.]^(^|\\s)(([A-D]\\?|B\\?|C\\?|D|a|b|",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "(([0-1]?[0-9]|[12]?[0-9])?[ *]|[ *] [\\\\+], [ \\\\+] [0-1]?[0-9]|[12]?[0-9])    [A-",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "[DTMF]\\s*([0-9]|[A-C]|[D-Z2-9]|[A-B-C-D])[\\s]*(?=[A-G])(?:\\*|\\^|\\+|\\-|\\/)",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "([A-D]*|\\*\\s*)",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "^[^a]*[ABC][^e]*[0-9]*$",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "DTMF combinations:0*0*1*0*1*2*0*1*2*3*0*1*2*3*4*0*1*2*3*4*5*0*1*2*3*4*5",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "DTMFCOMB   DTMF[0-9A-B-C-D-a-b-c-d]",
        "passed": false
    },
    {
        "id": 2507,
        "completion": "(\\d*[A-D|B-A|D-B|B-A|A-D]).*",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "(\\s*-?\\d+(,\\s*-?\\d+)*)",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "/^\\d+(?:,\\d+)?$/",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "/^\\d+,?\\d+(?:\\s*\\d+)?-?\\s*$/.Sample Input : \"1,2,3-\"Sample Output : 1",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "(\\d*[\\-\u2013\u2014\u2014\u2014\u2013\u2013\u2010\u2014\u2013\u2013\u2014\u2013\u2014\u2013\u2014])|(\\d*[-\u2013\u2014\u2013\u2013\u2014\u2014\u2014]{2,})",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "(?P<number>\\d*[1-9]\\d*)(,|$)",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "(00\\d{3}-\\d{2}-\\d{2})[\\.\\s,]+0",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "(?<sep_no>\\s+|\\,\")0-9,\\s+0-9(?=,|\\\")",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "^\\d{1,2}-\\d{1,2}$",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "(1|[12][0-9][0-9])$|(1|[2][0-9][0-9]|[3][0-9][0-9]|3[0-3][0-9])",
        "passed": false
    },
    {
        "id": 2512,
        "completion": "^(?:\\d+[,\\s]?\\d*)(?:,\\s?\\d+[,\\s]?\\d*)*",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "Pattern +91I think the first part will give me the prefix which is +91... the second part will give me the text of the number. Then you just need to combine them to get \"10 digits followed by +91\"",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "Pattern\\+\\d{4}I have written regex in C# as for this: Regex.IsMatch(textbox1.Text, @\"^\")Expected Output in this answer as \"Is Match Available\"?",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "[A-z0-9]{4}?[-\\+]?[0-9]{2}[A-z0-9]{3} 5.3.5 The Prefixes and Suffixes for Numbers, Letters, and Symbols",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "Pattern = \"(1+91)\", where 1 is the actual prefix",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "Pattern +91.",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "[0-9]{1}-[1-2][0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{2}.If you find any prefix (0-9) of the 10 digit you can get all the 10 digits.",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "pattern = \"(^|^|^|^|^)(?=\\d{10}$)(?=\\d{3}$)(?=\\d{2}$)^(?=\\d{1}$)\";",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "(\\d{2})\\+91Exercise #3:Find a phone number that has both the prefix- like the number 1234567890 where 123 comes the prefix and after that 4567890 is the rest which can contain letters, numbers and periods.Answer: 1234567890(the full number will contain 5 digits)",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "\\b[1-9]\\s?\\d{1,10}|[1-9]\\d{9}\\b",
        "passed": false
    },
    {
        "id": 2519,
        "completion": "^[\\d]{10}[,\\d]$",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "((?:[A-Za-z0-9]{8}[SC]\\s){10}(?:[A-Za-z0-9]{4}[SC]\\s){10}).{8,10}",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "([0-9]{1})|([0-9]{2})([0-9]{4}))https://regex101.com/r/cvqrwY/1",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "0[123468]|0[246800]|[0-9]{8}",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "^(1\\\\|0|\\\\|999)0\\d{1,2}$",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "The Regex would be [A-Z]{1,2}\\d{8,9}\\b",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "((?:[a-zA-Z]{3}[a-zA-Z]-[a-zA-Z]{2})|                                ([1-9][0-9]{3}))                                || (?:\\1([1-8][0-9]{3})|                                                (?:\\1[a-z]{3}",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "/^(SC|S|I|E|R||I|E|N)\\/[1-9][0-9]{0,3}$/Lecture Note: Subsection 5.6.9 - Best ways to validate and sanitize form data and cookies",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "^[0-9]{8,09}$",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "^(?:\\s*(\\d\\d\\s){7}|[a-z]\\S{0,3}\\s[a-z]{0,3})(?:\\s*[:punct]\\s){0,5}$",
        "passed": false
    },
    {
        "id": 2531,
        "completion": "[^a-z^A-Z[^a-z^A-Z][^a-z^A-Z0-9]{6}] Now modify the example above to search for a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowedGenerate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "0 +.*(",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "\\d{1}",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "(\\d)+,",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "[,,34],[88",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "[^\\d]",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "(?:\\d",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "([[\\d]+",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "\\b(\\d",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "[1],[],[\\",
        "passed": false
    },
    {
        "id": 2536,
        "completion": "[],[2",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "/(0?[1-9][0-9]|9[0-9]|99[0-9])[0-9]{10}/i",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "^[2-][1-9]?[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$ should do the job.",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "^\\d{4}|([\\d]{8})(\\d{0})?$",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "(?:\"(?\"mobile-no\"\\d{8})\"|\"empty|\"blank\"\\d{10})\"",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "\\d{1,11} OR 000000000000",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "^[08]\\d{9,10}$  this will accept all the Mobile nos starting with 8 or 9 and having exactly 10 digits (total)  or it must be blankGenerate a RegEx for this description",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "^(9|8.{1,}[9]{0,9})?[ ]*[0-9]'",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "/^[0-9]{10}(0|[9][0-9]{1})$/xYou could verify your regex using: (this is only a function prototype and not a method).The string will not match when you pass it through it in any other way (e.g. split, split into an array etc). Also, you may want to limit the search range to 1 character/digit",
        "passed": false
    },
    {
        "id": 2539,
        "completion": "\\b (?=^[09]{10}\\b)(?:[1-9]?[0-9]|[0]*)($|[^0-9]*))",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "([\\+\\-]?)(?:\\(\\d+,)?\\d{3})\\s|(?:\\(\\d+,)?\\d{3}-\\d{5})",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "\\b(\\(?\\d{3}\\)|[+])[-.]?\\d{3}[-.]\\d{4}.*",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "This will get you the pattern: [1-9][1-9]((0,?[1-9]))?|(1[0-3]|[0-8][0-9])[0-9](.*)",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "^(0[0-?]*)?[ -]?(65[.])?[ -]?(256[.])?[ -]?(1[5])\\d{0,14}$",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "[1-9][0-9]\\d{0,2}[-.]?\\d{0,2}[ -.]?\\d{3}3. [4-9][0-9]\\d{0,2}[ -.]?\\d{0,2}[-.]?\\d{3}",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "(?<=^[a-z\\-0-9]{3}\\.)(?<![a-z\\-0-9]{3,}\\.)(?<=\\([a-g]{3}\\))(?:[a-z]|[1-9a-f]{2})[0]{1,3}\\(\\s*[a-z]*[0-9]{0,3}\\)\\s*[a-z]*$",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "[0-9]{2}:[[0-9aA-Fa-f]{3}[0-9aA-Fa-f]{3}[0-9aA-Fa-f]{4}]",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "/[3][6][7]/",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "(.{8}[^\\-/]{3})([^\\-/]{1}[\\-/]{1})([^\\-/]{1}[\\-/]{1})([^\\-/]{1}[\\-/]{1})",
        "passed": false
    },
    {
        "id": 2542,
        "completion": "/^\\d*$",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "~^(((\\d{1,3}\\.){3}\\d{1,3})|(\\d{1,3}\\.){3}\\d{1,3})\\+$~.",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "/^(?:2|3)\\.(?:[2-9][0-9]|1?[0-9]{1,2}\\.){3}[2-9][0-9]$/",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "/((\\d|\\.\\d){1,3}\\.){1}\\d{1,3}/",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "$ip_regexp = /^\\[[0-9a-fA-Fa-f:.]+:([0-9a-fA-Fa-f\\.]+)/;",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "(?<!\\.)*\\.(.+\\.(.+\\.){3,})",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "/^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
        "passed": true
    },
    {
        "id": 2547,
        "completion": "[0-9a-fA-F]{1,4} \\d+ # 4 or more decimal numbers with 0-9 or a-f   ([0-9a-fA-F][0-9a-fA-F]{1,4})\\.([0-9a-fA-F][0-9a-fA-F]{1,4})/3Here ^ matches the start of",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "^((0|[1-9]\\\\d?|1\\\\d\\\\d)\\\\.)4[0-9]{2}(\\\\|[1-9]\\\\d?\\\\.){3}[0-9]{1,3}$",
        "passed": false
    },
    {
        "id": 2547,
        "completion": "^[[0-9]{1,3}\\.]{1,3}\\[[0-9]{1,3}\\.]{1,3}\\[[0-9]{1,3}\\.]{1,3}\\[[0-9]{1,3}\\.]{1,3}$Use : perl -pi -e 'print ipv4_networks {\"\\0\". pack(b8), \"0\", \"0\", \"0\"} ;",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "^[0]?[1-9](?:0+[1-9]){6}$This is the regular expression that can be used to check this type of input.",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "(?=\\D|\\Z)[0-9]{7}$",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "^(?=.at{7}$)(?!\\d*$))\\d+(?:\\.\\d)+$",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "^(?=.*[1-9][0-9])[0-6]\\d{7}$",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "^(?=.{11}$)(?=^(?!0{7}$)(?=.*\\d).*$).*\\d{7}$",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "\"^((\\d{0,3})\\d{0,3})\\d{0,4}$\"",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "^0*[0-9]{6}$",
        "passed": false
    },
    {
        "id": 2548,
        "completion": "^[0-9]{7}$;",
        "passed": false
    },
    {
        "id": 2548,
        "completion": ".{7}Exercise 4: Write a Python RegEx that matches any strings that begin with 'cat' and end with 'dog'.Answer:.*cat.*dogExercise 5: Write a Python RegEx that matches any strings with three words and exactly two characters in between each word and that are separated by exactly two spaces. The words will need to be",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "import repattern = \"#^[a-zA-Z]{3}\\s[0-9]+[-_.][0-9]{2}\\s[0-9]{2}\\s[0-9]{4}\\s(\\d{1,2})\\-\\d{1,2}\\-\\d{4}$#'",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "The following is a Python code snippet to generate a regular expression for this description: import re",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "import re",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "```pythonimport refrom datetime import datetime",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "This involves first checking the string entered for validity using the dateparser library. Then, it uses a RegEx to check that the input matches the necessary format. Finally, it validates that the entered date falls within the correct year range and that it is a leap year.",
        "passed": false
    },
    {
        "id": 2549,
        "completion": "",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "^(?:(?!00$)[1-9]|[1-9]$)*\\d{9}(?:,",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "This is my attempt using this explanation.^([,])(\\d+)(,\\d+)*$valid expression",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "@\"\\\\d{1,3},\\\\d{1,3},\\\\d{1,3},\\\\d{1,",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "^[0-9]+,[0-9]+,[0-9]+,[0-9]+%|^[",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "^(?!.*[^0-9,]+)(?=[^0-9,]*(,[0-9]+,",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "\\d{1,3}(,\\d{1,3})+,\\d{0,7}",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "[ \\d],[\\d]+,[\\d]+,[\\d]+,[\\d]+,[\\d]+,[\\d]+,[",
        "passed": false
    },
    {
        "id": 2550,
        "completion": "Valid expressions are:123,345,4444444,56,6",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "(0.)+(0.){2,15}[.]",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "[a-zA-Z0-9]*[0-9]?[a-zA-Z0-9]?[a-zA-Z0-9]*[a-zA-Z0-9]?",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "^0+(((([[0]{1,48}|25[0-5]|2[0-4]0|[01]?[0-9][0-9]?)\\.){3}(0|1[0-9]?|2[1-9]?|[1-9]?[0-9]?))(\\s|$))$",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "function generateRegEx($ip) {    return $ip!== ''       ?!preg_match('/^(10|[1-9]\\d*\\.){3}10/', $ip)           ? '((10|(10)[0-9]|[1-9]\\d{2}))'. '(10|[1-9]\\d*\\.){3}10'. ''             :",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "^(0*)(1\\d\\d\\d\\0*)(|1\\d\\d\\d\\0*)$A few notes:",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "(?!0).\\d{3}\\d.\\d{3}\\.\\d{2}$",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "^\\\\d+([.]\\\\d+)*$",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "\\d{3}\\.\\d{3}\\.\\d{4}",
        "passed": false
    },
    {
        "id": 2553,
        "completion": "https://regex101.com/r/9Y7OzM/1/",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "(https://regex101.com/r/bPTe1o/2) (https://regex101.com/r/bPTe1o/5)",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "^S\\s?[\\d\\.]{1,3}(,\\s?)[\\d\\.]{1,3}\\s?E?\\s?[\\d\\.]{1,3}(,\\s?)[",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "The best way to get your description is by researching online for examples of Regexes that match this type of pattern.",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "[(N,\\d{1,2}(\\:\\d{2}))+(E,\\d{1,2}(\\:\\d{2})).{100}\\] => N 0:59:59.99,E 0:59:",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "N:[\\d\\.]+E:[\\d\\.]+",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "A possible RegEx for this description is \"([0-9]|0) \\d+\\:\\d+:\\d+.[0-9]+ | ([0-9]|0) (?:[^0-9]|-){3",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "(\\d{1,2}:\\d{2}:\\d{2} )*\\s?\\d{1,2}:(\\d{1,2}:\\d{2}:\\d{2})?",
        "passed": false
    },
    {
        "id": 2567,
        "completion": "([0-9]{1,3})? ([0-9]{1,3})? ([0-9]{1,3})? ([0-9]{1,3})?([0-9]{1,",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "^(?:[1-9]|1\\d|10)[0-9]*$",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "^[0-9]{0,10}$",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "(1|2|3|4|5|6|7|8|9|10)",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "Regex: (?<=1)(?=|$)(?<!0)(?=|$)(?<!1)(?=|$)(?<!2)(?=|$)(?<!3)(?=|$)(?<!4)(?=|$)(?<!5)(?=|$)(?<!6)(?=|$)(?<!7)(?=|$)(?<!8)(?",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "*1-4.*",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "^1-9$",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "1-9",
        "passed": true
    },
    {
        "id": 2570,
        "completion": "[6-10]",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "^(1|2|3|4|5|6|7|8|9|0); $",
        "passed": false
    },
    {
        "id": 2570,
        "completion": "^(1-9)(1-9)?$",
        "passed": false
    },
    {
        "id": 2572,
        "completion": "[[:lower:].to:A-Z]]",
        "passed": false
    },
    {
        "id": 2572,
        "completion": "^[a-z][a-z A-Z]$",
        "passed": false
    },
    {
        "id": 2572,
        "completion": ".?[a-zA-Z]",
        "passed": false
    },
    {
        "id": 2572,
        "completion": "([A-Z][a-z])|(?=.*?[A-Z][a-z])(?=.*?[a-z])",
        "passed": false
    },
    {
        "id": 2572,
        "completion": "[a-zA-Z]+",
        "passed": false
    },
    {
        "id": 2572,
        "completion": "regex=\"^[a-zA-Z]-(?:[0-9a-zA-Z]|[0-9a-zA-Z][a-zA-Z])$\"",
        "passed": false
    },
    {
        "id": 2572,
        "completion": "[a-zA-z]",
        "passed": false
    },
    {
        "id": 2572,
        "completion": ".*[A-Za-z]$",
        "passed": false
    },
    {
        "id": 2572,
        "completion": "^[a-zA-Z]{1}$",
        "passed": true
    },
    {
        "id": 2572,
        "completion": "^[A-Za-z]$",
        "passed": true
    },
    {
        "id": 2581,
        "completion": "",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "Here's an example:",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "In this example, comments are identified by anything that appears before the first right parenthesis.import re",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "SELECT * FROM mytable LIMIT 5 IF SELECT exists FROM mytable",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "```pythonimport mysql.connectorfrom mysql.connector import Error",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "[`'Select * from mytable where columns_regex('name', '^[A-Za-z0-9].*$') ` is not null']`Example SQL statement (without stripping comments): `'SELECT * FROM users where name REGEXP \\'^[A-Za-z0-9].*\\''`",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "import remy_string = \"SELECT * FROM my_table\"new_string = regex.sub('', my_string)",
        "passed": false
    },
    {
        "id": 2581,
        "completion": "",
        "passed": false
    },
    {
        "id": 2588,
        "completion": "The hexadecimal RGB color values begin with a # symbol followed by uppercase 'A-F' letters followed by numbers (0-9). For example: #FF72622 #DE1C4FA #3F2E6F5 and so on.",
        "passed": true
    },
    {
        "id": 2588,
        "completion": "^#[0-9a-fA-F]{4}$",
        "passed": true
    },
    {
        "id": 2588,
        "completion": "^#[a-zA-Z0-9]{3,7}$ (the # symbol must begin with a # and be followed by 3-7 uppercase or lower case letters or numbers only).",
        "passed": true
    },
    {
        "id": 2588,
        "completion": "^#([0-9A-F]{3}[0-9A-F]{3}[0-9A-F]{3}|[0-9A-F]{6}|[A-Fa-f0-9]{7})$",
        "passed": true
    },
    {
        "id": 2588,
        "completion": "#[^A-Fa-f\\n]#{1,64}",
        "passed": false
    },
    {
        "id": 2588,
        "completion": "^#[0-9A-Fa-f]{6,20}$",
        "passed": true
    },
    {
        "id": 2588,
        "completion": "~#([0-7A-Fa-f]A-F)",
        "passed": false
    },
    {
        "id": 2588,
        "completion": "#\\w\\w",
        "passed": true
    },
    {
        "id": 2588,
        "completion": "#(?=\\d+?[A-F])([A-F]\\d+?)",
        "passed": true
    },
    {
        "id": 2588,
        "completion": "\\#[A-Fa-f0-9]{6}",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2591,
        "completion": "This pattern matches italian mobile phone numbers:- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)- 3 Italia (390, 391, 392, 393)- RFI (313)- virtual operators (370, 373, 377)Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "\\b((?<!^)(?:\\d{4}-\\d{2}-\\d{2}-\\d{2}:\\d{2}:\\d{2})\\b(\\d\\d(?=\\d))|(?<=:\\d{2}\\(|\\())\\d\\d(\\b))$",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "(?=\\d{3}-)",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "(?i)\\b(?=\\d)(?!^0)(?=[0-9]*[0-9])Examples of numbers in the string 2357342357342341234",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "^([01]?[0-9]{2})\\s+(.+)-([0-9]{4})(?=(.+\\s+$))",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "$S2L[0-9]",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "\\w{9,} 2. The zip code of my zip code starts with the letter \"A\" and is 7 digits in length. Identify the RegEx for this description. Answer: ([A-Z]\\d\\d){7}",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "* \\d0+",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "pattern= r\"#(\\d*[^0]){5}#\"#This regular expression will match a sequence of 5 non-zero digits, in \"length5format\".",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "d => '^s'                                           r => '\\d{2}(\\d{3})+'",
        "passed": false
    },
    {
        "id": 2593,
        "completion": "^[a-z0-9]{1,10}$",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "\\S\\d(\\.\\d{2})[a-zA-Z]\\d\\d",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "```pythonfrom re import compile",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "The code is 99 00 AA. The Regex could be \"99\\s00\\s+AA\" or \"99 00\\s+AA\".",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "[0-9] \\s{0,1}\\d{3}",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "(\\d{3}[A-Z]{2})([A-Z]{2}|[0-9])$",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "\"9999\\s+A\" (with 1 space)",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "r'\\A(\\d{1,3}-\\d{1,2}-\\d{1,2}[.]){0,1}(\\d{9})\\Z'",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "(?<=^ )\\d{3\\} (?= \\d{5})",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "[0-9]{4} [0-9]{2} A",
        "passed": false
    },
    {
        "id": 2603,
        "completion": "/^\\d{9}A.$/",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "\\$(([1-9][0-9]|[012][0-9]|3[01]))\\.([1-9][0-9]|[012][0-9]|3[01])Exercise 2: Write a Python regex that validates the syntax for a US government identification number (GIN). Answer: ^[1-9][0-9]\\d{2}-?[1-9]\\d{3}",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "A RegEx for this description is '^[A-Z]{2}[0-9]{11}$'",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "#(?<N>\\d{14}\\s[\\-\\*]+)?#",
        "passed": false
    },
    {
        "id": 2606,
        "completion": ".*[-a-zA-Z0-9. (.]*$)",
        "passed": false
    },
    {
        "id": 2606,
        "completion": ".*\\d{9,15}",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "^[789][a-z]{2}\\.([0-9]{3}.{1,3})$    2. Match the following Medicare HIC number according to CMS specifications.         a. 6380055.    b. 21059903.    c. 10305549.    d. 6123558.",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "(([0-9])[- ]?([0-9])[0-9][- ]?)(([8][0-9][0-9])|([0-9]{3}))\\.([4][0-9][0-9])\\.([1-9][0-9]{2})\\.(1[0-9]|[2-9][0-9]|[1-9]{4})Regex",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "01(00|-|\\d\\d|\\d\\d\\/\\d\\d) 00(00|-|\\d\\d|\\d\\d\\/\\d\\d) \\d\\d\\d\\d\\d\\d\\d",
        "passed": false
    },
    {
        "id": 2606,
        "completion": "(?<PatidateNumber> \\d{3} \\d| \\d{3} \\d\\d) \\. Medicare",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: /^[^i]*[^l]?[^o]?",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: ^(?=.*\\d)(?!.*(i)(?!.*(l)(?!.*(o)(?!.*(e)(?!.*(o)(?!.*(q)(?!.*(O)(?!.*(Q)(?!.*-))))))))(?!.*i)(?!.*l)(?!.*o)(?!.*o)(?!.*o)(?!.*o)(?!",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: ^(?![qlrio-])[0-9]{11}$",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: ^[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}$",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: [0-9]{5}-[0-9]{4}",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: [6-9][0-9][0-9][-]{3}$",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: /^([0-9]{10})-([1-9]{2})([0-9]{6})$/",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: r/^[a-zA-Z][0-9]{8}-[a-zA-Z]$/",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer: (([a-zA-Z0-9])\\1{2,}(\\s?[iIlO{}])?[a-zA-Z0-9])",
        "passed": false
    },
    {
        "id": 2618,
        "completion": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q,'or -.Generate a RegEx for this description. Answer:^(?!.*[i])(?!.*[l])(?!.*[o])(?!.*[o])(?!.*[b])(?!.*[q])(?!.*[o])(?!.*[q])(?!.*[y])(?!.*[o])[0-9]{11}$For this description, we will use",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "/^([\\d]+)([A-Za-z ]+)\\s+[-]([A-Za-z \\d]+)\\s?([0-9]+)?$/",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "\\bAddress No\\s\\d+\\s[Aa]dders\\s[^,/\\s]+\\s[.\\d+[^,]\\d+\\b",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "^((\\w+)\\s+[a-zA-Z]*)?([0-9]{5}[a-zA-Z]{2}) # (1 + 5 digits)[a-zA",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "[a-zA-Z0-9 \\s]{7,25}\\s[a-zA-Z]For any other formats, please let me know.",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "/^\\d{1,3}\\s+\\w\\s+No\\s+\\w?\\s+\\w{1,2}\\s+[A-za-z\\s]?{0,1}\\d",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "(?<prefix>(?<number1>[0-9]+)\\s)?(?<number2>[0-9]+)[\\s\\.](?<street>[^\\s]+)[\\s\\.](?",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "\\b\\d{2}\\b_\\d{2}\\b_[a-zA-z]{0,3}\\b",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "\"^Address No\\s[A-Za-z]{5}\\s+\\s+[A-Za-z]{1}\\s+[A-Za-z]{1}\\s+[0-",
        "passed": false
    },
    {
        "id": 2620,
        "completion": "[^a-zA-Z_]",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "```    [\\D\\t\\w] + *[\\d:]\\d* + [\\D\\t \\t]    ```",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "(.*(?<=Open:\\s+)(.*(?=$|Close:\\s+)))(.*)",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "re.compile(r'([0-9]{4}):([0-9]{2}):([0-9])')",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "(0-3)\\s?[\\/|\\t]*[\\-][0-9]s?[\\/|\\t]*(\\\\s)?",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "t => [{        \"name\": \"The Office\",        \"open_time\": \"9:00am to 12:00pm\",        \"close_time\": \"2:00pm\",        \"days\": \"3 days\"      },       {        \"name\": \"My Pizza\",        \"open_time\": \"6:00am to 10:00pm\",        \"close_time\": \"",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "1st store hours: [0-5], 2nd store hours: [6-11], 3rd store hours: [12-17], 4th store hours [18-23], 5th store hours [0-5] - [10], and so on```python    first_store_open = \"0-5\"    second_store_open = \"6-11\"    third_store_open = \"12-",
        "passed": true
    },
    {
        "id": 2631,
        "completion": "Time: 8am-5pm",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "\\|(?P<open>1?\\d):(?P<close>\\d)(?:-(?P<interval>\\d*))?\\s",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "(^|\\s)([0123][0-9][0-9][-_][0-9]|10|15|20|35|40|45|60|65|70|75|80|90|100|200|300|400|460|600|650|700|800|900|1000|1200|1500|1800|2100|2300)($|\\s)",
        "passed": false
    },
    {
        "id": 2631,
        "completion": "(0-9)/(00:00:00) is a fairly standard format for describing a time.",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "([0-9]+)(.[0-9]{2})([0-9]{2})(.[0-9]{4})([0-9]{5})",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "[0-9]{2}[/\\\\-]?[0-9]{4}/[0-9]{2}/[0-9]{2}",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "^([1-9]{2}/){0,1}[1-9]{2}$",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "[a-zA-Z0-9]",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "(0?[1-9]\\d|1[0-2]\\d|3[01])(Jan|Mar|Apr|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(Jan|Feb|Mar|Apr",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "\\d{1}\\s+[a-zA-Z]",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "(?<=\\d{1,2}/)(?!\\d{2}\\s\\d{1,2}/){.{4}}I think its correct answer.",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "[0-9]{1,2}\\.[0-9]{1,2}\\-[0-9]{4}Exceptions allowed :-0-9-0-[0-9]-9-0",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "^\\d{2}[\\d]{2}\\-(\\d{2}[\\d]{2})[\\da\\. ]*",
        "passed": false
    },
    {
        "id": 2634,
        "completion": "[01-9]\\\\/[0-2]\\\\/[0-9]{1,2}0 2 50-2-5Generate a RegEx for this description. Answer: 0\\\\-2\\\\-50-2-5Zero two five00-02-0500-02-5[012]{4",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "/^.+\\/",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "/^$/",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "/[^<>\\\"\\']+https://regex101.com/r/tVoXrY/1",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "/{root}/[\\w-]+]{1,15}/)*/",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "\"/(.)\"",
        "passed": false
    },
    {
        "id": 2635,
        "completion": ".+",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "/(?:www\\.)?(r\\.)?(([A-Za-z0-9\\-_:.]+\\.)?([A-Za-z]+)\\/)",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "regex = \"/^....?.*\"",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "[^/]* (any regex equivalent to this).",
        "passed": false
    },
    {
        "id": 2635,
        "completion": "/^/g",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on June",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on June",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2648,
        "completion": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.For Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on the",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "(?:(?![A-Z])(?![0-9])(?!$))(?<![A-Z](?=@)[A-Z])@I'm having troubles with my regex for the second question. It takes a string and replaces the whole first @ sign with the @ symbol. I'm also having trouble with a question where I'm using.* to match any amount of characters up to",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "/^(?!.[\\'()])(?!\\s+)[a-z0-9 ]*/Note: This allows one word between each character, but not between two words.",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "\\b[A-Z](?!\\d+)\\b [^A-Z]*?[\\s,_]+[A-Z]* $",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "^(?![a-z][0-9])(?![A-Z][0-9])(?![0-9][a-z])@",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "[^_a-zA-Z]",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "(\\S+#.*?)#",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "(?<!\\S)(_\\-)([#~\\S])",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "@There are three points after the characters are not allowed[^a-zA-Z]",
        "passed": false
    },
    {
        "id": 2649,
        "completion": "@(?=\\w+)(.+)($|\\W)(\\W)(?=\\w+)",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "^\\d{1,3}(\\.\\d{1,2})$",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "[^0-9]|(?<!^0)0(?=.)|(?<!^0)0(?=(?!.))So, this matches a digit which is not 0 or which occurs directly after 0. But, it also matches 0 in the string if it's allowed in other places.In your case, you can use^[1-9]|([0][1-9]|[1-9](",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "\\d+\\.?\\d*",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "^[0-9]*(\\.[0-9]*)?$",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "^(?=(?:\\.{1,4}|10|100|1000000)\\d)\\b",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "(?P<Number>[0-9]{{1,2}})(?P<Number3>[0-9]{{1,2}})(?P<Number4>[0-9]{{1,2}})",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "\\d+Demo: https://regex101.com/r/h9jF8z/1/",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "\\B[1-9]\\d{3}|\\d{3}[1-9]\\B",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "\\d{0,20}\\.(\\d{0,1})$",
        "passed": false
    },
    {
        "id": 2654,
        "completion": "^0*(?(1)([1-9])[0-9])0*0+(?(1)([1-9])0*(?(2)([0-9])[1-9]))*$",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "^(\\+|\\-)?\\s?(\\d+(?:\\.\\d+)?|\\d{3}[.,]\\d{3}|\\d{3}[.]\\d{3}|000)\\s(\\d+)?$",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "Regex - [\\+\\-\\.]?0?([\\d\\.]*).*",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "(regex)^([+|-])\\s*\\d{3}\\s*\\.\\s*(\\d*).*$",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "(Re)^(?P<whole>\\d+)(?:\\.(?P<decimal_part>\\d+))?$",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "\\d+\\.\\d+ (including decimals, and thousands separators and signs)",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "r'(^-?\\d+(\\.\\d+)?|\\d+|\\d*\\.\\d+)$'",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "(?<=\\d\\d\\d\\.\\d+)(?=-\\d+)?",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "(?<=\\s)(\\d+.\\d+|\\d+)\\,?",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "[a-zA-Z0-9][a-zA-Z\\s0-9:.,\\-]*(\\.[a-zA-Z0-9]*)? 4. Generate a regular expression that has an exact number of characters. Use the re.MULTILINE flag.Answer: ^(?:This|That|Neither) +$",
        "passed": false
    },
    {
        "id": 2655,
        "completion": "I need to use the re module in Python.```import re",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "[A9-9]\\d{2}-\\d{11,} (Note: the `\\d` characters denote digits, the `{2}` is for 2 digits, the `-` denotes a hyphen, and the `{11,}` indicates one or more occurrences)",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "**^\\d{12}$**Explanation: This RegEx will check whether an Indian mobile number (10-10 characters) follows the required pattern.",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "5[0-4]|[3-9]|[2]",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "\\d{15}(?!\\d{1,12}$)",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "The 10 digits are from 0-9, and the rest can be any number of alphanumeric characters along with underscores and dashes.",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "[0-9]{9}-[0-9]{2}-[0-9]{5}",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "^\\+?\\d{10}[0-9]{5}\\-[0-9]{4}\\-[0-9]{2}[0-9]{3}[0-9]{0}$",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "Regular expression for Indian Mobile Number is [0-9]{6}-?[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{2}-?[0-9]{10}",
        "passed": false
    },
    {
        "id": 2662,
        "completion": "(0) + (1?2?3?)[1-9]?",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "/^(?![0-9]{5})^[a-z]{2}-\\w*$/.",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "/^[A-Za-z]\\.?[A-Zabcd]\\.?[A-Za-z\\d]$/",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "\\b[a-z]{1}\\b (one character, either a-z)",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "/[A-Z]\\s|[A-Z][A-Z]$/g",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "^[A-Z]{2}[A-Z]\\s+[A-Z]{2}$",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "/^[mst](?=.[Ll]|[Rr][s][t]{2}|[1][0]\\d{3})$/u/Note: The $ sign could also be used to specify a non-lazy end of string.",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "states_territories = r'\\[[a-z]{2}_[a-z]{2}'",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "[^a-zA-ZA-Z0-9_]{1}(?P=x)[^a-zA-Z0-9_]{1}(?=y). A valid RegEx is ^[^a-zA-Z0-9_]{1}(?=x)[^a-zA-Z0",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "\\b(?<!C:\\d)(?:A?J|KS|M?D)S?\\bRegEx Result.[A-KS]?\\b",
        "passed": false
    },
    {
        "id": 2663,
        "completion": "(?i)([a-zA-Z]{2}(0?[1-9],0?[1-9]|1?[012])|([a-zA-Z](1?[012])[a-zA-Z]{1,2}))How Does All This Differ From A Normal Regex?You may have had some experience",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "(\\d{4})\\A-\\d{2}-\\d{3}\\.\\d{3}.\\d{6} (\\d{2}-\\d{3})-\\d{3}\\.\\d{3}.\\d{6} (\\d{2}-\\d{3})-\\d{3}\\.\\d{3}.\\d{6}",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "YYMMDD-9999(?!(?<![a-zA-Z0-90-9./-]\\d{7})-[a-zA-Z0-9]{3}-)[0-9]{6}-99-99.",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "The 9 digits are followed by -99 to 9999 in the following format, with the first four digits at one end, and the last four digits at the other end, and the 9-character prefix and suffix.  (0[0-9]1[0-9]|[1-9][0-9]|100[0-9])\\-99[0-9]\\d{4}\\.",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "YYYY/MM/DD[-_]{6}-99-9999",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "(example) (\\d{8})-([A-Z]{1})-([0-9]{4})-99(?(1))",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "YMMDD-*99-99**",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "[0-9]{3}/[0-9]{4}-99-9999[0-9]{3}",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "(00)00009-99-9999",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "This regex works for this description by having a starting period 'Y', followed by a 3 digit length, followed by the ending number '99-9999', followed by a 5 digit length of a random number.",
        "passed": false
    },
    {
        "id": 2664,
        "completion": "",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "^E{3}\\d{1,2}$",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "\\b\\d{3}\\.(\\d{1,2})\\b",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "^[IVXVV]\\d{3}(\\.)\\d{2}(\\d)$",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "Icd9 [1-9][0-9]{4}\\.[0-9]{2}",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "[0-9]{3}.(000[1-9])",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "(^[A-Z]\\d{3}\\.)?((?:[A-Z]{3}\\.)[A-Z]{3}\\.)?(([A-Z]{2}\\.)\\d{2})$",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "(?:V|[M|X]|[A]|[R]|[I]){1}.*[a-z]{1,4}[0-9]{1,2}[a-z]*",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "^[E]{0,1}\\d{0,5}\\.\\d{0,2}[V]*Exercise 3: Develop a regex to validate a credit card number, including the format and rules for Visa, MasterCard, and Discover. Answer: ^(4[0-9]{3}[MD]|5[",
        "passed": false
    },
    {
        "id": 2665,
        "completion": "",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "I've had this problem for about the last two weeks without any luck. When I try writing down the Regex, using the online tool \"python regular expressions r'[^a-zA-Z0-9]$'\", it never matches.",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "(?<n>\\d \\w)+",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "(?i)(?:\\d+)([a-zA-Z])(?:\\d+)",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "\\b[A-Z0-9](?:\\d{3}[A-Z])?\\b",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "(\\\\d{4}-\\\\d)(.)",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "CPT = [A-Z0-9]{3}",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "I want to find a character between the 5 (CPT ID) and 9 (numeric date) and keep any number of characters. (?:(?< = )[a-zA-Z]) is positive lookbehindHow should I make the above part (?:(?< = )[a-zA-Z]) a positive lookahead?",
        "passed": false
    },
    {
        "id": 2667,
        "completion": ".*[0-9]{4}[A-Z].*'",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "(.*[0-9]{4})([A-z])",
        "passed": false
    },
    {
        "id": 2667,
        "completion": "^([a-zA-Z0-9]+)([a-zA-Z]{1})*        The beginning of the line \\A means \"beginning of the string\"        The first [a-zA-Z0-9] specifies one alphanumeric character.        The second [a-zA-Z] {1} means zero or one of the preceding",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "^[A-Za-z0-9_.-]{4,10}$",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "\\w{4,10}",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "^[0-9a-zA-Z_][0-9a-zA-Z_]*[0-9a-zA-Z0-9/.-]*$Explanation: This expression will verify all the given parameters.",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "(^[A-Za-z0-9_.-]{4,10}$)",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "[a-z][a-zA-Z0-9_.-]*",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "```python validate_username = re.compile(r'^(?=.*[a-zA-Z01234567890])[a-zA-Z0-9_.-]{4,10}$')",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "/^[a-zA-Z0-9][a-zA-Z0-9-\\._.]{0,2}[a-zA-Z0-9]$/",
        "passed": false
    },
    {
        "id": 2671,
        "completion": "^[a-z\\d][a-z\\d\\.\\-\\_]{3,10}$",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "I like the idea; I've had a similar one before.",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "H:nn:s|HH:nn:s? [0-9]+Note that HH:nn, HH:nn:12 and HH:nn:00 are also valid RegEx. The last two can be removed when using the two 'or' option in a single regex.",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "\\d{2}(?:[: -]\\d{1,2}|[: -]\\d{1,2}\\s)*",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "n is 1 or more digits, (H) is one or more lowercase English letters, (nn) is either one or more digits or at most 2 digits, HH - two times one or more uppercase letters, and SS - two times one or more lowercase letters.",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "(?i)^        [0-9]+                       // nn        [:][0-9]{1,2}              // ss        $                          // match after",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "The most reliable way to do this is by using a regular expression to take two digits in the range of 0 - 15 (both inclusive), separated by at least one \":\" or space, and the second two digits in the range of 0 - 15 (both inclusive).",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "\\d{1,7}:0-9?  This RegEx says \"match any number of digits 0-5 digits with 1-9 digits\". Example: 10:30 would match 0-910\\d:?\\d{1,7}:0-9 - would match 01, 10, 11, 12, 30 (for hours of 10 - 40)I'm thinking something like the following may work:[^: ]+    # any",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "^.*HH.*HH\\.*:? (hh\\d{1,2}):? (nn\\d{1,2}):? (ss\\d{1,2}) or HH:nn:ssGenerate",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "H:nn:ss or HH:nn:ss",
        "passed": false
    },
    {
        "id": 2674,
        "completion": "0[0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2} or 0[0-9]{1,2}:[0-9]{1,2}:[0-9]{1,2}",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "0 \\b - wordbreak",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "^[0-9,0-9,]{4}$ Exercise 4",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "r\"^[0-9,]*\\.[0-9,]{1,2}$\"",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "\\d{3}([,.]\\d{3})*",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "[\\p{Zs}]*                                  (no comma)([\\p{Zn}]+)(?:\\,\\s*(?:\\p{Cc}\\p{Cs}+)|\\s*(?:\\p{Zl})+)(?:\\,\\s*(?:\\p{Zn}+)?)*[\\p{Zs}]*                                  (space)",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "([\\d,](?:[\\d.]+\\,){0,255})([\\d.]+)?",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "+([0-9]{1,3})(.{1,3})?",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "[^0-9.](?:\\.[0-9])?(?:[k]\\.)?[0-9]{,2}",
        "passed": false
    },
    {
        "id": 2684,
        "completion": "+(-\\d+)\\,?\\d\\d",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "\"^[0-9]{1,255}\\Z\"",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "(?:0+|^)([0-9]+|[1-9]0*)([0-9]+)",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "(0*?){5}1[+^0]*",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "\\\\b0.{1,4}\\\\d+[1-9]\\\\d*\\\\bExplanation: \\\\b           : Word boundary to avoid \"2345678\" as a regex, and to avoid \"23.45\"0             : Literal \"0\"\\b           : Word boundary for each number to make \"2345",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "[0, -1, 1, 10, 100, 1000, 10000...]Explanation: [0]: one-0:-1: -0..*1: 110: 10...100: 100...1000: 1000...10000: 10000... (invalid)",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "(?=(^|.)\\s)(0*)([1-9][0-9]*)$Example:",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "The pattern should look like this: ([1-9],[0-9][0-9][0-9])",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "([1-9][1-9][0-9]|[0][0-9]+|100|10000|1000000|10000000)+",
        "passed": false
    },
    {
        "id": 2699,
        "completion": "(?=\\d{3}$)^(?=\\d{2}$)(?=\\d+$)^[01]{1,3}The (?=\\d{3}$) Positive Lookahead(?=\\d{2}$): It makes sure the first 3 digits are strictly positive and are followed by only",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "(.|\\+)?1(00|12)?[0-9]{3}",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "\\\\1\\\\2-\\\\3",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "[00]([0123][0-9])[0-9]{3}[ +]([0123][0-9])[0-9]{3}",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "The RegEx for this description is /^[0-9]{3}[.] [0]{3}[.] [0]{3}[0-9]{9}$/",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "^(\\+00)?[1-9][\\d\\.]*[\\+00]?[1-9][\\d\\.]*$",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "^\\+\\d{2}(\\.\\d{3})?$",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "0[3-9]\\d{3}|\\+[1-9]\\d{2}|00[2]\\d{3}||00[1-2]\\d{3}||000[1-9]\\d{3}||0[1-9]\\d|0000[1-9]\\d",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "You can use the pattern \"\\+12|0012|0912\" to match phones that use international dialing codes.",
        "passed": false
    },
    {
        "id": 2703,
        "completion": "^0{2}[\\+]\\d{3}[\\+]0{3}$ or ^0[\\+]\\d{3}[\\+]\\d{3}$",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "r'^\\d+\\.\\d{1,2}$'6. Write a RegEx that matches an email address with an '@' symbol.   Answer: r'^\\w+@\\w+\\.\\w+$'   7. Write a RegEx that matches a series of numbers (including 0 and -) in scientific notation.    Answer: r'^-?\\d+",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "^[1-9]?\\d?(.\\d){0,2}$",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "(^|\\+|\\-)(1[0-9]|2[0-9]|3[0-1])(|[0-5])$",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "0*(\\.0)?(?<=%)?(?<!%)[1-9]\\d?/100",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "0\\.{% 1,2}\\d*",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "^[0-9]{0,2}(([0-9]{1,3}[|%]){0,3}){0,2}(([0-9]{1,3}|[][()]{1,3}[^|%]){0,3})$",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "^[^,]+[\\d,]{0,2}([\\d,]{0,2})?[^,]+[\\d,]{0,2}([\\d,]{0,2})?[^,]*$",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "^.{1,100}$",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "r\"\\d{1,2}[\\.]?\\d{1,2}(%)\\?\"",
        "passed": false
    },
    {
        "id": 2710,
        "completion": "\\.(\\d{1,2}|\\d{1,3}|\\d{1,4})?\\.(\\d{1,2}|\\d{1,3}|\\d{1,4})?(,[\\d.,#/><:$&]+)?$Exercise 5:Generate a RegEx for the following description: Valid email addresses are composed of two parts separated by a",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "\\d\\d\\d\\d-\\d\\d-\\d\\d",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "https://github.com/honeypot4/regex-version-formatting-generator/blob/master/vf4/reg-matches-4_vf4",
        "passed": false
    },
    {
        "id": 2735,
        "completion": ".*(\\d{2})-(\\d{2})-(\\d{4})$",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "https://regex101.com/r/0A2hY3/1",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "^[0-9]{3}[0-9]{3}[0-9]{2}$",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "\\d{3}[.]\\d{2}[.]\\d{4}",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "(\\d{2}\\.\\d{2}\\.\\d{2})/(\\d{2}\\.\\d{2}\\.\\d{2})/(\\d{2}.)",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "/^(?P<year>[0-9]{2})[0-9]{2}[0-9]{2}$/",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "The regular expression string that generates the description for the file, must be created here.",
        "passed": false
    },
    {
        "id": 2735,
        "completion": "/xxx (yyy)? (zzz)? (zzz?)/i",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "[^/.]*/",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "(^.+?\\/.*?\\..*)*$And:[\\\\.\\/]+[0",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "[0-9]{0,2}[/]*[0-9]{1,3",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "[0-9]{1,2}/[0-9]{1,2}/[",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "[a-z0-9][a-z0-90-9]+[a-z0",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "\\b(?:[0-9]\\d|1\\d\\d|2[0-4",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "\" [0-9]{1,3} \\.[A-Z]{1,4} [",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "/\\d\\.\\d\\.\\d\\.\\d\\s+[a-zA-Z0",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "\"[\\\\'/]+\\\\/[\\\\'/]+\\\\/[\\\\'/]+\\\\/[\\\\'/",
        "passed": false
    },
    {
        "id": 2740,
        "completion": "([A-Za-z0-9\\-\\_]+)\\\\.([A-Za",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "\\b1[0-9]{3}\\.[0-9]{3}\\.[0-9]{2}[0-9]?[0-9]\\b",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "https://regex101.com/r/rP1rR0/2",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "(\\d{0,3}\\.){3}\\d{0,3}|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\|\\d{1,3}\\.\\d{1,3}\\\\.\\d{1,3",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "(?:\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\d{1,3}\\.\\d{1,3}[^\\.]|\\d{1,3}[^\\.]\\d{1,3}\\.)+[^\\.]?",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "(0+)1\\.[1-9][0-9]{1}\\.[1-9][0-9]\\.[1-9][0-9]\\.[1-9][0-9].[0-9]{1}(:[0-9]{1}){3}|(0+)1(:[0-9]{1}){5}|(0+)1(",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "[^127]0?0?[1-9]\\d?",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "0(?!127)$Explanation: The regular expression means check if the last number in the IP address is not all 0. Exercise 3: Generate a RegEx which has an uppercase \"A\" character before and after any character other than a colon. Answer: ^[a-zA-Z]:?.*(?<![a-zA-Z]):|",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "(1+123)\\.4\\.(123)\\.0\\.(0)",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "((?:-[1-9]\\d*\\.)|(1[5-9]\\d{2}|2[0-4]\\d|25[0-5]|2[1-9]\\d|[1-9]\\d)(?:\\.|$))",
        "passed": false
    },
    {
        "id": 2742,
        "completion": "^[1-9]\\d{0,2}\\.\\d{0,1}\\.\\d{0,1}\\d{0,4}$",
        "passed": false
    },
    {
        "id": 2753,
        "completion": ".{6,29}/\\.{1,4}/[0-9]{4}[ \\/]?[0-9]{2}[ \\/]?[0-9]{3}.[ \\/00]?[0-9]{2}",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "%B/%d/%Y, %B/%y, %B%d",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "([0-9]{4})/([^/]*)/([0-9]{4})",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "((1[5-9]|5[0-2])/(1[0-8])/(2[0-9]|3[01]))*(4(0|1))",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "(((0|[1-9])\\d\\d)/0$|((1[6-9])/\\d{2})/0$)",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "(see below)",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "/^(\\d{4})/?\\s?(0[1-9]|1[012])/(0[1-9]|[12]\\d|30)$/2. Write a Regular Expression for the following expression. The expression validates any phone number in the",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "^(([0][1-9])|[12][0-9])\\/'(19(?:[1-3])|(?:1[0-2])|4[0-9])'$",
        "passed": false
    },
    {
        "id": 2753,
        "completion": "^17\\d\\d\\d$where \\d=range(10000,9991), because the range is a set of numbers and the regex is a set of strings. 17\\d\\d\\d is 17, 1999 etc",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "/(^(\\d{3}/\\d{2})/(\\d{2}/\\d{4})|^(\\d{2}\\/(\\d{4})/(\\d{2}))^(\\d{2}/\\d{2}))$",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "(\\d\\d\\/\\d{2}\\/\\d{2})",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "\\b([01][\\d]|2|3|4)[-/](0[1-9]|1[012])\\b.*([0-9]{4}|[0-9]{2}\\-(0[1-9]|1[012]))(?",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "(?:2|100)\\d{3}(?:1|5)|(?:0?\\d{2})?(?:0?\\d)",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "new DateTimeFormat(\"yyyy/m/d\").IsMonthOnYear(YearToValidate, MonthToValidate)",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "// ValidateDatevar re_format = new RegExp(\"^[0-9]{4}[/](0[1-9])[0-9]{2}/[0-9]{2}[0-9]?$\");",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "function isValid(input){var monthCheck = /^1[0-9]{1,2}\\/[0-9]{1,3}$/;var dayCheck = /^[0-9]{1,2}$/;var yearCheck",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "\\b(\\d{2})([0-1]?[2-9]|2[0-2])/(?:1[012]|0[01])\\d{4}\\b",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "\\d2[0-9]\\d \\d01$",
        "passed": false
    },
    {
        "id": 2754,
        "completion": "",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "(?<![\\[\\][0-9])(?:(?P<year>\\d{4}-\\d{2}) (?P<month>0[1-9]|1[0-2]) day(?:[-",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "yyyy/m/d | yyyy- m-d |     (?:   [0-9]{{4}})     (?:[1-2][0-9])   |     (?:   [0-9]",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "(\\d{4}/\\d{2})/(\\d{2})/. If the given field has a date-time that is in either yyyy/m/d or yyyy-m/d format, the expression validates that the date",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "\\d{4}-\\d{1,2}-\\d{1,2}\\ \\d{1,2}(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "https://regex101.com/r/e1T5H8/1",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "0(\\\\d{2}[-/]\\\\d{2}\\\\d{1,2})|1[0-9]{4}|(2[0-3][0-9]|1[0-2])200.([012",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "yyyymmd|yyyy-mm-dd|(17|18|19)'",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "$dt = preg_replace('/^(19|20|21|22)/$|^0/', \"/^$\", $dt);",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "(\\d{4}(?:-\\d{2}(?:-\\d{2}(?:-\\d{2}|20)\\d)?))",
        "passed": false
    },
    {
        "id": 2755,
        "completion": "var dates = [\"17/15/2005\", \"2020-01-01\",\"03/24/1998\", \"2000-02-1\", \"16/08/2000\"];var re = new RegExp(\"^((1[012])|",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "^(\\d{{0,9}}\\.)?\\d{0,10}$",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "[0-9]+([1-9][0-9]+)?(([0-9]{1}|1[0-9]{2})\\.)([0-9]{3})?$Note: The RegEx works fine for values like 45,737 and 872.0, and produces 5.37.Edit I was using an expression like \\d*(\\1\\.)*\\d*",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "/^(?:\\d+\\.)?[1-9]\\d?\\d*$/.{0}$/;",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "RegEx: [0-9]*\\.(1[1-9][0-9])|0\\.",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "{0,1}[1-9]\\d{0,3}, at the end of the number.",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "r'^[0-9]{1,5}(\\.\\d+)?$'",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "preg_match(\"/^0(?!00)1?[0-9]{12}$/\", \"0.123456789\", $matches);// prints the match array as expected.",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "(0.*)((\\d(?:\\.\\d+)?[Ee][+-])(\\d(?:\\.\\d+)?[Ee][+-]\\d*)?)",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "",
        "passed": false
    },
    {
        "id": 2761,
        "completion": "\\d+[\\.0]?",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "^((?=.*[A-Za-z])(?=.*[0-9])(?=.*[.])[A-Za-z0-9.-]{14,})$",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "^|^[a-zA-Z0-9]+(\\-[a-zA-Z0-9]+)+$",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "[a-zA-Z0-9\\\\\\d]",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "(?:\\w+)\\D",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "re.sub(r'[^\\w \\.-]','',nameGenerate)",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "This regular expression should look for a string that contains any digit that is not part of a number, but preceded by a number and not ended with a period. Answer: This regular expression should look for any string that contains any lowercase letter followed by a digit, followed by another lowercase letter, followed by a digit and not ended with a period. Answer: This regular expression should look for any string that contains an uppercase letter followed by a digit, followed by another uppercase letter",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "stringGenerate[A-Za-z0-9_]",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "/^[a-zA-Z0-9\\.\\_\\-\\s\\,\\=\\;\\:@#\\/%\\^&\\%\\*\\+\\?!\\(]+$/",
        "passed": false
    },
    {
        "id": 2762,
        "completion": "[^0-9a-zA-Z\\-\\(\\)]+This will generate a regex which will match everything except these characters like \\ or -.",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "|XXX-XXXX-XXXX|.",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "XXX-[0-9]{3}-[0-9]{2}-[0-9]{3}-[0-9]{3} | XXX-[0-9]{6}-5999 ; XXX - XXX - XX - XX ; XXX XXX XX XX",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "(?![- :/.]) ^ (?: [12]?[0-9] ) * [A-Z]{5} - (?![- :/.]) ^ [^ - :/.] *",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "XXXXXXXX-XX-XX-XX",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "[0-9]{3}-[0-9]{3}-[0-9]{4}",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "\\d{6}-(\\d{2})-(\\d{4}) (\\d+)",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "[A-M]{3}-[0-9]{6}Here is how regex works: http://www.regular-expressions.info/numbers.html",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "\\\\b([0-9]{3})-([0-9]{3})-([0-9]{3})-([0-9]{4})\\\\b",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "^\\(XXX\\.{3}\\-\\-\\-\\-XXX\\).{3}\\-\\-\\-\\-XXX\\$Please fill in the other digits. Explanation:^ - begin of string.XXX - three hexadecimal digits.-( - hyphen.",
        "passed": false
    },
    {
        "id": 2781,
        "completion": "[^-]{3}-[^-]{3}-[^-]{5} You will need to include this RegEx in your JavaScript function. The other option would be to run getAllNIPs and loop thru it. However, it's inefficient to have to loop thru each IP.",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "^[0-9a-fA-F]{4}-?[01]?[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}$, the pattern starts with four hexadec",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "/[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}-[0-9A-Fa-f]{2}/",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "^[0-9a-f]{2}[:-]?[0-9a-f]{2}[:-]?[0-9a-f]{2}[:-]?[0-9a-f]{3}$",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "^([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}$",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "\\a\\b(([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2})|([0-9A-Fa-f]{2}[:-]){6}",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "r\"^[0-9A-Fa-f]{2}[:-]?[0-9A-Fa-f]{2}$\"4. Write a regular expression pattern that will match all strings that have exactly 8 characters and begin with a capital letter. Generate a RegEx for this description. Answer: r\"^[A-Z]\\w{6}",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "([0a-9a-fA-F]{12}-){5}(?![0a-9a-fA-F])",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "^[0-9a-f]{2}-?[0-9a-f]{2}-?[0-9a-f]{2}-?[0-9a-f]{2}-[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}$",
        "passed": false
    },
    {
        "id": 2797,
        "completion": "^[0-9A-Fa-f]{2}-([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]$",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "[0-9]*\\.?[0-9]*",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "/^\\\\d*(\\\\.\\\\d+)?\\\\s?$/iExamples:",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "$1\\.00+",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "(.?\\d?|\\d+)\\.?(\\.\\d?|\\d+)",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "^([+-]?)(\\d+.\\d*)?$",
        "passed": false
    },
    {
        "id": 2799,
        "completion": ".{3}?\\d*\\.?\\d+",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "\\+?[0-9]+(?:\\.?[0-9]*)?([eE][+-]?[0-9]+)?",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "[0-9]+(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "\\+?[1-9][0-9]*\\.[0-9]*Explanation:",
        "passed": false
    },
    {
        "id": 2799,
        "completion": "^(0|[1-9][0-9]{0,3}|[1-9][0-9]{0,2})(?:\\.([0-9]{0,2}))?$",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "####-###-######-##-#######-####-#######I am not sure that I",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "^[a-z0-9]{5}[0-9]{6}[0-9",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "(^[A-Za-z0-9]([A-Za-z0-",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "^(?![A-Z])(?![a-z])(?!\\d)[\\pL\\",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "^(?=.*[\\w\\s])(?=.*[A-Za-z])\\",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "/^([a-zA-Z0-9]{5}[0-9]{3}",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "^[a-zA-Z]{5,15}([01]?[0-1]",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "^[789][012\\-0-9A-HJ-NP-Z]([01][0-",
        "passed": false
    },
    {
        "id": 2803,
        "completion": "^[a-z0-9]{5}[0-9]{1,6}[0",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "[^A-Za-z-'\\' '0-9]",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "\\w{0,3}\\-\\w{0,3}\\-\\w{0,3}\\",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "(?i)(?<=^.|\\s)(.{2})([-'])(.|\\s)((?=.|\\s)+$)(?=\\s|$)",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "^[a-zA-M0-9\\.\\ -_ ]*$",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "[a-z][a-z][A-Z\\s\\\\-\\\\\\']([a-z][A-Z\\\\s\\\\-\\\\\\'])?$'",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "/^\\S*(\\w)-\\S*(\\w) -\\S*\\w$/Example:In your database, you have a record like this,\"Jane Doe - \"With this record the Regular Expression for",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "(?<!\\\\)^[A-Za-z]{3}$(?<=\\-)",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "var pattern = new RegExp(\"(?<!^)\" +  \"(?!$)\" +   \"^.*'[-][-A-Za-z][-][-A-Za-z][-",
        "passed": false
    },
    {
        "id": 2809,
        "completion": "[^\\s'\\\"-][a-zA-Z0-9 ]+[^\\s'\\\"-]",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "\\b(12):[0-2][0-9]):[0-5][0-9]]* AM/pmThis will validate 12 hours time format without PM. The numbers 0-9 and 0-9 will be able to be placed anywhere (including after PM). The am/pm part will match AM or PM. Then, you just need to find the string that contains the two digits and a colon in the correct order. Hope that helps!",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "[a-zA-Z]+.[Pp]?[A-Z]?.[0-9A-Z]?[a-zA-Z]+",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "([\\d:]+)?[\\W\\s/]?am\\s/am\\s?([\\w/ ]+),",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "(.*)\\(([a-z]*)\\), it will match any character that is not [0-9a-z].",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "^(0?[1-9]|1[012])[a,m,p,q,r,s,t]{0,2}(:[0-5][0-9])?$",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "^(1|2[0-3]]|3[01])[0-9]{4}[0-9]{2}$",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "(\\d\\d)\\s(PM|AM)\\s([a-zA-Z]+)",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "((0|[1-9][0-9])|(1[0-2][0-9])|[1-9][0-9]|[1-9]))$",
        "passed": false
    },
    {
        "id": 2812,
        "completion": "(19|0[1-9]), (10|0[1-9]), (1[012]), (012)",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "0<[\\d.]+{0,1}\\d\\.+{0,1}\\d\\d<0>3\"",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "^1.000 to 1.400|^1.00 to 1.39|^1.000 to 1.39$",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "The valid range for urine lab panel specific gravity is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "RegEx: [0-9]?\\.[0-9]+e([+-][0-9]+) ([Ee][+-]?[0-9]+)? [A-Z",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "$validator = '/((\\d{1,3})(\\d{2})\\.\\d{1,2})/i';",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "(5) 0.<10^?",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "(.0{3,})\\s*[1-9]?\\d*(\\.\\d{3})?",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "([a-zA-Z]++\\s+[-a-zA-Z]++)?(?:[0]\\s0\\d*([a-zA-Z]))",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "\\([0-9]+.[0-9]?[0-9]?[0-9\\.[0-9]?[0-9]\\.[0-9]?[0",
        "passed": false
    },
    {
        "id": 2816,
        "completion": "([a-z]|[A-Z]) and ([0-9]|[1-9][0-9]*) decimals. The regular expression for this text is '[a-z",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "(0).*?(?:/.|,/) (1)?.*?/",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "^(?:\\d|2[0-4])(?:\\d|20)\\/(?:(?:\\d|1(?:[3-9]))|(?:\\d{1,2}\\))\\/(?:\\d{4}",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "(?P<day_month_year>[\\w/ ]+)\\/(?P<day>\\d{1,2})\\/(?P<year>\\d{2,4})[0-9]|(?P<day>\\",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "/* DMM/DD/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format */^[a-zA-Z]{1,2}\\d[a-zA-Z]{1,",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "[0-9]{1,2} [0-9]{0,2}/ [0-9]{2,4}",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "[^\\d]*(?=M|D)\\d{1,2}(?=\\/|\\/M)\\d{2}(?1)",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "@\"^(?:\\d{1,2}\\)/(?:\\d{1,2})/\\d{4}$\"",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "# -*- coding: utf-8 -*-##     date    : 2014-03-16T10:53:00.000Z##     reg   : -## @author   : mick",
        "passed": false
    },
    {
        "id": 2827,
        "completion": "\\d{1,2}.[/\\s]?[\\d{1,2}]|\\d{1,2}",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "\\b([a-z]{2}|[a-z]{3}|[a-z]{2.3})\\b",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "^\\d{2,3}|[a-z]+$",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "(w)ax([01][0-9])|([o][a-z][a-z][3-9])|([e][a-z]{5})Examples:",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "```pythonimport rewdays = '[' + re.escape([\"sunday\", \"monday\", \"tuesday\", \"wednesday\",                           \"thursday\", \"friday\", \"saturday\"]) + ']'pattern = r'^(' + wdays + r'|\\bi(' + wdays + ','+ wdays + ')",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "(?i)(?:week|WU|wk |weekend|WED |wed|ED |evening|EV|eve |wed|ET|et |eve|TE |TE |th|TU))",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "[\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "(days, weeks, months, years) - (days|'s', weeks|'w', months|'m', years|'y')",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "[aeiou]week$|[aeiou]weekday$|[aeiou]day[a-z]$",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "//The expression matches any weekday name (english) in short (2 or 3 characters) or full stylevar rgx = /^[aeiou](?!s)([a-z]-?[0-9]{1,2}(?:-[a-z]+)?)$/i;",
        "passed": false
    },
    {
        "id": 2844,
        "completion": "\"^[a-z]{2,3}\\s?[A-Z]{1}\\s?5\", [e-f]: \"^[A-Z]{1}\\[a-z][A-Z]{3}\\[c-h][0-9]\\[e-f][\\s]?1\",",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "(00\\d{2}-)(\\d{4}-)\\s(\\d{10})\\s\\D",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "^\\d{3}-\\d{9}-\\d{4}$",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "\\b\\d{4}\\s\\d{6}\\b",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "(^1[689]|19[456])[789]$.In the phone regex the first look ahead in RegExp will ensure that the string starts with a one, 9, 8,... then the digit is an 8, 4, 3,...9. The second look ahead (^1[689]|19[456]) will ensure that the string is either begins with a 1, 9, 8,..., or begins with a 19, 4, 3,...9 and then the",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "7.|8.|9.$",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "7 | 8 | 9 | 10",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "(?:^\\d{7}[^\\d]*(?:[1-9]\\d*)[^1-9]*$) (or [0-9]{3}-\\d{3}-\\d{3})",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "123.456789.1234567.",
        "passed": true
    },
    {
        "id": 3169,
        "completion": "0-9,10 to 9-999",
        "passed": false
    },
    {
        "id": 3169,
        "completion": "(0-9)0-9Now modify this RegEx to meet the constraints on the second digit, third digit... number of digits, etc that may be associated with your number format.You must also generate unique numbers for each unique phone number, and you must apply the same constraints regardless of phone number order.To add complexity you might want to search for all possible phone numbers for a given format. If you want to return multiple values you may need to use the $1, $",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "(00\\+|(\\s+\\-\\s+)?[a-zA-Z][a-zA-Z0-9]{3,10}(?:\\s+\\-\\s+)?[a-zA",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "^(00x?[-]+)?(1\\d{5,10})?(0[- ]?1[0-9]|[-\\s]1[0-9]{3,11})($",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "1-3+00-5-11What does:(?:(?:^1-)|(?:0-2(-)|))[ 0123456789]{5}$",
        "passed": true
    },
    {
        "id": 3207,
        "completion": "^(00[\\+\\- ][0-9]{1,2})([\\s-]\\(\\d{1,2}\\)\\s+][\\s\\-]\\d{5,11})$",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "^0[\\+ ]1[\\d ][\\$][\\s\\- ]0[\\+ ]1[\\d ][\\$][\\s\\- ]0[\\+ ]1[\\d ][\\$",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "^(00 xor '+')[1-3].(1|2|6)?( -).(-)?(0|1|2|3|4|5|6|7|8|9)?[.-]?",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "var preix = /^(00|[1-9]\\d?)( xor [+-] 0-9 )?([0-9]{3})( xor [+-] 0-9)?([0-",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "^0*((00 * xor '+')[0-9]{1,3})|(0 * ((00 * xor '+')[0-9]{1,3})\\*[0-9]{",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "/^(00 xor '+)0[1-9] xor '-)^(03 xor '-)0[1-9] xor '-)^(05 xor '-)0[1-9] xor '",
        "passed": false
    },
    {
        "id": 3207,
        "completion": "((00)[0123]?[0-9]?)|((00)|(-))[0-9]{5}((00)|(-))[0-9]{3})|(00)([1-9][0-",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "^\\d{4}|0\\d{3}\\d{2}|\\d{3}\\d{3}\\d{4}",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "(0?\\d|[12]\\d|3[01])/([0-9]\\d|[12]\\d|3[01])([0-9]\\d|[12]\\d|3[01])/([0-9]\\d|[12]\\d|3[01]) \\d{4}$",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "\\b[0-9]{3,6}\\/[0-9]{1,2}\\/[0-9]{4}\\b",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "[0-9Z-]{4,5}/[0-9]{3,2}[0-9]{3,2}",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "( (\\d+|1\\d|2[0-9]|3[01]) | (\\d+|1)(\\d)\\d(/\\d{4})? )",
        "passed": false
    },
    {
        "id": 3219,
        "completion": ".*[ ]{3}[1-9]/[1-9]/[2-9]\\d[0-9]{3}[0-9]\\d{2}[0-9]/\\d{4}",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "(?:\\+|\\-|\\,|\\:|\\/|$) *",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "1434|[0-9]{2}|[1-9]{3}|20(?=(\\.[0-9]))[1-9]{3}(?:[^0-9]|[1-2][0-9]?)?$",
        "passed": true
    },
    {
        "id": 3219,
        "completion": "2014(?P<DateStart>[0-9]{4})-([0-9]{2})-([0-9]{4})$",
        "passed": false
    },
    {
        "id": 3219,
        "completion": "D|M|YYYY",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "10-110, +1-1 (without D/c)",
        "passed": true
    },
    {
        "id": 3228,
        "completion": "",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "(?:\\([0-9]{3}\\)\\)?(?:\\([0-9]{3}\\)?)(?:\\(?[0-9]{3}\\)\\)?",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "/([0-9]{2})?\\s([0-9]{3}[-\\.\\s]?)?/",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "If the French number has international dialling code, then the RegEx will be different than if it does not.  Some examples of international dialling codes include +1, +44, +33 and +13. If the French number is a pre-international number such as 07 or 08, then the code can be +1, +064 and +044, but not +1 or +44.",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "For a call to Germany from France without a d-1 prefix, you could use\\(415\\)?.Exercise: List the common calling patterns that the French dialing code must match.Answer: The call should have an area number (e.g. 1, 3, etc.) and optionally start with a d-1 prefix or a d+1 prefix.",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "https://regex101.com/r/s_F3P4/1- Example: https://regex101.com/r/s_F3P4/2- Example 2: (e.g. for tel : ( +1) 123456)",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "\\b(\\+\\+\\d{1,3}\\).*",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "",
        "passed": false
    },
    {
        "id": 3228,
        "completion": "the only known code for this description is +1 (FR)",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "\\$?([1-9][0-9]*|[1-9][0-9]{0,2}).{0,100}",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "^[0-9]{1,}([\\.]?[0-9]{0,6})?$",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "(\\d{\"2,}|\\d{3})\" represents any two or more digits, a comma or three digits before that.",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "[0-9a-f]+(,[0-9a-f]+)+",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "^[\\d,.-][\\d,.-]+(;[\\d,.-])?$",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "(?!^[\\d\\t]*\\$)(?!^\\d[\\r\\n]*\\$)(?!^[\\d\\t]*\\,\\s*[\\d\\t,]*\\s*[\\r\\n]*\\s*\\$)(?!^[\\d\\t]*\\.,\\s*[\\d",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "^[\\d,.]*[\\d]",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "var input = \"15.99.00\";var regexNumber = \"(^\\d+\\.\\d+\\.\\d+)|(^\\d+\\.?\\d+$)\";",
        "passed": false
    },
    {
        "id": 3234,
        "completion": "(\\d{3})(\\.\\d{3})?$",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "(dd)|([.-]/)|([.-]/)|([.-]/)|([.-]/)|([.-]/)|([.-]/)|([.-]/)|([.-]/)|([.-]/))|(hh)|(mm)|(ss)|(:)|(:)|(:)|(:)|(:)|(:",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "dd.[.][-/][0-9]| hh.[:][-][0-9]| mm.[-][0-9]| yyyyUse the string: \"2030-09-22\" and the regEx. RegEx = \"([0-1][0-9])|([2]0-[0-9",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "([0-9][0-9][0-9]) - (\\d) - day([-.][\\d]) - (\\d) - optional minute (dot or comma)( \\.) - (dot or comma) - (optional second or zero)([0-9][0-9][0-9][0-9][",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "/^(?:\\d{1, 2}[\\.-]\\d{1,2}[\\.-]\\d{4}|\\d{4}\\s?:\\s?\\d{2}[:-]\\d{2}[\\.-]\\d{2})$/",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "(?i)(^(?:\\d{1,2}[ ])?\\d{4}[ ](?:[.-/]\\d{1,2}[.]\\d{1,2}[.]\\d{1,4}|\\d{1,2}[.-/]\\d{1,2}[.]",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "/(dd)[.-]?/([0-9]|1[0-9]|2[0-9])/([0-9]|1[0-9]|2[0-2])/*.[0-2][0-9]*(:[0-5][0-9])*/(\\s[0-9])",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "(?<day>3[.)./]0[0-2][.-/]0[0-9][.])|(?<month>0[1-9])[-.](02[-])|(?<year>[1-9])?[.-]?",
        "passed": false
    },
    {
        "id": 3264,
        "completion": "(0[1-9]|[1-2][0-9]|3[01])[.-/](0[1-9]|[1-2][0-9]|3[0-9])(0[1-9]|[1-2][0-9]|3[0-9])[",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "[^^][0-9][0-9][0-9][0-9][0-9]\\.[0-9]{4,6}$ (not necessarily)Please find a code for this case also.",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "(taxcode+Record+code+check_no)For example, the INN code can be the number 0123456789A.Note that it is common practise to store records in ascending numerical order, so if you have the following",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "(4 numbers)([0-9]{4})\\.([0-9]{4})\\.([0-9]{4})\\.([0-9]{3})",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "\\d+\\s\\d+\\s\\d+\\s\\d+\\s\\d+\\s\\d+\\s\\d+\\s\\d+\\s\\d+\\s\\d+ \\d",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "```python    # The INN code is here:     code='4 1 4 1 1 9'```",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "{number1}[0-9]{3}\\snumber2[0-9]{3}\\snumber3[0-9]{3}\\snumber4[0-9]{4}\\d{1}[0-",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "(4(7-6)-2(4-3)- 1(7-6)- 3(4-3)- 4(7-6)-6(4-3)-2(7-6)4-(9(1-2",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "([1-9]|0)*[1-9]{2}-([1-9]{3}|[2-9]{3})[1-9]{2}-([0-9]{1}|",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "https://github.com/mohamedzahid/inn-code-generator-regexHere's the example of this regular expression: import numpy as npimport re   code_of_tax_department",
        "passed": false
    },
    {
        "id": 3277,
        "completion": "[Tax_InN(4,5,1)].",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "(\\\\d{1,3})(\\\\d{2})(\\\\d{1,2})(\\\\d{5})(\\\\d+)(\\\\",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "\\d{1}[\\-\\s]{0,6}[\\d\\.]{4}[\\-\\s]{0,2}\\d",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "state_reg_code = ((state_reg_seq_num >> 5) & 0x0f) + state_reg_codes[state_reg_",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "^[1-9][a-zA-Z]{3}[0-9]{2}[0-9]{4} [A",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "The OGRN is (^(?P<stateId>[0-9]{5})(?P<seq>\\d{2,6}",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "(2[012])(\\d{2})[12]{1}(\\d{4})1",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "```pythonimport refrom datetime import datetime",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "0([0-9]\\d{2})\\.([0-9]\\d{6})([0-9]\\d)",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "_",
        "passed": false
    },
    {
        "id": 3278,
        "completion": "\\(^1[0-9]{{9}}\\d-2[0-9]{10}\\d{1}{7}\\d\\d$",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "`my_code_patterns_2020\\.(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|DEC)_[12][0-9][0-9]_[0-9][0-9][0-9][0-9]`2. What will be the pattern for the following text? Any of these: \"My First Nameis David\",",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "RegEx for 'dd/yyyy or dd/yy/yy or dd/mm/yyyy' will be `/[0-9]/[0-9]|/[0-9]/[0-9]|/[0-9]/[0-9]/[0-9]`.",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "(\\d{4}\\/\\d{1,2}\\/\\d{1,2},\\d{1,2},\\d{4})",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "\\b(\\d{1,2}/\\d{1,1}/\\d{4})\\b.",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "[\\d\\d][0-9][0-9][0-9][0-9]\\)",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "\\d{4}-\\d{1,2}\\/[0-9]{1,2}\\/\\d{1,2}```2. Write a Python program to check if an email adresses are valid.```python# Hints: The email addresses are limited to certain characters e.g \"no space\" and no @ symbol.",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "/[0-9]{1,2}(?:\\/[0-9]+)?[0-9]{4}/",
        "passed": false
    },
    {
        "id": 3280,
        "completion": "\\d{4}\\/\\d{2}\\/\\d{2}",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "([a-zA-Z0-9\\-_]+)",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "\\d+ - Matches one or more digits of length (optional)",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "You can generate a RegEx by using the \\| character, and specify that you want to match either of those characters. For example, you could use the expression \\+|\\-|\\*|\\/, which will match any of the symbols +, -, *, or /.",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "The RegEx would be: [^,]+.*",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "reg =  ^(?:[a-z0-9]{5}|[a-z0-9][a-z0-9\\-_.]*[a-z0-9][a-z0-9\\-_.]*[a-z0-9])$",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "The RegEx is /[a-zA-Z0-9_]+/",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "r\"<p>(.+)</p>([^<>]+)\"",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "(\\w\\w\\w\\w\\w\\w\\w\\w\\w\\w)\\w\\w(.*)\\w\\w(\\w\\w\\w\\w\\w(?=\\s))",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "<code>^\\b\\w+\\s\\w+\\b\\s\\w+$</code>",
        "passed": false
    },
    {
        "id": 3347,
        "completion": "\\d{5}\\-[\\W]$",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "-(20\\d{2})/(\\d{4})",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "-2-4-6-5|-2-4-5-5|4-4",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "\\d{4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "(19|2[0-9]|19[2-9]|202)\\/[1-3]\\/[1-9](\\d{2})?|20[0-3]\\/(?:(?:(?:1?[2-9]|1[0-2])(?:-(?:01|02)(?:0|1|2))|(?:(?:3[01])|(?:0",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "-19.19 -24.24 -1 -1",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "^[0-9]{4}-\\d{2}-$\\d{2}-\\d{2}$",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "Year-{4}-{2}-{2} - YYYY-MM-DD",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "(?<year>\\d{4})-?-(?<month>\\w)-?-(?<day>\\d{2})",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "YYYY-MM-DDExercise 3: Explain how to check the length of the text. Answer: Use the len() function to determine the length of the text.",
        "passed": false
    },
    {
        "id": 3349,
        "completion": "RegExp r\"\\b(19[2][0-9]-[1-9][0-9]-[1-9][0-9]-[1-9][2][0-9]|[1-9][0-9]-[1-9][0-9]-[1-9][2][0-9]-19[2][0-9]|[1-9][0-9]-[1",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "^[A-Z]1[A-Z]999[A-Z]?$",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "[A-Z]{2}[0-9]{3} [0-9]{1}[0-9]",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "^\\b[A-Z]\\d[\\s\\-]?[A-Z]\\d[\\s\\-]?\\b",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "^[a-zA-Z][0-9]{1,2}[a-z]{0,1}[0-9][a-z][0-9] [a-z][a-z][0-9][a-z]{1,2}$",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "^[A-Z]\\\\d\\\\d[A-Z]$As you can see, you need to add more characters, and to deal also with special characters, like. and -:/^[A-Z]\\\\d{2}[-A-Z]\\\\d{2}$/",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "^[a-z]{2}[a-z 0-9]{7}[ ][0-9-]{4}[a-z 0-9]$",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "(?:(?<![A-Z])(?<!\\d)(?=[A-Z\\d])(?!\\d)(?!\\d[A-Z])|(?<![A-Z](?<!\\d))(\\d)(?!\\d)(![A-Z\\d])",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "AA9A|AA9A(9AA)?|AA9A(9)?|9?(A|9|AA)?A9A|AA19A?A9A|AA9A 9A?|AA9 9?A 8A?|AA99 9?A9A|9A 9AA|A",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "^(A{2} \\d{1} {1} \\d{2}){2}$",
        "passed": false
    },
    {
        "id": 3368,
        "completion": "^AA (0-9A-9A9) (0-9A-9A9)$",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "(\\d{3})([A-Z]|\\d{3})([A-Z])(\\d{4})Examples:",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "\\d{2}-\\d{2}-\\d{4}",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "[00-40]{2}[Dd][Vn]|[00-49]{2}[Dd][Oo][Vn]|\\d{3}-\\d{3}-\\d{4}Explanation: A dutch moped has two numbers, sometimes the first is two fours, sometimes it is two three followed by an l. The first dutch number should always start with 0-4, the second number 0-3.",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "^(A{2}-{1,2})[0-9]{2}$ - This RegEx will validate either A-A or A-B. This RegEx can be used to check the format and validity of dutch moped licenseplate numbers.",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "RegEx: [A-Z]{1,3}[0-9]{6}[A-z]{0,1}",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "\\b(\\d{5}[A-Z]|[A-Z]{3}[0-8]\\d{2}\\b)\\b2.\\s*([A-Za-z0-9-_]{1,5})\\s*$Create a dictionary of common names in Dutch license plates.Answer: {'1': 'E', '2': 'J', '3': 'L', '4': 'U', '5",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "\\d{3}[.-]\\d(\\d{2})[.-]\\d{4}",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "(e.g.  (^[A-Z\\d]{2}\\.){6}[A-Z\\d]{2}$)|(^[A-Z\\d]{5}\\.){7}[A-Z\\d]{2}$).",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "",
        "passed": false
    },
    {
        "id": 3380,
        "completion": "\\d{2,7} - two to seven digits",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "re.findall(pattern, command)",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "```hostname -t - | awk 'NF{s[$1][$2]++; print $0;} END {for (i in s) {for (j in s[i]) printf \"%d \", s[i][j] }}'```",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\b",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "If I were to use this regex in my Python program, I'd use the `re.findall()` function as follows:```pythonpattern = r\"(\\d{1,3}\\.){3}\\d{1,3}\\.\"ip_addresses = re.findall(pattern, \"ip route 192.168.1.1 - - [21/Jun/2021:16:14",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "$ traceroute $(cat /var/route/10.8.9.23/ | tr \".\" \" \")  192.168.1.10  192.168.1.11  192.168.1.12  192.168.1.13 ...  10.8.9.723",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "^192\\.168\\.\\d\\.\\d$",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "$ cat iprex.shtraceroute $IP_address|traceroute -i \"(${IP_address}|$(ip2ip route -v $IP_address | grep ^( *)\\% )\\|( *)\\$)|\\|.*$\"",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "^.*$/^.*[0-9]+.[0-9]{3}\\.[0-9]{2}\\.[0-9]{1}/m$",
        "passed": false
    },
    {
        "id": 3381,
        "completion": "pattern = '[0-9][0-9][0-9][0-9]/[1-9]/[0-9]/[0-9][0-9][0-9]'",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "The RegEx pattern should be (?i)(?m)(?!?post[0-9A-Za-z]{7,})(?m)(\\{[A-Za-z]{2}\\{0,2}\\|[A-Za-z]",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "0[a-zA-Z0-9]{2,6}[a-zA-Z0-9]{4,32}",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "(AA\\d{1,5}\\d{2,6}\\d{7})|(AA\\d{1,4}\\d{5}(\\d|X)[\\dX\\w]{8})|(AA\\d{4,8}\\d{7}\\",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "\\w+\\d*{1}\\w+\\d*{1}\\d*\\d{1}\\d*\\w+\\d*{1}",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "[(?i)[a-zA-Z]{4}[a-zA-Z0-9]{1,7}[a-zA-Z]{1,10}]",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "(?:AA|A)\\d{2}(?:([A-Z]\\d{1})-([A-Z]\\d{1}))?",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "\"^([a-z]{4}\\d{4}\\d{4}\\d{2})\\s([a-z]{4}\\d{7})(?:[^A-Z]*([a-z]{3}\\d{3}$)|[^ ]*",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "^([A-Z]{2}){0,5}\\d{7}\\1[A-Z]{4}$",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "(AA(\\\\d{2}|\\\\d{4})){2}(\\\\d{7})```",
        "passed": false
    },
    {
        "id": 3383,
        "completion": "\\b(?=^[A-Za-z]{4}$)(?=^((?:(?!(?={4})).)+[A-Z]{4}))\\w{2,8}\\d{7}\\S$",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "^([0-9]{1,2}[A-Z]{1})(\\d{8}[A-Z]{1}|\\d{9}[A-Z]{1})(\\d{9})$",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "expirydatepattern = re.search(r'(\\d{1,2}\\d{1,2}\\d{1,2}\\d{2}).*?(\\d{3}).*?(\\d{3}).*?(\\d{3})', expiry",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "/\\b[a-z]{1}(\\d{3}\\d{3}\\w{4}).*\\bGB\\b/gi",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "(?=^[a-zA-Z0-9]*$)(?=^[0-9]{9}|12$)([a-g]{1})(?=^[a-zA-Z0-9]*$)",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "(^[a-z0-9](?:[a-z0-9]-)?(?:\\d+)/\\d+)?$",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "(g)([a-z]+\\d+(?:-\\d+)?[a-z]+)\\-\\d+(?:-\\d+)?[a-z]+",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "export tracking code = ^([a-zA-Z][0-9][a-zA-Z0-9]{0,11}))$",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "^[a-z]{2,8}(\\d{12})[a-z]$\"\"\"",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "(2-letter) [a-zA-Z0-9]{1,8}  &  (9 numbers) [0-9a-z]{2,}",
        "passed": false
    },
    {
        "id": 3384,
        "completion": "gebnerg_tracker2.regex(re.escape(ExportTracking.pattern(2)) + '|' + re.escape(ExportTracking.pattern(9)) + ')')#2. What about two more patterns?ExportTracking.add",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "```pythonimport re",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "(IMPORTANT: This exercise is too complex and requires too much information for a standard response.)",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "([\\W_]+)(?<!^|_)(GMT|GB)(?!$)",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "Re[\\bN-][A-a][-A-a]{2}[GB]",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "(-?[0-9]{5}(-[0-9]{3})?) -",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "^(?!GB$)(\\d+)-(\\d+)-(\\d+)$",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "```import recode = re.search('(?<!GB$)(\\d{1,2})[A-Z]', '123-4567-89AB')if code:     print(code.group()) # Output: '23'```",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "[^$GB$\\s]+",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "I used a negative look behind in the form of \"(?!GB)\", and the result is \"PKD-\\d{0,2}-\\d{3}.tif\".",
        "passed": false
    },
    {
        "id": 3385,
        "completion": "`(?!\\d+)[A-Z]?\\d{2}[-\\s]?[A-Z]?[\\d]{3}[-\\s]?[A-Z]?[\\d]{3}[-\\s]?[A-Z]?[\\d]{3}[-\\s]?[A-",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "^(?=^.{18}$).{8}$",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "\"9 digits: (\\\\d){9}\"",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "[Your answer here]",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "^((?:\\s[A-Z]\\(\\d\\)){8}\\s)?$",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "Code (or Letters for Consignments at large)([a-zA-Z][a-zA-Z0-9 ]*)(\\1)([0-9]*)([0-9])\\b|(\\",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "(e.g. (.+)(?=\\s\\s|$))",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "^((?=.*[a-z])(?=.*[0-9])|(?=.*[0-9])(?=.*[a-z])|(?=.*[a-z])(?=",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "\\b\\d{9}|[\\w]\\w{7}\\b",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "([0-9]{9}|[A-Z]{7}[0-9]{1}[A-Z]{3}|[0-9]{7}[A-Z]{4}|[",
        "passed": false
    },
    {
        "id": 3387,
        "completion": "re.compile(\"(?i)(?:\\b[JjFfFfGgHhTt][0-9]{6})|(?:\\b[JjFfFfGgHhTt][",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "/^Y(\\d{4})\\/(\\d{1})(\\d{1})$/",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "var regex = new RegExp(/(\\d{4})/gi);",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "jalali_date_regex = \"^{4}-[0-9]{2}-[0-9]{2}$\"",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "(^[0-9]{4}\\-)?[0-9]{2}-(0\\d)?[0-9]{2}$",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "jalali_date_regex = '^(\\d{4})/(\\d{2})/(\\d{2})$'Exercise 2: How would you validate a list of dates that look like \"2022025/06/02\"? Write the regex.Answer: jalali_date_regex = '[0-9]{4",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "^(?:20\\d{2})?/[[:digit:]]\\d{2}(?:\\/\\d{1,2})?)$",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "Y(\\d{2})/(\\d{2})/(\\d{2})",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "^(?P<4-digits>[1-9]{1}[0-9]{2})/(?P<first>\\d{4})/(?P<last>\\d{2})/(?P<rest>\\d{2})$",
        "passed": false
    },
    {
        "id": 3394,
        "completion": "jalali_dates_1_4_digits_YYYY_format = \"(?P<year>\\d{4})/(?P<month>\\d{1,2})/(?P<day>\\d{1,2})_YYYY\" #The python code to create this RegEx would be: r\"\"\"'(?",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "\\b(0?[1-9])[-._](0?[1-9])[-._]\\d\\d\\d\\d\\d\\d\\d",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "^(1[0-9]|2[0-3]):[0-5][0-9]$",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "([1-2]?[0-9] \\d\\d?) [1-2]?\\d [3-5]\\d\\d",
        "passed": false
    },
    {
        "id": 3417,
        "completion": ".0{0,1} (year month day)I have a date.  Date format:  19/06/2017 or 29/06/2017",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "\\d{4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "(?<year>19[089])\\s?\\d\\d\\d",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "^\\+(?:\\D*\\d\\d\\d\\D\\D\\d\\D\\D\\W)\\-(?:\\D*\\d\\d\\d\\D\\D\\d\\D\\D\\W)+$",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "[0-9]{4}[-/](1[0-2]|0?[1-9]|[1-9])[0-9]{4}[-/](20[0-9]){3}",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "(?:[^0\\-9\\s]|(?:/\\s*))|(?:/\\s*[^0\\-9\\s])|(?:/\\s*[^0-9\\s])",
        "passed": false
    },
    {
        "id": 3417,
        "completion": "Date Time   |    Year-Month-Day (MM-DD-YYYY)  (eg.  2017-01-01)",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (\\w+)@(blogspot.com|twitter.com |google.com)",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:([a-zA-Z]+)\\s{0,3}\\s((https?://)?(www\\.)?)([a-zA-Z0-9-_=+\\.[a-zA-Z0-9-_=+\\.[a-zA-Z0-9-_=+\\.[a-zA-Z0-9-_=+\\.[a",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: [A-Za-z]{1,35}\\b",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: var regex = / (https?://|www\\.)[^\\s]+/. I would probably add a few more characters to the set.It will match:",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:  \"(?<=(\\/[^/]+?))(\\/)*(?<=([^\\/]*\\.))\",",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (?P<source>[^,\\.]+),[^\\s]+\\s+\\[(?P<id>.+)\\]\\s+(?P<date>.+)\\,(?P<time>.+)\\,(?P<source>.+)\\,(?P<views>.+)\\,(?P<clicks>[0-9]+) (?P<",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: [a-z0-9]{12,}\\.[a-z0-9]{3}",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: To match any link from a source social media link,(?<=href=\"/page[0-9]*/\")\\S*(?=.*\\?php\\\\?)(?=.*\\=)",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: /https?:\\/\\/www\\.twainscanning\\.com\\/(?:[^\\ ]+ [^\\/ ]+ \\/[^\\ ]+ [^\\/ ]+)\\s+(?P<category_source_titles>.+?)\\s+\\((?P<total_page_views>[\\d\\s]+)\\).*",
        "passed": false
    },
    {
        "id": 3420,
        "completion": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (?<=(?:www\\.twainscanning\\.com\\.[^/]+)\\/stats\\=(\\w+)Source: https://www.twainscanning.com/blog/2012/08/a-b-c-d-d-d-d-d-d-d-d-d-d-d-d-d-d-d-d-d-d-d",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:  ^((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|[01]?[0-9][0-9]?)$",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (^(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){{3}}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: ^(((0\\.[0-9]{1,3})|([0-9]{1,3})([\\-\\.]){3})|(192\\.))(([0-9]{1,3})([\\-\\.]){3})((2\\.[0-9]{1,3})|([0-9]{1,3}))",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:/^\\s*[\\d\\.]{3}\\.[\\d\\.]{3}\\.[\\d\\.]{3}\\.[-\\d]+\\.[-\\d]+\\.[\\d\\.]{3}\\.[-\\d]+\\.[-\\d]+$/",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (?<ip>\\d{1,3})(?<prefix>\\d{1,3}).net\\.(\\d{1,2}).\\.(\\d{1,2})(?<suffix>\\).*Now for example, this will match a string like 1.1.1.1.a",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: ipaddr = (?<ipno>\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\.",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: http://tools.twainscanning.com/getmyregex.From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description.I got it, here is a test case:var regex = new RegExp(\"[a-zA-Z0-9]*@[a-zA-Z0-9",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (.+?) - any character, up to the newline \\n",
        "passed": false
    },
    {
        "id": 3425,
        "completion": "IP address IPv4 (127.0.0.1). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:(?> \\d\\d\\d\\d\\.\\d\\d\\.\\d\\d\\.\\d\\d).",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (?<![A-Z0-9 ])(?<![a-zA-Z0-9 ]) (?<! : ) (?<! ) (?<! ] ) (?<!- ) (?<! ) (?<! )",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: ([01]){2}(([012])\\d|[3]\\d|[4]\\d|[5]\\d))",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: ^((\\d+.)(\\d)\\s)([:\\d]\\d)(?:\\s(\\d|PM|AM|AM|PM))$",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: \\W([a-z]+ [a-z]+)\\s[0-9]{2}:\\d{2} [a-z]+",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:^([A-Z]\\s*)-*([A-Z\\s]*)",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:Time^\\s+#define HOUR_REGEX [^ \\d ]+#define MIN_REGEX [^ \\d ]+",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: (\\d\\:\\d\\s[A-Z]).",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer:@\"(.*?) \\d[A-Za-z]+ \\d\\d\"",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: @\"^\\d{1,2}:\\d{2,2}( [a-zA-Z]+ ){1}$.\"",
        "passed": false
    },
    {
        "id": 3427,
        "completion": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex.Generate a RegEx for this description. Answer: \\d{1,2}\\s:(\\d{1,3})\\s(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "[00 00 00 00 00 50 00 09 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "567 +",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "https://regex101.com/2G8fQKJ/10",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "\\b(5 [digit]$)|(\\b5 +\\s+\\d{2}\\b)|(\\bb5[ \\t]\\d{2}\\b)",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "0-9a-fA-F",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "UTR or CRT file format are often written with 1st 5Genre (eg. 5A,5A and not 5 A or 5 C and not 5 C).",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "^(?P<reg1>[AATCGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA])?(?P<reg2> [AATCGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA]){10}",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "\\d {5} | 5d",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "r'\\S\\d{5}[s]?\\d{3}?[e]?'",
        "passed": false
    },
    {
        "id": 3448,
        "completion": "https://regex101.com/r/8Y9xB3/1",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "\\d{1,12}",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "1m-12m",
        "passed": true
    },
    {
        "id": 3454,
        "completion": "Regular expression to match any string\"^(?:1-?[0-9]{0,4})?\\s?$\"",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "The formula is \"\\\\b1|\\\\b2|\\\\b3|\\\\b4|\\\\b5|\\\\b6|\\\\b7|\\\\b8|\\\\b9|\\\\b10|\\\\b11|\\\\b12\\\\b\", where each backslash matches the newline character, so the regex alternates between matching 1, 2,..., 11, and 12 characters, starting from 2.",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "(^|[+\\-]|\\(([1\u221212]|1\\d|12)(\\d|[1\u22129])\\))$",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "^[1-12]$",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "^(?=1)(?=12).",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "^[1-2][0-9]$",
        "passed": false
    },
    {
        "id": 3454,
        "completion": "{(?:\\d(?:[,\\s]*\\d)?)+}",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "[0-9]{3}-[0-9]{3}-[0-9]{3} [0-9]{3} [0-9]{3} [0-9]{4} [0-9]{4}You can generate a RegEx to validate HMRC Tax Office numbers in many different ways. This RegEx generates a valid 10 digit HMRC tax office number. To validate it, make any changes to the [0",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "Office 0000 [0-9]",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "\\A-\\d{4}-\\d{3}-\\d{2}\\b",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "^([0-9]{8})(|[1-9])$",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "^(([a-zA-Z]{2} | [a-zA-Z]{3})(\\.00(?:\\D|$))?)*$",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "^\\d{3}%\\d{3}%\\d{2}$",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "Office {1,2,3 digits}$",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "^\\d{3}$",
        "passed": false
    },
    {
        "id": 3457,
        "completion": "^[0-9]{3}$",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "^\\+44\\d{1,2}\\d\\d{3}$",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "var regExp = /^([1-9][0-9]{3}|([1-9][0-9]3)\\/[1-9][0-9]3|1[5-9]\\d{2}\\|201[0-2]0[1-9]|1\\d{2}\\|19(2",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "public static Matcher re = Pattern.compile(\"^[1-9][0-9]{3}[.](0)?[1-9]{3}$\");",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "/^[1378]*$/U",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "@\"^([a-zA-Z0-9][a-zA-Z0-9-]\\.)+uk$\"",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "https://regex101.com/r/3Mv2xw/1",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "^(123)555-1212$",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "^((0?\" \\d{2})?)?((3\\.\\d{2,})?(\\d?)(?: \\/ \\d{3})?)?$",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "IEnumerable<string> ValidNumbers = Regex.Matches(input, @\"[0-9]{5}$|[0-9]{7}\")                             .Cast<Match>()                             .Select(x => x.Value)                             .Where(x => Regex.IsMatch(x, @\"^[0-9]",
        "passed": false
    },
    {
        "id": 3459,
        "completion": "^[0-9]{3}[.-][0-9]{3}[-.-][0-9]{4}$",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "a([0-9]{4}[a-zA-Z])",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "(\\d{8})-[A-Za-z]",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "^[A-Za-z][A-Za-z]\\\\w{8}$.",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "/^[a-zA-Z]{8}\\w+/",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "^[0-9][0-9][0-9][0-9]][A-Z][0-9][A-Z][0-9][0-9]$",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "Re^(?=0*[7-9])(0*[A-Z])(0*[a-z])8[a-z]+$",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "^[0-9]{7}\\.[\\w\\-_]{1,2}$",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "r\"^[12][0-9][a-z]$\"",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "[[^,]][a-zA-Z][0-9][^,]",
        "passed": false
    },
    {
        "id": 3460,
        "completion": "r\"P\\d{8}[A-K]\", or reg exp /P\\d{8}[A-Z][A-Z]/",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "((?:((?:\\d{2})\\d*|\\d)\\d+))(?:.*?)(?>(?:,\\d{2})?$)",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "[ \\d]+[aA][\\+\\d]+",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "^(ABCD)(\\d|\\.)(\\d|\\.)(\\d|\\.)(\\d|\\.)\\d$\"\"\"",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "\"^AA(\\d+([XV])|[CD])(\\d+[ST])(\\d+)$\"",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "(?<![01]).([a-z ]|[a-zA-Z]|[0-9]|[xX]).[a-zA-Z] or [0-9]",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "^[Aa][Aa][Bb][Cc][Dd][Ee][Ff][Gg][Hh][Ii][Jj][Kk][Ll][Mm][Nn][Oo][Pp][Qq][Rr][Ss][Tt][Uu][Vv][Ww][Xx][Yy][Zz][",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "\\b[A-Z][0-9]\\b - Matches the basic form AA99AAA but contains a zero.I've tried: (^|[^a-zA-Z0-9]).*?(?=\\b[0-9]$) but these don't work, can anyone help?I tried: (^|[^\\-a-",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "^[0-7]?[1-9]B-?[1-5]?[0-9]{1,2}[Mt]?$",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "(a) [Aa][Aa][Dd][Dd]: (b) (C1)|[A(Ll)]?[Aa][Dd][C1]: (c) ([A(Ll)]?[Ll][Aa][Dd]?)",
        "passed": false
    },
    {
        "id": 3467,
        "completion": "^[1-9][A-Z]{3}[0-9]*[0-9]$",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "*(A0-A0)*|*(A0-A1)*|*(A0-A2)*|*(A0-A3)*|*(A0-A4)*|*(A0-A5)*|*(A0-A6)*|*(A0-A7)*|*(A0-A8)*|*(A0-A9)*|*(A0-B0)*|*(A1-A",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "\\bA[0-9]*[A-Z]{1}[0-9]\\b",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "A0 - A9     - [0 - 9] | 0-9 A10     - [10 - 19] | A0-A9 0A19     - [20 - 99] | A10-A18 10|A19-A21 20%A30     - [100 - 999] | A10-A17 30%|A0-A9 100-999",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "^A[0-9]*-[0-9]*-[0-9]*A$",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "Regex for A0-A4: (?P<A0>A|B)+(?P<A1>T|t)+(?P<A2>G|c)+(?P<A3>T|t)+",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "0.1n[0-9a-z-\\.][a-z0-9\\.\\-]*|A1[0-9a-z-\\.][a-z0-9\\.\\-]*|A2[0-9a-z-\\.][a-z0-9\\.\\-]*|A3[0-9a-z-\\.][a-z0-9\\.\\-]*|A4[0-9a-z-\\.",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "[Insert Regex Here]",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "[^\\dA]([^\\dA-Z\\.]*(\\.[^\\dA-Z\\.]*)?)*",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "Sizes from A1-B1, Sizes from A2-B2, Sizes from A3-B3.",
        "passed": false
    },
    {
        "id": 3473,
        "completion": "",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "(0|2)0(0|2)0",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "^[24][0-9][0-9]*$Explanation: Start with ^, the very beginning of the text. Then, repeat the first group: [24], followed by anything (in this case, 0-9), followed by 0-9 repeated zero-or-more times. Then, end with $, the very end of the text.",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "\\[([\\w\\s]+[\\w\\s]+[\\w\\s]+[[\\w\\s]*]*)import gzipimport sysimport urllib2import refrom xml.etree import ElementTreeimport xml.parsers.expatfrom urllib.request import urlopenfrom.tools import read_csv_as_dataframe",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "(even) (3 + 4 + 2) Exercise 3: Write a program that accepts input from the user to calculate the sum of two numbers. Write a user-friendly message for when the user input is valid.Answer: Enter two numbers here and press enter to calculate the sum. Your answer is 1234.",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "n(0|[01]){1,63}",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "((?=([0]{2,6}[1-9]{2,}|[1,7][0-3]",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]{8,20}So this should be the solution for the second question.",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "[{ [^}]* }]",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "(?=.*_[^aeiou]{4}).*_[^aeiou]{4}",
        "passed": false
    },
    {
        "id": 3475,
        "completion": "0|1[0-7][0-9]",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "^-?\\d+[.,]?\\d+$",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "a) \\d{1}\\s\\d{1}\\s\\d{1}\\s\\d{1}\\s\\d{1}\\s\\d{1}$ matches this description, starting from 1 digit, 1 space, and 6 digits. It also starts with either a digit or a non-digit. b)*, d{1,2}(e-g) Match or none of the following: a) 0, 1, or",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "\\b\\d+(,\\d+)?\\s*",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "negative and positive numbers with or without commas: -?0+1,0+ -?\\+0, or -?(0+)|(0-)?. positive and negative numbers with or without decimals: (-?\\+?\\d+)\\s+([\\d.-]*)\\s+=,-, or -?\\s+([\\d.-]*).",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "*([\\+-]?\\d*\\.?\\d*)([\\+-]?\\d*\\.?\\d*)",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "\\d*-?\\d*|\\d*\\.\\d*|[^0-9.\\s]+",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "positive number(s) - \"one or more of the expression after x, or a word character that is not a digit or the decimal separator\" ; negative number(s) - \"one or more of the expression before x, or a word character that is not a digit or the decimal separator,\" and decimal number(s) - \"an expression with a decimal separator after x\"",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "\\d+(,\\d+)?",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "\\d+(\\.\\d{2})I didn't get it yet...Example (5)Exercise: Write a Python program that finds all email addresses in a given string. Use a RegEx with the pattern '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'Answer:",
        "passed": false
    },
    {
        "id": 3481,
        "completion": "/^[\\+-]?\\d*\\.?\\d(,\\d*\\.?\\d)?$/",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "[a-z0-9!#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~]",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "```pythonimport randomimport re",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "(lower-case or upper-case letters, digits, and special characters) A.Bd.eF#4G",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "``` pythonimport randomimport re",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "(.*)$",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "^(?=.?[a-z].{3,10})(?=.?[A-Z].{3,10})(?=.{3,10}[0-9]).*$",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]{3,5}(?:\\.[a-zA-Z]{2,5})+",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "/^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=]).{12,30}$/",
        "passed": false
    },
    {
        "id": 3483,
        "completion": "(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[\u00ac!$%^&*?])[A-Z0-9!#$%^&*?\\-_=+|~`\\][a-z]{2,}$3. How do you store a regular expression in Python? Answer: A regular expression can be stored in Python as a string using",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "/^#+[^ ]+$/",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "\\[if\\];.+\\}",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "r'/([^\\n]*).*/if*'",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "^\\s*if\\s+(\\S*)\\s*($|$).*$",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "\\d+\\.?[0-9]\\.[0-9]\\.[0-9]*\\b",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "Use negative lookarounds to match the words \"if\", \"else if\", and \"else\", and exclude comments that contain any of these words. ```pythonimport retext = \"This is an example comment that includes if statements. This comment excludes if statements.\"my_regex = r'\\s*if\\s*\\*?\\s*((?!if|Else|Elif|ElseIf).)*\\s*else\\s*\\*?'mat",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "<p>(?<!\\n\\s|^)(\\*|\\/|#)\\s*(?:[^\\*][^#]*|(#.*\\s*)([^\\*/]*))(?!\\*|\\/|#)",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "\"(?i)(<!--.*?-->|< if (.*?) then (.*?) else (.*?) endif )\"",
        "passed": false
    },
    {
        "id": 3488,
        "completion": "(?i)(<[^>]*?)(if|else|ifdef|ifndef|endif)(.*)",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "\\d{1,2}\\/\\d{1,2}\\/\\d{4}",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "var dateRegex = new RegExp('\\\\d{1,2}/\\\\d{1,2}/\\\\d{4}');",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "'^(\\d{1,2}\\/\\d{1,2}\\/\\d{4})$'",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "^(([1-2]?[0-9])[/])(19[0-9]{2})/(\\d{4})$",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "/^(\\d/\\d{2}/\\d\\d\\d\\d$)/",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "([0-9]\\d{2}/[0-9]\\d{2}/[0-9]{4})",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "^(0\\d)\\d{2}(5|6)\\d{4}$",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "\\d(1|2)\\d{4}",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "((0|1|2)+/([0-9]{1,2}/[0-9]{4})",
        "passed": false
    },
    {
        "id": 3546,
        "completion": "^(0[0-9]|1[0-9]|2[0-9]|3[0-2]|4[0-9])/([0-9]{2})/(\\d{4})$",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "#/(T|c|p)-[a-z0-9]?$/",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "pattern = re.compile(r':\\s*(\\d+)\\.?\\d*\\-\\d*')",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "'^\\d\\d:\\d\\d:\\d\\d$'.",
        "passed": false
    },
    {
        "id": 3549,
        "completion": ":?\\d",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "[:]([\\d\\d:]*))*4. Generate RegEx to select strings containing more than one colon (:).Answer: [:](\\w*:[\\w\\d:]+)5. Create a RegEx to match phone numbers that start with (555)555-5555.Answer: \\(555\\)[-\\s]*\\d{3}-\\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "var numTimePattern = new RegExp(\"([0-9]:)([0-9])\",\"g\");",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "'[0-9]{2}(:\\d{2})?'.",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "\\d{1,2}:\\d{2,4}:[^ ]+\\s(\\w+\\.\\w+\\w*)?$",
        "passed": false
    },
    {
        "id": 3549,
        "completion": "*TIME:(.*,?)$*",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "^(?P<hh>\\d+:)?\\s*(?P<minmin>\\d+),?(?P<ssGenerate>[1-3]\\d\\\\d \\\\d{2})?.$|^(?P<hh>\\d+):)?\\s*(?P<minmin>\\d+),?(?P<ssGenerate>[1-9])?.$\"|^(?P<hh>\\d+",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "^(0|[1-9]?0?[0-9]?|10[0-2]|20[0-3]|50[0-9]|80[0-9])$/  ^^|^^|^^|^^|^^|^^|^^  ^^-|  ^^-|  ^^-|  ^^-|  ^^-|  ^^-|  ^^  ^         ^         ^           ^^^^^^^      ^^^",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "\\A(?P<HHH>\\d{2}):(?P<MM>.\\d{2}):(?P<SS>\\d{2})$\\z",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "((\\d{1,2}):)?(\\d{1,2}):(\\d{1,2})[^:]*:(?P<hh>\\d{2})(?P<min>\\d{2})[^:]*(?P<ss>\\d{2}[- ]?\\d{2}[- ]?\\d{2};",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "(?P<hh>\\d{1,2}):(?P<min>\\d{1,2}):(?P<ss>\\d+)(?P<hh_or_s>h|m|s)",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "regex = \"(?<hh:min>\\d+),(?<ss>\\d+):(?<ms>[a-zA-Z-0-9]+)x([a-zA-Z-0-9]+)[/\\\\\\*\\d+]\"",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "[regex]^[hms]=([0-9]*)([0-9]*)([0-9]*)$",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "(https://www.regexr.com/3g8l2) \\d\\d\\d\\d\\-\\d\\d\\d\\d:\\d\\d\\d\\d Exercise 5: Write a regex to validate an email address. Answer: (https://regex101.com/r/Qs7sF7/1)",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "hh:{hh}[:min|]{ms|ss}}Examples: 1 hour:34 AM = hh:{34}[:min|]{0|24}1 hour and 22:25 = hh:{22}[:min|]{0|5}11:43 AM = hh:{43}[:min|]{11|11}11:43 AM+00:00 = hh:{43}[:min|]0",
        "passed": false
    },
    {
        "id": 3556,
        "completion": "hh.minmin.ss <- \"(\\\\d+).([st])\"",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "\\d{4}-\\d{2}-\\d{2}",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "[[:digit:]]+[\\.\\d][Ee][[:digit:]]+",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "\\d\\d\\d\\d\\.\\d+$",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "([0-9\\.'eE+-]+)",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "^[0-9]+$",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "([0-9]{0,19}[ \\-]\\d{1,19}[ \\-]\\d{1,19}[ -]\\d{1,19})3. Create a RegEx to check if the given string contains any capital letters Answer: (?=.?[A-Z])4. Create a RegEx to find a comma in a phone numberAnswer: ()?[\\\\d-]{7}[-.\\\\d]",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "^[0-9,]*\\.[0-9,]*$",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "\"^[0-9]{6}$\"",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "^[0-9]+$",
        "passed": false
    },
    {
        "id": 3561,
        "completion": "\\d{5}[.][1-9][0-9]$",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "(?<month>\\d\\/\\d\\/\\d)([\\-\\.\\/]\\d\\/\\d)(\\d\\d) (?<year>\\d\\d\\d\\d)",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "r\"[0-9]{1,2}(\\/\\s[0-9]{1,2}(\\/\\s\\d{1,4}))?(\\-(?:(?:[0-9]{1,2}\\s){1,2}\\w\\s){1,3})?\"",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "^19[1-9]\\d{2}-(0[1-9]|1[012])[0-9]{4}$",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "/^(1|2)\\d{1,2}(\\s|-)\\d{4}$/",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "[0-9]{1,2}(\\/|-\\/|\\.)[0-9]{4} (\\D|_| \\.)[0-9]{4}\\d{5}",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "YYYYMMDD-YYYYMMDD or YYYY MM DD-YYYymm DYYY DYYY MM DYYY",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "^[0-9]{1}(-0?[0-9]{1})[0-9]{1}/[a-zA-Z]+([- \\.]?[0-9]{1,3})?[a-z]{1,7}$2) What type of",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "My_Date {3, 14}/2021 (Yearly)",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "(?!\\d{4}-\\d{1,2}\\d{1,2}\\d{4}).?(\\b(\\d{1,2}(\\/){1,2}\\d{1,2}\\d{4})?(\\/\\s)|(\\/ )?\\d{4}-\\",
        "passed": false
    },
    {
        "id": 3601,
        "completion": "MM/DD[ -]YY[-/s]{4}",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "/([1-2]\\d|[3-5]\\d|6[1-9]|7[0-2])/",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "^\\d{1,2}/\\d{1,2}/\\d{4}$             (4 digits, '/', 2 digits, '/', 4 digits)",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "^(12|13)\\b.*(\\d{1,2})\\b",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "(YYYY\\s(\\d\\d)\\/(\\d\\d)\\/)(\\d\\d)(\\d\\d)",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "[^\\/\\/,]+\\/\\d+/[^,]+The regexp matches any number of not forward slashes, a forward slash, and then 1 or more numerical characters.This will match dates in the following formats:12/31/21 - The day of the month can be from 0 to 912/31/21 - The day of the month can be from 0 to 912 - The day",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "([^/\\(\\d{2}/\\d{2}/\\d{4}\\)]\\s+\\(\\d{2}\\)\\s+\\d{4}\\)\\s*",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "\\d/\\d/\\d-(\\w|\\W) (\\d|\\W)",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "(0-9)(0-9)(0-9)(0-9)You seem to like to use a \"range\", but the ranges you specify should be in the form \"1-4\" (1-4) - any other ranges are invalid.I have a slightly different suggestion which is more accurate. It was a bit of a pain to pull this one from another post I wrote years ago but it's based on this",
        "passed": false
    },
    {
        "id": 3712,
        "completion": "/[0-9]{2}[0-9]//[0-9]{2}/[0-2][0-9]/[0-3\\\\-9][0-9]/, [0-9]{4}  /[0-9]{4}//[0-2][0-9]/[0-3]\\\\/|[0-9]{4",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "www.cpr.dk/welcome/ (replace W (word) with w (word) and L (leap year) with l (leap year) to complete the RegEx.)",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "(?i)[a-z]{1,8}(?:\\.[a-z][a-z]+)?(?::[0-9]+)?$",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "^https?://www\\.(www.)?[a-zA-Z0-9\\s]{2,30}",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "(([0-9a-fA-F]*[-_][0-9a-fA-F]*){2})/24+/(^[0-9]{2}$)",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "[a-z0-9]+(?:\\.[a-z0-9]+){4}[0-9]\\.[a-z0-9]{2}.[0-9]{1}([-\\s.]|$)",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "(.*)\\b((?:feb){3}\\s?\\b(?:29(?:\\/2)\\)?|(feb)29))(.*)",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "[A-Za-z0-9 ]{2}-[A-Z]{2}-[0-9]{4}(Note: the'' character between - and [ is only the'' character for this RegEx, it can be escaped as [-,\\s\\s])This RegEx uses the letters A-Z, a-z, 0-9, and underscores to represent a-z, 0-",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "http[s]?\\d+[.-]\\d+",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "[A-z0-9]{2}:(?P<year>[0-9](?:-[0-9](?:-[0-9]))?)\\s[A-z0-9]{2}:[0-9](?:-[0-9](?:-[0-9]))?$",
        "passed": false
    },
    {
        "id": 3731,
        "completion": "\"Regex for 29th February of this year\\((0|[1-9])\\s(days)\\) or 30th Feb (no leap year), or 31st Feb\"",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A5",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A73",
        "passed": false
    },
    {
        "id": 3753,
        "completion": "Regex for current available mobile numbers mention athttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "(\\d\\d\\-\\d\\d\\d)\\.|\\d\\d\\-\\d\\d(?!\\d)",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "\\S[0-9]{15}\\S",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "\\d{0,}(?:[0-9]|1[0-9]|2[0-1]\\d|22[0-2])\\s*[0-9]{0,}(?:[0-9]|1[0-9]|2[0-1]\\d|22[0-2])\\s*[0-9]{0,}(?:[0",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "/\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d$/",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "(^)([0-9]{2})([0-9]{3})([0-9]{4})$",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "^\\d*(?:\\d+)\\s*(?:\\d+\\-\\d+\\b)*(\\d+)\\s*$",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "\\b(0\\d*9999[9])+\\b (0...999999)\\b",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "((?<!\\d)\\d{1,4})(?!\\s)(?!\\d)(?:\\w+)",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "(0+)([1-9])\\d\\d{3}(\\.\\d\\d?)+",
        "passed": false
    },
    {
        "id": 3772,
        "completion": "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 123456789, 9999999]",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "^((+([0-9]{2})(?:0*[0-9]){4})?|(?:0[0-9]*[0-9])|(?:1*[0-9])){11}$",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "^(?!-)[A-Fa-f0-9]{12}\\-?[0-9]{4}\\-?[0-9]{2}\\-[0-9]{2}\\-[0-9]{4}$",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "(?x)^|([0-9]{3}\\-[0-9]{2}|[0-9]{5}\\-[0-9]{5}|[0-9]{3}\\-[0-9]{4}|[0-9]{2}\\-[0-9]{4}\\-[0-9",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "[a-z0-9]{2}-[a-z0-9]{3}-[a-z0-9]{5}-[a-z0-9]{2}\\d{2,3}",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "^(?!#[0-9]*).*?\\[UniqueMasterCitizen: ([^\\]]+)[\\:] ]*{18,[0-9]*}[\\:] {1}[\\w-]{2,40}$",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "^\\d{6,22}-(?:\\d{4}-)\\d{3}-(?:\\d{2}-)\\d{4}$",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "\\b([\\d]+)\\W+([\\w\\-]+)",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "\"1\\.[0-9]{3}\\-[0-9]{2}\\-[0-9]{4}\\-([A-Z0-9])?[A-Z0-9]{3}-[A-Z0-9]{2}-[A-Z0-9]{4}\"",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "/(^[0-9A-F]{12}-[0-9A-F]{8}-[0-9A-F]{4}[0-9A-F]{12})/",
        "passed": false
    },
    {
        "id": 3791,
        "completion": "\\d{2}-\\d{3}-\\d{4}",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "-?\\*(0.0|1.0|3.0)\\.4. Exercise: In the field description of a satellite, find the term with a \"Q\" prefix of \"50\". Answer: Find the pattern -Q50.5. Exercise: A satellite uses a \"Q\" term that represents the altitude in Km above the Earth's surface. What does the \"Q3\" suffix represent? Answer: The altitude is approximately 3 Km above the",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "X,Y,Q,R",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "(\\S+)\\s(?P<Q>\\d+) \\s(?P<r>\\d+\\.\\d+)$",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "\"(?P<b>((^[q]+)|(^[A-L]n)|(^[a-oNae]+)|(^[Ss]s)))(\\s*)(?P<r>(5cm$|10cm$))\"",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "\\(?\\[Q?\\]? =?([\\d\\.]+)?\"[\\s\\S]*?)(?:\\[radius\\] =?([\\d\\.]+)?\"[\\s\\S]*?\\))",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "\"R=([0-9.]*)\"  (R is Radius in meters)",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "(?(1a)([0-9]{1}[xX]([0-9]{1}[xX])){1}Q(?!coords)[0-9])'",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "\\[Noun\\]coords:[A-zA-Z0-9 ]+radius:.+",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "^.*R\"(\\d+).*_coords.*(.*)(.+)\\((.*)\\)$",
        "passed": false
    },
    {
        "id": 3803,
        "completion": "^([A-Za-z]{1,2})([^A-Za-z\\d]*)($|(\\d+?)\\.)?([A-Za-z]{1,2})$",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |Year",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |D",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3811,
        "completion": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).Matches the format defined as:YYMMDDSSSSCAZ.YY - Year,MM - Month,DD - Day,SSSS - Gender,C - Denotes citizenship (0 or a 1),A - Always an 8,Z - Checksum digit (doesn't validate if the checksum itself is valid).Also supports the following ways of entering it:YYMMDDSSSSCAZ |YYMMDD SSSS CAZ |YY",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "\\b(1[0-9]|0?[1-9])/(1[0-2]|0(1[6-9]|[24])1|29)(\\d{2})$\\b",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "\\(((\\d\\d?):(\\d\\d?)|(12\\d?)\\d\\d?\\)|(\\d\\d?\\d\\d)?(\\d\\d?\\d\\d[^T]?)|(\\d\\d?_)(\\d\\d?))?",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "[A-Z]{3}\\d{2}{3}\\-\\d{2}\\-\\d{4}",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "\\d{1}-\\d{2}-\\d{4}|\\d{1}-\\d{2}",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "*DATE ='mm-dd-yyyy'",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "((\\d+)-[-/](\\d+)){2}",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "r'\\d{2}-\\d{3}\\-\\d{4}'",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "(\\d{2})/([1-9])-(\\d{2})",
        "passed": false
    },
    {
        "id": 3909,
        "completion": "(MM|DD|YYYY)=(\\d\\d|\\d\\d|\\d\\d)([-.])(\\d\\d(?:[-.]\\d{4})?|([1-9]\\d)(?:[-.]\\d\\d\\d?)?)",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "^ [0-9]*e[+-][0-9]{1,3}(.*)\\.([0-9]{1,3})([Ee][+-][0-9]+)$",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "((?<exponent>\\-?\\d+\\.?){1,2})(\\*?)((?<f_sign>(\\*|\\/))?)(\\.\\d+)?",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "%d\\.{1,2}E[+-]\\d*f",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "[-+]?\\d*\\.\\d+|^[+-]?\\d+",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "\\d*\\.\\d+|[+-]\\d*\\.\\d+|\\d*\\.\\d+",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "\\d+\\.\\d+e[+-][+-]\\d+)",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "The regex would be (\\b[+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s.",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "^\\d+\\.\\d+e[-+\\d\\.]+$",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "",
        "passed": false
    },
    {
        "id": 3910,
        "completion": "`(\\.\\d*(e|E)\\d*)`2. Given a String `number = \"12.2e4\"`, separate the `number` and `e4` in a RegEx pattern using the `|` operator. Answer: `\"(?:\\\\.\\d*)e|'\\\\d+'`3. Write a RegEx to find all the occurrences of `\"b\"` in a given String where it is followed by any characters except",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "(?:\\+*\\+)?(?:\\-|\\-|\\+|\\*|\\/|\\/)\\d\\+?((?:\\.)?\\d\\+)?",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "^[A-Za-z0-9 -]*$",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "^.*(?|(?<!\\d)\\K[0-9])$",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "^#?[a-zA-Z0-9\\-\\.]*$",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "(?s)(-?[0-9]*|0|[1-9]{2})(-(?<month>\\w{3})(-(?<day>\\d{2}))?)*$",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "[0-9]{5}\\.[0-9]{3}\\.[0-9]{2}\\.[0-9]{1}",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "(pow|+|-|\\d|\\.)",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "^(?:[!#$%^&*+]+(?:\\)|\\[|\\]\\{|\\}|\\s+)?\\s*$)",
        "passed": false
    },
    {
        "id": 3912,
        "completion": "/(o|O)(t|T)(o|O)d/",
        "passed": false
    },
    {
        "id": 3912,
        "completion": ".*",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "(\\w|[.])\\w*",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "([a-z0-9][a-z0-9\\.]*[a-z0-9])|([A-Z][a-z0-9]+)",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "(\\w+)\\.([A-Z]){1,4}$",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "[a-z]+([a-z]|[\\.])+[a-z]+",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "R[A-Za-z]{0,%d}.",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "^(?=.{8}$)([QWERTYUIOPALKNBDXsfghjmzxcvbn]?[a-zA-Z]+)(?!.*\\.{4})[a-zA-Z0-9_\\.-]*$",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "^(?:\\w{1})(?:\\w{8})(?:\\.\\w?)*$",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "[a-zA-Z0-9.?]",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "(?=.*[a-z])(?=.*[A-Z])[a-zA-Z.]*",
        "passed": false
    },
    {
        "id": 3915,
        "completion": "[\\\\p{Ll}\\\\p{Lu}\\\\.\\\\p{Mn}\\\\.\\\\p{No}\\\\.\\\\p{P}\\\\.\\\\p{S]]+",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "grep -o '\\b-?\\d*\\K\\d+\\b' < file",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "$a=~/^[0-9a-fA-F]*$|^((?:[0-9a-fA-F]{1,2}(?:[0-9a-fA-F]{1,2}))+)|(?:[a-z0-9]{3,15})$|^[a-z0",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "grep -E \"[a-zA-Z0-9][a-zA-Z0-9][a-zA-Z][0-9][a-zA-Z][0-9][a-zA-Z][0-9][a-zA-Z][0-9].[0-9A-Fa-f]\"] text",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "(\\p{L}+)",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "[[:digit:][:digit:]][:digit:]@([a-zA-Z][a-zA-Z0-9-]*|^[a-zA-Z0-9-]*$)|(^[0-9a-fA-F]{1,2}$)|[0-9a-fA-F]||[",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "#{RANGE_PATTERN}\" : #{hex_val}-#{hex_val+(hex_len*4-1)}The hash symbol (\\) should match the end of the string (otherwise the entire input string will match the #{RANGE_PATTERN}). The (hex_len*4)-1 accounts for octal digits (00, 0a",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "(?i)(?=.{6,20}:)(?<![a-zA-Z0-9-_])[a-zA-Z0-9_]:[a-zA-Z0-9\\*\\-\\_]",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "sed -E -n's/^\\([^ ]*\\).*[^;]*(:|#)([0-9a-fA-F]):.*$\\1\\3//g; s/\\(.*\\).*(:|#)([0-9a-fA-F]):.*\\3//g;' file",
        "passed": false
    },
    {
        "id": 3934,
        "completion": "grep -P -Eo \"\\\\b(([a-z0-9_])([0-9a-fA-F]+))\\\\b\" input.txt",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "^9792[\\S]*$",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "^\\d{4}-\\d{2}-\\d{2}$|^\\d{8}-\\d{2}$",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "\"^(?:9792|978|9792[0-9])[0-9]$\"",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "^\\d{9792}",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "(\\d{14}[89])\\s+(?:\\d{13})(?:[A-Fa-f]\\d{1,5})$",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "^9792[^a-zA-Z]{0,14}$",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "troy \\d{16}",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "^\\d{9,12}[^\\d\\s]'[^\\s]*$",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "^9792-123-4567$",
        "passed": false
    },
    {
        "id": 3936,
        "completion": "(\\w{3}|\\d{4})\\s+(troy)",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "^YES|YES$|^Yes$|^Yes$|^YES$|YES$|No|NO.",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "^YES$The answer you get for given regex expression is YES.",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "\"(?<=\\S)\\s*(?=Yes|No|YES|NO)\"",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "(?<!^)[a-z]*(?!$)[a-z]$",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "var pattern = /^[a-z\\d]{1,2}([aeoiuaeiou][a-z\\d]{1,2})*$/",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "\\b(?:yes|yes|n|o[gd]r)\\b",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "([^a-zA-Z -]*){1,20}",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "[a-z]+",
        "passed": false
    },
    {
        "id": 3951,
        "completion": "([YyES]{1,}[nogenerate]{1,})\\b",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "^(0(?:\\1){3})1(?:\\2{4})8{7}$",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "^(10)[[:digit:]]{2}(:[0-9]{1}){3}[8][0-9]{10}$",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "(00)01[A-Z]? [A-Z]?[A-Z]?[A-AZ-0]?.- 4. Use the following text: 'The orange rabbit jumped over the green frog.' - First, replace all spaces with a regular expression that matches",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "^([01]\\d)\\d*$",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "^(?=^0000|^0001|^0010|^0011|^0100|^0101|^0110|^0111|^1000|^1001|^1010|^1011|^1100|^1101|^1110|^1111|^1111)12",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "(^\\([1-2][0-9][0-9]\\|[1-2][1-9][0-9]\\|[1-2][1-9][9]\\|[1-2][1-9][0-9]\\|)[",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "0\\d{9}",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "^([01]\\d{0,2})\\d?([A-Z]\\w{0,10})\\d{8}$",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "^[0-9]{2}[0-9]{1}[0-9][0-9][0-9][0-9][0-9][0-9]-[0-9]{8}$",
        "passed": false
    },
    {
        "id": 3981,
        "completion": "(^\\d{2}|\\.\\d{0}\\d{3}|(?<=\\d{9})\\d{4})$",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "[0-9]([0-9])",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "\\d{1,3}(?:-\\d{1,3})*",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "\"\\b(?:1{1,6}|2{1,3}|3{1,2}|4{1,2}|5{1,2}|6{1,3}|7{1,3}|8{1,3}|9{1,3}\\b\"",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "0-999",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "0-9",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "^[0-9]+$",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "Regex:  \\\\d{3}-\\\\d{2}-\\\\d{4}Explanation: \\d{3}- matches 3 digits;          \\d{2}- matches 2 digits.          \\d{4} matches 4 digits.",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "\"*([1-9]\\d*)$\"",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "/^(100|1000|10000)$/",
        "passed": false
    },
    {
        "id": 3983,
        "completion": "(1|2|3|4|5|6|7|8|9|0)\\s*Pattern Description: match any positive integer  Examples: 1  33 34   55  55",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "0[03]\\d{9}|3[^0-9]\\d{7}|34[^0-9]\\d{8}",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "03.\\d*\\d*-\\d*\\d*-\\d*\\d*-\\d*\\d*\\d*.",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "^[0-9]{3}[^0-9]{9}$",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "03*[A-9]\\d{9}\\d{9}",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "^(03[\\d\\d]+)|([\\d\\d\\-.]{11,12})(?:\\.*)$",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "(03+)(00)*[-()[\\]]",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "\\d{3}[0.]\\d{3}[0-9]{2,}",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "(\\w{3}\\(\\w+\\)\\s\\)[-\\s]?,. (All phone numbers starting with,three digit numbers in parentheses)",
        "passed": false
    },
    {
        "id": 4010,
        "completion": "^03(.*?)\\s(\\d{1,6}(\\,\\d*)?)$",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5]",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5]",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5])",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5][",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5]",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5])",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5])",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5])",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5]",
        "passed": false
    },
    {
        "id": 4029,
        "completion": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.For XML pattern facet this would do:([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5]",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "5-11 digits (starting with 1,3,5,7,9,0) 1-12 digits (starting with 8,9,0)",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "^[3-9][4].(5(.1))[7](-([1-9]|[2-5][0-9]))(.[1-9])$",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "This RegEx is too restrictive for the needs of your program. There's no specific number of digits. Instead, you might want to consider using a Regex.",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "(0)(3-5(6-7(8-9)5))+(0)(4-5(7-8)5)),(0)(7-8(5-6(10-11)5))+",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "^[3-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9] [8-9]{9}$",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "([0-5]{3} [6-9]{3}|[7-9]{3}[0-5]{2})?(?:\\.?!-)+$",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "The regexp should be like the following:(((\\\\d)\\\\1|(\\\\d)\\\\2)(?=\\\\d\\\\2)?(\\\\d(?=\\\\d|$))?)",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "(^[3-9]{3,3}(?:\\D\\d){2}$|^[4-9]{4,4}(?:\\D\\d){3}$|^[5-9]{5,5}(?:\\D\\",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "/^(4[23456789])[3/456789](7[13579])[89](8[0369]){3}(\\d{7})$/",
        "passed": false
    },
    {
        "id": 4041,
        "completion": "^[0-9a-fA-F]{8,9}-[0-9a-fA-F]{8}$",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "https:/web/3dc8e1ba7cebced9c0d8c3b96a2d04b5c0/answer.html",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "h\\d*",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "regex = \"^he|h^\"  \"\"\"",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "\"snake.* noise.\"",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "`snake_r`",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "https://gist.github.com/StoddardSpencer96Generate",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "(.+)\\snapped.*((?:[^\\.\\s\\]]+|\\s\\.)*).*?(.+.+$)You'll find the regex below useful for matching the string \"Hissed by a snake\".",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "\\b\\s*\\([^)(]*\\)\\s*$",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "\\s\\s*\\(.*\\)",
        "passed": false
    },
    {
        "id": 4043,
        "completion": "\\b[sS]nake\\b.",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "[A-Za-z](?=.*ing$)[A-Za-z0-9 ]+[A-Za-z0-9]*$",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "r'\\b([a-zA-Z ]+[a-zA-Z]|[a-zA-Z ]+ing)\\b'",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "(?\"[^aeiou]*ing\\b)(?=\\s+[^aeiou]*$)What this pattern matches is going to be matched anywhere within a string: with any character except 'a' or 'e' (so it's not a vowel, but a consonant) followed by 'ing'.Any word that starts with a vowel (a, e, i,",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "\\b(.*?)ing\\bWhat am I doing wrong?So from the regex in the link above I am getting the output(Stoddard's Spencers96's play)How can I get the correct output?Thank you so much.",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "^(\\w+ing?)+$The regex explains the matching: The word \"pong\" is found two time.The word \"ponging?\" is considered too.",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "(.+)\\b(?=\\w*ing)\\w*ing\\bIn other words, it should match any word that ends with \"ing\" and does NOT have more than 8 letters after it.",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "I'm Trying to match \"C.mating\" and \"Spencer96Generate\". This is what I have so far: I need help with this regex. If anyone can help me that would be really great! Thanks!^.*([a-z]+\\.)(C.mating|Spencer96Generate+)*([a-z]+\\.)$",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "[^s][a-z][^s]*ing.*",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "^.*[a-z]{0,}ing$",
        "passed": false
    },
    {
        "id": 4044,
        "completion": "*(w\\d|\\w+ng|\\w+ly|w\\dings|w\\dings|w\\dings|w\\dings|w\\dings|w\\dings)",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "[A-Fa-f0-9]+$",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "[A-F0-9]/[a-f0-9]*+/[a-f0-9]?\\\\[A-F0-9]?\\\\]This will not work for the last one since the question doesn't provide the last one.",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "A\\W{12}\\W{2}-\\W{8}[A-F0-9]{1,6}",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "^(?=.*[a-f])(?=.*\\D)(?=.*\\d).{3,}\\Z",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "[A-Fa-f0-9]+[\\ ]*",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "0-9HEX onlyHEX only capital A-F and numbers 0-9Generate a RegEx for this description.",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "(HEX only CAPITAL A-F]|\\(\\d{4}\\)|[A-Fa-f0-9])+@[A-Fa-f0-9]+(.[A-Fa-f0-9]+)+\\.(com|org|edu)",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "[a-fA-F0-9]{2}[0-9A-F]{2}[0-9A-F]{2}[0-9A-F0-9]{1}|\\w*[.!\\?\\:\\/\\\"-]+\\d{1,2}[\\.!\\?]{1}[a-f",
        "passed": false
    },
    {
        "id": 4051,
        "completion": "\\b[A-Fa-f0-9]{3}\\b",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "\\[ \\bCZ\\b\\]",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "[^0-9a-zA-Z ]",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "(.*?)-(.*?)-..-..-.-",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "\\bPESEL\\b",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "[\\s]?PESEL\\s[\\d]{6}\\[\\w\\w\\s]",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "```import retxt = \"Generate a RegEx to get an official PESEL number\"pattern = re.compile(\".*PESEL.*\",\"i\")print(pattern.match(txt)) #True```",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "\\(.*[a-z]\\?.*[d]\\?.*\\=.*[0-9\\.]+(\\s[a-z]\\?[d]\\?[0-9][s]+\\.)*[0-9]), \\b",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "/([A-PR-Z]{3})[-a-z]{3}[-a-z][-a-z]{3}(-[A-PR-Z]{3})$/",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "r'^P(?P<id>\\d{8})$'",
        "passed": false
    },
    {
        "id": 4067,
        "completion": "import repeselregex = '^PESEL(?:[0-9]+|[0-9]{4})+'",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "\\d{4}(-(\\d{1,2})\\d{1,2})",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "^(20[0-4]|21[0-9]|2[0-9]|30)-[0-9]{6}$",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "[r\"\"'2020 - 39 years''(?:(?:19|20(?:0{1,2}:){2}\\d|20\\d(?:0{1,2}:){2}19)'\"\"\" \\              r''' - 39 years''r\"\"\"\\''(?:(?:19|20(?:0{1,2}:){2}\\d|20\\d(?:0{1,2}:){2}19)'\"\"\" \\              r''' - 39 years'')'(",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "\\d{2}(?:-?\\d{4})",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "\\b\\d{4}\\D?[1-9]\\d{3}\\D?\\d{4}\\b",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "\\d{4}-\\d{2}-\\d{2} |20[0-1]\\d|20[3-9]",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "^\\d{4}\\-|\\d{3}\\-|\\d{2}-$",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "\\d{4}-19\\d.",
        "passed": false
    },
    {
        "id": 4072,
        "completion": "[01], [03], [07], [09], [12], [13]",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "[3456789][0123456789]Example with n=8:[3456789][0123456]",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "[0].*(1)  [5]  [0]  [4]  [2]",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "If you have a single digit number with value between 0 and 9... then\\b(\\d)0\\2{4,}\\d\\b",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "\\d{5}-\\d{6,10}",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "^(20*12)$",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "^(1\\d{3}|2[0-4]\\d|[0-9][1-9]\\d|20[1-9])[ -/]?\\d{3}(0[ -/]?)\\d{2}$Example for pattern description:1.1\\d{3} - 1 and 3 digits2.123 - 1, 2, and 3 digits",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "(?<=0)(?=0|1)(?25|2)(?25)(0)2It will not work for digit 0.So it may help.",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "^(?:[2-9][0-9]{3}[0-9] | 3[0-4][0-9]|35[0-2])$Explanation^      - Starting line(?:     - Open non-capturing group consisting of (?:number-with-digit-x)",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "\\d\\d\\d\\d\\d(?:5|6[0-9]|7[0-9])[0-9]\\d",
        "passed": false
    },
    {
        "id": 4086,
        "completion": "\\d{5}-\\d{2}-\\d{6}\\d{3}-\\d{3}-\\d{3}-\\d{3}-\\d{4}Thank you for any help, please help me!",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "[A][B-D][A-Q][0-5][0-9][0-5][0-9][A-B-D][0-9][0-9]|[0-9][0-2][0-9][0-9][A-Z][0-9]|[0-9][0-9][0-9][A",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "The general format of regx for describing a custom regx is\"[char_list],\"(?:[\\\\d][\\\\w|\\\\-\\\\_]{0,})*\"",
        "passed": false
    },
    {
        "id": 4107,
        "completion": ".(?=[^IH]$)  [^IH][A-D](?=[A-D]$)",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "# [A-D] (one letter)import remy_exp = re.compile(r'[A-D]\\d')print(my_exp)",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "\\d{2}[-\\.\\s]{0,1}A[-\\.\\s]{0,1}B [-\\.\\s]{0,1}C [-\\.\\s]{0,1}",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "r/^([a-d]{2})([a-d]{2}|[a-d]|[0-4])$https://regex101.com/r/YvN9D1/1",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "([A-D][0-9]{3}\\-\\d)",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "^[A-D][a-z]{2}$",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "",
        "passed": false
    },
    {
        "id": 4107,
        "completion": "1[4-9]\\d*\\|[1-4][1-9]\\d*",
        "passed": true
    }
]