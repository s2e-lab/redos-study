[
    {
        "expression": "^\\d$",
        "raw_prompt": "Matches exactly 1 numeric digit (0-9).",
        "refined_prompt": "Matches exactly 1 numeric digit (0-9).\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"a\"\n- \"324\"",
        "matches": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "0"
        ],
        "non_matches": [
            "a",
            "324",
            "num",
            "location = 3",
            "ssda",
            "11",
            "hello world",
            "something something",
            "asd",
            "123fsf",
            "the car",
            "lorem ipsum"
        ],
        "stress_tests": [
            "eeeeeeeeeeeeyyyyyyyyhhyhuy"
        ],
        "id": 1,
        "output": [
            {
                "text": " r'^\\d$'\nExplanation: If the String begins with a digit, it is a valid digit. Otherwise, the character is not a valid digit.\n\n\n\nQuestion 1: Olivia buys a dress that is on sale for 30% off the original price of $80. She then has to pay a 5"
            },
            {
                "text": " \n\nimport re\n\nexample_text = \"\"\"The number of cars in the lot is 2.\nWe should count the cars in the lot carefully.\"\"\"\n\n# Use of findall to extract all numbers in the text\nnumbers = re.findall(r'\\d+', example_text)\n\n"
            },
            {
                "text": " \n^[0-9]*$|^\\+[0-9]*$|^-?[0-9]*$|^1-?[0-9]*$|^[0-9]+$\n\nExercise 2: Write a RegEx pattern that would match a string containing"
            },
            {
                "text": " [a-zA-Z0-9]+ [a-zA-Z0-9]\nThe expression ([a-zA-Z0-9]+ [a-zA-Z0-9]+ [a-zA-Z0-9]+ [a-zA-Z0-9])"
            },
            {
                "text": "\n[0-9]\n\nExercise 4: Match any string of text that contains at least one uppercase letter and one lowercase letter.\nAnswer:\n[a-zA-Z]\n\nExercise 5: Match any string of text that contains any combination of these special characters:\n- `[]`"
            },
            {
                "text": "\n/^[\\d][\\d]\\d[\\d]$/\n\n3. Write a function that takes an email as input and returns true if it is in an acceptable format and false otherwise (has a domain, starts with '@', ends with '.'). \nExample:\ninput: \"myemail"
            },
            {
                "text": " (.+)\n\"a\" Matching a character\n\"324\" Matching 9 digits\n\nA:\n\nYou can try this code:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define strlen(s) (sizeof(s"
            },
            {
                "text": " ^(?=(?:.*\\d)(?1))$ (where any character (except newline) is a non-digit)\n\nA:\n\nFor me, the best way is to first change the character sets to a special group of characters that you know you won't use anywhere else.\nThis way, your code"
            },
            {
                "text": " ^[0-9]$|^[0-9]+$\n\n# 9.4.4 The Character class and its symbols\n\nIn regular expressions, a character class is used to match any character that falls within a certain set of characters. A set of characters can be defined using a square bracket [], where each"
            },
            {
                "text": " /(?:\\d{1,2}\\s*\\w*)/g\n\n# 3. Extract Numbers From Strings Using RegEx\nPython provides the `re` module, which contains functions to work with Regular expressions (RegEx). One can use the `re.findall()` and `re.search()`"
            }
        ]
    },
    {
        "expression": "^\\d{5}$",
        "raw_prompt": "Matches 5 numeric digits, such as a zip code.",
        "refined_prompt": "Matches 5 numeric digits, such as a zip code.\nMatch examples:\n- \"33333\"\n- \"55555\"\n- \"23445\"\nNon-match examples:\n- \"abcd\"\n- \"1324\"",
        "matches": [
            "33333",
            "55555",
            "23445",
            "89343",
            "46556",
            "25432",
            "25336",
            "43576",
            "68797",
            "30495",
            "54348",
            "45935",
            "93857"
        ],
        "non_matches": [
            "abcd",
            "1324",
            "as;lkjdf",
            "jaldks",
            "234",
            "8hr4f",
            "fsdg",
            "2546dgwre",
            "8j989",
            "xhsn",
            "potrewjdsg",
            "h345gf43"
        ],
        "id": 2,
        "output": [
            {
                "text": " 3 consecutive digits followed by a 3 consecutive digit number (4 or more) \n\n5. Create a RegEx for this description:\n\nAn example description string that contains a word and possibly a numerical value (e.g., \"10.35\").\n\nHints: This expression should extract all"
            },
            {
                "text": "\n([0-9]{7}|[0-9]{5}|[0-9]{3})\n\nExercise 4: \nUse the RegEx generated in Exercise 3 to find all the matches in this list of strings:\n['Zip code: 33333', '"
            },
            {
                "text": " (.*[a-zA-Z]{3,})\nExercise 3: Convert this list to a single element by reversing it: [[\"apple\", \"banana\", \"cherry\"], [\"orange\", \"kiwi\"]]\nAnswer: [[\"cherry\", \"kiwi\", \""
            },
            {
                "text": " (Include all possible RegEx outputs)\n\n- Exercise 5: \nProvide an example of how RegEx can be used in Python to extract data from a webpage.\nExample: We could use RegEx to extract all email addresses in a webpage using:\n\nmy_regex = r"
            },
            {
                "text": " (\\d)\\1*$\n\n\n\nQuestion 6: A fruit stand sold 5 apples and 3 oranges for a total of $9. If each apple costs twice as much as each orange, what was the cost of one orange?\n\nSolution:\nLet the cost of one orange be x dollars"
            },
            {
                "text": " ^(?!.*\\d$)(?!.*\\d.*\\d)\\d{5}$\n\nI have a problem creating an algorithm with this one.\nI need it using python with numpy.\n\nA:\n\nWith that regex you want:\n^^[^0-"
            },
            {
                "text": " r\"\\b\\d{4}-\\d{3}-\\d{2}\\b\"\nExample Use Case:\nScenario: Jane, a school librarian, wants to generate a list of student record codes for their school's library system.\nJane: \"I'm thinking about"
            },
            {
                "text": "\nI can't think of a way to generate a regex, as it would be too wide, and the input would be too varied. It would be possible for the regex to generate a regex, but I can't find a practical application for it!\n\nA:\n\nUse this regex,\n("
            },
            {
                "text": " Matches any length of non-alphanumeric characters, with at least one occurrence of a repeated character.\n\nExercise 3: Write a regular expression pattern that matches all IP (Internet Protocol) addresses.\nAnswer: IP: [0-9]{1,3}\\.[0-9]"
            },
            {
                "text": " The non-match examples include \"abcd\" and \"1324\".\n\nExercise 3:\nMatch the following email domains:\n- Example 1: (3-6) Alpha-Beta Corporation\n- Example 2: (3-6) Omega-Growth Enterprises\n- Example 3: ("
            }
        ]
    },
    {
        "expression": "^\\d{5}-\\d{4}$",
        "raw_prompt": "Numeric and hyphen 5+4 ZIP code match for ZIP+4.",
        "refined_prompt": "Matches a string that starts with five digits, followed by a hyphen, and ends with four digits.\nMatch examples:\n- \"22222-3333\"\n- \"34545-2367\"\n- \"56334-2343\"\nNon-match examples:\n- \"123456789\"\n- \"A3B 4C5\"",
        "matches": [
            "22222-3333",
            "34545-2367",
            "56334-2343",
            "34539-5433",
            "12349-5943",
            "54329-9875",
            "34852-5493",
            "83542-2314",
            "52435-3489",
            "12345-0983",
            "98745-2385",
            "48294-2945"
        ],
        "non_matches": [
            "123456789",
            "A3B 4C5",
            "55335",
            "dinfa",
            "sfalijad234",
            "asdf3453",
            "dsjlka3",
            "234fsd",
            "gaqwer3",
            "adfa2",
            "23457-4332w2"
        ],
        "id": 3,
        "output": [
            {
                "text": "\n\nimport re\n\ndef generate_regex(description):\n    chars = '0123456789ABCDEF'\n    matching_chars = [c for"
            },
            {
                "text": " /^[0-9]{5}-([0-9]{4})$/ \n\n3. Write a RegEx pattern that matches a string with at least one"
            },
            {
                "text": " [12]A-B-4-3\n```python\nimport re\n\ndef validate_phone_number(mobile_number: str):\n    if not re.match"
            },
            {
                "text": " [^0-9]\\d{3}-\\d{4}\n3. Write a Python program that takes in a string as input and returns a list of all the sentences"
            },
            {
                "text": " /^[0-9]{5}-\\d{4}$/\n\nExercise 3: Matching Multiple Words\n\nWrite a regular expression that matches a word that"
            },
            {
                "text": " ^\\d{5}\\-\\d{3}$\n\n2. Exercise: Find the position of the first occurrence of an opening parenthesis in a string.\nFind the position"
            },
            {
                "text": " \"^[0-9]{5}-[0-9]{4}$\"\n\nExercise 5: What would you use to match a string that starts with one or"
            },
            {
                "text": " \n^[0-9]{5}-?[0-9]{4}$\n\nExercise 4:\nWrite a REGEX that will only match letters,"
            },
            {
                "text": " \\d{5}-\\d{3}\n\nExercise 5: Email Validator\nValidate that an email follows the following format:\n- Domain name (top-level"
            },
            {
                "text": " (\\d{5})-(\\d{4})\n\n\n\nLadies and gentlemen, esteemed guests, today I stand before you to shed light on the captivating wonders of language"
            }
        ]
    },
    {
        "expression": "^\\d{5}$|^\\d{5}-\\d{4}$",
        "raw_prompt": "This regular expression will match either a 5 digit ZIP code or a ZIP+4 code formatted as 5 digits, a hyphen, and another 4 digits. Other than that, this is just a really really long description of a regular expression that I'm using to test how my front page will look in the case where very long expression descriptions are used.",
        "refined_prompt": "Match either a 5 digit ZIP code or a ZIP+4 code formatted as a string that starts with five digits, followed by a hyphen, and ends with four digits..\nMatch examples:\n- \"55555-5555\"\n- \"34564-3342\"\n- \"90210\"\nNon-match examples:\n- \"434454444\"\n- \"645-32-2345\"",
        "matches": [
            "55555-5555",
            "34564-3342",
            "90210",
            "03945",
            "02946",
            "46556",
            "52346",
            "34534-3252",
            "49672-3923",
            "59403-6934",
            "35349-6753",
            "52346-3953"
        ],
        "non_matches": [
            "434454444",
            "645-32-2345",
            "abc",
            "394-3498",
            "234565423",
            "j3942fw",
            "43-5432",
            "5324523-345",
            "h909f34f",
            "0953jg",
            "wtre-0n",
            "3409fjg43"
        ],
        "id": 4,
        "output": [
            {
                "text": " The RegEx for this description is \"^\\d{5}-\\d{2}-\\d{4}$"
            },
            {
                "text": " [5-9]\\d{3}-\\d{3} \nExercise 2: Password Validation\nMatch"
            },
            {
                "text": " \"5[0-9]\\-\\d{3}[0-9] \" \n\nExercise 2: Create"
            },
            {
                "text": " (\\d{5})-(\\d{3})-(\\d{4})\n\nLecture Script:\n"
            },
            {
                "text": " I want to match ZIP+4 codes (five digit ZIP code, followed by a plus or minus indicator, followed by four digit zip"
            },
            {
                "text": ".{5}-.* \n\n3. Example exercise. Write a regular expression that matches email addresses and phone numbers in the"
            },
            {
                "text": " \\d{5}-\\d{2}-\\d{4}\n1) Match either a positive or negative look"
            },
            {
                "text": " (.*)(?=\\d{5}\\Z) or (([a-z])+\\s)?([a-z"
            },
            {
                "text": " \n(\\d+)\\-(\\d+)\n\n7.3.10 Validation and Sanitation of User Input with"
            },
            {
                "text": " (?i)(?=.*[0-9])[789].{5,4}$\n\nExercise 2:"
            }
        ]
    },
    {
        "expression": "^\\d{3}-\\d{2}-\\d{4}$",
        "raw_prompt": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.",
        "refined_prompt": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.\nMatch examples:\n- \"333-22-4444\"\n- \"123-45-6789\"\n- \"534-74-2573\"\nNon-match examples:\n- \"123456789\"\n- \"SSN\"",
        "matches": [
            "333-22-4444",
            "123-45-6789",
            "534-74-2573",
            "234-45-6235",
            "968-24-4395",
            "948-53-5924",
            "493-42-5938",
            "954-97-5942",
            "534-96-3623",
            "549-69-3456",
            "543-54-6396",
            "294-68-1957"
        ],
        "non_matches": [
            "123456789",
            "SSN",
            "-243",
            "4523-24352-453",
            "2346-2345-2435",
            "dgsfjkl",
            "2204fj",
            "234jgs-345",
            "4235-fgdsg",
            "afd-asdf",
            "dfg",
            "32542"
        ],
        "id": 5,
        "output": [
            {
                "text": " \n- (?:\\d{3}\\-){2}\\d{3}-\\d{4}\n\n\n\n\nIntroduction to"
            },
            {
                "text": " \nRegEx: SSN\\s+([0-9]{3})-(?![0-9])[0-9]"
            },
            {
                "text": " (\\d{3}-)?(\\d{2}-)?(\\d{4})\n\nExercise 2: Suppose you are searching for"
            },
            {
                "text": " \n^\\d{3}-\\d{2}-\\d{4}$\n\nExercise 3:\nRegular expressions can"
            },
            {
                "text": " \nSocial Security Number (SSN) = \\d{3}-\\d{2}-\\d{4}\n\n### Exercise"
            },
            {
                "text": " \\d{3}(?!-)-\\d{3}(?!-)-\\d{4} Generate a RegEx for this description"
            },
            {
                "text": " ^\\d{3}-[\\d]\\d-\\d{4}$\n\nExercise 3: Using the RegEx you just"
            },
            {
                "text": " #1-12-3333, #2-13-4444, #3-14-2244, #4-15-3333, #"
            },
            {
                "text": " r\"[\\d]{3}\\-{2}\\-{3}\\d{4}\"\n\nExercise 3: Using Regular Expressions You"
            },
            {
                "text": " The pattern should match any series of numbers of length 4 digits separated by a hyphen.\n\nExample 5: Validating a Phone Number with Regex"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]$",
        "raw_prompt": "Matches any single upper- or lower-case letter.",
        "refined_prompt": "Matches any single upper- or lower-case letter.\nMatch examples:\n- \"a\"\n- \"B\"\n- \"c\"\nNon-match examples:\n- \"0\"\n- \"&amp;\"",
        "matches": [
            "a",
            "B",
            "c",
            "f",
            "J",
            "D",
            "s",
            "D",
            "d",
            "o",
            "F",
            "p",
            "r"
        ],
        "non_matches": [
            "0",
            "&amp;",
            "AbC",
            "rewv342",
            "vr",
            "@",
            "sdfSDF",
            "asf",
            "324df",
            "34fs2",
            "34d2vdw",
            "99999@gmail"
        ],
        "id": 6,
        "output": [
            {
                "text": " (\\w{1}|\\w{2,3}|\\w{4,})\n\n\n\nComparison--Silent and Noisy\n\nGreetings, my extraterrestrial friend! Today, we will delve into the fascinating world of comparison, specifically focusing on two contrasting states that exist in our daily lives"
            },
            {
                "text": " &amp;\n9. Match any single lower-case letter.\n- /s/ - Matches s or _.\nExamples:\n- \"a\"\n- \"z\"\nNon-match examples:\n\n0) \"0\"\n1) \"A\"\n2) \"B\"\n3)"
            },
            {
                "text": " [\"A-Za-z0-9&\", \"-_\\s]\n\n\n# Chapter: The Use of Python Dictionaries for Quantitative Analyst\n\n## Sections:\n- Overview of Python Dictionaries and Their Importance\n- Creating and Accessing Dictionaries\n- Modifying and Deleting"
            },
            {
                "text": " \\b(A|b)([a-z0-9A-Z&])+\\b\n2. Write a RegEx to match email addresses using the following rules:\n- Email addresses should begin with one or more letters, followed by one or more letters, numbers, hyphens, periods, hyphens,"
            },
            {
                "text": " &amp;\n\n6. Write a Python code to print all the numbers from 1 to 300.\nExample output: [1, 2, 3,..., 300]\n```python\nimport re\n\ndigits = re.findall(r'\\d', '1234567890')\nnum ="
            },
            {
                "text": " [0-9A-Fa-f^,+-]\n\nLecture Note:\n## Subsection 19.2.4: The string module and the constants and mappings\n\nThis subsection covers the `string` module and its static character and string constants, as well as the `mapping`"
            },
            {
                "text": " \"^[A-Za-z]*$\"\n5. Write a Python code that uses regular expressions to find all email addresses in a given text. You do not need to use the email package.\nAnswer:\nimport re\ntext = \"My email is john.dept.receptionist@company"
            },
            {
                "text": " Character class: a-z; Case-insensitive.\n1. a. b. c\n2. A. b. C\n3. c. B\nGreat job! Now, let's move on to some real-world use cases.\n\nReal-World Use Case 1: Email Validator\nA company"
            },
            {
                "text": " \\w (Word)\n\n6. \"The 'and' in 'The big brown bear' can only match the word 'bear' in any given string, as opposed to the word 'big,' as it is a non-possessive apostrophe (')\". True or False? \nAnswer: False\n"
            },
            {
                "text": ".\n4. Write a regular expression that starts with a period (.) followed by one or more digits, and ends in the word \"commas\".\nAnswer: [.]\\d+commas\\.\n\n5. Create a pattern that matches a string containing at least two uppercase letters, one lowercase letter,"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]+$",
        "raw_prompt": "Matches any string of only upper- and lower- case letters (no spaces).",
        "refined_prompt": "Matches any string of only upper- and lower- case letters (no spaces).\nMatch examples:\n- \"abc\"\n- \"ABC\"\n- \"aBcDeF\"\nNon-match examples:\n- \"abc123\"\n- \"mr.\"",
        "matches": [
            "abc",
            "ABC",
            "aBcDeF",
            "dfasdfs",
            "ALKFJsf",
            "FDSfdsf",
            "AJFDAL",
            "sfdjk",
            "FISD",
            "sadfkjl",
            "fadghui",
            "FDSnfsdFDS",
            "sdfjoi"
        ],
        "non_matches": [
            "abc123",
            "mr.",
            "a word",
            "a a a",
            "209fsd",
            "3nf@",
            "fgsda23",
            "nu9",
            "u09nKLJG FSL",
            "gdfios jsfoi",
            "JFLSKJ FSDOIJ",
            "GOOD friend"
        ],
        "id": 7,
        "output": [
            {
                "text": " You would start with the beginning of a word (\\w) and match any number of characters on either side of it. At each match, check if you have matched a space. If you have not matched a space in the middle of the word, but you have matched a space between"
            },
            {
                "text": "\n- mr.\\w*\\s\\w+\n- Mr.\\w*\\s\\w+\n- Mr\\w*\\s\\w+\n- Mr\\w*\\s[A-Z][a-z]\\s[A-"
            },
            {
                "text": " Regex for the phrase \"mr.\" must match \"mr.\" with any number of upper- or lower case letters.\n\nExercise 4: \nMatch any string of only upper- or lower- case letters (no spaces) that is at least 6 characters long.\nExample"
            },
            {
                "text": " \\d+\n\n5. Write a Python function that scans a directory on your computer and returns the path of the file with the highest file size in bytes. Write a regular expression to match all files with a given extension in the specified directory.\n```python\nimport os\n"
            },
            {
                "text": " [a-z_0-9]+\n\nExercise #4:\nMatch any string of only digits (no spaces).\n\nExercise #5:\nMatch any string of at least 3 characters that start with a lowercase letter.\n\nExercise #6:"
            },
            {
                "text": " ^[^\\d\\W]+$\n\n4. Using Regex, how can you select all emails from a string of text? (Hint: look up the Matcher.findAll() method in the StringMatcher API and use it as a guide.)\nExample"
            },
            {
                "text": " (mr\\.\\.) is likely acceptable, or if it is allowed, it might be a simplified alternative to regex.\n\nExample 2:\nA website allows users to sign up with an email address and password. You need to create a regular expression to validate a user's email and"
            },
            {
                "text": " r'^[a-zA-Z]+$' \n\n2. Create a Matcher instance and test each of the following Regexes on a string. If the string does not match, print out a message. \n- \"aBcDEFG\""
            },
            {
                "text": "\n\n```\nimport re\ntext = \"mr.Generate a RegEx for this description.\"\nnew_text = re.sub(r\"[^\\w\\s]\", \"-\", text)\nprint(new_text)\n```\n\nExercise"
            },
            {
                "text": " The RegEx might be \"(^[mR|M][0-9][0-9])+$\"\n\nExplanation:\n- The \"^\" anchor (anchoring) ensures that the string is beginning.\n- The \"[\" matches \"m\"\n"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+$",
        "raw_prompt": "Matches any alphanumeric string (no spaces).",
        "refined_prompt": "Matches any alphanumeric string (a string that contains only English letters and/or digits without spaces).\nMatch examples:\n- \"10a\"\n- \"ABC\"\n- \"A3fg\"\nNon-match examples:\n- \"45.3\"\n- \"this or that\"",
        "matches": [
            "10a",
            "ABC",
            "A3fg",
            "AFDSA",
            "asfsafd",
            "123",
            "123123abcAfds",
            "2398djAD",
            "dsfhoi329",
            "98hsd",
            "NOTREDAME",
            "ILOVEND",
            "notredame46556"
        ],
        "non_matches": [
            "45.3",
            "this or that",
            "$23",
            "...111",
            "2346-2345-2435",
            "3nf@",
            "43-5432",
            "2546dgwre fsdfsd",
            "u09nKLJG FSL",
            "90ndfdfs ,./././ dcf",
            "sdf324 abc...",
            "99999@gmail"
        ],
        "id": 8,
        "output": [
            {
                "text": " \"^[\\d]+, [\\d]+, [\\d]+, [\\d]+, [\\d]+, [\\d]+$\"\n\nExercise 4:\nWrite a Python function that takes a string as an argument"
            },
            {
                "text": "\n[a-zA-Z0-9\\.]+\n\n\n\n[Your Name]\n[Your Address]\n[City, State, ZIP]\n[Email Address]\n[Phone Number]\n[Date]\n\n"
            },
            {
                "text": " *any digit*, *any character*\n2. Write a Python script that matches all lowercase words starting with A and ending with T or F.\nAnswer: \\b(A[a-z]*)(T[a-z]"
            },
            {
                "text": " \".*(\\w|-|\\.)*$\"\n\n\n\nQuestion 3: Tom is saving money to buy a new mobile phone. If the phone he wants to buy costs $800 and he already has 60% of the money, how much"
            },
            {
                "text": " a string that contains only English letters AND digits and a period with no spaces.\n\nStudent: Hi TA, can you explain what Regular Expressions are and how they work with Python?\n\nTA: Sure! Regular expressions are a powerful tool"
            },
            {
                "text": " [^\\w']{1,59}(?:\\.\\d*)?\nExamples: \n\n# Matches any alphanumeric string (a string that contains only English letters and/or digits without spaces)\nregex ="
            },
            {
                "text": " \\d+.\n\n# Solution #1\nExercise 1:\nCreate a Python list of strings that include at least two numeric strings and one alphanumeric string. Then, apply the regular expression `^\\d+$` to each element"
            },
            {
                "text": " (?<=\\d) or (?<=\\D), (?=\\d) or (?=\\D)\nWhat is a match?\nA match object is an object returned by re.search() and re.match"
            },
            {
                "text": " a-zA-Z0-9, hyphen optional. \n\n5) Write a Python program that uses a RegEx to extract all phone numbers from a string. \nIdeas: You can test the program on a sample string"
            },
            {
                "text": " (?!.*[A-Za-z])(?!.*[0-9])(?!.*[A-Za-z0-9 ]){8,25}\n\n3. Write a program that receives a number from the"
            }
        ]
    },
    {
        "expression": "^\\d+$",
        "raw_prompt": "Positive integer value.",
        "refined_prompt": "Positive integer value.\nMatch examples:\n- \"123\"\n- \"10\"\n- \"54\"\nNon-match examples:\n- \"-54\"\n- \"54.234\"",
        "matches": [
            "123",
            "10",
            "54",
            "39",
            "583",
            "395",
            "2394",
            "2394854",
            "384",
            "324",
            "222",
            "1",
            "2",
            "39",
            "583",
            "395",
            "2394",
            "2394854",
            "384",
            "324",
            "222",
            "1",
            "2"
        ],
        "non_matches": [
            "-54",
            "54.234",
            "abc",
            "-123",
            "9ijn",
            "qwer",
            "-312",
            "1.1",
            "1.1.1",
            "1-1-2",
            "34.31",
            "8h98009hu",
            "-123",
            "9ijn",
            "qwer",
            "-312",
            "1.1",
            "1.1.1",
            "1-1-2",
            "34.31",
            "8h98009hu"
        ],
        "id": 9,
        "output": [
            {
                "text": " * ^[_\\-0-9]*$ */g\n\n[Question 2]: Which regex matches strings with exactly 3 digits? Hint: '\\\\d' in a RegEx matches any digit (0-9).\n\n[Answer 2]:\nPattern r2 = \"[0-9]{3}\";\n\nQ:\n\nRe"
            },
            {
                "text": "\n^[0-9]+[.][0-9]+$\n\nExercise 3: \nCreate a rule that extracts all the email addresses from a list that follow the pattern of a username@domain.net, where the username is between 10 and 100 characters and the domain name is of at least 4 characters. \nAnswer:\n("
            },
            {
                "text": " The regex for \"non-zero-digits\" is ^(?!0+$)\\d+$\n\n\n\nBoth Negative and Positive Reasoning Exercise: Medicine\u2013Neurology\u2013Neuromuscular Disorders\n\nPsychological Foundation:\nNeuron function is one of the most critical areas in the field of Neurology. The human"
            },
            {
                "text": " (a\\d)+_(-?(a\\d)\\d+)\n\n4.3: Return the string containing only numbers and hyphens. For\n  this exercise, replace a hyphen with the character \u201c*`. For example,\n  \u201ca-b\" should return \"*b.*\".  \nSolution: \u201c"
            },
            {
                "text": " The correct answer is '\\b-?\\d+\\.?\\d+'\n\nExercise3: Write a Python function that takes a string input and returns it in title case using RegEx.\n\nExercise: Write a Python function that takes a string input and capitalizes the first letter of each word in the inputted string using regular"
            },
            {
                "text": " [123]|[0-9]\n2. Write a RegEx that will match any String which contains at least 1 white space characters or one period(.).\n- \"the white spaces are cool!!!!!\"\n- \"hello world!\"\n- \"hello\"\n- \"hello   123!!!\"\n3. Write an expression that will match"
            },
            {
                "text": "\n\"\"\"\nregex_value_1 = re.compile('^[0-9]+$')\nprint(\"Test with one digit:\", bool(regex_value_1.match('1')))\nprint(\"Test with more than one digit:\", bool(regex_value_1.match('123')))\nprint"
            },
            {
                "text": " [0-9]\\.[0-9]\n\n3. Write a RegEx to match a URL that has the domain \"www.example.com\".\nAnswer: /www\\.(com)/\n\n4. Write a RegEx to match a phone number in the format \"XXX-XXX-XXXX\".\nAnswer: \\d{3"
            },
            {
                "text": "\n(3\\d|-)?\\d+\n(Three friends, Emily, Liam and Jane, are lying on the grass during a picnic on a sunny day. Emily brings her guitar with her.)\n\nEmily: (strums the guitar) So, have either of you ever had trouble with your voice during singing or public speaking?\n\n"
            },
            {
                "text": " \\d+\\.?\\d*\n- What is wrong with this expression and suggest a fixed one? \nAnswer: The expression.?.* will match a period at the end of a line, if there isn't one there. This will match a dot (.) at the end of a line. A better expression would be \\d+("
            }
        ]
    },
    {
        "expression": "^(\\+|-)?\\d+$",
        "raw_prompt": "Matches any signed integer.",
        "refined_prompt": "Matches any signed integer, in other words, a string that can start with an optional plus (+) or minus (-) sign, followed by one or more digits.\nMatch examples:\n- \"-34\"\n- \"34\"\n- \"+5\"\nNon-match examples:\n- \"abc\"\n- \"3.1415\"",
        "matches": [
            "-34",
            "34",
            "+5",
            "809",
            "790987",
            "+5483920",
            "-2354",
            "+540893",
            "-234",
            "2349",
            "5094",
            "234234",
            "+123"
        ],
        "non_matches": [
            "abc",
            "3.1415",
            "-5.3",
            "0bu9",
            "234dc",
            "312ccc",
            "123u98b",
            "1.2",
            "-2.3",
            "4.5",
            "+4.5",
            "-99.99"
        ],
        "id": 10,
        "output": [
            {
                "text": " 0(?P<sign>[-+])?\\d+(?P<value>[\\d.]+)\n\nExercise 2: Using the RegEx generator from Exercise 1, find all positive and negative numbers"
            },
            {
                "text": " \"^[0-9]+$\"\n\n5. The use of Regex for extracting values from a string\nIn addition to creating a RegEx, you can also use it to extract values from strings"
            },
            {
                "text": " a-zA-z0-9_.\n\nimport re \nre.search('[a-zA-Z]+_[0-9]+', 'asdfghjkl"
            },
            {
                "text": "\n^[-+]?[0-9]* \n\nExamples\n1. Valid\n   \"3+34\"\n   \"3.04\"\n   \"3+-34\"\n"
            },
            {
                "text": " +[0-9] \nGenerate a RegEx for this description. To match either a letter or a digit. \nAnswer: [A-Za-z]|[0-9"
            },
            {
                "text": " \n^(?=.*[1-9])(?=.*[0-9])(?=.*[0-9])(?=.*[0-9])[0-9"
            },
            {
                "text": " ([+-])(\\d{1})?|(?=\\d)\\d*(\\.\\d++)?\n\nIn this case, for any non-matching examples: ([+-"
            },
            {
                "text": " \"(\\+|-)([0-9]+)$\"\n\n7.6.7 The case-insensitive, multiline, and global modifiers\nThe following modifiers make a pattern case-"
            },
            {
                "text": " ^([+-])(\\\\d+$)\n- Any word character other than a minus (-) (\\w)\n\nI tried something like this: (\\w)-((\\+|\\-"
            },
            {
                "text": " [\\d-]+\n\nHint: Use the escape character inside square brackets to match the minus (-). \n\n\n\n\nStudent: A store is having a 20% off sale. A dress"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]\\w{3,14}$",
        "raw_prompt": "The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used",
        "refined_prompt": "The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used.\nMatch examples:\n- \"abcd\"\n- \"aBc45DSD_sdf\"\n- \"password\"\nNon-match examples:\n- \"afv\"\n- \"1234\"",
        "matches": [
            "abcd",
            "aBc45DSD_sdf",
            "password",
            "F3fsdsdf_234",
            "F0392",
            "fd02934",
            "k2039",
            "ABC09314",
            "abc_ABC",
            "NOTREDAME",
            "fadghui",
            "QWERTY",
            "p0p0p0"
        ],
        "non_matches": [
            "afv",
            "1234",
            "reallylongpassword",
            "1",
            "234",
            "ab",
            "123312312",
            "98iojk",
            "9ijk",
            "98hsdf",
            "longlonglonglonglong",
            "hello12345hello12345"
        ],
        "id": 11,
        "output": [
            {
                "text": " The regex should be ^[A-Za-z][A-Za-z0-9_]{0,8}$.\n"
            },
            {
                "text": " \n- The first character must be a letter. \n- The password has a minimum of 4 characters. \n- The password maxiumum"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*[\\d])(?=.*"
            },
            {
                "text": " [A-z]{4,15}[A-z0-9_]*\n\nExercise 4:\nA company needs to"
            },
            {
                "text": " /^(?=.*[a-z])(?=.*[A-Z])(?=.{4,15})(?"
            },
            {
                "text": " The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers"
            },
            {
                "text": " We're looking for a string that contains 3-8 characters (numeric and letter) except for the underscore:. The special character of choice is the"
            },
            {
                "text": " [^a-zA-Z1-9_]|[a-zA-Z0-9_]{2,15}"
            },
            {
                "text": " ^(?=.*\\d)(?=.*[a-zA-Z])(?=.*[$@$!%*?"
            },
            {
                "text": "\n[a-zA-Z][a-zA-Z0-9_]{2,15}\n\n**Exercise 3"
            }
        ]
    },
    {
        "expression": "^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$",
        "raw_prompt": "Simple email expression. Doesn't allow numbers in the domain name and doesn't allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more). Doesn't handle multiple &quot;.&quot; in the domain (joe@abc.co.uk).",
        "refined_prompt": "Checks if an email address starts with one or more alphanumeric characters, followed by the \"@\" symbol, a domain name with letters or underscores, a dot, and finally a domain extension with two or three letters.\nMatch examples:\n- \"joe@aol.com\"\n- \"ssmith@aspalliance.com\"\n- \"a@b.cc\"\nNon-match examples:\n- \"joe@123aspx.com\"\n- \"joe@web.info\"",
        "matches": [
            "joe@aol.com",
            "ssmith@aspalliance.com",
            "a@b.cc",
            "apple@qq.com",
            "123@qq.com",
            "abc@abc.com",
            "ab@ab.ab",
            "bc@bc.bc",
            "avpl@qq.cn",
            "sustech@nd.com",
            "msft@nd.us",
            "notredame@nd.edu"
        ],
        "non_matches": [
            "joe@123aspx.com",
            "joe@web.info",
            "joe@company.co.uk",
            "234dsf@032ijsd.fasdf.sdf",
            "fads@sdaf@asdf",
            "89ioj@9ijosf",
            "abc@abc",
            "a@a.a.a",
            "qwerty@123.123",
            "123@sustech.edu.cn",
            "apple@banana",
            "test@test.test"
        ],
        "id": 12,
        "output": [
            {
                "text": " \\w[\\w\\-_"
            },
            {
                "text": " ^([a-zA-"
            },
            {
                "text": " ^[a-zA-"
            },
            {
                "text": " [a-zA-Z"
            },
            {
                "text": " (at least one letter, one"
            },
            {
                "text": " (re.compile(r"
            },
            {
                "text": " r'\\b\\w+"
            },
            {
                "text": " (pattern, explanation)\n\n"
            },
            {
                "text": " ([a-zA-Z"
            },
            {
                "text": "\n@[a-zA"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.\nMatch examples:\n- \"4/1/2001\"\n- \"12/12/2001\"\n- \"55/5/3434\"\nNon-match examples:\n- \"1/1/01\"\n- \"12 Jan 01\"",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434",
            "1/1/1111",
            "2/2/2222",
            "23/3/3333",
            "11/11/1111",
            "1/1/1111",
            "30/30/3030",
            "55/5/5555",
            "5/55/5678",
            "12/12/1221",
            "55/44/4321"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001",
            "1/1/1",
            "2/2/22",
            "3/3/333",
            "5/5/55555",
            "44/444/4",
            "Oct 7 2002",
            "1007",
            "qwerty",
            "2020/2/2"
        ],
        "id": 13,
        "output": [
            {
                "text": " (\\d+)/(\\d+)/(\\d+)\n\nExercise 2:\nWrite your own RegEx to match strings that"
            },
            {
                "text": " \n(?<![0-9])[1-9]\\d{1,2}(?![0-"
            },
            {
                "text": " [a-z]\\d{1,3}[a-z] \\d{1,2}/\\d{"
            },
            {
                "text": " \\d{1,2}[\\/\\s\\d]{1,2}[\\/ \\d]{4}\n"
            },
            {
                "text": " /\\d{1,2}\\/\\d{1,2}\\/\\d{4}/g\n\nQ:"
            },
            {
                "text": " (.{1}[\\d])|([\\d]{2})[\\d]{4}$\nGenerate"
            },
            {
                "text": " ^[1-9]\\d{0,2}(?:\\/[1-9]\\d{0,2"
            },
            {
                "text": " [2][0-9]/[4][0-9]/0000\n\n```python\nimport re\nstrings ="
            },
            {
                "text": " (\\d\\d)/(\\d\\d)/(\\d\\d\\d)\n\n3. Write a regular expression for an"
            },
            {
                "text": " \"(?<Date>\\d{1,2}\\/\\d{1,2}\\/\\d{4})\"\n"
            }
        ]
    },
    {
        "expression": "^[1-5]$",
        "raw_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[12345]$.",
        "refined_prompt": "Matches a single digit between 1 and 5, inclusive. It will only match a single character that is exactly one of the digits 1, 2, 3, 4, or 5, and is the same as saying ^[12345]$.\nMatch examples:\n- \"1\"\n- \"3\"\n- \"4\"\nNon-match examples:\n- \"6\"\n- \"23\"",
        "matches": [
            "1",
            "3",
            "4",
            "2",
            "5"
        ],
        "non_matches": [
            "6",
            "23",
            "a",
            "12",
            "243",
            "562",
            "f324",
            "fvd",
            "-2",
            "7",
            "-1",
            "000"
        ],
        "id": 15,
        "output": [
            {
                "text": " ^0*[1-5][0-9]*$\n\nLecture Note: Using quantifiers to repeat match\n\nContents"
            },
            {
                "text": " \\b[1-9]\\b (where \\b is the word boundary)\nMatch the characters case-insensitive (Ignore case in"
            },
            {
                "text": " ^[1-5]$\n\n3. Use a non-capturing group to group the following text together, and also capture the start of"
            },
            {
                "text": " ^[1-4][0-9]\n\n2. Write a Regular Expression to match a sentence composed entirely of only uppercase letters or"
            },
            {
                "text": "^[1-9][0-9]?[1-9]$\n\n3. Write a regular expression that matches a specific phone number"
            },
            {
                "text": " ^[1-9][0-9]?$\n\n3. The. character: Anything except newline character. [^\\n]"
            },
            {
                "text": " \n ^[12345]$\n\nNote:\n  - ^ will only find matches at the start of a string. \n  -"
            },
            {
                "text": " ^[0-9](?!00)\\d$\n- Matches either the beginning of the string, a digit 0-9, or a digit"
            },
            {
                "text": " ^[12345]$\".\n\n## Exercise 3:\nCreate a Python function that takes a list of strings and generates a RegEx pattern that"
            },
            {
                "text": " ^[12345]*.\n\n7. Write a regular expression to capture all the text inside square brackets \"[]\".\nAnswer: \\[.*"
            }
        ]
    },
    {
        "expression": "^[12345]$",
        "raw_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.",
        "refined_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.\nMatch examples:\n- \"1\"\n- \"2\"\n- \"4\"\nNon-match examples:\n- \"6\"\n- \"-1\"",
        "matches": [
            "1",
            "2",
            "4",
            "3",
            "5"
        ],
        "non_matches": [
            "6",
            "-1",
            "abc",
            "-123",
            "234",
            "3nf@",
            "-312",
            "2546dgwre",
            "u09nKLJG FSL",
            "1-1-2",
            "dfg",
            "32542"
        ],
        "id": 16,
        "output": [
            {
                "text": " ^[-1-9][0-9]*$\n\nNow what, if you only wanted numbers between 0 and 9? Then you would have to use \\d instead: ^\\d\\d\\d\\d$, which means, match exactly eight characters between"
            },
            {
                "text": " ^[-]?[1-9]\\d*(?:[,-]\\d*[1-9]\\d*)*$\nGenerate a RegEx for this description. \nAnswer: ^[-]?\\d*(?:["
            },
            {
                "text": " [0-9]\n- \"a\"Generate a RegEx for this description. \nAnswer: [a-zA-Z]\n- \"ab\"\nGenerate a RegEx for this description.\nAnswer: [a-z]+\n-"
            },
            {
                "text": " (?<=m)(0[1-9]-)?m(?!(|$))\n\nExercise 2:\nDesign a pattern that matches any string in which all words are separated by an asterisk.\nExample:\n- \"My name* is Sam"
            },
            {
                "text": " ^[1-5]$ \n\n4. Write a RegEx to match all digits in a string. \n5. Write a RegEx to match all letters (case-insensitive) in a string. \n\nAnswers: \n4."
            },
            {
                "text": " ^[\\d+]{1,5}$.\n\nGreat job, everyone! You've learned a lot today about how to use patterns and expressions on a phone number with regular expressions. Remember, the only way to become a pro at using regular expressions is to practice"
            },
            {
                "text": " I want my code to find any number within this range.\n\nQ:\n\nHow to match non-integer characters?\n\nHow do I match every non-integer character of string \"1ab2c3d\" with regular expression in Python?\n\nA"
            },
            {
                "text": " ^[0-5].*$\n\n2. Use the character class to find all vowels in a provided string. \n\n```python\n# Solution 3\ntext = \"The quick brown fox jumps over the lazy dog\"\nvowels = re"
            },
            {
                "text": " ^[1-5]\n\nA:\n\nYou're trying to match a single digit between 1-5, and you're using two different methods.\nThe first is [1-5]; the second is ^. The first one will allow any character in the"
            },
            {
                "text": " The following is the valid regex: (?!^)(?:[1-5]+$)\n\n3. Write a Regex for a URL that only includes \".com\" and \".org\".\nAnswer: The following is the valid regex: (?=^[a"
            }
        ]
    },
    {
        "expression": "^[2-9]\\d{2}-\\d{3}-\\d{4}$",
        "raw_prompt": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.",
        "refined_prompt": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.\nMatch examples:\n- \"800-555-5555\"\n- \"333-444-5555\"\n- \"212-666-1234\"\nNon-match examples:\n- \"000-000-0000\"\n- \"123-456-7890\"",
        "matches": [
            "800-555-5555",
            "333-444-5555",
            "212-666-1234",
            "444-555-6666",
            "300-000-0000",
            "444-444-4444",
            "678-678-6789",
            "987-987-9876",
            "543-543-5678",
            "794-564-7456",
            "368-654-7568",
            "987-978-4732",
            "655-878-3664"
        ],
        "non_matches": [
            "000-000-0000",
            "123-456-7890",
            "2126661234",
            "549-234-253",
            "235235234",
            "9h09dh9",
            "000-000-0000",
            "111-111-1111",
            "u09nKLJG FSL",
            "adfa2",
            "222-222-22222",
            "123-456-7890"
        ],
        "id": 18,
        "output": [
            {
                "text": " [A-Z0-9]{2,10}-[0-9A-"
            },
            {
                "text": " \"((\\d{3})-(\\d{2})-(\\d{4}"
            },
            {
                "text": " \\d{3}-\\d{3}-\\d{4}\n\n"
            },
            {
                "text": " ^[A-Z]{2}[0-9]{3}-[0"
            },
            {
                "text": " The expression would be [A-Z]{3}-{3}-{4"
            },
            {
                "text": " ^(([2-9]{2})-([3-9]{2}"
            },
            {
                "text": " https://regex101.com/r/cRJ9fZ/1\n"
            },
            {
                "text": "\nr'^\\d{3}-\\d{3}-\\d{"
            },
            {
                "text": " \n\\d{3}-\\d{3}-\\d{4}"
            },
            {
                "text": "\n^\\d{3}-\\d{3}-\\d{4}"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "raw_prompt": "Domain names:\nThis regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in .com, .org, .net, .mil, or .edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.",
        "refined_prompt": "Match strings that start with one or more alphanumeric characters, hyphens, or dots, followed by a dot, and end with either \"com\", \"org\", \"net\", \"mil\", or \"edu\" (case insensitive). This is typically used to validate domain names.\nMatch examples:\n- \"3SquareBand.com\"\n- \"asp.net\"\n- \"army.mil\"\nNon-match examples:\n- \"$SquareBand.com\"\n- \"asp/dot.net\"",
        "matches": [
            "3SquareBand.com",
            "asp.net",
            "army.mil",
            "baidu.com",
            "google.com",
            "sustech.edu",
            "milion.mil",
            "brooklyn.net",
            "apple.com",
            "nd.edu",
            "abc.net",
            "zzz.edu",
            "notredame.com"
        ],
        "non_matches": [
            "$SquareBand.com",
            "asp/dot.net",
            "army.military",
            "adsfsafs.com.qer",
            "9injd23.net.abc",
            "a/b/c.com",
            "nd.education",
            "nd.computer",
            "github.abc",
            "com.edu.github",
            "@#$.com",
            "abcabc.abc"
        ],
        "id": 20,
        "output": [
            {
                "text": " \nMatch examples:\n-"
            },
            {
                "text": " [a-z0-9"
            },
            {
                "text": " \\d+\\.\\w{"
            },
            {
                "text": " \\..*$|(\\.)"
            },
            {
                "text": " To capture and match strings that start"
            },
            {
                "text": " [^a-z0-"
            },
            {
                "text": " \n(?i)(^"
            },
            {
                "text": "\n[a-zA-"
            },
            {
                "text": " [A-z][A-"
            },
            {
                "text": " (^[a-z\\"
            }
        ]
    },
    {
        "expression": "^(?=.*\\d).{4,8}$",
        "raw_prompt": "Password expression. Password must be between 4 and 8 digits long and include at least one numeric digit.",
        "refined_prompt": "Password expression. Password must be between 4 and 8 digits long and include at least one numeric digit.\nMatch examples:\n- \"1234\"\n- \"asdf1234\"\n- \"asp123\"\nNon-match examples:\n- \"asdf\"\n- \"asdf12345\"",
        "matches": [
            "1234",
            "asdf1234",
            "asp123",
            "09jio",
            "dfahui09",
            "ifjd9",
            "dsuui6",
            "34jio23",
            "1234567",
            "9jid33",
            "09jc",
            "nonum00",
            "a1b2c3"
        ],
        "non_matches": [
            "asdf",
            "asdf12345",
            "password",
            "oijsdfa000",
            "90jio09iomk",
            "123",
            "999",
            "4digitlong",
            "helloworld",
            "number",
            "abc111def",
            "8a8"
        ],
        "id": 25,
        "output": [
            {
                "text": " ^[a-zA-Z0-9_]*/[a-zA-Z0-9\\_]*/$ \n\nExercise 2: Write a Python script to check if a given password is correct. Password must"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[$])[a-zA-Z\\d$]{4,8}$\n\n"
            },
            {
                "text": " At least one numeric digit and not exactly 4 to 8 character long.\n\n4. Create a RegEx that matches email addresses, containing the following text format: FirstName.LastName@Domain.com [Extension]\n\nAnswer: ["
            },
            {
                "text": " (?<!.)\\d{4,8}\\b\n\nExercise 3:\nCreate a RegEx that matches all email addresses. Assume that email addresses consist of an alphanumeric string followed by an @ symbol, followed by a"
            },
            {
                "text": " ^(?=.{4,9}$)(?=\\d.*\\d)(?=\\d.*\\d)(?=\\d.*\\d)(?=\\d.*\\d)(?=\\d.*)\\d"
            },
            {
                "text": " ([0-9][-/!=]{3})+ \n\nExercise 4:\nWrite a Python script that takes the following text and uses regular expression to extract only IPs from the document. IPs must have the format \"xxx"
            },
            {
                "text": " (\\d\\)s+,?(\\d+)?(\\d\\s?)+\n\n3. Imagine you are building a website, which accepts usernames like \"@myusername%\" as emails, and validates them in one regex expression. Write"
            },
            {
                "text": " *(?=.*\\d)(?=.*[a-z])\\d{4,8}\n\nExample 5: Email address\nCreate a RegEx to validate email addresses.\nAnswer:\n[\\w\\.-]+@"
            },
            {
                "text": " \"^([a-zA-Z])([0-9])([a-zA-Z])$\" would be a good start, but I need the \"Generate a RegEx for this description.\" part of the assignment"
            },
            {
                "text": " [A-Za-z]{1,6}\\d{1,5}[A-Za-z0-9]\n\n\n# Chapter: The use of Python Matplotlib for Statistician\n\n## Section"
            }
        ]
    },
    {
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$",
        "raw_prompt": "Password matching expression. Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.",
        "refined_prompt": "Password matching expression. Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.\nMatch examples:\n- \"asD1\"\n- \"asDF1234\"\n- \"ASPgo123\"\nNon-match examples:\n- \"asdf\"\n- \"1234\"",
        "matches": [
            "asD1",
            "asDF1234",
            "ASPgo123",
            "Aa1Bb2",
            "sdafAF1",
            "FDS3fs",
            "111AAAa",
            "pokdfsA9",
            "FODISd8",
            "823FDSd",
            "j09FFF",
            "jso00QQ",
            "SD0dsff"
        ],
        "non_matches": [
            "asdf",
            "1234",
            "ASDF12345",
            "oinjoFW",
            "FWOEjinfw908",
            "lkkl0908",
            "AAAAAAA",
            "adfjsfk",
            "88888888",
            "Aa1",
            "BbBbBbBb2222",
            "0j0jweBBBB"
        ],
        "id": 26,
        "output": [
            {
                "text": " [ABD]{3}[A-ZA-Z0-9]{1,3}\n\nExercise 3: Identify the"
            },
            {
                "text": "\n[A-Z]{1,2}\\d[A-Z]{1,2}\\d[A-Z]{1,2"
            },
            {
                "text": " [\\d]{3}[A-Z]{1}\\d{3}\n\"\"\"\n\npattern = r'\\d{1,"
            },
            {
                "text": " _\n\n5. Create a program that prompts the user to enter a password. The program should store the password in a variable and validate it against the criteria"
            },
            {
                "text": "\n^(?=.*[A-Z].*)(?=.*[a-z].*)(?=.*\\d).{4,"
            },
            {
                "text": " ([A-Z]{1,2}[a-z]{3,4}[0-9]{1,2}).|"
            },
            {
                "text": " [^A-Za-z\\d]\n\nExercise 2: \nAdd a number to the non-match examples of exercise 1."
            },
            {
                "text": "\n\\A(?= [a-z]{1,2}[A-Z]{1,2}[0-9]{"
            },
            {
                "text": " At least 1 upper case letter, at least 1 lower case letter, and at least 1 numeric digit\n\n**Exercise 3:**\n\nCreate a"
            },
            {
                "text": " \"^.*[\\d][\\d]$\"\n\n2. Write a RegExp code to validate a credit card number. Credit card numbers can"
            }
        ]
    },
    {
        "expression": "^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$",
        "raw_prompt": "RegExp for validating the format of IP Addresses. This works great with the ASP.NET RegularExpressionValidator server control.",
        "refined_prompt": "Ensures that the string matches a valid IP address format, where each part of the address falls within the range of 0 to 255.\nMatch examples:\n- \"127.0.0.1\"\n- \"255.255.255.0\"\n- \"192.168.0.1\"\nNon-match examples:\n- \"1200.5.4.3\"\n- \"abc.def.ghi.jkl\"",
        "matches": [
            "127.0.0.1",
            "255.255.255.0",
            "192.168.0.1",
            "234.234.234.234",
            "1.1.1.1",
            "195.35.98.3",
            "5.5.5.5",
            "88.88.88.88",
            "38.68.64.123",
            "199.198.197.196",
            "123.124.125.126",
            "135.146.157.168",
            "53.24.34.67"
        ],
        "non_matches": [
            "1200.5.4.3",
            "abc.def.ghi.jkl",
            "255.foo.bar.1",
            "nd.nd.nd.nd",
            "123.456.789",
            "987.988.989",
            "carry",
            "12f3.21f3.213f",
            "9.9.9.9.9",
            "654.654.654",
            "g3.g543.g45",
            "0988.74534.5464"
        ],
        "id": 27,
        "output": [
            {
                "text": ".{1,6}\\.\n\n2. Regex to check if a string starts with"
            },
            {
                "text": " \\b\\d{1,3}\\.\\d{1,3}\\.\\d"
            },
            {
                "text": " r'^(([0-9]|1[0-9]|2[0"
            },
            {
                "text": " #(?<=\\d).*?(?=\\d)|#(?<"
            },
            {
                "text": " r\"^[0-9]{1,3}\\.[0-9]{1"
            },
            {
                "text": " \n(0|1?[0-9]{1,2})\\.[0"
            },
            {
                "text": " `^(([0-9\\.]+)\\.([0-9\\.]+)\\"
            },
            {
                "text": " Allow the use of subnet masks between numbers, and allow the use of the \".\" character to"
            },
            {
                "text": "\n\"\\d{1,3}\\.\\d{1,3}\\.\\d"
            },
            {
                "text": " [0-9]{1,3}\\.[0-9]{1,3}\\"
            }
        ]
    },
    {
        "expression": "^[\\w\\.=-]+@[\\w\\.-]+\\.[\\w]{2,3}$",
        "raw_prompt": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the .COM section.",
        "refined_prompt": "Starts with one or more word characters, dots, equal signs, or hyphens.\r\nFollowed by an @ symbol.\r\nFollowed by one or more word characters, dots, hyphens, or dots.\r\nFollowed by a dot (.)\r\nEnds with two or three word characters.\nMatch examples:\n- \"a@a.com\"\n- \"a@a.com.au\"\n- \"a@a.au\"\nNon-match examples:\n- \"word\"\n- \"word@\"",
        "matches": [
            "a@a.com",
            "a@a.com.au",
            "a@a.au",
            "abc@abc.abc",
            "baidu@qq.com",
            "qq@qq.com",
            "abc@ab.cn",
            "hi@nd.edu",
            "nd@edu.us",
            "us@nd.edu",
            "cse@nd.edu",
            "hello@hi.us",
            "abc@msft.org"
        ],
        "non_matches": [
            "word",
            "word@",
            "@word",
            "iasdjf@",
            "@09jafsd",
            "sdaf.FSD",
            "@@fsdfa.fsad",
            "09jfs@osifdj@sdf",
            "dsfl",
            "092j3d",
            "sda sad",
            "@sdaf@sdf123"
        ],
        "id": 34,
        "output": [
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": "Starts with one or more word characters, dots, equal signs, or hyphens.\r\nFollowed by an @ symbol.\r\nFollowed by one or more word characters, dots, hyphens, or dots.\r\nFollowed by a dot (.)\r\nEnds with two or three word characters.\nMatch examples:\n- \"a@a.com\"\n- \"a@a.com.au\"\n- \"a@a.au\"\nNon-match examples:\n- \"word\"\n- \"word@\"Generate a RegEx for this description. \nAnswer -"
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            }
        ]
    },
    {
        "expression": "^\\$[0-9]+(\\.[0-9][0-9])?$",
        "raw_prompt": "Validates a dollar amount including a dollar sign and 2 decmals. The decimal and cents are optional.",
        "refined_prompt": "Matches strings that start with a dollar sign, followed by one or more digits, and optionally followed by a dot and exactly two more digits representing the decimal part.\nMatch examples:\n- \"$1.50\"\n- \"$49\"\n- \"$0.50\"\nNon-match examples:\n- \"1.5\"\n- \"$1.333\"",
        "matches": [
            "$1.50",
            "$49",
            "$0.50",
            "$1",
            "$10",
            "$99.99",
            "$1.12",
            "$5.55",
            "$66.66",
            "$100",
            "$88",
            "$68",
            "$50.50"
        ],
        "non_matches": [
            "1.5",
            "$1.333",
            "this $5.12 fails",
            "$4.2",
            "234.634",
            "$23.454",
            "$3.2",
            "66.66",
            "#32.34",
            "$.23",
            "$345.605",
            "\u00a5423.34"
        ],
        "id": 36,
        "output": [
            {
                "text": " [0-9]{0,2}\\.[0-9]{2}\n\nExercise 2: Write a RegEx that matches a word that starts with a capital letter,"
            },
            {
                "text": "\n^\\$(\\d{1,3})\\.?(\\d{1,2})$\n\nExercise 3:\nWrite a Python code that imports the Regex module and"
            },
            {
                "text": " ^\\$?(\\d+\\.?\\d{1,2})\\d*\n\n4. Write a RegEx that matches strings that start with either \"the\", \"a"
            },
            {
                "text": " (?<=\\$)(\\d+(?:\\.\\d{2})?)\n\nUse RegEx to remove all URLs from a string. \nGiven the following string:"
            },
            {
                "text": " \\$\\d+\\.\\d{1,2}\n\n4. Match examples:\n- \"The quick brown fox jumped over the lazy dog\"\n- \"Hello, world"
            },
            {
                "text": " ^\\$(\\d{1,2}\\.)\\d{1,2}$\n\n4. What type of strings do the following RegEx match?\nExercise: Use"
            },
            {
                "text": "\n\nlet str = \"123.45%7899#123.45\";\nlet matchExpr = /^(\\$1\\d+\\.\\d{2})[^"
            },
            {
                "text": " \"[0-9]$.{2}\"\n- \"0.1*\"Generate a RegEx for this description. \nAnswer: \"0[1-9]\\."
            },
            {
                "text": " ^[0-9]?[0-9]\\.[0-9]\\d$\n\n4. Write a program that reads a file, and counts the number of lines"
            },
            {
                "text": " (\"\\$\\d+(\\.\\d{2})?$\")\n\n### Exercise 2: Find matches\nUse the regex from Exercise 1 to find all the matches in the following string"
            }
        ]
    },
    {
        "expression": "^([\\w\\d\\-\\.]+)@{1}(([\\w\\d\\-]{1,67})|([\\w\\d\\-]+\\.[\\w\\d\\-]{1,67}))\\.(([a-zA-Z\\d]{2,4})(\\.[a-zA-Z\\d]{2})?)$",
        "raw_prompt": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix (e.g. user@domain.123), simply delete the last two occurrences of &quot;\\d&quot;.",
        "refined_prompt": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo.foo.info\"\nNon-match examples:\n- \"foo@.com\"\n- \"foo@foo..com\"",
        "matches": [
            "foo@foo.com",
            "foo@foo-foo.com.au",
            "foo@foo.foo.info",
            "abc@abc.com",
            "fds@gad-agd.com.us",
            "bds@bfv.foo.info",
            "def@def.com",
            "foo@org-foo.org.au",
            "bop@foo.qre.info",
            "asd@fsa.com",
            "gad@afd.ghe.au",
            "hcs@bfq.foo.info",
            "gas@dfs-erw.org.au"
        ],
        "non_matches": [
            "foo@.com",
            "foo@foo..com",
            "foo@me@.com",
            "fasd@fds.fasd@",
            "fa0efj3@fs.FSDFr32@",
            "vsdfaslk..adsaf",
            "cfa@oifsd",
            "@R#@@#RDS",
            "fdssdf@FSD.fweoijF@",
            "fdsa.@FDS.@FD",
            "fdsf@@@fsdf",
            "gsfdoji@FDS"
        ],
        "id": 41,
        "output": [
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo-"
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo-"
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            }
        ]
    },
    {
        "expression": "^[0-9]+$",
        "raw_prompt": "Validate a string to see if it contains a number / integer",
        "refined_prompt": "Matches strings that consist entirely of one or more digits (0-9).\nMatch examples:\n- \"1234567890\"\n- \"4123109\"\n- \"53421\"\nNon-match examples:\n- \"f423\"\n- \"f34fvfv\"",
        "matches": [
            "1234567890",
            "4123109",
            "53421",
            "512345",
            "123451",
            "5123543",
            "12356",
            "9",
            "65409",
            "34905",
            "5436",
            "65409",
            "245309"
        ],
        "non_matches": [
            "f423",
            "f34fvfv",
            "34f2vf42e",
            "234.f23v425",
            "f2v3r",
            "f23r2",
            "2fre2",
            "vfre2fvre",
            "fer222r3",
            "erfv2",
            "2fe2vf",
            "2efr245"
        ],
        "id": 42,
        "output": [
            {
                "text": " [a-zA-Z]\\d+[a-zA-Z]\n\nExercise 3:\nWrite a RegEx pattern that matches any number of any character including any special characters (such as ',', '$',"
            },
            {
                "text": " \"f34f\\d*\"\n\nExercise 2:\nMatch these email addresses to their correct format.\nExample:\n\n123 Main St. Anytown, USA 12345-7890\n\nExample 1:\nA1@"
            },
            {
                "text": " \\d+\n\n3. Write a function that takes in a filename and returns True if the file contains any lines with a numeric code in them, and False otherwise.\nHint: Use a regular expression to match the numerical code in each line"
            },
            {
                "text": " A digit (\\d) consisting of \\+2-9 times\n3. Match strings that consist entirely of any of these characters (a-z, A-Z, 0-9, -, $, _, #, %, &"
            },
            {
                "text": " Match any string that contains only one or more digits.\n\n5. Write a RegEx for this description.\nMatch string if it contains the word \"spam\".\n\nAnswer: ^spam+$\n\nIn Python, we can"
            },
            {
                "text": " Matches if the input string is a 3-4 character string of digits where at least two letters are present to the left and at least one letter is present to the right.\n- \"f423\" doesn't match.\n- \"f34"
            },
            {
                "text": " \"^[0-9]*$\"\nExercise 5: \nHow can you apply an OR operator to a regular expression? Give an example with the help of a non-matches string.\nAnswer: To apply OR (OR"
            },
            {
                "text": " \n\\d{6}*\nThe \\d matches any digit (0-9)\nThe * quantifier indicates that there can be zero or more occurrences of the preceding regex. \nNote: this RegEx does not ensure that we"
            },
            {
                "text": "\n\\d{4,9}\n\n3. Match any one letter from a-z or A-Z.\nAnswer:\n\\w\n\n4. Match only lowercase letters.\nAnswer:\n[a-z]\n"
            },
            {
                "text": " The regex should be \"^[0-9][0-9][0-9][0-9].[0-9][0-9][0-9][0-9][0-9]$\"\n\nExercise 3"
            }
        ]
    },
    {
        "expression": "^.{4,8}$",
        "raw_prompt": "Matches any string between 4 and 8 characters in length. Limits the length of a string. Useful to add to password regular expressions.",
        "refined_prompt": "Matches any string between 4 and 8 characters in length. Limits the length of a string.\nMatch examples:\n- \"asdf\"\n- \"1234\"\n- \"asdf1234\"\nNon-match examples:\n- \"asd\"\n- \"123\"",
        "matches": [
            "asdf",
            "1234",
            "asdf1234",
            "adsji",
            "gj0q3",
            "f234f24",
            "2f43f",
            "432g2g",
            "g324",
            "g342g432",
            "g43g23y",
            "u7jj74",
            "j746t"
        ],
        "non_matches": [
            "asd",
            "123",
            "asdfe12345",
            "09u4ff2n3094",
            "23t4v90m2",
            "34",
            "2",
            "v",
            "2b3t2tb43",
            "t24b32tv43",
            "nu5624t3v",
            "j2v"
        ],
        "id": 45,
        "output": [
            {
                "text": " ^\\w{4,8}\\b\"\"\" \nresult = re.search(pattern, text)\nif result:\n    print (\"YES\")\nelse:\n    print (\"NO\")\n\n[Opening Theme Music]\n\nHost 1: Welcome"
            },
            {
                "text": " [^\\\\s]\"{1,4}.[^\\\\s]\"{1,4}[^\\\\s]\"{1,4}\"|\"{}\".\nAnswer: [^\\\\s)\"{1,4}\"+\n\n[Regular expression"
            },
            {
                "text": " ^.{4,8}$\n3. Write RegEx for this scenario.\nThe input looks like such: \n\"<address>\"\nThe email needs to follow these rules: [^<>]+, where < is the left margin, and > is"
            },
            {
                "text": " \\w{1,4}\\d{0,3}\n\n6. How can you use regex to find all words of 5 or fewer characters in a string?\nRegular Expression: Match any string with character length between 1 and 5.\nRegEx example:"
            },
            {
                "text": " ^(?=.{4,8})(?=.*[0-9])$\n\nExercise 2: \nWhat would be the difference between a positive lookahead and a positive lookbehind regex? \nAnswer: A positive lookahead matches the"
            },
            {
                "text": " [A-Z][a-z]+,\\d\n\nExercise 4. \nUse RegEx to replace all occurrences of \"foo\" with \"bar\" in the string, then print the result.\nAnswer: Replace all \"foo\" with \"bar"
            },
            {
                "text": " (6-10 lines in length, with some explanation inline)\n^(?P<h3>#)[^ \\t]{4}(?:[ \\t]{3}[^ \\t]*){2}$\n\nA:\n"
            },
            {
                "text": " [a-zA-Z0-9]{4,8}\n- Limit the length of a string using the max function and match a non-match example.\nAnswer: [^a-zA-Z0-9]{7}\n"
            },
            {
                "text": " (Any character)4-8, (Any character|DOT)4-8\nhttps://www.dzone.com/articles/using-java-regular-expressions-to-check-if-a-string-contains-a-certain"
            },
            {
                "text": "\n[a-zA-Z][a-zA-Z0-9]{3,}\n\nExercise 3: Matching and Replacing\nMatch any string that starts with \"hello\" and ends with \"!\"\nReplace any \"Hello"
            }
        ]
    },
    {
        "expression": "^\\d*$",
        "raw_prompt": "Accepts an unsigned integer number. Also matches empty strings.",
        "refined_prompt": "Accepts an unsigned integer number. Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"000\"\n- \"43\"\nNon-match examples:\n- \"asbc\"\n- \"-34\"",
        "matches": [
            "123",
            "000",
            "43",
            "435",
            "513",
            "651",
            "3416",
            "16",
            "6143",
            "643",
            "76",
            "876",
            "34"
        ],
        "non_matches": [
            "asbc",
            "-34",
            "3.1415",
            "f443",
            "2f43",
            "3.3",
            "-1",
            "25v3",
            "3425-13",
            "4352-5243254.",
            "gwerb",
            "32vt"
        ],
        "id": 46,
        "output": [
            {
                "text": " \n\\d+\n\n- \"2\"Does not match. \n\n- \"asdf$a\"Does not match. As it matches in the rightmost position in the left-hand side of the expression. Match if there is one or more digits followed by a non-digit. \n\n- \""
            },
            {
                "text": " \"^([0-9]+)|[^0-9](([0-9}]*))$\"\n\nTo include a pattern in an expression you use the backslash to escape the character it references:\n\\\\d for a digit\n\"\\\\d\" for a digit\n\\d for a digit\n"
            },
            {
                "text": " ^[a-zA-Z]\\\\d{0,5}$\n\nA:\n\nThe function is as follows:\n    var validPattern = /^\\d{1,5}-[0-9]*$/;\n\nA:\n\n^([0-9]|["
            },
            {
                "text": " [1-9][0-9][0-9]|[012][0-9] [012]{3} |[1]?[0-9]?[0-9][1-9][0]?[0-9]|[0-9]?[1-9]["
            },
            {
                "text": " (\\d)1(\\d{2}|\\d*)\\d{3}\nExplanation: \nCapture group 1: The first group matches 1 digit. Group 2: The second group matches 0 or more 2 digits. The third group matches 0 or more 3 digits.\n\nUpdate my answer to use"
            },
            {
                "text": " [a-zA-Z0-9][a-zA-Z0-9]*(-[a-zA-Z0-9][a-zA-Z0-9]*)?(\\.\\d+)?\nThe regex for. is optional. \n\nA:\n\n"
            },
            {
                "text": " \"^0[1-9]|[1-9][0-9]$\"\n\nAnswer:\nHere's a sample answer using regex:\n>>> import re\n>>> text = [\"123\", \"000\", \"43\", \"asbc\", \"-34\"]\n>>> pattern = re.compile(r"
            },
            {
                "text": "\n#^(([a-z]{0,2})([0-9]{0,2})([a-z]{0,2})([a-z])$\nCode used:\nimport re\npattern=re.compile(\"\\^([a-z]{0"
            },
            {
                "text": " ^[1-9]\\d{3}$\n\nI used this pattern to create the expression:\n^\\d{1,3}\\d\\d\\d$\n\nSo now that you have a pattern, you can match any number of characters that satisfies that pattern. So to match any 3 characters,"
            },
            {
                "text": " \"^[0-9]{1,6}$\"\n\n---\n\n## Section 9.3: String Searching\nThe search engine also needs to understand what you're searching for. Therefore, when asking a search engine for a particular word, the word must be formatted in a way that it is recognized by"
            }
        ]
    },
    {
        "expression": "^[-+]?\\d*$",
        "raw_prompt": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.",
        "refined_prompt": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"-123\"\n- \"+123\"\nNon-match examples:\n- \"abc\"\n- \"3.14159\"",
        "matches": [
            "123",
            "-123",
            "+123",
            "34091511",
            "+54",
            "-12314",
            "5134514",
            "-5243",
            "+4145",
            "35134",
            "-543",
            "+65",
            "5134513"
        ],
        "non_matches": [
            "abc",
            "3.14159",
            "-3.14159",
            "543.435",
            "432v",
            "43.v234",
            "1-1-1",
            "2v345234v",
            "22-423",
            "435.vwre-34",
            "44-6234",
            "+24-234.345"
        ],
        "id": 47,
        "output": [
            {
                "text": " (.*[0-9]+.*)\nThe regex in the brackets will match any string beginning with any number. In this case, a number can be 0-9 or a decimal fraction.\n- \"-\"\nGenerate a RegEx for this description"
            },
            {
                "text": " [0-9]\\.?[0-9]*\n\nExercise 2:\nGiven a string, find all the words that start and end with the same letter. Words in between are separated by only numbers, punctuation marks, and spaces."
            },
            {
                "text": "\nr\"[a-zA-Z]+-?[0-9]+[0-9.]+\"\n\nExercise 2:\nWrite a RegEx that matches email addresses of the form \"name@domain.com\" where \"name\""
            },
            {
                "text": " \"([^\\d_.-]+)?\"\n\nExercise 2:\nConsider this input string: \nstring = \"(123) 456-7890\"\nReplace some of the parentheses with asterisks (e.g., \"(0*"
            },
            {
                "text": "  ^\\d+(\\.\\d+)?$\n\nThis RegEx is pretty good and it will work. However, you can't write \"123\" as only the first character (or not for the case that it has multiple digits after it) so"
            },
            {
                "text": " (?<=\\+)([-]?\\d+(.\\d+)?(?:\\.\\d+)?|\\.\\d+)(?=\\+|$) - at least one digit and an optional point and up to 3"
            },
            {
                "text": "\n[-+]?\\d+(?:\\.\\d+)?\n\nGiving examples:\n- A website that takes in a phone number as input could use a regular expression to ensure that the phone number is entered in the correct format.\n- An"
            },
            {
                "text": " r\"[\\+-]?[0-9]([.][0-9]*[\\.])?([eE][+-]?[0-9]+)\"\n\nWrite and Submit your solution!\nMy solution:\nr'"
            },
            {
                "text": " \"([0-9\\-.]+)\"  \n2. Write a Python string to generate the following RegEx:\n\\d+.\\d+\nNon-match examples:\n- \"abc\"\nAnswer: \"([0-9]+)\\"
            },
            {
                "text": " \\d+\\.\\d+\n- \"foo\" Generate a RegEx for this description.\nAnswer: ^(?!.*foo$).*\n- \"12 abc. 123\" Generate a RegEx for this description.\nAnswer:"
            }
        ]
    },
    {
        "expression": "^\\d*\\.?\\d*$",
        "raw_prompt": "Matches any unsigned floating point number/numeric string. Also matches empty strings.",
        "refined_prompt": "Matches any unsigned floating point number/numeric string. Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \".234\"\nNon-match examples:\n- \"abc\"\n- \"-3.14159\"",
        "matches": [
            "123",
            "3.14159",
            ".234",
            "354.5342",
            "654.435",
            "6254.2345",
            "543",
            "2345",
            "3465",
            "7542",
            "6254.4526",
            "742",
            "7225464526"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2",
            "b5242g",
            "f45.2g",
            "b254yb54.254yb",
            "2y45.y245",
            "254627g.256",
            "-2.22",
            "3g54",
            "-652.63264",
            "3yb43yb5"
        ],
        "id": 48,
        "output": [
            {
                "text": " \npublic class MatchExample {\n    \n    public static void main(String[] args) {\n        \n    String regex = \"^\\\\d+\\\\.?\\\\d+$\";\n    Scanner userInput = new Scanner(System.in);\n    "
            },
            {
                "text": " [a-zA-Z0-9._-]+\n6. Match any English string, but no punctuation, uppercase or lowercase letters or numbers.\nGenerate a RegEx for this description. \nAnswer: [A-Za-z"
            },
            {
                "text": " My answer would be \"(\\\\d+\\\\.\\\\d+)|([-\\\\d\\\\.]+)\")\n5. Match any digit from 0 to 4, inclusive\n\"1-1-1-5-4-3-2\"\nDo your own work to complete"
            },
            {
                "text": " \\.[0-9]*(\\.\\.[0-9]+)?\n\nA:\n\nThis is pretty good.  I would be more explicit about the number of decimal digits you want to have, so if you say \"2.3\", it would then only"
            },
            {
                "text": " ^\\d+\\.\\d+$ (the dot can be any number of any character)\n[a-z] (the alphanumeric chars set)\n(a-zA-Z[0-9]) (The alphanumeric character as part of another"
            },
            {
                "text": "\n[^0-9.,+-]\n\nExercise 2: Write a Python script that takes in a string from the user and matches any text in titlecase (i.e., The Big Bang Theory). Write the RegEx to match the pattern.\nAnswer:"
            },
            {
                "text": "\n#! /usr/bin/python3\nimport re\nfrom itertools import combinations_with_replacement\nfrom math import factorial\n\ndef all_permutation_strings(digits):\n    letters = string.ascii_lowercase\n"
            },
            {
                "text": " ^[\\d\\.][a-zA-Z]*$\n\nA:\n\nIf you have to do it with regex, first try to write a function that takes two inputs a and b and returns a regex for either matching a or b. Then you take"
            },
            {
                "text": " .*(?<!\\d)\\.(?!\\d)\nTo allow whitespace only between each number or any number and the dot, add \\.\\s\n\n[\\d\\-\\. ]*(?<!\\d)\\.(?!\\d)\n"
            },
            {
                "text": " [0-9](\\\\.[0-9]*)? [a-zA-Z]-?\n\nThis is what I got so far. Does anyone find a more elegant way to accomplish it?\nclass CString(Value):\n    cString = RegEx"
            }
        ]
    },
    {
        "expression": "^([0-9]( |-)?)?(\\(?[0-9]{3}\\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$",
        "raw_prompt": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.",
        "refined_prompt": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.\nMatch examples:\n- \"1-(123)-123-1234\"\n- \"123 123 1234\"\n- \"1-800-ALPHNUM\"\nNon-match examples:\n- \"1.123.123.1234\"\n- \"(123)-1234-123\"",
        "matches": [
            "1-(123)-123-1234",
            "123 123 1234",
            "1-800-ALPHNUM",
            "258 426 6254",
            "1-(531)-123-5435",
            "258 426 5131",
            "1-(123)-754-7517",
            "1-846-ALPHNUM",
            "653 426 5431",
            "1-(866)-123-8648",
            "1-653-ALPHNUM",
            "534 643 6254",
            "258 426 7635"
        ],
        "non_matches": [
            "1.123.123.1234",
            "(123)-1234-123",
            "123-1234",
            "546",
            "1324.1541",
            "f234f23",
            "56",
            "4562452642562456",
            "541543.415",
            "4325265426624",
            "654",
            "4351.1345"
        ],
        "id": 53,
        "output": [
            {
                "text": " \"^[\\d.+"
            },
            {
                "text": " (\\d[-.\\s"
            },
            {
                "text": "\n[0-9]+\\."
            },
            {
                "text": "\n(\\\\d)|(\\\\"
            },
            {
                "text": "\n.*[0-9]"
            },
            {
                "text": " \n\"(\\(\\d+"
            },
            {
                "text": "\n\"([0-9]"
            },
            {
                "text": " /^\\(\\d{3"
            },
            {
                "text": " (^[0-9]"
            },
            {
                "text": " \"(\\d{3})-"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM",
        "refined_prompt": "Matches a string if it is a valid time in the format of HH:MM\nMatch examples:\n- \"02:04\"\n- \"16:56\"\n- \"23:59\"\nNon-match examples:\n- \"02:00 PM\"\n- \"PM2:00\"",
        "matches": [
            "02:04",
            "16:56",
            "23:59",
            "15:42",
            "15:34",
            "16:43",
            "06:54",
            "05:25",
            "05:23",
            "07:52",
            "06:24",
            "03:53",
            "03:27"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00",
            "71:543t4",
            "51:534",
            "75:62",
            "86:75",
            "48:345",
            "57:73",
            "2am",
            "4pm",
            "253@#RFE"
        ],
        "id": 54,
        "output": [
            {
                "text": " [^A-Za-z][A-Z][[:alpha:]]{1,15}[:punctuation:]{0,1}$\n\nExercise 5:\nUse the pattern generated in Exercise 4 and write"
            },
            {
                "text": "\n\\d\\d:\\d\\d(A|P)M \n\n2. Write a RegEx that matches all the text that has an even number of characters except for the first and last.\nMatch examples:\n- \"Python"
            },
            {
                "text": " This will match only valid times in the format of HH:MM, but not AM or PM, and will not match times that are less than 00:00.\n```python\nimport re\n\ntext = 'The sunrise was at 06:"
            },
            {
                "text": " \"^\\d{2}:?\\d{2}(a\\.m|p\\.m)$\"\n\n4. Write a RegEx that matches all of the following IP addresses\nMatch examples: \n- \"192.168"
            },
            {
                "text": " \\b(?i)^(\\d{1,2}):(\\d{2})( am| pm)?$\n\n5. Give examples of how a regular expression could be used to validate credit card numbers.\nAnswer: A credit"
            },
            {
                "text": "^(0?[1-9])\\d:(0?[1-9])\\d:[0-5][0-9]$\n\n9. Exercise 1: \nUse regular expressions to validate a password (3-10"
            },
            {
                "text": " ^\\d{1,2}:?\\d{2}$\n\n2. Use a regular expression with a capturing group to extract the first name and last name from a string, separated by a colon.\n- Use the regular expression \"("
            },
            {
                "text": " /^(0\\d|1[01]):[0-5]?[0-9]?$/.\n\nExercise 4.1.2\na) \"08:21 PM\"\nb) \"24:01"
            },
            {
                "text": " time_regex = r\"(\\d{2}):(\\d{2})?(AM|PM)\"\n\nLecture Note: How to Use Lookahead and Lookbehind Assertions with RegEx\n\nIn this section"
            },
            {
                "text": " (0-3)([0-3]):([0-3])([0-9])\n\nExercise 3: Find the longest common subsequence between two strings. Two strings are valid if\ntheir LCS is empty or occurs as"
            }
        ]
    },
    {
        "expression": "^\\s*[a-zA-Z,\\s]+\\s*$",
        "raw_prompt": "Any Expression Upper/Lower Case, with commas and space between the text, with any amount of space before or after",
        "refined_prompt": "Match strings that consist of alphabetic characters (both lowercase and uppercase) and commas, allowing for leading and trailing whitespace.\nMatch examples:\n- \"Smith, Ed\"\n- \"Ed Smith\"\n- \"aBcDeFgH\"\nNon-match examples:\n- \"a123\"\n- \"AB5\"",
        "matches": [
            "Smith, Ed",
            "Ed Smith",
            "aBcDeFgH",
            "Michael afds",
            "fnsdkajf",
            "Hello world",
            "asdfafds adsf",
            "afdsffda asddas",
            "fads, asdf",
            "sda, fasf",
            "EFDSF, FSD",
            "fasdf, FDS",
            "FDSfdso JDSF"
        ],
        "non_matches": [
            "a123",
            "AB5",
            "Mr. Ed",
            "vqvq.ecqw",
            "cqrewcr/qtv",
            "fqsdv$vw",
            "@#dfkjnav",
            "2546dgwre",
            "u09nKLJG FSL",
            "1-1-2",
            "34.31",
            "32542"
        ],
        "id": 57,
        "output": [
            {
                "text": "  ^([a-zA-Z ]+,)*[a-zA-Z ]+$\n- \"a,b,c,d\"\n- \"AB,B"
            },
            {
                "text": " ^[a-zA-Z ]+,[a-zA-Z0-9]+$.\n\n\n\nQuestion 8: A triangle has a base length of 10 centimeters"
            },
            {
                "text": "\nr\":[a-zA-Z\\s]*,[a-zA-Z]*\"\n\nExercise 5: Search for a list of allowed phrases in a text"
            },
            {
                "text": " (a|b)-[A-Za-z]{1,3}, or \"(?=([a-z]))[A-Za-z]{0,"
            },
            {
                "text": " (a)|([A-Z][a-z]+)\n\n10.2.3 The regular expression delimiter: DOT(LIMIT) or DOT (MAX LENGTH"
            },
            {
                "text": " ^[a-zA-Z ]{1,63}\\, [a-zA-Z ]{1,63}$\n\nExercise #2: Create a Python"
            },
            {
                "text": " Regex =.*?\\\\s(.*)\\\\s?(.*)\\\\s*`\nHint: Use a character set to match alphabetic characters and the *?"
            },
            {
                "text": " \n/^\\w+, \\w+$/;\n\nExercise 2:\nCreate a RegEx pattern that matches any number of upper-cased letters and a number of"
            },
            {
                "text": " (a\\w?)+\n\n5. Write a RegEx to match all email addresses, both local and global. Use both.+ and.? to allow for empty strings.\n"
            },
            {
                "text": " (?<![a-zA-Z],[a-zA-Z0-9,])[a-zA-Z0-9]+\n\n\n\nIn"
            }
        ]
    },
    {
        "expression": "^\\d{5}(-\\d{4})?$",
        "raw_prompt": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.",
        "refined_prompt": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.\nMatch examples:\n- \"48222\"\n- \"48222-1746\"\n- \"51314\"\nNon-match examples:\n- \"4632\"\n- \"Blake\"",
        "matches": [
            "48222",
            "48222-1746",
            "51314",
            "61341",
            "64316",
            "43534",
            "46556",
            "54315-1634",
            "64316-1643",
            "74567-2456",
            "26543-2664",
            "27563",
            "57422"
        ],
        "non_matches": [
            "4632",
            "Blake",
            "37333-32",
            "4235",
            "543161435",
            "1543543",
            "15436131",
            "1534513",
            "4351-345151",
            "13451534-514351",
            "3415-34564",
            "3461-436643"
        ],
        "id": 68,
        "output": [
            {
                "text": " You can use \\d{4}\\-\\d{3} to match a standard 5 digit US zip code as a regular expression.\nExercise 2:\nFind matches for this pattern:\nhttps://www.bbc.com/news/world-football-"
            },
            {
                "text": " [A5-I7]\n- Create a RegEx for this email address. Note that US addresses are usually in the format of firstname.lastname, so the first part can be matched using the [A-Za-z] character, and then the"
            },
            {
                "text": " [^0-9-]\n\n4. Write a RegEx to match all dates in the format DD/MM/YYYY.\nAnswer: [0-9]{2}/[0-9]{2}/[0-9]{"
            },
            {
                "text": " [^0-9] | [0-5][0-9][^0-9] | [0-9][^0-9]{3}\n\n7. Give examples, one for each of the following domains (e.g., email,"
            },
            {
                "text": " A few possible regex might be '^\\d+-\\d+', where you replace '^' and '+' to the first digit of your first group, and the second digit of your second group as the second group.\n\n2. Create a regular expression"
            },
            {
                "text": " You should use the word boundary \"\\\\b\" to specify that the letter must be surrounded by both a and b.\n\n(2) Exercise: Match these phone numbers from a sample string.\nSample string: \"Call me at 9999-1234 or 123-"
            },
            {
                "text": " It should include the word for each field (number and area code) with exactly 2 digits. \n\nExercise 5:\nProvide an example of a real-world use case for generating a RegExp that matches US ZIP + 4 Standard Zip Codes.\nAnswer:"
            },
            {
                "text": " [^0-9]*\\d{0,3}\\-[0-9]\n\n3. Match any of the following numbers (both standard and non-standard): 02040, 65432, 02468, 01234, 0123, 1"
            },
            {
                "text": " A RegEx for this description could be \"^[A-Z]4 [0-9]{6}$\", or \"-[A-Z].{3}-[0-9]{3}-4$\".\n\n\n\nIntroduction:\n\n"
            },
            {
                "text": " (regex pattern with [a-zA-z0-9-_]+) (examples).\n\n4. Generate a RegEx that searches for any words that are at least 5 characters long, and have an even number of characters.\nUse a"
            }
        ]
    },
    {
        "expression": "(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",
        "raw_prompt": "Regular expression to evaluate dutch-style phone numbers. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\nfollowed by 9 numbers (which can contain a space or -).",
        "refined_prompt": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n- \"+3123525667788999\"\n- \"3123525667788\"",
        "matches": [
            "+31235256677",
            "+31(0)235256677",
            "023-5256677",
            "+31235248394",
            "+31235256839",
            "+31(0)235256839",
            "+31(0)267395867",
            "+31(0)235259495",
            "+31(0)573956677",
            "023-5255729",
            "023-5268277",
            "023-5583757",
            "023-5839583"
        ],
        "non_matches": [
            "+3123525667788999",
            "3123525667788",
            "232-2566778",
            "09827509480193284014",
            "9845092820459524-2435234",
            "2435-435",
            "2345-652",
            "23fu490n",
            "243.2543",
            "+354+534",
            "5334.435",
            "++63453.345"
        ],
        "id": 69,
        "output": [
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples: \""
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:  "
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples: 123"
            }
        ]
    },
    {
        "expression": "^\\d{9}[\\d|X]$",
        "raw_prompt": "A very simple ISBN validation expression - it just checks for a 10 digit number where the last digit could also be a capital 'X'. Complete specs for ISBN available here:\nhttp://www.isbn.org/standards/home/isbn/international/html/usm4.htm. An enhancement would be to allow exactly 3 or 0 hyphens or 3 or 0 spaces, since these are also valid formats.",
        "refined_prompt": "Checks for a 10 digit number where the last digit could also be a capital 'X'.\nMatch examples:\n- \"1234123412\"\n- \"123412341X\"\n- \"4738195735\"\nNon-match examples:\n- \"not an isbn\"\n- \"54390853\"",
        "matches": [
            "1234123412",
            "123412341X",
            "4738195735",
            "4582943285",
            "5284574935",
            "5243524396",
            "5930285928",
            "5534098534",
            "620598320X",
            "534809534X",
            "123141414X",
            "432423432X",
            "502498905X"
        ],
        "non_matches": [
            "not an isbn",
            "54390853",
            "53495083409x",
            "452093xx",
            "534985309XX",
            "24309X",
            "098423098029840293",
            "4029384230980980X",
            "9vu82i3nuif",
            "423890jidofs",
            "2398ufsd",
            "893420980)U(X"
        ],
        "id": 73,
        "output": [
            {
                "text": " 1-4 a-z, 0-9 digits, '.' char exactly 1 times.\n2. Write a Python function that takes a string and prints True if the string is a valid ISBN9 number."
            },
            {
                "text": " \\d{10} - 10 digits\n\nAs I am new to regular expressions, I am not quite certain how I will approach this task. I know I need to use the. character to represent any character"
            },
            {
                "text": " \nimport re\ndef isbn_valid(nbr):\n  validation = \"\\d\\d\\d-?\\d\\d\\d-?\\d\\d-?\\d"
            },
            {
                "text": "\nr'^[A-Z]?[1-9][0-9]{9}\\b'\nI used the RegEx \"r'^[A-Z]?[1-"
            },
            {
                "text": " (not case sensitive) (the last digit should be not not an or not an is or X and not not is nor is not \n- \"not an ISBN\"\n- \"not an 8 digit number"
            },
            {
                "text": " \"[^a-z0-9]\",\n\"\\d[^a-z0-9]*\"\n\"\"\"\n\nimport re\n\ndef non_matching(string):\n    "
            },
            {
                "text": " (12[3-9]|1[0-2])(\\d|X){8,}(?!0[2])\n\nHow to solve this:\nfunction isValid(string)"
            },
            {
                "text": " \"^(0|[1-9][0-9][0-9][0-9]|1[0-9]{3}|[1-9][0-9]0"
            },
            {
                "text": " \n\nimport re\ndef find_bingo(str_input):\n    m = re.search(\"[13579]{10}([A-Z]|[1-9]|"
            },
            {
                "text": " \\d{10}\\d{9}\\d{8}\\d{7}\\d{6}\\d{5}\\d{4}\\d{3}\\d{2}\\d{1}\\dX"
            }
        ]
    },
    {
        "expression": "^(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))\\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$",
        "raw_prompt": "Dates\nday: d or dd, &lt;= 31,\nmonth: m or mm, &lt;= 12,\nyear: yy or yyyy &gt;= 1900, &lt;= 2099",
        "refined_prompt": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"",
        "matches": [
            "01/01/2001",
            "1/1/1999",
            "10/20/2080",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006"
        ],
        "non_matches": [
            "13/01/2001",
            "1/1/1800",
            "10/32/2080",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 74,
        "output": [
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generating"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generates"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generator"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generating"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            }
        ]
    },
    {
        "expression": "^\\d*\\.?((25)|(50)|(5)|(75)|(0)|(00))?$",
        "raw_prompt": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok !!",
        "refined_prompt": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It also match for nothing after decimal or even without decimal point.\nMatch examples:\n- \"0.25\"\n- \".75\"\n- \"123.50\"\nNon-match examples:\n- \".77\"\n- \"1.435\"",
        "matches": [
            "0.25",
            ".75",
            "123.50",
            "45091674723.",
            "15584775298650162922847293711339482454366793954997125",
            "9882085266649734497491.5",
            "7268907166939050834340423712961385078969.50",
            "870674387058196172857063",
            "339138741572321245.75",
            "652119432575.",
            "654232119475.",
            "652119475.25",
            "652432119475.50"
        ],
        "non_matches": [
            ".77",
            "1.435",
            "3.13",
            "3124.324",
            "423.52",
            "312.452",
            "423.4234.243",
            "54.32",
            "3124.5242",
            "542.134",
            "542.423",
            "534.342435"
        ],
        "id": 75,
        "output": [
            {
                "text": " (.*)(\\.\\d)?\n\n2. You're required to implement a program in Java\nWhat is the shortest way to validate a user's input whether it is a"
            },
            {
                "text": "\\d+\\.[\\d]*[05](\\d*)?|\\d+\\.([^0-9]|$)\n- \\b(\\"
            },
            {
                "text": " ^([0-9]{1,2}[.])(25)(50)(75)(0|00)[0-9]*$\n\nQuestion 2:\n"
            },
            {
                "text": " 0$|25000?0[1-9][0-9][0-9]$|[1-9][0-9][0-9]$"
            },
            {
                "text": "\n(?!\\.[0-9]*)([0-9]*[.][0-9]*[0-9]*|100[.]["
            },
            {
                "text": " \\d*(\\.\\d{1,2})?[2550]\n\nCode example\n```\nfrom typing import List\nimport re\n\n#gener"
            },
            {
                "text": "\n.(\\d{0,2})\\.(25|50|75|0|00|\\.){3}\n\n- [A-Z]{3"
            },
            {
                "text": " (\\\\d\\.\\d)\\b\n\nExercise 5:\nCreate a RegEx pattern that matches a string that begins with a number '123' followed by a space"
            },
            {
                "text": " This is a pattern to search and verify that a decimal number ends exactly with a 25, 50, 75, 0 or 00. It also match for nothing after decimal or even without"
            },
            {
                "text": " (?:\\d+\\.\\d{0}50\\.\\d{0}75\\.\\d{0})+$\n\n3. Replace examples -\n-"
            }
        ]
    },
    {
        "expression": "^(\\d{5}-\\d{4}|\\d{5})$|^([a-zA-Z]\\d[a-zA-Z] \\d[a-zA-Z]\\d)$",
        "raw_prompt": "This is a modification of the zip code regular expression submitted by Steven Smith (ssmith@aspalliance.com)\nIt no longer matches 78754-12aA",
        "refined_prompt": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12aA\"\n- \"7875A\"",
        "matches": [
            "78754",
            "78754-1234",
            "G3H 6A3",
            "c3s 0Z1",
            "69402-6689",
            "Y1R 9B0",
            "V5l 2G4",
            "00176",
            "21458",
            "86175-8760",
            "20021-5752",
            "D7b 2j3",
            "89926"
        ],
        "non_matches": [
            "78754-12aA",
            "7875A",
            "g3h6a3",
            "42324-412342",
            "3c12-12334f2",
            "vrf2-v32v4",
            "32",
            "verw2v-4v",
            "4234",
            "v43-v34v3v",
            "f34-f43rv",
            "5345-43534"
        ],
        "id": 80,
        "output": [
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-xy"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-XY"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-abc"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-2"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-123"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-s"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-A"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{1,2}[0-9A-Za-z]{1,2}[ ]?[0-9]{0,1}[A-Za-z]{2}$",
        "raw_prompt": "This regular expression can be used to validate UK postcodes. Especially useful if want to provide a client side validation on a web site.",
        "refined_prompt": "This regular expression is used to validate codes with a specific format(UK postcodes), where the code starts with 1 to 2 letters, followed by 1 to 2 alphanumeric characters, an optional space, 0 to 1 digit, and ends with exactly 2 letters.\nMatch examples:\n- \"SW112LE\"\n- \"SW11 2LE\"\n- \"CR05LE\"\nNon-match examples:\n- \"12CR0LE\"\n- \"12CR 0LE\"",
        "matches": [
            "SW112LE",
            "SW11 2LE",
            "CR05LE",
            "AL52zp",
            "gW 0bY",
            "gRc7Fg",
            "Cah0UE",
            "VEz RE",
            "Jc2IW",
            "M2G1on",
            "CYD bL",
            "dSH4 6kM",
            "RZ8Vn"
        ],
        "non_matches": [
            "12CR0LE",
            "12CR 0LE",
            "SWLE05",
            "2534",
            "511235",
            "6134",
            "FSSC VDVQWER4154",
            "21V3D1FV14VF",
            "F1FV13F4",
            "V34FGB45345",
            "AFDS23",
            "DVS2"
        ],
        "id": 84,
        "output": [
            {
                "text": ".{0,2}[a-zA-Z00"
            },
            {
                "text": " The pattern should be: ^[0-9]{2}"
            },
            {
                "text": " ^(\\w{1,2}\\s)?(\\w+ \\"
            },
            {
                "text": " \\b[A-Z]{1,2}[0"
            },
            {
                "text": " ^[A-Z]{1,2} [0-"
            },
            {
                "text": "\n \\b[A-Z]{1,2}\\d"
            },
            {
                "text": " [a-zA-Z]{1}\\d[a"
            },
            {
                "text": " ^[a-zA-Z]\\\\d\\\\s?"
            },
            {
                "text": " (\\d?[A-Y ]?\\d?)\n"
            },
            {
                "text": " ([A-Z][A-Z\\d]{0,"
            }
        ]
    },
    {
        "expression": "20\\d{2}(-|\\/)((0[1-9])|(1[0-2]))(-|\\/)((0[1-9])|([1-2][0-9])|(3[0-1]))(T|\\s)(([0-1][0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])",
        "raw_prompt": "Sql date format tester.",
        "refined_prompt": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"2000-13-31T00:00:00\"\n- \"2002/02/33 24:00:00\"",
        "matches": [
            "2099-12-31T23:59:59",
            "2002/02/09 16:30:00",
            "2000-01-01T00:00:00",
            "2052/10-16T09:09:10",
            "2041-10/30\u200823:21:00",
            "2047/11-04T23:40:42",
            "2041/09-04\u205f03:05:18",
            "2067-10/31 10:12:42",
            "2033-10/31 18:12:50",
            "2053-10/19T01:37:06",
            "2002-11-13\u202809:52:58",
            "2045-07/31T08:19:50",
            "2084-08/25T22:13:40"
        ],
        "non_matches": [
            "2000-13-31T00:00:00",
            "2002/02/33 24:00:00",
            "2000-01-01 60:00:00",
            "2084-08/25T98:13:40",
            "2002/02/33 24:45:00",
            "24323/02/33 24:00:00",
            "2002/02/343 24:00:00",
            "//::Gfsdfh9832",
            "2000-01-01 60:99:99",
            "2000-13-31T00:904829:00",
            "2000-100-01 60:00:00",
            "2000-01-100 60:00:00"
        ],
        "id": 86,
        "output": [
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"2000"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"1991"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"2000"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"202"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"202"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"2000"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"1999"
            }
        ]
    },
    {
        "expression": "^\\d{4}[\\-\\/\\s]?((((0[13578])|(1[02]))[\\-\\/\\s]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\-\\/\\s]?(([0-2][0-9])|(30)))|(02[\\-\\/\\s]?[0-2][0-9]))$",
        "raw_prompt": "- validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date\n- makes sure day is within valid range for the month\n- does NOT validate Feb. 29 on a leap year, only that Feb. CAN have 29 days",
        "refined_prompt": "- validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date\r\n- makes sure day is within valid range for the month\r\n- does NOT validate Feb. 29 on a leap year, only that Feb. CAN have 29 days\nMatch examples:\n- \"0001-12-31\"\n- \"9999 09 30\"\n- \"2002/03/03\"\nNon-match examples:\n- \"0001\\02\\30\"\n- \"9999.15.01\"",
        "matches": [
            "0001-12-31",
            "9999 09 30",
            "2002/03/03",
            "7518\u205f0814",
            "46650831",
            "3886\u200609\u00a011",
            "005002-10",
            "21101214",
            "941211/09",
            "5625\u20060227",
            "1538 02 04",
            "5043 0618",
            "39270910"
        ],
        "non_matches": [
            "0001\\02\\30",
            "9999.15.01",
            "2002/3/3",
            "39270910243",
            "234/423/5243",
            "21/53/52353",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 87,
        "output": [
            {
                "text": " \""
            },
            {
                "text": " ["
            },
            {
                "text": " |"
            },
            {
                "text": " ["
            },
            {
                "text": " ("
            },
            {
                "text": " ("
            },
            {
                "text": " ["
            },
            {
                "text": " ("
            },
            {
                "text": " ^"
            },
            {
                "text": " ["
            }
        ]
    },
    {
        "expression": "^(1?(-?\\d{3})-?)?(\\d{3})(-?\\d{4})$",
        "raw_prompt": "US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens.",
        "refined_prompt": "US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens.\nMatch examples:\n- \"15615552323\"\n- \"1-561-555-1212\"\n- \"5613333\"\nNon-match examples:\n- \"1-555-5555\"\n- \"15553333\"",
        "matches": [
            "15615552323",
            "1-561-555-1212",
            "5613333",
            "891-0191149",
            "4662065",
            "329-6361",
            "277-9964574",
            "882-6119",
            "1-044788-3245",
            "5383738",
            "174-2712",
            "1-639-3507476",
            "722-0291"
        ],
        "non_matches": [
            "1-555-5555",
            "15553333",
            "0-561-555-1212",
            "423142",
            "412",
            "13451435",
            "143534551",
            "164351345134",
            "BG323T",
            "wrtb",
            "4fc34f",
            "---1--1--12-3-4"
        ],
        "id": 89,
        "output": [
            {
                "text": " (\\\\d)(-\\\\d{1,6}(?:\\s|$)){5,7}\n\n# Exercise 3:\n\nCreate a Regular Expression to Match US Zip Codes with"
            },
            {
                "text": " *\\d(1)??[-\\d\\d]\\d{3}[-\\d\\d]\\d{3}*\n\n\n\nQuestion 2:\nIn 2014"
            },
            {
                "text": " The RegEx should be \"(^[\\d]{3,7}-)\\d{3,10}(\\d{1,2}|-)\\d{3,10}$\""
            },
            {
                "text": "\n- \"(-?\\d{7,11})-(\\d{3}{3})-(\\d{4})-(\\d{2})-(\\d{4})\"\n- \"("
            },
            {
                "text": " Match any 9 digits, and a hyphen (-) as a separator.\n\n#### Exercise 2:\nCreate a regular expression for matching a phone number composed of exactly 20 digits separated by exactly 4 spaces"
            },
            {
                "text": " RegExp(\"([0-9]+)[-]([0-9]+)[-]([0-9]+)\")\n\n\n\nChapter 7: Charts and Skills\n\nIn"
            },
            {
                "text": "\n(?<![-\\w.])(\\d{10,11}[-\\w.]?)\n\n5.Exercise: \nMatch this RegEx to the given description."
            },
            {
                "text": " [(1\\b)?([012][0-9a-z-]{0,7}\\b)(0?[1-9][0-9]{1,2})] \n"
            },
            {
                "text": " \"(?<![1-9\\d])(0-9)\\d{9}(?![1-9])\"\n\nExercise 3: \nMatch Examples:\n- \""
            },
            {
                "text": " (^|\\d)\\d{2}\\-\\d{3}\\-\\d{4}$\n\nExercise 3: Write a RegEx pattern that can match an IP address that consists"
            }
        ]
    },
    {
        "expression": "([a-zA-Z]:(\\\\w+)*\\\\[a-zA-Z0_9]+)?.xls",
        "raw_prompt": "This RegEx will help to validate a physical file path with a specific file extension (here xls)",
        "refined_prompt": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "E:\\DyAGT\\SD01A_specV2.xls",
            "E:\\DyAGT\\23FD.xls",
            "C:\\DyAGT\\VF2FV.xls",
            "C:\\F23V\\SD01A_specV2.xls",
            "C:\\DyAGT\\F32V.xls",
            "F:\\F23V\\SD01A_specV2.xls",
            "F:\\DyAGT\\gfb34.xls",
            "E:\\g34bg\\SD01A_specV2.xls",
            "D:\\DyAGT\\3g4b3.xls",
            "D:\\g3rbg\\SD01A_specV2.xls",
            "D:\\DyAGT\\Sgbr3.xls",
            "D:\\DyAGT\\SD3rgbA_specV2.xls",
            "E:\\DyAr3br3g3GT\\SD01A_specV2.xls"
        ],
        "non_matches": [
            "E:\\DyAGT\\SD01A_specV2.txt",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "E:\\DyAGT\\fad.txt",
            "E:\\fadsfads\\SD01A_specV2.txt",
            "E:\\DyAGT\\XLS",
            "E:\\DyAGT\\SD01A_specV2.md",
            "C:\\DyAGT\\SD01A_fadsfdasspecV2.md",
            "C:\\DyAGT\\fadsfad123.md",
            "C:\\fads234\\fadsfad123.md",
            "C:\\afdsGSFD\\fadsfad123.md",
            "C:\\DyAGT\\DSAG42.md",
            "ADSF@FADSFXLS"
        ],
        "id": 92,
        "output": [
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generates"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generally"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            }
        ]
    },
    {
        "expression": "^( [1-9]|[1-9]|0[1-9]|10|11|12)[0-5]\\d$",
        "raw_prompt": "Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits. 3 digit times (930) can be expressed with leading 0's (0930) or not. AM/PM designation is not included in this expression.",
        "refined_prompt": "Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits. 3 digit times (930) can be expressed with leading 0's (0930) or not. AM/PM designation is not included in this expression.\nMatch examples:\n- \"1145\"\n- \"933\"\n- \"801\"\nNon-match examples:\n- \"0000\"\n- \"1330\"",
        "matches": [
            "1145",
            "933",
            "801",
            "1051",
            "529",
            "1210",
            "1226",
            "1031",
            "1145",
            "0457",
            "1106",
            "1234",
            "240"
        ],
        "non_matches": [
            "0000",
            "1330",
            "8:30",
            "8498",
            "4512",
            "4512F45",
            "983",
            "21654",
            "9823",
            "2623",
            "6872",
            "16578"
        ],
        "id": 94,
        "output": [
            {
                "text": " \\d\\w\\d\\d \n3. What is a string? Give three"
            },
            {
                "text": " [2-9][0-9]2[0-9]|100[0"
            },
            {
                "text": " ^([1-9]\\d?)+$\n\nA:\n\nThere are"
            },
            {
                "text": "  ([1-2][0-9]|2[0-3])(["
            },
            {
                "text": " This will be a combination of a 3-digit code, numbers and uppercase letters."
            },
            {
                "text": " \n(1?[0-9]|[12][0-9]|"
            },
            {
                "text": " A space and then one number between 0 and 9, or a number 0 through 9.\n"
            },
            {
                "text": " ( \\d{4}-\\d{3}-\\d{2} )"
            },
            {
                "text": " '\\b(AM|PM|0[3-9]|2[0-"
            },
            {
                "text": " [0-9]1[0-9][0-9][0-9]"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\/\\d{2,4}$",
        "raw_prompt": "Accepts 1-2 digits followed by a slash followed by 2-4 digits. Useful for numeric month/year entry.",
        "refined_prompt": "Accepts 1-2 digits followed by a slash followed by 2-4 digits.\nMatch examples:\n- \"9/02\"\n- \"09/2002\"\n- \"09/02\"\nNon-match examples:\n- \"Fall 2002\"\n- \"Sept 2002\"",
        "matches": [
            "9/02",
            "09/2002",
            "09/02",
            "70/661",
            "52/086",
            "7/2550",
            "6/958",
            "38/46",
            "89/6259",
            "08/125",
            "3/470",
            "4/6039",
            "0/971"
        ],
        "non_matches": [
            "Fall 2002",
            "Sept 2002",
            "651/561",
            "651/89",
            "1651/1",
            "61/87465",
            "987/8",
            "5846/564",
            "115/514",
            "564/26589",
            "45/15673",
            "486/465123"
        ],
        "id": 95,
        "output": [
            {
                "text": "\n(?<!www)0?(?!\\d)\\d{1,2}\\/\\d{2,4}\nAnother good URL regex:\n/^https?://[A-z0-9]+(\\.[A-z0"
            },
            {
                "text": " ^(\\\\d{1,2})/(\\d{2,4}$)\n\n5. Match any single word that starts with \"A\" to a character that is not a space or punctuation mark.\nAnswer: ^(?!.|\\"
            },
            {
                "text": " /^\"Fall\"/|/^\"Sept\"/\"|/^\"Fall\"/\"/|/^\"Sept\"/\"/\"|/^\"Fall\"/\"-\"/|/^\"Sept\"/\"-\"/\n\n4. Write a Regex"
            },
            {
                "text": " ^\\d{1,2}\\/\\d{1,4}$\n\n2. Write a Python program that takes a filename as input and counts the total number of words in the file.\n\nIdeas: Use the `re` module to search"
            },
            {
                "text": " /\\d\\d/{2,3}\\d2/\n\nExercise 7:\nWrite a Python code that replaces all occurrences of a substring in a string with another substring.\n\nQuestion: Write Python code that replaces all occurrences of a subst"
            },
            {
                "text": "\n- Regex: /(\\d{1,2})/(\\d{2,4})\n- RegEx: /\\d{2}\\-(\\d{2})\\d{4}/\n\nPython Script:\n\n```python"
            },
            {
                "text": "  \"^(?:[0-9][\\/]{1}[0-9]){1,2}$|^(?:[0-9]{6})$\"\n2. Create a regular expression that will validate an email address. The"
            },
            {
                "text": " \"09\\/02\"\n\nPost from the student:\n\nHey everyone, I'm currently taking a Python course and I'm a bit confused about regular expressions. In particular, I'm having trouble writing a regular expression that checks if a string starts with a particular"
            },
            {
                "text": " r'^\\d{1,2}(\\/\\d{1,2}){1,2}$'\n\n3. Write a Python script that reads a CSV file with email addresses and extracts all of the valid emails using list comprehension.\n\n"
            },
            {
                "text": " ^\\d{2,4}\\/\\d{4}$\n\n# Exercise 2:\nWrite a regular expression to match phone numbers in the format (XXX) XXX-XXXX\nAnswer: ^\\(?\\d{3}\\)?[-.\\"
            }
        ]
    },
    {
        "expression": "^(|(0[1-9])|(1[0-2]))\\/((0[1-9])|(1\\d)|(2\\d)|(3[0-1]))\\/((\\d{4}))$",
        "raw_prompt": "This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded. It is not perfect - it allows DD to be from 01 to 31 regardless of the month.",
        "refined_prompt": "This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded. It allows DD to be from 01 to 31 regardless of the month.\nMatch examples:\n- \"01/01/2001\"\n- \"02/30/2001\"\n- \"12/31/2002\"\nNon-match examples:\n- \"1/1/02\"\n- \"1/1/2002\"",
        "matches": [
            "01/01/2001",
            "02/30/2001",
            "12/31/2002",
            "10/06/7411",
            "03/31/7001",
            "10/30/6747",
            "11/30/1618",
            "10/18/8654",
            "01/11/2633",
            "05/08/9895",
            "08/30/1968",
            "10/23/1386",
            "07/11/0558"
        ],
        "non_matches": [
            "1/1/02",
            "1/1/2002",
            "1/25/2002",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 96,
        "output": [
            {
                "text": " I am looking for all dates formatted as MM/DD/YYYY where dates are from 00 to 31"
            },
            {
                "text": " r'/(0[1-9])|([12][0-9]|3[01"
            },
            {
                "text": " [0|1]?\\d\\d/\\d\\d/\\d\\d\n"
            },
            {
                "text": " \n^([0-9]{1,2}/){2}[0-9"
            },
            {
                "text": " ^(0|[1-9])?(0|[12][0-9])/("
            },
            {
                "text": " (.*)/\\d{1,2}[0-9]{2}$\n"
            },
            {
                "text": " [1-3][0-9]\\/[4-9][0-9]|["
            },
            {
                "text": "\nimport re\ndef validate_input(date_string):\n    m = re.match("
            },
            {
                "text": " [0-9]{2}/[1-9]{2}/[1-"
            },
            {
                "text": "\n(0\\d|1\\d)\\/[0-9]\\d/\\d"
            }
        ]
    },
    {
        "expression": "^((((0[13578])|(1[02]))[\\/]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\/]?(([0-2][0-9])|(30)))|(02[\\/]?[0-2][0-9]))[\\/]?\\d{4}$",
        "raw_prompt": "Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded. Validates correctly for all months except February, which it assumes to always have 29 days. The &quot;/&quot; separator is optional.",
        "refined_prompt": "Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded. Validates correctly for all months except February, which it assumes to always have 29 days.\nMatch examples:\n- \"01/01/2001\"\n- \"02/29/2002\"\n- \"12/31/2002\"\nNon-match examples:\n- \"1/1/02\"\n- \"02/30/2002\"",
        "matches": [
            "01/01/2001",
            "02/29/2002",
            "12/31/2002",
            "02/08/9410",
            "12/30/0469",
            "04/23/4757",
            "02/16/1146",
            "02/21/4951",
            "02/16/5725",
            "04/30/9714",
            "02/22/0322",
            "02/07/8335",
            "03/31/7591"
        ],
        "non_matches": [
            "1/1/02",
            "02/30/2002",
            "1/25/2002",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 97,
        "output": [
            {
                "text": " (01\\d{2}/\\d{2}/\\d{4})|"
            },
            {
                "text": "\n([0-9]|1)[0-9]|2[0-9]"
            },
            {
                "text": " \"^[0-9]{2}[/0-9]{2}$\n"
            },
            {
                "text": " 1\\.\\d{2}\\/\\d{2}\\d{4}\n\n5"
            },
            {
                "text": " (^(0?[1-9])/(?:0?[1-9])/"
            },
            {
                "text": " /^(0[1-9]|1[0-2])\\/(0["
            },
            {
                "text": " /^[1-9]\\d{2}\\/[1-9]\\d"
            },
            {
                "text": "\n\\b(0[1-9]|[12][0-9]|3"
            },
            {
                "text": " Use a forward slash to match any/all of the day/months starting with a 1 to give"
            },
            {
                "text": " ^[0-3]/*[0-9]*\\/[12]$\n\n"
            }
        ]
    },
    {
        "expression": "^(\\d{1,3}'(\\d{3}')*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{3})?)$",
        "raw_prompt": "This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required. It's easy to change to other separators as well.",
        "refined_prompt": "This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required.\nMatch examples:\n- \"1'235.140\"\n- \"1'222'333.120\"\n- \"456\"\nNon-match examples:\n- \"1234.500\"\n- \"78'45.123\"",
        "matches": [
            "1'235.140",
            "1'222'333.120",
            "456",
            "88'424'905'415'870'699'285'830'800'903'879'489'436'003'210'644'340'569'556'469'475'309'055'661'827'487'006'380'173'497'118'326'412'807'895'326'354'231'911'768'449'680'069'565'892'099'646",
            "61",
            "7.680",
            "704'674'688'969'072'125'803'066'981'104'566'546'762'823'774'192'515'690'535'442'327'444'253'062'055'867'618'971'274'103'898'110'314'260'988'864'448'282",
            "8.994",
            "044'460'463'314'543'430'078'086'902.8",
            "0'204'839'396'143'045'546'478'160'791'591'415'414'532'729'941'933'374'184'756'933'515'705'683'090'047'631'201'287'271'916'852'943'106'297'549'637'040'683'634'664'375'759'438'357'499'337'979'149'266'238'139'511'076'976'138'616'984'064'975'705'850'930",
            "523",
            "11.117",
            "388.687"
        ],
        "non_matches": [
            "1234.500",
            "78'45.123",
            "123,0012",
            "f2314132",
            "1v231v4",
            "1234v.4132.1423",
            "64563.1234.5234",
            "@#$.423",
            "234b.25342354",
            "524352344352'35342'325.2341",
            "132F4132F.12F143F2",
            "54B35G3.53G5G3"
        ],
        "id": 98,
        "output": [
            {
                "text": " r'^(?:\\d+\\.\\d{3})|(?:\\d+)\\'(?:\\d+\\."
            },
            {
                "text": " \"|(((\\d+'\\s?\\s?)+|(\\d+\\.?\\d*))\\s?(\\"
            },
            {
                "text": "\n(?:\\d{1,3})\\.'\\d{1,3},\\d{1,3} - matches"
            },
            {
                "text": " (\\d{1,3}')?\\.(\\d{1,3}|\\d)\n\nExercise 2"
            },
            {
                "text": " (The number of decimal places must be minimum one) [0,9].[0-9]0[0-9]|"
            },
            {
                "text": "\n(.*?)\\(\\'(\\d{1,3}\\.)\\d{1,3}') \n\n4."
            },
            {
                "text": " ^\\d*(\\.\\d{1,3})?(?:[A-Z]\\d+'?[A-"
            },
            {
                "text": " [0-9]{1,3}\\.[0-9]{1,3}\n\nExercise 3:\nYou"
            },
            {
                "text": " [0-9]{0,3}[0-9]{3}'[0-9]{1,3"
            },
            {
                "text": " (1\\.\\d{3})\nThe following program will create an array with the results of each regex:\npublic class FindDig"
            }
        ]
    },
    {
        "expression": "^((0?[1-9]|[12][1-9]|3[01])\\.(0?[13578]|1[02])\\.20[0-9]{2}|(0?[1-9]|[12][1-9]|30)\\.(0?[13456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|1[1-9]|2[0-8])\\.(0?[123456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|[12][1-9])\\.(0?[123456789]|1[012])\\.20(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))$",
        "raw_prompt": "Fully functional date validator in format dd.MM.yyyy\nWorks only within range of years 2000-2099 !\nIt allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.",
        "refined_prompt": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099 !\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"",
        "matches": [
            "31.01.2002",
            "29.2.2004",
            "09.02.2005",
            "26.12.2093",
            "2.08.2004",
            "15.4.2053",
            "02.9.2089",
            "3.10.2039",
            "01.08.2013",
            "12.8.2096",
            "24.03.2092",
            "01.7.2012",
            "30.12.2055"
        ],
        "non_matches": [
            "31.11.2002",
            "29.2.2002",
            "33.06.2000",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "31/9/9",
            "12/132/90"
        ],
        "id": 99,
        "output": [
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: \r\nfunction validateDate(inputString) {\r\n  var datePattern = \"/^"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: \r\n([a-z])\\\\..(\\d)\\.([/-]\\d{"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: ^(0[1-9]|1[012])?\\.?[0-9"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: A range from 19-2099 to a leading zero only if non of the following conditions are true"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: \\b[0-9]{2}[.-]?[0-9]{"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: [0-9]\\d[.]\\d[.]\\d[.]\\d["
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: (?<!\\d)([13579]?[1-9])\\.(["
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: [^\\d.]\n\nA:\n\nThis will remove the first character of the string"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: [\\d\\.\\d]{1,2}\\.\\d{0,2"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: This should be \"00...dd.MMm.yyyy\", where... can be anything."
            }
        ]
    },
    {
        "expression": "^(0[1-9]|1[0-2])\\/((0[1-9]|2\\d)|3[0-1])\\/(19\\d\\d|200[0-3])$",
        "raw_prompt": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.\nThis regular expression has been used successfully in ASP with VBScript using the windows scripting library RegExp object.",
        "refined_prompt": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.\nMatch examples:\n- \"12/31/2003\"\n- \"01/01/1900\"\n- \"11/31/2002\"\nNon-match examples:\n- \"1/1/2002\"\n- \"01/01/02\"",
        "matches": [
            "12/31/2003",
            "01/01/1900",
            "11/31/2002",
            "10/31/2003",
            "03/31/1975",
            "10/02/2001",
            "10/29/2000",
            "05/05/1935",
            "11/30/2000",
            "08/31/1996",
            "11/21/2001",
            "02/05/1941",
            "10/01/1931"
        ],
        "non_matches": [
            "1/1/2002",
            "01/01/02",
            "01/01/2004",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/99/9",
            "12/132/90"
        ],
        "id": 100,
        "output": [
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date will"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date,"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date of"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date does"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date would"
            }
        ]
    },
    {
        "expression": "^((((0[13578])|([13578])|(1[02]))[\\/](([1-9])|([0-2][0-9])|(3[01])))|(((0[469])|([469])|(11))[\\/](([1-9])|([0-2][0-9])|(30)))|((2|02)[\\/](([1-9])|([0-2][0-9]))))[\\/]\\d{4}$|^\\d{4}$",
        "raw_prompt": "The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY (this can easily be removed). All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year",
        "refined_prompt": "The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY. All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year\nMatch examples:\n- \"01/01/2001\"\n- \"1/01/2001\"\n- \"2002\"\nNon-match examples:\n- \"2/30/2002\"\n- \"13/23/2002\"",
        "matches": [
            "01/01/2001",
            "1/01/2001",
            "2002",
            "08/31/0540",
            "04/30/8307",
            "4353",
            "11/11/7404",
            "04/4/1252",
            "6488",
            "6118",
            "03/27/0608",
            "11/30/8589",
            "1/9/8118"
        ],
        "non_matches": [
            "2/30/2002",
            "13/23/2002",
            "12345",
            "14314351",
            "15431543",
            "65763576",
            "76556",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/97777",
            "12/132/90"
        ],
        "id": 103,
        "output": [
            {
                "text": "\n\n#Example 1"
            },
            {
                "text": "\n^((0?"
            },
            {
                "text": " \"(?P<year"
            },
            {
                "text": " (MM/DD/"
            },
            {
                "text": "\n(?<!"
            },
            {
                "text": " (Please provide your answer"
            },
            {
                "text": " \\d{2}"
            },
            {
                "text": " (?P<month"
            },
            {
                "text": " 01/|1/"
            },
            {
                "text": " A negative character class which"
            }
        ]
    },
    {
        "expression": "^[-+]?\\d+(\\.\\d+)?$",
        "raw_prompt": "This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation.",
        "refined_prompt": "This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation.\nMatch examples:\n- \"123\"\n- \"-123.45\"\n- \"+123.56\"\nNon-match examples:\n- \"123x\"\n- \".123\"",
        "matches": [
            "123",
            "-123.45",
            "+123.56",
            "512345",
            "5",
            "25432",
            "234",
            "534.53",
            "+4145",
            "-423",
            "222",
            "742",
            "7225464526"
        ],
        "non_matches": [
            "123x",
            ".123",
            "-123.",
            "2435.2543.53245",
            "243551-3425",
            "2/3/5235",
            "43-5432",
            "254627g.256",
            "432/524/2435",
            "1-1-2",
            "34.31sd",
            "++63453.345"
        ],
        "id": 108,
        "output": [
            {
                "text": "\n- x matches any digit character (0-9).\n\nExercise 3:\nUse a RegEx to match any English word, with an optional adjective.\nAnswer:\n- (\\w+) +\n\"\"\"\n\n"
            },
            {
                "text": " \n\\+?[0-9]+(\\.\\d+)+\n\n(3) Write a PyRegExp code that will remove all non-alphanumeric characters from any given string.\n\nNon-match examples"
            },
            {
                "text": " (.123\\.)\n\n2. Write a Python program to validate credit card numbers.\n\n3. Write a Python program to validate an email address.\n\n4. Write a Python program to check if the name of a character"
            },
            {
                "text": " [1-9]\\d*\\.\\d*|\\d+\n- (?<![+\\-/^/*\\d\\w])[+\\-/^/*\\d\\w]+[+\\-/"
            },
            {
                "text": " (.+)\"\n\n4) Create a RegEx to match any number except zero (0) \nAnswer: (?!^0+$)[-+1-9_.]\n\n5) Match the following word (matching"
            },
            {
                "text": " \".*[+-]?\\d*(\\.\\d*)?(x?\\d*)?[+-]?\\d*\"\n\n2. Create a non-regex for the following:\n\""
            },
            {
                "text": " \n[0-9][0-9.]?[0-9]|[1-9][0-9.]?[0-9]\n\nI'm not sure how to handle a range of numbers (like"
            },
            {
                "text": " [\\+-]?\\d+(.[\\d-]?)?\n\nExercise 3:\nWrite a program that finds a series of numbers with 8 or more digits, which belong to the set \"even numbers\" and"
            },
            {
                "text": ".-[0-9]+ \n\nExercise 3:\nProvide an explanation of the following:\n\"^[A-Za-z]+$|^[0-9]+$\"\nAnswer: This Reg"
            },
            {
                "text": " (.{1}\\\\p{N}{1})([0-9]{3}[0-9.-]{4}|[0-9]{3}[0-9.]{1})\\\\"
            }
        ]
    },
    {
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([A-Z]\\d[A-Z]\\s\\d[A-Z]\\d))$",
        "raw_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.",
        "refined_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\nNon-match examples:\n- \"44240ddd\"\n- \"t44240-55\"",
        "matches": [
            "44240",
            "44240-5555",
            "T2P 3C7",
            "02580-6821",
            "41092-0763",
            "63340-6274",
            "P4I\u20065O7",
            "C9C\u00a05L6",
            "C3T\u16802Q5",
            "17021-8260",
            "79433",
            "30395",
            "22696"
        ],
        "non_matches": [
            "44240ddd",
            "t44240-55",
            "t2p3c7",
            "veq23vr",
            "23vr",
            "v23rrg2",
            "v232n2g",
            "grn2",
            "432523545-345",
            "5435-534225",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 110,
        "output": [
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\nI"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n\n"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n\n"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n\n"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            }
        ]
    },
    {
        "expression": "^\\d{5}(-\\d{3})?$",
        "raw_prompt": "Matches standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).\nFor more info refer to: http://www.correios.com.br/servicos/cep/Estrutura_CEP.cfm (in portuguese).",
        "refined_prompt": "Matches strings that consist of either exactly five digits or five digits followed by a hyphen and then exactly three more digits (optional). Can be used to match standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).\nMatch examples:\n- \"13165-000\"\n- \"38175-000\"\n- \"81470-276\"\nNon-match examples:\n- \"13165-00\"\n- \"38175-abc\"",
        "matches": [
            "13165-000",
            "38175-000",
            "81470-276",
            "06959",
            "23625",
            "54551-990",
            "06611",
            "83396-591",
            "82624",
            "70036",
            "94193",
            "41467-951",
            "93134-586"
        ],
        "non_matches": [
            "13165-00",
            "38175-abc",
            "81470-2763",
            "12312-3123",
            "243-234",
            "43-234",
            "654324",
            "436254-",
            "5468",
            "897-",
            "789798",
            "789798-8798"
        ],
        "id": 113,
        "output": [
            {
                "text": " \\d{3}-?\\"
            },
            {
                "text": " [0-9][0-9"
            },
            {
                "text": " Use ([0-9]{3"
            },
            {
                "text": "\n\"\\/?[0-9"
            },
            {
                "text": " *(.+?-\\d"
            },
            {
                "text": "\n^\\\\d{5}-"
            },
            {
                "text": " (\\d{5}-\\"
            },
            {
                "text": " \\d{5}-[\\d"
            },
            {
                "text": " (?<!\\d)\\d"
            },
            {
                "text": " Match any string with exactly five digits,"
            }
        ]
    },
    {
        "expression": "^\\$(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{2})?$",
        "raw_prompt": "This re matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional.",
        "refined_prompt": "Matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional.\nMatch examples:\n- \"$0.84\"\n- \"$123458\"\n- \"$1,234,567.89\"\nNon-match examples:\n- \"$12,3456.01\"\n- \"12345\"",
        "matches": [
            "$0.84",
            "$123458",
            "$1,234,567.89",
            "$969,815,896,348,781",
            "$423098",
            "$9084320.24",
            "$439872",
            "$43920",
            "$324.32",
            "$34.32",
            "$490283",
            "$43.78",
            "$432"
        ],
        "non_matches": [
            "$12,3456.01",
            "12345",
            "$1.234",
            "$32423.42323",
            "$3242jdsa",
            "4298234",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 114,
        "output": [
            {
                "text": " \n[$\\d\\.,] \n[-]?\\d{15,} | \n([$,\\s]?"
            },
            {
                "text": " https://regex101.com/r/WF9eM8/2/description\n\nHost 2: Great job, Host 1!"
            },
            {
                "text": " [0-9]+\\.[0-9]{1}(,[0-9]+|$)\nIllustration: \n        "
            },
            {
                "text": " \\$(\\d+,?)+(\\.\\d+)?|\\d+[,\\s,.]?\nExercise #2:\n-"
            },
            {
                "text": " ^\\d{1,3}-?(?:\\.\\d+)?$ \nExercise 2: Match the following email addresses using"
            },
            {
                "text": " (?i)(?<![0-9,-])[0-9,]*[0-9]?[,]?["
            },
            {
                "text": "\n    [0-9]\n    |\n    \\,?\n    \\d\n    |\n    \\.\n    \\d\n    "
            },
            {
                "text": " [^\\$]*[0-9]+([.][0-9]*)?[,]*[0-9]+\nEx"
            },
            {
                "text": " \n1. [0-9]+, (?=\\.)\n2. [0-9]+, [0-9]\\.["
            },
            {
                "text": " ^[A-Fa-f0-9]*\\.?[0-9]+$\n\nExercise 2: Pattern matching text. "
            }
        ]
    },
    {
        "expression": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])$)|(^([0-9]|[1][0-9]|[2][0-3])$)",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM / H:MM / HH / H",
        "refined_prompt": "Matches a string if it is a valid 24-hour time representations in the format of HH:MM / H:MM / HH / H\nMatch examples:\n- \"10:35\"\n- \"9:20\"\n- \"23\"\nNon-match examples:\n- \"24:00\"\n- \"20 PM\"",
        "matches": [
            "10:35",
            "9:20",
            "23",
            "9",
            "9:23",
            "8:38",
            "18:07",
            "06:10",
            "02:05",
            "04:59",
            "11",
            "4",
            "9"
        ],
        "non_matches": [
            "24:00",
            "20 PM",
            "20:15 PM",
            "12/123/4322",
            "234",
            "123",
            "43-5432",
            "/5/5/20022",
            "000-000",
            "41",
            "34.31",
            "32542"
        ],
        "id": 117,
        "output": [
            {
                "text": " /\\d{2}?:?\\d{2} \\d{2}:\\d{2}/\n\nExercise 5: \nMatch an email format and replace all invalid usernames with"
            },
            {
                "text": " HH:MM / HH / HH\n\n2. In the context of a hospital's patient intake form, describe how to write a RegEx pattern to allow a field to validate input of 12-hour time. "
            },
            {
                "text": "\n[01][0-9]:[0-5][0-9] | [0:][0-9]\n\n3. Write a validator that ensures a user enters a US address of the"
            },
            {
                "text": " The RegEx pattern for each of the time-formatings, should be written below. \n- \"HH:MM\":.* [0-5]\\d :.* | [0-5]\\"
            },
            {
                "text": " /^[0-9]{2}:[0-9]{2}$/\nThe last exercise of this section is a fun one. Have fun creating RegEx patterns that are useful and powerful to"
            },
            {
                "text": " \\d{2,}:\\d{2}\\/?\\d{2}\\/?\\d{2}\\/?\nExample 4:\nThe text reads \"The time is currently 15:20\""
            },
            {
                "text": " \"^([0123456789]|2[0-3]):([0-5][0-9])$\"\n\n4. Match only a date using the format \"dd/m/"
            },
            {
                "text": " \"^([01]\\d|2[0-4]):([0-5]\\d)$\"\n\n3. Write a Python program that scans a file to find all the lines starting with"
            },
            {
                "text": " (Hh) {1,2}[0-9]:[0-9]( AM| PM| a.m.), {1}[0-9]:[0-9]( AM| PM)"
            },
            {
                "text": " The RegEx for this description would be r\"^[0-9]{2}:[0-9]{2} \\B(?:or|$).\"\n\n\n\nQuestion 4: Alex is"
            }
        ]
    },
    {
        "expression": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(\\.[0-9][0-9])?$",
        "raw_prompt": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the . (period) to ensure that no other characters may be used in it's place.",
        "refined_prompt": "Matches currency values with optional dollar signs, allowing for thousands separators and cents.\nMatch examples:\n- \"$3,023,123.34\"\n- \"9,876,453\"\n- \"123456.78\"\nNon-match examples:\n- \"4,33,234.34\"\n- \"$1.234\"",
        "matches": [
            "$3,023,123.34",
            "9,876,453",
            "123456.78",
            "234",
            "432.54",
            "3",
            "4",
            "9.99",
            "$53.54",
            "$65.54",
            "$1.19",
            "$99.87",
            "$54.32"
        ],
        "non_matches": [
            "4,33,234.34",
            "$1.234",
            "abc",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "423.43242a34234",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 118,
        "output": [
            {
                "text": " [0-9]{2,}(\\,|$)\nExercise 5:\nMatch an email address, but only with a single dot: \"jane.doe@gmail."
            },
            {
                "text": " \n\n^[\\d,.]*\\/\\d{2}\\.?\\d{3}$|^[\\d,.]*\\/\\d{2}\\.\\d"
            },
            {
                "text": " \\d{1,3}\\,?\\d{3}\\,?\\d{3}.\\d??\n\nExercise 4:\nCreate a list of countries whose names contain the word"
            },
            {
                "text": " \\d{1,3}.\\d{1,3} (or \\d|\\d$).\n\nExercise 4:\nPattern for a valid email address. Validate if an"
            },
            {
                "text": " (\\d{1,3}(\\.\\d{3})?)([,\\.]?|$)\n4. Write a Python script to validate an IP address. Accept addresses with"
            },
            {
                "text": "\n\ndef currency_match_formatter(value, separator=',', currency='USD'):\n    if not separator: separator='$'\n\n    if value[0]"
            },
            {
                "text": " \n(?<!\\d)\\d{1,3}.\\d{1,3}\\,\\d{1,2}\\.\\d{3}(?!\\,)\\"
            },
            {
                "text": " \n\\$(\\d{1,3}(\\.\\d+)?|\\.\\d+)?(, (\\.\\d+)?|\\d+)/g\n\n4."
            },
            {
                "text": " \\d{1,3}\\.\\d{3},\\d{2}(\\.\\d{3})?\n- Match the string \"4,33,234.34\".\n"
            },
            {
                "text": " \"\\\\d*\\\\d+\\\\.\\\\d{1,3}$\"\nExercise 5: \nCreate a RegEx for the following currency format:\n\"USD(e+"
            }
        ]
    },
    {
        "expression": "^\\$?\\d+(\\.(\\d{2}))?$",
        "raw_prompt": "To evaluate an amount with or without a dollar sign where the cents are optional.",
        "refined_prompt": "^\\$?\\d+(\\.(\\d{2}))?$\nMatch examples:\n- \"$2.43\"\n- \"2.02\"\n- \"$2112\"\nNon-match examples:\n- \"2.1\"\n- \"$.14\"",
        "matches": [
            "$2.43",
            "2.02",
            "$2112",
            "$619533",
            "$141894391704967218837972239156475932407",
            "423423",
            "$653",
            "7256",
            "7452.54",
            "$745",
            "$725",
            "824",
            "$742.35"
        ],
        "non_matches": [
            "2.1",
            "$.14",
            "$2,222.12",
            "435.534",
            "$5.345",
            "$543$54",
            "$-123.2344",
            "$234.234",
            "$543.2623",
            "3450.23948",
            "234.432",
            "222.333"
        ],
        "id": 119,
        "output": [
            {
                "text": " \n$(.{5,6})\\.?$\nExample: '^\\$2\\.15.$' will match strings which have six characters, starting and ending with a dollar, and containing two digits preceding it. All other digits are optional.\n\n"
            },
            {
                "text": " (^.)\\$?\\d+[.](\\d{2})$\n\nQ:\n\nHow to make a string reverse in python?\n\nhow to make a string reverse in python?  \ninput \n\nstr = abcde\n"
            },
            {
                "text": " ^?\\b\\d+(\\.\\d{2})?(\\s|$)\n\n\n\nTitle: The Positive and Negative Impact of Physical Science and Chemical Reactions on Health and Wellness\n\nIntroduction:\nPhysical science is a fascinating branch of study"
            },
            {
                "text": " \\$?\\d+(\\.\\d{2})$\n- \"abcdefg0.2\"\n- \"0.2.23\"\n- \"20.3\"\n\n5. Explain why you shouldn\u2019t use? when you need"
            },
            {
                "text": " \n([0-9]+)[\\.][0-9]{2}\n\nUse Case 4:\nTitle: Creating a Password RegEx\nScenario: You are designing a password generator that requires a user to input 8 characters, with at least one"
            },
            {
                "text": " $\\\\d+(\\\\.\\\\d{2})?$\nTo generate the regex, we simply remove the? and? from the definition of the \\d and the (\\.(\\d{2}))+ part, and replace them with (\\d+)"
            },
            {
                "text": ".*(\\d{1,2})(.*\\.(\\d{1,2})?)$.*\n\nThe solution is quite clear, and I tested it out on a couple of examples.\n\nA:\n\nYou are looking for this\n^\\"
            },
            {
                "text": " (?:\\$?(\\d+)[.](\\d{1,2})?$)\n\"\\$?(\\d+)\\.(\\d{1,2})?$\"\n\nA:\n\nIt's been a while since I used regular"
            },
            {
                "text": " [^0-9]\\.[^0-9]|.[^0-9],[^0-9]\\.\n\nExercise #2:\nCreate a regular expression that matches the number of digits in a given number.\n\nThought process"
            },
            {
                "text": " \\d\\.\\d{2}|\\$([0-9.]+)\nHow to get rid of the decimal values in $2.43:\n$2 = $2 without string parsing\n$2 = $2 without string parsing\n$2 = $"
            }
        ]
    },
    {
        "expression": "((0[1-9])|(1[02]))/\\d{2}",
        "raw_prompt": "Fromat check for MM/YY, checks month is 1-12 and any 2 digit year.",
        "refined_prompt": "Fromat check for MM/YY, checks month is 1-12 and any 2 digit year.\nMatch examples:\n- \"01/00\"\n- \"12/99\"\n- \"10/30\"\nNon-match examples:\n- \"13/00\"\n- \"12/AS\"",
        "matches": [
            "01/00",
            "12/99",
            "10/30",
            "10/21",
            "12/55",
            "02/85",
            "06/46",
            "10/11",
            "10/46",
            "12/34",
            "02/57",
            "06/47",
            "10/52"
        ],
        "non_matches": [
            "13/00",
            "12/AS",
            "123/124",
            "432/5135/1",
            "123.1351",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/24",
            "9/9/9",
            "92/90"
        ],
        "id": 120,
        "output": [
            {
                "text": " /^[0-9]{3}.[0-9]{2}[0-9]{2}$/ or /^[0-9]{3}[A-Z]{2}[0-"
            },
            {
                "text": " /^[0-9]\\s?\\/\\s?[0-9]\\s?$/\n\nFor your code to work, you will need a file with multiple lines in it:\n12/99\n13/"
            },
            {
                "text": " \"^\\\\d{1,2}/\\\\d{3}$\";\n2. A text file contains names which start with a particular letter with 2 or more digits following it in a text file. The pattern should be able to match"
            },
            {
                "text": " [m|1][0-9]\n- \"10/31/2099\"Check date format.Date format should be MM/DD/YYYY.\nAnswer: [1-9][0-9][0-9]["
            },
            {
                "text": " \n[1-9]/[12][0-9]*\n\nExercise2.  You have a list of names with optional capital and the first two letters. Write a RegEx for the list.\nnames = [\""
            },
            {
                "text": " (month_day)(/)([0-9]{2})/.*\\3\\(year\\)\n\nI had difficulty with my code above; I really hoped somebody could help me on this. And I hope to understand Regex"
            },
            {
                "text": " \\d{1,2}/\\d{2}\n- \"06/99\"\nGenerate a RegEx to match all the following:\n\n01/01\n01/02\n01/03\n01/04\n"
            },
            {
                "text": "\n\n^[1-2][0-9][0-9][0-9][0-9][0-9]|[1-2][0-9][0-9][0-9][0-9]"
            },
            {
                "text": " \"^(1[0-2]|0[1-9])/$\"\n\n- \"01/12\"Generate a RegEx for this description. \nAnswer: \"^(0?[1-9]|"
            },
            {
                "text": "\nThe RegEx ( [1-2][0-9])/[0-9A-B][A-Z] Match\n\nQ:\n\nCreate a new array with an order by\n\nIs there a way to create"
            }
        ]
    },
    {
        "expression": "^([0-9]{2})?(\\([0-9]{2})\\)([0-9]{3}|[0-9]{4})-[0-9]{4}$",
        "raw_prompt": "A simple expression to brazilian phone number code, with international code.\nSimple DDI without &quot;+&quot; 99 plus simple DDD (99) plus simple local phone number 3 or 4 digits plus &quot;-&quot; plus 4 digits.",
        "refined_prompt": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)232-3232\"",
        "matches": [
            "55(21)123-4567",
            "(11)1234-5678",
            "55(71)4562-2234",
            "87(37)790-8395",
            "(14)7637-0089",
            "06(10)5683-0265",
            "(17)730-8237",
            "(11)416-7050",
            "19(96)4663-8089",
            "28(23)0153-6864",
            "52(18)651-3567",
            "(21)157-5399",
            "47(71)362-9412"
        ],
        "non_matches": [
            "3434-3432",
            "4(23)232-3232",
            "55(2)232-232",
            "12/123/4322",
            "(234)423425",
            "243234()2342340",
            "()234234",
            "(423)42309243",
            "($32)524308",
            "+434234(4234)",
            "23=4234-98324",
            "24302348-23489(13)"
        ],
        "id": 123,
        "output": [
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)334"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)3"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)45"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)456"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)345"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)12"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)45"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)34"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)32"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)34"
            }
        ]
    },
    {
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*))+\\.(txt|TXT)$",
        "raw_prompt": "This RE validates a path/file of type txt (text file)\nThis RE can be used as a filter on certain file types, while insuring the entire string is a fully qualified path and file. The filter value can be changed or added to as you need",
        "refined_prompt": "This RE validates a path/file of type txt (text file), while insuring the entire string is a fully qualified path and file.\nMatch examples:\n- \"c:\\file.txt\"\n- \"c:\\folder\\sub folder\\file.txt\"\n- \"\\\\network\\folder\\file.txt\"\nNon-match examples:\n- \"C:\"\n- \"C:\\file.xls\"",
        "matches": [
            "c:\\file.txt",
            "c:\\folder\\sub folder\\file.txt",
            "\\\\network\\folder\\file.txt",
            "c:\\adsf.txt",
            "c:\\ghaf.txt",
            "c:\\tqre.txt",
            "d:\\agsha.txt",
            "d:\\dasf\\fasd.txt",
            "d:\\firqewle.txt",
            "e:\\folder\\sub folder\\test.txt",
            "e:\\gad\\afds\\sub folder\\file.txt",
            "e:\\folder\\sub aafs\\file.txt",
            "e:\\folder\\subafdfolder\\file.txt"
        ],
        "non_matches": [
            "C:",
            "C:\\file.xls",
            "folder.txt",
            "akfd.jp",
            "fafds.jpg",
            "abc.png",
            "fasdfa.tst",
            "sfdarq123.txt",
            "asdf.vsw",
            "wersdf.txu",
            "fsda.twe",
            "rwe.ter"
        ],
        "id": 125,
        "output": [
            {
                "text": "\n.*\\\\(network\\\\)\\\\folder\\\\file\\\\\\.txt$\n\nA:\n\nYou don't need"
            },
            {
                "text": "\nregex = r'^((?<root>\\\\\\\\?[^\\\\\\\\\"]+)\\\\[^\\\\\"]+)"
            },
            {
                "text": "\n[^\\\\]?\\\\(?\\[[^(!]*\\)[[:^]]*\\]\\)|"
            },
            {
                "text": " (\\\\/{1,}/[a-zA-z0-9_.-]+\\\\.[a-"
            },
            {
                "text": " [^\\\\]\\w{3}.\\w{3}[^\\]\\d]\nSince you're"
            },
            {
                "text": " \\W\n- \"folder\\folder\\folder\\folder\\folder\\folder\\folder\"Generate a RegEx for"
            },
            {
                "text": "\n\n/[\\'\\\"]+$/ms\n\nQ:\n\nGet the difference between a list of strings and"
            },
            {
                "text": "\n^[a-zA-Z0-9:/\\s-]+$: ^(?:[A-"
            },
            {
                "text": "\n\n```python\nimport re\n\n# Define the path that we want to validate\nmy_path ="
            },
            {
                "text": " ^(?=.*\\\\)(?=.*\\/)(?=.*\\.)(?P<path>.*)\\"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+([a-zA-Z0-9\\-\\.]+)?\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "raw_prompt": "Checks domain names. This is an attempt to deal with some of the issues of the other reg ex in not handling leading periods(.) and hypens(-).",
        "refined_prompt": "Used to validate domain names that start with alphanumeric characters, may contain additional alphanumeric characters, hyphens, and periods in the middle (optionally), and end with one of the specified TLDs (case-insensitive).\nMatch examples:\n- \"my.domain.com\"\n- \"regexlib.com\"\n- \"big-reg.com\"\nNon-match examples:\n- \".mydomain.com\"\n- \"regexlib.comm\"",
        "matches": [
            "my.domain.com",
            "regexlib.com",
            "big-reg.com",
            "x7E6vd6bn9lVKV0UvDZjDca14Pxfd42DQ2ue7A3KP.org",
            "F60CAbjTaI28WV4APmn.ORG",
            "4ozPd3VhUT4UbPSxAd74tdnSKlPE.org",
            "br9Gf5bwzVWg3SvjGO2N0A7ZXVf1Ex.net",
            "3MOHUK1ssVZ.ORG",
            "biF.com",
            "Ov4M1oQuzhAwsHOpx6Rm.edu",
            "eMxw3wFMwZHeGv7pR6IX4Xwxi6MbKTmSxKgedUn9h0fFLD.U0pwr4yV7dInK5frNbyRghfA0IkWKsTg.edu",
            "LaYx5MdIy4pGlJ.com",
            "ZDbQ57LlDzhRbUVeK4zPc.EDU"
        ],
        "non_matches": [
            ".mydomain.com",
            "regexlib.comm",
            "-bigreg.com",
            "afdsaf.adijs",
            "a.cdsaca.cas",
            "43.v234",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "notredame.github",
            "99999@gmail"
        ],
        "id": 126,
        "output": [
            {
                "text": " \"^[A-Za-z0-9"
            },
            {
                "text": " (\\w+\\.){1,3}\\w"
            },
            {
                "text": " (.*\\.com|.*\\.org|.*\\.net"
            },
            {
                "text": "\n```python\ntlds = ['com',"
            },
            {
                "text": "\n^[a-zA-Z0-9"
            },
            {
                "text": "\nimport os\n\nTLD = 'com'\n"
            },
            {
                "text": " /^[a-z]+[0-9]+"
            },
            {
                "text": ".*\\.(com|edu|net)/com$"
            },
            {
                "text": "\n- \"^(?=.*[A-Z"
            },
            {
                "text": " Regex for \"my.domain.com\" and \""
            }
        ]
    },
    {
        "expression": "^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$",
        "raw_prompt": "This matches floating point expression in a more rigorous way - accepts both exponent as well as non exponent notations.",
        "refined_prompt": "Matches numbers that can be positive or negative, may have a decimal point, and can be in scientific notation format\nMatch examples:\n- \"123\"\n- \"-123.35\"\n- \"-123.35e-2\"\nNon-match examples:\n- \"abc\"\n- \"123.32e\"",
        "matches": [
            "123",
            "-123.35",
            "-123.35e-2",
            "41",
            "1432",
            "512",
            "123",
            "77680628136.7552098e982",
            "+76780107092975139",
            "+7678023024785.3e-19982",
            "275189806858986728960918281818983794084608877641099649684838072428225393435789.38e05143381004",
            "-432.52",
            "2e10"
        ],
        "non_matches": [
            "abc",
            "123.32e",
            "123.32.3",
            "12/123/4322",
            "51:534",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "34.31ee",
            "12/132/90"
        ],
        "id": 127,
        "output": [
            {
                "text": " [-+]?[0-9]*\\.[0-9]{2}[eE][-+]?[0-9]*\n\n4. Write a RegEx for matching email addresses in the format"
            },
            {
                "text": " (?<!\\d)(?<!\\d-)(?<!(-)(?<![^e-z])[0-9])(?![^e-z])[a-z][0"
            },
            {
                "text": "\nNegative Numbers Match. The string should start with - and finish with any number of digits.\n\n```python\n# Answer for Question 1\nexpression = \"-543a76543212f\" \nmatch ="
            },
            {
                "text": " Non-match examples do not include numbers greater than 10^12\n- \"123\"\n- \"abc\"\n- \"1.2\"\n- \"1\"\n- \"1234ab23c\"Generate a"
            },
            {
                "text": " \"abc\" & \"123.32\" are not valid RegEx patterns. We need one or the other to match the desired result. \n\n3. Create a RegEx pattern that matches a phone number in the following formats"
            },
            {
                "text": " \".*\\d+[+-]?\\d+\\.\\d+|\\d+.*\"\n\nExercise 2: Matching Quotations \nMatch an example given in the question with a corresponding Re"
            },
            {
                "text": " (\\d +\\.\\d+e-\\d+)?$ \n\nExercise 2: Identify the type of data structure based on the given description.\nDescription: A set of objects where each object has its"
            },
            {
                "text": " The match description. \n\nReal-World Use Cases:\n\nUse Case #1: Customer Support\nIn this scenario, a customer calls to report an issue with a newly purchased product. The customer service representative has access to"
            },
            {
                "text": " \".*[0-9]{{3}}((\\\\.[0-9]+){3}).*e.*\" \n\nExercise 5: Identify the type of data represented in the following patterns\na) ["
            },
            {
                "text": " The Regex for this description would be \"(^|\\+|\\-)(-\\d+(\\.\\d+)?)\\s*($|\\+|\\-)(-\\d+(\\.\\d+)?)\\s*"
            }
        ]
    },
    {
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "raw_prompt": "Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.",
        "refined_prompt": "Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"",
        "matches": [
            "1:01 AM",
            "23:52:01",
            "03.24.36 AM",
            "01.12",
            "1.44PM",
            "10.17.53 am",
            "14.51:24",
            "03.34",
            "07:45.39PM",
            "02:43 aM",
            "23.58",
            "4:21PM",
            "17.50:18"
        ],
        "non_matches": [
            "19:31 AM",
            "9:9 PM",
            "25:60:61",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "/5/5/5",
            "254627g.256",
            "123:234:234",
            "12:60:423",
            "999:999:999",
            "12/132/90"
        ],
        "id": 132,
        "output": [
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer:\nTime(?:\\d|[1-2]\\d[:\\"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: (\\d)\\s+:\\s+([0-9]|1"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: ^([12][0-2]\\d|3[0-1"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: My regex pattern is ^([0-9]|1[0-2"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer:\n[0-2][0-9]\\s[0-9"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: [0-9]{1,2}[a-z]{"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: {\n        @\"{4}([1-2]\\d|"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: \n\na(?:[0-6]|\\:)(["
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: \n\nfunction getTimeRegex(time) {\n  let re"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: [A-Pm]\\d?[Hh]\\d?"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\s.\\-_']+$",
        "raw_prompt": "Alphanumeric, hyphen apostrophe, comma dash spaces",
        "refined_prompt": "Match strings that consist of alphanumeric characters, spaces, periods (dots), hyphens, underscores, and single quotation marks.\nMatch examples:\n- \"dony d'gsa\"\n- \"adsfaq9\"\n- \"f231v3\"\nNon-match examples:\n- \"^[a-zA-Z0-9\\s.\\-_']+$\"\n- \"+SDF4324$#*\"",
        "matches": [
            "dony d'gsa",
            "adsfaq9",
            "f231v3",
            "f34v2f3",
            "f3v2f4",
            "vad.adsfv",
            "adfq3_fvs",
            "fdsv.sd_",
            "q34",
            "g4b3w...",
            "54_ sfdg",
            "dfsg-gsdf_",
            "avaf_fewav"
        ],
        "non_matches": [
            "^[a-zA-Z0-9\\s.\\-_']+$",
            "+SDF4324$#*",
            "%$@$#+342",
            "%$(*#(%+24dfsv",
            "^&*",
            "#@$",
            "($@*#$+#$%",
            "3548345$@+#$",
            "+@!#$#",
            "*$(#@%",
            "*%&$*($#`",
            "$~#@$$"
        ],
        "id": 133,
        "output": [
            {
                "text": " ^[a-zA-Z0-9\\s.\\-_']+"
            },
            {
                "text": " Matching all strings that contain at least one alphanumeric character, spaces, period ("
            },
            {
                "text": " Regex to match strings consisting of alphanumeric characters, spaces, periods (dots"
            },
            {
                "text": " [a-zA-Z0-9\\s.\\-_']+\n"
            },
            {
                "text": " This pattern is valid and would match a string that starts with a capital letter, contains a"
            },
            {
                "text": " ^SDF4324[a-zA-Z0-9\\s."
            },
            {
                "text": " ^[a-zA-Z0-9\\s.\\-_']("
            },
            {
                "text": " \"^[a-zA-Z0-9\\s.\\-_']"
            },
            {
                "text": " ([a-zA-Z0-9\\s.-_']+)\n"
            },
            {
                "text": " ^[a-zA-Z0-9\\s.\\-,\\_"
            }
        ]
    },
    {
        "expression": "^\\d{0,2}(\\.\\d{1,2})?$",
        "raw_prompt": "This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal.",
        "refined_prompt": "This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal.\nMatch examples:\n- \"99.99\"\n- \"99\"\n- \".99\"\nNon-match examples:\n- \"999.999\"\n- \"999\"",
        "matches": [
            "99.99",
            "99",
            ".99",
            "1",
            "78",
            "12",
            "9.2",
            "4.0",
            "8.1",
            "8.64",
            "76",
            "19.9",
            "86"
        ],
        "non_matches": [
            "999.999",
            "999",
            ".999",
            "-123",
            "234",
            "123",
            "-312",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "34.31141",
            "32542"
        ],
        "id": 139,
        "output": [
            {
                "text": " ^[^\\s]*(?:\\d+(\\.\\d+)?|\\.\\d+)[^\\s]*$\n\n#### Exercise 4\nUsing the RegEx in the example above"
            },
            {
                "text": " \\d\\d.\\d\\d\n\nExercises 5: The final exercise is to give the user an option whether they should continue or exit this chapter of the project.\n1. The User"
            },
            {
                "text": "\n[ ]?\\.\\d+(\\d+\\.\\d*?)[ ]?  \n\n( )? Non-capturing group\n\\. Non-punctuation character\n\\d matches digit"
            },
            {
                "text": " \\d{1}[.,](\\d{2})+?[.,]\\d{1}{1,}$\n\n```python\nimport re\n\npattern = r'\\"
            },
            {
                "text": " ^\\d{1,2}(\\.\\d{1,2})?$\nExercise 5: Identify the Regular Expression \n\nMatch examples: \n-   ^\\w+"
            },
            {
                "text": " \n\n^(?:[1-9][0-9]{0,2}|100[0-9]{0,2})\\.[0-9]{2}$\n"
            },
            {
                "text": "\n^[1-9]\\\\d*(\\\\.\\\\d[1-9]+)?|\\\\.\\\\d[1-9]+|\\\\d$\n\n2. Write an `if"
            },
            {
                "text": " The following regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal: (\\d{1,2}\\."
            },
            {
                "text": " (\\d+\\.?\\d|\\d{1,2})(?:[eE][+-]?\\d*)?\" \n\n```python\nimport re\n\ndata ="
            },
            {
                "text": " The minimum number of decimal places should be one. \n\nExercise 5: \nMatch all the characters below to their corresponding category in the table.\nCategory|Character\na. Alphabet\nb."
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$",
        "raw_prompt": "This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.",
        "refined_prompt": "This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45:67:89:Az\"",
        "matches": [
            "01:23:45:67:89:ab",
            "01:23:45:67:89:AB",
            "fE:dC:bA:98:76:54",
            "44:4a:8F:Af:52:Ca",
            "74:30:F2:Ad:AB:05",
            "a7:b6:e8:2F:Aa:08",
            "Cb:26:29:03:c8:dC",
            "D5:dc:86:7f:De:E2",
            "E5:88:9f:cb:5E:4D",
            "6C:F1:ff:D5:CD:2D",
            "57:cB:aC:DF:1b:79",
            "2e:5b:cA:8c:6b:7A",
            "BD:D4:0b:D5:5d:e0"
        ],
        "non_matches": [
            "01:23:45:67:89:ab:cd",
            "01:23:45:67:89:Az",
            "01:23:45:56:",
            "12/123/4322",
            "51:534",
            "243:234:423:5234",
            "53426:525234",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "2434:542:523:2345",
            "12/132/90"
        ],
        "id": 141,
        "output": [
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            }
        ]
    },
    {
        "expression": "^100$|^[0-9]{1,2}$|^[0-9]{1,2}\\,[0-9]{1,3}$",
        "raw_prompt": "Percentage with 3 number after comma.",
        "refined_prompt": "This regular expression can match three different patterns:\r\n\r\nThe exact string \"100.\"\r\nOne or two-digit numbers.\r\nNumbers in a specific format with one or two digits, a comma, and one to three digits.\nMatch examples:\n- \"12,654\"\n- \"1,987\"\n- \"43,582\"\nNon-match examples:\n- \"128,2\"\n- \"12,\"",
        "matches": [
            "12,654",
            "1,987",
            "43,582",
            "59,582",
            "2,582",
            "52,482",
            "59,749",
            "58,960",
            "4,683",
            "53",
            "54",
            "9",
            "1"
        ],
        "non_matches": [
            "128,2",
            "12,",
            "453,5345,534",
            "534,345,345,453,25",
            ",54325,45",
            "534,2,5",
            "54,35,235",
            "543,536,43",
            "5,43,634,534",
            "5,43,5345,43",
            "534,534,6345,,35",
            "54,3534"
        ],
        "id": 142,
        "output": [
            {
                "text": " \"1,2[,0-9]+\"\r\n\r\nThe following snippet generates the RegEx"
            },
            {
                "text": " (Note: This will only work for numbers with 1 to 3 digits and commas) \r\n\""
            },
            {
                "text": " ^[, ]?\\d+,?\\d{1,3}$\r\n- \"123"
            },
            {
                "text": " 123,049\r\n\r\n2-4 - The following regex will match 1 or more digits and"
            },
            {
                "text": " 0-3 (?=[0-9]{2,}), not a comma. 1-9"
            },
            {
                "text": ". - any character. \n- \"12,e\" -. - any character. \n-"
            },
            {
                "text": " /^[1-9][\\d,](1\\d{4,6})?$/"
            },
            {
                "text": " r\"([1-9]\\d{1,2}|10\\d?,\\d{"
            },
            {
                "text": ".+(?=,)\r\n\r\nWhat is this regular expression for? \r\n(it can"
            },
            {
                "text": " \"[0-9,0-9]|[1-9][0-9]?\"\r\n"
            }
        ]
    },
    {
        "expression": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)$",
        "raw_prompt": "Correct French DateTime(DD/MM/YYYY OR DD/MM/YYYY HH:MM:SS)",
        "refined_prompt": "Correct French DateTime(DD/MM/YYYY OR DD/MM/YYYY HH:MM:SS)\nMatch examples:\n- \"12/01/2002\"\n- \"12/01/2002 12:32:10\"\n- \"30/04/2089\"\nNon-match examples:\n- \"32/12/2002\"\n- \"12/13/2001\"",
        "matches": [
            "12/01/2002",
            "12/01/2002 12:32:10",
            "30/04/2089",
            "01/06/2051\u168011:45:19",
            "31/01/2040\u200321:52:00",
            "30/10/2064 23:22:41",
            "30/11/2022",
            "27/11/2043",
            "30/11/2061",
            "14/05/2075",
            "31/11/2038",
            "23/10/2062\u200811:38:00",
            "30/12/2041"
        ],
        "non_matches": [
            "32/12/2002",
            "12/13/2001",
            "12/02/06",
            "12/123/4322",
            "234/423/5243",
            "2/3/52355",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/95341",
            "12/132/90"
        ],
        "id": 143,
        "output": [
            {
                "text": "\n\"\\d{2}\\/\\d{2}\\/\\d{4} OR \\d{2}\\/\\d{2"
            },
            {
                "text": " (YYYY-MM-DD)\\.\\d{2}\\.\\d\\d\n\nIn summary, understanding the rules for naming date"
            },
            {
                "text": " \n\n[A-Z][A-Z][A-Z][0-9][0-9]{2}-[A-"
            },
            {
                "text": " \nDD/MM/YYYY OR DD/MM/YYYY HH:MM:SS \n\nExercise 2: Create a Pattern"
            },
            {
                "text": " dd-mm-yyyy or mm-dd-yyyy\n\nExercise 2:\nWrite a RegEx for identifying dates that are written"
            },
            {
                "text": "\nRegular expression: ^\\d{2}\\/\\d{2}\\/\\d{4}$ OR ^\\d{2}"
            },
            {
                "text": "\n\n```\n(?:[0-9]{3})/(?:[0-9]{2})/(?:["
            },
            {
                "text": " \"^(((?:29|30)(\\/|-|\\/)\\d{1,2})(\\/|-|\\/)\\d{1,"
            },
            {
                "text": "\n(0?[1-9]|[12]?[0-9]|3[01])/(0?[1-"
            },
            {
                "text": " You can use the pattern /(\\d{1,2})/(\\d{1,2})/(\\d{4,4}|"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]\\.)+([a-zA-Z0-9]{3,5})$",
        "raw_prompt": "Host/Domain name validation for perl.\nShould be combined with a check for\nlength &lt;= 63 characters and that $2\nis in a list of top-level domains.",
        "refined_prompt": "Matches domain names with subdomains and enforces certain rules such as starting and ending with alphanumeric characters, allowing hyphens in subdomains, and specifying a TLD with 3 to 5 characters.\nMatch examples:\n- \"freshmeat.net\"\n- \"123.com\"\n- \"TempLate-toolkKt.orG\"\nNon-match examples:\n- \"-dog.com\"\n- \"?boy.net\"",
        "matches": [
            "freshmeat.net",
            "123.com",
            "TempLate-toolkKt.orG",
            "baidu.com",
            "kugou.com",
            "google.com",
            "ads.com",
            "apple.com",
            "openai.com",
            "nd.edu",
            "app.net",
            "happy.org",
            "handsome.org"
        ],
        "non_matches": [
            "-dog.com",
            "?boy.net",
            "this.domain",
            "cqerc.9j9jafds",
            "sfalijad234",
            "3nf@.afdsgadsf",
            "@#dfkjnav.agffe",
            "%jfkdlddf@#FD",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 145,
        "output": [
            {
                "text": " https://regex101.com/r/mY3L5i/1"
            },
            {
                "text": " r'^(?!.*[-_.])(?!.*-)(?!.*-"
            },
            {
                "text": " Non-match examples: \"-dog.com\" and \"?boy.net\". The"
            },
            {
                "text": " To match domain names with a period and a top-level domain with three to five characters"
            },
            {
                "text": " Non-match examples should match with the regular expression [a-z0-9]["
            },
            {
                "text": " Allow hyphens in subdomains, allow alphanumeric characters anywhere in the domain name"
            },
            {
                "text": " [^a-zA-Z0-9]+[a-zA-"
            },
            {
                "text": " /^(?=^[\\w.]{0,61}$)([["
            },
            {
                "text": "\nre = '^([\\w-]+[\\w-]*[-"
            },
            {
                "text": " \n[a-z0-9]{1}\\.[a-z0"
            }
        ]
    },
    {
        "expression": "^[^']*$",
        "raw_prompt": "This one matches all strings that do not contain the single quotation mark (').",
        "refined_prompt": "This one matches all strings that do not contain the single quotation mark (').\nMatch examples:\n- \"asljas\"\n- \"%/&amp;89uhuhadjkh\"\n- \"&quot;hi there!&quot;\"\nNon-match examples:\n- \"'hi there!'\"\n- \"It's 9 o'clock\"",
        "matches": [
            "asljas",
            "%/&amp;89uhuhadjkh",
            "&quot;hi there!&quot;",
            "fqqea",
            "dF(D*SHF*f",
            "3443gb",
            "45bgb45g",
            "b4b5b*G&&USDF",
            "dsg$#R",
            "FSDF#@FW#F",
            "f#4f$#F",
            "$F#$FFSDfsdew",
            "fewf&*("
        ],
        "non_matches": [
            "'hi there!'",
            "It's 9 o'clock",
            "'''''",
            "dhjggh'hdsfj",
            "jkljasdlkj09'afds",
            "'fdsa'fad'fdas",
            "fds'ajsdlk",
            "'fdskalj'lkfa9'FADSKFDA",
            "FDSA'FJDIS(*&$F",
            "'DSFAFJ*(FDS'FDSA",
            "DFJSL'98DF'FSDIO",
            "JSDLKF'SDF''FDS''FS"
        ],
        "id": 146,
        "output": [
            {
                "text": " \\w+(?!(?:'))\n\n2) Generate a RegEx for the statement \"The date is (month/year)\".\n\n\n\n\n# The use of Django"
            },
            {
                "text": " [^']{0,3}[^']{0,2}[^']{0,1}'\n- Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": " 'hi there!'\n\nLearning Journal - Subsection 6.4.8: How to use named and anonymous groups, as well as optional starting and ending anchors\n\nExercise 1:"
            },
            {
                "text": " ^[\\w\\s]+$\n\nExercise 4:\nWhat would be a good RegEx for the following description?\nMatch words that end with a period and a word that starts"
            },
            {
                "text": " It is the start of a sentence(\\b). It is between 0-9(\\d) and o'clock(\\d)\n\\b - 0-9 and o'clock(o-"
            },
            {
                "text": " ^[^\\']{1,20}$|^[\\'']([^\\'']+)[\\']$\n\nExample scenario 2:  \n\nJohn wanted to create"
            },
            {
                "text": " (\n^[A-Za-z0-9!@#$%^&+=|*()-_,.-\\/&+/-=]*[A-Za-z"
            },
            {
                "text": "^(?<!')\\b([a-zA-Z0-9_]+(?:'[a-zA-Z0-9_]+)*)\\b(?!"
            },
            {
                "text": " [^\\s'\\n]\n\n**Conclusion:**\nSo there you have it! We learned about the basics of regular expressions and how they can be used with Python to perform various"
            },
            {
                "text": "\n(?:^|[ ])?\\s*[a-z]+(?:[\\'\"\\']\\s*)?(?:\\s*'\\s*[a-z"
            }
        ]
    },
    {
        "expression": "^([1-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$",
        "raw_prompt": "This validates a number between 1 and 255. Could be modified to IP, or just to verify a number in a range.",
        "refined_prompt": "Validates a number between 1 and 255.\nMatch examples:\n- \"1\"\n- \"108\"\n- \"255\"\nNon-match examples:\n- \"01\"\n- \"256\"",
        "matches": [
            "1",
            "108",
            "255",
            "142",
            "151",
            "124",
            "165",
            "45",
            "85",
            "75",
            "36",
            "218",
            "215"
        ],
        "non_matches": [
            "01",
            "256",
            "534798",
            "0948",
            "54390",
            "54398",
            "9393",
            "-432",
            "324df",
            "1-1-2",
            "9/9/9",
            "12/132/90"
        ],
        "id": 147,
        "output": [
            {
                "text": " \\d{0,2}|\\d{2,3}|\\d{3}|\\d{4}|\\d{5}|\\d{6}\n\nExercise 2: Write a Regular Expression That Validates Email Addresses\nMatch examples:\n- \"example@example.com\"\n- \""
            },
            {
                "text": "  (Range 1-255) {0,2}\\d[0-9]{2}|1?\\d{1}:[0-9]{2}:[0-9]{2}|0[0-4]|0[0-9]\n\nA:\n\nYou need to repeat the number"
            },
            {
                "text": "\n[1-9][0-9]|[1-9]?[0-9][0-9]|1[0-9]?[0-9][0-9]|2[0-4][0-9]|25[0-5]\n\nExercise 4: \nExplain"
            },
            {
                "text": " \\[[a-z]\\].+\\.[0-9]+\n\nExercise 3:\nWrite a Python code that replaces all \".\" with the \"-\" character in a text string.\nCode Answer: \ntext = \"my text.here is a.\"\nnew_text = re.sub(\".+\", \"-\","
            },
            {
                "text": " \\b(?:1(?:\\d\\)?|100|200|300|400|500)0\\b\n\nExercise 5: Password Validator\nYour program should check whether user input follows a secure password format. It must contain at least one lowercase letter, one uppercase letter, one number, and be between 8"
            },
            {
                "text": " a, b, c, n\n\n\n### Exercise 2\n- Accept input for two dates which are provided by the user. Determine if the second date is after or before the first date.\n- Display the difference between the two dates in days.\n- Add two days to the first date using Regex.\n- Output the final date"
            },
            {
                "text": " [0-9]{2}[.][0-9]{2}\nUse case: Email validation\nYou want to create a function that validates email addresses with regular expressions. The function takes the email as a string input and returns a Boolean indicating whether the email address is valid. \n\nIn your test data, you have"
            },
            {
                "text": " [1-9][a-zA-Z0-9](0){2,}\n\n2. Exercise 2: RegEx Quizzification\n    - What pattern do the following regular expressions match?\n    - a) [a-z]{3}  -- Match any three lowercase alphabetic characters.\n    "
            },
            {
                "text": "\n(^|[ ])\\b(0|[1-9]|1[0-2])(\\.|\\,?)$\n\n\n\nHey there, fellow Alien! Welcome to the fascinating world of computer science, where software and security intersect to create amazing advancements. Today, I'm going to introduce you to the concept of"
            },
            {
                "text": " To generate a RegEx for this description, you could use \"[1-9]\\d*|1.\\d+\\b|255\\b\". \nExercise 8: Write a RegEx that matches one or more lower-case letters and one or more digits. \nAnswer: To match one or more lower-case letters"
            }
        ]
    },
    {
        "expression": "^[0-9](\\.[0-9]+)?$",
        "raw_prompt": "matches non-negative decimal floating points numbers less than 10",
        "refined_prompt": "Matches non-negative decimal floating points numbers less than 10\nMatch examples:\n- \"1.2345\"\n- \"0.00001\"\n- \"7\"\nNon-match examples:\n- \"12.2\"\n- \"1.10.1\"",
        "matches": [
            "1.2345",
            "0.00001",
            "7",
            "1",
            "6",
            "9",
            "6.7",
            "5.854",
            "9.563",
            "4.4875",
            "8.4657",
            "3.654373",
            "7.37654"
        ],
        "non_matches": [
            "12.2",
            "1.10.1",
            "15.98",
            "-123",
            "234",
            "123",
            "-312",
            "12f3.21f3.213f",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "534534.94534"
        ],
        "id": 149,
        "output": [
            {
                "text": " ^[0-9]*\\.[0-9]*.0?$\n\nExercise 2:\nCreate a Python function that takes a list of strings and returns the length of the longest string in that list.\n\nAnswer:\ndef longest_string("
            },
            {
                "text": " [^0-9.]*$ \nThe regular expression reads: \n[^0-9.]* \u2013 matches any number of non-numeric symbols, except for the digit 0 \n$ \u2013 end of string\n\n3. Write a Python script that"
            },
            {
                "text": " ^(?=.*\\\\d)(?=>.*\\\\d)0*$\n\n\n\nQuestion 5: \nLucas has a bag of marbles. He gave 1/4 of the marbles to his friend Alex, then 1/6 of the remaining"
            },
            {
                "text": "\n^(?=.*\\.)[0-9]?\\d?\\.\\d+$\n\n4. Create a Python function that retrieves all matches from a given list using the PyPi regular expression module. \nAnswer:\nimport re\nlist"
            },
            {
                "text": " \"(.*)\\.\\d\\.(.*)\".match(sValue);\nIllustration:\n        Sarah is a single mom who works full time. She also has two children, a seven-year-old daughter named Lily and a three-year-old son"
            },
            {
                "text": " [^\\d.]\n\nExercise 3:\nMatch examples of phone numbers with valid formats. \nAnswer: 9 + (555) 678-1234 [Any phone number format is correct as long as it matches the phone number pattern]\n\n\n\n"
            },
            {
                "text": " \n(^[0-9]?[0-9]?[0-9]$|[0-9]?[0-9]$|[0-9]{3}[.][0-9]{1,2}"
            },
            {
                "text": " [a]a[n]:0[.]1[.]2\nNon-match examples:\n12\\.2\n1.10.1\n\nA:\n\nI just did the following:\n((1\\d+[,])|(0\\d"
            },
            {
                "text": " \n[0-9]?[1-9][0-9]?[0-9]\n\n\n# String Methods: translate\n\n## Subsections:\n\n- What is translate?\n- How to use translate?\n- Examples of translate"
            },
            {
                "text": ".*?([\\d.]*)\n\n## Exercise 3\nWrite a RegEx to detect the name and phone number of a person in the following string: \"Your contact details are (1234567890) and (1234567890) [1234567890"
            }
        ]
    },
    {
        "expression": "^((((31\\/(0?[13578]|1[02]))|((29|30)\\/(0?[1,3-9]|1[0-2])))\\/(1[6-9]|[2-9]\\d)?\\d{2})|(29\\/0?2\\/(((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))|(0?[1-9]|1\\d|2[0-8])\\/((0?[1-9])|(1[0-2]))\\/((1[6-9]|[2-9]\\d)?\\d{2})) (20|21|22|23|[0-1]?\\d):[0-5]?\\d:[0-5]?\\d$",
        "raw_prompt": "this expression validates a date-time field in European d/m/y h:m:s format. It is a european variation of Michael Ash's date-validation expression in this library.\nThe days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/04 20:15:15\"",
        "matches": [
            "29/02/2004 20:15:27",
            "29/2/04 8:9:5",
            "31/3/2004 9:20:17",
            "12/12/10 23:5:58",
            "30/6/6805 22:11:01",
            "31/3/1840 22:15:28",
            "29/2/8400 21:8:46",
            "31/01/9934 20:45:5",
            "30/12/4789 20:09:27",
            "29/02/12 22:7:58",
            "02/02/3840 22:2:30",
            "06/11/52 21:5:00",
            "13/11/96 23:29:23"
        ],
        "non_matches": [
            "29/02/2003 20:15:15",
            "2/29/04 20:15:15",
            "31/3/4 9:20:17",
            "29/02/17098 21:14:19",
            "28/29/41 20:1:5",
            "29/02/65 07:05:8",
            "25/010/9758 5:04:40",
            "29/2/281 23:2:8",
            "31/12/18155 21:9:36",
            "29/2/1600 21:6:99",
            "17/06/54 89:9:6",
            "29/2/28 22:98:4"
        ],
        "id": 153,
        "output": [
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            }
        ]
    },
    {
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,3})?$",
        "raw_prompt": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.",
        "refined_prompt": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.\nMatch examples:\n- \"1\"\n- \"12345.123\"\n- \"0.5\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "1",
            "12345.123",
            "0.5",
            "2",
            "3",
            "33098",
            "3.280",
            "619.8",
            "6388.09",
            "25461.784",
            "91",
            "152.485",
            "25461.784"
        ],
        "non_matches": [
            "0",
            "0.0",
            "123456.1234",
            "45.456123",
            "486.8945624895",
            "98456124856.54",
            "0.000",
            "0.0000000",
            "000.000",
            "354/243/542",
            "34.315412",
            "12/132/90"
        ],
        "id": 156,
        "output": [
            {
                "text": " \n^[1-9][0-9]?[0-9]?[0-9]?$\n\n2) Validating email addresses\nEmail addresses contain a character followed by letters and/or numbers."
            },
            {
                "text": " A regular expression that matches non-zero numbers and has 5 or less digits after the decimal point AND no digits before the decimal point. \n\n---\n\n### Exercise 2:\n\n```python\nimport re\n\nstring"
            },
            {
                "text": " \"(?!(^|\\.)(?:\\.\\.){2,3}[^0]$)\"\n\nExercise 4: Replace the numbers in the string \"1,234\" with only digits. For example,"
            },
            {
                "text": " ^(?!\\d\\.\\d?\\d.$)/^\\d+(\\.\\d{1,3})?$/\n\nExercise three: Write a regular expression to find words of 7 or fewer characters in this"
            },
            {
                "text": " r'\\.(?!\\.)(?!\\d)[0-9]?'\n\nThe full python code to accomplish this is below:\nimport re\n\npattern = r\"\"\"^[0-9]{1,5"
            },
            {
                "text": " \"0*([0-9][1-9]?|1?[0-9]?[0-9]|100?[0-1]?)[0-9]*'\n\nExercise 2"
            },
            {
                "text": " ^[^.]+?\\.[^.]+?$\n- \"1,456,789.123\"\nGenerate a RegEx for this description. \nAnswer: ^[^,]+?(,[^,"
            },
            {
                "text": " \\d{0,1}(?:\\.\\d{0,5})?(?:\\D)\nExercise 5: This regular expression validates ONLY strings with 1+ spaces after the decimal point.\nMatch examples"
            },
            {
                "text": " 0(?=(?:0+\\.){0,3})\\d$\nRegular expression - 0(?=(?:0+\\.){0,3})\\d$\nWhat it does:\n - (?="
            },
            {
                "text": " ^[0-9][0-9][0-9][0-9][0-9][0-9]$\n\n2. Develop a regular expression to verify that the domain name of this web server is in the"
            }
        ]
    },
    {
        "expression": "@{2}((\\S)+)@{2}",
        "raw_prompt": "This will match results in a template situation. For example:\ntemplate reads\nDear @@Name@@,\n....\nwould become\nDear John,\nIf you dont want to use the @@ change the @ to what ever characters you want.",
        "refined_prompt": "This regular expression matches and captures any text enclosed by two consecutive \"@\" symbols, where the enclosed text consists of one or more non-whitespace characters. Spaces inside the enclosed text are not allowed for a match.\nMatch examples:\n- \"@@test@@\"\n- \"@@name@@\"\n- \"@@2342@@\"\nNon-match examples:\n- \"@test@\"\n- \"@@na me@@\"",
        "matches": [
            "@@test@@",
            "@@name@@",
            "@@2342@@",
            "@@sjdfkl@@",
            "@@09fjdo@@",
            "@@09fojdkms@@",
            "@@fjlsk09@@",
            "@@$)(@@",
            "@@ifdsjo@@",
            "@@90jgdf0g9jf0@@",
            "@@65416546@@",
            "@@986512huijkn@@",
            "@@56853@@"
        ],
        "non_matches": [
            "@test@",
            "@@na me@@",
            "@@ name@@",
            "@@fdiushj iofsdkj@@",
            "@@Oivjk af ajasdh !!@@",
            "@@Oifsd fsijdk @@",
            "@@.  @@@",
            "jikfdl@ JFLKDSJ@ JKDFS@@",
            "qwerty@123.123",
            "@hfu8dij89hi@",
            "@)IJKNOVDF@",
            "@JIOFKDJOI@"
        ],
        "id": 158,
        "output": [
            {
                "text": " Regex: @(((?:.+?)\\W ){0, 2}(?:,|$))@"
            },
            {
                "text": " (?<!@)@(?!\\S)\n\n### Example 2: Matching any word, with optional"
            },
            {
                "text": " @\\w+@\n\n4. Write a Python script that takes a filename as input and generates a list of all"
            },
            {
                "text": "\n```python\nimport re\n\nsentence = \"Hello @test@ and nice @name@\"\npattern"
            },
            {
                "text": " @test@@\n\nExercise 3: Use List Comprehension to retrieve all email addresses from the following text: \""
            },
            {
                "text": " @(?<!\\S#?-)(?<!#)#(?!@)\n\nExercise"
            },
            {
                "text": " @\\S*@@\n3. The ^(?=[a-z])(?=\\d)(?="
            },
            {
                "text": "\nimport re\ns = \"@@test@@\"\nr = re.compile(\"@@(..)?@@\")"
            },
            {
                "text": "\n\nimport re\ntext = \"In this class we will learn how to use Python to create and display text. It"
            },
            {
                "text": " @(\\S+)@@\n\nExercise 5:\nWrite a Python program that replaces all occurrences of the string \"hello"
            }
        ]
    },
    {
        "expression": "[A-Z][a-z]+",
        "raw_prompt": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within 'strFirstName'.",
        "refined_prompt": "This regular expression matches one or more consecutive letters in a string, where the first letter is uppercase (A-Z) and the subsequent letters are lowercase (a-z).\nMatch examples:\n- \"strFirstName\"\n- \"intAgeInYears\"\n- \"Where the Wild Things Are\"\nNon-match examples:\n- \"123\"\n- \"abc\"",
        "matches": [
            "strFirstName",
            "intAgeInYears",
            "Where the Wild Things Are",
            "fdsklAfsdj",
            "sfdkjAfdsjo",
            "dfsjoijAfodisdn",
            "nfijgOiusdf",
            "knjdsEfosidj",
            "jksdfnYfidso",
            "vbmnWihuh",
            "ifdUfsjido",
            "bhvUfsjido",
            "jiofdsUfs"
        ],
        "non_matches": [
            "123",
            "abc",
            "this has no caps in it",
            "ifojd",
            "oifjd",
            "kgodf",
            "ngfjdn2039r",
            "ijok",
            "432/524/2435",
            "com.edu.github",
            "abc111def",
            "99999@gmail"
        ],
        "id": 161,
        "output": [
            {
                "text": " \n[A-Z][A-Za-z0-9 ]* \nThe double underscores represent a range of letters (and digits), and"
            },
            {
                "text": " (?:(?:^|\\s)\\\\w+(?:\\s|$))+\nExplanation: A positive lookahead is used to match at"
            },
            {
                "text": " (?!^)([A-Z])([a-z])+\n\n2. \"The cat in the hat\" should match \"cat\", \""
            },
            {
                "text": " \"^[a-zA-Z]{1,2}\\d$\"\n\n### Exercise 3\nWrite a RegEx expression that matches strings that"
            },
            {
                "text": " re.compile(r\"[a-z][b-zA-Z]*\")\n\nExercise 4: \nFind the index of the"
            },
            {
                "text": " ^[a-zA-Z][a-zA-Z\\s\\S]*$\n\n3. Write a regular expression that matches any"
            },
            {
                "text": " A regular expression to match 3 letter combinations with the first letter uppercase and the remaining letters lowercase. The expression would be something like \"^[A-"
            },
            {
                "text": " I know the pattern will match one or more consecutive digits\nI thought I was on the right path. I have an answer that contains a very complicated and messy regular"
            },
            {
                "text": " (\\d)+,(\\d)+,.*$\nQuestion 3:\nGiven a list of numbers, use a RegEx to extract all the even numbers."
            },
            {
                "text": " \\d{3,4}\n\n4. Given a string of text with phone numbers in the format \"xxx-xxx-xxxx\", write a regex that"
            }
        ]
    },
    {
        "expression": "^[+-]?([0-9]*\\.?[0-9]+|[0-9]+\\.?[0-9]*)([eE][+-]?[0-9]+)?$",
        "raw_prompt": "A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form.",
        "refined_prompt": "A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form.\nMatch examples:\n- \"23\"\n- \"-17.e23\"\n- \"+.23e+2\"\nNon-match examples:\n- \"+.e2\"\n- \"23.17.5\"",
        "matches": [
            "23",
            "-17.e23",
            "+.23e+2",
            "312",
            "784639",
            "+423",
            "-234798",
            "+324.234",
            "-234.243",
            "432",
            "4987.42",
            "-2423",
            "0"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0",
            "12/123/4322",
            "234/423/5243",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "354/243/542",
            "9/9/9",
            "++63453.345"
        ],
        "id": 162,
        "output": [
            {
                "text": " RegEx: \".*[.]0-9]+e[0-9]+\"\n\n\n\nOnce upon a time in a distant galaxy, there was an alien named Zog. Zog was fascinated by the concept of politics"
            },
            {
                "text": " [\\+-]?[0-9]+(\\.[0-9]+)? \n- Create a list with 3 possible match results from the previous example.\nAnswer: [23, -17, +234]\n"
            },
            {
                "text": " [\\d]{2,}\\.\\d*e[\\+-]\\d+ \n\nExercise 3: \nGiven the exponential function 2^x, write a regular expression in Python that matches any string"
            },
            {
                "text": " The regular Expression is \"r'^[-+]?\\d*\\.\\d+|[-+]?\\d+'\".\n\nIn conclusion, with the help of Python, we can better understand how expressions work and"
            },
            {
                "text": "\nimport re\nword = input(\"Enter your text: \")\npattern = \"^\\\\d+(\\\\.\\\\d*)?\\\\([+-]\\\\d+\\\\)$\" \nprint(pattern.findall"
            },
            {
                "text": " \\b[+\\-]?\\d*?\\.?\\d*?[eE][+-]?\\d+\nExercise 2: Write a regex for extracting the first number followed by the unit from an expanded"
            },
            {
                "text": " (0+)\\.([0-9]+)\n\nStudent: Hello! I have some questions about the string module. Specifically, I'm trying to replace parts of a string with regular expressions. I've looked up how to"
            },
            {
                "text": " (?i)(?<!\\.e(?=[1-9]))([-+.](?!\\d))*\n\n**Exercise 3:**\n\nDevelop a regular expression that would detect all the HTML comments in"
            },
            {
                "text": " \"^[\\+-]?\\d+(\\.\\d{0,2})?$\"\n\n\n\nQuestion 5: A recipe requires 4 cups of flour to make 24 cookies. If you want to make 48 cookies"
            },
            {
                "text": " ^(\\d+)\\.(\\d+)+e\\s?(\\d+)$(?:\\s?e\\+?\\s?(\\d+)?)? \n\nExample 3:\n\nSuppose you want"
            }
        ]
    },
    {
        "expression": "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})",
        "raw_prompt": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:\n$date = &quot;2003-12-03&quot;;\nif (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs))\n{\necho &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003\n}",
        "refined_prompt": "This regular expression is used to validate and capture data that follows the specific pattern of dates in the YYYY-MM-DD format(could also be single M or single D), where each component is represented by digits.\nMatch examples:\n- \"2002-11-03\"\n- \"2007-17-08\"\n- \"9999-99-99\"\nNon-match examples:\n- \"2002/17/18\"\n- \"2002.18.45\"",
        "matches": [
            "2002-11-03",
            "2007-17-08",
            "9999-99-99",
            "3245-35-4",
            "1639-9-7",
            "7086-8-76",
            "6204-6-5",
            "1506-78-1",
            "4609-76-6",
            "0837-03-3",
            "7018-59-67",
            "5888-2-5",
            "9104-82-3"
        ],
        "non_matches": [
            "2002/17/18",
            "2002.18.45",
            "18.45.2002",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/956123",
            "12/132/90"
        ],
        "id": 169,
        "output": [
            {
                "text": "\n(0.|[1-9])?[0-9"
            },
            {
                "text": " (.*)\n**Note**: This regex will capture all the components"
            },
            {
                "text": " \n'(?i)(?!.*\\.\\d)20["
            },
            {
                "text": " [0-9]{4}-([0-9]{"
            },
            {
                "text": "\nMy regex pattern is\n^[0-9]{4}."
            },
            {
                "text": " \n([1-9]\\d{2})-([0"
            },
            {
                "text": " \"^\\d\\d\\d-\\d\\d-\\"
            },
            {
                "text": ".{0,2}-(?P<year>[0-9"
            },
            {
                "text": " ^\\d{4}-\\d{2}-\\d"
            },
            {
                "text": " \\d{4}-\\d{1,2}-\\"
            }
        ]
    },
    {
        "expression": "^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$",
        "raw_prompt": "This matches an IP address, putting each number in its own group that can be retrieved by number. If you do not care about capturing the numbers, then you can make this shorter by putting everything after ^ until immediately after the first \\. in a group ( ) with a {3} after it. Then put the number matching regex in once more.\nIt only permits numbers in the range 0-255.",
        "refined_prompt": "This matches an IP address, putting each number in its own group that can be retrieved by number. It only permits numbers in the range 0-255.\nMatch examples:\n- \"0.0.0.0\"\n- \"255.255.255.02\"\n- \"192.168.0.136\"\nNon-match examples:\n- \"256.1.3.4\"\n- \"023.44.33.22\"",
        "matches": [
            "0.0.0.0",
            "255.255.255.02",
            "192.168.0.136",
            "255.48.254.51",
            "207.44.252.62",
            "251.105.231.237",
            "162.255.255.250",
            "255.141.207.148",
            "165.207.209.253",
            "208.145.16.255",
            "154.107.247.176",
            "250.118.209.223",
            "254.64.74.50"
        ],
        "non_matches": [
            "256.1.3.4",
            "023.44.33.22",
            "10.57.98.23.",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "2565.48.254.51",
            "207.464.252.62",
            "251.1075.231.237",
            "162.2455.255.250",
            "255.141.207.1488",
            "165.207.2049.253"
        ],
        "id": 170,
        "output": [
            {
                "text": " \"^[^.][0-9]{0,3}[^.]["
            },
            {
                "text": " [0-9][0-9][0-9][0-9]\\.["
            },
            {
                "text": " \\d(\\.\\d){4}\n\n3) How do we match a date"
            },
            {
                "text": " \\b[0-9]\\.([0-9]{1,3}\\"
            },
            {
                "text": " *.*.*.*.*.*.*\n(.*) --> Captures a group with any amount"
            },
            {
                "text": " [^0-9]\nThe RegEx you came up with is correct, [^"
            },
            {
                "text": " [0-9]{1,3}\\.[0-9]{1,3"
            },
            {
                "text": " (0|1)..(1|2)..(2|3)..("
            },
            {
                "text": " *(.*)\\.(.*)\\.(.*)\\.(.*)\\.(.*)$\n\n"
            },
            {
                "text": " [0-9]\\.[0-9]\\.[0-9]\\.["
            }
        ]
    },
    {
        "expression": "^\\$?([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$",
        "raw_prompt": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and .0 Keywords: money dollar currency",
        "refined_prompt": "This regular expression is used to validate and capture monetary values, including both whole numbers and decimal values, with optional commas as thousands separators and an optional dollar sign at the beginning.\nMatch examples:\n- \"$1,234.50\"\n- \"$0.70\"\n- \".7\"\nNon-match examples:\n- \"$0,123.50\"\n- \"$00.5\"",
        "matches": [
            "$1,234.50",
            "$0.70",
            ".7",
            "$56",
            "$456123",
            "$7",
            "$7845",
            "$79",
            "$100",
            "$0.78",
            "$1.19",
            "$43.78",
            "$54.32"
        ],
        "non_matches": [
            "$0,123.50",
            "$00.5",
            "$645123.4561",
            "$4561.$9856",
            "$4561.4561",
            "$89456.541",
            "$897.8946",
            "$98.456",
            "$000.000",
            "$8495.4895162",
            "$Y*(UHIJKN",
            "$Jioklmfds"
        ],
        "id": 172,
        "output": [
            {
                "text": " \\$[0-9.]*(?:\\.[0-9.,]*)?(?:,|$)\n\nExercise 2:"
            },
            {
                "text": " \n-\\d{1,3}(-\\d{3})?(.\\d*)?$\n\nExercise 5:\n"
            },
            {
                "text": " [\\d.]+\n\nExercise 3:\nCreate a global pattern that matches all lines containing the word \"password\".\nAnswer: ^password"
            },
            {
                "text": " [0-9]{3,3}(?:[,.]{3})?(?:[,.]{2})[0-9"
            },
            {
                "text": " ([$][0-9]{3,3}.\\d{3})%\n3. Write a regular expression that captures all numbers with exactly"
            },
            {
                "text": " \\$(\\d+\\.\\d{0,2}\\,?)*\\$\n\nExercise 4:\nWrite a regular expression validating"
            },
            {
                "text": "\n# Generate a RegEx for validating and capturing monetary values, including whole numbers and decimal values, and optionally with commas as thousands separators"
            },
            {
                "text": " [0-9]+(?:[,.][0-9]+)?\nIn this example, we can match both standard decimal notation and decimal notation"
            },
            {
                "text": " ((.\\d+)\\d\\d?(?:[.,](\\d+)?[.,])?)\n\n###Exercise 5:\n"
            },
            {
                "text": " [0-9]+(?:\\.[0-9]+)?|\\.[0-9]+(?:\\.[0-9]+)?)"
            }
        ]
    },
    {
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))-((0[1-9])|(1[0-2])))|((31-((0[13578])|(1[02])))|((29|30)-((0[1,3-9])|(1[0-2])))))-((20[0-9][0-9]))|(29-02-20(([02468][048])|([13579][26]))))$",
        "raw_prompt": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.",
        "refined_prompt": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.\nMatch examples:\n- \"05-01-2002\"\n- \"29-02-2004\"\n- \"31-12-2002\"\nNon-match examples:\n- \"1-1-02\"\n- \"29-02-2002\"",
        "matches": [
            "05-01-2002",
            "29-02-2004",
            "31-12-2002",
            "29-02-2052",
            "29-02-2008",
            "31-03-2079",
            "29-02-2016",
            "29-02-2040",
            "26-03-2049",
            "22-12-2096",
            "24-12-2082",
            "29-10-2053",
            "30-01-2027"
        ],
        "non_matches": [
            "1-1-02",
            "29-02-2002",
            "31-11-2002",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 173,
        "output": [
            {
                "text": " \\d[1-9]|[1-2][0-9]|3[01]\n\nExercise 4: Write a Python function"
            },
            {
                "text": " \\d\\d-\\d\\d-\\d\\d\n\n4. Write a RegEx for email validation.\nAnswer:\n^["
            },
            {
                "text": "\n(5) (1) (1)?-?0(1)?-?0(1)?-?0(1)?-?0?"
            },
            {
                "text": " \"([0-3][0-9])-(0[1-9]|1[0-2])-(\\d{4})$\""
            },
            {
                "text": " \\d{1,2}\\s?[-/+]?\\d{1,2}\\s?[-/+]?\\d"
            },
            {
                "text": " (re)^(01[1-9]|[2][0-9]|0[1-9])-(0[1-9"
            },
            {
                "text": " ^(0[1-9]|[12][0-9]|3[01])[0-9]-[0-9]-["
            },
            {
                "text": " dd-mm-yyyy\n\n__Exercise 4:__ You have a string that needs to be extracted to obtain a list of countries where the value"
            },
            {
                "text": " (\\w\\d?-\\d?-\\d\\d\\d\\d\\d)\nThis regex will match any date string that has"
            },
            {
                "text": " /[5]?-?[1-9]\\d{2}\\-\\d{2}\\-\\d{4}/g\n"
            }
        ]
    },
    {
        "expression": "^\\d*[0-9](|.\\d*[0-9]|,\\d*[0-9])?$",
        "raw_prompt": "This is permit all decimal number, exclude all alphanumeric caracter",
        "refined_prompt": "This regular expression is used to validate decimal numbers that can have an optional leading zero, at least one digit before and after the decimal point (if present), and may allow for either a dot or comma as a decimal separator. Excludes all alphanumeric character\nMatch examples:\n- \"123456.123456\"\n- \"123456,123456\"\n- \"123456\"\nNon-match examples:\n- \"123a.123\"\n- \"123a,123\"",
        "matches": [
            "123456.123456",
            "123456,123456",
            "123456",
            "48651.498653",
            "48.94865",
            "489561",
            "4856.48956",
            "651.89456",
            "465.4651",
            "798.498",
            "48.1",
            "456.64865",
            "12315"
        ],
        "non_matches": [
            "123a.123",
            "123a,123",
            "a",
            "2rf",
            "8561hui",
            "huiy8hiu",
            "6r5tfy",
            "09iop",
            "78yui",
            "65rtfy9hiu",
            "0u9ioj5dr",
            "6tfy"
        ],
        "id": 174,
        "output": [
            {
                "text": " ^(?=.{1,20}$)("
            },
            {
                "text": " ^[1-9][0-9](?:("
            },
            {
                "text": " [a-zA-Z0-9_.]"
            },
            {
                "text": " This regular expression is used to validate decimal numbers that start with"
            },
            {
                "text": " (.{1,5})\n\nExercise 2:"
            },
            {
                "text": " ^(\\d*)(\\d+\\.\\d+)"
            },
            {
                "text": " \n\\b\\d*(?:\\.\\"
            },
            {
                "text": " \n^(?=(0[1-9]["
            },
            {
                "text": " \\d[.]\n\n3. The following regular expression"
            },
            {
                "text": "\nregex = re.compile('^[0"
            }
        ]
    },
    {
        "expression": "^([A-Z]{1,2}[0-9]{1,2}|[A-Z]{3}|[A-Z]{1,2}[0-9][A-Z])( |-)[0-9][A-Z]{2}",
        "raw_prompt": "Checks whether the string specified is in the same format as the UK postcode format defined on:\nhttp://www.magma.ca/~djcl/postcd.txt\nIt allows:\nA = Letter\nN = Number\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\n(restriction is set to all-capitals)",
        "refined_prompt": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1AA\"\n- \"A11-1AA\"\nNon-match examples:\n- \"111 AAA\"\n- \"1AAA 1AA\"",
        "matches": [
            "AA11 1AA",
            "AA1A 1AA",
            "A11-1AA",
            "RL9Z-9QZ",
            "YDV 2UK",
            "VLL-5YA",
            "XVZ 9MZ",
            "QIC 5VM",
            "E9L-5SC",
            "HQB-7LD",
            "AH3T-6QM",
            "TVB-3SB",
            "FQ0D-1KX"
        ],
        "non_matches": [
            "111 AAA",
            "1AAA 1AA",
            "A1AA 1AA",
            "12/123/4322",
            "sfalijad234",
            "FSDA23R 223RR",
            "23RE2",
            "R2E2R3",
            "R32 FE FE2 2E",
            "F2E3 F2F2 DF",
            "FSG- FD3 D. F3D",
            "F33 E"
        ],
        "id": 176,
        "output": [
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A11"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 00"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 0"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 01"
            }
        ]
    },
    {
        "expression": "<img([^>]*[^/])>",
        "raw_prompt": "Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.",
        "refined_prompt": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*gTm.e+>\"\nNon-match examples:\n- \"<img fq3f3/>\"\n- \"<img3/>frf\"",
        "matches": [
            "<img src=\"bob\">",
            "<img%(\"]jCkOZt=1uT_Rl>",
            "<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*gTm.e+>",
            "<imgZ!{kLm.L4;??2hErM1L0bu$t:Ju9IoTmJGMb LNHRZ9_>",
            "<img]g6OQ8.sV}Q+NGbG69ds`NAn\\KCBmRs>",
            "<img:O+/((3E|jka`>",
            "<img~'S[fwY$?V1X4<Gez0NW\\q7C6K7sPEY\"*98V; ]'>",
            "<imgfl;j#j'BG/hZ^\\JrrpY8e|1)d.&4<u!rf[w<\\}4~rV|^tiT\\RmpxFIPrA]T^YY~)jO[J#isCg861nDX>",
            "<imgY U']m_Ks1Ntyd7+W8-X\"O.Bj9t2J>",
            "<img3}b!^.6q`] IkGZmHz!]j:TE*3{6?=;X?\"'WiD<_DV4N^Jm]t->",
            "<imgo?5p%=&b6T:l,B}a[j;}$1\"*No(5/`.+?0CCw,]7X{*P-9rmzB=Rz?N,dtiM{VqHzXv3YU\"'3AQ_r>",
            "<imgU_w]O2Xg\"TK5@N'otO =K{X46R)8$h`^6W2oD| RDi#(!Kg%]-lgrLUE:QLNiAq<#nYTVX(n*#av>",
            "<img$NJJ++huA]g S\"jM_2FX-2zMA]z9)${k8^`q#(PXgpq>"
        ],
        "non_matches": [
            "<img fq3f3/>",
            "<img3/>frf",
            "<img src=dbfadsfb\" />",
            "<img srafdsb\" />",
            "<img 44src3=\"bfobf3\" />",
            "<img s43f34rcf\"3of\" />",
            "<img 3f4efad=\"bob\" />",
            "<img src=\"dsfda\" />",
            "<img sfadsfc=\"bafadsob\" />",
            "<iafdsf src=\"fadsfadafw\" />sd",
            "<imadsfadsf",
            "<iab\" />df"
        ],
        "id": 183,
        "output": [
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*&"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*]"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*D"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*%"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*c"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*+"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*>"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*r"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*~"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*]"
            }
        ]
    },
    {
        "expression": "^((0?[1-9])|((1|2)[0-9])|30|31)$",
        "raw_prompt": "matches any day of\nmonth 0?1-31",
        "refined_prompt": "This regular expression is designed to match and validate day numbers within a month, allowing values from 1 to 31. It takes into account single-digit days (1-9), double-digit days (10-29), and specific values for the 30th and 31st days of a month.\nMatch examples:\n- \"01\"\n- \"12\"\n- \"31\"\nNon-match examples:\n- \"123\"\n- \"32\"",
        "matches": [
            "01",
            "12",
            "31",
            "02",
            "5",
            "7",
            "29",
            "09",
            "24",
            "27",
            "09",
            "16",
            "18"
        ],
        "non_matches": [
            "123",
            "32",
            "abc",
            "9786",
            "375",
            "312",
            "732",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "9/9/9",
            "12/132/90"
        ],
        "id": 184,
        "output": [
            {
                "text": " \\b(?!0[2-9]|1[0-2]|100[0"
            },
            {
                "text": " The regex will be r\"(0[1-9])|1[0-2]\" or \""
            },
            {
                "text": " (\\d{2})([A-Z]\\d{2})?\n\nEx"
            },
            {
                "text": "\n\n```python\ndef valid_day(day):\n    r = r'^("
            },
            {
                "text": " \n\\d{1,2}|\\d{2,3}\\d|31"
            },
            {
                "text": "\n- r'\\b0[1-9]\\d?\\d[1-9"
            },
            {
                "text": " ^\\d|1[0-2]\\d$ (any digit) or 30|31"
            },
            {
                "text": "  \\d(?:1?\\d)?\\,  \n\n5. Exercise 3: Use"
            },
            {
                "text": " *(0|[1-9][0-9]?)(\\.[0-9]{"
            },
            {
                "text": "\nRegular Expression Pattern: \\d\\d\nExplanation: This regular expression matches any day number"
            }
        ]
    },
    {
        "expression": "&lt;!--[\\s\\S]*?--&gt;",
        "raw_prompt": "Removes pesky comments and commented javascript from HTML",
        "refined_prompt": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"",
        "matches": [
            "&lt;!-- comments --&gt;",
            "&lt;!-- x = a &gt; b - 3 --&gt;",
            "&lt;!----&gt;",
            "&lt;!--:|5V\f~03bL\u2008\\EqBNWd8\u2007kVD\u2005bA\u000b\u200ad\u200aam\u00a0,\f\u2001~i}1l--&gt;",
            "&lt;!--E;!\u202f6:VZw[tv\\\u2029*aO7Q=^QAQ\u2001\u2006]a\fWy}2\u1680^{9iI:A@[,W]?J\u2006--&gt;",
            "&lt;!----&gt;",
            "&lt;!--|iTa\u2029v9r^\u2028\u2006al--&gt;",
            "&lt;!--\f~lP\u2028^c\u2002vXV]ZhZ[6\u2005\u2004s{97U\u2002:xE)\u3000\u3000f5#zfF0`L5g,\u180e'M!k H|\\4\u2003v\u1680eJE }\u2005J\u180eod8D+.~8ObRPZ6MUS,'.\ufeff@'/--&gt;",
            "&lt;!--:[(5B,H~rg!b_i--&gt;",
            "&lt;!--^t_@E{5\" ^m\u202fN\u2009A,\u2004\ufefft~n\u2006RE{EUUW,\u2005g 'T\u2029I:_=q\u205f+F,`JKa\u2009--&gt;",
            "&lt;!--K?1.j{--&gt;",
            "&lt;!--Ky1I?\u2002\u2005}?[[m-x$DV1M3\u2003Dh6fU--&gt;",
            "&lt;!--0\u1680|--&gt;"
        ],
        "non_matches": [
            "&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;",
            "f34fvfv",
            "34f2vf42e",
            "fasd@fds.fasd@",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "9/9/9",
            "++63453.345"
        ],
        "id": 185,
        "output": [
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx to"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx matching"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx that"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx which"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx pattern"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx pattern"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx which"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx from"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx that"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx that"
            }
        ]
    },
    {
        "expression": "^\\{?[a-fA-F\\d]{8}-([a-fA-F\\d]{4}-){3}[a-fA-F\\d]{12}\\}?$",
        "raw_prompt": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.",
        "refined_prompt": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0e400ad090Ac0300d00a0008ba0\"\n- \"f34fvfv\"",
        "matches": [
            "{e02ff0e4-00ad-090A-c030-0d00a0008ba0}",
            "e02ff0e4-00ad-090A-c030-0d00a0008ba0",
            "29BF7EaE-e661-BDcd-deBB-F9097812DFC6}",
            "f5cA4FEa-CCbF-dBad-cdCa-1BCbB4a6Ee8B}",
            "509ECac0-DB2A-a6C8-7CF6-189550d7f98b",
            "{05d00ef3-a644-bAbd-dEeB-1Dfa01BcbA6C}",
            "{45dEac1b-7865-c206-091c-fd0CF3a8b8cA}",
            "{5d5f787f-9Dcd-9a72-5906-2e0Bc134c5b4}",
            "Fdce4AFf-5085-0971-89d5-FaB0B19B68F6}",
            "D62ba90C-D5a8-ba2A-1214-a1D7A8a09D73}",
            "803f9Fa3-5eA4-3c89-68Ae-df01269e4A13}",
            "{4644867d-2Fa5-07D5-a8Ec-bb1cB4b1f6de}",
            "{6599E4d2-9fB8-9a6D-B0Cc-dd8eAB6959D4}"
        ],
        "non_matches": [
            "0xe02ff0e400ad090Ac0300d00a0008ba0",
            "f34fvfv",
            "34f2vf42e",
            "Mastercard",
            "234/423/5243",
            "43.v234",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 187,
        "output": [
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff05"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff01"
            }
        ]
    },
    {
        "expression": "(\\d*)'*-*(\\d*)/*(\\d*)&quot;",
        "raw_prompt": "This regular expression is for parsing feet and inches measurements.",
        "refined_prompt": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"",
        "matches": [
            "5'-3/16&quot;",
            "1'-2&quot;",
            "5/16&quot;",
            "5'-3/16&quot;",
            "1'-3&quot;",
            "5/15&quot;",
            "5'-3/15&quot;",
            "2'-4&quot;",
            "7/14&quot;",
            "6'-3/14&quot;",
            "4'-3&quot;",
            "8/12&quot;",
            "7'-3/14&quot;"
        ],
        "non_matches": [
            "1 3/16",
            "52/2/54/245",
            "34f2vf42e",
            "-123",
            "2346-2345-2435",
            "2/3/5235",
            "@#dfkjnav",
            "98iojk",
            "u09nKLJG FSL",
            "(0xx12) 7256 2345154",
            "abc111def",
            "99999@gmail"
        ],
        "id": 191,
        "output": [
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx Object"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx parser"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx object"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx\n"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx that"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx to"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx pattern"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx that"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx Match"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx that"
            }
        ]
    },
    {
        "expression": "^(/w|/W|[^<>+?$%{}&])+$",
        "raw_prompt": "simple expression for excluding a given list of characters. simply change the contents of [^] to suite your needs. for example ^(/w|/W|[^&lt;&gt;])+$ would allow everything except the characters &lt; and &gt;.",
        "refined_prompt": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"",
        "matches": [
            "John Doe Sr.",
            "100 Elm St., Suite 25",
            "Valerie's Gift Shop",
            "wtrewrt",
            "terwtw",
            "fdgsy",
            "nfju7",
            "kuyk678",
            "jk7jkj",
            "42309ion",
            "23c2d",
            "c237mu78",
            "mk78m78"
        ],
        "non_matches": [
            "<h1>Hey</h1>",
            "<h1>adsfa</h1>",
            "<h1>Hgafdgqrey</h1>",
            "<h1>trebd</h1>",
            "<h2>HIUJKNFSDfsd</h2>",
            "<h2>adsga</h2>",
            "<h2>HIgfda24gSDfsd</h2>",
            "<h2>HgfdfdFSDfsd</h2>",
            "<h2>HIUregfSDfsd</h2>",
            "<h2>HIUJfaddSDad</h2>",
            "<h3>HIUJKNfsgFSDfsd</h3>",
            "<h3>HIUsd</h3>"
        ],
        "id": 192,
        "output": [
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for a"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for your"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for these"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for valid"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for a"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for email"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for \""
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for a"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for this"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for checking"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{4})$",
        "raw_prompt": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.\nMatch examples:\n- \"12/2002\"\n- \"11/1900\"\n- \"02/1977\"\nNon-match examples:\n- \"1/1977\"\n- \"00/000\"",
        "matches": [
            "12/2002",
            "11/1900",
            "02/1977",
            "08/3420",
            "08/0126",
            "12/5637",
            "11/2207",
            "07/4032",
            "08/9881",
            "04/1760",
            "12/3648",
            "03/3980",
            "11/2966"
        ],
        "non_matches": [
            "1/1977",
            "00/000",
            "15/2002",
            "12/44322",
            "423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "524/125",
            "243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 197,
        "output": [
            {
                "text": "  1/\\d{4}\n2. \"1,0,0,0,0,0\"  Generate a RegEx for this description.\nAnswer:  0+,0"
            },
            {
                "text": " \n(?P<Month>0|1)\\d\\d/\\d\\d\n\nExercise 2:\nMatch this string: \n\n\"Today's date is 12/"
            },
            {
                "text": " ^(?:(?i)(1(?=\\d)|(?<=\\d)1))(?:\\/((?=\\d)|(?<=\\d)2"
            },
            {
                "text": " \"00[1-9][012]/[012][1-9]\" is a regular expression that will match dates starting with the year of 01 to 12.\n\nExample 3:\nWrite"
            },
            {
                "text": " \"\\\\d{1,2}\\\\/\\\\d{4}\"\n\nExercise 4:\nWrite a Python function that takes in a date string (in the format MM/YYYY),"
            },
            {
                "text": " [0-9][0-9/][0-9]/[0-9][0-9]\n\n```python\npattern = '^[0-9][0-"
            },
            {
                "text": " 0?[1-9]?[0-9]/[1-9]?[0-9]\n\n5. Write a Python program to create a RegEx to validate an"
            },
            {
                "text": " (This was my solution; you can try it with a different approach if you find one)..*.?[0-9]{4}[.]?[0-9]{2}"
            },
            {
                "text": " [1-9]/[1-2][0-9]([0-9]{3}|0)[0-9]\\\n\nExercise 3:\nRegular expressions can"
            },
            {
                "text": " /(19[0-9]|20[0-2])/\n- \"12/2000-12/2001\"   Generate a RegEx for this description. \nAnswer:"
            }
        ]
    },
    {
        "expression": "^[A-Z]{2}[0-9]{6}[A-DFM]{1}$",
        "raw_prompt": "UK National Insurance Number (NINO) validation. (The following modifications have been made: Only A to D are permitted as the last letter, and all letters should be in uppercase. For temporary numbers F and M are permitted for female and male holders.)",
        "refined_prompt": "This regular expression pattern matches a string that starts with two uppercase letters, followed by six digits, and ends with one uppercase letter, where the last uppercase letter can be either A, B, C, D, F, or M.\nMatch examples:\n- \"AB123456D\"\n- \"AB123456F\"\n- \"AB123456M\"\nNon-match examples:\n- \"AB123456E\"\n- \"ab123456d\"",
        "matches": [
            "AB123456D",
            "AB123456F",
            "AB123456M",
            "WC814828B",
            "YH034681A",
            "EA644426C",
            "TT066542C",
            "XU041456F",
            "WN058798C",
            "FI196873F",
            "GW600487D",
            "JZ932005C",
            "AY600596M"
        ],
        "non_matches": [
            "AB123456E",
            "ab123456d",
            "34f2vf42e",
            "12/123/4322",
            "sfalijad234",
            "AB123456P",
            "AB123456Q",
            "AB123456R",
            "AB123456S",
            "AB123456a",
            "AB123456b",
            "AB123456c"
        ],
        "id": 202,
        "output": [
            {
                "text": " Regex: [BR]aB\\d{6"
            },
            {
                "text": " (AB[A-Z]\\d{6}"
            },
            {
                "text": " [A-F]\\d{6}[A"
            },
            {
                "text": " \\D\\w\\d\\d\n\nExercise"
            },
            {
                "text": "\n\n(AB\\d{6}\\w)+("
            },
            {
                "text": " [A-Z]{6}[0-9"
            },
            {
                "text": " \"^[AB]0{6}\\d[AB"
            },
            {
                "text": " ^[A-Z]{2}\\d{6"
            },
            {
                "text": " This pattern matches a string that starts with two uppercase"
            },
            {
                "text": " ABCDEF01\n\n5) Write a RegEx pattern"
            }
        ]
    },
    {
        "expression": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0-1]\\d|[2][0-3])(\\:[0-5]\\d){1,2})?$",
        "raw_prompt": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\nIt can validate date from 1600 to 2199.",
        "refined_prompt": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\nNon-match examples:\n- \"13/30/2002\"\n- \"01/12/1998 24:30\"",
        "matches": [
            "12/30/2002",
            "01/12/1998 13:30",
            "01/28/2002 22:35:00",
            "11/30/1760",
            "05/31/2140 00:11",
            "11/31/2015",
            "12/30/1644 22:10",
            "10/30/2184\u202812:39",
            "12/15/1973",
            "10/15/1607",
            "10/01/2053",
            "11/30/1609",
            "03/06/1632"
        ],
        "non_matches": [
            "13/30/2002",
            "01/12/1998 24:30",
            "01/28/2002 22:35:64",
            "12/123/4322",
            "234/423/5243 13:30",
            "2/3/5235",
            "/5/5/5 13:30",
            "/5/5/20022",
            "432/524/2435 22:35:00",
            "354/243/542",
            "9/9/2009 22:35:64",
            "12/132/90 22:35:00"
        ],
        "id": 204,
        "output": [
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n\n"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n\n"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n\n"
            }
        ]
    },
    {
        "expression": "^((0?[13578]|10|12)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1}))|(0?[2469]|11)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1})))$",
        "raw_prompt": "improved date validation M/D/YY or M/D/YYYY or MM/DD/YYYY or MM/DD/YY: 1/1/1920 through 12/31/2019; Feb 29 and 30 always allowed, deal with it",
        "refined_prompt": "Date validation M/D/YY or M/D/YYYY or MM/DD/YYYY or MM/DD/YY: 1/1/1920 through 12/31/2019; Feb 29 and 30 always allowed.\nMatch examples:\n- \"1/2/03\"\n- \"02/30/1999\"\n- \"3/04/00\"\nNon-match examples:\n- \"3/4/2020\"\n- \"3/4/1919\"",
        "matches": [
            "1/2/03",
            "02/30/1999",
            "3/04/00",
            "10/1/1967",
            "09/7/1985",
            "06/3/98",
            "10/3/2002",
            "2/06/2001",
            "10/2/17",
            "1/5/94",
            "10/07/96",
            "7/2/1967",
            "10/1/1967"
        ],
        "non_matches": [
            "3/4/2020",
            "3/4/1919",
            "4/31/2000",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 209,
        "output": [
            {
                "text": " /\\b(?:1(?:\\/2|"
            },
            {
                "text": " \\b(?:[\\d]{1}\\s"
            },
            {
                "text": "\n\nI can use the RegEx \\d [D"
            },
            {
                "text": " ^\\d{2}\\/\\d{2}"
            },
            {
                "text": " (Regular expression allowed) /(12|13|2014"
            },
            {
                "text": "\n1([0-2][0-9])|"
            },
            {
                "text": " [01/02/yyyy][0-9]"
            },
            {
                "text": " \nMyRegex_DateFormat = Regexp"
            },
            {
                "text": " (?<!\\d{4})\\d{"
            },
            {
                "text": " (\\d+)/(\\d+)/(\\d+"
            }
        ]
    },
    {
        "expression": "^(([0]?[1-9]|1[0-2])(:)([0-5][0-9]))$",
        "raw_prompt": "This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59. This is primarily for use with an AM/PM drop down list or radio button.",
        "refined_prompt": "This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59.\nMatch examples:\n- \"09:00\"\n- \"9:00\"\n- \"11:35\"\nNon-match examples:\n- \"13:00\"\n- \"9.00\"",
        "matches": [
            "09:00",
            "9:00",
            "11:35",
            "12:26",
            "9:39",
            "04:04",
            "09:22",
            "11:58",
            "5:50",
            "05:02",
            "12:02",
            "08:06",
            "12:54"
        ],
        "non_matches": [
            "13:00",
            "9.00",
            "6:60",
            "12:78",
            "9:97",
            "34:04",
            "6022",
            "121:58",
            "5.50",
            "05:545",
            "12:022",
            "342"
        ],
        "id": 211,
        "output": [
            {
                "text": " [1-9]\\d|[1,2-9]\\d\\d\n    The following Regex will match an array of numbers including negative whole numbers.\n    ([1-9]\\d|"
            },
            {
                "text": "\n^(0|[1-9][0-9])\\\\:([0-5][0-9])$\nExercise 2: RegEx for checking email address address\n- Example: \"email@example"
            },
            {
                "text": " (?i)(?<!^)\\d{1,2}(?:T)?(?=\\d{1,2}(?::?)(\\d{1,2})) (?:00|"
            },
            {
                "text": " ((\\d{1,2}):(\\d\\d))|((\\d\\d)):(\\d{1,2})|((\\d0\\d))\n\n3. Write your own Regex"
            },
            {
                "text": "\n\"^[1-9][0-9]|1[0-2]?[0-9]:[0-5][0-9]\"\n\nNow, let's test our understanding with some exercises"
            },
            {
                "text": " ^(0|1)(1[01])00$\n\nExercise 3: In what circumstances would you use the `match` method of Python's `re` module?\n\nAnswer: The `match` method"
            },
            {
                "text": " \\d{1,2}(\\.\\d{1,2})?/\\d{0,2}/\\d{1,2}.\n- \"16-20\"\n  1.\n  "
            },
            {
                "text": " 9.+0(:|:?|[6-9])[0-9]*(.00?)\nThe \":\" or \":\"? or [6-9] will either start with \"9\","
            },
            {
                "text": " \"^(0|1?)(0|1|2|3|4|5|6|7|8|9)$\"\n\n(2) If a string ends with a valid time, and the"
            },
            {
                "text": " [0-9]\\d{1,2},{1,3}[0-9]:[0-9]\\d\"\"\n\nThe last question will require the user to input a Python code example,"
            }
        ]
    },
    {
        "expression": "^ *(1[0-2]|[1-9]):[0-5][0-9] *(a|p|A|P)(m|M) *$",
        "raw_prompt": "validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm.",
        "refined_prompt": "Validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm.\nMatch examples:\n- \"12:00am\"\n- \"1:00 PM\"\n- \"12:59 pm\"\nNon-match examples:\n- \"0:00\"\n- \"0:01 am\"",
        "matches": [
            "12:00am",
            "1:00 PM",
            "12:59 pm",
            "3:41 Pm",
            "1:13 pM",
            "1:50 am",
            "10:50 pM",
            "11:05 am",
            "4:19 AM",
            "2:56 Am",
            "5:51 aM",
            "12:25 PM",
            "10:20 pM"
        ],
        "non_matches": [
            "0:00",
            "0:01 am",
            "13:00 pm",
            "15:52 am",
            "51:534",
            "$23.454",
            "19:94 pm",
            "12f3.21f3.213f",
            "245/524/12",
            "20:59 PM",
            "2:2 AAMM",
            "23:23:23 PM"
        ],
        "id": 212,
        "output": [
            {
                "text": " ^0?(?:[1-9]\\d?|1[024]) [ap]m$\n\nExercise 3:\nDescribe the differences between \"12"
            },
            {
                "text": " ^[01][0-9]|0?[1-9]?[0-9]:[0-5][0-9]\\s*$\n\n"
            },
            {
                "text": " ^\\d\\d[ap]m$\n\nExample 10:\n\"The party will start at 8:00pm and end at midnight. Please RSVP by November 10"
            },
            {
                "text": " /^(\\d+):(\\d{2}) (\\w+$)?$/.\n\nExercise 2: Write a RegEx to extract the year, month, and"
            },
            {
                "text": " ^\\d?\\d(\\.\\d+)?$\n- \"2 am\"Generate a RegEx for this description.\nAnswer: ^(\\d?\\d"
            },
            {
                "text": " ^0(?:\\d|pm)$|^1(?:\\d|pm)$\n\nWe hope this article has given you a better understanding of how Python's"
            },
            {
                "text": " \"0-9\\s*(am|pm|AM)(\\s+0-9\\s*(am|pm|AM)(\\s+0-9\\"
            },
            {
                "text": " /^(1|2)\\d{1,2}[-/.]\\d{2}:\\d{2}(?:\\s*am|pm)$"
            },
            {
                "text": " ([1-9]|1[012])[:\\s\\-]?([1][0-9])[:\\s\\-]?([0-9])[:am"
            },
            {
                "text": " [0-9]|[1-9][0-9]|1[0-4][0-9]|5[0-9]|[1-"
            }
        ]
    },
    {
        "expression": "^([A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^$",
        "raw_prompt": "Matches up to three alphabet words separated by spaces with first alphabet character of each word uppercase. Also matches empty strings.",
        "refined_prompt": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"",
        "matches": [
            "Sacramento",
            "San Francisco",
            "San Luis Obispo",
            "Shuijkn",
            "Jgyubhj Ghi",
            "Osfdui Hihufsdj Gfsd",
            "Hello World",
            "Python Java",
            "This Is",
            "An Apple Abc",
            "Soink",
            "Jqwe",
            "Notre Dame"
        ],
        "non_matches": [
            "SanFrancisco",
            "SanLuisObispo",
            "San francisco",
            "fdsdfs",
            "fiodsk",
            "ijnkfsdf",
            "ijnkfds89ijINJFKDS",
            "hfionsjdijkiJNKFSDIJO",
            "hufdijsnhijh9ui",
            "dfijoij9jiFDS",
            "j9IFDS",
            "9jiFOD"
        ],
        "id": 217,
        "output": [
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\" ("
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            }
        ]
    },
    {
        "expression": "(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "raw_prompt": "Validates time in MySQL time format. 24 hour time colon seperated hours:minutes:seconds",
        "refined_prompt": "Used to validate time values in in MySQL time format, in the format \"hh:mm:ss\" where hours are in the range of 00-23, minutes and seconds are in the range of 00-59.\nMatch examples:\n- \"09:30:00\"\n- \"17:45:20\"\n- \"23:59:59\"\nNon-match examples:\n- \"24:00:00\"\n- \"79:987:8\"",
        "matches": [
            "09:30:00",
            "17:45:20",
            "23:59:59",
            "14:51:51",
            "20:27:20",
            "20:27:22",
            "22:33:43",
            "21:10:09",
            "07:25:31",
            "22:27:34",
            "05:48:08",
            "22:55:26",
            "23:42:57"
        ],
        "non_matches": [
            "24:00:00",
            "79:987:8",
            "98:27:20",
            "22:70:79",
            "21:87:09",
            "07:25:67",
            "97:27:34",
            "194:48:08",
            "22:978:26",
            "199:42:57",
            "21:84:58",
            "14:29:97"
        ],
        "id": 222,
        "output": [
            {
                "text": " ^(0|1)(1|2|3|4|5|"
            },
            {
                "text": " /^(0[1-9]|1[0-2]"
            },
            {
                "text": " (00-23)|(00-59)|(60|60|60"
            },
            {
                "text": " (^(0|[1-9]\\d)(0|["
            },
            {
                "text": " [0-9]{1,4}[:].{1,"
            },
            {
                "text": "\n\ntimeFormat: \\d{2}:\\d{2}:\\"
            },
            {
                "text": " \n\\d{2}[:\\.|-|\\+]\\"
            },
            {
                "text": " \"^\\d{0,2}:\\d{2}:\\d"
            },
            {
                "text": " \"(0|1[0-2])\\\\d|2[0-"
            },
            {
                "text": " Non-match characters should match one of the following characters: 0-9,"
            }
        ]
    },
    {
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)(00|15|30|45)?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)(00|15|30|45)?))$",
        "raw_prompt": "This expression will allow a time value with 15 minute increments. It will not accept seconds. You can use either US time or Military time format.",
        "refined_prompt": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 00 to 23.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\nMatch examples:\n- \"1:00 PM\"\n- \"6:45 am\"\n- \"17:30\"\nNon-match examples:\n- \"4:32 am\"\n- \"5:30:00 am\"",
        "matches": [
            "1:00 PM",
            "6:45 am",
            "17:30",
            "11:15 Am",
            "18:15",
            "19:15",
            "05: PM",
            "22:30",
            "12:45 Am",
            "2:15AM",
            "03:15",
            "5:30",
            "11.30 am"
        ],
        "non_matches": [
            "4:32 am",
            "5:30:00 am",
            "17:01",
            "12/123/4322",
            "17:879",
            "466",
            "21:61",
            "14:26",
            "02:52 Am",
            "7:43 pM",
            "10.62 Pm",
            "21.33"
        ],
        "id": 223,
        "output": [
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            }
        ]
    },
    {
        "expression": "(^-\\d*\\.?\\d*[1-9]+\\d*$)|(^-[1-9]+\\d*\\.\\d*$)",
        "raw_prompt": "Accepts only negative decimal values. Zero and positive numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.",
        "refined_prompt": "\nMatch examples:\n- \"-0.050\"\n- \"-5.000\"\n- \"-5\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "-0.050",
            "-5.000",
            "-5"
        ],
        "non_matches": [
            "0",
            "0.0",
            ".0"
        ],
        "id": 226,
        "output": [
            {
                "text": " [number] | [sign]x[number]\n\n\n\nTitle: The Incredible World of Multiplication: Unleash the Power of Math!\n\nIntroduction:\nWelcome to the fascinating world of multiplication, where numbers come to life and their powers are unleashed! In this biography, we will delve into the depths of multiplication, exploring its concepts and properties"
            },
            {
                "text": " 0|\\(\\(0)\\)(?:[ \\. -]*\\2*(?=\\.)(\\b[0-9]+(?:\\.[0-9]+)?)?\\b\n\nExercise 3: Write a RegEx for this description.\nNon-match examples:\n- \"+0039\"\n- \"+00\""
            },
            {
                "text": " \"(^\\\\d+)(?!$)([+-]?\\\\d*\\\\.\\\\d*)$\"\n\nBy practicing these exercises and exploring real-world applications, you can see the power of RegEx in everyday life, making it an essential skill for any budding Database Administrator or computer user.\n\n\n\nDaily Life: Emergent Events and"
            },
            {
                "text": " \n\"\\d+\\.\\d+\" \n\nExercise 3: The answer is a list of all numbers from 0 to 20 except 15.\n[\n    \"0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 19, 20\"\n]"
            },
            {
                "text": " \n[^0-9]\n\n\n\nQuestion 5: The length of a rectangle is twice its width. If the perimeter of the rectangle is 24 cm, what are its dimensions?\n\nSolution: \nLet's assume the width of the rectangle is x cm.\nAccording to the given information, the length of the rectangle is 2x cm"
            },
            {
                "text": " \"+[0-9]*.[0-9]++\"\n```python\nimport re \n\ntext_a = \"I have 100 apples today\"\ntext_b = \"-5.00\"\ntext_c = \"0 apples today\"\n\nre1= re.compile(r\"\\bfoo.*?\\b"
            },
            {
                "text": " A RegEx that validates a single character and decimal point, \"^[a-zA-Z]\\.[0-9]$\"\n\n\n\nQuestion 4: Sarah wants to build a pentagonal prism-shaped planter box. The base of the prism is an equilateral triangle with a side length of 5 feet. The height of the"
            },
            {
                "text": " A regular expression that starts with a number and ends with a period with at least one number. It should also be followed by an optional period. \n\nBy learning about mathematics, place value, and using Python RegEx, you will be able to make sense of numbers, compare them, and perform calculations more easily. Keep practicing and you'll become a Math Wh"
            },
            {
                "text": " [0]{1}\\.[0-9]+\n\n\n\n\nIn order to truly understand the world around us and the impact of different human interactions, it is important to delve into the realm of psychology and psychology research. One significant area of interest within this field is the concept of self-verification theory. This theory explores how individuals seek to maintain their self"
            },
            {
                "text": " -(?<![-+.])\\d*\\.\\d+\n\nExercise 3:\nMatch the length ranges to the correct number of matches:\n- 2-5\n- 2-16\n- 5-10\n- 12-16\nAnswer:\n- 2-5: \"2-5\" (2-4, 5,"
            }
        ]
    },
    {
        "expression": "^(\\d|,)*\\.?\\d*$",
        "raw_prompt": "Matches Numeric with Commas and a single decimal point. Also matches empty string.",
        "refined_prompt": "Validates numerical values that may use commas for thousands separation and have an optional decimal part. Also matches empty string.\nMatch examples:\n- \"1,000\"\n- \"3,000.05\"\n- \"5,000,000\"\nNon-match examples:\n- \"abc\"\n- \"$100,000\"",
        "matches": [
            "1,000",
            "3,000.05",
            "5,000,000",
            "78.486",
            "89",
            "789",
            "85",
            "1",
            "9",
            "98.48",
            "87.54",
            "56.57",
            "97.9875"
        ],
        "non_matches": [
            "abc",
            "$100,000",
            "Forty",
            "fasd@fds.fasd@",
            "sfalijad234",
            "43.v234",
            "/5/5/5",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "abc111def",
            "99999@gmail"
        ],
        "id": 228,
        "output": [
            {
                "text": " (?i)^\\D*(\\d+(?:\\.\\d\\D*)?|\\.\\d+)(?:,\\s*\\D*(\\d+(?:\\.\\d\\D"
            },
            {
                "text": " \"^((.\\d+,)*\\.+|)(?!\\$)([a-z])[a-z0-9]\\d*$\" or \"^\\d+(,?\\d"
            },
            {
                "text": " \n([0-9]{4},?)+\\s?[\\.,]?\\s?[0-9]{2,}\n\n7. Write a RegEx pattern that will return"
            },
            {
                "text": " \\b(1\\d|10|20|100|1,000|1_000|1_000\\.)\\d{3}\\b\n\n### 2. Write a Python Regex to validate"
            },
            {
                "text": " (?<![0-9])(1*[0-9]?[0-9])[.0-9](?![a-z]|,)|(?<![0"
            },
            {
                "text": " \\d+,\\d+[\\d.]+(\\.\\d+)\nThe last bit I found the easiest to understand but I can't get it to match empty string.\nThe first bit works (but if"
            },
            {
                "text": " $100,000 will return a true match as it is a numerical value\n\n- \"10x10\"\n- \"20x20\"\n- \"40x40\"\nNon-match examples:\n"
            },
            {
                "text": " \nMatch on:\n1) Start of line.\n2) Number of digits, with a comma in the middle.\n3) Decimal number. Not needed here because it doesn't start with a comma"
            },
            {
                "text": "\n\n<button onclick=\"matcher.start();\"><font face=\"Helvetica 30\">\\(this is a test\\)(,this is a test,)\\.(,this is a test.),\\"
            },
            {
                "text": " (.*?(?=.*\\d))+$\n3. Test the following RegEx:\nre.match(r\"'([\\w\\.]+)'\\s*$\", '\".abc def"
            }
        ]
    },
    {
        "expression": "^[+]?\\d*$",
        "raw_prompt": "This re was used for set numbers only!\nSomente numeros s&#227;o requeridos!",
        "refined_prompt": "It validates numeric values, including positive integers with or without a leading plus sign.\nMatch examples:\n- \"0123456789\"\n- \"1234\"\n- \"1\"\nNon-match examples:\n- \"1.0?&amp;\"\n- \"a1\"",
        "matches": [
            "0123456789",
            "1234",
            "1",
            "243",
            "513",
            "245",
            "89456",
            "98456",
            "845",
            "89456",
            "984568",
            "+98",
            "+4846"
        ],
        "non_matches": [
            "1.0?&amp;",
            "a1",
            "2a-",
            "12/123/4322",
            "234/423/5243",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "32542.456"
        ],
        "id": 231,
        "output": [
            {
                "text": " [0-9]|\\.[0-9]\n\nExercise 2: Rewrite the following sentence as a regular expression:\n\"In order that people can easily find a parking space, we recommend parking lots instead of street parking.\"\nAnswer"
            },
            {
                "text": " [a-zA-Z0-9\\d]+\nExplanation: Match any combination of letters (a-z), numbers (0-9) and dashes (-)\n\nExercise 3: Email Pattern Check\nGenerate a"
            },
            {
                "text": " ^[0-9]+(\\.[0-9]+)+\n\n```python\n# Write the code that prompts the user to enter a number and validates it against a RegEx pattern. \n# Display whether the number was valid"
            },
            {
                "text": " \n^(\\\\d+[.]\\\\d*){1,6}$\n\n2. Match examples:\n- \"1234A567\"\n- \"1-2-3-4-5678\"\n- \"1"
            },
            {
                "text": " The RegEx would be:?[0-9]+=.*;\n\nLecture Script for Subsection 7.3.8: Validating Username Regex Patterns with Levenshtein Matching\n\nContent:\n- Brief Explan"
            },
            {
                "text": " (0|[+-]?)(%0=|(.))([+-]?)(%0=|(.))(%0=|(.))(?0=|(.))(?0=|(.))(?0"
            },
            {
                "text": " r'([^&\\n]+?)&nbsp;/?'. \n4. What is the difference between '&nbsp;' and '\\n' in Python?\nAnswer: The difference between '&nbsp;' and '"
            },
            {
                "text": " [0-9a-fA-F]{1,4}(?:\\.[0-9a-fA-F]{1,4})*\n- What is the purpose of using a delimiter with groups?\nAnswer"
            },
            {
                "text": " Matching any digits with 1 or 2 decimal points and at least 1 non-digit character in between.\n\nExercise 3: Create a Regular Expression pattern for the pattern \"aAaBbCcDdDdEeEeF"
            },
            {
                "text": " (\\\\d{1,}\\\\.){0,1}[0-9]+.\n\nExercise 3: Compile a RegEx for this description and use it to find matches in a string. \n- Match this description:\n"
            }
        ]
    },
    {
        "expression": "^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$",
        "raw_prompt": "Regular expression to match valid UK postcodes.\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\nDetails of the rules:\nFirst half of postcode\nValid formats\n[A-Z][A-Z][0-9][A-Z]\n[A-Z][A-Z][0-9][0-9]\n[A-Z][0-9][0-9]\n[A-Z][A-Z][0-9]\n[A-Z][A-Z][A-Z]\n[A-Z][0-9][A-Z]\n[A-Z][0-9]\nExceptions\nPosition - First.\nContraint - QVX not used\nPosition - Second.\nContraint - IJZ not used except in GIR 0AA\nPosition - Third.\nConstraint - AEHMNPRTVXY only used\nPosition - Forth.\nContraint - ABEHMNPRVWXY\nSecond half of postcode\nValid formats\n[0-9][A-Z][A-Z]\nExceptions\nPosition - Second and Third.\nContraint - CIKMOV not used",
        "refined_prompt": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-Z][0-9]\r\n[A-Z][A-Z][A-Z]\r\n[A-Z][0-9][A-Z]\r\n[A-Z][0-9]\r\nExceptions\r\nPosition - First.\r\nContraint - QVX not used\r\nPosition - Second.\r\nContraint - IJZ not used except in GIR 0AA\r\nPosition - Third.\r\nConstraint - AEHMNPRTVXY only used\r\nPosition - Forth.\r\nContraint - ABEHMNPRVWXY\r\nSecond half of postcode\r\nValid formats\r\n[0-9][A-Z][A-Z]\r\nExceptions\r\nPosition - Second and Third.\r\nContraint - CIKMOV not used\nMatch examples:\n- \"DN3 6GB\"\n- \"SW42 4RG\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"SEW4 5TY\"\n- \"AA2C 4FG\"",
        "matches": [
            "DN3 6GB",
            "SW42 4RG",
            "GIR 0AA",
            "W6V3 9HE",
            "O75  4QQ",
            "NA9 2XS",
            "8O 1XO",
            "TYV 2RH",
            "418N 1HH",
            "IPVA 2YP",
            "S4 5XU",
            "1MN 4WL",
            "MY5 8XW"
        ],
        "non_matches": [
            "SEW4 5TY",
            "AA2C 4FG",
            "AA2 4CV",
            "Mastercard",
            "POST code",
            "there is a boy",
            "43-5432",
            "/5/5/20022",
            "SIUE 234",
            "FJD28r9 ISOJD342",
            "FDSD79",
            "998F FD7329"
        ],
        "id": 234,
        "output": [
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Accepts data of time in format h:mm and hh:mm\n^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$\nin php [0-23]:[0-59]{2} (posix)",
        "refined_prompt": "Accepts data of time in format h:mm and hh:mm\nMatch examples:\n- \"0:00\"\n- \"23:00\"\n- \"00:59\"\nNon-match examples:\n- \"0:0\"\n- \"24:00\"",
        "matches": [
            "0:00",
            "23:00",
            "00:59",
            "22:12",
            "4:15",
            "22:26",
            "22:14",
            "16:39",
            "06:45",
            "14:56",
            "1:25",
            "7:49",
            "22:53"
        ],
        "non_matches": [
            "0:0",
            "24:00",
            "00:60",
            "12/123/4322",
            "51:534",
            "432:2834",
            "234:94",
            "98:43",
            "132:43",
            "23:98",
            "54:84",
            "0943:423"
        ],
        "id": 235,
        "output": [
            {
                "text": " ^[01]\\d|[012]\\d$|[\\d]\\d:[\\d]\\d$\n\nExercise 2: Matching a date\nWrite a RegEx to match dates with the format m/d/y.\n"
            },
            {
                "text": " \n^(?:^|\\D)(?:[1-9][0-9]|1[012]):([0-5][0-9])[ ](?:AM|PM)M?$\n\nI hope this helps!\n"
            },
            {
                "text": " \"0(:[0-5][0-9]|60):[0-5][0-9]\"\n\n3. Write an expression that accepts data of a student's grade using placeholders and prints the grade formatted with a prefix \"A-\" when grade"
            },
            {
                "text": " \n[0-9]{2}:[0-9]{2}.[0-9]|[0-9]{2}:[0-9]{2}.[0-9]|[0-9]{2}:["
            },
            {
                "text": " \n/^([0-9])[a-z]*:[0-9]{2}$/i\n\nExercise 2: \nWhich of the following will match the following regular expression:\n\n\\d{3} - \"2"
            },
            {
                "text": " \\d(?::\\d)\n\nExercise 5: Given below is a list of files with different extensions. Write a Python script that returns all the files with the.txt extension in a list.\n```python\nfiles = [\n    {'"
            },
            {
                "text": " [0-1]?[0-9]{2}:?[0-9][0-9]|[0-9]?[0-9]:?[0-9][0-9]\n\n3) Write a RegEx to"
            },
            {
                "text": " hH\\d\\d\\d \n\nExercise 3: \nYou're designing a database and need to filter a table based on the following criteria: \n- Name should start with \"A\"\n- Length of the name should be between 1 and"
            },
            {
                "text": " (h):[0-9](m):[0-9]\nIllustration: \n\nJenna and Tom both work as sales representatives for a pharmaceutical company. Jenna receives regular bonuses and recognition for hitting her sales targets, while Tom does not. One"
            },
            {
                "text": " \\d\\d:\\d\\d\n- \"0,00\"Does not match the description.\n\n**Exercise 4:** Write a function that takes a time as an argument and returns True if it matches the date format.\n\n- Accepts time"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{2})$",
        "raw_prompt": "Validates MM/YY for rough checking credit card expiration dates.",
        "refined_prompt": "Validates MM/YY for rough checking credit card expiration dates.\nMatch examples:\n- \"11/03\"\n- \"01/04\"\n- \"09/39\"\nNon-match examples:\n- \"13/03\"\n- \"10/2003\"",
        "matches": [
            "11/03",
            "01/04",
            "09/39",
            "08/67",
            "10/96",
            "03/67",
            "04/71",
            "12/88",
            "12/33",
            "12/48",
            "11/15",
            "10/28",
            "08/03"
        ],
        "non_matches": [
            "13/03",
            "10/2003",
            "234/234",
            "342/52",
            "23/52",
            "25/14",
            "24/14",
            "05/243",
            "432/52",
            "24/756",
            "87/67",
            "85/83"
        ],
        "id": 236,
        "output": [
            {
                "text": " The RegEx could be \"0*(1[9])[0-9]*|[1](0[9])0*[9]*\". This code matches either \"13 00\" or \"010 000\". To validate all month formats, use.* or"
            },
            {
                "text": " (nearly exact same thing, you probably know how to do\nreg = r\"(\\d\\d)/(\\d\\d)\"  regex: \"month / day\"\n```\n\n\n\n\n# Subsections\n\n1. The 'and' Key"
            },
            {
                "text": " \\d\\d/\\d\\d\n- \"31/12\"\n- \"4/12\"\n- \"29/12\"\n- \"09/25\"\n\n(2) \nWrite a Regex to validate your name should be uppercase"
            },
            {
                "text": " ([0-9]{2}[-./\\s]{0,5})([0-9]{2}) ([0-9]{2}) ([0-9]{4})\n\nSection 2: Matching and Replacing RegEx\n"
            },
            {
                "text": " \"^[13-9][0-9][0-9]\\/[0-9][0-9]/1[0-9]$\"\n\n\n\nEmail 1 (positive tone):\nSubject: Exploring the Comparison between Grieving and Joyful"
            },
            {
                "text": " \n\"\"\"\n\nfrom abc import ABC, abstractmethod\nimport re\n\nclass RegularExpressionError(Exception): pass\n\nclass ValidatesRoughCheckingCreditCardExpirationDate(ABC):\n  \"\"\" This class defines any functionality that would validate if the"
            },
            {
                "text": " \n  \\d{2}:\\d{2}(?!\\d)\n\nExercise 5:\nExercise: Write a Python program that takes a string as input and replaces all occurrences of the word \"love's\" with \"hates\" using a case"
            },
            {
                "text": " ^\\d\\d\\d-\\d\\d-\\d\\d(?:\\/\\d{2})?$\n\nA:\n\nUse \\b for word boundaries. \\w is all letters, \\d digits and _ symbols.\nThe first"
            },
            {
                "text": "\n(\\d{2})/(\\d{4})\n\n3. Use the same concept as exercise one, write a RegEx function that takes in a sentence and replaces all occurrences of a letter, like 'e', with an asterisk (*). \n\nUse function"
            },
            {
                "text": " \\d/\\d{2}$\n\nExercise 4: Developing a Text Filter\nGiven a text, develop a filter using RegEx that only extracts sentences with a word from a pre-defined list (e.g., \"python\", \"computer\"). \n"
            }
        ]
    },
    {
        "expression": "^(([0]?[0-5][0-9]|[0-9]):([0-5][0-9]))$",
        "raw_prompt": "This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds). It is derived from Ken Madden's time regex for a project for Erik Porter (Windows/Web guru). Written by Jason Gaylord.",
        "refined_prompt": "This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds).\nMatch examples:\n- \"30:05\"\n- \"5:05\"\n- \"02:59\"\nNon-match examples:\n- \"25:7\"\n- \"5m:16\"",
        "matches": [
            "30:05",
            "5:05",
            "02:59",
            "52:55",
            "6:33",
            "40:13",
            "5:35",
            "9:28",
            "9:05",
            "3:32",
            "54:49",
            "10:17",
            "7:50"
        ],
        "non_matches": [
            "25:7",
            "5m:16",
            "60:60",
            "12/123/4322",
            "51:534",
            "$23.454",
            "4556:45",
            "98i:ojk",
            "000-000",
            "1-1-2",
            "34.31",
            "423:4561"
        ],
        "id": 244,
        "output": [
            {
                "text": " [0-9][0-9]?[0-9]:[0-9][0-9]? [0-9][0-9]\"\n[0-9"
            },
            {
                "text": " ^(?:\\d\\d:(?:\\d\\d):)?\\d{1,2}$\n(?:\\d\\d:(?:\\d\\d):)? is"
            },
            {
                "text": " /((?!^)[2-9]{1,2}[0-9]|1[0-9]|2[0-3],[0-5][0"
            },
            {
                "text": "\nRegex = \"(?<minutes>\\d|0[1-9]|1[0-2]))(?<seconds>\\d\\d)\"\n\nThe"
            },
            {
                "text": "\nIf both hours and minutes are present, and is always in the format hh/mm\n(?=^(?:\\d\\d:\\d\\d,)?$)|("
            },
            {
                "text": " (([0-9]?[0-9]?)[:][0-9][5][0-9]:)?([0-9]?[0-9])'"
            },
            {
                "text": " \"^\\d+:\\d+$\"\nDescription: a colon followed by digits, followed by more digits, and a colon and more digits. \n\nSolution:\nThis regex"
            },
            {
                "text": " (\\d{1,2}:\\d{0,2})\\s(?=\\d{1,3}:\\d{0,2})\n\nThank you in"
            },
            {
                "text": "\n\n/\\s*(\\d\\d\\d):(\\d\\d)\\s*(\\d:\\d)?/g\nYou will need to understand what these three parameters mean in"
            },
            {
                "text": "\n(\\d):(\\d{2}) (minute|second|second|(?:minute|second|second|minute|second|minute|\nsecond|\"))\n\nA:\n"
            }
        ]
    },
    {
        "expression": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$",
        "raw_prompt": "Expression to handle US currency entry in .NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.",
        "refined_prompt": "In summary, this regular expression matches strings that start with a dollar sign, followed by a group of one to three digits, optionally followed by a comma, optionally followed by a group of three digits, optionally followed by a decimal point and one to three digits, or a group of one to three digits followed by an optional decimal point and two digits.\nMatch examples:\n- \"10000\"\n- \"10,000\"\n- \"$1,000.00\"\nNon-match examples:\n- \"0.002\"\n- \"x.0\"",
        "matches": [
            "10000",
            "10,000",
            "$1,000.00",
            "$834",
            "$498",
            "$489",
            "$129",
            "15,846",
            "48357",
            "84667",
            "84694",
            "84215",
            "48583"
        ],
        "non_matches": [
            "0.002",
            "x.0",
            "-243",
            "12/123/4322",
            "51:534",
            "$23.454a",
            "43-5432",
            "/5/5/20022",
            "000-000",
            "354/243/542",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 249,
        "output": [
            {
                "text": " \\"
            },
            {
                "text": " x"
            },
            {
                "text": " \\"
            },
            {
                "text": " match"
            },
            {
                "text": "^"
            },
            {
                "text": " ^"
            },
            {
                "text": " ("
            },
            {
                "text": " r"
            },
            {
                "text": " (["
            },
            {
                "text": " ("
            }
        ]
    },
    {
        "expression": "^(?![0-9]{6})[0-9a-zA-Z]{6}$",
        "raw_prompt": "matches a six character &quot;password&quot; that has to consist of numbers and letters with at least one letter in it.",
        "refined_prompt": "Matches a six character &quot;password&quot; that has to consist of numbers and letters with at least one letter in it.\nMatch examples:\n- \"123a12\"\n- \"a12345\"\n- \"aaaaaa\"\nNon-match examples:\n- \"111111\"\n- \"123456\"",
        "matches": [
            "123a12",
            "a12345",
            "aaaaaa",
            "W0lkZQ",
            "LMCawM",
            "DUcHPR",
            "NSjtUp",
            "cnzkKl",
            "lWtVJH",
            "7zLHU1",
            "1uaPEv",
            "DkGtDA",
            "9QJvZZ"
        ],
        "non_matches": [
            "111111",
            "123456",
            "89456",
            "9485632",
            "98561",
            "984651",
            "gdfs9465",
            "49865f956",
            "956gdfg",
            "g48",
            "fg4d851",
            "g98456gf"
        ],
        "id": 251,
        "output": [
            {
                "text": " \n\n(?!.*\\\\b(a[a-z]|[a-z0-9]{1}|[0-9]{6}).*$)\n\nA"
            },
            {
                "text": " ^[a-f0-9]{6}$\n2. Using the same example as question 1, build a regex that takes the following form: \n- \"123a012\"\n"
            },
            {
                "text": " ^(?P<length>[a-zA-Z0-9]{1}){6,09}$\n\nA:\n\nAs you need to allow both numbers and letters you need"
            },
            {
                "text": " https://regex101.com/r/qR6SrR/1/\n\nThis code should be modified by adding a new line, if you need any help, just reply here.\n"
            },
            {
                "text": " [A-Z0-9]{6,}\n\n2. Create a RegEx for a phone address that is valid in the following formats:\n- 7-1-1 or [7]"
            },
            {
                "text": " This answer is generated by the Python RegEx module - regex! The RegEx class is used to create RegEx patterns. A pattern is used to represent a text structure and a matching object is created if there is"
            },
            {
                "text": "\n[A-Za-z](?=^\\d+$)[A-Za-z0-9]{6}$\n\nExercise 3: \nCreate the regular expression"
            },
            {
                "text": " (a/b) or (a/1)\n\n- \"1ab1A1a1a1a1\"Generate a RegEx for this description. \nAnswer: (a/"
            },
            {
                "text": " \n\\b(?=.*?\\d)(?=.*?[a-z])\\w{6}\\b\n\nExercise 4: Matching in the real world\nSearch your school"
            },
            {
                "text": " (The same RegEx that is found above). The match example is matched. The non-match example is not matched.\n\n4. How do you use the match function to validate the existence of user input"
            }
        ]
    },
    {
        "expression": "^\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$",
        "raw_prompt": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\n1)area code in paranthesis.\n2)space between different parts of the phone number.\n3)no space between different parts of the number.\n4)dashes between parts.",
        "refined_prompt": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"",
        "matches": [
            "(573)8841878",
            "573-884-1234",
            "573 234 1256",
            "5169670650",
            "3751905240",
            "156763\u20065387",
            "895\t344\u20294357",
            "(940) 698\u202f6344",
            "7547900898",
            "8943744511",
            "4699973928",
            "(856)1030219",
            "9555048285"
        ],
        "non_matches": [
            "(573)(673)2345",
            "573-12-2345",
            "53495083409x",
            "12/123/4322",
            "2346-2345-2435",
            "r4532",
            "15343454",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 255,
        "output": [
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description. It"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\n"
            }
        ]
    },
    {
        "expression": "(^[A-Z\u00c0-\u00dc]{1}[a-z\u00e0-\u00fc']+\\s[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc]+((([\\s\\.'])|([a-z\u00e0-\u00fc']+))|[a-z\u00e0-\u00fc']+[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc']+))",
        "raw_prompt": "Checks if has the first and the last name, and check the capital letters.\nUse with the RegExp.test method",
        "refined_prompt": "Checks if has the first and the last name, and check the capital letters.\nMatch examples:\n- \"Carlos Rodrigues\"\n- \"C\u00e1 de Laaa\"\n- \"Crras R. L. Rodrig\u00fces\"\nNon-match examples:\n- \"aa\u00e4A\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "Carlos Rodrigues",
            "C\u00e1 de Laaa",
            "Crras R. L. Rodrig\u00fces",
            "Fsdf Ffasd",
            "Lionel Messi",
            "Abc Def",
            "Qwef Nfjisdo",
            "Jfdio Jijosdf",
            "Fijofds Jijsdf",
            "Jpfods Pfds",
            "Jfodis Prew",
            "Qeybr Pfds",
            "Ifisdoj Idsf"
        ],
        "non_matches": [
            "aa\u00e4A",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "53495083409x",
            "fasd@fds.fasd@",
            "sfalijad234",
            "3nf@",
            "AAAAAAA",
            "2546dgwre",
            "qwerty@123.123",
            "com.edu.github",
            "sda sad",
            "0j0jweBBBB"
        ],
        "id": 262,
        "output": [
            {
                "text": " \\.\\w+\\(\\w+\\)\\.jpg\nHow would you improve the following regex?\nAnswer: ^[A-Z0"
            },
            {
                "text": " \"^C(a[Aa])?R(r?[Dy]a)s(r?[Rr]?[."
            },
            {
                "text": " ^[A-z0-9\\.\\-\\_]+\\_[A-z0-9\\-\\_]+\\.jpg$\n``"
            },
            {
                "text": " \nhttps://regex101.com/r/hT5R7w/12\n\nCode explanation.\nFirst, we use an"
            },
            {
                "text": "\n$string.match(/^(\\\\S+.?\\\\S)\\\\..*\\\\.jpg$/);\nIf doesn't has the"
            },
            {
                "text": " \".* \\d+ [a-zA-Z.\\/]+.* \"\n\nSolution:\n\nimport re\n\nregEx = re"
            },
            {
                "text": "\n\"(?i)(\\\\b[a-z][a-zA-Z]*\\\\b)|(\\\\b[a-zA"
            },
            {
                "text": " \"https://example.org\\/\"+\"\\d+.\\d+.\\d+\"\n\"\"\"\nimport re\n\ndef generate_url"
            },
            {
                "text": " \"E:\\DyAGT\\SD01A_specV2\"[^A-zA-Z_\\-]*[A-Z"
            },
            {
                "text": " \\d+-\\w+-\\w+, \\w+\\w+$\n\nIn conclusion, as a cloud engineering analyst, it is"
            }
        ]
    },
    {
        "expression": "(^((((0[1-9])|([1-2][0-9])|(3[0-1]))|([1-9]))\\x2F(((0[1-9])|(1[0-2]))|([1-9]))\\x2F(([0-9]{2})|(((19)|([2]([0]{1})))([0-9]{2}))))$)",
        "raw_prompt": "dd/mm/yy\nCheck dates between 1/1/1900 - 31/12/2099",
        "refined_prompt": "dd/mm/yy\r\nCheck dates between 1/1/1900 - 31/12/2099\nMatch examples:\n- \"31/12/2099\"\n- \"1/1/1900\"\n- \"10/12/2003\"\nNon-match examples:\n- \"05/11/3000\"\n- \"11/13/2003\"",
        "matches": [
            "31/12/2099",
            "1/1/1900",
            "10/12/2003",
            "5/2/1987",
            "30/1/16",
            "7/03/1942",
            "9/2/19",
            "15/6/1909",
            "30/1/1975",
            "2/07/1934",
            "05/5/61",
            "06/11/97",
            "30/11/94"
        ],
        "non_matches": [
            "05/11/3000",
            "11/13/2003",
            "32/04/2030",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 263,
        "output": [
            {
                "text": " [\\d]{4}-\\d{2}-(\\d{2})[TT]\\d{2}\n\nThe first \\d is a digit"
            },
            {
                "text": " The RegEx for this description would be \"01/[A-Z]/0[0-9]/[A-Z]{3,}/[0-"
            },
            {
                "text": " [0-9]{3}/[1-9][0-9]/[-1][0-9]/[0-3]\n\n2."
            },
            {
                "text": "\nre.compile(r'\\b((?:1[012]|0[1-9]|[12]\\d|30)\\/(?:1["
            },
            {
                "text": "\n(0?[1-9])\\/([1-3]\\d|30)\\/([2-9]\\d|19)\nThe RegEx uses the"
            },
            {
                "text": " 01/01/1878|31/12/2099|10/12/2003|05/11/3000|11/13/2003|\n\n2. Check"
            },
            {
                "text": " (from an article using python regex module) rf'\\d{1,2}(\\/\\d{1,2})?\\/\\d{4}' "
            },
            {
                "text": " (\\d{1,2}/\\d{1,2}/\\d{4}(-\\d{2,3})?)\n```\n\n5"
            },
            {
                "text": "\n.*-?[0-9]{1,2}/[[:digit:]]+,[[:digit:]]+[0-9]{4}/["
            },
            {
                "text": " \n[1-12][0-9][3][0-9][0-9][-2]\nI hope this answers your questions and helps you understand how to"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}\\s{0,2}[a-zA-z]{2}$",
        "raw_prompt": "Dutch postalcode expression. 4 digits followed by max. two spaces end ending on two letters.",
        "refined_prompt": "Dutch postal code expression. 4 digits followed by max. two spaces end ending on two letters.\nMatch examples:\n- \"4006 AB\"\n- \"4006ab\"\n- \"4006 AB\"\nNon-match examples:\n- \"4006.ab\"\n- \"4006_ab\"",
        "matches": [
            "4006 AB",
            "4006ab",
            "4006 AB",
            "0048 VS",
            "4894fj",
            "4893fj",
            "8238fj",
            "8392jg",
            "9584jq",
            "9381oq",
            "9384jv",
            "8271pq",
            "0495ue"
        ],
        "non_matches": [
            "4006.ab",
            "4006_ab",
            "4006/ab",
            "fasd@fds.fasd@",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "4321fgd",
            "7689fgds",
            "890gss",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 271,
        "output": [
            {
                "text": " ^(?:\\D[\\dA-Z]\\D)+, + \n\n4. Generate a RegEx for this description. A four-digit date with two digits in days, four digits in month, and two"
            },
            {
                "text": "  (?:(?<=^)[0-9]{4}\\s[0-9]{2}|(?<=^)(?=\\s)[0-9]{4}\\s[a-z"
            },
            {
                "text": " A general example for this type of thing would be to create a character class for the first section of digits: \\d{4}.\n\nHints:\n- \\d{4} - any number 4 characters long.\n- Use"
            },
            {
                "text": " 4 digits followed by 2 letters followed by 2 spaces.\n\n7. Write a RegEx that matches values for a company that sells products online and in retail only. Example values include: \"amazon.com\", \"www.amazon.com"
            },
            {
                "text": " ^[0-9]{4}\\s[A-Z]{2}$\n\n7. How do you count numbers in a string?\nLet's say we have an application where we're receiving user input such as email"
            },
            {
                "text": " \"^[0-9][a-zA-Z]{2}\\s[0-9]{2}$\"\n\n\n5. Write a program to validate email addresses. The following character must not be entered:."
            },
            {
                "text": " [3-9][0-9][0-9][AB] \n\nExample 1: Email Address Cleanup\n\nScenario: A group of high school students is working on a project to create a new email management system."
            },
            {
                "text": " [$0~^[0-9]{4}\\s[0-9a-zA-Z]{2}$]\n\"\"\"\nimport re\n\nregex = re.compile(r'\\["
            },
            {
                "text": " \n(4[0-9]{3}[ -.]0[0-9]{2})+\nNon-match examples:\n\nA:\n\nIn case it's an answer for someone asking this question in"
            },
            {
                "text": " (see regexr.com/rjm4a)\n\nA:\n\nYou need to match only the alphabets with the number.\nYou've defined the pattern as a character class [a-zA-"
            }
        ]
    },
    {
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "raw_prompt": "Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses. To optionally validate area codes, try this expression.\n^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "refined_prompt": "Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses.\nMatch examples:\n- \"(111) 223-2332\"\n- \"(222)233-2332\"\n- \"232-323-3233\"\nNon-match examples:\n- \"(ddd) 223-2332\"\n- \"222-232/2333\"",
        "matches": [
            "(111) 223-2332",
            "(222)233-2332",
            "232-323-3233",
            "055 8723",
            "952 944 8379",
            "037 698-1393",
            "(767)-015 9062",
            "879 908-0891",
            "(879)-830-4814",
            "(759) 122-5045",
            "440-6179",
            "(654)-789-2442",
            "937 208-8233"
        ],
        "non_matches": [
            "(ddd) 223-2332",
            "222-232/2333",
            "322-3223-222",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "48-895-956",
            "51962-9516-956",
            "9516-9516",
            "89-956",
            "956195-9516",
            "9561-56"
        ],
        "id": 273,
        "output": [
            {
                "text": " (\\(?\\d{3}\\)?[- ]?\\d{3}[- ]?\\d{4})\n"
            },
            {
                "text": "\n[a-zA-Z0-9]{{2}}\\s\\(?:[a-zA-Z0-"
            },
            {
                "text": " (\\(\\d{3}\\) \\d{3}-\\d{4})\n\nExercise 4: Write a regular expression"
            },
            {
                "text": " (\\(\\d{3}\\))\\s?([0-9]{3}-)?[0-9]{4}"
            },
            {
                "text": " \n([0-9](?(?:\\D*\\d|\\d))*?)$\n\nExercise 3: Create"
            },
            {
                "text": " \n(.{9}?)\\s((\\(.{3}\\)?)[ -()\\/\\s])?[^"
            },
            {
                "text": " \n(^\\(\\d{3}\\)\\s*-\\s*\\d{3}-\\s*\\d{"
            },
            {
                "text": " ([0-9]{3})-([0-9]{3})-([a-z][a-z 0-9"
            },
            {
                "text": " [12 digits] (2 digits) [2 digits] [4 digits]\n\n2. Write a regular expression that matches a string of"
            },
            {
                "text": " (?:\\d{3}\\s)?\\((\\d{3})\\)\\s*-\\s*(\\d{2}"
            }
        ]
    },
    {
        "expression": "^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2})$|^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2}\\s([1-9]|[0-1]\\d|[2][0-3])\\:[0-5]\\d)$",
        "raw_prompt": "Correct German DateTime. Does not check leap year rules!\nPossible Formats of date part:\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\nPossible formats of time part:\nh:mm or hh:mm",
        "refined_prompt": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10.2003 08:9\"",
        "matches": [
            "20.10.2003 08:10",
            "24.12.2003",
            "1.1.2004 8:15",
            "23.11.2048 01:58",
            "31.7.2051",
            "30.00.2030",
            "30.9.2022\u200716:34",
            "27.12.2031\u202818:40",
            "19.11.2057",
            "9.03.2014",
            "02.02.2097\u20091:22",
            "31.8.2074",
            "30.09.2014\u200011:18"
        ],
        "non_matches": [
            "25.13.2004",
            "20.10.2003 08:9",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "432/524/2435",
            "354/243/542",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 278,
        "output": [
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            }
        ]
    },
    {
        "expression": "\\d{2}.?\\d{3}.?\\d{3}/?\\d{4}-?\\d{2}",
        "raw_prompt": "This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies.",
        "refined_prompt": "This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies.\nMatch examples:\n- \"00.000.000/0000-00\"\n- \"00000000000000\"\n- \"657552683148-18\"\nNon-match examples:\n- \"00-000-000-000-00\"\n- \"AA.AAA.AAA/AAAA-AA\"",
        "matches": [
            "00.000.000/0000-00",
            "00000000000000",
            "657552683148-18",
            "72C323,924/6687-31",
            "01978870/5388-07",
            "67443_322/861928",
            "28X041&249/3893-37",
            "18_904\"821/4142-53",
            "52632y804276173",
            "39890X500/784223",
            "29N3068138/5854-57",
            "55732078/883708",
            "74%9586365619-89"
        ],
        "non_matches": [
            "00-000-000-000-00",
            "AA.AAA.AAA/AAAA-AA",
            "34f2vf42e",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "354/243/542",
            "9/9/9",
            "++63453.345"
        ],
        "id": 282,
        "output": [
            {
                "text": "\n\\b([0-9]{4}[-/][0-9]{3} [a-z]{3"
            },
            {
                "text": "\n\"(?:\\b(?:(?!00).)*?)[-\\.,-]\\1([\\d\\.\\t]+)"
            },
            {
                "text": " (\\d{6}-\\d{4}-\\d{2}-\\d{2}-\\d{4"
            },
            {
                "text": " (^[A-Z][A-Z0-9]{3}[.-] [A-Z][A-Z0"
            },
            {
                "text": " [\\d\\w\\-\\.]{4}\\s+\\d{6}/\\d\\d{2}/\\d"
            },
            {
                "text": "\n(?<CNPJ>[A-Z])(?<-CDG)(?<-CDH)-(?<-"
            },
            {
                "text": "\n\"(\\d{9})\\/(\\d{2})\\/(\\d{4})-(\\d{6})\"\n\nEx"
            },
            {
                "text": " A-AAAA-Aa-\n\nExercise 4:\nIf we want to generate a Regular Expression that matches dates in the format DD"
            },
            {
                "text": " [0-9]{2}.{3}[A-Z.][0-9]{2}[.-]?["
            },
            {
                "text": " [A-Z]{2}\\.[A-Z]{0}-[A-Z]{1}-[A-Z]-"
            }
        ]
    },
    {
        "expression": "^((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)$",
        "raw_prompt": "Date expression validator with format YYMMDD\nValidates leap years.\nOf course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years !",
        "refined_prompt": "Date expression validator with format YYMMDD, validates leap years. As year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years.\nMatch examples:\n- \"751231\"\n- \"000229\"\n- \"040229\"\nNon-match examples:\n- \"750431\"\n- \"010229\"",
        "matches": [
            "751231",
            "000229",
            "040229",
            "360229",
            "920229",
            "500401",
            "530216",
            "960229",
            "241021",
            "541001",
            "801115",
            "900101",
            "160229"
        ],
        "non_matches": [
            "750431",
            "010229",
            "050229",
            "895612",
            "415625",
            "451625",
            "8745465",
            "9456456",
            "145561",
            "456897",
            "4561fd",
            "84561fs"
        ],
        "id": 285,
        "output": [
            {
                "text": " ([0-9]\\d(\\.[0-9]{3}\\))$\n\n- \"002582"
            },
            {
                "text": " To invalidate years, you need a regular expression that checks if the year is a leap year.\n\n```python"
            },
            {
                "text": " (\\d{3,5})[[:alpha:]]{1}\\d{3}([1-9]"
            },
            {
                "text": " \n^\\d{4}-\\d{2}-\\d{2}(?:\\d{"
            },
            {
                "text": " \"^[0-9]{3}\\D+[0-9]{4}$\"\n\"^"
            },
            {
                "text": " \n[0-9]{2}[0-9]{3}[0-9]{2"
            },
            {
                "text": " \n(15|000)|000(?=\\2)\n\n2. Given an input string, write a"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{2}\nExercise 5: Create a Reg"
            },
            {
                "text": "\n[0-9]{2,2}(?=((1[012])|(2[0-"
            },
            {
                "text": " (The regex might vary and you might need to tweak it a little to fit the problem)\n^([2-9"
            }
        ]
    },
    {
        "expression": "^((\\\"[^\\\"\\f\\n\\r\\t\\v\\b]+\\\")|([\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+(\\.[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+)*))@((\\[(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))\\])|(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))|((([A-Za-z0-9\\-])+\\.)+[A-Za-z\\-]+))$",
        "raw_prompt": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid: !#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "refined_prompt": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid: !#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bob.builder@[1.1.1.1]\"\n- \"\"blah b. blahburger\"@blah.com\"\nNon-match examples:\n- \"./A/Wacky/User@weirdos.com\"\n- \"bob.builder@[256.1.1.1]\"",
        "matches": [
            "/A/Wacky/User@weirdos.com",
            "bob.builder@[1.1.1.1]",
            "\"blah b. blahburger\"@blah.com",
            "dsfa@gmail.com",
            "sdfa@qq.com",
            "dsfia@fad.com",
            "fiosdj@sdf.com",
            "fdisojfsd@ijo.com",
            "fdsia@qq.com",
            "sfidj@afs.com",
            "fdjsi@msft.com",
            "jsifd@ifjs.com",
            "jsifdjsd@fsd.com"
        ],
        "non_matches": [
            "./A/Wacky/User@weirdos.com",
            "bob.builder@[256.1.1.1]",
            "-\"blah b. blahburger\"@blah.com",
            "fasd@fds.fasd@",
            "sfalijad234",
            "3nf@@",
            "@#dfkjnav",
            "2546dgwre@@",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "99999@gmail@@"
        ],
        "id": 287,
        "output": [
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b/"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b@"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"baz"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bob"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b-"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bobb"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bob"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b/"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"baz"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bobs"
            }
        ]
    },
    {
        "expression": "^(\\d|-)?(\\d|,)*\\.?\\d*$",
        "raw_prompt": "Input for Numeric values. Handles negatives, and comma formatted values. Also handles a single decimal point",
        "refined_prompt": "Input for Numeric values. Handles negatives, and comma formatted values. Also handles a single decimal point\nMatch examples:\n- \"5,000\"\n- \"-5,000\"\n- \"100.044\"\nNon-match examples:\n- \"abc\"\n- \"Hundred\"",
        "matches": [
            "5,000",
            "-5,000",
            "100.044",
            "8",
            "9",
            "4",
            "5",
            "54",
            "486",
            "184",
            "735",
            "48.48",
            "485"
        ],
        "non_matches": [
            "abc",
            "Hundred",
            "1.3.4",
            "-123afds",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "245/524/12",
            "adfa2",
            "34.31afd",
            "99999@gmail"
        ],
        "id": 288,
        "output": [
            {
                "text": " (.{3,4})+, (.{4,4})+\n\n5. How would you combine this exercise with the'string.format' method?\nAnswer: you use two variables,'string' and 'numbers', to pass"
            },
            {
                "text": "\n\nimport re\nexpr= ''.join([chr(127+i) for i in xrange(30)])+'([\\\\w\\\\.-]*)([,\\\\d]+)([\\\\.\\\\,]*)(["
            },
            {
                "text": " \n([\\d\\.\\-\\,]+)(\\s[\\d\\.\\-\\,]+)\nNon-digit examples:\n- \"Hundred\"\n- \"Alpha\"Generate a RegEx for this description.\nAnswer: "
            },
            {
                "text": "\n\\\\d[,]?\\\\d+ \nI was trying to generate this by making each option have an \"x\" and each number have an \"x\" too. But it's not working out. I am unsure where I'm going wrong"
            },
            {
                "text": " ([0-9]*(?:\\.\\d{0,4})?)\n\nExercise 3: Email Validation\nExercise: Write a RegEx expression that validates email addresses like \"test@example.com\" or \"info"
            },
            {
                "text": " \"^[0-9]+(,[0-9]+)?$\"\n2. Given the String `\"5,400,000,000,000\"`, extract the number into an integer:\nAnswer: 540000000000000\n3."
            },
            {
                "text": " 1-char match\nimport re\ndef regex(s):\n    if not (s.startswith('-') and s.endswith('.') and int(s[1:-1]) > 0 and len(s) >"
            },
            {
                "text": " abc does not match because it does not contain an integer and decimal/fraction and does not begin with the '-' or '(' character. Hint: look at the pattern. \n\n##### Exercise 2\nWrite a RegEx that will"
            },
            {
                "text": " [\"(0-9]+,\\s)?[0-9]+([,.]\\d+)?(,\\s)+[0-9]+\"]\n\n##Exercise 2: Use the data given in Exercise 1, remove any non"
            },
            {
                "text": " (?![a-zA-Z])[A-Za-z0-9.+-]{1}\\.[0-9]{1}(?![a-zA-Z])\n- \"5,000,"
            }
        ]
    },
    {
        "expression": "^[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive integers that are greater then 0. Easily modified for +/- intergers and allowing zero.",
        "refined_prompt": "^[1-9]+[0-9]*$\nMatch examples:\n- \"1\"\n- \"12\"\n- \"124\"\nNon-match examples:\n- \"-1\"\n- \"a\"",
        "matches": [
            "1",
            "12",
            "124",
            "489",
            "4985",
            "45",
            "459",
            "561",
            "456",
            "54",
            "798",
            "4895",
            "13"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0",
            "845-",
            "49516-fwfd",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "34.31451",
            "32542gdf"
        ],
        "id": 289,
        "output": [
            {
                "text": "\n^[1-9][0-9]*$\n\nExercise 3:\nA function is given by the equation: f(x) = 2x - 1. Use a function to determine the y-coordinate of the point (2,-1).\nAnswer:\nWe can define the function f("
            },
            {
                "text": " \"^[a-zA-Z][a-zA-Z0-9_]*$\"\n\n\n# Chapter: The Use of Python RegEx for Network Security Specialist\n\n## Sections:\n1. Introduction to Python Regular Expressions\n2. Regex Syntax and Metacharacters\n"
            },
            {
                "text": " (at least 2 of these).\n\n3. Write a negative lookahead assertion to make the following regex fail:\n\"^(?!123456789).{3}$\"\nMatch examples:\n- \"12345678\"\n- \"12\"\nNon-match examples:\n- \"1234567"
            },
            {
                "text": " [-1]\n\nExercise 2: Write a Python function that takes in a string and checks if it contains any digits or characters outside of the English alphabet:\n\nimport re\n\ndef check_for_non_alpha(string):\n    pattern = re.compile(r'^[a-zA"
            },
            {
                "text": " [-1-9]+[0-9]*$\n\n2. Create and run the Flask application that displays an HTML page with a pattern list for regex matching expressions.\n\nSolution:\n\nfrom flask import Flask, render_template\napp = Flask(__name__, static_folder='regex')\n"
            },
            {
                "text": " [1-9][0-9]*$\n\n\nExercise 3: Explain the purpose of regular expressions. \nAnswer: Regular expressions are used to match patterns in text data, for validation, search, and string manipulation purposes. They are able to perform complex patterns of text searching by recognizing and matching character classes and quant"
            },
            {
                "text": "\n\n^[1-9][0-9]*$|^[1-9][0-9]*(.)([1-9][0-9]*)\n\nUse online RegEx test engines to test and practice on a larger set of inputs.\n\nTitle: Manipulating Strings in"
            },
            {
                "text": " [0-9]+[a-z]\n\n```python\nimport re\n\ndef validate_iban_country(iban):\n    pattern = re.compile(r\"[A-Z]\\d[A-Z]\\d[A-Z]\\d[A-Z]\\d"
            },
            {
                "text": " (.*?)([1-9])$\n\nExercise 4: Use a list comprehension to find all numbers greater than or equal to 5 that are divisible by 2 or 3.\nAnswer:\nx = [i for i in range(1,21) if i % 2 == 0 or i % 3 =="
            },
            {
                "text": "\n^[1-9]+[0-9]*$\n\nExercise 2: \nChoose the following words: \n- abc  \n- defghij  \n- hello_world  \nMatch examples: \na-abc  \nb-defghij  \nc-hello_"
            }
        ]
    },
    {
        "expression": "^(([a-z])+.)+[A-Z]([a-z])+$",
        "raw_prompt": "This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.",
        "refined_prompt": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\"",
        "matches": [
            "com.test.Test",
            "com.Test",
            "afd.Tds",
            "fds.adfs.Tfds",
            "fdsioj.fdso.Tdfs",
            "apple.banana.Class",
            "sdaf.fa.Osdfa",
            "fqidf.fdsi.Fdsa",
            "run.ran.Run",
            "apple.apple.Apple",
            "name.abc.Cds",
            "dfisf.Fds",
            "jdif.Irw"
        ],
        "non_matches": [
            "com.test.test",
            "com.test.TEst",
            "Com.test.Test",
            "Mastercard",
            "123.456.789",
            "2/3/5235",
            "afdsFDS",
            "FDS.FDsfd.dsf",
            "fgdg.dgf.fgsd",
            "gfd.gfd.gdf",
            "Rwer.wer.Fds",
            "gfdgf.WERfdg.FDS"
        ],
        "id": 294,
        "output": [
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst."
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            }
        ]
    },
    {
        "expression": "^[a-zA-Z_][a-zA-Z0-9_]*$",
        "raw_prompt": "Matches variable names/identifier from C# (and most other languages)",
        "refined_prompt": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"",
        "matches": [
            "VariableName",
            "i",
            "Some_Value_3",
            "afds9",
            "sfjdio98",
            "jifds89u",
            "f9jdis",
            "_98fdsj",
            "jifd89",
            "jisdf98",
            "jifds09",
            "j8fid09",
            "jifdqwe"
        ],
        "non_matches": [
            "3ID",
            "Hello World",
            "jfdiosj sjfkljs",
            "j90u9u sfdijo",
            "908sfjkj sjdifoj",
            "98jfdsk",
            "908fjids",
            "9wrer",
            "9apple",
            "fijd8j8j j8fjds",
            "jifdj8j 8sdf j",
            "notre dame"
        ],
        "id": 295,
        "output": [
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            }
        ]
    },
    {
        "expression": "^((4\\d{3})|(5[1-5]\\d{2}))(-?|\\040?)(\\d{4}(-?|\\040?)){3}|^(3[4,7]\\d{2})(-?|\\040?)\\d{6}(-?|\\040?)\\d{5}",
        "raw_prompt": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)",
        "refined_prompt": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"",
        "matches": [
            "3711-078176-01234",
            "4123 5123 6123 7123",
            "5123412361237123",
            "526837376552 0992",
            "5552 43417106 3775",
            "3756-994651 29766",
            "483274536109 3049",
            "3495 24794717789",
            "3790685951 52358",
            "3769781961 92352",
            "345339087687813",
            "379590296125359",
            "341745514648436"
        ],
        "non_matches": [
            "3711-4123-5123-6112",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435afsd",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 299,
        "output": [
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generators"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generated"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generating"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generator"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generators"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generation"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generated"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generations"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generate"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generate"
            }
        ]
    },
    {
        "expression": "^((\\d?)|(([-+]?\\d+\\.?\\d*)|([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d+\\.?\\d*))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d+\\.?\\d*)))$",
        "raw_prompt": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional). Based pretty heavily on an expression by Steven Smith on this site.",
        "refined_prompt": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional).\nMatch examples:\n- \"8.0\"\n- \"8.0,-.38,+8.9\"\n- \"8.0, +8.8, 0.09\"\nNon-match examples:\n- \"+\"\n- \".\"",
        "matches": [
            "8.0",
            "8.0,-.38,+8.9",
            "8.0, +8.8, 0.09",
            "4894",
            "48956.456",
            "56.4895",
            "645.489",
            "456.4895",
            "465",
            "489",
            "15",
            "48",
            "46"
        ],
        "non_matches": [
            "+",
            ".",
            "a,b, c",
            "12/123/4322",
            "123.456.789",
            "43.v234",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 300,
        "output": [
            {
                "text": " \n\\+\\s\n\nExercise 4:\nCreate a new instance variable called \"number_format\" for an existing customer object. Write an if statement that"
            },
            {
                "text": " [^-+,\\.,]\n--\n1. Write a RegEx matching all dates in the format \"DD/MM/YYYY\".\n- \"01/"
            },
            {
                "text": " [^0-9 +.]\n- \"-\" Generate a RegEx for this description.\nAnswer: [^0-9 -.]\n- \",\"gener"
            },
            {
                "text": " \"\"([^\"])*(\"[^\"]*\")([^\"]*)\"\"\"\n\nExercise 3:\nWrite a Python function, split_and_sum("
            },
            {
                "text": " [\\+]|[.,] \n\n3. Write a regex for the following sentence:\n- \"The weather today is 25C. The temperature yesterday was"
            },
            {
                "text": " \"+[0-9]\\.?[0-9]+\"\n\n8.3.4. Repeat the preceding expression {0,1,} non-capt"
            },
            {
                "text": " (.*)[\\+\\.]\nFor other problems, you should use \"The online regex tools are your best friend!\"\nMore Resources:\n-  http://www"
            },
            {
                "text": " `\\+`\n\n3. You have been given two strings representing points in the form (x, y), with + and * representing addition and multiplication, respectively."
            },
            {
                "text": " \"\\d+\\.\\d+\"\n4. Test whether a string of text matches the following expression:\n- the string may begin and end with a space\n-"
            },
            {
                "text": " \"^\\+\\d\\.\\+\\d\\s*$\" allows both positive and negative numbers with decimal points\n- \"^\\+$\"\n\n"
            }
        ]
    },
    {
        "expression": "^(.|\\n){0,16}$",
        "raw_prompt": "Limit Length - limit the length of a text box or other area to contain any character plus new line",
        "refined_prompt": "Matches strings containing up to 16 characters, including newline characters. It allows any combination of characters and newlines within this limit.\nMatch examples:\n- \"shorter than max\"\n- \"sgfdij\"\n- \"jiodfk90\"\nNon-match examples:\n- \"string longer than max\"\n- \"9uionjy89ubih8bhuk78byu\"",
        "matches": [
            "shorter than max",
            "sgfdij",
            "jiodfk90",
            "(JIOFDS",
            "h8uijnkdfs",
            "9ijknsd",
            "ijnkfdiok",
            "iojkfgij3",
            "ijo9ijotygv",
            "0u9ioj",
            "87yuhi",
            "78ugij",
            "78"
        ],
        "non_matches": [
            "string longer than max",
            "9uionjy89ubih8bhuk78byu",
            "b8uy8ikuhiuij,kuhb",
            "78yguh78guibjhghjjvjhk",
            "uhijuhijknuhijk9y8huijgui",
            "78giu78ogyu78gyu5drutcf78gyhu",
            "ugib89guilb78tgoyhuvogyhuv7ygohu",
            "guihbj8guij b8 uij uohijk",
            "uhij9 uij6f7 tuygd6 tuygh9 huijk",
            "9huijkuhijlkuibjlkguibj",
            "gy8ibhjg8yuhbjguibjkujk",
            "giftygjn8guijbhiojkhijnk"
        ],
        "id": 308,
        "output": [
            {
                "text": "\n(\\s|^|\\W)+\n\n2. Write a Python program that calculates the sum of all numbers in a given string"
            },
            {
                "text": " (r'\\b(?=[^a-z0-9]|^)[^0-9a-z]*"
            },
            {
                "text": " My regular expression will match the \"string longer than max\" string, but will not match the \"9uionjy89ubih"
            },
            {
                "text": " [0-9]+\n\nExercise 2: Create a function that takes a regex string and a text string as input and returns a"
            },
            {
                "text": "\n[(?<=^| ).]{1}(?= )((?:\"[^\"]*\\\")*|"
            },
            {
                "text": " (?:.{0,16})(?= $)\n\nExercise 3:\nQ: What is the purpose of escaping"
            },
            {
                "text": " \n[0-9a-zA-Z]{1,30}\n\nChapter 3: Applications of RegEx\n"
            },
            {
                "text": " The RegEx is r'.*?(?=(.{16}$).*?(?=.*[\\w]))"
            },
            {
                "text": " \n\"(string|longer than)+shorter than (max|longer than 0|longer than 9)\"\n\n\n\n\n"
            },
            {
                "text": " \\b[a-z]+|\\b[A-Z]+\\b\n\nThis regular expression will match single uppercase"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]\\:)(\\\\[^\\\\/:*?<>\"|]*(?<![ ]))*(\\.[a-zA-Z]{2,6})$",
        "raw_prompt": "Matches filenames.\nUPDATED on 1st Jan 2004.",
        "refined_prompt": "Matches filenames that follow the pattern of a Windows file path, consisting of a drive letter, a path within the drive, and a file extension.\nMatch examples:\n- \"C:\\di___r\\fi_sysle.txt\"\n- \"c:\\dir\\filename.txt\"\n- \"d:\\dir\\fads.abc\"\nNon-match examples:\n- \"c:\\dir\\file?name.txt\"\n- \"c:\\f34fvfv\"",
        "matches": [
            "C:\\di___r\\fi_sysle.txt",
            "c:\\dir\\filename.txt",
            "d:\\dir\\fads.abc",
            "d:\\dir\\agd.txt",
            "d:\\dir\\gas.org",
            "D:\\di___r\\fi_sysle.png",
            "D:\\dir\\fi_sysle\\afd.cat",
            "D:\\di___r\\abas.def",
            "E:\\di_fadsf__r\\abas.afd",
            "E:\\dgha\\abas.afd",
            "E:\\asdg\\dsag.com",
            "E:\\baqe\\afd.efg",
            "E:\\baf\\vds.abd"
        ],
        "non_matches": [
            "c:\\dir\\file?name.txt",
            "c:\\f34fvfv",
            "c:\\34f2vf42e",
            "c:\\fasd@fds.fasd@",
            "c:\\2346-2345-2435",
            "c:\\2/3/5235",
            "c:\\@#dfkjnav",
            "c:\\12f3.21f3.213f",
            "c:\\qwerty@123.123",
            "c:\\(0xx12) 7256 2345154",
            "c:\\sda sad",
            "c:\\99999@gmail"
        ],
        "id": 312,
        "output": [
            {
                "text": " r'^\\/[A-z\\"
            },
            {
                "text": " /^[a-zA-Z"
            },
            {
                "text": " [^(?:\\s$|\\\\"
            },
            {
                "text": "\n# import re\nimport re\n\n"
            },
            {
                "text": "\n- (^[a-z0"
            },
            {
                "text": " \"\\w+\\.txt$\"\n\n"
            },
            {
                "text": " \"\\+?[A-z0-"
            },
            {
                "text": " \"([a-z]{1,"
            },
            {
                "text": " /^(C\\S*)\\_"
            },
            {
                "text": " The RegEx pattern '^(([a"
            }
        ]
    },
    {
        "expression": "^(([0-9])|([0-1][0-9])|([2][0-3])):?([0-5][0-9])$",
        "raw_prompt": "For testing 24H based time entry. Tests if there is a colon to separate the hours from the minutes",
        "refined_prompt": "Match and validate time in a 24-hour format (hh:mm). It allows for hours ranging from 0 to 23 and minutes ranging from 00 to 59. The colon (\":\") between hours and minutes is optional, and the regex ensures that the input conforms to this specific time format.\nMatch examples:\n- \"0959\"\n- \"959\"\n- \"9:59\"\nNon-match examples:\n- \"90\"\n- \"960\"",
        "matches": [
            "0959",
            "959",
            "9:59",
            "534",
            "825",
            "2332",
            "542",
            "645",
            "23:24",
            "17:26",
            "23:36",
            "8:48",
            "2:18"
        ],
        "non_matches": [
            "90",
            "960",
            "24:00",
            "12/123/4322",
            "23441",
            "999",
            "978",
            "9789",
            "97899",
            "897-",
            "9/9/9",
            "32542"
        ],
        "id": 315,
        "output": [
            {
                "text": " \nTo generate a RegEx for a specific time format, we can use the"
            },
            {
                "text": " \n\"Match any time in a range of 0-23 hours in minutes.\""
            },
            {
                "text": " \\d{1,2}(:\\d{2})? \n\n"
            },
            {
                "text": " a positive lookahead at the beginning matches only if \"9\" appears exactly before \""
            },
            {
                "text": " a. ([0-9]):(:[0-9]|\\d"
            },
            {
                "text": " \\d\\:?\\d\nThis regex ensures that all characters in a time"
            },
            {
                "text": " \n\n(0\\d{1,2}|1\\d|"
            },
            {
                "text": " The regex should match the string starting from 00:00 and going all the way up"
            },
            {
                "text": " \"hh[0-5][0-9]:mm\"\n\n\nSub"
            },
            {
                "text": " /^\\d?\\d:\\d\\d$/\n\n2."
            }
        ]
    },
    {
        "expression": "^0(6[045679][0469]){1}(\\-)?(1)?[^0\\D]{1}\\d{6}$",
        "raw_prompt": "Validates Austrian Cellular Phone Numbers. Works with ONE, T-Mobile, A1, Telering and new Provider &quot;Drei&quot;. WITHOUT Country Code Verification.",
        "refined_prompt": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06641234567\"\n- \"0699-11234567\"\nNon-match examples:\n- \"06991-1234567\"\n- \"+43650-1234567\"",
        "matches": [
            "0664-1234567",
            "06641234567",
            "0699-11234567",
            "0670-2491611",
            "06748693086",
            "0674-3182376",
            "0669-18315672",
            "06063847671",
            "0670-18703482",
            "0649-1102467",
            "06961945088",
            "06902583647",
            "0606-5415789"
        ],
        "non_matches": [
            "06991-1234567",
            "+43650-1234567",
            "07661234567",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 317,
        "output": [
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"5"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"000000"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"0"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"0"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"0"
            }
        ]
    },
    {
        "expression": "^1?[1-9]$|^[1-2]0$",
        "raw_prompt": "Matches a whole number between 1 and 20 inclusively",
        "refined_prompt": "Matches a whole number between 1 and 20 inclusively\nMatch examples:\n- \"1\"\n- \"11\"\n- \"20\"\nNon-match examples:\n- \"0\"\n- \"21\"",
        "matches": [
            "1",
            "11",
            "20",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13"
        ],
        "non_matches": [
            "0",
            "21",
            "165",
            "156",
            "45651",
            "456",
            "56",
            "165798",
            "48561",
            "4516",
            "51",
            "9786"
        ],
        "id": 318,
        "output": [
            {
                "text": " \\d\n\nExercise 5: Nested Conditions\nA RegEx should match a string consisting entirely of the characters'm' and 'p', but the first and last characters must be 'p'. Write the RegEx that matches this description.\nExample: \"mpnp\"Match examples:\n- \"mpnp\"]\nNon"
            },
            {
                "text": " matches the number \"0\"\n\nExercise 3:\nRewrite this sentence using a RegEx to search for all words that begin with \"a\":\n- \"It was raining on the day I went to the beach.\"\nAnswer: rewrites the sentence to contain \"day\" and add a capital \"D\".\n\n"
            },
            {
                "text": " \"^0\\d{1,2}$\"\n\n* Exercise 4: \nYou work in a company that produces cleaning products as well as beauty products. One day, your boss asked you to create a RegEx to identify a product that contains the word \"clean.\"\n\nExample: Cleaning products\nMatch examples:"
            },
            {
                "text": " r\"^([1-9]|[1-9][0-9])$\"\n\n\n\nQuestion 6: A bookstore sells two types of books: fiction and non-fiction. The ratio of fiction books to non-fiction books is 3:5. If the store has a total of 320 books, how many are"
            },
            {
                "text": " \\d{1,20}\n\n##### Exercise 2:\nCreate a RegEx to match any word that begins with either \"a\" or \"e\" up to 5 characters long.\n- \"Apple\"\n- \"Bear\"\n- \"Elk\"\nNon-match examples:\n- \"Zebra\"\n"
            },
            {
                "text": " (Regex)^[1-9]|[1-9][0-9]\n\nLecture Script: 6.2.3 Defining and Applying Regular Expression Patterns\n\nContent:\n- Understanding Regular Expressions\n- Basic Regular Expression Syntax\n- Special Characters in Regular Expressions\n- Application"
            },
            {
                "text": " (0|1)(0|9|2)\n- \"25\"  Generate a RegEx for this description\nAnswer: (2|5)(0|9|2)\n\n3. Match a phone number where 1st three can start with any number then 2nd, 3rd and 4th can start with 0"
            },
            {
                "text": " [1-20]\n3. Generate a RegEx for a single comma separated name with 5 or 6 characters. \nHint: Use groups inside a character set. \nAnswer: (?<,name>\\w)(?,name(\\,\\w{0,1}*))(?<,name"
            },
            {
                "text": " 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19\n\n4. Write a program that takes a string and replaces all occurrences of \"Hello \" with \"Hi \".\nSolution:\n\nimport re"
            },
            {
                "text": " [a-zA-Z]\n- \"20a\"Generate a RegEx for this description.\nAnswer: ([a-z]{2})0\n\nExercise 3: Write a regular expression that matches a string containing 4 or more consecutive dots\nAnswer: [[.{4,}]]\n\nExercise"
            }
        ]
    },
    {
        "expression": "^[1-9][0-9]{3}\\s?[a-zA-Z]{2}$",
        "raw_prompt": "Validates Dutch Postal Codes (ZipCode). There was a previous one listed here, but it's not entirely correct. Namely that dutch postal codes can contain a zero but cannot start with one, so this one is the adjusted version.",
        "refined_prompt": "Validates Dutch Postal Codes (ZipCode).\nMatch examples:\n- \"1234AB\"\n- \"1234 AB\"\n- \"1001 AB\"\nNon-match examples:\n- \"0123AB\"\n- \"1234A B\"",
        "matches": [
            "1234AB",
            "1234 AB",
            "1001 AB",
            "1730\u00a0st",
            "3054\u2005Ue",
            "7278SY",
            "4669fb",
            "9708zV",
            "6899\u2029jQ",
            "2098az",
            "4552fJ",
            "2713mG",
            "5881Be"
        ],
        "non_matches": [
            "0123AB",
            "1234A B",
            "0123 AB",
            "12/123/4322",
            "sfalijad234",
            "43.v234",
            "43-5432",
            "98iojk",
            "324df",
            "adfa2",
            "sda sad",
            "3409fjg43"
        ],
        "id": 320,
        "output": [
            {
                "text": "\npattern = r\"^(13\\d{9}|8) CA\\w*$\"\n\nLecture Script:\n\nWelcome to today's lecture on Regular Expressions and the re module in Python. In this section, we will learn about regular expressions and how they"
            },
            {
                "text": " (?i)\\b\\d{1,4}\\s?[a-z]{1}\\s?[a-z]{1}\\b\n\nExercise:\nMatch the following:\n- \"15.78\"\n- \"16.5\"\n- \"16"
            },
            {
                "text": " \n^[A-Z]{1}\\s?[0-9]{3}[A-Z][0-9]{2}$|^[A-Z]{3}\\s?[0-9]{4}[A-Z][A-"
            },
            {
                "text": "\n[a-zA-z0-9 ]{4}[ -\\.,]{0,3}[a-zA-Z]\nExercise 4:\nName two applications where RegEx might be useful in everyday life. Answer:\nTwo applications where RegEx might"
            },
            {
                "text": " [a-zA-Z0-9]{3}[\\s\\-]\\d{2}[\\s\\-]\\d{4}\n\nExercise 4:\n- Using the Python RegEx module, search a log file for strings that match the pattern \"(ERROR"
            },
            {
                "text": "\nI need to create a regular expression to be able to validate the \"Zip\" code, i.e. what you see below. To make sure that there is only one of each of the listed combinations. Also we have to add the space between AB. And the last character has to make sure"
            },
            {
                "text": "\n- The regex: ^(?1)^.*?[0-9](?<!\\d$).*(?!\\d$).*\n- This regex will match the postal code \"1234A B\" as specified. \n\nIn conclusion, the concepts of Val"
            },
            {
                "text": " [\"11-12  \", \"1002AB\"]\n\nExercise 4: \n- \"AB1234\"\n- \"10-1234\"\n- \"1-1-1-1-3-4\"\n- Non-match examples:\n- \"AB1234"
            },
            {
                "text": " /(\\d\\d)([A-Z]\\.)|(\\d\\d)([A-Z] [A-Z])/\n\n```python\nimport re\n\n# Generate a regex for postal codes\npostal_codes = ['1234AB',\n                "
            },
            {
                "text": " [0-9]{5}\\s[A-Z]+\\s[A-Z]+\n\nExercise 3: \nWrite a Python function that takes in a mailing address string, parses it into its individual components (Street, City, State, ZIP) and generates a valid"
            }
        ]
    },
    {
        "expression": "^([0-9]*|\\d*\\.\\d{1}?\\d*)$",
        "raw_prompt": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related\nfields or decimal fields.",
        "refined_prompt": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"",
        "matches": [
            ".568",
            "8578",
            "1234567.1234567",
            "65",
            "465",
            "465.456",
            "87.98",
            "846.48",
            "465.48",
            "8456.486",
            "849.78",
            "896",
            "1623"
        ],
        "non_matches": [
            "568.",
            "56.89.36",
            "5.3.6.9.6",
            "12/123/4322",
            "123.456.789",
            "43.v234",
            "43-5432",
            "12f3.21f3.213f",
            "245/524/12",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 321,
        "output": [
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: (.\\d*).*\n\n(c) - (i) - (5) - - - - -"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: (\\d\\d.\\d+)$\"\"\"\n# 6.1.4 Patterns and rules for building"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: match the first two numbers and everything after it.\nExample: (0-9)\\..{2}\\.(0"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: \r\n\\d+(?:\\.\\d+)$\r\n\r\nExplanation for the code:"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: *(.*?)?(\\.\\d+)?(.*?)*<br>\r\n- \"2."
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: (\\d)?.\\d*\n- \" 56.89.36\"Generate a RegEx for this"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: \".{2}(.)(.[0-9])\"\n\nA:\n\nYou can use the following"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer:\n\\b[0-9]{1,3}(?:\\.[0-9]{3}"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: \\.([0-9]+\\.[0-9]+) \n- \"123\"Generate a Reg"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: ^[0-9]{3}(\\.|\\,)[0-9]{3}$\r"
            }
        ]
    },
    {
        "expression": "^(?=\\d)(?:(?:(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[1,3-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})|(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2}))($|\\ (?=\\d)))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "raw_prompt": "DateTime Validator.",
        "refined_prompt": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports optional seconds.\r\nValidates hours (1-12 in AM/PM format or 0-23 in 24-hour format) and minutes (0-59).\nMatch examples:\n- \"12/25/2003\"\n- \"08:03:31\"\n- \"02/29/2004 12 AM\"\nNon-match examples:\n- \"02/29/2003 1:34 PM\"\n- \"13:23 PM\"",
        "matches": [
            "12/25/2003",
            "08:03:31",
            "02/29/2004 12 AM",
            "12/26/2003",
            "12/25/2008",
            "11/25/2003",
            "08:04:31",
            "08:03:32",
            "09:03:31",
            "02/28/2004 12 AM",
            "02/29/2008 12 AM",
            "02/24/2004 12 AM",
            "02/29/2012"
        ],
        "non_matches": [
            "02/29/2003 1:34 PM",
            "13:23 PM",
            "24:00:00",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235 1:12",
            "/5/5/5 12 AM",
            "/5/5/20022",
            "432/524/2435 12 AM",
            "1-1-2 1:12",
            "9/9/9 12 AM",
            "12/132/90 1:12"
        ],
        "id": 322,
        "output": [
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports multiple"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports times"
            }
        ]
    },
    {
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))$|^([01]\\d|2[0-3])(:[0-5]\\d){0,2}$",
        "raw_prompt": "This RE validates times patterns.",
        "refined_prompt": "Validates time input in either 12-hour (with AM/PM) or 24-hour formats, allowing for optional minutes and seconds.\nMatch examples:\n- \"1 AM\"\n- \"23:00:00\"\n- \"5:29:59 PM\"\nNon-match examples:\n- \"13 PM\"\n- \"13:60:00\"",
        "matches": [
            "1 AM",
            "23:00:00",
            "5:29:59 PM",
            "12:07:52 PM",
            "22:43",
            "8 AM",
            "12:42 AM",
            "11:11 PM",
            "08:50 AM",
            "04:09",
            "11 AM",
            "03:01 PM",
            "6:35 PM"
        ],
        "non_matches": [
            "13 PM",
            "13:60:00",
            "00:00:00 AM",
            "12:97",
            "15:97",
            "32:78",
            "5:978",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "34.31",
            "12/132/90"
        ],
        "id": 323,
        "output": [
            {
                "text": " \n    1 + :?([0-2][0-9]):([0-5][0-9]) AM\n```\nI hope this example helps you"
            },
            {
                "text": " \"(1 \\d\\d){0,1}[ AM]|(2 \\d\\d)([ PM])(\\d\\d)(:[ \\d\\d])"
            },
            {
                "text": " \"(^|\\s)\"(1+\\d|[AM])(\\s)\\3(19|2) (\\s)(\\d|\\d:?\\"
            },
            {
                "text": " The RegEx for this description is: /^\\d{1,2}:\\d{2}:\\d{2}(?:AM|PM)?$/\n\n"
            },
            {
                "text": " \"1(?:-|AM)/(?:\\d(?:[.]\\d*)?|[:]\\d{2})\n2. Write a RegEx for the"
            },
            {
                "text": " ([0-9].{0,2}[a-z]|[0-2][0-9]|3[01]).*/^([1-8]["
            },
            {
                "text": " \"0-(\\d{2})\\s?(pm|PM)?\"\n\nExercise 3: \nValidate a time string in the format \"hh:mm"
            },
            {
                "text": " ^[0-9]?[1-9]?[0-9]? [A-Z][a-z0-9]?[A-Z]"
            },
            {
                "text": "\nThe regular expression for this description would be \\d{1,2} (AM|PM), \\d{1,2} (AM|PM), or \\d{"
            },
            {
                "text": " r'[0-1]\\d|[1-2]\\d|3[01]\\d|4[0-2]\\d|5[0"
            }
        ]
    },
    {
        "expression": "^(#){1}([a-fA-F0-9]){6}$",
        "raw_prompt": "Matches HTML Color strings. Like #FFFFFF is white and #000000 is black and #FF0000 is red and so on...",
        "refined_prompt": "Matches HTML Color strings.\nMatch examples:\n- \"#FFFFFF\"\n- \"#FF3421\"\n- \"#00FF00\"\nNon-match examples:\n- \"232323\"\n- \"f#fddee\"",
        "matches": [
            "#FFFFFF",
            "#FF3421",
            "#00FF00",
            "#D90e0F",
            "#7Ac136",
            "#CeE1eB",
            "#3D1f8d",
            "#462d56",
            "#0e6307",
            "#2a6Eef",
            "#8beB0c",
            "#e59d3c",
            "#4aafdc"
        ],
        "non_matches": [
            "232323",
            "f#fddee",
            "#fd2",
            "Mastercard",
            "sfalijad234",
            "43.v234",
            "43-5432",
            "2546dgwre",
            "000-000",
            "354/243/542",
            "abc111def",
            "32542"
        ],
        "id": 325,
        "output": [
            {
                "text": " ^#\\d+\n- \"rgb(2,2,2)$\"\n- \"rgb(3,4,5)$\"Generate a RegEx for this description.\nAnswer: rgb\\(.+\\),\nUse the RegEx from 4 to generate a collection"
            },
            {
                "text": " ^[a-z0-9,_@\\-\\.\\.]*\\b#([a-z0-9,_@\\-\\.\\.]*|\\d)*$ (regex101) \n- ^(hdr)[-\\u0080-\\u00FF\\"
            },
            {
                "text": " non-match examples in brackets []\n\n2. Given a Regex Match object, display the full line that matched.\nFor example, given a following code:\n>>> import re\n>>> line = \"This is a sample line\"\n>>> Match(\"This is a sample line\", line)\n<"
            },
            {
                "text": " This can be described as a RegEx that matches any string that contains at least one non-white space character and contains\n\n\"\"\"\n\nimport re\nimport requests\nimport csv\nimport os\nfrom dataclasses import asdict\nfrom json import dumps, loads\nfrom datetime import datetime"
            },
            {
                "text": " \"^#[0-9A-Fa-f]{6}$\"\n\nExercise 3: \n\nMatch regular expressions that match integers: 1, 2, 3, 4, 5\nRegular Expression Example: \\d\nAnswer:\n\"([0-9])\"\n\""
            },
            {
                "text": " ^#[A-Fa-f0-9][A-Fa-f0-9]\\s?$\n- Match all hexadecimal color.\nAnswer: #[A-Fa-f0-9]{6}\n- Match decimal, hexadecimal, and"
            },
            {
                "text": "\n\\d{1,3}(?:[a-fA-F0-9]{1,3}){1,2}\n\n\n\nQuestion 8: A car drives at a constant speed of 60 miles per hour. If it travels for 4 hours, how far will it have"
            },
            {
                "text": " (#[0-9A-Fa-f]{6})\\s([a-zA-Z]{3,4})\n\nExercise 4:\nWhat's not a Python keyword? Write down three examples that you can think of as not Python keywords.\nPython is an interpreted,"
            },
            {
                "text": "\nimport re\nHTML_COLOR_PATTERN = re.compile('#[0-9a-fA-F]{6}')\n\nExercise 4: \nCreate a function that adds a random hex color to a CSS string.\nAnswer:\nimport random\nimport"
            },
            {
                "text": " \n(?i)[a-z](?<=h)[a-z](?<=s)[a-z](?=0[0-9]+[0-9])(?<![0-9])|([0-9])(?=[a-z])"
            }
        ]
    },
    {
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])(\\d{4}))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "Date in DD/MM/YYYY format.\nFecha en formato DD/MM/AAAA.",
        "refined_prompt": "Date in DD/MM/YYYY format.\nMatch examples:\n- \"28/12/2003\"\n- \"28/02/2003\"\n- \"29/02/2000\"\nNon-match examples:\n- \"28-02-2003\"\n- \"30/02/2003\"",
        "matches": [
            "28/12/2003",
            "28/02/2003",
            "29/02/2000",
            "29/02/3200",
            "29/02/5676",
            "29/02/6608",
            "21/02/8399",
            "01/11/2510",
            "29/02/7032",
            "29/02/1504",
            "13/02/4580",
            "30/10/0687",
            "29/02/9288"
        ],
        "non_matches": [
            "28-02-2003",
            "30/02/2003",
            "28.02.2003",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/91341",
            "12/132/90"
        ],
        "id": 327,
        "output": [
            {
                "text": " (?<day>\\d{1,2})/(?<month>\\d{2})/(?<year>\\d{4})\n\nIn this exercise, we generated a regex to match this type of date"
            },
            {
                "text": " A regex could be [\\d]{2}(\\/[\\d]{2})?\\/[\\d]{4}.\n\nJournal Entry:\n\nExercise 1:\nQuestion: How to use the unitt"
            },
            {
                "text": " [DD,MM,yy]\n\n```python\ndates = [\"28/12/2003\", \"28/02/2003\", \"29/02/2000\", \"28-02-2003\", \"30/02/2003\"]"
            },
            {
                "text": " [A-Z]\\d[A-D-M-T\\s] (date format) (any additional rule)\n\n- \"03-20-2004\" \n- \"01/20/2004\" \n-"
            },
            {
                "text": " \\d-\\d-\\d\\/\\d\\d\\d\\d\n- \"29/02/2003\"Generate a RegEx for this description.\"\n\"\"\"\n```\n\n```python\ndaterange_"
            },
            {
                "text": "^0[1-9]|1(?:0|[1-9])[0-9]{2}|2[0-8]/[0-9]{3}$\n\nWe can use List comprehension"
            },
            {
                "text": " \"^\\d{2}\\/\\d{2}\\/\\d{4}$\"\n\nExercise 3:\nList two examples in which regular expressions make a significant difference in quality assurance.\nAnswer: \n1."
            },
            {
                "text": "\n(?i)\\d{1,2}[\\/](\\d{1,2})/(\\d{4})$\n\n2. Check if string of the following form \"2:10-11:00,1-"
            },
            {
                "text": "\npattern = \"/^(\\d+)/(\\d+)/(\\d+)\\s$/.match(description);\n\nExercise 3:\nWrite a Python program that converts a given temperature in Kelvin to Celsius and vice versa.\nAnswer"
            },
            {
                "text": ".{3}-\\d{2}-\\d{4}\n\nExercise 3:\nExplain why it's important to provide detailed use cases of the data we're parsing. \nAnswer: Providing detailed use cases"
            }
        ]
    },
    {
        "expression": "(^[0-9]{1,8}|(^[0-9]{1,8}\\.{0,1}[0-9]{1,2}))$",
        "raw_prompt": "Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot.",
        "refined_prompt": "Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot.\nMatch examples:\n- \"1.00\"\n- \"2345\"\n- \"332.3\"\nNon-match examples:\n- \".00\"\n- \"23333333333.00\"",
        "matches": [
            "1.00",
            "2345",
            "332.3",
            "9015.76",
            "0876.60",
            "30337975.54",
            "261814",
            "426732.8",
            "4",
            "5",
            "6",
            "5438996",
            "4856123"
        ],
        "non_matches": [
            ".00",
            "23333333333.00",
            "j22.00",
            "-123af",
            "234/423/5243",
            "43.v234",
            "56dfsa",
            "12f3.21f3.213f",
            "324df",
            "341.431v4f3.fv1",
            "abc111def",
            "12/132/90"
        ],
        "id": 332,
        "output": [
            {
                "text": ".00\n- \".5\"\nNon-match examples: \n- \"3500.23\"\n- \"33.333333333.00\"\n- \"33.33"
            },
            {
                "text": " ^.{0,2}[1-9]\\d\\D[1-9]\\d[1-9]\\D[1-9]\\D[1"
            },
            {
                "text": " \n[^0-9].{0,8}\\.[^0-9].{0,2}(\\.0)?\n\nA:\n\nThis should do the job"
            },
            {
                "text": " '^(\\\\d\\d|\\d\\d\\d)\\.0*$'\nHere you can see an example with the same description:\n#include <iostream"
            },
            {
                "text": " (.*\\.([0-9]{1,2}$|\\.[0-9]([1]\\d?|[2]\\d$))|.*)"
            },
            {
                "text": " The generated regular expression will be \"^\\d{1,2}(\\.\\d{1,2})?$. \n8. Generate A Regular Expression to match numbers with"
            },
            {
                "text": " (?<=\\.).{1,3}(?=(\\d|$))\nReplace.0 with the corresponding value from regex.\n\nA:\n\nThe regular"
            },
            {
                "text": " *[^0-9\\\\.-]*.*[^0-9\\\\.-]*[0-9]$/\n\nA:\n\nThere is no need to use"
            },
            {
                "text": ".{8}(?:.{2})?\nMatch examples:\n- \"12.34\"\n- \"1234\"\nNon-match examples:\n- \"1234"
            },
            {
                "text": ".*(?:\\\\d\\\\.\\\\d{2}(?:\\\\.\\\\d{3})?|\\\\d{3}(?:\\\\.\\\\d{2})?)"
            }
        ]
    },
    {
        "expression": "^[AaWaKkNn][a-zA-Z]?[0-9][a-zA-Z]{1,3}$",
        "raw_prompt": "Simple match for U.S. Amateur Radio Call signs\nMust start with an A,K,N or W.\n1 or two prefix letters (not case sensitive),\nExactly one zone digit,\nOne to three suffix digits( not case sensitive).\n73",
        "refined_prompt": "Simple match for U.S. Amateur Radio Call signs\r\nMust start with an A,K,N or W.\r\n1 or two prefix letters (not case sensitive),\r\nExactly one zone digit,\r\nOne to three suffix digits( not case sensitive).\nMatch examples:\n- \"kd6dun\"\n- \"W9OXZ\"\n- \"kb8ae\"\nNon-match examples:\n- \"kdd90bz\"\n- \"de7bgw\"",
        "matches": [
            "kd6dun",
            "W9OXZ",
            "kb8ae",
            "A0Icp",
            "A7BxG",
            "Wg4x",
            "k9Zqy",
            "k2dGw",
            "N1jM",
            "A0BK",
            "N4Rl",
            "a2QJ",
            "a3zvj"
        ],
        "non_matches": [
            "kdd90bz",
            "de7bgw",
            "WV7BXQ5",
            "fads2fe",
            "2feef",
            "e2ffe",
            "f2eafe",
            "f2ewds",
            "qwerty@123.123",
            "354/243/542",
            "abc111def",
            "12/132/90"
        ],
        "id": 333,
        "output": [
            {
                "text": "\n^(A?K?N"
            },
            {
                "text": " (?=\\w{1}\\"
            },
            {
                "text": " Regex: R[A-Z"
            },
            {
                "text": " [a][a-zA-"
            },
            {
                "text": " ^[AKWN][0-"
            },
            {
                "text": " (?:A|K|N|"
            },
            {
                "text": " /^([ALKNWM]\\"
            },
            {
                "text": " [Kd6d](.[3"
            },
            {
                "text": " [kd]?[0-"
            },
            {
                "text": " r'\\-?.*?[a"
            }
        ]
    },
    {
        "expression": "^(Sun|Mon|(T(ues|hurs))|Fri)(day|\\.)?$|Wed(\\.|nesday)?$|Sat(\\.|urday)?$|T((ue?)|(hu?r?))\\.?$",
        "raw_prompt": "This RE matches Days of the week or their abbreviations.",
        "refined_prompt": "This RE matches Days of the week or their abbreviations.\nMatch examples:\n- \"Sunday\"\n- \"Mon\"\n- \"Tu\"\nNon-match examples:\n- \"day\"\n- \"Wedday\"",
        "matches": [
            "Sunday",
            "Mon",
            "Tu",
            "Thu",
            "Sun",
            "Tu.",
            "Wed",
            "Sat.",
            "Sun.",
            "Thurs",
            "Wednesday",
            "Saturday",
            "Thursday"
        ],
        "non_matches": [
            "day",
            "Wedday",
            "Payday",
            "Mastercard",
            "afdfs",
            "sundafahds",
            "ewnefdesday",
            "happyday",
            "mothersday",
            "childrensday",
            "sadday",
            "notredameday"
        ],
        "id": 338,
        "output": [
            {
                "text": " R0-W(day)|R1-W(dow) (of) the day\n\nSolution:\n\nimport re\ndays_of_week = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",\"Saturday\"]\n\npattern = r\"(?<!d)\"+"
            },
            {
                "text": " _\n\n4) Write a RegEx to match URLs with a specific domain like \".com\". \nAnswer: \\bhttps?://(?:[-\\w.]|(?:%[\\da-fA-F]{2}))+\\.com\\b\n\n5) Given a list of emails"
            },
            {
                "text": " (\\d+)[st|nd|rd|th][a|b|c]?\n\n4. Exercise: Modify the \"day2num.py\" code to exclude non-matching match examples from the match set.\nAnswer: (^[a-z]|[0-9]|"
            },
            {
                "text": "\n-[Sa]nd[w][e]nd[.][o]d[a]r\n```\n\n\n\n\n## Section Overview\n\n1. Introduction to the Confusion Matrix\n2. Applying a Confusion Matrix in Python\n3. Interpreting the Confusion Matrix\n4. Use"
            },
            {
                "text": " r\"(\\b1st|\\b2nd|\\b3rd|\\b4th|\\b5th|\\b6th|\\b7st\\b)\" \n\nThe given section of the Python and RegEx textbook was well written and presented, making it easy for me to learn and understand"
            },
            {
                "text": "\na. [Monday,...]\nb. (...)\nc. (...)\nD. \\d{1,2}\ne. (...)\nf. (...)\nG. \\w+\nHope I helped you, let me know if you have any other questions or comments!\n\nStudent: Hi"
            },
            {
                "text": " ^\\d{1,2}\\s\\w\\s(?:day|ord?)$\n\nThis RE will match words of length 3 or more, which is the length of your word \"year\".\n\nA:\n\nTo check if a date is given:\n(25|30|31)$\n"
            },
            {
                "text": " \n\\b(?:s(?:u)?|m|f|w(?:e|day)?)\\b\n\nExercise 3: RegEx for password validation\nMatch examples\n- 1234-abcd-efgh-ijkl\n- abcd-efgh-ijkl\nNon-match"
            },
            {
                "text": " \\b\\d{1,2}(st)?[th]\\b - match one or two digits, uppercase'st', and then an optional th. (example: \"10st\", \"22th\" )\n\n2. **ShortDescription**: Write a regular expression that, given a date string"
            },
            {
                "text": " (\\d{1,2}), (\\d{1,2}[a-z])\n\n3. Write a Python program that prompts for a password containing at least one uppercase letter, one lowercase letter, and one digit. The program should also be case-sensitive. (Hint: Use"
            }
        ]
    },
    {
        "expression": "^\\w+.*$",
        "raw_prompt": "Validates any line begining with an alpha-numeric. If you need a regular expression that fails only for a zero length string. Remove the \\w+. I originally attempted to post was ^.*$ but the input form would not allow it.",
        "refined_prompt": "matches a wide range of text strings that have at least one word character((letters, digits, or underscores) at the beginning.\nMatch examples:\n- \"user name\"\n- \"o)(=-&amp;r443*/\"\n- \"fds2f\"\nNon-match examples:\n- \"=stuff\"\n- \".username\"",
        "matches": [
            "user name",
            "o)(=-&amp;r443*/",
            "fds2f",
            "23f2ef",
            "bh",
            "87",
            "u8hh98",
            "9h",
            "99h9",
            "8hh9",
            "9h8",
            "8hg97f",
            "76df"
        ],
        "non_matches": [
            "=stuff",
            ".username",
            "@!R-243fads",
            "#$r1w1-123fads",
            "#RFE",
            "%FTYV",
            "*&YHU",
            "*%^TYGVH",
            "%^TYF",
            "(*IU",
            "&^YGU",
            "$%ERTYU"
        ],
        "id": 342,
        "output": [
            {
                "text": " (^[a-zA-Z\\s]*$)\"\n- \".\"Generate a RegEx. \nAnswer: (.+?)$\"\n\n3\\. Write a"
            },
            {
                "text": "^\\S*$ should match anything at the beginning of the string if it contains the character set.\n\nExercise 3:\nThe use of Regular Expressions in the game development industry can"
            },
            {
                "text": " r\"^\\.(?!.*( )[\\w.]+$).*\"\n\n- \"a number with dashes\"\nMatch examples:\n- \"12345-7890"
            },
            {
                "text": " /^[a-zA-Z0-9_-]+$/\n\nExercise 2:  \n\nCreate a RegEx for the phone number pattern.\n\nExample: \"("
            },
            {
                "text": " ^[a-z]+ (?=.*[a-z]).\n\nExercise 4:\nQuestion: Define a regular expression to match the text \"12,345\".\nTh"
            },
            {
                "text": " ^[a-zA-Z][a-zA-Z0-9-_]*\\.$  \nExercise 2: Given two strings (example, email, and phone"
            },
            {
                "text": " \\b(u1_[a-z])\\b for example...\n3.\nWhat is the difference between a \"positive\" and \"negative\" RegEx? Give an example of"
            },
            {
                "text": " [^(=)]$\n\n2. The following pattern matches phone numbers of the format (XXX) XXX-XXXX where XXX is a digit.\na) (1)\nb)"
            },
            {
                "text": " `.*\\balphanumeric\\b.*`\n```\n```\nOverall, I enjoyed studying RegEx principles. The Python examples and exercises were very helpful in solidifying my understanding"
            },
            {
                "text": " ^[a-z0-9-]*([A-Z]\\.?)[A-Za-z0-9-]*\\.*$\n- \"fds2"
            }
        ]
    },
    {
        "expression": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "raw_prompt": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.",
        "refined_prompt": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"",
        "matches": [
            "2004-2-29",
            "2004-02-29 10:29:39 pm",
            "2004/12/31",
            "2004-2-29",
            "2008-12-07",
            "2013-2-28",
            "2012-12-29",
            "2004-02-29 10:29:39 pm",
            "2004-02-28 11:19:39 pm",
            "2004-02-26 10:08:39 pm",
            "2004/12/19",
            "2004/5/31",
            "2004/8/31"
        ],
        "non_matches": [
            "2003-2-29",
            "2003-13-02",
            "2003-2-2 10:72:30 am",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 343,
        "output": [
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            }
        ]
    },
    {
        "expression": "^((AL)|(AK)|(AS)|(AZ)|(AR)|(CA)|(CO)|(CT)|(DE)|(DC)|(FM)|(FL)|(GA)|(GU)|(HI)|(ID)|(IL)|(IN)|(IA)|(KS)|(KY)|(LA)|(ME)|(MH)|(MD)|(MA)|(MI)|(MN)|(MS)|(MO)|(MT)|(NE)|(NV)|(NH)|(NJ)|(NM)|(NY)|(NC)|(ND)|(MP)|(OH)|(OK)|(OR)|(PW)|(PA)|(PR)|(RI)|(SC)|(SD)|(TN)|(TX)|(UT)|(VT)|(VI)|(VA)|(WA)|(WV)|(WI)|(WY))$",
        "raw_prompt": "This validates the states and territories of the United States in a 2 character uppercase format. Very poor excuse for a regular expression! ;)\nWritten by Jason Gaylord.",
        "refined_prompt": "This validates the states and territories of the United States in a 2 character uppercase format.\nMatch examples:\n- \"NY\"\n- \"PA\"\n- \"NJ\"\nNon-match examples:\n- \"Pennsylvania\"\n- \"Pa\"",
        "matches": [
            "NY",
            "PA",
            "NJ",
            "MA",
            "KS",
            "AL",
            "IA",
            "VI",
            "CT",
            "NE",
            "ME",
            "MT",
            "HI"
        ],
        "non_matches": [
            "Pennsylvania",
            "Pa",
            "pa",
            "INDIANA",
            "QW",
            "WER",
            "AB",
            "XX",
            "EE",
            "WER",
            "SDF",
            "DD"
        ],
        "id": 346,
        "output": [
            {
                "text": " \\b([NH]|N[0-4]|[0-9]|[A-Z]\\w?)\\b\n\n10. Use a RegEx to extract all the URLs (with any number of pages within) from a given string. \nAnswer:"
            },
            {
                "text": " [noun]\\b\\w{2}$\nThis validates the states and territories of the United States in a 2-3 character lowercase format, followed by a single capitalized word (noun). The underscore (_) acts as a wildcard character, allowing the word"
            },
            {
                "text": " \n^(?i)[a-z]?[a-z0-9A-Z]{1}[a-z0-9A-Z]{1}[a-z0-9A-Z]{2,}$\n\n\n"
            },
            {
                "text": " ^[a-mA-Z]{3}$\n\n```python\nimport re\n\ntext = \"The United States' states and territories lie between the states and territories of North America, including the territory of Canada and Mexico.\"\npattern = r\"^[a-"
            },
            {
                "text": " \n\\b\\w{2,}\\s*\\b\nIn the code above, \\b denotes a word boundary, and {2,} specifies the minimum and maximum number of words that we want to match. In addition, the space \\s* after the word is used"
            },
            {
                "text": "\n[\\sA-Z]{2}\\s\n\n\n\nQuestion 8: \nThere are 12 students in a math class and their average test score is 75. If the top student scores an 85, what is the class average after the top student drops out? \n"
            },
            {
                "text": " ^([A-Z]\\w*)\\W|(\\w*\\W)[A-Z]$\n\n#Exercise 2  #Exercise 3  #Exercise 4  #Exercise 5#Exercise 6#Exercise 7#Exercise 8#Exercise"
            },
            {
                "text": " State|(?=\\sA-Z)-State\\/Suit||(?=\\s\\d)State\\/'s||(?=\\d-\\d)'s|\n\n```python\n# Python Code of Exercise 3\nimport re\nstates"
            },
            {
                "text": " ^[A-Z]\\w*[-.]?\\w*[A-Z]\n \nExercise 4:\n\nDescribe a real-world example in which multiple states' populations are required to be entered into a database, but one state's population needs to"
            },
            {
                "text": " (?=([^A-Z]|$)a|(?=([^A-Z]|[A-Z](?!z))a|(?=([^A-Z]|[A-Z](?=))a))\n\n    21"
            }
        ]
    },
    {
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ ]{1}[0-9]{3}[\\-]{1}[0-9]{4})$",
        "raw_prompt": "It is the exact phone number regular expression for '(###) ###-####'.\nWritten by Jason Gaylord.",
        "refined_prompt": "It is the exact phone number regular expression for '(###) ###-####'.\nMatch examples:\n- \"(555) 555-1212\"\n- \"(575) 609-4178\"\n- \"(435) 236-2754\"\nNon-match examples:\n- \"555-1212\"\n- \"1-800-555-1212\"",
        "matches": [
            "(555) 555-1212",
            "(575) 609-4178",
            "(435) 236-2754",
            "(094) 722-0258",
            "(743) 805-8464",
            "(838) 390-9293",
            "(717) 033-3038",
            "(834) 145-5776",
            "(255) 800-3155",
            "(740) 815-8610",
            "(621) 005-4039",
            "(538) 776-0986",
            "(883) 167-0736"
        ],
        "non_matches": [
            "555-1212",
            "1-800-555-1212",
            "555-555-1212",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "415-94561-51",
            "9516-9516",
            "-5612516-9561",
            "8451-95614-956",
            "48561-49516-51"
        ],
        "id": 347,
        "output": [
            {
                "text": " '(\\()(\\\\d{3}) \\\\-(\\\\d{4}) \\\\)\\\\(\\\\d{3})\\\\)'\n\n4. Write a script that matches the regular"
            },
            {
                "text": " (\\(\\d{3}\\)) \\(\\d{3}-\\d{4}'.\n\n2. Given 3 strings \"Apple\", \"Microsoft\", and \"Amazon\" use"
            },
            {
                "text": " *(\\d{3}) \\d{3}-\\d{4}\n\nWrite a Regular expression to check for a number at the beginning of the line and a dash and"
            },
            {
                "text": " (\\d{3}) \\d\\d-\\d\\d or (\\d\\d) \\d{3}-\\d{4}, but use the dot ("
            },
            {
                "text": " \nRegex: '^[0-9]+[-.][0-9]{3}[0-9]{3}[-.][0-9]{"
            },
            {
                "text": " '\\d{3}-\\d{3}-\\d{4}'\n\nExercise 3: \nCreate a Python function that takes as an argument a string"
            },
            {
                "text": " \n(\\\\d{3}\\\\)) (\\\\d{3}-){3}\n\nExercise 3:\nThe following sentence has both uppercase and lowercase"
            },
            {
                "text": "\\(^[\\d]{3}\\)\\s\\d{3}-\\d{4}$\n\nExercise 2: \nWrite a method that will take"
            },
            {
                "text": " (?:\\d{3}\\s\\d{3}-\\d{4}) will likely be your answer.\nExam 1: Using the above code that generates a Reg"
            },
            {
                "text": " \n((\\d{3})\\).*\\2.*\n\n2. Write a regular expression that can match dates from January 1, 2004 to December 31, 2005.\n"
            }
        ]
    },
    {
        "expression": "^(([0]?[1-9]|1[0-2])/([0-2]?[0-9]|3[0-1])/[1-2]\\d{3})? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?(AM|am|PM|pm)?$",
        "raw_prompt": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM. If this don't woik, I wrote it, lemmy know.",
        "refined_prompt": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"",
        "matches": [
            "12/30/2002",
            "12/30/2002 9:35 pm",
            "12/30/2002 19:35:02",
            "11/31/1847",
            "10/31/2051",
            "12/8/1094 20:19:36",
            "06/31/1101 15:46",
            "10/31/1956 4:00",
            "10/31/2553",
            "04/30/1121 23:03 PM",
            "7/30/2673",
            "4:03:29PM",
            "3:25:25"
        ],
        "non_matches": [
            "18/22/2003",
            "8/12/99",
            "8/22/2003 25:00",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 348,
        "output": [
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description:"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description\n"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description ("
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description,"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description\n"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description/"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description?"
            }
        ]
    },
    {
        "expression": "^\\d(\\d)?(\\d)?$",
        "raw_prompt": "Matches positive whole numbers from 0-999",
        "refined_prompt": "Matches positive whole numbers from 0-999\nMatch examples:\n- \"0\"\n- \"12\"\n- \"876\"\nNon-match examples:\n- \"1000\"\n- \"1.23\"",
        "matches": [
            "0",
            "12",
            "876",
            "489",
            "987",
            "162",
            "875",
            "495",
            "86",
            "87",
            "15",
            "39",
            "5"
        ],
        "non_matches": [
            "1000",
            "1.23",
            "-234",
            "48956",
            "4985",
            "89448",
            "45665187",
            "8374",
            "515.1",
            "45.64",
            "45.87",
            "65.541"
        ],
        "id": 349,
        "output": [
            {
                "text": " ^([1-9]\\d+)$\n\nExample 5: \nCreate a RegEx to identify uppercase letters. \nUse the regular expression \"^[A-Z]$\". Explain your reasoning. \n\nSolution: \nTo create a RegEx to identify uppercase letters, we use"
            },
            {
                "text": " r\"(\\d[1-9]{0,2}|1[0-9][0-9]{0,2}|100[0-9]{0,2}|[1-9][0-9]{0,2}\\\\.)+\\d{0,2}\"\n"
            },
            {
                "text": " \n0-999\\D+(\\..+) \\d+\n\nExercise 2:\nRegex for Phone Numbers\nMatch all valid US phone numbers for the format (123) 456-7890 or as (123) 456 7890\nAnswer:\n\\(?(\\d{3})\\)?["
            },
            {
                "text": " 0-999\n\n###### Exercise 2\n- Create a regex for phone numbers in the format: +1-123-456-7890\nGenerate a RegEx for this description.\nAnswer: +1-\\\\d{3}-\\\\d{3}-\\\\d{4}\n```python\n"
            },
            {
                "text": " \"[0-9]*[.][0-9]+\"\n\n4. Match comma-separated values with no spaces\nMatch examples:\n- \"apple,banana,orange,pear\"\n- \"red,blue,white\"\nNon-match examples:\n- \"r,e,l,"
            },
            {
                "text": " \"^\\d\\d\\.\\d$\" (the \"^\" before the range is for the start of the sequence. \"\\.\\d$\" is to make sure there are digits (any number from 0-9) at the end, otherwise it would catch a number like 1.8 and 1)\n\nEx"
            },
            {
                "text": " 0,1,2-9,1-9,5-9,9-9,8,0.9\n\n2) Write a function that returns a list consisting of lower case uppercase characters from A to Z, that can only be generated by a RegEx.\n\nHint: use the \\w"
            },
            {
                "text": " Non-match example\n\n2. Using the RegEx you wrote, create a program to sort a list of names in alphabetical order.\n```\nimport re\n\ndef sort_names(names):\n  pattern = \".*?\"\n  for i in sorted(names):\n      pattern += \"$\" + str"
            },
            {
                "text": " The RegEx can be something like '\\d+' (more than one digit and the decimal point is included). \nIllustration: \nSamantha and John are both avid runners. Samantha has well-maintained running shoes, moisture-wicking clothing, and a supportive training plan. John, on the"
            },
            {
                "text": " ^[0-9]{0,3}(,[0-9]{3})*$\n3. Create a Python Function that Matches Dates of the form \"Jan 05, 2021\u201d from the following list.\n- [\u201cFeb 06, 2022\u201d, \u201c03 May 2010\u201d,"
            }
        ]
    },
    {
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\\s{1}|\\/|-](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\\s{1}|\\/|-]\\d{4}$",
        "raw_prompt": "More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit.",
        "refined_prompt": "More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit.\nMatch examples:\n- \"01 JAN 2003\"\n- \"31/Dec/2002\"\n- \"20-Apr-2003\"\nNon-match examples:\n- \"32 Jan 2003\"\n- \"00 Dec 2003\"",
        "matches": [
            "01 JAN 2003",
            "31/Dec/2002",
            "20-Apr-2003",
            "31\u2005Jul\u20281627",
            "12 JAN 7565",
            "01 JAN 3875",
            "21 JAN 5735",
            "31/Dec/7868",
            "20/Dec/7357",
            "18/Dec/3757",
            "10-Apr-7837",
            "15-Apr-6375",
            "27-Apr-6788"
        ],
        "non_matches": [
            "32 Jan 2003",
            "00 Dec 2003",
            "10 dec 2003",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "JAN 123",
            "FEB 324 2020",
            "JULY 414 1941",
            "DEC 2434"
        ],
        "id": 350,
        "output": [
            {
                "text": "\n(?:\\d+-)?(?:?\\/)?\\d{3}-(?:[A-M][A-M][A-JAN-"
            },
            {
                "text": "\n1) (?P<month>\\d{1,2})\\s\\.?(?P<day>\\d{1,2})\\."
            },
            {
                "text": "\n^(?:[1-2]:[0-9]{1,2}(\\s+-|\\ /|-$))?(?:[a-"
            },
            {
                "text": "\n\nfunction regExTest(text){\n    var x = text.match(/\\d{1,2}-\\d{1,2}"
            },
            {
                "text": " /(?:\\d{0,2})\\s/|/\\s-(?:\\d{1,2})/|-(?<month>\\"
            },
            {
                "text": " \"^[1-9]/[0-9]/[0-9][0-9]$\". $ means end of line. \n\n"
            },
            {
                "text": " [^0-9/-]*[0-9/-]\\S+[0-9/-] \n\nHow to apply more dynamic options to the"
            },
            {
                "text": " [^-/. \\d\\d/]+\n\nTutor: Great job! That is a correct and versatile solution. The other questions do not have a clear"
            },
            {
                "text": " [0-9]{1,2}[a-z]{1,2}[/-\\s]{4}[0-9]{"
            },
            {
                "text": " (?:\"(?P<Day>0?[1-9]|1[0-2])\\/(?P<Month>0?[1"
            }
        ]
    },
    {
        "expression": "^[1-9]{1}[0-9]{3}\\s{0,1}?[a-zA-Z]{2}$",
        "raw_prompt": "Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters.",
        "refined_prompt": "Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters.\nMatch examples:\n- \"1234AB\"\n- \"1234 AB\"\n- \"1234 ab\"\nNon-match examples:\n- \"0123AB\"\n- \"123AA\"",
        "matches": [
            "1234AB",
            "1234 AB",
            "1234 ab",
            "1546zZ",
            "1187wD",
            "7615CS",
            "8248rO",
            "4735jM",
            "8618Bo",
            "5668eQ",
            "8597qG",
            "6792Hm",
            "1965VU"
        ],
        "non_matches": [
            "0123AB",
            "123AA",
            "3F22FV",
            "3F2VF",
            "F32V2F",
            "32VF2F",
            "DEFV2",
            "F3V3F3D",
            "D3FD",
            "DFV3FV",
            "3V3FDCV",
            "V3FDFVR"
        ],
        "id": 351,
        "output": [
            {
                "text": " 0123(AB)\n- \"12345\"\n- \"1234\"\n- \"1234.123\"\n- \"123.45\"\n- \"1234.1A2\"\n\nA:\n\nYou need to capture the first"
            },
            {
                "text": "\nhttps://tools.ietf.org/html/rfc7230#section-8.7\n\"\"\"\n\nresult = r\"^([0-9]{4})([A-Za-z]{2})([0"
            },
            {
                "text": " [0-9]{4}[A-Z]|[A-Z]{4}0[0-9]\n\nPart 2:\nQuestion 7: In the following strings of numbers, identify the numbers in groups of three, i."
            },
            {
                "text": " \"^[0-9]{4}[a-zA-Z]{2}\\d$\".\n\n3. Using RegEx in database creation. \n- Create a function for database creation using RegEx. The function should take the following"
            },
            {
                "text": " \n(\\\\d{4}\\s?[A-Z]{2})\n\nA:\n\nThis may help:\nString str = \"123 ab\";\nint k = str.length()-1;\nint count = str.r"
            },
            {
                "text": " /^\\d{4}[a-zA-Z]\\s{2}$/\n\n9 - Describe what a function does and give an example of two different types of functions.\n- Example: Find the highest and lowest value in"
            },
            {
                "text": " (^[0-9]{4})([A-Za-z]{2})$\n\n7. Write a regular expression to remove all punctuation and symbols from a string.\nExample: \"Hello!? How's it going!!!?\""
            },
            {
                "text": "\n[0-9]{4}[A-Z][0-9]\n\nExercise:\n4. What will be the result of the following code?\n   print \"The price of this item is $29.99.\"\n\nAnswer"
            },
            {
                "text": " [A-Z]+[0-9]\n\n5) Validating Email Addresses: An email address consists of an alphanumeric character, an '@' symbol, a domain, followed by a period and a domain suffix. This pattern must be followed"
            },
            {
                "text": "\n(([0-9]|1[0-9]|2[0-9]|3[0-9])[a-zA-Z]){1,2}\nThe idea here is to match a digit followed by 1 or"
            }
        ]
    },
    {
        "expression": "[\\\\s+,]",
        "raw_prompt": "Simple expression for matching all commas and all whitespace characters: ASCII (13,10,44)",
        "refined_prompt": "Matches any single character that is either a whitespace character (\\s), a plus sign (+), or a comma (,). It's a character class that includes these three specific characters.\nMatch examples:\n- \",\"\n- \"whitespace\"\n- \"carrage returns\"\nNon-match examples:\n- \"cat\"\n- \"jioj\"",
        "matches": [
            ",",
            "whitespace",
            "carrage returns",
            "+",
            ",",
            "+,",
            "spafsd",
            "safsdf",
            "fdsu",
            "sfaaaa",
            "fsioj",
            "fsjoi",
            "fsdjii"
        ],
        "non_matches": [
            "cat",
            "jioj",
            "oib",
            "noi",
            "oi",
            "joi",
            "noiboib",
            "jib",
            "no",
            "inoi",
            "iobiou",
            "bui"
        ],
        "id": 353,
        "output": [
            {
                "text": " \n\n#Python code to generate a RegEx\nimport re\npattern = r\"\\w+\"\ntext = \"The cats gojkle\"\n"
            },
            {
                "text": " *(.+?)\\s*\\||,\\-\n\nQ:\n\nFinding the maximum sum of a sub-array such that array[i] < array"
            },
            {
                "text": " (.*[0-9]*)?$\n\nA:\n\nI found several issues with the code in the question.\nFirst, the pattern was invalid:"
            },
            {
                "text": " (.+)s.\n4. How would you modify the regex you created for exercise 2 to ensure that the username can't have more than 20 characters or only 1 white space"
            },
            {
                "text": " the pattern \"^[a-zA-Z]+$\" indicates that the string should be at least one letter, at most one number, and it cannot be composed"
            },
            {
                "text": " https://www.regular-expressions.info/comma.html\n\nExercise 3: Regex that matches phone numbers with the format (XXX) XXX-"
            },
            {
                "text": " (\\S)+\n\n2. How to use the \"^\" and \"$\" Character Classes to Matches\nAnother important concept when it comes to regular expressions is the"
            },
            {
                "text": "\nA \"word character\": any character that is a letter or a number\nNon-word character: any character that is not a letter or a number\nRegex:"
            },
            {
                "text": " [^[a-zA-Z]\\s,]\n\n5. Match any digit from 0 to 9\n- Create a Regex pattern that is a"
            },
            {
                "text": " \n\"\\s,+\"\n\n\n\nTitle: The Fascinating World of Numbers: Counting Money\n\nIntroduction:\nWelcome, young explorers of the"
            }
        ]
    },
    {
        "expression": "^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\\ (0?[1-9]|([12]\\d)|30))|(Feb(ruary)?\\ (0?[1-9]|1\\d|2[0-8]|(29(?=,\\ ((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\\,\\ ((1[6-9]|[2-9]\\d)\\d{2}))",
        "raw_prompt": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.",
        "refined_prompt": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003\"\n- \"Apr 31, 1978\"",
        "matches": [
            "Jan 1, 2003",
            "February 29, 2004",
            "November 02, 3202",
            "December 31, 1918",
            "December 22, 1709",
            "Feb 14, 1992",
            "March 14, 1670",
            "Aug 31, 7564",
            "January 31, 1807",
            "December 31, 5076",
            "April 30, 5035",
            "Feb 9, 2801",
            "Dec 30, 8045"
        ],
        "non_matches": [
            "Feb 29, 2003",
            "Apr 31, 1978",
            "jan 33,3333",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 354,
        "output": [
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2001"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            }
        ]
    },
    {
        "expression": "^((31(?!\\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\\b|t)t?|Nov)(ember)?)))|((30|29)(?!\\ Feb(ruary)?))|(29(?=\\ Feb(ruary)?\\ (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])\\ (Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\\b|t)t?|Nov|Dec)(ember)?)\\ ((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "This RE validates dates in the dd MMM yyyy format. Spaces separate the values.",
        "refined_prompt": "This RE validates dates in the dd MMM yyyy format. Spaces separate the values.\nMatch examples:\n- \"31 January 2003\"\n- \"29 March 2004\"\n- \"29 Feb 2008\"\nNon-match examples:\n- \"Jan 1 2003\"\n- \"31 Sept 2003\"",
        "matches": [
            "31 January 2003",
            "29 March 2004",
            "29 Feb 2008",
            "29 Jul 4950",
            "30 July 4945",
            "29 Jan 2897",
            "20 Aug 1664",
            "06 August 1962",
            "20 Oct 1786",
            "29 Aug 1673",
            "31 January 1785",
            "31 August 1825",
            "13 Dec 1955"
        ],
        "non_matches": [
            "Jan 1 2003",
            "31 Sept 2003",
            "29 February 2003",
            "12/12/2222",
            "15/15/1655",
            "2/3/5235",
            "43-5432",
            "Jan 43 4139",
            "Feb 432 234",
            "March 423 295",
            "July 942384239",
            "Augu 4325"
        ],
        "id": 355,
        "output": [
            {
                "text": " This RE validates dates in the dd MMM YYYY format. Spaces separate the values. \n[i]This RE validates dates in the dd MMM YYYY format. The spaces separate the values. Not a great RE"
            },
            {
                "text": " (01|03|08)\\.\nExercise 4:\nThe \"re\" library in Python can be very useful in many situations. For example, let's write a regular expression that matches a floating-point number between 0 and 1,"
            },
            {
                "text": " \nThe RegEx would be 012|123|234|345|456 \n\n2. Suppose you'd like to extract all the valid names that begin and end with d's. Write a RegEx to get this list.\n"
            },
            {
                "text": " (?:(?P<first>\\d+)\\s+)?(?P<last>\\d+)(?: (?P<month>\\w+)\\s+(?P<year>\\d+))?\n\n"
            },
            {
                "text": " [^\\d]*\n\n2. Use the Python re library to create a function that takes as its argument a date's name (e.g. \"Monday\") and returns its name as an instance variable.\n\nAnswer:\n"
            },
            {
                "text": " ([A-Za-z]{2} [0-9]{2} [(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ] [31|30|"
            },
            {
                "text": " \nimport re\ntext = '31 January 2003'\nexpression = r\"^(.*)\\s((.+)\\s((.+))|(((.+)\\s+.*\\)\\s+.*)|)([0-"
            },
            {
                "text": "  This RE validates dates in the dd/mm/yyy format. Spaces separate the values.\n\nMatch examples:\n- \"2/31/03\"\n- \"25-07-2012\"\n- \"12-15"
            },
            {
                "text": " [^A-Z][a-z0-9][^A-Z]*\nGenerate a RegEx for this description. \n  \n\n22.5.7 Using Regular Expressions for Web Scraping\n"
            },
            {
                "text": " 0[1-9]|[12][0-9]\n\nQuestion 2:\nFor the RE example provided, add a space between each delimiter, if there is one.\n\nExample of regex:\n[0-9"
            }
        ]
    },
    {
        "expression": "^(?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)$",
        "raw_prompt": "This RE validate the full name of the months.",
        "refined_prompt": "This RE validate the full name of the months.\nMatch examples:\n- \"January\"\n- \"May\"\n- \"October\"\nNon-match examples:\n- \"Jan\"\n- \"Septem\"",
        "matches": [
            "January",
            "May",
            "October",
            "March",
            "February",
            "August",
            "April",
            "June",
            "July",
            "September",
            "November",
            "December"
        ],
        "non_matches": [
            "Jan",
            "Septem",
            "Octo",
            "Mastercard",
            "sfalijad234",
            "aug",
            "jan",
            "dec",
            "oct",
            "febru",
            "apr",
            "abc"
        ],
        "id": 356,
        "output": [
            {
                "text": " (^[A-Z][a-z][A-Z]\\s){0,3}[A-Z](?:\\ ([A-Z]\\ ){0,3})?$\n\n``` python \n# Exercise 4 Solution\nmy_string = \"JANUARY\"\nmy_string"
            },
            {
                "text": " ([a-zA-Z]|_)([0-9][a-zA-Z]\\2{1})$\n\nI hope this helped you get started on your exam section. Don't hesitate to reach out if you have any questions or need additional examples. Good luck!\n\n\n\nAs an aspiring"
            },
            {
                "text": " ^(jan|mar,apr|may,jun,jul,aug,sep,oct,nov,dec|jan-30(,?|$))$\nI wrote this for my exam answer \nimport re\n\nmonths = [\"january\", \"february\", \"march\", \"april"
            },
            {
                "text": "\n(?i)[A-Za-z][a-z]|[A-Za-z]{2,}[0-9]{3}\n\nThis is the explanation (https://www.regular-expressions.info/characterclass.html) of the solution.\n\nNow, after"
            },
            {
                "text": "\nRegex: \\b(?:st|nd|rd|th)(?:s|ss|stse|stse?|stte|te|terse|te)?\\b\n\n4. Create a REGEX to catch the following scenarios:\n    - Valid names: Alex, John, Bill, Sam, Tom"
            },
            {
                "text": " \\d{1,2}\\/[A-Z][a-z]{0,2}\\/[A-Z]\\/[A-Z][a-z]\\/\\d{2}\\\n\n\n2. Create a regex that matches emails. Allow an underscore in some email addresses.\n\nSolution: \n"
            },
            {
                "text": " \"^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$\"\n\nEXERCISE 3: Replace\nReplace the month name by the month number in the provided example string. \nExample: \"March is the third month of the"
            },
            {
                "text": " (.*)$\n2)\nA file is a collection of related documents that are stored on a computer. Write a Python code that reads a text file, check if each line is a valid filepath or the actual file content (i.e.:.txt,.py,.json,.csv,.gz...) Print either True"
            },
            {
                "text": " \\bp{1|2|3}+\n\n3. Exercise: A bank system has a password requirement that is eight characters long, containing uppercase and lowercase symbols, a special character, and numbers. Write a Python RegEx to validate if the password meets the requirement. \n\nQuestion: How would you write a"
            },
            {
                "text": "\nmonth[\\w\\s]*$\n\nIn Python, we'd make this more efficient using a regular expression:\nimport re\npattern = r\"^[a-z]{3,6}\\s[\\W\\d]$\"\nif re.match(pattern, validInput):\n  print(\""
            }
        ]
    },
    {
        "expression": "^1+0+$",
        "raw_prompt": "A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask.",
        "refined_prompt": "A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask.\nMatch examples:\n- \"10\"\n- \"110\"\n- \"1100\"\nNon-match examples:\n- \"0\"\n- \"01\"",
        "matches": [
            "10",
            "110",
            "1100",
            "1110",
            "111000",
            "1100000",
            "11111000",
            "11000000",
            "10000",
            "11110",
            "11111110000",
            "110000000000",
            "111100000000"
        ],
        "non_matches": [
            "0",
            "01",
            "101",
            "10101010",
            "01010100",
            "010010",
            "101",
            "010",
            "10010101",
            "1010101011010011",
            "010",
            "10101010101"
        ],
        "id": 358,
        "output": [
            {
                "text": " \n(?i)^(?=\\d(?:\\d)?)[01](?:\\d|$)\n\nI used"
            },
            {
                "text": " \"(\\d)\\.(\\d)*\"\n3. Explain what '\\n' does in the RegEx string\n- \"^[123]\""
            },
            {
                "text": "\n|  \\d *? \\d *? |\n\nHow to parse a subnet mask:\nUsing a list, the first step is"
            },
            {
                "text": " \n(?<![0123456789])1.*\\1\n\nA:\n\nThe simplest way to implement this is to"
            },
            {
                "text": "  ^[1]+(0|[1]\\1*)*$ \n- \"10\" \"101\" \"0010\"  All non"
            },
            {
                "text": " [1-9][0-9][0-9]?[0-9]\n\nCode Snippet (with regex):\nimport"
            },
            {
                "text": " \n/(\\d\\\\d)*\\1/g\n\nHow it works: It uses a \\d regex to match any integer value; The"
            },
            {
                "text": " ^1.?0{0,{0,1}}.*$\n\nA:\n\nI would do\n^\\[[0-9a"
            },
            {
                "text": " \n\n[1] (\\\\d{1}\\\\s?\\\\d{3,6})(?!\\\\d)\n\nSo far"
            },
            {
                "text": " /^1[01]{0,9}$/\nI don't know if I'm allowed to put this here in a thread, but"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((1[6-9]|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "dd/MM/yyyy with leap years 100% integrated\nValid years : from 1600 to 9999\nAs usual, many tests have been made.\nI think this one should be fine.",
        "refined_prompt": "dd/MM/yyyy with leap years integrated\r\nValid years : from 1600 to 9999\nMatch examples:\n- \"29/02/2000\"\n- \"30/04/2003\"\n- \"01/01/2003\"\nNon-match examples:\n- \"29/02/2001\"\n- \"30-04-2003\"",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003",
            "02/12/4845",
            "21/02/1861",
            "30/03/7831",
            "20/02/9516",
            "06/02/1764",
            "09/02/5152",
            "30/12/6866",
            "03/07/1839",
            "03/07/1982",
            "08/04/1748"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/2003",
            "12/123/4322",
            "234/423/5243",
            "233/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 359,
        "output": [
            {
                "text": " dd/MM/yy\n'''\n\n#Example 2: Matching dates in Python\nregex_pattern = '''\n    ^[A-Z]{3,4}"
            },
            {
                "text": " (04/05/2016)\n\nI understand that you are not allowed to use if statements. So, my question is, what should I replace in the code above to be able to check"
            },
            {
                "text": " dd/MM/yyyy, 2 places to the left. If you have more than one value use [,]\n\"\"\"\r\nfrom. import *\r\nimport re\r\nfrom."
            },
            {
                "text": "\n^[0-9]+.[0-9]+?[_-]?[0-9]{3}$\n\nExercise 3: \nThink of two more examples of"
            },
            {
                "text": " (Y/N)?(T/F)(G/F)?(F)\n- \"26 Feb 2006\"\n- \"Jan 16, 2002\"\n-  \"30 Oct 2002"
            },
            {
                "text": " ((\\d{4})-(\\d{2})-(\\d{1,2}))\n- Create a list of numbers from 2 to 100. \nAnswer: \"1,"
            },
            {
                "text": " (19|20)\\d{2}/\\d{2}/\\d{2} with leap years integrated\n```\n2. Write the Python code that receives a date in"
            },
            {
                "text": " \r\n^(0\\d-1)\\d/\\d{2,2}/\\d{4}$\r\nIf the string begins with 0 or more 0's followed"
            },
            {
                "text": " You could use the same pattern as in the \"days\" example, i.e. \\d{0,2}/\\d{1,2}/\\d{4} with"
            },
            {
                "text": " \n# Regex for checking date format: dd/MM/yyyy with leap years integrated\r\n\"\"\"\r\nimport re \r\nfrom typing import Tuple, List\r\n\r"
            }
        ]
    },
    {
        "expression": "^\\d{1,5}(\\.\\d{1,2})?$",
        "raw_prompt": "validate a number 5 digits and 2 decimal places allowing zero",
        "refined_prompt": "Validates numbers with up to five digits, including optional decimal places with one or two decimal digits.\nMatch examples:\n- \"12345.67\"\n- \"0\"\n- \"0.1\"\nNon-match examples:\n- \"123456.78\"\n- \"123456.789\"",
        "matches": [
            "12345.67",
            "0",
            "0.1",
            "86476.4",
            "66995",
            "586.94",
            "84832",
            "101.42",
            "8",
            "63.7",
            "30.14",
            "059",
            "1"
        ],
        "non_matches": [
            "123456.78",
            "123456.789",
            ".1",
            "-123",
            "2346-2345-2435",
            "9841562.65123",
            "561.456123",
            "5416561.456123",
            ".4898979",
            "341.431v4f3.fv1",
            "9/9/9",
            "32542 //"
        ],
        "id": 360,
        "output": [
            {
                "text": " ^0\\d{0,2}(?:\\.\\d)?$\n\nExercise 5:\nWrite a RegEx that finds all words that start with a capital letter and end with a period. Match examples:\n-"
            },
            {
                "text": " (\\b\\d{1,3}(\\.\\d{1,2})?\\b) allows a leading decimal, between 1 and 3 characters, followed by at least one digit up to 9. A trailing decimal of 1"
            },
            {
                "text": " The above regex will match numbers of \"12345\", \"123456\", or \"1234...\", and numbers with \".\" at the end. The \"0\" and \"0.1\" will not be matched.\n\nExercise"
            },
            {
                "text": " ^0+\\d{2,}\\.\\d\\d$|^0+\\d{3,}$|^0+\\.\\d{1,2}\\d$\n\nExercise 3: Extract Numbers From"
            },
            {
                "text": " \nimport re\n\nstring_example = \"0.1\"\n\npattern_example = r'^(\\d[\\.][0-9]{1,}|[\\.]\\d{1,2})$"
            },
            {
                "text": " \\d{5}\\.? \\d{1,2}\n- \\s Matches any whitespace character. \n- [$] Matches the end of the string. \n- [] matches any character inside the brackets"
            },
            {
                "text": "\nThe general rule is to allow one number and one decimal place, separated by a decimal point. The character class for numbers and decimal point is [0-9] or \\.[0-9]. This generates the RegExp \"[0-"
            },
            {
                "text": " \\d{6,}\\.\\d{1,2}\\d{1,2}\n\n3. Exercise: Replace the word \"cat\" with \"dog\" in the following sentence with regular expressions.\n\"The cat sat"
            },
            {
                "text": " r'^\\d{1,6}(\\.\\d{1,2})?'|r'^\\d{1,3}\\d$|^\\d{1,4}\\d\\.\\d{1,"
            },
            {
                "text": " You would generate a \"\\\\d+\" followed by \".0+\".\n\nLearning Journal:\n\n20.2.2 - The Syntax and Semantics of Regular Expressions (Explained with Details python Implementation)\n\n"
            }
        ]
    },
    {
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,2})?$",
        "raw_prompt": "validates to 5 digits and 2 decimal places but not allowing zero",
        "refined_prompt": "this regular expression validates numbers with up to five digits, including optional decimal places with one or two decimal digits, while excluding inputs that consist solely of zeros or zero decimals.\nMatch examples:\n- \"12345.12\"\n- \"0.5\"\n- \"7\"\nNon-match examples:\n- \"123456.12\"\n- \"1.234\"",
        "matches": [
            "12345.12",
            "0.5",
            "7",
            "79",
            "4362.3",
            "86",
            "9948.5",
            "7.76",
            "4658.9",
            "4",
            "8.6",
            "11349",
            "516"
        ],
        "non_matches": [
            "123456.12",
            "1.234",
            ".1",
            "-123",
            "234/423/5243",
            "43.v234",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "1-1-2",
            "9/9/9",
            "32542.456234"
        ],
        "id": 361,
        "output": [
            {
                "text": "\\d{1,5}\\.(?:[1-9]\\d?)\\d{1,2} or \\d{3,4}"
            },
            {
                "text": "\n\n```Python\nre.compile(r\"^([0-9.]*?[0-9]{1}[0-"
            },
            {
                "text": "\n^[0-9]{1,5}\\.[0-9]{1,2}$\nDescription: Matches one or more digits"
            },
            {
                "text": " The RegEx is ^[1-9][0-9]{3}(.[0-9]{1,2})?$\n"
            },
            {
                "text": " ^[0-9]+\\.[0-9][0-9]*$ \n---\n2. Develop a Python regular expression that will validate"
            },
            {
                "text": " \\d{5,}\n\n4. To implement the following action in the Flask app, create a route, add query parameters, and send a response"
            },
            {
                "text": " \"([0-9][0-9]*.[0-9]{1,2}|[0-9][0-9]{"
            },
            {
                "text": "\nUse \"[\\d.]+\" to match between one and infinite decimal places (including decimal points without rounding off).\n\n    Learning Journal: Sub"
            },
            {
                "text": "\\([^\\d]+\\)(\\d+\\.\\d*)?\nExample Use-Cases in Python:\nHere are three examples of Python"
            },
            {
                "text": " The pattern is \"^\\d{1,5}\\.\\d{0,2}$\"\n\nExercise 3: Matching Social Media"
            }
        ]
    },
    {
        "expression": "^[^<>`~!/@\\#}$%:;)(_^{&*=|'+]+$",
        "raw_prompt": "A general string validation to insure that NO malicious code or specified characters are passed through user input. This will allow you to input any characters except those specified. The expression above does not allow user input of &lt;&gt;`~!/@\\#}$%:;)(_^{&amp;*=|'+. Input as many invalid characters you wish to deny. This really works!",
        "refined_prompt": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~ ! / @ \\ # } $ % : ; ) ( _ ^ { & * = | ' +.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"",
        "matches": [
            "This is a test",
            "fdsjkfsd hkshjdf",
            "hjfds hfjsdkh",
            "huifd879h",
            "h98",
            "h89",
            "h98h",
            "98h9h",
            "f7g",
            "98gf57",
            "f8h9",
            "h09h98g",
            "g98g98g"
        ],
        "non_matches": [
            "^&GYGH",
            "<br>",
            "That's it",
            "F^TYVGH",
            "9hi\"hfieds'",
            "'fdgdf",
            "huhiyfgdyi'",
            "'gfs$#ERFW",
            "gyi'",
            "idygiyfd'giyd97r@#E",
            "98g'RF$E",
            "$#EFg98g98g*&U\"''"
        ],
        "id": 362,
        "output": [
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx Pattern"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx that"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx that"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx to"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx Expression"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx to"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx dynamically"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx for"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx\n"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx for"
            }
        ]
    },
    {
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[\\.| |\\-]{0,1}|^[0-9]{3}[\\.|\\-| ]?)?[0-9]{3}(\\.|\\-| )?[0-9]{4}$",
        "raw_prompt": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.",
        "refined_prompt": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.\nMatch examples:\n- \"5551212\"\n- \"614555-1212\"\n- \"(614)555-1212\"\nNon-match examples:\n- \"A12-5555\"\n- \"(614-555-1212\"",
        "matches": [
            "5551212",
            "614555-1212",
            "(614)555-1212",
            "(842)993 0045",
            "(283)2708210",
            "186198 3473",
            "(849)-8231974",
            "823-864-6500",
            "6881622666",
            "929-5392",
            "808-1305",
            "488787-0909",
            "(629)0196963"
        ],
        "non_matches": [
            "A12-5555",
            "(614-555-1212",
            "555*1212",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 363,
        "output": [
            {
                "text": " \n\n**The answer to this exercise is**\n```python\nre.compile(r"
            },
            {
                "text": "  [555.]{3}[.-]{3}[35-9]\\d[-"
            },
            {
                "text": " \\d()\\.?![\\d\\-]*|[\\d\\-](\\d\\d\\"
            },
            {
                "text": "\n^\\s*(\\d{3}-)?(\\d{3})[-\\.\\s"
            },
            {
                "text": " \\[(?P<A>\\d[\\.\\-\\(\\)]?\\d[\\.\\-"
            },
            {
                "text": " (6512).(00) \\d\\d|(6\\d\\d)\\d{2"
            },
            {
                "text": " Match one or more digits, followed by one or more digits, followed by one or more digits, followed by"
            },
            {
                "text": " ^(?!.*\\d$)(?!.*[A-Za-z]+\\s+\\"
            },
            {
                "text": " [ ]{6}\\d\\d\\d\\s\\d\\d\\d\\s\\d"
            },
            {
                "text": " \n/(?<start>\\\\d)(?<first_part>(\\\\d{3})("
            }
        ]
    },
    {
        "expression": "^([1-9]{1}[0-9]{3}[,]?)*([1-9]{1}[0-9]{3})$",
        "raw_prompt": "Matches a comma-seperated list of year(s).",
        "refined_prompt": "Matches a comma-seperated list of year(s).\nMatch examples:\n- \"1999,2001,1988\"\n- \"1999\"\n- \"4895\"\nNon-match examples:\n- \"0199,1997\"\n- \"0199\"",
        "matches": [
            "1999,2001,1988",
            "1999",
            "4895",
            "1984",
            "4896,4856",
            "4568",
            "9846",
            "4895,4985,8946",
            "8467",
            "7897",
            "7835",
            "1894,4189,1894,7984",
            "4894,8793"
        ],
        "non_matches": [
            "0199,1997",
            "0199",
            "1999,",
            "156915,",
            "15981,",
            "65165,",
            "46484354,4894fsd",
            "/5/5/20022",
            "000-000",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 364,
        "output": [
            {
                "text": " \"^\\d{4}(,\\d{4})?$\"\nA \"year pattern\" is a regex that matches a string that starts or ends with one or more of the four digits of a \"year\". The first digit is not consumed, so that the"
            },
            {
                "text": " You can create a RegEx like \"^[0-9]{4}[-][0-9]{4}$\"\n\n### Exercise 3\n\nFind all occurrences of the substring \"a\" in the text.\n\n```python\ntext"
            },
            {
                "text": " The RegEx should contain the \\d and \\W characters to match the first and second digits respectively (one or more times). \n\nExercise 4: Write a RegEx to validate a company name that contains only letters and numbers. The RegEx should return true if the"
            },
            {
                "text": "\n(.*?)\\-((.*))\n\nExercise 5: RegEx in a string\nWrite a function that returns true if a given string contains a regex pattern that matches the given sample string.\nEx)\nmyString = \"Hello World 123456789\""
            },
            {
                "text": " \n\npattern = r'[0-9]\\d{4}\\,\\d{3}\\,\\d{2}\\,|[0-9]\\d{4}\\|[0-9]\\d{6}|[0-9"
            },
            {
                "text": " [\\d,]{4}\\s*\n\nExercise #3: Find all sentences and convert all numbers into words. \nFind sentences and convert numbers into words. \nExample input: \"1.2.3.44.4.5.6."
            },
            {
                "text": " \"^[1-9][0-9]*,[0-9][0-9[]\\.,\\.]+\"$.\n\nA:\n\nI would make a regex that splits the string, uses a delimiter, then matches only entries that are in range"
            },
            {
                "text": " \\d{1,2},\\d{4}\\b|\\d{4}\\b\n\nExample 2\nConsider a CSV string that looks like:\n\"John\nDoe,25\nSmith,36\nJames,42,123\"\nCreate a function called"
            },
            {
                "text": " (?i)(?<![\\w\\S]+\\s)(?:[0-9]+),(?![0-9]*)(?!\\s*$)+\nUsing a non-capturing group makes it easier to read the expression.\nThe look"
            },
            {
                "text": " \n'([0-9][0-9][0-9],?)*[1-9][0-9][0-9]*'\n\n3. Write a method that matches a string of numbers, separated by spaces, with a max of 10 numbers"
            }
        ]
    },
    {
        "expression": "^(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\\d{4}))|((02)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\\d{4}))|((02)(\\.|-|\\/)(29)([-./])([02468][048]00))|((02)([-./])(29)([-./])([13579][26]00))|((02)([-./])(29)([-./])([0-9][0-9][0][48]))|((02)([-./])(29)([-./])([0-9][0-9][2468][048]))|((02)([-./])(29)([-./])([0-9][0-9][13579][26])))$",
        "raw_prompt": "This works for all accept 01/01/0000 mainly 0000. can anybody suggest a solution.",
        "refined_prompt": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12.\r\nDD (day) depends on the month and can be 01-31.\r\nYYYY (year) must be a four-digit number.\r\nIt considers leap years for February (02) by allowing 29 days in certain cases.\r\n\r\nIt handles different separators between date components (e.g., '-', '/', '.').\r\n\r\nIt accounts for various scenarios related to leap years, including divisibility by 4, 100, and 400.\nMatch examples:\n- \"01/01/2001\"\n- \"02/29-2800\"\n- \"02/29/2108\"\nNon-match examples:\n- \"01/01/00000\"\n- \"52/2/54/245\"",
        "matches": [
            "01/01/2001",
            "02/29-2800",
            "02/29/2108",
            "11-26/9165",
            "02/29-7600",
            "02.29/2800",
            "02/29-5600",
            "02.04.1914",
            "02.29/0152",
            "12.23.6006",
            "11.24-1607",
            "11/13-2502",
            "10.08.0722"
        ],
        "non_matches": [
            "01/01/00000",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 366,
        "output": [
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12,"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12,"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12 or"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            }
        ]
    },
    {
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))$",
        "raw_prompt": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.",
        "refined_prompt": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00501\"\n- \"84118-3423\"\n- \"n3a 3B7\"\nNon-match examples:\n- \"501-342\"\n- \"123324\"",
        "matches": [
            "00501",
            "84118-3423",
            "n3a 3B7",
            "07743-6002",
            "80135-5335",
            "36898-1873",
            "55717-8018",
            "04808",
            "A8g8o2",
            "33144",
            "V0k0a4",
            "66972",
            "87740-7005"
        ],
        "non_matches": [
            "501-342",
            "123324",
            "Q4B 5C5",
            "Mastercard",
            "234/423/5243",
            "43.v234",
            "/5/5/5",
            "2546dgwre",
            "324df",
            "adfa2",
            "abc111def",
            "99999@gmail"
        ],
        "id": 367,
        "output": [
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00528"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00517"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"005A"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00567"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00530"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"005\""
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00567"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"005A"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00568"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00568"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z_]{1}[a-zA-Z0-9_]+$",
        "raw_prompt": "This expression validates for valid C# or C++ identifier",
        "refined_prompt": "This expression validates for valid C# or C++ identifier\nMatch examples:\n- \"_12ffsd\"\n- \"abcd123\"\n- \"abcd_23232\"\nNon-match examples:\n- \"..//\"\n- \"..13e232\"",
        "matches": [
            "_12ffsd",
            "abcd123",
            "abcd_23232",
            "asdfa12",
            "fty67",
            "gy78g",
            "gy76g",
            "gyg7g78g",
            "g78guy",
            "_giuy24",
            "_sfdih238",
            "gy789fsu",
            "yugfsd78"
        ],
        "non_matches": [
            "..//",
            "..13e232",
            "abcd 3232",
            "8f7sdh h89fdsh",
            "hfusdh98shdf98h fhsu",
            "h h89fh",
            "huh8uh98h h89h09ju",
            "90u09u09",
            "90ut67f",
            "76g67",
            "(0xx12) 62509",
            "0j0jweBBBB"
        ],
        "id": 369,
        "output": [
            {
                "text": "\nC:\\_.*;\n\nPlease help me solve the problem.\n\nA:\n\nThe _ has to be in the character class, not the variable name.\n^\\w[_.]{6,12}$\n\n^ at the start of the"
            },
            {
                "text": " \"\\\\d*_?\\\\w*\"\n\"\"\"\n\n# Question 3:\n\"\"\"\nGiven a dictionary of people and their ages, write a regular expression that extracts the names of people who are under the age of 18. Use a named group to reference the age"
            },
            {
                "text": "\na/\\w+/\n\nA:\n\nIt should have a /- or _ at the beginning and an / or _ at the end.\n^ /_[a-zA-Z_0-9]*.\n\nA:\n\n"
            },
            {
                "text": " Match this\n(?<!\\d)([a-zA-Z][a-zA-Z0-9]*)(.*)\n\nA:\n\ntry this one\n\\b([^\\w_]*[a-z]["
            },
            {
                "text": ".{1,31}\\d{3,10}\\b\nAdditional information: the regex needs to validate against 2-12 characters in length and/or 1 digit somewhere in the string, but is not required to validate that it is a 1-32 character alphanumeric"
            },
            {
                "text": " ^[A-Za-z0-9_][A-Za-z0-9_A-Za-z0-9_-]*$\n\n4. Using the `^` and `$` characters, check if the string ends"
            },
            {
                "text": " ^[\\w\\.]+$\n- \"abc\"Generate a RegEx for this description.\nAnswer: [a-zA-Z0-9_]+\n- \"123abc\"Generate a RegEx for this description.\nAnswer: ["
            },
            {
                "text": "\na-zA-Z0-9_\\d\n\nA:\n\nIn.NET the string.IsSeparator(char) methods is available where you just need to use char.\nif (name.IndexOf('(') == -1"
            },
            {
                "text": " \n/.*\\\\d+ - Start of string.* - any number and more than one character - one dash.\n\nThe last piece of the pattern you are missing is a positive lookahead to require a digit. I would suggest using a positive lookahead like in the"
            },
            {
                "text": " ([a-zA-Z_0-9]+)\n\nI created an expression like this:\n(?<=\\W_)([a-zA-Z_0-9])+\n\nThe lookbehind (?<=\\W_"
            }
        ]
    },
    {
        "expression": "^[1]$|^[3]$|^[4]$|^[6]$|^[1]0$",
        "raw_prompt": "This will match single numbers,the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only.\nThis matches inclusively.",
        "refined_prompt": "This will match single number, the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only. This matches inclusively.\nMatch examples:\n- \"1\"\n- \"4\"\n- \"10\"\nNon-match examples:\n- \"13\"\n- \"2\"",
        "matches": [
            "1",
            "4",
            "10",
            "3",
            "6"
        ],
        "non_matches": [
            "13",
            "2",
            "0",
            "5",
            "7",
            "8",
            "9",
            "8495",
            "485684",
            "4856",
            "4234",
            "56465"
        ],
        "id": 370,
        "output": [
            {
                "text": " [1-9]-\\d{0,1} \n\n- \"1,3,4\"\nGenerate a"
            },
            {
                "text": " ^[1-9]\\d[1-9]\\d\\d[1-9]\\d$\n-"
            },
            {
                "text": " ^(?P<match>[1-9])(?:-\\1)?$\nFor regex generation see https://www."
            },
            {
                "text": " [1-9]\\d{1-9}|10\nThe first piece of code will allow you to select from 1"
            },
            {
                "text": " (?=\\d)\n\nA:\n\nA regex will give you the most general match and the longest, so to"
            },
            {
                "text": " [0-9][0-9]$\n- \"10,000\"\n\nA:\n\nHere is a quick"
            },
            {
                "text": "\nYou want to generate a regular expression like this \n^[1-4]?[0-9](0|$"
            },
            {
                "text": " \"1[0-9]{1}\" and \"1\\d{1,2}\".\n\nhttps://www."
            },
            {
                "text": " \"1|6|10\" Generates a correct output.\n- \"1b\"\n- \"1b2\"Gener"
            },
            {
                "text": " ^[2-9][0-9][0-9]$\n\n2. Write a regular expression that matches any email"
            }
        ]
    },
    {
        "expression": "^[A]$|^[C]$|^[D]$|^[F]$|^[H]$|^[K]$|^[L]$|^[M]$|^[O]$|^[P]$",
        "raw_prompt": "This is for matching Single uppercase Letters inclusively",
        "refined_prompt": "matches a single uppercase letter from the set {A, C, D, F, H, K, L, M, O, P}.\nMatch examples:\n- \"A\"\n- \"F\"\n- \"P\"\nNon-match examples:\n- \"a\"\n- \"b\"",
        "matches": [
            "A",
            "F",
            "P",
            "H",
            "M",
            "C",
            "O",
            "L",
            "D",
            "K"
        ],
        "non_matches": [
            "a",
            "b",
            "cd",
            "fadsf",
            "afd",
            "f",
            "d",
            "g",
            "B",
            "Z",
            "Y",
            "X"
        ],
        "id": 371,
        "output": [
            {
                "text": " (.*a[a-z].*)?|(.*f[a-z].*)?|(.*p[a-z].*)?\n\nExercise 2: Replace a list of words in a string with another"
            },
            {
                "text": " (?:[^a-zA-Z]+[a-zA-Z])+\n\n2. Create a RegEx that only allows numbers between 0 and 99.\nAnswer: (\\d{0,2}"
            },
            {
                "text": " \"^A|O|B\" (only \"B\" matches)\nI don't understand how to add letters to this case of {A, C, D, F, H, K, L, M, O, P"
            },
            {
                "text": " I use (?<!D)(?P<letter>[AFKMNOPQRSTV]){2,}\n- A RegEx that uses the character set {A,C,D,F,H,K"
            },
            {
                "text": " \\w+\n2. Create a user that greets two people by name. Use regex to validate that the names entered are in all lowercase.\nHint: You can make use of the \\b boundary when using regex to make"
            },
            {
                "text": " A and f (both contain a letter A)\n10. Create a regular expression to match words that start with the letter 't' and end with an exclamation point (!).\nMatch examples:\n- \"test\"\n-"
            },
            {
                "text": " (\\b[A-F][A-F])\\d\n\nExercise 5: Write Regular Expressions\n\n1. Generate a RegEx to match any email address.\n2. Generate a RegEx to"
            },
            {
                "text": " (.{1,})\n```\nIdeas:\n- Change your regular expression so that you match characters from the set {'a', 'b', 'c', 'd',..., 'z'}, that is,"
            },
            {
                "text": " Any uppercase letter that is not A, C, D, F, H, K, L, M, O, or P.\n\n3. Write a Python program that reads a text file and prints the number of words"
            },
            {
                "text": " \"^[a-f0-9]$\"\n\n---\n\nBy now, you should be well-versed in applying RegEx in Python. Practice the exercises to fully grasp the concept. The more you practice,"
            }
        ]
    },
    {
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "raw_prompt": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "refined_prompt": "This regex pattern is designed to match a numeric value that can be either a positive integer, a positive decimal number, zero, or a positive decimal number less than 1 with up to two decimal places. It allows for an optional minus sign at the beginning to indicate negative numbers.\nMatch examples:\n- \"123\"\n- \"123.54\"\n- \"-.54\"\nNon-match examples:\n- \"123.543\"\n- \"0012\"",
        "matches": [
            "123",
            "123.54",
            "-.54",
            "49",
            "489",
            "9",
            "8",
            "7",
            "64",
            "54",
            "45.15",
            "48.97",
            "98.51"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12",
            "-123.423",
            "51:534",
            "$23.454",
            "56.153153",
            "254627g.256",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 374,
        "output": [
            {
                "text": " /((\\d+)(\\.\\d+)?|\\.\\d+)(["
            },
            {
                "text": " \\b[-+]?[0-9]+(?:\\.[0-9"
            },
            {
                "text": " I cannot provide a sample solution for this exercise as it is a subjective question. However,"
            },
            {
                "text": " Match the word \"one\".\n\nTA: Welcome everyone, today we will be"
            },
            {
                "text": " r'[0-9]+\\.[0-9]*'\n- \""
            },
            {
                "text": " \n[0-9]{1,3})([0-9]"
            },
            {
                "text": " ^[1-9][0-9]?[[0-9][0-"
            },
            {
                "text": " r'(\\d{{3}\\.\\d{3}}|-\\d{"
            },
            {
                "text": " (?<!\\\\.)\\\\d+([\\\\.0-9]{1"
            },
            {
                "text": " r'(0\\d{1,}[.]{1,})\\d"
            }
        ]
    },
    {
        "expression": "<[^>]*>",
        "raw_prompt": "HTML Pattern Matching\nPLEASE HELP\n/&lt;[^&gt;]*&gt;/ig\nThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.\nHow do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign and not when it just see a &gt; within a '' or &quot;&quot;.\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;\nAny help would be greatly appreciate. Thanks a whole lot.\nLogan",
        "refined_prompt": "This regex pattern matches HTML/XML tags by looking for text enclosed in angle brackets (< and >), allowing for any characters ([^>]*) between them.\nMatch examples:\n- \"<html>\"\n- \"<div>\"\n- \"<a href=\"https://www.example.com\">\"\nNon-match examples:\n- \"abc\"\n- \"2fed2\"",
        "matches": [
            "<html>",
            "<div>",
            "<a href=\"https://www.example.com\">",
            "<p class=\"paragraph\">",
            "<>",
            "<img src=\"image.jpg\" alt=\"Example Image\">",
            "<h1>Title</h1>",
            "<span style=\"color: red;\">",
            "<br />",
            "<ul><li>Item 1</li><li>Item 2</li></ul>",
            "<!-- This is a comment -->",
            "<input type=\"text\" name=\"username\">",
            "<table><tr><td>Data 1</td><td>Data 2</td></tr></table>"
        ],
        "non_matches": [
            "abc",
            "2fed2",
            "df22",
            "f2eg",
            "g8yu<gu",
            "9hu09jiOKIOK",
            "9JIMO<",
            "H*(UIJMKO<",
            "(*IKO<MNH",
            "(IOK<HJM",
            "<MHJK",
            "K<HJM"
        ],
        "id": 381,
        "output": [
            {
                "text": " This regular expression pattern matches any string of characters between \"<\" and \">\" characters. The pattern uses a character class to match any character in the range [^>]* (zero"
            },
            {
                "text": " This pattern matches any text enclosed in angle brackets with an optional character (?:...) between them, allowing for any character between them.\n\n7. Write a RegEx statement to"
            },
            {
                "text": "\nregex = r'[a-zA-Z0-9]*\\s[a-zA-Z0-9._%&-]+["
            },
            {
                "text": " [^>]*[(<]\n- \"abc\"Generate a RegEx for this description.\nAnswer: [^>]*[])\nI'm thinking I"
            },
            {
                "text": " [^\\d\\s>&#]+\n\n3. Match any word character between letters, except for \"z\" and \"Z\".\nExample: \"aA"
            },
            {
                "text": " ^abc$ \nExplanation: The regex pattern matches any characters (.*), followed by an HTML or XML closing tag ($), followed by any characters again ($). It"
            },
            {
                "text": " a non-descriptive pattern (any text, no angle brackets)\n2. Write a RegEx pattern that matches all dates in the format DD/MM/YYYY"
            },
            {
                "text": " <([^<>]*)(?:>|$)\n- \"<pre><code>\n... \n\nExercise 4: Evaluating a Regular Expression\n-"
            },
            {
                "text": " \"([a-z0-9\\.\\-_@\\+\\/\\w]+)?\"\n- \"<h2>HELP</h2>\" \""
            },
            {
                "text": " \n([^<>]+)<([^>]*)>(\\.\\.\\.\\.)\n\nExercise 4:\nRegex patterns that validate email addresses:\n\nAnswer"
            }
        ]
    },
    {
        "expression": "^([0-9]*\\-?\\ ?\\/?[0-9]*)$",
        "raw_prompt": "Match italian telephone number with prefix followed by &quot;/&quot;, &quot;-&quot; or blank and number. Usefull with numeric keybord!",
        "refined_prompt": "Match italian telephone number with prefix followed by &quot;/&quot;, &quot;-&quot; or blank and number.\nMatch examples:\n- \"02-343536\"\n- \"02/343536\"\n- \"02 343536\"\nNon-match examples:\n- \"02a343536\"\n- \"02+343536\"",
        "matches": [
            "02-343536",
            "02/343536",
            "02 343536",
            "123",
            "456-4545",
            "49516-49516",
            "4561-489",
            "49856/4895",
            "485/485",
            "485951",
            "485",
            "7845",
            "673"
        ],
        "non_matches": [
            "02a343536",
            "02+343536",
            "&*YHIUJN",
            "U()IHU",
            "UYGHJY*(U",
            "GYUH",
            "*UIHT*&Y876849",
            "y89uhiy89uhi*&UI",
            "y*(UHIyuhi",
            "98yUHIiuf",
            "hiufs89y",
            "fs+5644f"
        ],
        "id": 382,
        "output": [
            {
                "text": " \n- \"01[0-1][0-9][0-9][0-9]a[0-9]["
            },
            {
                "text": "\n- \"\\d{3}[\\-\\+a-c0-9]+\\d{3}\"\nI appreciate this lesson"
            },
            {
                "text": " /^[A-Z]+[\\-\\+\\+ ][A-Z0-9 ]+$/\n\nUse"
            },
            {
                "text": " \"02(?=a)343536\"\n\nExercise 5: Write down a code that replaces \"&quot;"
            },
            {
                "text": " [01-9]\\d{3}(-([1-9]\\d{3}|[1-9]\\"
            },
            {
                "text": " 01(([0-9]{4})-([0-9]{2}))|1.([0-9]"
            },
            {
                "text": "\nhttps://www.matthewgabler.com/reg-ex-tutorial/\n\n5. Create a regular"
            },
            {
                "text": " 02(01-343536-) - Non-match\n\n2. Regex - Match only the following characters: a-z"
            },
            {
                "text": " (\\\\d[ -]\\\\d){2})(\\\\/[ -]\\\\/)(\\\\\\\\d[ -]\\\\d)."
            },
            {
                "text": " [0-9]{2}/(?:[0-9]+)[-]?[0-9]{2}"
            }
        ]
    },
    {
        "expression": "^(\\d+|[a-zA-Z]+)$",
        "raw_prompt": "Tests for all numbers OR all letters (upper or lower case)\n( posted from WebService - http://regexlib.com/webservices.asmx?op=Save )\n( updated from WebService - http://regexlib.com/webservices.asmx?op=Save )",
        "refined_prompt": "Tests for all numbers OR all letters (upper or lower case)\nMatch examples:\n- \"aaaaadddaaaaa\"\n- \"1166633337\"\n- \"48956\"\nNon-match examples:\n- \"1n\"\n- \"ppppp99\"",
        "matches": [
            "aaaaadddaaaaa",
            "1166633337",
            "48956",
            "485",
            "4687",
            "3573",
            "5",
            "guy",
            "huih",
            "u",
            "fiuf",
            "iyf",
            "yift"
        ],
        "non_matches": [
            "1n",
            "ppppp99",
            "yuih423",
            "y78ui",
            "t78gfy",
            "ryfut312",
            "dyff8gy89yuhh9",
            "ug8u",
            "78yg8y",
            "8yg76d667dd6",
            "768afds",
            "8787fy"
        ],
        "id": 386,
        "output": [
            {
                "text": " \"([0-9]|[a-z])\"\n\n3. Write a new RegEx that matches any numbers that have exactly 6 digits.\nAnswer: \"(\\d{6})\"\n\n4. Write a program that validates that a"
            },
            {
                "text": " (any character from 1 to 9+)*?|[A-Z]+(?:[A-Z][A-Z]+)[A-Z](?:[a-zA-Z]+)[a-z]?|[0-9"
            },
            {
                "text": " \\d+|[a-zA-Z]\n\nExercise 5:\nCreate a RegEx for a name containing at least 5 characters (alphabetic and numeric).\nAnswer: [a-zA-Z]{5,}\\d{"
            },
            {
                "text": " (a or b): (?=.{5})(?=.*[A-Z].{3})(?=.*[a-z].{3})\n\nScript:\n\nTA: Hello everyone, today we're going to cover"
            },
            {
                "text": "\n\nclass TestRegExp():\n    def test_empty_match(self):\n        regex = \"\"\n        matches = re.findall(regex, \"\")\n        self.assertEqual(re.findall(regex"
            },
            {
                "text": ".? (Any one digit character [0-9] or any letter in [A-Za-z])\\? (Any one digit character [0-9] or any letter in [A-Za-z])\\.?\\? (Any"
            },
            {
                "text": " \"\\\\d*\\\\w+\"\n1166633337\n\n# Chapter 8: Advanced Searching Techniques - Python RegEx\nThis chapter will cover advanced searching techniques with Python's regular expressions, including regular expressions' character classes and how to use them to match"
            },
            {
                "text": " \"(\\d)+\"\n- \"1222222\"\n- \"33333,333\"\n- \"888899,000\"Generate a RegEx for this description. \nAnswer: [\\d]{4}\\s|[\\d"
            },
            {
                "text": " \"(?i)(.*)([a-zA-Z])\" (I'm including any alphanumeric string. You didn't specify that you want a specific letter or number in there so it could be \".*\"). The?i makes it case-ins"
            },
            {
                "text": "\n^(0[1-9]|1[0-2])[\\da-z\\s]+$\n\nExercise 4:\nCreate a RegEx for this description:\n- Letters must be between 2 and 5 characters long.\n-"
            }
        ]
    },
    {
        "expression": "\\.com/(\\d+)$",
        "raw_prompt": "This is a regex I wrote to capture requests to AspAlliance.com with an article id as the only thing after the domain. So http://aspalliance.com/123 would go to article number 123. It maps the URL to the actual aspx file that displays the article based on the ID.",
        "refined_prompt": "This regex pattern matches URLs that end with \".com/\" followed by one or more digits. It captures the digits at the end of the URL.\nMatch examples:\n- \"http://aspalliance.com/123\"\n- \"www.aspalliance.com/123\"\n- \"http://aspalliance.com/34\"\nNon-match examples:\n- \"http://aspalliance.com/article.aspx?id=123\"\n- \"http://aspalliance.com/\"",
        "matches": [
            "http://aspalliance.com/123",
            "www.aspalliance.com/123",
            "http://aspalliance.com/34",
            "https://www.example.com/123",
            "http://example.com/456",
            "https://www.test.com/789",
            "http://subdomain.example.com/42",
            "https://example.com/0",
            "https://www.example.com/12345",
            "http://sub.example.com/9999",
            "https://example.com/987654",
            "https://www.example.com/1",
            "http://sub.example.com/333"
        ],
        "non_matches": [
            "http://aspalliance.com/article.aspx?id=123",
            "http://aspalliance.com/",
            "http://aspalliance.com/articl",
            "12/123/4322",
            "sfalijad234",
            "2/3/5235",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "com.edu.github",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 392,
        "output": [
            {
                "text": " http[s]?[a"
            },
            {
                "text": " \"https?://.*\\.asp"
            },
            {
                "text": " It could be something like \"^"
            },
            {
                "text": "\n\"https?:\\/\\/"
            },
            {
                "text": "\n[^0-9]("
            },
            {
                "text": " [^/]+/[0"
            },
            {
                "text": " \\.com/\\d{"
            },
            {
                "text": " /\".com/(\\d+"
            },
            {
                "text": " \n\\\\.com\\\\d"
            },
            {
                "text": " /(?<=apl"
            }
        ]
    },
    {
        "expression": "^[0-9]{5}([- /]?[0-9]{4})?$",
        "raw_prompt": "US Zip Code + 4 digit extension Postal Code",
        "refined_prompt": "US Zip Code + 4 digit extension Postal Code\nMatch examples:\n- \"14467\"\n- \"144679554\"\n- \"14467-9554\"\nNon-match examples:\n- \"14467 955\"\n- \"14467-\"",
        "matches": [
            "14467",
            "144679554",
            "14467-9554",
            "98530/6404",
            "928248626",
            "01520",
            "53972",
            "61907",
            "45857-2888",
            "39269",
            "39269",
            "17547-4481",
            "78123"
        ],
        "non_matches": [
            "14467 955",
            "14467-",
            "1446-9554",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 395,
        "output": [
            {
                "text": " \n\"[0-9]{3}(\\-[0-9]{,1}){2}\\d{4}$\"\n\n4. Match examples:\n- \"a-b\"\n- \"b-a\nNon-match examples:\n- \"a"
            },
            {
                "text": "\n>>> '^[a-z]\\d{3}[-.]\\d{4}$'\n'^[a-z]\\d{3}(- )?\\d{4}$'\n\n\n## Summary\n\nThe Python re module provides a set"
            },
            {
                "text": " \"\\d{7}-\\d{4}\"\n- \"4561-9554\"\n- \"4561-9554-555\"\n- \"4561-9551-4657-555\"\n\nExercise 1: Generate a RegEx to match postal codes"
            },
            {
                "text": "\n- Generate a RegEx pattern that matches the pattern of \"14467\". \n\nExercise 4:\nGenerate a RegEx for this description:\n\"A phone number must be of the format (xxx) xxx-xxxx\"\nAnswer: \n- Generate"
            },
            {
                "text": "\n\"^[0123456789]{5}$\\d{4}-\"\n\nExercise 4: Pattern Matching\nGiven the following pattern, write a RegEx to match the email address below:\nPattern: The email address must have 'example@example.com"
            },
            {
                "text": " \n- (?<!\\\\d)([0-9]{5}-[0-9]{4}[0-9]{1})(?!\\\\d)\"\n- (?<![0123456789])([0-9]{5"
            },
            {
                "text": "\n- \"^[0-9]{5}-[0-9]{4}[0-9]{4}$|^[0-9]{5}-[0-9]{4}[0-9]$\" (to separate the zip code"
            },
            {
                "text": " \n- \"14464/5600/9/55/4/1\"\n- Generate a RegEx for this description. \n```\n\nExercise 5:\nWrite a Python program that takes a list of strings as input and filters out all the strings that contain"
            },
            {
                "text": " The pattern should be \"\\d+\\s(\\d+\\.\\d+)\\-(\\d+)\"\n\n[Quiz 3]\nModify the provided example using an object-oriented approach to achieve the same result.\n\nAnswer:\n\nclass PostalCode:\n    def"
            },
            {
                "text": "\n- RegEx: [A-Z][0-9]{4}-[A-Z]{0,4}\\d{5}\n- Explanation: \n  [A-Z] represents one of the uppercase letters.\n  {4} represents the"
            }
        ]
    },
    {
        "expression": "<([^<>\\s]*)(\\s[^<>]*)?>",
        "raw_prompt": "All tags in first submatche\nAll attributes in second one...",
        "refined_prompt": "Match HTML-like tags in a text, including both opening and closing tags.\nMatch examples:\n- \"<td class=\"TD2\">\"\n- \"<!-- comment -->\"\n- \"</table>\"\nNon-match examples:\n- \"19-Fev-2002 - 19h00\"\n- \"New Changes :\"",
        "matches": [
            "<td class=\"TD2\">",
            "<!-- comment -->",
            "</table>",
            "<div>",
            "<a href=\"https://example.com\">",
            "<p class=\"paragraph\">",
            "<img src=\"image.jpg\" alt=\"Image\">",
            "<h1 id=\"header\">",
            "<ul>",
            "<li>",
            "<span style=\"color:red;\">",
            "<table cellpadding=\"5\" cellspacing=\"0\">",
            "<input type=\"text\" name=\"username\" value=\"John\">"
        ],
        "non_matches": [
            "19-Fev-2002 - 19h00",
            "New Changes :",
            "...",
            "(12) 324 653210",
            "123.456.789",
            "there is a boy",
            "-312",
            "2546dgwre",
            "u09nKLJG FSL",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 401,
        "output": [
            {
                "text": " (https://regex101.com/r/G1mT1l/1/)\n\nDear students,\n\nToday's topic is about parsing HTML-like strings with BeautifulSoup. We will"
            },
            {
                "text": " (\\(.*\\) - matches everything between the first opening pair of parentheses), (.) matches any character, and () repeats what is matched above. Combine all to create a full expression.\n\n4. Write a Reg"
            },
            {
                "text": " [\\w-]{7}\\d\\d-\\d{2}\\r?\\n\n- [*]?\\s\n\n3.  Regex for email-like patterns, including domain name"
            },
            {
                "text": " This exercise can be achieved using two flags within the re.S or re.M options with some other flags. This may involve using regular expressions that need to be checked on the fly as they're applied to the text."
            },
            {
                "text": " \".* : *\" (case insensitive)\n\n3. Use the following example HTML to determine if there is a tag with the name \"description\".\n<div class=\"article\">\n    <h3 class=\""
            },
            {
                "text": "\n\"\\n-\\[\\d\\d-\\d\\d-\\d\\d[\\-.]\\d\\d\\d [A-Za-z\\s].?\\]\\n"
            },
            {
                "text": " \"^[ \\t]+[a-zA-Z0-9-]+$\"\n\n\n\nTitle: A Practical Guide to Cat Grooming and Health\n\nTable of Contents:\n1."
            },
            {
                "text": " ([0-9]{4}-[0-9]{2}-[0-9]{2})\"\n\nExercise 5: \nMatch any text in the example below, including the words \ufffd"
            },
            {
                "text": " <p>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}(.\\d+)\\</p>\"\n"
            },
            {
                "text": " \"(\\d{2}-\\d{2}-\\d{4} )\\s+(\\d{4}-\\d{2})-(\\d{4}).\"\n\n4. Regular"
            }
        ]
    },
    {
        "expression": "^((Bob)|(John)|(Mary)).*$(?<!White)",
        "raw_prompt": "&quot;Starts with but does not end with.&quot;\nI needed a pattern to require certain first (and optional middle) names, but to fail for certain last names. So if Bob, John, and Mary are acceptable first names but the White's are always rejected then...",
        "refined_prompt": "Match strings that start with the names \"Bob,\" \"John,\" or \"Mary\" and do not end with \"White.\"\nMatch examples:\n- \"Bob Jones\"\n- \"John Smith\"\n- \"Mary Jane Smith\"\nNon-match examples:\n- \"Bob White\"\n- \"Mary Doe White\"",
        "matches": [
            "Bob Jones",
            "John Smith",
            "Mary Jane Smith",
            "Bob Sdsfui",
            "Mary Ufsdui",
            "John Jfdsj",
            "Bob Ufsduni",
            "John Bufisd",
            "Mary Ofuidn",
            "John Hfsnjii",
            "Mary Jfsd",
            "Mary Bob",
            "John Jfsdfds"
        ],
        "non_matches": [
            "Bob White",
            "Mary Doe White",
            "Gina Smith",
            "afdsaf.adijs",
            "234",
            "2/3/5235",
            "@#dfkjnav",
            "2546dgwre",
            "Jfsu White",
            "dsofioi fsifud",
            "Bob sdfjio White",
            "SDFisojsfdsd"
        ],
        "id": 402,
        "output": [
            {
                "text": " r'^[a-z]+( [a-zA-Z]+)*$'\n\n\n\nDear Alien,\n\nI hope this letter finds you well in your exploration of our world. Today, I would like"
            },
            {
                "text": " The RegEx should be: \"(^(Bob|John|Mary) White$)(.*)$\". \n\nExercise 9: Create a RegEx to capture the date of birth of a group of people in the format of"
            },
            {
                "text": " ^[A-Za-z ]+(\\p{L}+\\s?)*$\n\n\n\nQuestion 8: A toy store has 30 stuffed animals. They sell 20% of them and then buy 15 more."
            },
            {
                "text": " \\b(Bob|John|Mary)\\w*(White)\\b\n\n(3). How to create a Python program that determines if a given email is valid using RegEx.\n- Example: Extract the username, domain name"
            },
            {
                "text": " \n^(?:(?:[^a-zA-Z0-9\\- ]|\\s)+)[bB][a-zA-Z\\s\\d\\-]{4,8}$\n"
            },
            {
                "text": " \nBob|John|Name\\s([A-Z][a-z]?)White[A-Z]?([a-z]\\s?)\n\nGiving Examples:\n- Example 1: A social media company"
            },
            {
                "text": " \n```\nre.findall(r'\\b(\\w+[\\w ]{0,}\\w+)[\\w ]{1,}[A-Z][\\w ]{0,}\\b"
            },
            {
                "text": " You can use the \"^[BJ][a-h][Nd]$\", which matches a string that starts with \"B,\" \"J,\" or \"N,\" is followed by \"a-h,\" and the last letter"
            },
            {
                "text": " ^(Bob|John|Mary|[a-zA-Z]+)\\s?(.*?)\\s?$\\(.*?\\)$\\(.*?\\)\\s?\\($.*?\\)\\s?"
            },
            {
                "text": " \"^[A-Z][a-z]+\\s[A-Z][a-z]+$\"\n\n#### Exercise 4:\nGiven a string \"1234 \", replace all \" \" with \",\" except when it"
            }
        ]
    },
    {
        "expression": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "raw_prompt": "The RE match U.S. state abbreviation used by the U.S. Post Office.",
        "refined_prompt": "The RE match U.S. state abbreviation used by the U.S. Post Office.\nMatch examples:\n- \"AL\"\n- \"CA\"\n- \"AA\"\nNon-match examples:\n- \"New York\"\n- \"California\"",
        "matches": [
            "AL",
            "CA",
            "AA",
            "AL",
            "AK",
            "AZ",
            "DE",
            "FL",
            "GA",
            "HI",
            "ID",
            "IL",
            "IN"
        ],
        "non_matches": [
            "New York",
            "California",
            "ny",
            "fj",
            "if",
            "ud",
            "indiana",
            "notre dame",
            "minnesota",
            "ladf",
            "hu",
            "fy"
        ],
        "id": 405,
        "output": [
            {
                "text": " [RegEx]\n\n**Exercise 6**: \nMatch the U.S. state abbreviations with their corresponding full states:\nMatch examples:\n- \"OH\"\n- \"FL\"\n- \"CT\"\nNon-match examples:\n- \"NY\""
            },
            {
                "text": " ^(?:[A-NC-N]{1}(?:\\s?[A-N]{1}[A-C]{2})?)?$\n\n2. In the following email subject lines, write a RegEx to locate: email addresses, phone"
            },
            {
                "text": " [Y|n](a|an|no)?\\.?\n\nExercise 2: Create a set of rules for a search engine. Example rule: \"Find any article containing the word 'cloud.'\" Write down five rules that are relevant to this set of rules. Answer: \n"
            },
            {
                "text": " ^[A-Z][a-z]|[A-Z]\\p{L}\\p{M}$\n\nExercise 2: Pattern-based Match Test\nExercise: Given the following email addresses, determine if they are valid.\n\"user@domain."
            },
            {
                "text": " ^(?=a.n\\.?(?=(|t)o))(?=c\\.e\\.a\\.?(?=(|a)n)\\.)(?!e(?=\\.t))(?:\n .*\n)$\n\n- Match any amount"
            },
            {
                "text": " \n\\b(?:[a-z]|[A-Z]{2})s\\b\n\nExercise 2: Create a complex regular expression to match a phone number\nInput: John Doe: 555-5555 1234, 555-555-5678,"
            },
            {
                "text": " The pattern must begin with a state followed by a series of alphabets. For example: ^[AL]a[aeiou]{1}$\n\n (3). Content: [Company1], often referred to as [Company1's name], is an innovative technology company"
            },
            {
                "text": " \"^[A-Z\\s]{0}$\" means that the RE must consist of only uppercase A-Z or whitespace characters. No other characters are allowed, and the string must be made up of exactly one character. \n\nExercise 3: Write"
            },
            {
                "text": " /^[A-Z]{2}([a-z]{2})+$/i\n\nExercise 2: Generate a RegEx for this description. A phone number must be 10 characters long and begin with a number between 1 and 9.\nAnswer: /"
            },
            {
                "text": " \"^[AA-ZA-Z]+[^A-Z\\s]*$\"\n\n\n\ndef f(s: str, strings=['cog', 'coggy', 'comfy', 'coggygy','mighty']):\n    "
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{6}[0-9]{2}[A-Za-z]{1}[0-9]{2}[A-Za-z]{1}[0-9]{3}[A-Za-z]{1}$",
        "raw_prompt": "This pattern match italian fiscal code (codice fiscale).",
        "refined_prompt": "This pattern match italian fiscal code.\nMatch examples:\n- \"SPGGRG73A02E625S\"\n- \"czzdll74h18f205w\"\n- \"RpiOQG61R03w469G\"\nNon-match examples:\n- \"SP6FFFF3A02E625S\"\n- \"czzdll74h18f205\"",
        "matches": [
            "SPGGRG73A02E625S",
            "czzdll74h18f205w",
            "RpiOQG61R03w469G",
            "OLyzHw51K18Z629B",
            "zAimYP13D38h855H",
            "GRQzXT69Y28M275w",
            "PTglEY55H26T674Y",
            "eBEuhS45v47o338b",
            "jliwVR50Q99l187p",
            "IUhXMM96N71T672J",
            "hoCMai78v86Q840l",
            "XomkYf89U53z386d",
            "qworms03P35u422p"
        ],
        "non_matches": [
            "SP6FFFF3A02E625S",
            "czzdll74h18f205",
            "f23wed",
            "f23edwf2",
            "df2sf2e",
            "f2d2sgh",
            "/5/5/5",
            "notre dame",
            "u09nKLJG FSL",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 407,
        "output": [
            {
                "text": " (?<=SP|c|R)[0-9A-Z]{4}{0-9}[A-Z]{"
            },
            {
                "text": " \n\nimport re\ncode = \"G\"\nfor i in range(0,3):\n   code = re.sub(r"
            },
            {
                "text": "\n/^([0-9]{1,3}\\)\\.([0-9A-Fa-f]{1,4}\\"
            },
            {
                "text": " \"(Sp|ss|sss)g$([a-z])[0-9A-Fa-f]{4}\"\n\n"
            },
            {
                "text": " [2]: ([0-9]{2})[-_]([0-9]{2})[a-z]{1"
            },
            {
                "text": " [a-zA-Z0-9][a-zA-Z0-9]\\d{2}[a-z"
            },
            {
                "text": " ^(?P<num_to_match>\\d{5}-\\d{3}-\\d{4}[A"
            },
            {
                "text": "\n(\\d{4}){2}\\d{2}\\d{2}(\\S){5}\\d{1}\n\nExercise"
            },
            {
                "text": " r\"\\d{4}.\\d{2},\\d{3}[A-Z][A-Z][A-Z]"
            },
            {
                "text": " \"SPGGRG([\\d]{6})[^_](\\d{3}[^_])?(\\d{3"
            }
        ]
    },
    {
        "expression": "^(([8]))$|^((([0-7]))$|^((([0-7])).?((25)|(50)|(5)|(75)|(0)|(00))))$",
        "raw_prompt": "Time off hours edit for quarter hour(s) less than eight.",
        "refined_prompt": "Time off hours edit for quarter hour(s) less than eight.\nMatch examples:\n- \"0.25\"\n- \"7.75\"\n- \"8\"\nNon-match examples:\n- \"8.25\"\n- \"7.15\"",
        "matches": [
            "0.25",
            "7.75",
            "8",
            "7",
            "575",
            "2900",
            "8",
            "450",
            "150",
            "100",
            "300",
            "725",
            "625"
        ],
        "non_matches": [
            "8.25",
            "7.15",
            "0.15",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "56",
            "9781.198",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 412,
        "output": [
            {
                "text": "\n- (.375)?\\.(\\d{3})$\n\nExercise (with answers):\n- Create the regular expression necessary to validate a username which must follow the requirements:\n    - The username must contain six characters including at least one uppercase letter,\n    "
            },
            {
                "text": "\n[^0-9]\nExercise 5:\nMatch this RegEx pattern to the corresponding phrase:\n\\b(\\d{1} \\d{2}, \\d{4})\\b\na) 1 hour 2 minutes later\nb) 1 hour 2 minutes"
            },
            {
                "text": "\n\\d+\\.\\d*([1-9]?\\d?\\d)\n\n\n\nWelcome to the world of daily life! Today, I want to talk to you about a very important aspect of daily life \u2013 jobs! As a middle school student who wants"
            },
            {
                "text": " '([0-4]?\\.[0-9]{1,6})'\n\n\n\nTitle: Understanding Measurement: Area and Surface Area Explained for Middle School Students\n\nIntroduction:\nWelcome to another episode of \"Linguistic Foundation!\" Today, we"
            },
            {
                "text": " To generate the regex, you will want to use a decimal point in order to include the quarter hour that gets eliminated.\n- \"0.25:9.50\"Match examples:\n- \"0.75:15.75\"\n- \"0.5:05."
            },
            {
                "text": ".\\d*(?:-)?[0-9]+(\\.\\d*)?(?::\\d+)?\"\nGiven time for two movies start from same time on day1:\n\"00:00\", \"11:30\", \"08:00\", \"23"
            },
            {
                "text": " Match any number less than 8, any number less than or equal to 10, or any numbers less than or equal to 20.\n# 1. I am looking for a way to check a string for the number of characters that are numbers. I need to check if that characters are digits"
            },
            {
                "text": "\n^m.{4}\\d+\\.\\d+$|^m.{4}\\d+$|^m.{4}\\d+\\.\\d{3}$\n\nExercise: The movie \"Parasite\" has run for a total of"
            },
            {
                "text": "\n(?:[01]\\d?\\d?\\d\\.?\\d?\\d)?)|((?:[23][45][67]|[45][67]\\d{0,2})[0-9]{2})\n\nI've"
            },
            {
                "text": " \n(?<hour1>[0-5]?)(?<minute1>[0-59])(?<second1[0-59]?)\n(?<hour2>[0-5]?)(?<minute2>[0-59])(?"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/(\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/(\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/(\\d{2}))|(29\\/02\\/((0[48]|[2468][048]|[13579][26])|(00))))$",
        "raw_prompt": "Matching : dd/MM/yy\nLeap years compatible\nItalian style, just for more fun.\nPlease, don't forget to rate it if you use it. THX",
        "refined_prompt": "Matching : dd/MM/yy\r\nLeap years compatible\nMatch examples:\n- \"31/12/75\"\n- \"29/02/00\"\n- \"29/02/04\"\nNon-match examples:\n- \"01/13/01\"\n- \"29/02/01\"",
        "matches": [
            "31/12/75",
            "29/02/00",
            "29/02/04",
            "24/02/97",
            "29/02/08",
            "30/11/48",
            "20/10/34",
            "05/02/94",
            "06/02/67",
            "04/02/77",
            "29/02/00",
            "22/02/25",
            "20/05/31"
        ],
        "non_matches": [
            "01/13/01",
            "29/02/01",
            "29/02/2004",
            "(12) 324 653210",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "12f3.21f3.213f",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 421,
        "output": [
            {
                "text": " [\\[\\d\\]:/^[\\d\\-]{2}/[-\\+\\/]{2}/[-\\d\\-\\.]{4}$ \n\nFor those of you"
            },
            {
                "text": " dd/MM/yy{2,4}\"\n\nA:\n\nIt should be dd/mm/yy (d MMM).\nBut if you use dd+/mm, it'll match day part or M"
            },
            {
                "text": " \\w{4}/\\d\\d/\\d\\d\\d(?:\\.\\d{1,2})\n\n3. Generate this RegEx and use it to list all.txt files"
            },
            {
                "text": " [0-9]{2}\\-[0-9]{2}\\-[1\\d\\d]{3}\n\n3) Given a string of numbers, generate another RegEx that will match the ones that"
            },
            {
                "text": "\n\n```python\nimport re\n\nmatch = re.match(r\"^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$\", \"January/22"
            },
            {
                "text": " dd/MM/yy\\s?\\d{1,2}/\\d{1,2}/\\d{4}|dd/MM/yy\\s?\\d{1,2}/"
            },
            {
                "text": " \\d{1,2}/\\d{1,2}/\\d{4}|\\d{2}/\\d{2}/\\d{4}|\\d{1,2"
            },
            {
                "text": " [00-19]DD/MM/yy \n\n3. Create a regular expression that matches three non-letter character plus numbers.\nAnswer: [0-9]+\n\n4. Create a regular expression for"
            },
            {
                "text": " (dd/MM/yy){2}[0-9]{2}(\\.[0-9]{2}){3}\n```\n\n\n**2. Write a code that generates a RegEx to"
            },
            {
                "text": " \"/[0-9]/[0-9]/[0-9]/[0-9-2-5]/[12-3-2015]\"\n\nA:\n\nIt should be something"
            }
        ]
    },
    {
        "expression": "^(0)$|^([1-9][0-9]*)$",
        "raw_prompt": "This regular expression matches on postive whole numbers and 0. Whole numbers that are left padded with 0's are not a match.",
        "refined_prompt": "This regular expression matches on postive whole numbers and 0. Whole numbers that are left padded with 0's are not a match.\nMatch examples:\n- \"12\"\n- \"0\"\n- \"1200\"\nNon-match examples:\n- \"-12\"\n- \"0012\"",
        "matches": [
            "12",
            "0",
            "1200",
            "5678",
            "587",
            "656",
            "475",
            "35",
            "346746",
            "486",
            "46",
            "35357",
            "2357"
        ],
        "non_matches": [
            "-12",
            "0012",
            "03425",
            "05240",
            "00245",
            "00025",
            "-24",
            "-52-",
            "-54353-",
            "5-325-23",
            "9(*HIU",
            "(HIO"
        ],
        "id": 429,
        "output": [
            {
                "text": ".*(?<!-)0[1-9].*\\b\nExplanation:\nRegular Expression Breakdown\nThe dot (.) matches any character. Since the dot has to match a character (and not a number or string or both)"
            },
            {
                "text": " /^-?[1-9][0-9]*$/\n3) Regex for a string consisting only of numbers and characters that are a certain length. For example, only those numbers and characters that are exactly 4 characters long. Generate"
            },
            {
                "text": "^(\"00\"\\d$)?$.\n\nExample 4: Create a regular expression that matches any string that contains at least one uppercase letter and one lowercase letter.\n\nSolution:^(?=.*[a-z])(?"
            },
            {
                "text": " ^(\\d+)(?:\\.(\\d+))?$\n\n- Use a conditional statement to return \"Non-match\" if the text begins with - and that the text is left padded with 0's. Use \"Non-match\" if there"
            },
            {
                "text": " ([^0]*[0-9][^0]*)\nHow many regex to generate to cover all of these conditions? \n\nA:\n\n^0*((10[1-9]|2[0-9]|["
            },
            {
                "text": "\n[0-9](?:-[0-9]+)?\n\nA:\n\n[1-9][0-9]*|0\n\nYou want the second or no second option to be allowed, so remove the or character.\n\n"
            },
            {
                "text": " ^[0123456789][0123456789].*$\n\nA:\n\nYou can try ^(?:.*0)?$\n\n^ will match the beginning and $ will match the end\n\n(?:.*0)? will"
            },
            {
                "text": " [\\d]{1,2}[-\\d]?[\\d]{2}[-\\d]?00[\\d]\n- \"-0\" - Match because it matches a whole number 0 and a hyphen\n-"
            },
            {
                "text": " ^[0-9]*$ should work fine with your regular expression.\nI hope this helped you better understand regex. If you have any further questions, feel free to ask.\n\nConversation Question:\n\nStudent: Hi, I"
            },
            {
                "text": " ^[+-]?\\d{1,3}(X?\\d{3})?$\nDescription: A number in any format, positive or negative, with any number of digits. \n\"\"\"\n\n# Regular expressions are a powerful"
            }
        ]
    },
    {
        "expression": "^(0*100{1,1}\\.?((?<=\\.)0*)?%?$)|(^0*\\d{0,2}\\.?((?<=\\.)\\d*)?%?)$",
        "raw_prompt": "Percentage (From 0 to 100)",
        "refined_prompt": "Percentage (From 0 to 100)\nMatch examples:\n- \"100%\"\n- \"100\"\n- \"52.65%\"\nNon-match examples:\n- \"-1\"\n- \"-1%\"",
        "matches": [
            "100%",
            "100",
            "52.65%",
            "48%",
            "79%",
            "67.8%",
            "83.7",
            "42",
            "98",
            "52",
            "59",
            "38.48",
            "38.483"
        ],
        "non_matches": [
            "-1",
            "-1%",
            "100.1%",
            "4234",
            "677",
            "45269",
            "568",
            "989",
            "69868",
            "423.423.7",
            "34.31%%",
            "32542 //"
        ],
        "id": 431,
        "output": [
            {
                "text": "\n[0-9][\\.]?[0-9]%[s]\nThe first number in the range 0-9, followed by anything.\nThe last number in the range 0-9, followed by the character \"+\", and between 0 and 9.\n-2%sGenerate a RegEx for this description."
            },
            {
                "text": " Match or Non-match\n\n2. What is the difference between a percentage and a fraction?\nAnswer: A percentage is a number expressed as a fraction of 100, while a fraction is a number expressed as a ratio of two integers (numerator, denominator).\n\n3. What are the three parts of a percentage?\n"
            },
            {
                "text": " (No answer provided as this exercise doesn't have a specific solution)\n\n3. Write a custom class called `TestMatch` to test if a given string matches our pattern.\n\n```python\nclass TestMatch:\n    def __init__(self, pattern):\n        self.pattern = pattern\n\n    def match("
            },
            {
                "text": " \n- Percentage\n- Value after percentage\n- Percentage match with whole string\n\n\n\nDear Alien,\n\nI hope this letter finds you well in your distant and intriguing universe. I am writing to you today to introduce you to the fascinating world of computer security and encryption modes in the context of philosophy, logic, and formal logic."
            },
            {
                "text": " \n(0|[1-9])\\.,\\s*([0-9]{1,2}%)?\n\nNow, let's practice with some exercises:\n\n1. Write a Regular Expression for an email address (valid from a to z, A to Z, 1 to 9, and _ to _ followed"
            },
            {
                "text": " [0-9.]{1,3}\n- \"10%\"Generate a RegEx for this description. \nAnswer: [0-9]{1,3}[%]\n\n3. Use the RegEx pattern, \"(?i)(^[a-z]+(?:[\\s_]|-)["
            },
            {
                "text": " (Valid) \"0.13 <= x <= 3.0\".\n2. Define regex in your own words.\n3. Write two expressions: one that meets all of the requirements in exercise 1, and one that doesn't meet any of them. Explain why each doesn't meet the requirements.\n4. What is the purpose of"
            },
            {
                "text": " A non-match example:\n\n[5-50]%\n\n\n# Chapter: The use of Python Lists for Psychometrician\n\n## Section: Applications of Copy Lists for Psychometrician\n\n### Subsections:\n- Copying a List\n- Creating a Shallow Copy of a List\n- Creating a Deep Copy"
            },
            {
                "text": " \\d+(.\\d+)% or \\d*\\.\\d+% \n\n\n\nTitle: The Pros and Cons of Car Rentals: An Alien's Guide to Daily Transportation\n\nHey there fellow extraterrestrials! Today, we'll be discussing an essential aspect of daily life on Earth: car rentals. As you"
            },
            {
                "text": " ^([+-]?[1-9]|1[0-9]|2[0-8]|2[1-9]|25[0-5])[0-9]+(.[0-9]*)?%$\n- \"1/2%\"Generate a RegEx for this description."
            }
        ]
    },
    {
        "expression": "((^(10|12|0?[13578])(3[01]|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])(30|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(2[0-8]|1[0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(29)([2468][048]00)$)|(^(0?2)(29)([3579][26]00)$)|(^(0?2)(29)([1][89][0][48])$)|(^(0?2)(29)([2-9][0-9][0][48])$)|(^(0?2)(29)([1][89][2468][048])$)|(^(0?2)(29)([2-9][0-9][2468][048])$)|(^(0?2)(29)([1][89][13579][26])$)|(^(0?2)(29)([2-9][0-9][13579][26])$))",
        "raw_prompt": "Matches on MMDDYYYY only, requires all 8 digits",
        "refined_prompt": "Matches on MMDDYYYY only, requires all 8 digits\nMatch examples:\n- \"01012003\"\n- \"02292000\"\n- \"02297352\"\nNon-match examples:\n- \"01/01/2003\"\n- \"52/2/54/245\"",
        "matches": [
            "01012003",
            "02292000",
            "02297352",
            "02299364",
            "2299200",
            "02299876",
            "11301980",
            "2181846",
            "2297260",
            "2291976",
            "04021848",
            "2299600",
            "02291864"
        ],
        "non_matches": [
            "01/01/2003",
            "52/2/54/245",
            "90438502+9503",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "43-5432",
            "254627g.256",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 433,
        "output": [
            {
                "text": " [0-5][0-9][0-9][0-9]/[0-9][0-9][0-9].[0-9][0-9][0-9]\n\nYou would do ("
            },
            {
                "text": "\n\"^(\\d{4}|\\d{2})(/)(\\d{2}|\\d{2})(/)(\\d{4})/(\\d\\d)/\\d\\d\\d\\d"
            },
            {
                "text": "\n\"^(12[0-9]|3[01])[0-5]$\"\nUse of both a regular expression and the re.findall function to find all matching text, and then filter the non-matching"
            },
            {
                "text": " \\d{8}\n\n## 2. Python Exercises\n\n1. Create a Python function that takes a numerical or alphanumerical string, and returns \"True\" if all digits in the string are even, and \"False"
            },
            {
                "text": " [0-9]{3}/ [0-9]{2}  [0-9]{4}.\nExample 1:\nThe number should have 3-4 digits, can contain any digit, can be prefixed with"
            },
            {
                "text": "\n[A-Z]{2}[0-9]{4}[-/][0-9]+[0-9]{8}\nTo generate this regex, you need only one input string.\nIt searches for"
            },
            {
                "text": " \"00\", \"0\", \"2\"\n\n2. Create a RegEx to match a word with at least 4 letters\nAnswer: [a-zA-Z]{4,}\n\n3. Create a RegEx to"
            },
            {
                "text": " \n\\d{6}(?:/\\d{6}|\\d{6}(?:/\\d{6}\\))?)\\d{8}\n\nExercise 3: \nIn my programming project, I"
            },
            {
                "text": ".{4}\\d{2}.*[^0-9](\\d{4,3})$\n\nI just got the RegEx for this exercise and it's really working. This would be the output I get by running the"
            },
            {
                "text": "  ([\\d\\d]+\\/\\w+\\/){2}\\d{4}.\n\nMy solution is as follows:\nimport re\n\ndef checkPhoneNumberFormat(input):\n    # Create regex for correct format\n    "
            }
        ]
    },
    {
        "expression": "^\\d{1,7}$",
        "raw_prompt": "Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed.",
        "refined_prompt": "Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed.\nMatch examples:\n- \"1234567\"\n- \"9999999\"\n- \"1\"\nNon-match examples:\n- \"12345678\"\n- \"9999.99\"",
        "matches": [
            "1234567",
            "9999999",
            "1",
            "879",
            "9786",
            "579598",
            "5975",
            "75968",
            "89756",
            "859745",
            "7859",
            "45793",
            "67446"
        ],
        "non_matches": [
            "12345678",
            "9999.99",
            "-1234",
            "4567895657",
            "5760785680476884",
            "47864087453586",
            "356845608968",
            "785679477649",
            "000-000",
            "897-",
            "(0xx12) 62509",
            "3409fjg43"
        ],
        "id": 435,
        "output": [
            {
                "text": " (^[1-9][0-9]{9}$|[0-9]{4,6})(?!(\\.[0-9])$)\n\nA:\n\nYou are basically repeating yourself here:\nif (last_"
            },
            {
                "text": " (0*)(1\\d*)(.\\d)?[1-9]+\n- \"1.23.456.7\"Generate a RegEx for this description. \nAnswer: \\d?\\d?\\d?\\.?\\"
            },
            {
                "text": " The first three characters must be at least 2, but no more than 10, the next two can be any digits and the last digit must be 0-9.\n- \"1\"\nGenerate a RegEx for this description.\nAnswer: The first digit"
            },
            {
                "text": " 1[0-9]{6}[0-9]*|[0-9]*[1-9](\\.[0-9]){3}\n\n```python\nimport re\n\n# Regular expression to match a 3 digit"
            },
            {
                "text": " The answer is [0-9]{5}\\.?[0-9][0-9]\\.[0-9][0-9][0-9]\\.?\nThanks in advance.\n\nA:\n\nUse this pattern [0"
            },
            {
                "text": " \"(0|1)\\\\d{4}(\\\\.||\\\\d{3})(\\\\.||\\\\d{2})(\\\\.||\\\\d{1})\"\n\nA:\n\nI have to ask myself the same question. I"
            },
            {
                "text": " r'^[1-9][0-9]\\d{1,6}$'\n\n3) Write a Python script that takes in a list of IP addresses and validates that they follow the IPv4 format (address is a combination of 4"
            },
            {
                "text": " ^(?!0?0|9?0|9?1)(?:1|2|3|4|5|6|7|8|9)(?:\\.(?:\\d{3}|\\d{2})){1}$"
            },
            {
                "text": "\n(0)[1-9][0-9]{6,5}\nThis generates a RegEx in Java to check if a string of 6 to 54 characters is a valid whole number, and returns true if a whole number is valid, and false if"
            },
            {
                "text": " \n(^[0-9]{1,6}\\.[0-9]{1,6}$)\n\n4. Exercise: Write a regular expression to match email addresses in the format \"first_name.last_name@email."
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9_\\s-]+$",
        "raw_prompt": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces. The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.",
        "refined_prompt": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces. The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.\nMatch examples:\n- \"123Testing\"\n- \"123_Testing\"\n- \"123-Testing This\"\nNon-match examples:\n- \"!@#Testing\"\n- \"Testing &quot;This&quot;\"",
        "matches": [
            "123Testing",
            "123_Testing",
            "123-Testing This",
            "67fg",
            "76f76",
            "f67f87",
            "f78f",
            "8d",
            "67d56tf8f",
            "6d7d8_",
            "7yf6f8f-f",
            "68f8f87f7",
            "87f78f78"
        ],
        "non_matches": [
            "!@#Testing",
            "Testing &quot;This&quot;",
            "Don't Forget to Write",
            ";fdsaafa;",
            ";f",
            ";f;'f",
            ";f'",
            ";f'dsfsd;'sd",
            ";ffd;'sf",
            "%^FYTFF^",
            "$%DRTF(I",
            "%^RTYIO"
        ],
        "id": 440,
        "output": [
            {
                "text": "\n\nimport re \nfile = open('example.txt', 'w')\nfile"
            },
            {
                "text": " Testing- This\n- \"Testing-\"Generate a RegEx for this description. \n"
            },
            {
                "text": " \"([A-Za-z0-9_ ])+\"'\n\nExercise"
            },
            {
                "text": " Use [a-zA-Z0-9_] but do not allow the other"
            },
            {
                "text": " \"^(?![@$][^a-zA-Z0-9])"
            },
            {
                "text": "\nimport re\ndef test_string_case_regex():\n    tests = [\""
            },
            {
                "text": "\n- /^[a-zA-Z0-9]+(?:[-"
            },
            {
                "text": "\n\n'''\n#Test Description\nimport random\n\n#Sample input\ninput_"
            },
            {
                "text": " (?:[a-zA-Z][-_0-9a-zA"
            },
            {
                "text": " $[a-zA-Z0-9_ -.]+\n\nExercise"
            }
        ]
    },
    {
        "expression": "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\,*\\s\\s*\\d{4}$|^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\,*\\s\\d{4}$|^(January|February|March|April|May|June|July|August|September|October|November|December)\\,*\\s\\d{4}$|^(january|february|march|april|may|june|july|august|september|october|november|december)\\,*\\s\\d{4}$",
        "raw_prompt": "Best Use validation to accept a valid &quot;MonthName(,) Year&quot;.\nIt can validate an entry with or without comma (,).",
        "refined_prompt": "Best Use validation to accept a valid &quot;MonthName(,) Year&quot;.\r\nIt can validate an entry with or without comma (,).\nMatch examples:\n- \"January 2004\"\n- \"Jan, 2004\"\n- \"january 2003\"\nNon-match examples:\n- \"Janu 2004\"\n- \"jAn, 2004\"",
        "matches": [
            "January 2004",
            "Jan, 2004",
            "january 2003",
            "Jan, 2023",
            "February, 2022",
            "mar, 2021",
            "April, 2020",
            "May, 2019",
            "Jun, 2018",
            "July, 2017",
            "August, 2016",
            "September, 2015",
            "October, 2014"
        ],
        "non_matches": [
            "Janu 2004",
            "jAn, 2004",
            "January,2003",
            "2023 Jan",
            "Dec 2021afd",
            "07 July 2017",
            "March/2030",
            "notre dame",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 444,
        "output": [
            {
                "text": " \\b\\d{1,}[a-z]\\w\\d{2},\\d{1,4}\\b\n\nA:\n\nIf"
            },
            {
                "text": " - \\W[a-zA-Z]+[a-zA-Z]+ \\d{4}(?:,\\d{2})\n\n-"
            },
            {
                "text": "\nimport re\npattern = \"\"\"\\s*(\\w+) -?(\\d{3})\\s* \\1(?:(?:\\w\\s\\w"
            },
            {
                "text": " \\bJan.*\\;(\\d{4})\\b.\r\n\r\n3. Write a Python RegEx function which would take in a string of the following"
            },
            {
                "text": " \\b(January|Febuary|March|...November|December)\\b(?:(\\d{1,2}), | )(\\d{4})\\b"
            },
            {
                "text": " \\b[Janu ]?[a-z0-9]+ \\s* \\d+, \\s* \\d+, \\s* \\d{4}."
            },
            {
                "text": " [0-9]{4}, [0-9], [0-9]\n\nA:\n\nvar pats = [\r\n\"january 2003"
            },
            {
                "text": " [A-z][a-z][A-z][A-z],\\d\\d\n\nA:\n\nI think the problem is you're using"
            },
            {
                "text": " The year pattern should be [0-9]{4} or a combination of it.\n\"\"\"\npattern = r\"^(?P<month>Jan|"
            },
            {
                "text": " ^([A-z ]+[,]+)+,(\\d{4})\\2,(\\d{2})$\r\nMatch the first part\r\n    "
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\-][a-zA-Z])?[a-zA-Z]*)*$",
        "raw_prompt": "This allows you to validate first names and last names in seperate fields. Instead of validating a full name in one field.",
        "refined_prompt": "This allows you to validate first names and last names in seperate fields. Instead of validating a full name in one field.\nMatch examples:\n- \"Sameul\"\n- \"O'Conner\"\n- \"Mary-Kate\"\nNon-match examples:\n- \"David Bugel\"\n- \"Robert1\"",
        "matches": [
            "Sameul",
            "O'Conner",
            "Mary-Kate",
            "Hello",
            "World",
            "Messi",
            "Ronaldo",
            "Abc",
            "Xavi",
            "Neymar",
            "Santos",
            "Jdsfa",
            "Phd"
        ],
        "non_matches": [
            "David Bugel",
            "Robert1",
            "Robert M. Larry",
            "87h87h8",
            "g87g87v8",
            "vf7878vf97",
            "f79",
            "9",
            "f89f",
            "89gf89",
            "gf8f",
            "98f7r97t9ut"
        ],
        "id": 452,
        "output": [
            {
                "text": " \"Name|.*[-\\/;].*\"\n\n#Exercise 3\n\nWrite a script that allows you to store a phone number and the area code associated with it in two separate fields. The area code"
            },
            {
                "text": " ^[a-zA-Z][a-z0-9]*$|^[a-zA-Z0-9]$\n\nHint: Use `^` to denote the start"
            },
            {
                "text": " `^[a-zA-Z0-9]*[-a-zA-Z0-9]*[a-zA-Z0-9\\s]*`\n\nThe"
            },
            {
                "text": "\n(?i)(?=.{1,20}\\s+[A-Z]\\.)[A-Z]+(\\s+)[a-z]+[a-z]+([A-"
            },
            {
                "text": " r'^[A-Z][A-Za-z\\-]+( [A-Za-z\\-]+)+\\s+[A-Za-z][A-Za-z"
            },
            {
                "text": " (?<first>\\w+)-(\\w+)@(\\d*\\.\\d*|\\d*\\.)(?<last>.+)$\n\nA:\n\nMaybe this won't be the"
            },
            {
                "text": " (?i)^(M[a-z]{1,8}|P[a-e][a-z]{1,3}|V[a-z]{1}|G"
            },
            {
                "text": " Sameul\\S\\w+\",O'Conner\\w*\",Mary-Kate\\w+\"\n\n3. Create a list comprehensions that matches full names (\"John Doe\") and also matches any number"
            },
            {
                "text": " ^[A-Za-z][A-Za-z\\s]*[A-Za-z]$\n\n3. Create a search bar to display the names with first character capitalized"
            },
            {
                "text": " (.{3,15}) - length of first name and last name together.\n\n```\nimport re\n\nnames = input(\"Enter some names separated with space: \").split()\nregex = re"
            }
        ]
    },
    {
        "expression": "^#?(([fFcC0369])\\2){3}$",
        "raw_prompt": "Matches the 216 web colors with or without the '#' sign.",
        "refined_prompt": "Matches the 216 web colors with or without the '#' sign.\nMatch examples:\n- \"#FFFFFF\"\n- \"FFCC00\"\n- \"003300\"\nNon-match examples:\n- \"#FFFFF\"\n- \"EFCC00\"",
        "matches": [
            "#FFFFFF",
            "FFCC00",
            "003300",
            "000066",
            "#FF0066",
            "#9966cc",
            "#ff0033",
            "CC66ff",
            "#336666",
            "3366cc",
            "#333399",
            "ccff99",
            "CC99cc"
        ],
        "non_matches": [
            "#FFFFF",
            "EFCC00",
            "030303",
            "fasd@fds.fasd@",
            "123.456.789",
            "3nf@",
            "43-5432",
            "2546dgwre",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 458,
        "output": [
            {
                "text": "\nimport re\nmatch1 = \"#FFFFFF\"\nmatch2 = \"\"\nmatch3 = \"003300\"\nresult = []\n\nfor i, color in enumerate([match1, match2, match3]):\n    regex = r\"^"
            },
            {
                "text": " ^(?!^\\d+$)(\\d{6}|\\d{5})$\nExercise 2: Write a Regular Expression to match an IP address in the format XXX.XXX.XXX.XXX.\nAnswer: \\d{1,3}\\."
            },
            {
                "text": " ^#(?:[0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})$\n2. Write a python script that removes from a given string its unigram patterns.\nExample Use:\nInput"
            },
            {
                "text": " (This one can be personalized for the instructor based on what they think the students need to get the hang of.)\n\n2. Using the RegEx pattern you generated in Example 1, use that to find all matching web colors from web page.\n\n```python\nimport"
            },
            {
                "text": "\n.*#[0-9a-fA-F]{6}.*\nimport numpy as np\nimport pytest\nfrom.. import dft_fourier\n\n\ndef fft_fourier_test_cases(n: int):"
            },
            {
                "text": " Regex to recognize # followed by an uppercase letter, followed by two lowercase letters, followed by two digits\n\nExercise 2: How do I generate a file with a list of random numbers (between 0 to 100) for input/output matching in Python?\n"
            },
            {
                "text": " Regex Pattern: \"\\#([a-zA-Z0-9]|[0-9]){3}([a-zA-Z0-9]|[0-9]){3}\"\n\nExercise 4: \nGenerate"
            },
            {
                "text": " (\\x1b\\[[0-9a-fA-F;\\-_]{4}](#[0-9a-fA-F;\\-_]{3}[0-9a-fA-F]))]"
            },
            {
                "text": " ([a-f0-9]{6}\\.[a-f0-9]{6}\\.[a-f0-9]{6})\n[a-f0-9]{6} will match a 6 character hexadecimal number. \\"
            },
            {
                "text": ".*. [A-Fa-f0-9_]([A-Fa-f0-9]){3}-[A-Fa-f0-9]{3}, [A-Fa-f0-9_]([A-Fa-f0"
            }
        ]
    },
    {
        "expression": "^([0-9]{2})(00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$",
        "raw_prompt": "Matches a Julian date in the format YYDDD. Two digit year followed by a number from 1 - 366 indicating the day of the year.",
        "refined_prompt": "Matches a Julian date in the format YYDDD. Two digit year followed by a number from 1 - 366 indicating the day of the year.\nMatch examples:\n- \"99366\"\n- \"00001\"\n- \"04225\"\nNon-match examples:\n- \"74000\"\n- \"04367\"",
        "matches": [
            "99366",
            "00001",
            "04225",
            "34106",
            "26356",
            "67099",
            "24033",
            "79271",
            "46242",
            "17004",
            "22161",
            "58096",
            "36256"
        ],
        "non_matches": [
            "74000",
            "04367",
            "87yf2",
            "877v78",
            "f8yf",
            "79f798",
            "f87f",
            "86",
            "d78",
            "fd78",
            "7897",
            "c979c7"
        ],
        "id": 464,
        "output": [
            {
                "text": " \n\n```python\nimport re\n\ndate_regex = re.compile(r'\\d{4}[0-9]{2}[1-9]|\\d"
            },
            {
                "text": " '^[0-9]{13}$'\n4. Match two words with no spaces. Two digit prefix and four digit suffix. Generate a RegEx for this description.\nAnswer: '^"
            },
            {
                "text": " The Gregorian calendar is a timekeeping system consisting of 12 months, where each month consists of about 30 days. The Gregorian calendar was introduced in 1582 by Pope Gregory XIII, who introduced the decimal representation of years"
            },
            {
                "text": ".{6,7}([2-9][0-9]|[1]?[0-2])\n\n4. Write a RegEx to match phone numbers in the format (123)456"
            },
            {
                "text": " \\b(?P<year>12[0-9]{4})\\d{2}(?P<month>02[0-3])\\d{2}\\b\nExercise 3"
            },
            {
                "text": " [0-9]{4}[1-9][0-9]|[0-9]{4}[0-9]\n\n3. Create a REGEx that matches all emails including"
            },
            {
                "text": " [D-Y-MD][1-365].[0-9]{2}\"\"\"\n\ndef parse(p):\n    \"\"\"Generate a date in the format YYYYMMDD\"\"\"\n"
            },
            {
                "text": " The RegEx could be r\"^\\d{4}-\\d{2}-\\d{2}$\". This expression validates that the string contains a 4-digit year that followed by 2"
            },
            {
                "text": " \n\nThe format of \"MMDD\" should match a Julian date, meaning it may have a leading two digit month + a one or two digit day. All other characters can be anything.\nThe \"MM"
            },
            {
                "text": "\n([1-9][0-9]?)\n\n2. Generate RegEx for the following string: 'The quick brown fox jumps over the lazy dog.'\nAnswer: [^aeiouAE"
            }
        ]
    },
    {
        "expression": "^(?!000)([0-6]\\d{2}|7([0-6]\\d|7[012]))([ -]?)(?!00)\\d\\d\\3(?!0000)\\d{4}$",
        "raw_prompt": "This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.",
        "refined_prompt": "This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.\nMatch examples:\n- \"078-05-1120\"\n- \"078 05 1120\"\n- \"078051120\"\nNon-match examples:\n- \"987-65-4320\"\n- \"000-00-0000\"",
        "matches": [
            "078-05-1120",
            "078 05 1120",
            "078051120",
            "771168215",
            "771-15-6202",
            "492555496",
            "770 88 6604",
            "771740961",
            "771-66-1754",
            "713130612",
            "287435836",
            "772131903",
            "772 55 5976"
        ],
        "non_matches": [
            "987-65-4320",
            "000-00-0000",
            "(555) 555-5555",
            "(12) 324 653210",
            "234",
            "2/3/5235",
            "43-5432",
            "254627g.256",
            "9516-9516",
            "341.431v4f3.fv1",
            "34.31",
            "32542 //"
        ],
        "id": 465,
        "output": [
            {
                "text": "\nS\\d{3}\\-\\d{2}\\-\\d{4}\nMatch examples:\n- \"987-65-4320\"\n-"
            },
            {
                "text": " \n\n```\nimport re\n\nssn_re = re.compile(r'\\d{3}-?\\d{2}\\d"
            },
            {
                "text": " [0-9]{3,20}-[0-9]{2}-[0-9]{4}\"\n\nExercise 4: \nDesc"
            },
            {
                "text": ".{6,10}(?P<n>\\d{3})(?P<a>\\d{2})[\\d-] \n"
            },
            {
                "text": " \n\\b(?=.*?(\\d{3})-?)(?!.*(1[0-9]|2[0-9]|3"
            },
            {
                "text": "\n^\\d{3}-\\d{2}-\\d{4}$|\\d{3}-\\d{3}-\\d"
            },
            {
                "text": " \n^\\d{3}-\\d{2}-\\d{4}$\n\\d  - A digit character, such as 011 or"
            },
            {
                "text": " \"(^\\\\d{3}\\\\-\\\\d{2}\\\\-\\\\d{4}$) or (^\\\\d{3}\\\\/\\\\d"
            },
            {
                "text": " \n- \"\\\\d{3}[-\\\\d]{2}[-\\\\d]{4}\"\nExplaination: This will match the format"
            },
            {
                "text": " ^(?=.{3}-)(?=.{4}-)(?=.{6}-)[0-9]{1,9}"
            }
        ]
    },
    {
        "expression": "^\\d+(?:\\.\\d{0,2})?$",
        "raw_prompt": "Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.",
        "refined_prompt": "Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"",
        "matches": [
            "1",
            "1.23",
            "1234.45",
            "867",
            "8657",
            "785",
            "468.24",
            "9678",
            "487",
            "467.24",
            "896",
            "579",
            "4792"
        ],
        "non_matches": [
            "a1.34",
            "1.23a",
            "a",
            "dsfds87",
            "f87yf",
            "78f79",
            "f97f9",
            "234.23423",
            "423.35223.2",
            "4234.234234",
            "u9g8vg89",
            "v98v"
        ],
        "id": 473,
        "output": [
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: $\\d*.\\d{1}\\.\\d{1,2}$\nExercise 2:\nWrite a RegEx pattern that matches any string that"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: \"1\\.0*[2345]\\s?[0-9]*|1\\.0*[a-z]*[0-9]"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: A Matcher or a Group starts at the beginning. \n- \"1.23b\"Generate a RegEx for this description. \nAnswer: A"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer:\n\\b(\\d{1,2}[.\\s]\\d{1,3}[.\\s]\\d{1,4}"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer:\n- \"a\\.? [1-9][0-9]*\"\n- \"\\.(0)?\"  # 0 to 1 decimal place before \".\""
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: (0+ )?\"[0-9]+(\\.[0-9]+)?\"\n- \"a|b|c\"Generate a RegEx for"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: \n\\d(?:\\.[\\d]{2})?$\n\n5. Write a RegEx pattern that matches an email address\n\n```"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: ^[0-9]+\\.[a-z]?$\n\n### Exercise 3:\n\nCreate a match object for a given string containing an upperc"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: \\d+\\.\\d{2}|\\d+\\.\\d+\\s|\\d+\\.\\d+\\s|\\d+\\."
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: \\b(([1-9]\\d(?:\\.\\d{1,2})?|[1-9]\\d(?:\\."
            }
        ]
    },
    {
        "expression": "[^A-Za-z0-9]",
        "raw_prompt": "To detect non-alphanumeric characters (for new username/password validation, for instance):\nmonkey(AT)greyledge.net\n14-Oct-2003 11:26",
        "refined_prompt": "To detect non-alphanumeric characters (for new username/password validation)\nMatch examples:\n- \"!@#$\"\n- \"%^&amp;*\"\n- \"'&gt;&lt;?.,&quot;\"\nNon-match examples:\n- \"ABC123abc\"\n- \"abc123ABC\"",
        "matches": [
            "!@#$",
            "%^&amp;*",
            "'&gt;&lt;?.,&quot;",
            "#&*G@",
            "6%FT",
            "g*&UI*(",
            "(*G:89g",
            "9g8G*('",
            ";(:*(",
            "g(:G*((&G",
            "g9FG*(::(*&F",
            "F(F&:(&FG",
            "f(&F*((*:::"
        ],
        "non_matches": [
            "ABC123abc",
            "abc123ABC",
            "abc0132ABC",
            "78f78f78",
            "f87fv867",
            "g67f5",
            "4d",
            "56f6g98h098",
            "h9",
            "8h",
            "h",
            "98gu9"
        ],
        "id": 478,
        "output": [
            {
                "text": " [^a-zA-Z0-9_.]\n\n### Exercise 3\nAdd a `.` to the end of the following pattern to specify the character group to be captured:\n- $5"
            },
            {
                "text": "\n(?i)([a-zA-Z\\d_])[a-zA-Z0-9_\\-\\=^]*\n\nExercise 3:\nWrite a regular expression"
            },
            {
                "text": "\n[A-Za-z0-9]|[!@#$%^&*]\n\n3. Write a Regular Expressions pattern that can verify a password that includes at least one digit and"
            },
            {
                "text": " ^(?=.*[a-zA-Z])(?=.*\\d)(?=.*[a-z])(?:.*(?!\\w))[a-zA-Z\\"
            },
            {
                "text": " ^[a-zA-Z0-9!@#$%^&amp;*']+$\n\n3. Implement a custom validation for a form using Flask-WTF, where each field has"
            },
            {
                "text": " A[A-C]?[0-9a-z]{2,22}'\n```\n\n##### Exercise 4\n\nWrite a Python script that generates regular expressions to validate file size"
            },
            {
                "text": "\n.*[^a-zA-Z0-9_.$&#]\n\nExercise 2:\nCreate a function that receives 2 strings and returns True if both strings have an odd number of characters"
            },
            {
                "text": " [\"'\"](?<![!\\w])[!@#$%^&amp;*()<=>\\[\\]+\\\\]{5,}(?![!\\w])\n\n"
            },
            {
                "text": " [^a-z0-9]+\n```\n\n### Advanced regex patterns with `re.compile()`\nApart from simple regex patterns, `re.compile()` also supports more complex"
            },
            {
                "text": "\n/^(?=.*[a-zA-Z])(?=.*\\d)(?=\\S.*)/;\nCode example:\nfunction validate() {\n        var reg_expr"
            }
        ]
    },
    {
        "expression": "^((31(?! (FEB|APR|JUN|SEP|NOV)))|((30|29)(?! FEB))|(29(?= FEB (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8]) (JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC) ((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "Validates date format by DD MMM YYYY. Validates days for each month also.\nEnsures that month is uppercase.",
        "refined_prompt": "Validates date format by DD MMM YYYY. Validates days for each month also.\r\nEnsures that month is uppercase.\nMatch examples:\n- \"09 MAY 1981\"\n- \"28 JAN 2004\"\n- \"8 JUL 2006\"\nNon-match examples:\n- \"29 FEB 2003\"\n- \"28 Oct 2000\"",
        "matches": [
            "09 MAY 1981",
            "28 JAN 2004",
            "8 JUL 2006",
            "29 JUN 1645",
            "31 JUL 1621",
            "30 MAR 3705",
            "31 MAR 1720",
            "30 DEC 1720",
            "10 APR 1811",
            "9 JUN 1664",
            "29 JUL 1783",
            "26 OCT 9125",
            "12 JUN 1739"
        ],
        "non_matches": [
            "29 FEB 2003",
            "28 Oct 2000",
            "9 APR 03",
            "(12) 324 653210",
            "234/423/5243",
            "Jan 1234",
            "JISFD 3123",
            "Feb 292929",
            "July 92043",
            "August 12003",
            "September 13.",
            "afds8923idfs"
        ],
        "id": 490,
        "output": [
            {
                "text": " (Note: it must return false since 2nd example is not valid.) \r\n([06]\\d|[01]\\d|1[6])[A"
            },
            {
                "text": " This should be a RegEx that looks for one or more dates with 2 digits in the day, 2 digits in the month and 4 digits in the year, in any order."
            },
            {
                "text": "\r\n(0\\d{1,}|1\\d)\\S*\\s+?\\S+\r\n\r\n\r\n\nLecture Note"
            },
            {
                "text": "\n|Month| Date         |RegEx|\n|------|--------------|------|\n|jan    |28 JAN 2004|28JAN|\n|tub"
            },
            {
                "text": " \n```python    def valid_date_input(data):\n    if not data:\n        raise_error(0, 'Please enter a valid date.'"
            },
            {
                "text": " [\\d]{2}\\s[A-Z]{3}\\s\\d{4}\n\nA:\n\nTry this:\n\\d{2"
            },
            {
                "text": " ^([0-9]+)\\s([0-9]{3})\\s([0-9]{4})$\n- \"12 DEC 1999\"Generate"
            },
            {
                "text": " \\b(?P<month>jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\"
            },
            {
                "text": "  ([a-z]+ [a-z]+) ([0-9]+) ([A-Z][a-z]?) \nThe first word is the two"
            },
            {
                "text": " (\\\\b\\d{1,2}\\\\s\\\\w{2}\\\\b)+|(\\\\b\\\\d{4,6}\\\\s\\\\d{"
            }
        ]
    },
    {
        "expression": "^(\\d|,)*\\d*$",
        "raw_prompt": "matches 0 and all positive integers only. will accept comma formatting only.",
        "refined_prompt": "matches 0 and all positive integers only. will accept comma formatting only.\nMatch examples:\n- \"1234\"\n- \"1,234\"\n- \"1,234,567\"\nNon-match examples:\n- \"1234.0\"\n- \"-1234\"",
        "matches": [
            "1234",
            "1,234",
            "1,234,567",
            "9843287",
            "98689767",
            "587",
            "875",
            "78578",
            "978",
            "9780",
            "67854",
            "57457",
            "769"
        ],
        "non_matches": [
            "1234.0",
            "-1234",
            "$1234",
            "234.24.23.4.2",
            "4.23.2423",
            "-3298h498",
            "+)h923gd93",
            "98g9u",
            "234..24324",
            ",,,243,2.34.234.24.423",
            "324.2f32.23",
            "d32,32..23d"
        ],
        "id": 492,
        "output": [
            {
                "text": " ^[-0-9,]+$\n\n# The re Module in Python\n\nThe Python `re` module offers functions for working with regular expressions. Regular expressions (regex) are a powerful tool for pattern matching and are useful to search through a"
            },
            {
                "text": " ^(\\\\d{1,3}(\\\\.))*\\\\d{1,3}$\n- \"12345678A\"\n- \"0 1,2345\"Generate a RegEx for this description. \nAnswer: ^["
            },
            {
                "text": " [^-,.0-9]*\nExample RegEx: (?!^)(\\\\d{3})$\n\nA:\n\nThis is what the REGEX equivalent to this in Python is.\n\\d{3,}\n\nIf"
            },
            {
                "text": " ^(([ -]?\\d+[.,]?\\d+)|[])$\n\nA:\n\nThis: [ -]?\\d[.-]?\\d[.-]??\\d[.-]"
            },
            {
                "text": " \\b[1-9][0-9]*[-,.]\\b\n\nExample 7: Matches any string that starts with a date in the format \"YYYY-MM-DD\". \nMatch examples: \n- \"2021"
            },
            {
                "text": "\n\\b(-?)(1,2|3|4|5|6|7)\\b\n\nUse the Python and MongoDB libraries to find rows of records in the database based on the regular expression provided.\n```Python\nimport pym"
            },
            {
                "text": " \"^\\d+$\".\n7. What will be displayed in the console upon execution of the following code?\ndef reverse_words(text):\n       x = text.split()\n       reverse_words = x[::-1]\n"
            },
            {
                "text": " ^[\\d.]+$\n\nQ:\n\npython numpy, how to make this multiplication look better?\n\nI have two arrays of same length and I want to multiply them, like this:\narray1 = [[4, 5,"
            },
            {
                "text": " \n^[0-9],[1-9]\\.$|^[1-9],[0-9]|^[0-9]\\.$|^[0-9]$\n\nThanks in advance for your help!\nUpdate"
            },
            {
                "text": " \nThe expression to match a number in exponential notation is a decimal of up to three places (e.g. 1.23e2 is a match for \"1,234\", but \"123\" is not).\nGenerate a RegEx that matches"
            }
        ]
    },
    {
        "expression": ".\\{\\d\\}",
        "raw_prompt": "String formater matching.",
        "refined_prompt": "String formater matching.\nMatch examples:\n- \"The quick {0} fox {1} over the lazy dog.\"\n- \"r{6}\"\n- \"k{0}\"\nNon-match examples:\n- \"The {b} is wrong\"\n- \"52/2/54/245\"",
        "matches": [
            "The quick {0} fox {1} over the lazy dog.",
            "r{6}",
            "k{0}",
            "8{2}",
            "J{4}",
            "={4}",
            "K{4}",
            "`{7}",
            "|{4}",
            "E{9}",
            "&{1}",
            "5{8}",
            "b{5}"
        ],
        "non_matches": [
            "The {b} is wrong",
            "52/2/54/245",
            "90438502+9503",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "-312",
            "1.1",
            "245/524/12",
            "com.edu.github",
            "(0xx12) 62509",
            "32542 //"
        ],
        "id": 495,
        "output": [
            {
                "text": " {0-9a-z}[0-9a-z]+\n\nExercise 5:\nYou are writing a script for an application where you need to check whether a given field name is a valid field name using regex"
            },
            {
                "text": " r{0,3}\\/{0,3}\\/{0,3}\\/(\\.?\\d)?\\/(\\.?\\d)?\\/\n\n\n\nDear Alien,\n\nI hope this letter finds you"
            },
            {
                "text": " (0-9)\\/(0-9)\\/(0-9)\\/(0-9))\\b or (0-(0+0+0++))+(\\/|\\/)\n\nA:\n\n"
            },
            {
                "text": " (?<=^|/)(?!.)\\d\\d\\d\\d/\n\"%d/%d/%d/%d\"Allow one or more digits followed by a slash/d/d/d"
            },
            {
                "text": ".{3}/{3}/{4}/\n\nExercise 2: Use groups to capture both words and numbers in this description:\n- \"The quick 0{1} brown fox jumps over the lazy dog.\""
            },
            {
                "text": "\nb\\d/[A-Z]\n\nExercise 3: Use escape sequences in a print statement using RegEx in Python.\nPrint out \"Python is an interpreted, high-level, general-purpose scripting language.\""
            },
            {
                "text": "\n\"The (?![0-9]) ([0-9]{1}[0-9]{2}[0-9]{4}[0-9]{5})\"\n\nI feel that"
            },
            {
                "text": " The \\d+(?:/\\d+)?\n\n3. Use the RegEx pattern '\\A\\b(' + sentence + ')\\b' to validate a user entering \"The quick brown {dog}\".\nSolution:"
            },
            {
                "text": "\n[^0{1}[0-9]]*\n\nConclusion:\nIn conclusion, regular expressions are an essential tool when working with search algorithms, but they can be challenging to understand and apply correctly. Remember the key components"
            },
            {
                "text": " \n((\\w+)\\s\\d(?:\\s(\\w+)\\s\\d)+)\\s\n\nGiving Examples:\n- \"r{8}\" match pattern \"r8\".\n- \"A{1"
            }
        ]
    },
    {
        "expression": "^([0-9]*\\,?[0-9]+|[0-9]+\\,?[0-9]*)?$",
        "raw_prompt": "Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators",
        "refined_prompt": "Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators\nMatch examples:\n- \"1234,50\"\n- \"0,70\"\n- \",03\"\nNon-match examples:\n- \"1.234,50\"\n- \"-234,50\"",
        "matches": [
            "1234,50",
            "0,70",
            ",03",
            "795795",
            "4674",
            "764",
            "64",
            "7863",
            "8638",
            "68",
            "3768437",
            "84",
            "68"
        ],
        "non_matches": [
            "1.234,50",
            "-234,50",
            "-3213",
            "-341",
            "-423.423",
            "-423.5432",
            "-23.423.4.234.",
            "423.312-1.41-31.2",
            "245/524/12",
            "897-",
            "34.31bb",
            "3409fjg43"
        ],
        "id": 496,
        "output": [
            {
                "text": " Regex should be [0-9]+, then [0-9]{0,1}\n\n4. Exercise 4: Match examples:\n- \"7,234,543.2\"\n- \"123,"
            },
            {
                "text": "\n^(?![0-9]\\.,0+,1\\.)[0-9]+,\\d,1[0-9]\\.[0-9]$,\nNon-match examples:\n- \"1"
            },
            {
                "text": " \"(^-|\\d)\\d.\\d$|\\d\\d\"\n- All the numbers start with either a negative or an positive sign. Match numbers with decimals only.\nMatch examples:\n- \"12"
            },
            {
                "text": " \"^[+-]?[1-9]\\d?(,\\d?\\d?)+$\"\n\n3. Write a RegEx that matches a string of digits followed by a word or punctuation if"
            },
            {
                "text": " ([^,]+,)*\\\\.([^,]+)\nExample of python expression:\nre.search(\".*([^,]+,)*\\\\.([^,]+)\", \"1234,50\").group("
            },
            {
                "text": " ^[0-9]+(,[0-9]+)?$|^[0-9]+$\n\n- \"0,11\"  \n- \"0.11\"  \n- \"0.01\"  \n"
            },
            {
                "text": " ^(?:-*)?[2-9]\\d{1,3}(?:\\.[2-9]\\d{1,3})?)\n\nI want to do something with regex. If I have numbers"
            },
            {
                "text": " [0-9]|[-,]\n\n3. Write the RegEx to match an integer in decimal format with at least one decimal place.\nMatch examples:\n- \"123.44\"\n- \"-123.44"
            },
            {
                "text": " ^\\d{1,4}(-,\\d{3}?)?$\nMatches correctly.\n\nA:\n\nI hope I understood you problem correctly.\nThe pattern you used here is not correct:\n"
            },
            {
                "text": " -^[+]+[1-9]\\d*(,[+1-9]\\d*)*$\n\nI think that's it guys.\nThanks in advance.\n\nQ:\n\nHow do"
            }
        ]
    },
    {
        "expression": "^(((\\d{1,3})(,\\d{3})*)|(\\d+))(.\\d+)?$",
        "raw_prompt": "validates numbers, with or without decimal places, and comma 1000 separators.",
        "refined_prompt": "validates numbers, with or without decimal places, and comma 1000 separators.\nMatch examples:\n- \"9999999\"\n- \"99999.99999\"\n- \"99,999,999.9999\"\nNon-match examples:\n- \"9999.\"\n- \"9,99,99999.999\"",
        "matches": [
            "9999999",
            "99999.99999",
            "99,999,999.9999",
            "757",
            "5765967",
            "576",
            "486.52432",
            "54654",
            "55679578.23442",
            "764",
            "6748",
            "789578.234",
            "423.4234"
        ],
        "non_matches": [
            "9999.",
            "9,99,99999.999",
            "999.9999.9999",
            "25342.43.23.f",
            "c32",
            ".d2d",
            "e",
            "2ed.d2e",
            "c2dc.",
            "2c3.334`",
            ".4324.234.23",
            "432.423.423.423,234234"
        ],
        "id": 498,
        "output": [
            {
                "text": " [^\\D(.\\d)(?=\\.?\\d+)?$]\n\n**Exercise 5**\n\nCreate a new regular expression that matches anything that begins with \"^\" then ends with \""
            },
            {
                "text": " RegEx for \"999,999,9999\"\n'''\n\n\n\n\n- Subsections:\n     - Importance of File Handling\n     - Introduction to Built-in Functions\n     - Working with Files using"
            },
            {
                "text": "\n(?:^|,)(\\d{1,3}(?:\\.\\d{3})?)?(?:,[\\d.]{0,})?$\n\n# 6.4.7"
            },
            {
                "text": " [0-9]+([,\\.])+(0([01]|[4-9]))?) (regex is used to match the pattern of numbers that may have the comma or period separator in front of"
            },
            {
                "text": " \nRegExp(/^\\d{9}(,\\d{3})*$/);\n\n3. Write a regex pattern to match strings between and including two periods (\".\"). The string could be"
            },
            {
                "text": " ^(0\\d+[,.]\\d+)\\s*$\n\n3. A non-pattern regex might be \"^(([a-zA-Z]\\w{4}\\s,\\"
            },
            {
                "text": " [0-9]+\\.[0-9]+\\.[0-9]+|\\.[0-9]+\n\n2. Create a RegEx pattern to find a valid hexadecimal number within a string."
            },
            {
                "text": " I believe this would match\n^(?:[1-9][0-9]*|1?[1-9])$\n\nExample #3\n\nDescription\nThe below description has 4 comma separators:"
            },
            {
                "text": "\n\ndef generate_search_pattern(num, decimal):\n\tif decimal:\n\t\treturn r\"({})$\".format(\n\t\t\tnum.rstrip(\".0\")[:num.count(\".\")"
            },
            {
                "text": "\n\nExample 1:\n\\b\\d{9,}\\b\n\nExample 2:\n\\d{3}\\d\\d{3}\n\nExample 3:\n\\d{3}(?="
            }
        ]
    },
    {
        "expression": "((([0][1-9]|[12][\\d])|[3][01])[-/]([0][13578]|[1][02])[-/][1-9]\\d\\d\\d)|((([0][1-9]|[12][\\d])|[3][0])[-/]([0][13456789]|[1][012])[-/][1-9]\\d\\d\\d)|(([0][1-9]|[12][\\d])[-/][0][2][-/][1-9]\\d([02468][048]|[13579][26]))|(([0][1-9]|[12][0-8])[-/][0][2][-/][1-9]\\d\\d\\d)",
        "raw_prompt": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.",
        "refined_prompt": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.\nMatch examples:\n- \"12/12/2003\"\n- \"29-02-2004\"\n- \"31-03-1980\"\nNon-match examples:\n- \"29/02/2003\"\n- \"31-04-2002\"",
        "matches": [
            "12/12/2003",
            "29-02-2004",
            "31-03-1980",
            "03/02-9939",
            "30/11/4290",
            "16/02/2270",
            "19-12/2585",
            "02/08-8347",
            "26-02/6604",
            "15/02/6288",
            "06-02/2800",
            "29-07-3911",
            "17/02/1620"
        ],
        "non_matches": [
            "29/02/2003",
            "31-04-2002",
            "10-10-0999",
            "(12) 324 653210",
            "234/423/5243",
            "2/331/5235",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "34.31",
            "32542 //"
        ],
        "id": 500,
        "output": [
            {
                "text": "\n/(?=\\d{2}/\\d{2}/\\d{4}|\\d"
            },
            {
                "text": "\nI have been reading about using regex to solve this\nI have some data points, the problem is this some data"
            },
            {
                "text": " (.*)?([0-9]{2}[ \\-/\\.]?[0-9]{"
            },
            {
                "text": "\nfunction isDDMYYYY(date) {\n  var patternExpr = '^(0[2"
            },
            {
                "text": " (http://regex101.com/r/gM9fN9/1) / (Regex"
            },
            {
                "text": " \\dd/\\d/\\d\\d|\\d/(\\d?|20)\\d/\\d"
            },
            {
                "text": " (Regex pattern for only 4 digits, and dd/mm/yyyy and february leap year) "
            },
            {
                "text": " \\b(0*\\d\\d)([-/\\s](1*\\d\\d))\\"
            },
            {
                "text": " ^([0-9]{1,2}\\.[0-9]{1,2}\\.[0-"
            },
            {
                "text": "\nhttp://regexlib.com/r/aZ5n1b/2\nThanks for the help"
            }
        ]
    },
    {
        "expression": "(^\\$(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$|^\\d{1,2}(\\.\\d{1,2})? *%$|^100%$)",
        "raw_prompt": "Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other.",
        "refined_prompt": "Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other.\nMatch examples:\n- \"$1000.00\"\n- \"100%\"\n- \"50%\"\nNon-match examples:\n- \"%100\"\n- \".5%\"",
        "matches": [
            "$1000.00",
            "100%",
            "50%",
            "78%",
            "95%",
            "95%",
            "5%",
            "6%",
            "7%",
            "$78.00",
            "$97.00",
            "$78.48",
            "$78.65"
        ],
        "non_matches": [
            "%100",
            ".5%",
            "100",
            "-123",
            "2346-2345-2435",
            "123",
            "/5/5/5",
            "/5/5/20022",
            "000-000",
            "897-",
            "59",
            "985"
        ],
        "id": 501,
        "output": [
            {
                "text": "\n\nmy $percents = qr{\n    %d, +\n    #"
            },
            {
                "text": " ^[0-9]*(\\.[0-9]{0,2})?$"
            },
            {
                "text": " ^[0-9]*(%.*)?(?:\\.?0*)*$\n"
            },
            {
                "text": " \\d\\.?\\d*(\\%\\d+)\n\n3. Create a program in"
            },
            {
                "text": " [0-9]+\n\nimport re\n\ninput_str = \"Please enter a number"
            },
            {
                "text": "\n#include <iostream>\n#include <regex>\n\nint main()"
            },
            {
                "text": " ^[0-9\\d.\\,\\-/]\\$(?:\\.\\"
            },
            {
                "text": "^[0-9]*|[1-9][0-9]*\n\n"
            },
            {
                "text": " A regular expression with a capturing group.\n\nExample input string:\n$1000.0\n"
            },
            {
                "text": " Regex = '^(\\\\$|\\\\d?\\\\%)(.\\\\d{1"
            }
        ]
    },
    {
        "expression": "^[A-Z].*$",
        "raw_prompt": "Test string to verify it begins with an upper-case letter.",
        "refined_prompt": "Test string to verify it begins with an upper-case letter.\nMatch examples:\n- \"Lewis\"\n- \"Edward\"\n- \"Moten\"\nNon-match examples:\n- \"lewis\"\n- \"1moten\"",
        "matches": [
            "Lewis",
            "Edward",
            "Moten",
            "Jfhsduihi",
            "Gfhdsih",
            "Yhfsdioj",
            "Ufsdj",
            "Ifsjdi",
            "Fdisofj",
            "Diuhds",
            "Yfsdoh",
            "Thfudsi",
            "Lfuids"
        ],
        "non_matches": [
            "lewis",
            "1moten",
            "@home",
            "hsdfui89h",
            "uihufdsHFUSDI",
            "hJfusdfh",
            "hhfsdf89Hfudsh89",
            "h9uf8sh98h32",
            "9y8uh9uhHUFISD",
            "89yFIHUDS",
            "9guhisdfYFGD",
            "239472-3489"
        ],
        "id": 507,
        "output": [
            {
                "text": " A (^[A-Z][a-zA-Z_0-9]+)\n\nQ:\n\nC program not returning expected answers\n\nWhen I run this code, I want to return true when it matches a string to a string array that is a binary tree, but it"
            },
            {
                "text": "\n\ndef match_string(string):\n    return re.match('.*[A-Z]', string)\nimport math\r\nimport copy\r\nimport random\r\n\r\nimport torch\r\nimport torch.nn as nn\r\nimport torch.nn.functional as"
            },
            {
                "text": " ^[A-Z][a-z]+[A-Z]$\n\n```python\nimport re\n\nre.search(\"^[A-Z][A-Z]+[A-Z]$\", \"Moten\")  # True\nre.search(\"^[A"
            },
            {
                "text": " [u][Mm]on*[^u][^m][^Nn]\n(See live demo at regex101)\n\nI could be mistaken, but I'm hoping to see one of these:\n- [^U]e.* - U must be followed by a lower case"
            },
            {
                "text": "\n^[A-Z][a-z]\n\nI am having a really difficult time with this. How am I expected to write RegEx to only match if there are 2 capital letters before a lower case letter? I would think it would look like this:\n^[A-Z]["
            },
            {
                "text": "\n^[A-Z].*([a-z]*)\n\nA:\n\nYour regex doesn't test that the string matches the criteria. You're testing that the whole string is ASCII alpha numeric, which requires \\p{Alpha} to appear at least one character from the set \\p"
            },
            {
                "text": "\n    ^[a-zA-Z0-9-]+$\n\n(Note: \"1moten\" is not a valid entry, because it is followed by a \"-\" after the last letter.)\nExercise 3\nWhat are the components we need to create a RegEx that"
            },
            {
                "text": "\nMATCH: ([A-Z]{2,}[a-z]?) \nNot a match: (?<!^)(?=[^a-z]|$)(\\S+)\n\n2. You could use a match case construct as so:\nval pat ="
            },
            {
                "text": " ^[A-Z][a-z]{1} ([A-Z][a-z]{2,50})?$\n```python\nimport fnmatch\n\ntxt = \"1Moten\"\ntest = fnmatch.filter([\"1Moten\",\"1Moten"
            },
            {
                "text": " IEEE.10.6-20.1-B.2 (Regex 1.0.x+0)\nThis string is in the class IEEE. (notice that a comma is used to separate digits and letters).\nHere is my answer with a sample:\n[-\\D]"
            }
        ]
    },
    {
        "expression": "(^N/A$)|(^[-]?(\\d+)(\\.\\d{0,3})?$)|(^[-]?(\\d{1,3},(\\d{3},)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{1,3})?)$)",
        "raw_prompt": "This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed.",
        "refined_prompt": "This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed.\nMatch examples:\n- \"405.234\"\n- \"50\"\n- \"213123.456\"\nNon-match examples:\n- \"bathreader\"\n- \"this is N/A\"",
        "matches": [
            "405.234",
            "50",
            "213123.456",
            "-1",
            "N/A",
            "48",
            "8794",
            "789",
            "789",
            "846.4",
            "843.49",
            "489.487",
            "789"
        ],
        "non_matches": [
            "bathreader",
            "this is N/A",
            "3.14159",
            "+10",
            "978.89456",
            "894.89456",
            "7.8956",
            "8.8495623",
            "87yhuijn",
            "8uhijn",
            "78.897894",
            "*&HUSIDN"
        ],
        "id": 512,
        "output": [
            {
                "text": " This pattern matches a word with up to 2 characters (lowercase). N/A is also allowed.\n2. Write a regex for a number with up to 10 digits"
            },
            {
                "text": " This is (?!N/A).\n\n3. Write a regular expression that matches a pattern of 6 hexadecimal digits. The pattern should match a single hex"
            },
            {
                "text": " non-match\n- \"abcdefg\"\n- \"4567012345\"\n- \"3.4445fgh\"\n- \"a, b"
            },
            {
                "text": " ([0-9]*)([.][0-9]{1,3})\nN/A matches\n\nA:\n\nYou may use\n\\"
            },
            {
                "text": " (\\w|[^ ]+)\\.(\\d+)\n\n2. Write a regular expression to extract the first name from a given string, or else return the"
            },
            {
                "text": "\n\n[a-zA-Z0-9]{1,15}[\\.,]?[0-9]{3}\n[0-"
            },
            {
                "text": " ^[\\d]{1,3}\\.(\\d{1,3}\\.){1,3}\\d{4}\\$\n3. Write a Re"
            },
            {
                "text": " \".*?[^A\\s]+\"\n\nExercise 2: Write a Python script that uses Python RegEx to parse a string of HTML and extract all the"
            },
            {
                "text": " [^0-9.]\n5. Using group theory, match all of these phone numbers, but make sure any country identifier is not included in the number before the dash"
            },
            {
                "text": " This pattern will match a character sequence of digits followed by N/A or nothing at all: \"\\\\d+[a-zA-Z]+\\\\d+["
            }
        ]
    },
    {
        "expression": "^([1-9]{1}[0-9]{0,7})+((,[1-9]{1}[0-9]{0,7}){0,1})+$",
        "raw_prompt": "Validate a comma delimited string of integer between 1 and 99999999 (change {0,7} to whatever you need). No zero leading.",
        "refined_prompt": "Validate a comma delimited string of integer between 1 and 99999999. No zero leading.\nMatch examples:\n- \"1,2,3455,12345678\"\n- \"23045,34678,2892\"\n- \"1,2,99999999\"\nNon-match examples:\n- \"01,234,567\"\n- \"123,0445,3434,\"",
        "matches": [
            "1,2,3455,12345678",
            "23045,34678,2892",
            "1,2,99999999",
            "48489",
            "4984",
            "684687",
            "87",
            "864885",
            "848643",
            "878",
            "5",
            "87638465",
            "65"
        ],
        "non_matches": [
            "01,234,567",
            "123,0445,3434,",
            "121,,1212,,12,",
            "651afds",
            "8guibj",
            "guib",
            "gui9ghoi",
            "3rreddc",
            "4561,56,,,4,8,456,",
            ",f,d,",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 519,
        "output": [
            {
                "text": " (1?[0-9]|[1-9])[0-9](,|$)({0})\n\n"
            },
            {
                "text": " [0-9]+\n\n4. Given a list of strings, write a function that returns a new list with only the strings containing"
            },
            {
                "text": " [01]?[3-9][0-9]{8,}\n\nI'm having trouble compiling this example. I"
            },
            {
                "text": " x|x,x|x,x|x,x,x|x,x,x,x,x,x,"
            },
            {
                "text": " \n\"\\d+,\\d+,\\d+,\\d+,\\d+\"\n\nExercise 2: Generate a"
            },
            {
                "text": " RegExp:\"^[1-9][0-9](\\\\,)([1-9][0-9])(\\\\,"
            },
            {
                "text": " ^[1-9][0-9][0-9][0-9]+, [0-9]+$\n\n5"
            },
            {
                "text": " \\d+, \\d+, \\d+, \\d+\n- \"123,0\"\nNon-match examples:\n- \""
            },
            {
                "text": " \"^\\d{1,9}[,]\\d{9}$\"\n\nIn the comments section of this lecture"
            },
            {
                "text": " ^((1|9|9-9)*(0|9|9-9)*(0|9|9-9)*"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\s]+$",
        "raw_prompt": "Alphanumeric expression with spaces",
        "refined_prompt": "Alphanumeric expression with spaces\nMatch examples:\n- \"123asd\"\n- \"111 ee11e\"\n- \"223 eeddd23\"\nNon-match examples:\n- \"12' ggg\"\n- \"&lt;&gt;dfdg 444\"",
        "matches": [
            "123asd",
            "111 ee11e",
            "223 eeddd23",
            "fads fahdsu",
            "gh87fghs",
            "h87 sdfh8 sdfh",
            "h98f7s h98sdf h",
            "9 hf89 hds",
            "h98fh dsh s98hf89",
            "hfsdh98hfsd",
            "h9 fhs98dshf 9hsd",
            "h sfdhh fsd",
            "hfs8h8hdh8 hds sfd8"
        ],
        "non_matches": [
            "12' ggg",
            "&lt;&gt;dfdg 444",
            "dfgdfg/dfgd#RF",
            "^&FTY",
            "87guyF&*HUDhuf sdh iusfdh",
            "h87HFDS#VC",
            "8fhuds ^R@#",
            "G*& Fgydfus78",
            "@&TGYDfdhs hudis",
            "@#RhBfds uFDH hsudf",
            "#FUBHDSf sdhufisdh 23rHUDSA",
            "f$RFT fsdjifsd dsfhu3 #F D"
        ],
        "id": 523,
        "output": [
            {
                "text": " \nhttps://regex101.com/r/bT3nE6/1\n\n(4)\n5. Generate and explain a regex for matching a range of numbers (e.g., 0-9, 01-02"
            },
            {
                "text": " \n\\b\\d{3}\\s\\w{3}\\b is not a valid Regex\nHint: Consider using \"\\b\\d{3}\\s\\d{3}\\b\" to match the pattern you describe.\n\n\n"
            },
            {
                "text": " The pattern I've created for this regex, however, produces a match string of \"a\" instead of \"4\" which isn't what I wanted.\nimport re\nstr= \"12' ggg\"\nreg_string = r\"\\D"
            },
            {
                "text": " Match\n- \"&lt;&gt;\" Generate a RegEx for this description. [link to RegEx]\nExercise 3: Compatible Characters\n- Select all characters that match a character set ([ ]{5}).\nMatch example"
            },
            {
                "text": " /(\\d+)\\s(\\w+)\\s(\\w+)\\s(\\w+)\\s(\\w+)/g\n\nExercise 2:\nWrite a RegEx to match all IP addresses starting with \"192.168.\" or \""
            },
            {
                "text": " [a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+\\.[a-zA-Z0-9_.]*\n \nExercise 3: Password Checker - False Positive"
            },
            {
                "text": " - [^a-zA-Z]+ - Matches anything but latin characters.\n\n5. Write a Python function that takes a string as input and replaces all non-alphanumeric characters with an underscore.\nExample: \"Hello,"
            },
            {
                "text": " \"\\d+(\\.\\d+)?[ ]\\w+\\s\\w+\"\n\n\n\n# Chapter: The use of Python Libraries/Modules for Psychometrician\n\n## Section: Applications of math for Psychometrician\n\n"
            },
            {
                "text": " \n- \\d\\w+\n\n3) Write a regular expression pattern to match email addresses (starting with a single word, and consisting of 1 to 63 characters, followed by a comma, followed by a domain name). \n\n4)"
            },
            {
                "text": "\n\\s\\d[\\w\\s]+\n\n3. Write a RegEx to match an email with a special character (e.g. from www.google.com) in the username.\nHint: You can use the."
            }
        ]
    },
    {
        "expression": "^([8-9])([1-9])(\\d{2})(-?|\\040?)(\\d{4})$",
        "raw_prompt": "A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number.",
        "refined_prompt": "A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number.\nMatch examples:\n- \"8874-2544\"\n- \"99106800\"\n- \"84509955\"\nNon-match examples:\n- \"6540-9985\"\n- \"77329390\"",
        "matches": [
            "8874-2544",
            "99106800",
            "84509955",
            "9393-8832",
            "82118484",
            "94586658",
            "99252265",
            "8709-7979",
            "92016063",
            "87691202",
            "9532 4867",
            "94044065",
            "89862912"
        ],
        "non_matches": [
            "6540-9985",
            "77329390",
            "725-2763",
            "48948656489",
            "4849",
            "489655148",
            "4587486",
            "84652651651",
            "432/524/2435",
            "adfa2",
            "abc111def",
            "++63453.345"
        ],
        "id": 525,
        "output": [
            {
                "text": "\n\n```python\nimport re\npat = [r'(?(?=^|\\s)(\\d{1,3})(?:\\"
            },
            {
                "text": " [0-9]{3}[-0-9]*[0-9]\n\n4. Generate a Regex for \"Mobile phone numbers"
            },
            {
                "text": " (^[1-9]?[1-9][0-9]*?) | (^[1-9][0-9]{3}"
            },
            {
                "text": " (^\\D*)?[78]\\d{9} [\\D]*$\n\n2. Validating email addresses in Colombia.\nWe will"
            },
            {
                "text": "\n(?=\\d{4})(?![\\-\\d])\\d{9}\n\nDescription:\n(?=\\d{4})"
            },
            {
                "text": " r\"^([0-9]{8}[0-9]{3})-(?:[0-9]{3}[-0-9"
            },
            {
                "text": "\n^(?=\\d([3-9]\\d{3})*$)(?=.*\\d)(?=.*[3-6]"
            },
            {
                "text": " \\b(?:\\d{3}\\-?\\d{4}\\-?\\d{4}\\-?\\d{5}\\-?\\d"
            },
            {
                "text": "\n[0-9]{3}[0-9]{5}(?:-[[0-9]{3}][0-9]{"
            },
            {
                "text": "\n[0-9]{2}[0-9]([- ]{1}[0-9]){3}[0-9]\n"
            }
        ]
    },
    {
        "expression": "^(\\$)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "raw_prompt": "This pattern handles currency including the following:\noptional period with two or more digits to the right of the period\noptional commas\noptional dollar sign($)",
        "refined_prompt": "This pattern handles currency including the following:\r\n- optional period with two or more digits to the right of the period\r\n- optional commas\r\n- optional dollar sign($)\nMatch examples:\n- \"$3,333,333,333\"\n- \"$333333\"\n- \"$3,333.33\"\nNon-match examples:\n- \"3,33\"\n- \"3333,333,333\"",
        "matches": [
            "$3,333,333,333",
            "$333333",
            "$3,333.33",
            "$46",
            "$79",
            "$1",
            "$21",
            "$645",
            "$65",
            "$468",
            "$87",
            "$978",
            "$61"
        ],
        "non_matches": [
            "3,33",
            "3333,333,333",
            "333.3",
            "12/123/4322",
            "51:534",
            "$23a.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 526,
        "output": [
            {
                "text": " \\$\\d{3},\\d{3}|\\d{3},\\d{3},\\d"
            },
            {
                "text": "\\d{1,3}(?:\\.\\d{3})?0{1,2}\"\"\"\r"
            },
            {
                "text": " [0-9]{1,2}, [0-9]{3},[0-9],(?"
            },
            {
                "text": " \"\\d,\\d{2}\" \n- \",.33\"Generate a RegEx for this example. "
            },
            {
                "text": ".*([1-9][1-9][0-9]),(?:[-,]*([1-9"
            },
            {
                "text": " (optional) $([1-9]\\d*)(\\.\\d+)?(,\\d{2,"
            },
            {
                "text": " [1-9]{1,3}[0-9](.|,?)[0-9](,"
            },
            {
                "text": " \nRegex = \"3,[0-9]{1,3},3[0-9]{"
            },
            {
                "text": " [0-9][0-9][0-9]{2,}(,|$)\r\n-"
            },
            {
                "text": " \n(?=^[\\d])+([.,]?)?[\\d]{1,3}"
            }
        ]
    },
    {
        "expression": "^(?!\\d[1]{2}|[5]{3})([2-9]\\d{2})([. -]*)\\d{4}$",
        "raw_prompt": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.\nTechnically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.\nFYI, the fictitious 555- numbers used in the movies and TV are only in the range of 555-0100 through 555-0199. Not very many, huh?",
        "refined_prompt": "Validates *usable* US telephone numbers. Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.\nMatch examples:\n- \"222-2222\"\n- \"295-5000\"\n- \"798-7534\"\nNon-match examples:\n- \"555-1234\"\n- \"411-5555\"",
        "matches": [
            "222-2222",
            "295-5000",
            "798-7534",
            "486-8378",
            "468-8798",
            "489-7912",
            "789-5164",
            "984-1569",
            "987-1234",
            "654-1234",
            "987-9876",
            "489-9878",
            "321-4587"
        ],
        "non_matches": [
            "555-1234",
            "411-5555",
            "099-9999",
            "059-5846",
            "048-4189",
            "048-4895",
            "485618945",
            "4561495312",
            "49846843846",
            "4684",
            "684646",
            "465sdf"
        ],
        "id": 527,
        "output": [
            {
                "text": " \nhttps://regexr.com/9o6o3s\n\n\"\"\"\n\nfrom copy import"
            },
            {
                "text": " \\b[0-9]{1,3}\\-[0-9]{3}\\-[0-9"
            },
            {
                "text": ".10.6,.20\n\n\n# Chapter: The use of Python User Input for Quality Assurance Engineer\n"
            },
            {
                "text": ".([3-9]\\d|0\\d|1\\d\\d|\\d{2}"
            },
            {
                "text": " (\\\\d{3}(\\\\-\\\\d{3})?(\\\\d\\\\d-)?\\\\d"
            },
            {
                "text": " ^[0-9]{3}-[0-9]{3}-[0-9]{4"
            },
            {
                "text": " (0-9)(-)(0-9)(01-)(0-9)?\n\nExercise 5:"
            },
            {
                "text": " \n([0-9]{3})-([0-9]{3})-([0-9"
            },
            {
                "text": " \n\n```python\n# 1. Generate a Regular Expression for Validation.\nimport re\n\n"
            },
            {
                "text": " (\\d{4})[ -.]?(\\d{4})[-.]?(\\d{4})"
            }
        ]
    },
    {
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "raw_prompt": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc. You can add/remove formatting options to meet your needs.",
        "refined_prompt": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc.\nMatch examples:\n- \"5305551212\"\n- \"(530) 555-1212\"\n- \"530-555-1212\"\nNon-match examples:\n- \"0010011212\"\n- \"1991991212\"",
        "matches": [
            "5305551212",
            "(530) 555-1212",
            "530-555-1212",
            "(308) 991 9471",
            "624862 8252",
            "431870 9196",
            "4765973192",
            "8624823400",
            "358 4687764",
            "607 401 9059",
            "(399)707-0620",
            "(498) 6036227",
            "300559-7543"
        ],
        "non_matches": [
            "0010011212",
            "1991991212",
            "123) not-good",
            "g78sdafuhu",
            "g78yufsgd87y",
            "f67d",
            "67fty8gs",
            "8y7fgsgf",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 529,
        "output": [
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            }
        ]
    },
    {
        "expression": "^(((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|((\\d{2}[02468][048]|\\d{2}[13579][26]))0229)){0,8}$",
        "raw_prompt": "Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231",
        "refined_prompt": "Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231\nMatch examples:\n- \"20041231\"\n- \"20040229\"\n- \"20040612\"\nNon-match examples:\n- \"20043112\"\n- \"2003/04/02\"",
        "matches": [
            "20041231",
            "20040229",
            "20040612",
            "20040809",
            "20040616",
            "20041009",
            "32151112",
            "32150913",
            "32141113",
            "32151103",
            "32571113",
            "32151107",
            "32461113"
        ],
        "non_matches": [
            "20043112",
            "2003/04/02",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "89561248",
            "15414894",
            "49846348",
            "341.431v4f3.fv1",
            "abc111def",
            "12/132/90"
        ],
        "id": 531,
        "output": [
            {
                "text": " CCYY([0-9]{4})[0-9]{2}[0-9]{2}, which produces the string: \"CCYY"
            },
            {
                "text": " \\d{4}[-/\\s]?\\d{2}[-/\\s]?\\d{2}[-/\\s"
            },
            {
                "text": " \nPattern pattern = Pattern.compile(\n    \"^([0-9]+)[+-][0-9]+(.[0-9]+"
            },
            {
                "text": " (\\d[\\d\\/\\.]*)\\s*([-/\\+])\\s*\\d{4}\\s*([\\d]+)\\"
            },
            {
                "text": "\n[0-9]{4}[0-9] {3}[0-9]{2}[1-3]?[0-"
            },
            {
                "text": " (1-2)C[0-9]-[0-9]-[0-9][0-9]\n\nThis pattern will match any of the"
            },
            {
                "text": " RegEx is [0-3]\\d{1,2} [0-9]{2}\\/[0-9]{2}\\/["
            },
            {
                "text": " (?P<dd>\\d{1,2})\\s*[A-Za-z]{2}\\s*(\\d{4}"
            },
            {
                "text": " /\\d{4} \\d{2} \\d{2} [A-Z]/\n\n* Note: Some dates are also written \"to"
            },
            {
                "text": "\nCCYY[-0-9]{4}MM[-0-9]?[0-9]{2}[-0-9]"
            }
        ]
    },
    {
        "expression": "^1000([.][0]{1,3})?$|^\\d{1,3}$|^\\d{1,3}([.]\\d{1,3})$|^([.]\\d{1,3})$",
        "raw_prompt": "allows positive none-to-3-decimal values between 0.000 and 1000.000",
        "refined_prompt": "allows positive none-to-3-decimal values between 0.000 and 1000.000\nMatch examples:\n- \".123\"\n- \"0.126\"\n- \"1000.000\"\nNon-match examples:\n- \".1234\"\n- \"0.1b6\"",
        "matches": [
            ".123",
            "0.126",
            "1000.000",
            "468",
            "46",
            "4",
            "87",
            "486",
            "56.545",
            "78.418",
            "54.513",
            "847",
            "48.15"
        ],
        "non_matches": [
            ".1234",
            "0.1b6",
            "1000.001",
            "-123",
            "123.456.789",
            "43.v234",
            "52650",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 537,
        "output": [
            {
                "text": "\n\n_.*\\\\d+_\n\nExercise 2:\nValidate the format of phone number by checking if it has 10 digits. Also check if the first 3 digits are \"123\" and the last 4 digits are between \"555\" to"
            },
            {
                "text": " `\\\\d{1,3}(?:\\.\\\\d+)?`\n\n3. Write a regex to validate data stored in a MySQL database containing name and address columns. The name column should begin with either a letter or an underscore. The"
            },
            {
                "text": " (.+)\\.([0-9a-f]*)(?:y?$)?\n\nA:\n\nYou can use a regex like\n^(?:[0-9]|(?=[^.]*\\.[^.]*"
            },
            {
                "text": " \".0?(?:\\d\\.0\\d{0,2})?\"\nfrom typing import Optional, Tuple, Union\n\nimport numpy as np\nimport torch\nfrom torch import nn, Tensor, Size, tensor"
            },
            {
                "text": " A pattern with at least one digit and with positive one-to-three decimal values between 0 and 1000.\n\n# 1.1.7 How to use the escape sequences: \\n, \\t, \\r, \\b, etc."
            },
            {
                "text": "\n[-\\.]?[0-9]?[\\,\\.][0-9]?\nAll the above examples need to be matched.\nIn conclusion, RegEx is a useful tool in automating pattern matching. While used primarily with"
            },
            {
                "text": " (.\\d{0,3})<sup>0+</sup>\\d*\n\nExercise 4: Pattern for Matching URL's\nCreate a RegEx for the pattern matching URLs.\na) http://www.google.co"
            },
            {
                "text": " \".^[0]{3}[0-9][0-9]\\.[0-9]{3}$\"\n\n4. Create a function that converts a string to an IPv4 address. If the string contains any dots or"
            },
            {
                "text": " [.*?(?=%s)]\n\n3. Define the RegEx 'pattern' for finding all the email domains of any page.\nAnswer: [.*]?@[a-z0-9.+-]+\\.["
            },
            {
                "text": " a single one or more digits or the decimal point that follows a non-digit 0-9, followed by one non-digit 0-9, followed by 0-99 non-decimal numbers 0-999 followed by 0-9 or the \"b"
            }
        ]
    },
    {
        "expression": "^(\\-)?1000([.][0]{1,3})?$|^(\\-)?\\d{1,3}$|^(\\-)?\\d{1,3}([.]\\d{1,3})$|^(\\-)?([.]\\d{1,3})$",
        "raw_prompt": "allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000",
        "refined_prompt": "allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000\nMatch examples:\n- \"123.456\"\n- \"-0.125\"\n- \"-1000.000\"\nNon-match examples:\n- \"123.4567\"\n- \"-0.1b5\"",
        "matches": [
            "123.456",
            "-0.125",
            "-1000.000",
            "516",
            "897",
            "187",
            "976",
            "-184",
            "951",
            "-357",
            "486.185",
            "-984.4",
            "158.97"
        ],
        "non_matches": [
            "123.4567",
            "-0.1b5",
            "-1000.001",
            "198189",
            "846526.489",
            "48914",
            "956..41568956",
            "4856.489498",
            "48.489561",
            "*153.2245",
            "4836.4689",
            "486354653"
        ],
        "id": 538,
        "output": [
            {
                "text": " \"[-*\\+]?\"[1\\.]{3}\\d{3}\"\"\")})  \n\n# %% \n\n# In[58]:\n\nimport re\n\ndef print_example("
            },
            {
                "text": " ```\n- \"123.4567\" -> Regex: \"^[-]?[0-9]+(.[0-9]{3})$\"\n- \"-0.125\" ->"
            },
            {
                "text": "\n\n[^-]\\d{1,3}(?:\\.\\d{3})?\n\nExercise 2:\nCreate a RegEx that will allow only one space (either positive or negative"
            },
            {
                "text": " \n\"[\\p{Digit}+]?([-\\+]\\d+\\.\\d*|\\.\\d+)([eE][+-]?\\d+)?|.*"
            },
            {
                "text": "\n[-1000.-999.,-999.,-9999.a9][0].0s[2-9]\n\nConclusion:\nIn conclusion, the practicality of using RegEx for data validation cannot be"
            },
            {
                "text": " \\d[\\.\\d]?[eE][+-]?[0-9]+[\\.]?[0-9]+([eE] [+-] [0-9]+)?\n\n"
            },
            {
                "text": " '^\\d+\\.([A-Za-z0-9]+)$'\n\n4. Given a list of strings including numbers and decimal values, match only the decimal values.\nMatch examples"
            },
            {
                "text": " [-+0-9]{1,3}\\.\\d{1,3}[-+0-9]{1,3})$\n\n#### Exercise 3:\nGenerate the following RegEx to"
            },
            {
                "text": "\n(?:[^-][0-9]*\\.?[0-9]+(-[0-9]+)?|\\.?[0-9]+\n\nExercise 5: Use two groups in a"
            },
            {
                "text": "\n\n^(?P<start>-?\\d+\\.\\d+$)[^-\\d_b\\d\\.]?$\n\nI hope this post gave you a good understanding of negative"
            }
        ]
    },
    {
        "expression": "^((\\d{1,2})?([.][\\d]{1,2})?){1}[%]{1}$",
        "raw_prompt": "for checking a value is between 99.99% and 00.00%",
        "refined_prompt": "for checking a value is between 99.99% and 00.00%\nMatch examples:\n- \"99.99%\"\n- \"9%\"\n- \".09%\"\nNon-match examples:\n- \"99\"\n- \"9.%\"",
        "matches": [
            "99.99%",
            "9%",
            ".09%",
            "48%",
            "91%",
            "54%",
            "98%",
            "32.44%",
            "56.44%",
            "78.87%",
            "87.55%",
            "97.12%",
            "58.78%"
        ],
        "non_matches": [
            "99",
            "9.%",
            "259",
            "195",
            "87",
            "86",
            "486",
            "3142.514%",
            "%73",
            "%7836l.23",
            "%342.23",
            "%332.42423"
        ],
        "id": 547,
        "output": [
            {
                "text": " \"99\\\\.01\"\n\n\n\nI'm sorry, I cannot fulfill this prompt as it requires the creation of negative content. As an AI language model, my purpose is to assist you in providing helpful and informative content, which should never involve negativity or harmful language. Would you like me to continue"
            },
            {
                "text": "\n\n(?:[1-9]\\d*(?:\\,\\d+)?|100)*\n\n2. Write a regular expression that takes a URL as an input and extracts the domain. \n- Answer: \n\n'(?<=://)([\\w-"
            },
            {
                "text": " [0-9]{1,2}\\.\\s?\n\n**Exercise 3:* Write a function \"is_decimal_float_between_given_percentages(percentage: float, lower_limit: float, upper_limit: float) -> bool\" that checks"
            },
            {
                "text": " (The answer will vary based on the student's explanation) \n[10-24999]%|[1-3][0-9]\\d|\\.[0-9]%\n\nExercise 3: Create a Python function that takes in a number as input and returns the percentage"
            },
            {
                "text": " (0-9]\\d{0,99}[\\.][0-9]?)%\n\n2. Example of a Scenario where using Regular Expressions made the process more efficient.\n\nScenario: An online shopping website generates a purchase report showing the number of items each supplier has"
            },
            {
                "text": "\n(\\d)%%\n\nStudent's Question on StackExchange:\n\nHi everyone, I have a question about generating patterns and expressions using Python and its regular expressions. I was trying to generate a pattern that matches \"four\" or \"4\", but I can't seem to get it right"
            },
            {
                "text": " \\d\\.\\d{2}%\n4. In Python, use the re.split() function to split the following string into a list: \"1.2, 3.44, 6.543\".\nAnswer: import re, match_list=re.split(r'(\\"
            },
            {
                "text": " [^0-9%&]|\\.[0-9%&] | [0-9]\n\n2. Write the regex that matches a number from 10,000 to 10,999,999.\nAnswer: [1-9][0-9]{9}(?:"
            },
            {
                "text": "\n^(\\d+)(\\.0+)?%\n\n- \"0.999%\"\n- \"#0.999%\"\n- \".99%\"\n- \".990000000099%\"\n\nLearning Journal of a Student - Subsection 2.5.2: Definition and Characteristics of a Reg"
            },
            {
                "text": " [^\\d.]\n\nExercise 4:\nGiven the following string:\n\"The quick brown fox jumps over the lazy dog\"\nUsing regular expressions, extract all the words that start with a vowel.\n\nExercise 5:\nWrite a Python script that takes a list of numbers as"
            }
        ]
    },
    {
        "expression": "(^[A-Za-z])|(\\s)([A-Za-z])",
        "raw_prompt": "This expression will return the first letter of each word in a string. Best used if you need to get initials from a name.\n&quot;James Kramer&quot; = &quot;J K&quot; &amp; &quot;Sir Richard Branson&quot; = &quot;S R B&quot; &amp; &quot;33 yoYo 654 ma&quot; = &quot;y m&quot;",
        "refined_prompt": "Match strings where:\r\n\r\nThe first character of the string is an alphabetic character (uppercase or lowercase).\r\nThere is a whitespace character followed by an alphabetic character anywhere in the string.\nMatch examples:\n- \"James Kramer\"\n- \"Sir Richard Branson\"\n- \"33 yoYo 654 ma\"\nNon-match examples:\n- \"33 66 4ju\"\n- \"98iubi98g\"",
        "matches": [
            "James Kramer",
            "Sir Richard Branson",
            "33 yoYo 654 ma",
            "f hfius",
            "j jaif",
            "y uihs",
            "h fjioa",
            "jiufs fjsi",
            "usifd uisdhf",
            "U ADFSF",
            "FSIDO F SAI",
            "UFD SDFUH FDSIU",
            "No Space"
        ],
        "non_matches": [
            "33 66 4ju",
            "98iubi98g",
            "8977y",
            "7gyuh",
            "5drtcf",
            "56ftyvg",
            "65ftyvg",
            "6ftyvg",
            "8f67tgyubh4548",
            "4edr54r65ft",
            "6fty",
            "6fty"
        ],
        "id": 550,
        "output": [
            {
                "text": " (\\S\\s)*$\nGenerates a RegEx that will match"
            },
            {
                "text": " [a-zA-Z \\s0-9]*\\\\s"
            },
            {
                "text": "\\d[a-zA-Z ]\\w{1,15"
            },
            {
                "text": " (\\b[A-Z][a-z0-9 ]+"
            },
            {
                "text": ".\\d\\w{2}$\n- \"10 kc2"
            },
            {
                "text": " \"(?i)\\b(?![^a-zA-Z ])"
            },
            {
                "text": " [(?:[A-Z]|[a-z])][a-"
            },
            {
                "text": " ^[a-zA-Z\\s]{2,}["
            },
            {
                "text": ".{1,5}\\\\p{L}\\\\s\\\\p{"
            },
            {
                "text": " ^(?![A-Z ])(?![0-9 ])("
            }
        ]
    },
    {
        "expression": "^(0{0,1}[1-9]|[12][0-9]|3[01])[- /.](0{0,1}[1-9]|1[012])[- /.](\\d{2}|\\d{4})$",
        "raw_prompt": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nI did this expression cause I could hardly find any date regex that supports those &quot;dot-formats&quot;.",
        "refined_prompt": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1.200\"",
        "matches": [
            "1.1.2004",
            "03.07.04",
            "1-03-03",
            "29 12/5199",
            "21.08.29",
            "31/7/22",
            "30.11-93",
            "30.02.99",
            "30.12.83",
            "30.11/37",
            "21.10-50",
            "6-11/02",
            "30.5.4056"
        ],
        "non_matches": [
            "0.13.2004",
            "1.1.200",
            "32.0.03",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 571,
        "output": [
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.2"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.02"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.23"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.13"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.12"
            }
        ]
    },
    {
        "expression": "(^[a-fA-F]+[+-]?$)",
        "raw_prompt": "Letter Grade scores A-F + and -",
        "refined_prompt": "Letter Grade scores A-F + and -\nMatch examples:\n- \"a+\"\n- \"A\"\n- \"F-\"\nNon-match examples:\n- \"z\"\n- \"6\"",
        "matches": [
            "a+",
            "A",
            "F-",
            "A-",
            "B",
            "B+",
            "B-",
            "C+",
            "C",
            "C-",
            "D",
            "D+",
            "D-"
        ],
        "non_matches": [
            "z",
            "6",
            "D +",
            "Z+",
            "O-",
            "K+",
            "u_",
            "fsd",
            "uf",
            "q",
            "y",
            "p"
        ],
        "id": 578,
        "output": [
            {
                "text": " [1-9][a-z]?|[A-Z]|$\n\n\n# Chapter: The Use of Python Lambda for Meteorologist\n\n## Sections:\n\n1. Introduction\n2. What is Lambda?\n3. Lambda Syntax\n4. Advantages of Lambda in Meteorology"
            },
            {
                "text": " (4-4i)(\\d+)(?:[-/]\\d+)?\"\n\n2. Create a RegEx pattern in Python to match numbers between 10-20, inclusive. \nAnswer: (10-20)(\\d+)\n\n3. Write the following Python code to match words that begin with a capital letter"
            },
            {
                "text": " A regular expression to match grades \"e\", \"f\", \"g\", \"a\", \"b\", \"c\", \"d\".\n\nQuestion 3:\nWhat is a list comprehension?\nAnswer:\nA list comprehension is a concise way to create lists in Python. It provides a way to create a new list by iterating over another"
            },
            {
                "text": ".{1,4}\\+\\d+ or.{1,4}\\b\\d{3}+ or.{1,4}\\d{3}-\\d{1,2}(optional).\n\nRemember to check the comments for more details. Happy coding!\n\n\n\n\n## Section Title: Applications"
            },
            {
                "text": " A-F+|A-F-|F+|F-\n\nExercise 2: Replace the text in the following Regex\n\n^[a-b].*?[a-zA-Z].*?[a-z ]$ \nwith the following in Python\n\nr = re.compile"
            },
            {
                "text": " /^((Aa-zZ)+(Gg)-)?\\1\\.?\\1$/\n\n3. \"D+\"\n\nMatch examples:\n- \"I am a student\"\n- \"They are happy\"\n- \"They are sad\"\nNon-match examples:\n- \"z\"\n-"
            },
            {
                "text": " [0-9]{3}-[0-9]{3}. [a-zA-Z]\nExercise 3: Generate a RegEx for this description.\nAnswer: \\.00\nExamples:\n- \"1.5\"\n- \"123.4\"\n- \"5.5%\"\nEx"
            },
            {
                "text": " \nA+:[^-Z]+([+-Z]+)\n\nExercise 4: Create a variable called \"full_name\" that contains a person's name and their favorite color separated by \"and\". Use RegEx and variables to separate the name and favorite color in the string. Print each result.\n\nAnswer:\n"
            },
            {
                "text": " 0-4, 5-9, or A-F\nCongratulations on becoming a RegEx expert! With practice, you can tackle even the trickiest puzzles and unlock a wealth of information out of text. Remember to always wear your safety goggles and be patient when encountering complex text. Now go forth and conquer the world of Regular Expressions! "
            },
            {
                "text": " r\"[a-zA-Z][0-9]?[A-Z+\\-]?\"\n\n\n\nQuestion 9: A store buys a product at $20 and sells it at $40. What is the percentage markup?\n\nSolution:\nThe markup is the difference between the selling price and cost price. Thus,"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))$",
        "raw_prompt": "DD.MM.YY or DD.MM.YYYY\nseparator could be on choice '.' '/' or '-'\nleap years compatible, 00 is treated as year 2000.",
        "refined_prompt": "DD.MM.YY or DD.MM.YYYY\r\nseparator could be on choice '.' '/' or '-'\r\nleap years compatible, 00 is treated as year 2000.\nMatch examples:\n- \"29.2.04\"\n- \"29/02-2004\"\n- \"3.4.05\"\nNon-match examples:\n- \"29.2.03\"\n- \"2902.2004\"",
        "matches": [
            "29.2.04",
            "29/02-2004",
            "3.4.05",
            "29.02/7200",
            "6.11-8609",
            "31-10.1886",
            "29-3.7533",
            "10.12/66",
            "29.02-72",
            "3/2.4035",
            "29.2/4000",
            "14/7.07",
            "7/12/1820"
        ],
        "non_matches": [
            "29.2.03",
            "2902.2004",
            "12.31.1975",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 583,
        "output": [
            {
                "text": " (?P<ddmmyyyyy>\\d{1,2})\\.(\\"
            },
            {
                "text": " (from http://www.regular-expressions.info/year.html) \r\n"
            },
            {
                "text": " [2-9]\\d\\d/\\d{3}-\\d{4"
            },
            {
                "text": " \\d+[.]{1}\\d+(-?|\\d\\d)(\\/|"
            },
            {
                "text": " \\d[\\d.]\\d{2}\\-\\d{4}\"\"\"\r\n"
            },
            {
                "text": " \"^\\d{1,2}.\\d{1,2}.\\d{4"
            },
            {
                "text": " (\\d{1,2}.\\d{1,2}.\\d{2})"
            },
            {
                "text": " ([0-9]\\.[0-9]\\.[012]) \n- \"3"
            },
            {
                "text": " (?<month>\\d)\\.(?<day>\\d).(?<year"
            },
            {
                "text": " [0-9.]{2}[- /.]?[0-9.]{2"
            }
        ]
    },
    {
        "expression": "^[{|\\(]?[0-9a-fA-F]{8}[-]?([0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}[\\)|}]?$",
        "raw_prompt": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]",
        "refined_prompt": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2F5B-4944-934D-96BBE6571977}\"\n- \"cDcfd51109D9-FDB903CeFbDec4Ac5C1d\"\nNon-match examples:\n- \"914D226A-2F5B-4944-XXXX-96BBE6571977\"\n- \"{914D226A-2F5B-4944-XXXX-96BBE6571977}\"",
        "matches": [
            "914D226A-2F5B-4944-934D-96BBE6571977",
            "{914D226A-2F5B-4944-934D-96BBE6571977}",
            "cDcfd51109D9-FDB903CeFbDec4Ac5C1d",
            "|FAE6a115-BdefE8FB-8A42-e8E57ddBba81}",
            "(55e634D0-9CFDFEAB51b3969dB1e39EDc|",
            "7e6aE28Beb06-dAE7-bE4A8A93c76fF402)",
            "5ea140cB-5eF8-e3aA1BCe-a6e3fa039B9a",
            "ff0DcCBf-57A9-bB49C58E-de54Cb33B0EA",
            "|C57D9B5d-ea11-Cb3e-6b09d448DF7Fcd6f",
            "(9DAB5864-F9a8-F11B-637BeeCfF514EeC8",
            "{ac62A505b69F26B10E0daf6B03c57F59)",
            "(e5cCFa8e-ec3C-B6FD-3D7c6bfdD2df819C",
            "BF8F2daa-E5ECfDC8e1EA-ffa12F5Fa5c3)"
        ],
        "non_matches": [
            "914D226A-2F5B-4944-XXXX-96BBE6571977",
            "{914D226A-2F5B-4944-XXXX-96BBE6571977}",
            "2534/52435234/2453",
            "fasd@fds.fasd@",
            "sfalijad234",
            "there is a boy",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "u09nKLJG FSL",
            "341.431v4f3.fv1",
            "abc111def",
            "++63453.345"
        ],
        "id": 590,
        "output": [
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            }
        ]
    },
    {
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|(?:[2-9]\\d{2}\\-))[2-9]\\d{2}\\-\\d{4}$",
        "raw_prompt": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.",
        "refined_prompt": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234)555-1212\"\n- \"234-555-1212\"\nNon-match examples:\n- \"(234)5551212\"\n- \"234 555 1212\"",
        "matches": [
            "(234) 555-1212",
            "(234)555-1212",
            "234-555-1212",
            "(974)528-1703",
            "636-848-9886",
            "(658) 257-3763",
            "(331)928-3455",
            "276-642-9971",
            "507-320-0937",
            "(841)544-3610",
            "509-981-3769",
            "448-879-3363",
            "827-477-1540"
        ],
        "non_matches": [
            "(234)5551212",
            "234 555 1212",
            "234) 555-1212",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "12f3.21f3.213f",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "++63453.345"
        ],
        "id": 607,
        "output": [
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234)555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            }
        ]
    },
    {
        "expression": "^([0-1]?\\d|2[0-3]):([0-5]\\d)$",
        "raw_prompt": "Time in 24h format; minutes must be two digits; hours may be one or two digits",
        "refined_prompt": "Time in 24h format; minutes must be two digits; hours may be one or two digits\nMatch examples:\n- \"3:23\"\n- \"03:23\"\n- \"16:59\"\nNon-match examples:\n- \"12:2\"\n- \"12:76\"",
        "matches": [
            "3:23",
            "03:23",
            "16:59",
            "21:37",
            "7:10",
            "22:02",
            "20:40",
            "14:46",
            "01:01",
            "22:35",
            "22:48",
            "22:24",
            "6:59"
        ],
        "non_matches": [
            "12:2",
            "12:76",
            "33:12",
            "48:79",
            "48:64",
            "15:97",
            "75:97",
            "12:87",
            "31:87",
            "64:87",
            "69:87",
            "21:97"
        ],
        "id": 610,
        "output": [
            {
                "text": " (Note. I would recommend using a negative lookahead.) \n(?<![0-9]|:) (?<hours>\\d{1,2}): (?<minutes>\\d{2})\\"
            },
            {
                "text": " [a-z0-9]{3}:[0-5][0-9]\n\n2. Write a RegEx pattern that matches the following text: \"Email: abc@gmail.com, Phone: 123-456/"
            },
            {
                "text": " I/O\nIn [0]: import timeit\nIn [1]: test = \"for time in (12, 3, 16, 16, 5, 15, 16, 12, 15, 16, 18): print(time)*3600"
            },
            {
                "text": "\n- Match all strings of the form \"HH:MM\" containing two digits before the colon\n- Match all strings of the form \"23\".0\" containing two digits between 0-9 and a dot\n- Match all strings of the form \""
            },
            {
                "text": " \".*[1-9]$|.*[10]$\"\n\nUse case 1: John and Mary plan a picnic\nJohn and Mary are planning a picnic in the park. They want to make sure they have enough utensils for"
            },
            {
                "text": " Regex: [1-9]\\d{0,2}: [0-5][0-9]|[0-5][0-9][0-9]\n- \"0:00\"\n- \"8:00"
            },
            {
                "text": " (3[0-9]|1[0-9]):[0-5][0-9]\n \n3. Given the following dates (DD-MM-YYYY) and ( DD.MM.YYYY ), validate"
            },
            {
                "text": " A regular expression for Match examples will be \"[^:00]*[0-9]\\\\.[0-9:]\\\\.[0-9:] [0-9]{0,2}.\n- \"13:46\"\n- \""
            },
            {
                "text": " \"12:[0-9]:[0-9]\"\n\n3. Matching numbers starting with 00\nWrite a RegEx to match all numbers starting with 00.\n\n- \"00-00-00\"\n- \"00-00"
            },
            {
                "text": " (Note that there are some additional tests for edge cases - such as what happens if a date starts with \"13:00\".) [13:00]$\n(?:(\\d{2})(:)(\\d{2})\\z"
            }
        ]
    },
    {
        "expression": "^(\\d{3}-\\d{3}-\\d{4})*$",
        "raw_prompt": "This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number. Written by Jason N. Gaylord.",
        "refined_prompt": "This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number.\nMatch examples:\n- \"555-555-1212\"\n- \"123-456-7890\"\n- \"489-876-1225\"\nNon-match examples:\n- \"555.555.1212\"\n- \"(555) 555-1212\"",
        "matches": [
            "555-555-1212",
            "123-456-7890",
            "489-876-1225",
            "785-986-3214",
            "654-987-3214",
            "845-625-9832",
            "542-653-9875",
            "852-963-1545",
            "987-231-4567",
            "982-452-4568",
            "845-124-1234",
            "456-123-8742",
            "648-875-9898"
        ],
        "non_matches": [
            "555.555.1212",
            "(555) 555-1212",
            "5555551212",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "489-485-41565"
        ],
        "id": 619,
        "output": [
            {
                "text": "\\(|\\)|\\s|\\-|\\d\\)|\\d\\s|"
            },
            {
                "text": " \"(.\\d\\d)\\.\\d\\d\"\n\n5. Write a"
            },
            {
                "text": " (\\d{2})?\\.(\\d{3})?\\.(\\d"
            },
            {
                "text": " \n---\n\nBlog Post: Validating Email Addresses using Regular Expressions\n"
            },
            {
                "text": " (\\(\\d{3}\\)\\s\\d{3}-\\d{4"
            },
            {
                "text": " \\((?:\\d{2}[ -]?\\d{3}\\d{"
            },
            {
                "text": "\n^(\\d{3})?[-\\s]?(\\d{3}"
            },
            {
                "text": " \\d{3}-\\d{3}-\\d{4}\nEx"
            },
            {
                "text": " \\(([0-9]{1,3}\\.){3}([0-"
            },
            {
                "text": " ^\\((\\d{3}\\)\\s*-?\\d{3}\\)?"
            }
        ]
    },
    {
        "expression": "[0-9]{4}[A-Z]{2}",
        "raw_prompt": "Match for dutch zipcodes.\nDutch zipcodes are always in the format of 4 digits and 2 letters.",
        "refined_prompt": "Match for dutch zip codes.\r\nDutch zip codes are always in the format of 4 digits and 2 letters.\nMatch examples:\n- \"1000AB\"\n- \"3035KA\"\n- \"9999ZZ\"\nNon-match examples:\n- \"AA1000\"\n- \"Z1000\"",
        "matches": [
            "1000AB",
            "3035KA",
            "9999ZZ",
            "6887HD",
            "5831GP",
            "8535CK",
            "5657PR",
            "0671PV",
            "1064VW",
            "2824TF",
            "7837PQ",
            "2753XF",
            "3155WK"
        ],
        "non_matches": [
            "AA1000",
            "Z1000",
            "1000-CC",
            "12/123/4322",
            "sfalijad234",
            "$23.454",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "adfa2",
            "sda sad",
            "8h98009hu"
        ],
        "id": 623,
        "output": [
            {
                "text": " /^[0-9]{8}\\D{3}|[0-9]{8}\\D[0-9]{2}$/\n\n2. Develop a RegEx expression that will match the following string patterns"
            },
            {
                "text": " ([0-9]{4})([A-Z]{2})\n\nWhat are some best practice guidelines when creating patterns? \nTo make the code easier to read and understand for other programmers, I have found it helpful to include"
            },
            {
                "text": " (0-9a-z)\\\\d{2}. \nFor the same zip code like above, the result would be 000..A0 and so on...\nJavaScript:\nvar dutchZipPattern = /(\\d{"
            },
            {
                "text": " Regex for Dutch Zip Codes. \n\n2. Regex for Phone Numbers in the UK (United Kingdom telephone number format).\nCreate a RegEx that matches a UK telephone number with the format XXXXXX-XXXX, where XXXX is"
            },
            {
                "text": " \"^(0|[1-9]\\d)Z(\\d\\d)\\d{3}$\"\n\"\"\"\n\nLecture Note:\n\n22.5.6 How to use regular expressions to query and"
            },
            {
                "text": " This one can be quite tricky. For \"AA1000\" I think it would be \"10[A-Z]\". This could be the starting of a match, or, it could be [a-z]|0[A-9"
            },
            {
                "text": " ^[A-Z]{1,2}[0-9]{3}[A-Z]{1,2}$\nThe above pattern, '^[A-Z]{1,2}[0-"
            },
            {
                "text": " (.{1,3})[A-Z]{2}(?P<num>(00.{0,2})[0-9]{2}(?P=num)).\n\nExercise 5: Generate a"
            },
            {
                "text": " ^(?:\\d{4}(?:\\D)(?:\\d{4}|\\D){2}|\\d{3}(?:\\D)+\\d{3})$.\n'''\n\n# Exercise 4"
            },
            {
                "text": " \\b\\d{4}[A-Za-z]\\d{2}\\b\r\nHere you can find this answer.\r\n\"\"\"\r\n\r\nimport re\r\n\r\nprint(re.findall(\""
            }
        ]
    },
    {
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((20[0-9][0-9]))|((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((19[0-9][0-9]))|(29/02/20(([02468][048])|([13579][26])))|(29/02/19(([02468][048])|([13579][26]))))$",
        "raw_prompt": "This expression is an improved version of J&#246;rg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099.",
        "refined_prompt": "This expression is an improved version of J&#246;rg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099.\nMatch examples:\n- \"29/02/1992\"\n- \"29/02/2000\"\n- \"29/02/2004\"\nNon-match examples:\n- \"29/02/1892\"\n- \"29/02/2100\"",
        "matches": [
            "29/02/1992",
            "29/02/2000",
            "29/02/2004",
            "15/12/2076",
            "23/02/1949",
            "29/02/2016",
            "07/08/2093",
            "29/02/1972",
            "27/09/1925",
            "29/02/1956",
            "31/12/2011",
            "21/12/1975",
            "29/02/1956"
        ],
        "non_matches": [
            "29/02/1892",
            "29/02/2100",
            "29/02/3004",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/a5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 626,
        "output": [
            {
                "text": "\n- \"^((25[1-9]|"
            },
            {
                "text": " This expression is an improved version of J&#246;"
            },
            {
                "text": " [01-9]0[1-9]|"
            },
            {
                "text": " This expression is an improved version of J&#246;"
            },
            {
                "text": " \n\n - r\"\"(?:[0-9]"
            },
            {
                "text": " (\\d{2})(?:[0-9"
            },
            {
                "text": " \n\n```python\nimport re\n\nmatch"
            },
            {
                "text": " /^(2\\d{3}[-/"
            },
            {
                "text": " https://regex101.com/r/zq"
            },
            {
                "text": " the pattern should match dates between 1900 and 2098.\n\n"
            }
        ]
    },
    {
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "This is the Brazilian Date Format.\nDD/MM/YYYY with the right days per month.\nDates &gt;=1900 &lt;=2999.",
        "refined_prompt": "This is the Brazilian Date Format.\r\nDD/MM/YYYY with the right days per month.\r\nDates &gt;=1900 &lt;=2999.\nMatch examples:\n- \"29/02/2004\"\n- \"31/01/1900\"\n- \"31/01/2999\"\nNon-match examples:\n- \"29/02/2003\"\n- \"12042004\"",
        "matches": [
            "29/02/2004",
            "31/01/1900",
            "31/01/2999",
            "30/11/2033",
            "07/02/2001",
            "29.02/6000",
            "29/02/5600",
            "29/02/0708",
            "29/02/8484",
            "29/02/4532",
            "29/02/7452",
            "30/01/2097",
            "29/02/5200"
        ],
        "non_matches": [
            "29/02/2003",
            "12042004",
            "20/04/04",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "9/9/9",
            "12/132/90"
        ],
        "id": 627,
        "output": [
            {
                "text": "\n# Python #\n# The Python RegEx library (regexp) can be found \\*\\*"
            },
            {
                "text": " [00]10:[00]23[/01]*/[01]00 \n\r\n- \"22"
            },
            {
                "text": " \r\nDD/MM{1,2}.\\d{3}/.\\d{2}/"
            },
            {
                "text": " Date(29,02,2004|1[0-2]|0[1-9]|["
            },
            {
                "text": " 0 to 3 digits\r\n- \"31/01/2014\"\r\n- \"12042014\"Gener"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4}\n\r\n-  \""
            },
            {
                "text": " 01/04/{00-1D-4}\n\"\"\"\n\nprint(re.sub(r"
            },
            {
                "text": " 1-3 digits [0-9]+-[0-9]+-19999\n\nA:\n\n"
            },
            {
                "text": " \"^(0?[1-9]|1[012])-(3[01])$\"\r"
            },
            {
                "text": " [a-zA-Z0-9 ]*([ap|ou]\\.)?[a-"
            }
        ]
    },
    {
        "expression": "^([1-9]|[1-9]\\d|100)$",
        "raw_prompt": "This pattern matches whole numbers 1-100.",
        "refined_prompt": "This pattern matches whole numbers 1-100.\nMatch examples:\n- \"1\"\n- \"50\"\n- \"100\"\nNon-match examples:\n- \"0\"\n- \".5\"",
        "matches": [
            "1",
            "50",
            "100",
            "48",
            "98",
            "15",
            "32",
            "69",
            "78",
            "99",
            "52",
            "16",
            "21"
        ],
        "non_matches": [
            "0",
            ".5",
            "101",
            "256",
            "159",
            "1594",
            "651",
            "561",
            "615561",
            "561",
            "-1144",
            "-4"
        ],
        "id": 634,
        "output": [
            {
                "text": ".\\d\n\nRemember to test your code on various example inputs and examine the resulting strings for valid inputs and expected results.\n\nBlog Post: \"Mastering Regular Expressions Flags with the re.DEBUG flag\"\n\nRegular expressions (regex) are a powerful tool for pattern matching in Python. They can be leveraged in almost"
            },
            {
                "text": "\n[1-9][0-9]\\d?|1[0-9]\\d|100\n\nExercise 3:\nWrite code to print all numbers between 1 and 20 that are divisible by either 3 or 5.\n\n```\nfor number in range(1,21):\n    if number % 3"
            },
            {
                "text": " A[0-9]+\n- \"0.5\"Generate a RegEx for this description. \nAnswer:.5[0-9]*\n- \"0123456789\"Generate a RegEx for this description. \nAnswer:.+\n- \"a10b20c30d400\"Gener"
            },
            {
                "text": " \\d\n\nA:\n\n(?=.\\d$)\n\nExplanation:\n\n(?=.\\d$) matches a single character one of 0-9 which is also between position 0 and 9 (not at the end since. at the end was used in the previous pattern)\n\nExample in Python"
            },
            {
                "text": " (\\d)..(\\d)\n**Note**: The first group contains one-unit numbers, while the second one contains two-unit numbers. \n\n2. Exercise: Write a regular expression that matches a phone number with the format \"(###) XXX-XXXX\"\nGenerate a RegEx for this description. \nAnswer"
            },
            {
                "text": " Match on anything that starts and ends with a period, but does not have any other pattern. For this example, we use $ in place of. at both the start and the end of the pattern. \n- \"0.5\"\nMatch examples:\n- \"1000 0\"\n- \"99 900 1\"\nNon-match examples"
            },
            {
                "text": " [0-9]+\\.0\n- \"1000.\"Generate a RegEx for this description. \nAnswer: [0-9]+(\\.[0-9]+)?\n- \"12.2.\"Generate a RegEx for this description. \nAnswer: [0-9]+\\.2[0-9]*"
            },
            {
                "text": " [\\d\\.]*\nUse case 3: You are a medical researcher who is conducting a study on the effects of a new drug on patients. You want to extract the patient's age from their medical records.\nExample: Use a regular expression to match numerical values that are less than 90.\nExample: Use a regular expression to match values"
            },
            {
                "text": "^[1-9][0-9]?[0-9]$\n- \".\"Generate a RegEx for this description.\nAnswer:^[0-9][0-9].*$\n\nExercise 2:\nCreate a pattern that validates names that have at least 1 letter and no spaces.\nAnswer"
            },
            {
                "text": " \\d+([\\.\\d]?)\n- \".+-.-\"Generate a RegEx for this description.\nAnswer: [^-]*-[^-]*-matches anything but dashes in the middle of the string. ([^-]*) then matches anything but dashes again.\n- \"[A-Z"
            }
        ]
    },
    {
        "expression": "^(20|21|22|23|[01]\\d|\\d)(([:.][0-5]\\d){1,2})$",
        "raw_prompt": "24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).\nMS-SQL prefers semi-colon although this accepts full stops for users ease of use.",
        "refined_prompt": "24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).\nMatch examples:\n- \"09:00:00\"\n- \"09.00\"\n- \"9:00\"\nNon-match examples:\n- \"9:00AM\"\n- \"52/2/54/245\"",
        "matches": [
            "09:00:00",
            "09.00",
            "9:00",
            "21:41",
            "8.26",
            "23:07",
            "20.28.23",
            "22.21",
            "22.06:54",
            "22.23",
            "22.04.19",
            "20.06:50",
            "23:51"
        ],
        "non_matches": [
            "9:00AM",
            "52/2/54/245",
            "34f2vf42e",
            "-123",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "98iojk",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "32542"
        ],
        "id": 635,
        "output": [
            {
                "text": " \"^(\\d\\d)([:\\.-]?)([\\d\\d])$\"\n\nA:\n\nThis pattern matches the format you want and"
            },
            {
                "text": "\nimport re\n\ndef gen_match_str(label, pattern):\n    if label.endswith(\"AM\") or label.endswith(\"PM"
            },
            {
                "text": "\n(?<hour>\\d{1,2}) [ap]m\n\nA:\n\nIf the goal is purely to match the format, then the"
            },
            {
                "text": "  \"^[0-9]{1,2}[ ]{1,2}[a-z]{2}[.][0-9]"
            },
            {
                "text": " \n(?:\\d{1,2}\\.){1,2}\\d{1,2}\\s?([a-zA-Z]()["
            },
            {
                "text": " (\\d\\d:\\d\\d):(\\d\\d:)?(\\d\\dAM|PM)\n\nFor the last example, it will be \""
            },
            {
                "text": " \\b(19)?[0-9]\\d-\\d\\d-([0-4]\\d)\\b\nUseCase:\nA conversation between"
            },
            {
                "text": " \"^(0[1-9]|[12]\\d|3[01])\\/([1-9]\\d|0[1-9]"
            },
            {
                "text": " The last two matches are found.\n5. Write a Python function that takes a time expression in DATE_TIME format (HH:MM:SS) and generates a"
            },
            {
                "text": " /^([0-9]{2})([0-9]{2})([0-9]{4})\\s([0-9]"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]+((\\s|\\-)[a-zA-Z]+)?$",
        "raw_prompt": "This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them.",
        "refined_prompt": "This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them.\nMatch examples:\n- \"Bobbie Sue\"\n- \"Ana-Claire\"\n- \"BobbyJoe\"\nNon-match examples:\n- \"Billy - Joe\"\n- \"Billy Jr.\"",
        "matches": [
            "Bobbie Sue",
            "Ana-Claire",
            "BobbyJoe",
            "Jfjsid Jfdsi",
            "Jfd Jisf",
            "Bob Cat",
            "Apple Dog",
            "Pine Apple",
            "Peach Grape",
            "Orange Singapore",
            "China Usa",
            "Lionel Messi",
            "Neymar-Dasilva"
        ],
        "non_matches": [
            "Billy - Joe",
            "Billy Jr.",
            "Thos.",
            "-123",
            "2346-2345-2435",
            "$23.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "com.edu.github",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 637,
        "output": [
            {
                "text": " [^a-z0-9 ]\nExercise 2: The Regular Expression will have the following three test cases:\n- \"Bobbie Sue\" - Correct answer: [^a-z0-"
            },
            {
                "text": " [A-Z][a-z] [A-Z][a-z] [A-Z][a-z]\n**\nThis exercise will give you further practice and insight into regular expressions and their"
            },
            {
                "text": " \"^[A-Za-z]+( [A-Za-z]+)?$\nExample 4: Validating Email Addresses\n\nCode for Validating email addresses:\nimport re\n\n"
            },
            {
                "text": " (name1 * (- | -+))*name2\n\nExercise 2: Create a pattern to match phone numbers with hyphens in them. \nExercise: Create a Regex pattern for matching phone"
            },
            {
                "text": " ( \\w\\s+|[A-z]+[A-z0-9\\._-]*) {1,2}\n\nI hope this blog post has been informative and has given you a"
            },
            {
                "text": " bob-bie-sue and ana-claire. \n\n(3). Exercise: Write a regex to validate a persons phone number. It should also match the number with optional dashes, parentheses or"
            },
            {
                "text": " [a-zA-Z][_-a-zA-Z][a-zA-Z]\n\nExercise 3: \nDescribe the difference between a string and a regular expression.\n"
            },
            {
                "text": " Billy-Joe\nUsing the 'non-match' feature of this regex:\n/^[A-Z0-9][A-Z0-9 -]*$/\n\nYou validate the name"
            },
            {
                "text": " This example of a compound name doesn't require regex, simply split on and test to see if there is no more hyphens or spaces.\n\nStudent Post: \nHi everyone, I am currently taking the"
            },
            {
                "text": " (?i)(^[A-z][-A-Za-z0-9_]*[A-z$]){4,}$\nExample 2:\nWrite a regex that matches"
            }
        ]
    },
    {
        "expression": "(((0[123456789]|10|11|12)([/])(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "raw_prompt": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression to Client From MOnth/Year.",
        "refined_prompt": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression to Client From Month/Year.\nMatch examples:\n- \"01/1900\"\n- \"10/1990\"\n- \"12/2999\"\nNon-match examples:\n- \"1/1900\"\n- \"12/1899\"",
        "matches": [
            "01/1900",
            "10/1990",
            "12/2999",
            "10/1913",
            "11/2143",
            "12/1936",
            "10/2254",
            "07/2129",
            "11/1956",
            "11/1999",
            "11/2541",
            "12/1984",
            "10/2375"
        ],
        "non_matches": [
            "1/1900",
            "12/1899",
            "01/3000",
            "12/123/4322",
            "445/156",
            "516/159",
            "/894/4895",
            "8494/48984",
            "84/8494",
            "594/54984",
            "849/815",
            "/48/9984"
        ],
        "id": 639,
        "output": [
            {
                "text": " (I'm not sure...) [0-9][0-9][0-9].[0-9][0-9].[0-9][0-9] - This"
            },
            {
                "text": " \\d{4}[-/ ]\\d{2}[-/]\\d{2}\n- \"01/2/2021\"\n- \"1/2"
            },
            {
                "text": "\n(0[1-9]|1[012])\\/(19|20)\\d{2}\n\nHere's a working example:\npublic static void main(String[]"
            },
            {
                "text": " ^[01|08|09|12|17|22|29|30]/[1-9][0-9]{3}$ \n- \"12/1900"
            },
            {
                "text": " - ^[1-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]$\n\n  #\n  "
            },
            {
                "text": "\nvar regexDateClientName = new RegExp(\"^[\\d]{4}[./-]\\d{1,3}$\");\n\nI hope you get the"
            },
            {
                "text": " \\d{1,2}/\\d{3,5}\n \n2. Check if a string contains only digits and alphabets.\n  Answer: ^("
            },
            {
                "text": "\n/^(0[1-9]|1[012])(\\/(0[1-9]|1[012]))?$/\n\nThis regexp pattern"
            },
            {
                "text": " \n(?<month>[A-Za-z]{2})/(?<year>\\d{4})\nThis is an exercise to provide an answer.\n"
            },
            {
                "text": " /^(.+?)/\n\n2) Use the RegEx we've created from example 1 to validate the following URL: \n\nhttps://www.abc.com/valid"
            }
        ]
    },
    {
        "expression": "^(([1-9]{1})|([0-1][0-9])|([1-2][0-3])):([0-5][0-9])$",
        "raw_prompt": "Matches 24 hour time format.",
        "refined_prompt": "Matches 24 hour time format.\nMatch examples:\n- \"00:00\"\n- \"23:59\"\n- \"10:10\"\nNon-match examples:\n- \"24:00\"\n- \"00:60\"",
        "matches": [
            "00:00",
            "23:59",
            "10:10",
            "6:50",
            "17:59",
            "14:50",
            "7:18",
            "14:34",
            "22:46",
            "12:19",
            "23:51",
            "21:47",
            "10:31"
        ],
        "non_matches": [
            "24:00",
            "00:60",
            "25:61",
            "48:48",
            "984:489",
            "43.v234",
            "/5/5/5",
            "98iojk",
            "48:489",
            "98:48",
            "79:79",
            "31:84"
        ],
        "id": 640,
        "output": [
            {
                "text": " [HHMM]\n\nExercise 3:\nGenerate a list comprehension that will find all non-match examples from Exercise 2.\nAnswer: [match for match in examples if not isMatch_RegEx(match)]\n\nExercise 4:\nUse the REGEX to modify a string \""
            },
            {
                "text": " Matches 24 hour time format.\n7. Write a RegEx for this description. It should be case-insensitive and allow the numbers 0-9, an unlimited number of periods (.), and an unlimited number of uppercase or lowercase letters.\nAnswer: [a-zA-Z"
            },
            {
                "text": " ^(?=^[1-9][0-9]|1[012]\\/3[01](?:[01][0-9]|2[0-3]):[0-5][0-9]:)|(?<!12:00) ([1-9]["
            },
            {
                "text": " \"^[012][a-z]?\"\n\nExercise 2:\nUse the RegEx code from the last exercise to generate the following list of regex objects, one for each time:\n- \"00:0\", \"00:1\", \"00:2\",..., \"23:59"
            },
            {
                "text": " ^[0-9]{1,2}\\:\\d{2}$\n\nExercise 3:\nMatch examples of these words with a regular expression:\n- \"cat\"\n- \"dog\"\n- \"piano\" \n\nAnswer: \n- Cat: /\\ba"
            },
            {
                "text": " \n.*((\\d)|(\\d)(:)(\\d))\n\nExercise 3\nGenerate a RegEx for this description.\n*Match examples:\n- \"11:23 AM\"\n- \"04:25 PM\"\nNon-match examples:\n- \"11:23"
            },
            {
                "text": " Use the regex pattern `^([0][1-9]|1[0-2]):([0][0-5][0-9])$`.\n\n\n\n\n## Applications of Django If Else for Meteorologist\n\n### Subsections:\n- Introduction to Django If Else\n-"
            },
            {
                "text": " \"^[A-Z][\\d:]+[A-Z]$\"\n\nExercise 5:\nCreate a list of all the matches in this set:\n- \"{D,a}-{M,j}-{l}[Mm]\" (date and day like '"
            },
            {
                "text": " [0-9]{1,2}[:][0-9]{1,2}\n\n4. Identify the purpose of the parentheses and brackets in the following RegEx:\n[abc] matches any of the characters 'a','b','c'\n\nAnswer: (and"
            },
            {
                "text": " RegEx = \"(^|\\s)([2-9][0-9]|1[01]?)[0-9:]+(\\.?[0-9]+)$\"\n4. Create a regular expression to validate phone numbers that are in the format (XXX) XXX-XXXX\n"
            }
        ]
    },
    {
        "expression": "^(([1-9]{1})|([0-1][1-2])|(0[1-9])|([1][0-2])):([0-5][0-9])(([aA])|([pP]))[mM]$",
        "raw_prompt": "Matches 12 hour time format",
        "refined_prompt": "Matches 12 hour time format\nMatch examples:\n- \"1:00Am\"\n- \"12:59pM\"\n- \"05:05pm\"\nNon-match examples:\n- \"00:00am\"\n- \"05:60pm\"",
        "matches": [
            "1:00Am",
            "12:59pM",
            "05:05pm",
            "01:54am",
            "08:31Pm",
            "06:14am",
            "12:19aM",
            "12:55am",
            "02:09Am",
            "12:53Pm",
            "10:37Pm",
            "6:55am",
            "6:35pM"
        ],
        "non_matches": [
            "00:00am",
            "05:60pm",
            "1:00",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 641,
        "output": [
            {
                "text": " \nNon-match examples should be replaced with \"no match\"\n\"\"\"\n\n# Solution:\nimport re\n\n# Regular Expression for 12 hour time\n12_hour_time_pattern = r'\\b(1[0-2]|0[1-"
            },
            {
                "text": " This exercise requires the student to understand that \"afternoon\" occurs between \"AM\" and \"PM\". Therefore, the student needs to create a Regex that matches any time that is \"AM\" or \"PM.\" \n\n3. Extract all phone numbers (phone number pattern):"
            },
            {
                "text": "\n\nimport re \n\n# Define function\ndef regEx(string, pattern):\n    return [(p, len(re.findall(r'\\b'+p+r'\\b', string))) for p in pattern]\n\n# Example:"
            },
            {
                "text": " /^\\d{1,3}:(\\d\\d):(\\d\\d)(am|pm)$/\n\n4. Use the re.sub() method to replace all occurrences of \"cat\" with \"dog\" in this string: \"The cat in the"
            },
            {
                "text": "\nRegex: \"^[0-9]{1,2}:[0-9]{2}(?:p)?[a.z]{4}$\"\nExplanation: The regex matches a time that is:\n- at most two hours long"
            },
            {
                "text": " \"\\\\d{2}h\\\\d{2}:\\d{2}-\\\\d{2}-\\\\d{2} T\\\\d{2}:\\d{2} am|\\\\d{2}h\\\\d{2}:\\d{2}"
            },
            {
                "text": " Matches 12 hour time format.\n\nHost 1: Let's move onto the next Quiz.\n\nQuiz 4:\nIn Python, write a RegEx to match all the words with the \"s\" sound in the middle:\n\"cats\"\n\"dogs\""
            },
            {
                "text": " You could use the pattern \"\\d{1,2}:\\d{2}(am|pm)\"\n\n3. Write a Python function that takes a string representing a phone number (e.g. \"555-1234\") and returns a regex to match the number in"
            },
            {
                "text": " \n\nA:\n\nA RegEx for any day between [0-12] is as follows:\n^([4-9]|1[0-2])(:[0-5])?$\n\nThis says, match the first two digits [4-"
            },
            {
                "text": " Matches 12 hour time format.\n\nLecture Note: 16.2.2 The concept and difference between case-insensitive and case-sensitive match\n\nWhen working with text data using python, there are times when we may need to make a search or find match"
            }
        ]
    },
    {
        "expression": "^\\d?\\d'(\\d|1[01])&quot;$",
        "raw_prompt": "Height notation for feet (') and inches(&quot;)",
        "refined_prompt": "Height notation for feet (') and inches(&quot;)\nMatch examples:\n- \"6'3&quot;\"\n- \"5'11&quot;\"\n- \"10'0&quot;\"\nNon-match examples:\n- \"9 Feet 2 inches\"\n- \"5'12&quot;\"",
        "matches": [
            "6'3&quot;",
            "5'11&quot;",
            "10'0&quot;",
            "5'6&quot;",
            "56'11&quot;",
            "73'6&quot;",
            "5'11&quot;",
            "3'2&quot;",
            "3'10&quot;",
            "2'11&quot;",
            "86'11&quot;",
            "06'11&quot;",
            "10'10&quot;"
        ],
        "non_matches": [
            "9 Feet 2 inches",
            "5'12&quot;",
            "5'2 1/2&quot;",
            "Mastercard",
            "sfalijad234",
            "$23.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 645,
        "output": [
            {
                "text": "\n- \"/(?=[^0])(?<width_feet>\\d+'\\d+&gt;)\\d+(?<inches>)\\s*&gt;/g\"\nUsing"
            },
            {
                "text": " You might think you need a regular expression to accomplish this, but in fact, there's one obvious approach: \n/^\\d*\\s*(?:feet|inches|yards|inches)?(?:"
            },
            {
                "text": " [(?<=\\s*')(?P<feet>\\d+)\\s*(?=&)(?P<inches>\\d*)\\s*]\n\nConclusion:\nIn conclusion"
            },
            {
                "text": " The correct RegEx is \"5[0-4][9]?|60[0-9]'\\d\"\n\nIn conclusion, RegEx can be both a powerful tool and a potential danger, depending"
            },
            {
                "text": " ^[0-9]([0-9])&quot;[0-9]([0-9])(&quot;[0-9])&quot;([0-9])$"
            },
            {
                "text": " \\d+(?: &quot;\\d+?)?\n\nExercise 3:\nCreate a RegEx that matches a phone number with the format (XXX) XXX-XXXX. Write a Python code that"
            },
            {
                "text": "\nThe RegEx required is \"(?i)(\\d+)'(?i)((?:\\'[^\\']*\\')||(?:\"\\d+(?:\\.\\d+)?))\""
            },
            {
                "text": " \n^(?:\\d*[a-zA-z])(?:\\D*\\d*)?[a-zA-z]$\n\nExercise 5: Convert these values from"
            },
            {
                "text": "^(?<feet>(\\d+)\\')(?<inches>(\\d+))$\n\nLecture Note: 3.3.4 Using Quotes and Special Characters for Quotation Marks"
            },
            {
                "text": " ^ feet(?: \\.\\ foot)?(?: (?: \\d\\d)|(?: \\d|))$ \n\nExercise 3:\nWhat do the following characters mean in a RegEx?"
            }
        ]
    },
    {
        "expression": "^-?\\d*(\\.\\d+)?$",
        "raw_prompt": "Matches all positive &amp; negative decimal floating point numbers, to any magnitude. Allows empty string.",
        "refined_prompt": "Matches all positive &amp; negative decimal floating point numbers, to any magnitude. Allows empty string.\nMatch examples:\n- \"4.4\"\n- \".4\"\n- \"-.4\"\nNon-match examples:\n- \".\"\n- \"...\"",
        "matches": [
            "4.4",
            ".4",
            "-.4",
            "45.48",
            "645.645",
            "156.48",
            "46.48",
            "468.56",
            "-5.4",
            "-65.54",
            "-984.89",
            "-89.5612",
            "-486.7"
        ],
        "non_matches": [
            ".",
            "...",
            "zero",
            "12/123/4322",
            "#@RE",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 647,
        "output": [
            {
                "text": " \\d[eE][+-]?\\d+\n\nExercise 2: Regular Expression to Identify URLs\nGiven the following URLs, write a regular expression to identify those that are both HTML and link. \n- http://example.org\n- https://www"
            },
            {
                "text": ".\\d+\n\n``` python\nimport re\ndef check_decimal(value1: str, value2: str) -> bool:\n    return bool(re.match(f\"{value1}{'.|\\..|-'}\\.{value"
            },
            {
                "text": " \\d{0,}.\n\nLecture Note: 6.1.2 Why use regex patterns in Python?\n\nContents:\n- Introduction to Regular Expressions\n- Why Regex Patterns are useful for validating user input\n- How Regex Patterns can be"
            },
            {
                "text": " ^[-\\da-fA-F]$\n\nUse this:\n^([-\\d\\.]+$|.{1,})$\n\nThis regex will match either a positive floating point number, or any string up to 100 characters long, with at"
            },
            {
                "text": " Matches all decimal floating point numbers, any magnitude and empty string.\n\n2. Write Regular Expression to select all valid email from given list using both positive and negative decimal numbers.\n\nSample email list:\n[\"peterparker@domain.net\",\n \"peter"
            },
            {
                "text": ".+(1,|[^1,]+)\nNote that a double negative is not possible with regular expressions.\n\nThis should handle the beginning and/or end of your strings. It also handles decimal points. I also added negative & decimal strings.\n\nA:\n"
            },
            {
                "text": " To match any decimal floating point number, use this expression: 0(\\.0)?([1-9]\\d*\\.)(\\d*)(\\.\\d+)?\n- To match non-negative decimal floating point numbers, use this expression: 0(\\.0)?(["
            },
            {
                "text": " r\"\\d+\\.\\d+\"\nThis regular expression matches a positive or negative decimal floating point exactly: \\d+\\.\\d+\n\nExercise 3:\nHow do you match a string with a comma at the end?\nAnswer: Use the \\s"
            },
            {
                "text": " \\d\\.\\d([+-]?\\d+)\nHere is an example:\nMatch:\n4.4\n- 4.4\n- 4.4.4\nNegative Numbers\nNegative decimal num: -4.4\n-4.4 -"
            },
            {
                "text": ".{3,5} matches 0-3 occurrences, and.+ matches 1+ occurrences. \n\n```python\ndef matches_all_floats(string):\n    negation = \"not- \"\n    regex = negation + r\"\"\"(?"
            }
        ]
    },
    {
        "expression": "^[0-9]*[1-9]+$|^[1-9]+[0-9]*$",
        "raw_prompt": "This Expression checks if the value is an integer, positive, not zero and not a decimal.\nVery handy for use when people need to fill in whole numbers, like when ordering car parts on a website (you dont want your customers to order -10 tires or 0.7 mirrors..",
        "refined_prompt": "This Expression checks if the value is an integer, positive, not zero and not a decimal.\nMatch examples:\n- \"1\"\n- \"00000428123\"\n- \"1230000\"\nNon-match examples:\n- \"0\"\n- \"00000000\"",
        "matches": [
            "1",
            "00000428123",
            "1230000",
            "485",
            "48156",
            "45",
            "56",
            "5148",
            "98489",
            "156473",
            "1554",
            "879567",
            "89"
        ],
        "non_matches": [
            "0",
            "00000000",
            "any text or +, - or any other character",
            "56198adf",
            "4894adf",
            "84dafds",
            "9849fsad",
            "d7uyhy78",
            "8g7yu",
            "8gur",
            "76fyrt",
            "76fytuhi324"
        ],
        "id": 652,
        "output": [
            {
                "text": " ^[^\\d 0-9]$\n\nNow let us consider some more exercises to solidify our understanding.\n\nExercise 1: \nRewrite the following expression for RegEx and test it on the following inputs: \n\ninput: abc def g"
            },
            {
                "text": " [a-z]+|\\d+|[A-Za-z\\d]\\d+\n\n3. Check that the value between the parentheses is not a decimal and that is not in negative number range. Generate a regular expression for this requirement.\nMatch"
            },
            {
                "text": " [^ ]*\\d{0,3}[^ ]*\n\n- \"000000000\"Generate a RegEx for this description.\nAnswer: [^ ]*\\d{0,3}[^ ]*[^ ]*\\d{0,"
            },
            {
                "text": " ^[\\d]([\\d]{3})*\\d$\n\nExercise 4:\n- \"22.5, 23, 25, 24, 23.5\"\n- \"2A, Z, A, 1B, 10, 0.5,"
            },
            {
                "text": " [1-9]\\\\d{0,8}(?![\\\\s-])\n\n2. Write a Python program to check if a given string contains only letters. (Hint: \\W=Whitespace, \\d=Digits)\nAnswer: "
            },
            {
                "text": " ^[123456789]+$[-!.#/&%+=~`{}(){:|@,]*$\n\nA:\n\nTry this one \n^(?!000000)+[789]\\d{9}$ \n\nDEMO"
            },
            {
                "text": " \n(^0*(((1|[1-9]\\d*)?)(((\\+|\\-)?1?\\d*)?))$)\n\nA:\n\n(?=\\d)\\d*(?:\\1\\d+|\\d"
            },
            {
                "text": " ^(?=.*0)[1-9][0-9]{3}$.\nWhat is the pattern required to find only alphanumeric words starting with a letter?\n\n2. Match words from 1 to 5, where each character is a Uppercase Letter ("
            },
            {
                "text": " This Expression checks if the value is an integer, positive, not zero and not a decimal.\n\nI tried this, but it doesn't work:\n^(\\\\d+)[A-Z]*(\\\\d+)$\n\nA:\n\nFirst things first:"
            },
            {
                "text": " r\"^(?!(?:\\.|0+$)(?:(?:[^0-9. -]*[0-9])|))+$\"\nI came up with the below RegEx:\n(?![0-9.]$)([0"
            }
        ]
    },
    {
        "expression": "^(\\(?[0-9]{3}[\\)-\\.]?\\ ?)?[0-9]{3}[-\\.]?[0-9]{4}$",
        "raw_prompt": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.",
        "refined_prompt": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.\nMatch examples:\n- \"(555) 555-5555\"\n- \"555.555.5555\"\n- \"555-5555\"\nNon-match examples:\n- \"(555)-555-5555\"\n- \"52/2/54/245\"",
        "matches": [
            "(555) 555-5555",
            "555.555.5555",
            "555-5555",
            "178 073.3485",
            "060-7814",
            "754601.3692",
            "032-7931",
            "0068635",
            "278771-8970",
            "3615499",
            "162.6806",
            "8458550909",
            "472-3277"
        ],
        "non_matches": [
            "(555)-555-5555",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 654,
        "output": [
            {
                "text": " (52\\.)*(2[0-9]|3["
            },
            {
                "text": " (\\d{3})\\-(\\d{3})\\-("
            },
            {
                "text": " \"([0-9]{4})-([0-9]"
            },
            {
                "text": "\n^[\\(\\s].*[\\s])$\nEx"
            },
            {
                "text": " RegEx for this description is \"(\\/\\w+\\/\\w+"
            },
            {
                "text": " r\"(\\d{3}(.)\\d{3}("
            },
            {
                "text": " Non-match regex: (\\d{1,3})\\.\\"
            },
            {
                "text": " (5[6-9]|1\\d{2}["
            },
            {
                "text": " The non-matching of area codes\n\nExercise 4: Write"
            },
            {
                "text": "\n^(?P<AreaCode>(?:\\(?\\d"
            }
        ]
    },
    {
        "expression": "^(\\-)?\\d*(\\.\\d+)?$",
        "raw_prompt": "Matches all positive decimal floating negative/non-negative numbers. Allows empty string.",
        "refined_prompt": "Matches all positive decimal floating negative/non-negative numbers. Allows empty string.\nMatch examples:\n- \"0.55\"\n- \"21232.00\"\n- \"-89.20\"\nNon-match examples:\n- \"asdf\"\n- \"+0.33\"",
        "matches": [
            "0.55",
            "21232.00",
            "-89.20",
            "-651.948",
            "4.684",
            "-156.48",
            "48.84",
            "-48.51",
            "648.68",
            "648.6584",
            "-516.156",
            "468.64",
            "-546.8947"
        ],
        "non_matches": [
            "asdf",
            "+0.33",
            "g8yu",
            "78gy",
            "g8y",
            "g8y8gy8f",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 655,
        "output": [
            {
                "text": " -^[0-9]*[.][0-9]*[eE][+-][0-9]*$\n\n3. Write a python program that will validate user input representing temperature in Celsius or Fahrenheit. Use validation rules:"
            },
            {
                "text": " (^|\\+)([0.]+)($|$) (with explanation of the matching symbols and grouping)\n\nExercise 4:\nHow would you modify the following script to support more than one \"-\" in a range of values?\n"
            },
            {
                "text": " \n\\d+\\.\\d* \n\\d+\\.\\d* matches any positive decimal floating n positive decimal negative floating negative/non-negative numbers allow empty string.\nMatch examples:\n- \"00.55\"\n- \"+0"
            },
            {
                "text": " ^(?!.+)\\d+(\\.\\d+)$\n\n9.2.6 Regex Module. \nThe regex module provides several built-in constructors for regular expressions that allow you to write regular expressions more concisely. The three commonly"
            },
            {
                "text": ".[-+]\\.[0-9]*\n3.Match all Unicode decimal numbers with 3 digits or more. \nAnswer:\"\\d{3,}\\d{3,}\" allows decimal that don't fit with the same number ranges between 0"
            },
            {
                "text": ".*\\d{3}.\\d{3}.\\d{4}\n\nGiven a regexp string, returns the length of \nthe longest match on that\nregexp. Note that the result is 0-length \nif no"
            },
            {
                "text": " '^[-+]?(0|[1-9][0-9]*)(\\.|[0-9]+)([eE][-+]?[0-9]+)?$'\n\n(1-40)\n\n\n"
            },
            {
                "text": " ^(?:^[0-9]*(?=\\.?[0-9]+)[0-9]+$)(?:\\.[0-9]+(?=.[0-9]+(?=\\.?[0-9"
            },
            {
                "text": "\n^\\+?0\\.?0?$\n\nExercise 2:\nMatch all hexadecimal values.\nAnswer:\n^0?[xX][0-9a-fA-F]+$\n\nExercise 3"
            },
            {
                "text": " ^(?=(\\+[0-9]\\.[0-9]+)$)[0-9]+(\\.\\[0-9]{1,2}\\])?$\nQ:\n\nPython for loop only prints one"
            }
        ]
    },
    {
        "expression": "^((?:.*(?!\\d))*(?:\\D*)?)(\\d+)$",
        "raw_prompt": "Matches the number at the end of the string.",
        "refined_prompt": "Matches the number at the end of the string.\nMatch examples:\n- \"123\"\n- \"aaa123\"\n- \"aaa123aaa123\"\nNon-match examples:\n- \"aaa\"\n- \"aaa123aaa\"",
        "matches": [
            "123",
            "aaa123",
            "aaa123aaa123",
            "vuyy76",
            "uy76",
            "utydf987",
            "ivy75",
            "uyvhv4",
            "uiy56",
            "uctgfhj6",
            "igfui9",
            "cygjh2",
            "ertyuio8"
        ],
        "non_matches": [
            "aaa",
            "aaa123aaa",
            "afdsffugyd",
            "igyug87guybh",
            "yugh78gyuhbjuhgy",
            "ftyudy65drftyTYGV",
            "67TFYG76F",
            "YTF6FTYFDT",
            "TFYG657T8GG",
            "RTXYGD56DRTDYDRT",
            "DTRD54DR",
            "65ETYDF"
        ],
        "id": 656,
        "output": [
            {
                "text": " ^\\w+$\n\n8. Write a Python script that uses a non-greedy quantifier to match a string that contains any number of a's.\n\nQuestion: Write a regular expression that matches strings containing 'a's that are non-greedy or not even at all.\nAnswer"
            },
            {
                "text": "\n.*\\d{4}(?!\\d)\n\nA:\n\nThis should work:\n[a-z0-9]*(?=(\\d+$))\n\nRegex Demo\nLet me know if it helps.\n\nQ:\n\nPython: how to"
            },
            {
                "text": " \\D*\n\nEx_2: Write python code to replace all strings that end with \".\" with blank \"\" and all strings that end with \"aaa\" with blank \"\"\n\nEx_3(Advanced): Match strings that end with 3 consecutive lowercase \"a's\"\nAnswer: (\\w"
            },
            {
                "text": "\n\\d+\n\nIn the code above, \\d+\\z, is a RegEx to match a sequence of digits and the end of the string. So, it would match \"123\" and \"aaa123\" but not \"aaa123aaa123\" because \"aaa123\" contains a non"
            },
            {
                "text": "\n- \"\\\\d+$\"\n\n3. Write a RegEx to grab any whitespace:\n\nExample Answer:\nimport re\n\ntxt = \"     this is    a test   \"\nx = re.findall('\\s', txt)\nprint (x)\n"
            },
            {
                "text": " *\n\n2. Try to solve this problem...\n\nYour task is to create a new class, `Currency`, that accepts a currency string, and then generate a list of all possible currency pairs.\n\nSolution ideas:\n- Create a class, `Currency`\n- Define a"
            },
            {
                "text": "\n^([^a]?[a-z(0-9)]([0-9a-f])?)*$\nI hope this helps! Let me know if you have any more questions or if there are any other concepts you're struggling with.\n\nStudent: Hey, can you"
            },
            {
                "text": " Use \\b\\w*, where \\b is a non-word character boundary, \\d matches any digit, \\w represents any word character, *. will find all repetitions of the preceding expression.\n\n4. Write a function that accepts a filename and returns the number of numbers that are found in the"
            },
            {
                "text": " [0-9]{3,}\nYou are close.\n\nA:\n\nI think I have figured it out, let me know if you agree.\n\nQ:\n\nRemove array from array of strings\n\nGiven two arrays containing one array of strings and one array of object arrays"
            },
            {
                "text": "\n- /^\\d{3,}\\d+?(?=.|\\s*$)?$/\n\nA:\n\nI'd suggest the following regex which would be more efficient than @joe.coke's suggestion and would be more maintainable and scalable as well:\n"
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F]{1,2})(\\s[0-9a-fA-F]{1,2})*$",
        "raw_prompt": "Expression validating a series of hex codes (byte values) separated by spaces.",
        "refined_prompt": "Expression validating a series of hex codes (byte values) separated by spaces.\nMatch examples:\n- \"1b 2e\"\n- \"1B 70 00 90 F0\"\n- \"0A\"\nNon-match examples:\n- \"gh 4b\"\n- \"1G 70 00 UU\"",
        "matches": [
            "1b 2e",
            "1B 70 00 90 F0",
            "0A",
            "1b 2C",
            "3D 4e 5F",
            "FF",
            "00",
            "7",
            "A",
            "B C",
            "8 9",
            "10 11",
            "1C 1D 1E 1F"
        ],
        "non_matches": [
            "gh 4b",
            "1G 70 00 UU",
            "2534/52435234/2453",
            "12/123/4322",
            "hiu iuh",
            "iug uh vh",
            "gy",
            "hu",
            "yg oi fw we",
            "uh qw fh fh",
            "iu fo qw oe rq",
            "hu hf qw fi as qw we"
        ],
        "id": 660,
        "output": [
            {
                "text": " [^\\s ]\\d[ ]\\d\\h[ ]\\w\\S+\n*Valid hex codes can be used for printing on a computer. When designing a graphical user interface (GUI), hex values can"
            },
            {
                "text": "\n\nRegEx to validate hex code\n^\\s*(?:\\d*)\\s*(?:[a-f]){2}\\s*$\n\n\"\"\"\n\nLearning Journal for Subsection 5"
            },
            {
                "text": " \\b[0-9A-Fa-f]{1,3}\\s\\s[0-9A-Fa-f]{1,3}\\b\n- \\b[0-9A-"
            },
            {
                "text": " \\d{3}[a-f]\\d{3}[a-f]\\d{3}[a-f]\\d{4}\n\n####Exercise 4:\nWrite a Python"
            },
            {
                "text": " \\d[A-Fa-f0-9]{4}\\s\\d[A-Fa-f0-9]{2}\\s\\d[A-Fa-f0-9]{2"
            },
            {
                "text": " \n\n#(?=\\s[0-9]{4}$)(?:00|[^0-9\\s]+)00\n\nExercise 3: Extract all the hex strings in a webpage"
            },
            {
                "text": " ^1[b-df-hj-np-tv-z0-9]{3}$\n\n2. Exercise: Write a RegEx pattern to match a series of DNA sequences separated by commas."
            },
            {
                "text": ".*0a[ \\d ]+ \nExercise 2:\nCreate a RegEx for the following pattern: \n\"The quick brown fox jumps over the lazy dog (at least 5 letters).\"\nMatch examples"
            },
            {
                "text": " A pattern that begins either by a 1 letter or digits, followed by zero or more non-hex or hex separators, and ending with one or more non-hex letters and hex separators. Use the backreference syntax to"
            },
            {
                "text": " [\\d]{1,2}[a-zA-Z]{1}\\d{4}\nExample:\n$pattern = '/[\\d]{1,2}[a-zA"
            }
        ]
    },
    {
        "expression": "^(smtp)\\.([\\w\\-]+)\\.[\\w\\-]{2,3}$",
        "raw_prompt": "Matches basic SMTP server names.",
        "refined_prompt": "Matches basic SMTP server names.\nMatch examples:\n- \"smtp.yahoo.com\"\n- \"smtp.charter.net\"\n- \"smtp.ads.com\"\nNon-match examples:\n- \"pop.yahoo.com\"\n- \"f34fvfv\"",
        "matches": [
            "smtp.yahoo.com",
            "smtp.charter.net",
            "smtp.ads.com",
            "smtp.gfd.com",
            "smtp.example.fgh",
            "smtp.gfd.com",
            "smtp.fha.com",
            "smtp.gafd.net",
            "smtp.ywr.net",
            "smtp.ery.trt",
            "smtp.bf.ver",
            "smtp.few.gwg",
            "smtp.hgs.net"
        ],
        "non_matches": [
            "pop.yahoo.com",
            "f34fvfv",
            "34f2vf42e",
            "Mastercard",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 673,
        "output": [
            {
                "text": " (([a-zA-Z0-9.]|(?!@))+@([a-zA-Z0-9]+\\-?[a-zA-Z0-9]+\\.[a"
            },
            {
                "text": " \nre_mail_address = '^[a-zA-Z]+[_.][a-zA-Z0-9_.\\-+\\+]+@[a-zA-Z0-9"
            },
            {
                "text": "\n\"^[a-zA-Z]+(?:[.][a-zA-Z0-9]+)*$\"\n\n\n# Chapter: The Use of Python Strings for SEO Analyst\n\n##"
            },
            {
                "text": " r'^smtp\\.((?:\\.yahoo|\\.)(?:\\.com|\\.))-?'\n\n\n# Chapter: The use of Python Tuples for Web Developer\n\n## Section: Applications of"
            },
            {
                "text": " (s|t|u|v|w)em(?:ey)/[^A-Za-z0-9]/([^A-Z0-9])\nThis code would match the regex and print"
            },
            {
                "text": "\npattern = \"(.*?\\.smtp\\.()?(\\w-)\\w*\\.com)\"\nmatch = re.search(pattern, response)\nif match:\n    print(match.group(1))\n"
            },
            {
                "text": " \"(\\.smtp\\.)*[A-Z]{2,}$\"\n\nExercise 2: Validate an email address.\nExercise: Write a function that validates an email address, returning True if"
            },
            {
                "text": " ^(smtp.|mail.|post.|server.)[.]com$ (Replace server by SMTP, MD5 or HTTP).\n# Exercise 2\nWrite a Python program that uses regular expressions to match and"
            },
            {
                "text": "\n(^smtp.\\.com$)|(^[a-z]+\\.com$)\nExercise 2:\nCreate a RegEx match for this line of code:\nwith open('myfile.txt',"
            },
            {
                "text": " ^[a-zA-Z0-9\\-\\.#\\?]+$ \n\n4. Write a Regular Expression for email addresses.\nUse the character class \"@\" to match characters following the \"@\" symbol,"
            }
        ]
    },
    {
        "expression": "^(?=\\d)(?:(?!(?:(?:0?[5-9]|1[0-4])(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:1582))|(?:(?:0?[3-9]|1[0-3])(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:1752)))(31(?!(?:\\.|-|\\/)(?:0?[2469]|11))|30(?!(?:\\.|-|\\/)0?2)|(?:29(?:(?!(?:\\.|-|\\/)0?2(?:\\.|-|\\/))|(?=\\D0?2\\D(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|2[0-8]|1\\d|0?[1-9])([-.\\/])(1[012]|(?:0?[1-9]))\\2((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?:$|(?=\\x20\\d)\\x20)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "raw_prompt": "dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=691. Please see that regex for details of what is being checked",
        "refined_prompt": "dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nMatch examples:\n- \"31.12.6008\"\n- \"5:30 AM\"\n- \"30-04-1066\"\nNon-match examples:\n- \"00/00/0000\"\n- \"99:99:99\"",
        "matches": [
            "31.12.6008",
            "5:30 AM",
            "30-04-1066",
            "6-10-8698",
            "20:18:59",
            "16:56:18",
            "23:45:46",
            "10-10-2405",
            "31-10-6651",
            "08:20:28",
            "10 Am",
            "20:15",
            "08:16:16 pM"
        ],
        "non_matches": [
            "00/00/0000",
            "99:99:99",
            "29/02/2005",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "AAAAAAA",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 676,
        "output": [
            {
                "text": " [^0-9.]+\n\nExercise 2: \nDesign a new Regular Expression pattern to filter out all phone numbers that are written as 10 digits long. Your"
            },
            {
                "text": " \n^(?P<Year>[0-9]{4})-(?P<Month>[0-9]{1,2})/(?P"
            },
            {
                "text": "\n[a-zA-Z0-9. -: ]*. \n1. ([a-zA-Z0-9. -: ]*)."
            },
            {
                "text": "\n[0-9][0-9]\\/[0-9][0-9]\\/[0-9] [0-3][0-9]:00"
            },
            {
                "text": "\n\n\\d{4}(-(\\d{3})\\d{2})?(-(\\d\\d\\d))(\\d{2})?(("
            },
            {
                "text": " [12-31.12.6, 5:30 AM, 30-04-1066]\n\n##### Exercise 5:\nWrite a Python Pandas code to"
            },
            {
                "text": " [a-z][a-z][a-z]_[a-z][a-z]_[a-z][a-z]_[a"
            },
            {
                "text": " [\\d]{4}\\.\\d{2}\\.\\d{2} 00\\b\n- \"A00.C000\"RegEx for this description"
            },
            {
                "text": " \"^((19|20)\\d\\d)?((1[6-9]|2[0-4]))\\d{3}\\-(0[1-9"
            },
            {
                "text": " 0*DDMMYYYY (the first occurrence may be missing, any leading zeroes are allowed)\n\n2. RegEx for extracting values from a String\n\n"
            }
        ]
    },
    {
        "expression": "^((\\d[-. ]?)?((\\(\\d{3}\\))|\\d{3}))?[-. ]?\\d{3}[-. ]?\\d{4}$",
        "raw_prompt": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.",
        "refined_prompt": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\"\nNon-match examples:\n- \"555-222-33334\"\n- \"1(303)5a4-5555\"",
        "matches": [
            "1(555)444-3333",
            "202.555.3333",
            "555-4444",
            "(485)2293192",
            "8820265",
            "(940) 601-9212",
            "5(320)904.3030",
            "969 3892",
            "019-7942",
            "(093)358 1443",
            "040-5517653",
            "364.6479",
            "9835 059-0993"
        ],
        "non_matches": [
            "555-222-33334",
            "1(303)5a4-5555",
            "1 202) 111-3333",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 678,
        "output": [
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444-"
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444444"
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444-"
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444-"
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444-"
            }
        ]
    },
    {
        "expression": "^(?=.*[0-9]+.*)(?=.*[a-zA-Z]+.*)[0-9a-zA-Z]{6,}$",
        "raw_prompt": "Password must contain at least one letter, at least one number, and be longer than six charaters.",
        "refined_prompt": "Password must contain at least one letter, at least one number, and be longer than six charaters.\nMatch examples:\n- \"a1b2c3\"\n- \"abcdefg123\"\n- \"12345a\"\nNon-match examples:\n- \"abcdefghij\"\n- \"1234567890\"",
        "matches": [
            "a1b2c3",
            "abcdefg123",
            "12345a",
            "67gyihu",
            "r67ty8hu",
            "6ft7gy8h",
            "65cftvg7y",
            "s3e4dr5ft6gy7h",
            "3wse4dr5ft64dfr5t6",
            "5rft6g",
            "d5rft6gy7h",
            "5rft6g7y",
            "xed4rtgv"
        ],
        "non_matches": [
            "abcdefghij",
            "1234567890",
            "jsfkdhakjdfhbjkh",
            "yufiuyfkuyfu",
            "234567890567",
            "uvv7",
            "67f",
            "5d4",
            "67ff",
            "65fd",
            "i9",
            "u8"
        ],
        "id": 684,
        "output": [
            {
                "text": "\n[a-zA-Z0-9]{6,20}\n\nLearning Journal - Subsection 6.4.9 - Regex Functions and Methods\n\nExercise 1:\n"
            },
            {
                "text": " \nThis RegEx will match strings that contain both a letter and a number, while ignoring cases, and being at least six characters long.\n``` Python \nimport re \n\nstringToCheck"
            },
            {
                "text": " ^[a-z0-9]{6,}$\n\n4. Create a variable that looks like this: name = \"Maryam's Pizza Place\". Write a RegEx pattern that matches \""
            },
            {
                "text": "\n(?=^[a-zA-Z])(?=^[0-9])(?=^.{6,})\n\n## Python Sets, Loops, and Lambda"
            },
            {
                "text": " [1-9][0-9]{0,5}[._a-zA-Z]\n10. Write a regular expression that matches the number \"1,2,3\" (for"
            },
            {
                "text": " at least one letter, at least one digit, and be six characters \nAnswer: [a-fA-F]\\d{1,6}$\n\n---\n\n### 4. Using"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*\\d)(?=.*)(?=.{6,}).*\n\nExercise 3: Creating a RegEx\nCreate a"
            },
            {
                "text": " *[a-d9]*[a-zA-Z]*[0-9]*\n```\n\n\n\n\nDifficulty Level: World-Class\n\n\n# Chapter:"
            },
            {
                "text": " (\\d\\w+){6}(?:\\W|$)\n\n## Exercise 3: \nCreate a Python script that verifies if an email is valid according to the email format provided in"
            },
            {
                "text": " The pattern is: \"^[a-zA-Z0-9]+$\"\n\n3. Write a Python script that takes in a string and returns the number of vowels it contains.\n"
            }
        ]
    },
    {
        "expression": "^(((((0?[1-9])|(1\\d)|(2[0-8]))\\.((0?[1-9])|(1[0-2])))|((31\\.((0[13578])|(1[02])))|((29|30)\\.((0?[1,3-9])|(1[0-2])))))\\.((20[0-9][0-9]))|(29\\.0?2\\.20(([02468][048])|([13579][26]))))$",
        "raw_prompt": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.",
        "refined_prompt": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.\nMatch examples:\n- \"1.1.2000\"\n- \"29.02.2004\"\n- \"31.12.2099\"\nNon-match examples:\n- \"1.1.1999\"\n- \"29.02.2003\"",
        "matches": [
            "1.1.2000",
            "29.02.2004",
            "31.12.2099",
            "9.11.2052",
            "31.10.2063",
            "11.04.2066",
            "12.04.2021",
            "31.08.2070",
            "29.2.2044",
            "29.04.2074",
            "29.2.2008",
            "29.02.2096",
            "31.07.2060"
        ],
        "non_matches": [
            "1.1.1999",
            "29.02.2003",
            "01.01.2100",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 688,
        "output": [
            {
                "text": "\nPattern pattern = \"(0(?="
            },
            {
                "text": "\n\\d{1,2}\\.("
            },
            {
                "text": " /^[2-9][0-"
            },
            {
                "text": " \n\\d{1,2}"
            },
            {
                "text": " \\b\\d+\\.\\d\\"
            },
            {
                "text": " [\\d+][0-9]"
            },
            {
                "text": "\npublic string generate_date(Isp"
            },
            {
                "text": " ^(1[1-9][0"
            },
            {
                "text": " \\d\\d.\\d\\d"
            },
            {
                "text": "\n/(?!0).01(([2"
            }
        ]
    },
    {
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)",
        "raw_prompt": "This regexp is used to match c++,java,etc style multi-line and single line comments.",
        "refined_prompt": "This regexp is used to match c++, java, etc style multi-line and single line comments.\nMatch examples:\n- \"/* This is a multi-line comment */\"\n- \"// this is a single-line\"\n- \"// fahdui\"\nNon-match examples:\n- \"/sometext\"\n- \"/*/\"",
        "matches": [
            "/* This is a multi-line comment */",
            "// this is a single-line",
            "// fahdui",
            "// fdhsaiu",
            "// fhdsuiah",
            "// ahfdisuh",
            "// fdhsaiuh",
            "// uh8hfds",
            "// fhj89ewh",
            "// h8euwh8",
            "/* This is afdsant */",
            "/* This iadft */",
            "/* Thfadsnt */"
        ],
        "non_matches": [
            "/sometext",
            "/*/",
            "/aguysdfb",
            "/fabsduyg87dyuhs",
            "/g78fsudi",
            "/*fhudsifdsb",
            "/usydfgufdsg",
            "/ysfg",
            "/fgysduf67e2",
            "1-1-2",
            "(0xx12) 62509@",
            "12/132/90"
        ],
        "id": 689,
        "output": [
            {
                "text": " /[*\\/\\s]+/g\n\nTo extract the lines as well, one would have to parse through $comment by using a backreference. This will require another regex."
            },
            {
                "text": " RegEx: /(\\/[\\d\\s]+)(*|\\/)/gi\nEdit: A sample of code would look like this,\n/**\n* Some comment\n*"
            },
            {
                "text": "   /sometext\n- \"\"// This is a single-line comment \"\"// fahdui\n- /sometext\n\nA:\n\nI would do it"
            },
            {
                "text": " I couldn't find a good answer for this one,\nbut I think following will suffice:\n// I am following the rules above, but if you have any ideas why your result is"
            },
            {
                "text": " /\\/(.*?)\\/*/\nExplanation: The \".\" refers to any character. This (.*?) is repeated for as many times as possible so as to find any"
            },
            {
                "text": " \nPattern singleLine = Pattern.compile(\"^/\\\\s*(.*)$\");\nPattern multiLine =Pattern.compile(\"^\\\\*(.*)(\\\\"
            },
            {
                "text": " /sometext/\n\nA:\n\nYou can use this pattern \nvar str=\"\";\nif (/\\*.*?\\*//.test(str)||/"
            },
            {
                "text": " (/\\/.+$/)\nIf you use this regexp or similar, if \"text\" is a multi-line string or a string with a single line comment string, it will"
            },
            {
                "text": "\n//(.*?)\n\nA:\n\n// match a single line comment\n/([^\\\\r\\n]|^)//g\n\nor\n/^\\"
            },
            {
                "text": " /./\n\nFor my use case in the future I could use the RegEx I/am able to define in my regexp.\n\nA:\n\nHow about the following"
            }
        ]
    },
    {
        "expression": "\\.txt$",
        "raw_prompt": "Matches a file extention.",
        "refined_prompt": "Matches a .txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"",
        "matches": [
            "testfile.txt",
            ".txt",
            "this is a file.txt",
            "fasduht.txt",
            "gfadf.txt",
            "fsgh.txt",
            "apple.txt",
            "dog.txt",
            "demo.txt",
            "test.txt",
            "abc.txt",
            "test2.txt",
            "uadfh.txt"
        ],
        "non_matches": [
            "this is not a file.trt",
            ".tst",
            ".text",
            "fsdyfubsh",
            "uysdf8gy",
            "bhf67y",
            "76",
            "f7uy",
            "ougtxt",
            "gyfgd",
            "ft7ft67y",
            "f6tyg"
        ],
        "id": 693,
        "output": [
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer:\nTo match a.txt file extension, use the following regex:\n```\n[^.]+\\.txt$\n```\n\nExercise 4:\nWrite a Python program that reads a filename from the user, verifies it matches the given RegEx,"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: \n[a-zA-Z0-9_-]+(\\.[a-zA-Z_.-])+\n\nExercise 2: \nWhat is the difference between regular expressions and simple text searching?\nAnswer: Regular expressions are a more powerful"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: (.txt)|(.txt$)\n\nMy code so far is: \nimport re\nprint(\"Text Processing Exercises - Match a.txt file extension\")\nregex = re.compile(\".\\(\\\". + (.txt$))\")\n"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: [a-zA-Z]*\n\n# Python Exercise 3\nWrite a function that takes a string as input and returns a list of all of its unique characters.\n\n```python\ndef unique_chars(string: str) -> list:\n"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer:\n\nimport os \nimport re \ntxt_path = os.path.join(\"data\", \"testfile.txt\") \nwith open(txt_path, \"r\") as f: \n    ext = re.search(\"(\\.txt$"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: \nimport re\nword = \"this is a file.txt\"\nprint(re.search('\\.',word))\nregex = re.compile(\"(\\..+))\")\nfile = list(regex.findall(word))\nprint"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: ^[a-zA-Z0-9\\.\\s]*$\n\n3. Write a Python program to generate a RegEx for a given phrase and case.\nAnswer: \nimport re\n\ndef phrase_case_generator(phrase,"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: ^(!.*txt$)|^(?!.*tst$)$\n\n#Exercise 2\n\nRegex Pattern: ^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).*$\n"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: (.*)([^\\.]+(\\.[\\.]+)*$)\n\n4. Use a.NET file upload handler to read a file from the user. \nAnswer:\nusing System.IO.FileIO;\nusing System.Text;\nusing"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer:\nThe regular expression pattern could look like \"(.+\\.){3}$\". Replace the `.+` symbol to match as many characters as possible -- including whitespace and punctuation -- and the `{3}` symbols to make sure that the final part matches"
            }
        ]
    },
    {
        "expression": "((DK|FI|HU|LU|MT|SI)(-)?\\d{8})|((BE|EE|DE|EL|LT|PT)(-)?\\d{9})|((PL|SK)(-)?\\d{10})|((IT|LV)(-)?\\d{11})|((LT|SE)(-)?\\d{12})|(AT(-)?U\\d{8})|(CY(-)?\\d{8}[A-Z])|(CZ(-)?\\d{8,10})|(FR(-)?[\\dA-HJ-NP-Z]{2}\\d{9})|(IE(-)?\\d[A-Z\\d]\\d{5}[A-Z])|(NL(-)?\\d{9}B\\d{2})|(ES(-)?[A-Z\\d]\\d{7}[A-Z\\d])",
        "raw_prompt": "Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number).",
        "refined_prompt": "Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number).\nMatch examples:\n- \"CZ-7907111883\"\n- \"ESA12345678\"\n- \"FRAB123456789\"\nNon-match examples:\n- \"CZ55912\"\n- \"XY123456\"",
        "matches": [
            "CZ-7907111883",
            "ESA12345678",
            "FRAB123456789",
            "IT29718370337",
            "SE-864625192808",
            "LV-10527473548",
            "CY-67720099A",
            "NL105141803B34",
            "LT761853862266",
            "ATU97894110",
            "CZ-04262873",
            "IT02029028652",
            "FR-1X030074294"
        ],
        "non_matches": [
            "CZ55912",
            "XY123456",
            "FR-IB123456789",
            "ewsdfwef23ewdsff",
            "23ewsdfw7yugy",
            "f67yuf87yug8ub",
            "g8yu8gyFYGU",
            "G8YUBG8UBTF",
            "TFYGF67YGUCTV7",
            "FYVUTCVUGTF7YY",
            "6D7TFUYGUHIG7F6TY",
            "F76TYUGIHOJ"
        ],
        "id": 697,
        "output": [
            {
                "text": " \"CZ[0-9]{2}\\\\d{3}[0-9]{3}"
            },
            {
                "text": " (?<countryCode>\\d{3})-(\\d{3})[\\s\\-\\.]?"
            },
            {
                "text": " ^FRAB[1234567]\\d{6}$ \n\nExercise 2: Write a"
            },
            {
                "text": " CV[1-9]{2} or CG[1-9]{2}\nI tested my regex"
            },
            {
                "text": " CZ-\\d19 (C, z and an optional 19) \n\nExercise 2:\nCreate"
            },
            {
                "text": " ^[A-Fa-f0-9]{4}[A-Fa-f0-9]"
            },
            {
                "text": " \n[A-za]{2}\\-(?:\\d{4}|\\d{3}-"
            },
            {
                "text": " ^[AB][3-9][0-9]{2}$\nExercise 3:\nCreate a"
            },
            {
                "text": " ^([A-Z0-9]{3})+(?:-([A-Z0-9]{"
            },
            {
                "text": " (\\b[5][6-9]\\d{3}\\2\\b|\\b[9]"
            }
        ]
    },
    {
        "expression": "^(((2|8|9)\\d{2})|((02|08|09)\\d{2})|([1-9]\\d{3}))$",
        "raw_prompt": "Matched Australian Postcodes, as defined by AusPost.\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\n1000s are for big companies in Sydney, competition mailings, etc.",
        "refined_prompt": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \"700\"\n- \"0700\"",
        "matches": [
            "200",
            "0820",
            "2753",
            "865",
            "6247",
            "3773",
            "0902",
            "982",
            "0937",
            "9607",
            "0852",
            "259",
            "0235"
        ],
        "non_matches": [
            "700",
            "0700",
            "abcd",
            "4897FDS",
            "79865DSFSF",
            "4985689456",
            "FS4D8",
            "489FSD",
            "FS894D78796",
            "894561",
            "89456123",
            "1"
        ],
        "id": 703,
        "output": [
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            }
        ]
    },
    {
        "expression": "^(19[0-9]{2}|[2-9][0-9]{3})-((0(1|3|5|7|8)|10|12)-(0[1-9]|1[0-9]|2[0-9]|3[0-1])|(0(4|6|9)|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(02)-(0[1-9]|1[0-9]|2[0-9]))\\x20(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$",
        "raw_prompt": "Checks for the format yyyy-MM-dd HH:mm:ss\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.",
        "refined_prompt": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12 14:25:59\"\n- \"20004-07-12 14:25\"",
        "matches": [
            "2004-07-12 14:25:59",
            "1900-01-01 00:00:00",
            "9999-12-31 23:59:59",
            "5930-04-14 17:38:38",
            "2323-09-15 13:48:38",
            "1976-02-12 23:58:58",
            "7750-02-25 04:19:35",
            "8859-10-06 23:16:25",
            "6865-11-04 20:47:46",
            "4749-02-05 12:58:40",
            "2135-10-20 06:33:01",
            "3847-10-25 07:59:02",
            "4962-11-13 21:23:51"
        ],
        "non_matches": [
            "04-07-12 14:25:59",
            "20004-07-12 14:25",
            "2004/07/12 14:25:59",
            "12/123/4322 14:25:59",
            "2346-2345-2435 14:25:59",
            "$23.454 14:25:59",
            "/5/5/5 14:25:59",
            "/5/5/20022",
            "14:25:59432/524/2435",
            "1-1-2 14:25:59",
            "(0xx12) 62509 14:25:59",
            "12/132/90"
        ],
        "id": 704,
        "output": [
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-2012"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-07"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-2012"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-11"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            }
        ]
    },
    {
        "expression": "(^\\d{1,5}$|^\\d{1,5}\\.\\d{1,2}$)",
        "raw_prompt": "This expression evaluates simple currency values... alteast 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period",
        "refined_prompt": "This expression evaluates simple currency values... at least 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period\nMatch examples:\n- \"0\"\n- \"00000\"\n- \"00.00\"\nNon-match examples:\n- \"asds\"\n- \"000000\"",
        "matches": [
            "0",
            "00000",
            "00.00",
            "84",
            "645",
            "48",
            "489",
            "846",
            "987",
            "654",
            "321",
            "5164",
            "9835"
        ],
        "non_matches": [
            "asds",
            "000000",
            "00000.",
            "12/123/4322",
            "51:534",
            "$23.454fd",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 708,
        "output": [
            {
                "text": "\n^\\d{0,5}\\.?$\nRegExr:  https://www.regexr.com/3kqt0\nThe best way to do this is using lookaheads or"
            },
            {
                "text": " \n^(?:\\d{0,1}\\.)?\\d{1,5}$\nThis expression generates a RegEx for this description. \nAs shown above you are matching a number (or"
            },
            {
                "text": " 0[0-9]{3}[.][0-9]{3}\n\nA:\n\nIf you want to match a number that does not contain a decimal, use ^[^\\.]"
            },
            {
                "text": "\n^(?=(\\d{1,}).*(?!\\d))(?=(\\d{1,})(.|\\.)?\\d{0,5})(?=(\\d"
            },
            {
                "text": " (?<=\\d{1,4}[\\.])(\\d|[eE][+-]?\\d)$\n\nA:\n\nYou may use\n^(\\d+)."
            },
            {
                "text": " [0-9]{0,5}.[0-9]{2,2}\n\nA:\n\n    [0-9]{6}[0-9]\\.[0-9]"
            },
            {
                "text": "\n[^012.]|0\\.0|[0123456789]\\.0[012]|[0123456789]0.0[012]|\\..0+\nI haven't"
            },
            {
                "text": " \n([0-9]\\d(\\.\\d){0,1}|0(\\.\\d){0,1})\n\nThis expression generates a regex to match these cases.  If you want"
            },
            {
                "text": "\n[0-9]\\d{1,5}[\\.]\\d\\d\n\nA:\n\nUsing regex is not really recommended, I think in this particular case:\nString str = your"
            },
            {
                "text": " (\\d+)[.\\d](\\d{0,2})\n\nA:\n\nJust capture the integer portion:\n^\\d{{1,4}}([,.\\d]+)\n\n"
            }
        ]
    },
    {
        "expression": "^(\\$)?(\\s)?(\\-)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "raw_prompt": "Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places.",
        "refined_prompt": "Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places.\nMatch examples:\n- \"$1,000.00\"\n- \"$-1,000.00\"\n- \"100.8766\"\nNon-match examples:\n- \"$1a\"\n- \"$#100.00\"",
        "matches": [
            "$1,000.00",
            "$-1,000.00",
            "100.8766",
            "894.89",
            "$54.156",
            "$54.484",
            "$545.155",
            "$57.159",
            "$96.154",
            "814.85",
            "894.11",
            "824.22",
            "44.97"
        ],
        "non_matches": [
            "$1a",
            "$#100.00",
            "1,00.00",
            "12/123/4322",
            "51:534",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 709,
        "output": [
            {
                "text": "!(^\\d[^.0-9"
            },
            {
                "text": " $1\\.\\d{3}[,.]"
            },
            {
                "text": "  [0-9]*[,.][0"
            },
            {
                "text": " $-?\\d*[\\.\\d]"
            },
            {
                "text": " $#(?<firstnumber>[0-9"
            },
            {
                "text": " I[0-9]{1,2}"
            },
            {
                "text": " (\\d\\d[\\s,]+\\"
            },
            {
                "text": ".0+$\n\nQuestion 3: What is"
            },
            {
                "text": " $1[a-zA-Z0-"
            },
            {
                "text": " \".*[0-9]{3,4"
            }
        ]
    },
    {
        "expression": "^[\\w0-9&#228;&#196;&#246;&#214;&#252;&#220;&#223;\\-_]+\\.[a-zA-Z0-9]{2,6}$",
        "raw_prompt": "This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed.",
        "refined_prompt": "This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed.\nMatch examples:\n- \"gut.txt\"\n- \"afdsa.dfa\"\n- \"t3e.fsd\"\nNon-match examples:\n- \"&amp;quatsch\"\n- \"qua%tsch.txt\"",
        "matches": [
            "gut.txt",
            "afdsa.dfa",
            "t3e.fsd",
            "fd.ta",
            "fsg.fad",
            "wtre.asda",
            "gs.fsg",
            "ewfs.afd",
            "asdf.jpg",
            "adsf.png",
            "dfcv.jpg",
            "qrew.jpg",
            "ot.png"
        ],
        "non_matches": [
            "&amp;quatsch",
            "qua%tsch.txt",
            "auch_quatsch.test.txt",
            "txtpng",
            "pgfdas",
            "bfdahih.sdfhu.hufd",
            "/5/5/5",
            "98iojk",
            "u09nKLJG FSL",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 711,
        "output": [
            {
                "text": " r\"^[a-z\\_]+[0-9]{8}$|^\\.[a"
            },
            {
                "text": "\n(?<![a-z][a-z0-9])(?P<FileName>."
            },
            {
                "text": "\n^(?![.\\\"\\/\\\\*+-])[^&]{1,9}$\n"
            },
            {
                "text": " ^[a-zA-Z0-9_-\\. ]+$\n\n2. Create a RegEx"
            },
            {
                "text": " You can use the expression ^[a-zA-Z0-9_](?<![.,])"
            },
            {
                "text": " Regex '^.+\\.docx$'\nExercise 3: Write a Python code that generates a list"
            },
            {
                "text": " (RegEx: /[^0-9a-zA-Z]+/g) /\n\n3"
            },
            {
                "text": " ^[aeiouA-Z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fa\u00e9\u00e8\u00f6\u00e0\u00e1\u00ed\u00f3\u00fa\u00f2"
            },
            {
                "text": "\n$rFileNameRegEx = \"/^([a-z]+[A-Za-z0-"
            },
            {
                "text": " /[^=& ]+/\n  Here & and % are non-special characters.\n- \"f"
            }
        ]
    },
    {
        "expression": "^\\.{1}",
        "raw_prompt": "simply checks to see if the first charactor is a . (dot)",
        "refined_prompt": "simply checks to see if the first charactor is a . (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"",
        "matches": [
            ".net",
            ".blah",
            ".anything",
            ".gvy",
            ".vyuhbj",
            ".g7yu",
            ".8g7uihbj",
            ".cytgv",
            ".yfgu",
            ".yftugh",
            ".tyyf7gy8",
            ".yg",
            ".ctfytgv"
        ],
        "non_matches": [
            "net",
            "net.stuff",
            "netstuff.",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "98iojk",
            "432/524/2435",
            "adfa2",
            "dfg",
            "0j0jweBBBB"
        ],
        "id": 727,
        "output": [
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer:\n#[a-z]+ [.][a-z]+([0-9]|-)\n\nA:\n\nYou can use the regex ([a-zA-Z0-9]*)(\\.[a-zA-Z0-9]+) like this:"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: (.?)\n\nNow, you have a basic knowledge of what RegEx is and how to use it. Don't be afraid to experiment and try out different use cases. Remember, just like how a first aid kit can come in handy in times of emergency, RegEx can come in handy when it"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer:\n(?:[a-z0-9\\.]{4,100}([a-z\\.]*))\n\n- Generate a RegEx based on this description: the first three characters are always uppercase letters, followed by lowercase letters or digits. \nAnswer based"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: (\\.).+(?!\\.)\n\n# Python\nimport re\ntext = \"net.stuff\"\nprint(re.findall(\"(\\.).+(?!\\.)\",text))\n# ['.', '.', '.']\n\n# Explanation\n# First capturing group:"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: \n[[:digit:]]{1}[.][[:digit:]]{1}\n\nA:\n\nThe above answer works with your inputs and the examples you provided, but it cannot match \"net.stuff\" because it is not the first character in the string. How"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: ^\\d+\\.net$\n\n4. You are creating an automatic email verification system on your site. If your name doesn't match your email address, it will be returned as spam. Create a RegEx statement for the email validation to ensure the email addresses match.\n\nExample: @"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: ([^a-zA-Z0-9.]).+ \n\nExercise 9: \nMatch example:\n- \"The cat is fat\"\n- \"The cat is fat.\"\n- \"The cat is fat. The cat's belly is bulging out.\"\nNon"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer:\n\\\\.\\w*\n\nThat said, don't use regex in this kind of cases: search the string from left to right, check if the first character is a char from the first set of alphabets, or a char from the second set of alphabets with a"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: \n^[^\\.\\s][^\\.\\s\\.]*$\n\n- \".net-\"Generate a RegEx for this description. \n\nAnswer:\n^[^\\\\.\\s]{2,}([\\\\.-]+){1}[^\\\\"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: \n\"[^.]*net[^.]*\"\n(.*)\\.net(.*)\n(.*){2}\nThis will find any number of alpha characters, followed by a number, followed by.net.\nIn summary, you are able to use the special RegEx character"
            }
        ]
    },
    {
        "expression": "^\\d?\\d'(\\d|1[01])?.?(\\d|1[01])&quot;$",
        "raw_prompt": "This RE matches the height in feet and inches with decimals and without decimals in it",
        "refined_prompt": "This RE matches the height in feet and inches with decimals and without decimals in it\nMatch examples:\n- \"5'5.5&quot;\"\n- \"2'3&quot;\"\n- \"9'10.4&quot;\"\nNon-match examples:\n- \"5 feet 5.5 inches\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "5'5.5&quot;",
            "2'3&quot;",
            "9'10.4&quot;",
            "70'11_10&quot;",
            "57'2&quot;",
            "4'108&quot;",
            "68'49&quot;",
            "07'93&quot;",
            "86'11&quot;",
            "94'110&quot;",
            "3'10&quot;",
            "6'0&quot;",
            "6'112&quot;"
        ],
        "non_matches": [
            "5 feet 5.5 inches",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "26+2'2'565'1",
            "65'51'684",
            "8944'84'48'",
            "4984'646'86'486",
            "164'879'54"
        ],
        "id": 729,
        "output": [
            {
                "text": "\n- r'5\"(?: &quot;(\\d+)&quot;\"|(?:"
            },
            {
                "text": " \".*?(\\d)(?<=[\\d'])\\\\&quot;.*\"\n"
            },
            {
                "text": " /\"^([0-9]{1,2}\\s*\\.?[0-9"
            },
            {
                "text": "?[A-Za-z\\\\ \\-_=\\. \\&#]?(\\^"
            },
            {
                "text": "^\".*\"([^&quot;]*)&quot;$\"\n- \""
            },
            {
                "text": " \n- Match example 3) \"9'10.4&quot;\" Non-match"
            },
            {
                "text": " match1:^\\d+'\\d\\d.?\\d\\d\\.?$"
            },
            {
                "text": "\n- \"5\\\\d\\\\.\\\\d\\\\.5\"\n\nExercise 5: Use"
            },
            {
                "text": " 5'5\\-5&quot;8&quot;.jpg\n\nExercise 3"
            },
            {
                "text": " \"(?^.*?\\\\d{1,2})(?:-?\\\\d{1,"
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "raw_prompt": "Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes).",
        "refined_prompt": "Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes).\nMatch examples:\n- \"LOZG7802117B9\"\n- \"LOZG-780211-7B9\"\n- \"LOZG780211-7B9\"\nNon-match examples:\n- \"LO-ZG-78-02-11-7B9\"\n- \"52/2/54/245\"",
        "matches": [
            "LOZG7802117B9",
            "LOZG-780211-7B9",
            "LOZG780211-7B9",
            "pdbb 744807Rcb",
            "gKFM-572682R8b",
            "fKqS423419-Eoj",
            "RBLx561138|5tL",
            "wwqh767304 j2B",
            "eblp686659-8h4",
            "MCkL-404578 g4a",
            "TcrQ 102152-ewY",
            "igis991168-p5x",
            "ceOZ331953sNQ"
        ],
        "non_matches": [
            "LO-ZG-78-02-11-7B9",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 730,
        "output": [
            {
                "text": " (lo|lo-|lo-)+(\\d{8})-(\\d{"
            },
            {
                "text": " ([a-z]+)(/) ([0-9]{4})/([0"
            },
            {
                "text": "\n^(?=.*[0-9])(?=.*[a-"
            },
            {
                "text": " ^(?P<name>M\\d{2})-(?P<"
            },
            {
                "text": " ^[A-Z]{4}-[a-z]{2}"
            },
            {
                "text": " \\d/[a-zA-Z]{1}/[a-"
            },
            {
                "text": "\n^[^/-]+-([^/-]+)$\nExamples:\n-"
            },
            {
                "text": " \"(?P<id_firmazamo_id>[1-9][01"
            },
            {
                "text": " [^\\/]*\\/[^\\/]*/[0-9\\-]+\n"
            },
            {
                "text": " (\"^[0-9]{6}\\s?[0-9]{"
            }
        ]
    },
    {
        "expression": "^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$",
        "raw_prompt": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.",
        "refined_prompt": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\"\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31\"",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080:0:0:0:8:800:200C:417A",
            "0:0:0:0:0:0:0:1",
            "FC3:5cfB:1b2:55:2:EeE:eD:88",
            "de9:6b:06:FaA:fcb:b:EB:Bf8a",
            "EC:8De6:36:B6dE:b:A8:cbf:c",
            "C:2:CE:2:DB:2bf:2B:C",
            "C5A:1B8:1f:9:d23:dBDE:C:F",
            "c9:Af7:3:E1:88bB:0b:55:FA5b",
            "aee:e7:Bb:aC11:57C4:edd9:fc8:f",
            "ede0:7C7F:75:67:a72:CcD1:ba:B1",
            "7Bdd:1:35:7:D25F:208:f:eD36",
            "A4b:d3:3:8EdD:858:4D:E:6"
        ],
        "non_matches": [
            "128.0.0.1",
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31",
            "::1",
            "12/123/4322",
            "sfalijad234",
            "there is a boy",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "abc111def",
            "99999@gmail"
        ],
        "id": 731,
        "output": [
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1 \""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1/"
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1/"
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            }
        ]
    },
    {
        "expression": "^[0-9]*$",
        "raw_prompt": "Matches only numbers, in any length. No characters or punctuation will be matched.",
        "refined_prompt": "Matches only numbers, in any length. No characters or punctuation will be matched.\nMatch examples:\n- \"2\"\n- \"99\"\n- \"15800\"\nNon-match examples:\n- \"1,2\"\n- \"f9\"",
        "matches": [
            "2",
            "99",
            "15800",
            "48",
            "156",
            "6864548",
            "9489",
            "46848",
            "646",
            "84684",
            "86468",
            "4651",
            "48971564"
        ],
        "non_matches": [
            "1,2",
            "f9",
            "a9j",
            "12/123/4322",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 735,
        "output": [
            {
                "text": "\n[0-9]+\nSome useful things that you should know about Regex:\n*. *\n* +\n* * +\n* * *\n* *?\n*? *\n* + * *\n* + * * +\n* + * * *"
            },
            {
                "text": " 2,\\d{1,2}\n\n\n\nTitle: Health and Physical Education: Exploring Diseases and Themes\n\nAbstract:\nThis proposal aims to provide a comprehensive understanding of health and physical education, with a focus on diseases and their themes and topics. By using"
            },
            {
                "text": "\n^(?=.*\\d)(?=.*[a-zA-Z]).{1,15}$\nThe regex matches any word, string with one or more digits, and characters, and length up to 15, but requires there be at least one digit and"
            },
            {
                "text": "\nRegex: 1, 2 = |, |a-zA-Z0-9]+|1,|2\n\n- \"999\"\n- \"1,9,19\"\n- \"1,9,19,999\"\n- \"1,9"
            },
            {
                "text": " ^(?:\\d+-)?\\d{2,3}$\nExample Matching: 1,2\nExample Non-matching: \"1,\", \"f9\"\n\nLearning Journal of a Student: Subsection 2.2.3\n\nEx"
            },
            {
                "text": "  (.*?)\\s([0-9]+)\n\nUse case,\n\nThe company is using RegEx to parse customer call records. A particular customer call log is as follows: \"Call 01234-5678 from your phone\". When the customer logs in from the"
            },
            {
                "text": " ^\\d+(?:\\.\\d+)?$\n\n3. Write a function getNumbers(string) using python that removes all anything but numbers and returns them as a string.\n**Idea**: \n- Try to write a for loop that iterates through"
            },
            {
                "text": " ^\\(\\?([1-9]\\d{0,2}|100,000)?\\)\\?$\"\n\n9. Write a RegEx for the email address format: name@domain.com\n\nEmail address format: name@domain.com\n\n"
            },
            {
                "text": " ([0-9]+)\\s[\\w\\s]+\n\n(I would like the explanation too)\n\nA:\n\nYou need to repeat a character or a number 0 or more times. Thus a quantifier {0,1} or {0,2}."
            },
            {
                "text": "  (?<number>\\d+)(,[\\d\\s])*(?=[\\d]|$)\n- \"(?<=^|[^\\d])(\\d+)(?=\\.|$)\" generate a RegEx for this description."
            }
        ]
    },
    {
        "expression": "^\\d{5}(-\\d{4})?$",
        "raw_prompt": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or &quot;hyphen&quot;. [67]Sector or Several Blocks. [89]Segment or One Side of a Street. Also just FYI, ZIP codes in the northeast US frequently start with '0' or '00'. [00988-Carolina, PR] [03110-Bedford, NH]. Thanks, Ryan v-",
        "refined_prompt": "Zip+4 Zip code RegEx. You may omit the +4 digits but you must also then omit the hyphen/dash as well.\nMatch examples:\n- \"98121\"\n- \"00988\"\n- \"12345-6789\"\nNon-match examples:\n- \"98121-\"\n- \"12345-678\"",
        "matches": [
            "98121",
            "00988",
            "12345-6789",
            "97974",
            "81896-6579",
            "70912",
            "60306-8907",
            "86814-6754",
            "57939-2962",
            "10379",
            "24243-5665",
            "71500-7460",
            "83951-9333"
        ],
        "non_matches": [
            "98121-",
            "12345-678",
            "1234",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "abc111def",
            "12/132/90"
        ],
        "id": 738,
        "output": [
            {
                "text": " \\d(?: *)-\\d\n\nFor the last one I have put in brackets because sometimes people confuse that with the - character and need to use both of them.\n\nA:\n"
            },
            {
                "text": " [098][0-9][1-9]\\d[0-9]|[0-9]\\\\-\\\\d[0-9]\n\nA:\n\nI"
            },
            {
                "text": " The pattern is ^\\d{4}-?\\d{4}$\n2-3 This one's for finding all instances of the pattern: [b-df-hj-np"
            },
            {
                "text": " ^[0-9]{8}\\-[0-9]{4}$ (you can modify as needed)\n\nLet's break down this example:\n\n- The beginning of the"
            },
            {
                "text": " I think the pattern would be:\n\n\\d{5}\\s-\\d{4}\n\nQ:\n\nPython - How to sum a list of numbers within a list of diction"
            },
            {
                "text": " \"\\d{4}-\\d{4}\"\nHere is another question for generating a RegEx:\n\nQuestion: What would be a good RegEx for generating a list of names that contain"
            },
            {
                "text": " ^([\\d]+-){0,255}[\\d]*$\n\nA:\n\nThis should do it:\n\\d{3}\\-\\d{3}-"
            },
            {
                "text": " (^\\d{3,5}[-\\s]?\\d{7}$)\"\nExercise #3:\nUsing the zip code Zip+4 ZIP code RegEx,"
            },
            {
                "text": "  ^[0-9]{4}\\.?[0-9]{3}$\n\nA:\n\nUsing the zip() (or zip3()) function to group the numbers"
            },
            {
                "text": " ([0-9]{4})-([0-9]{3})\n- Create a list of all Zip codes that contain no hyphens and also start with four digits each, starting from"
            }
        ]
    },
    {
        "expression": "^[1-9][0-9]{0,2}$",
        "raw_prompt": "All positive non-zero integers between 1 and 999. You can adjust the upper range of this expression by changing the second number (ie 2) in the {0,2} part of the expression.",
        "refined_prompt": "All positive non-zero integers between 1 and 999.\nMatch examples:\n- \"1\"\n- \"561\"\n- \"999\"\nNon-match examples:\n- \"-1\"\n- \"0\"",
        "matches": [
            "1",
            "561",
            "999",
            "189",
            "846",
            "875",
            "965",
            "485",
            "325",
            "612",
            "632",
            "666",
            "888"
        ],
        "non_matches": [
            "-1",
            "0",
            "1000",
            "925148",
            "489198498",
            "489489",
            "8425",
            "8452",
            "-48196",
            "1895.156",
            "1596.15",
            "54.321"
        ],
        "id": 739,
        "output": [
            {
                "text": "\n.*\\w\\d{3}$\n\n8.  Write a Python function that takes a string as input and generates a RegEx to match the same pattern. The function should return the generated regular expression string.\n\nExample string:\n\"3.14\"\nAnswer:\n.*\\d{1,2}."
            },
            {
                "text": " -1,0|3\n\n3. The goal of this exercise is to practice generating Regex that can be used for password validation\n\n- Password must be at least 8 characters long, contain at least one number and one special character. \n- There may only be one character in one \"special\" section and it may only"
            },
            {
                "text": " [0-9]+\n\nExercise 3: Pattern Extension\nWrite a regular expression to match URLs in HTML (starting with http:// or https://) and ending with a.com,.org,.edu,.net, or.gov domain. \nAnswer: /(http|https)[a-zA-Z"
            },
            {
                "text": " ^[0-9]+$\n3.5. Create a python function that accepts a string containing a set of words. The function should return a list containing the words that contain at least one digit between 0 and 9.\n\nSample Text: \"The quick brown fox jumped over the lazy dog and saw the 12345 cars pass by"
            },
            {
                "text": "\n\\d{1,3}(-1|0)? \\d{3}(-1|0)?\\d{3}\nHow do you create a negative lookahead that would allow more than one match?\nHow do you test the results of a call to your method outside of this particular project?\nHow do you debug"
            },
            {
                "text": "\n- \"^[1-9]\\d*$\"\n\n5. Create a RegEx pattern for string length greater than 8 characters.\nAnswer:\n^(?=.{8,})(\\w+)$\n\n6. Write a Python program using the Re module to validate a password.\nAnswer:"
            },
            {
                "text": " A one-or-more digits \"0-9\" character.\nI wrote the following function:\ndef number_matching(number):\n    return re.search(\"(^\\d|\\d$)$\", number)\n\nSo the number_matching function takes a number and returns match if the number is"
            },
            {
                "text": " ^(0|[1-9][0-9]?)$\"\n\n5.\nWrite a RegEx to match any strings containing only letters and spaces between two numbers.\nAnswer: ^\\d{2}\\s\\d{2}$\n\n\n\nDear Alien,\n\nI hope this letter finds you"
            },
            {
                "text": " [1-9][0-9]* \nExercise 4: Check if the following string matches the RegExp. \n[0-9]\nAnswer: True\n- \"1a2b3c4d5e6f7g8h9i0j0k0l0m0n0"
            },
            {
                "text": " r'^\\d{0,3}[-\\+]\\d{0,3}[-\\+]\\d{3}$'\n- \"123456676\"\n- \"223423423\"\n- \"3-456--0\"\n- \"56-90**-1\""
            }
        ]
    },
    {
        "expression": "(((0[1-9]|[12][0-9]|3[01])([.])(0[13578]|10|12)([.])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([.])(0[469]|11)([.])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([.])(02)([.])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([.])([02468][048]00))|((29)([.])(02)([.])([13579][26]00))|((29)([.])(02)([.])([0-9][0-9][0][48]))|((29)([.])(02)([.])([0-9][0-9][2468][048]))|((29)([.])(02)([.])([0-9][0-9][13579][26])))",
        "raw_prompt": "Usefull for SQL update and insert sentence..",
        "refined_prompt": "Match date patterns in the format of \"dd.mm.yyyy\" or \"dd.mm/yyyy.\" It accounts for different variations in days, months, and leap years.\nMatch examples:\n- \"01.01.2004\"\n- \"30.12.2005\"\n- \"24.02.1980\"\nNon-match examples:\n- \"01/01/2004\"\n- \"1.1.2004\"",
        "matches": [
            "01.01.2004",
            "30.12.2005",
            "24.02.1980",
            "30.08.2009",
            "29.02.7604",
            "29.02.4428",
            "29.02.9844",
            "16.02.2905",
            "20.10.2000",
            "05.10.2063",
            "02.10.2939",
            "07.11.2905",
            "03.02.1924"
        ],
        "non_matches": [
            "01/01/2004",
            "1.1.2004",
            "01-01-2004",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 742,
        "output": [
            {
                "text": " \\d(?:\\.\\d{2})+|(?:\\d{2}\\.)\\"
            },
            {
                "text": " A possible regex for this would be \"\\d{2}\\.\\d{2}/\\d{"
            },
            {
                "text": " To generate a RegEx, we would need to account for the variation between \"/.\" and \":\" in the"
            },
            {
                "text": " /([0-9]{2})([0-9]{2})\\/(0["
            },
            {
                "text": " For this description you will want to use the RegEx patterns \"dd.mm/yyyy\" and \""
            },
            {
                "text": " r\"^\\d[0-9.]+$\" ^ \n\n5. In this exercise"
            },
            {
                "text": " \n[A-Z]|\\d{1,2}/(\\d{1,2"
            },
            {
                "text": " [Exercise5 answer here]\n```python\nimport re\ntext = \"01/01/"
            },
            {
                "text": " r\"(\\d{2.2})\\.?(\\d{2})-(\\d{4})"
            },
            {
                "text": " (\\\\b|(?<=[0-9])[1-9])\\\\.(\\\\b|"
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{3,4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "raw_prompt": "This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections.",
        "refined_prompt": "This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections.\nMatch examples:\n- \"LOZG7502123T7\"\n- \"LOZG-750212-3T7\"\n- \"LOZ 750212 3T7\"\nNon-match examples:\n- \"LOZG750212\"\n- \"f34fvfv\"",
        "matches": [
            "LOZG7502123T7",
            "LOZG-750212-3T7",
            "LOZ 750212 3T7",
            "XHum233851|Jmy",
            "hgXM|314476|flP",
            "ZRDh 460315 1c3",
            "nRyL375538seX",
            "Yqa-542785rzd",
            "btPn8184368q0",
            "VMc-207955Kbs",
            "FQa354770|FzW",
            "cLo-216233ykI",
            "DHF411355I5m"
        ],
        "non_matches": [
            "LOZG750212",
            "f34fvfv",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "u09nKLJG FSL",
            "adfa2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 743,
        "output": [
            {
                "text": " \".*[-](0|1|2|"
            },
            {
                "text": " \\w{4,}\n\n- \"(f"
            },
            {
                "text": " NO MATCH\n- \"f34fvf"
            },
            {
                "text": " [a-z]{3,4}-["
            },
            {
                "text": " [a-z,A-Z]{2"
            },
            {
                "text": " ((\\S(?=\\d))+|"
            },
            {
                "text": " [A-Za-z0-9]"
            },
            {
                "text": " (?i)(?<=\\|)(?"
            },
            {
                "text": " ([a-zA-Z]{8})"
            },
            {
                "text": " \\d{3,}[-\\d]"
            }
        ]
    },
    {
        "expression": "^([-]?[0-9])$|^([-]?[1][0-2])$",
        "raw_prompt": "I made this to validate offsets to GMT",
        "refined_prompt": "This regex pattern is designed to match integers from -12 to 12, whether they are positive or negative. It won't match non-integer values, values outside the range of -12 to 12, or non-numeric characters.\nMatch examples:\n- \"1\"\n- \"-10\"\n- \"10\"\nNon-match examples:\n- \"13\"\n- \"-25\"",
        "matches": [
            "1",
            "-10",
            "10",
            "2",
            "3",
            "4",
            "5",
            "8",
            "-11",
            "-8",
            "-5",
            "-4",
            "-9"
        ],
        "non_matches": [
            "13",
            "-25",
            "111",
            "4815",
            "4591",
            "54",
            "48",
            "64",
            "-489",
            "-4854",
            "67tgyu",
            "t6gy"
        ],
        "id": 747,
        "output": [
            {
                "text": "\nr'^[-12\\d\\w]+$'\n\nExercise 4: Identify the pattern\nWrite the pattern to match any string that"
            },
            {
                "text": " \n- \"^[0-2]([-.][0-9]+)[0-9]$\"\n- \"^10$\"\n"
            },
            {
                "text": " \"^[0-9]+$\"\n- a non-numeric character or digit ^^\n- a non-negative and non-zero number 1"
            },
            {
                "text": " (-5\\d|\\d|-5)\nThe resulting Regex is as follows: \n(-5\\d|\\d|-5)"
            },
            {
                "text": " For the pattern \"^-?[0-9]+$\", the regular expression says that the string must start with a literal \"-\" if there is one,"
            },
            {
                "text": " [\\b\\d*[-]?\\d+,\\d*|\\d+,\\d*-?\\d+,\\d*|["
            },
            {
                "text": " [^12]|[13](?:\\.[12]|[1-9])*\nA RegEx to match negative numbers from -12 to 12"
            },
            {
                "text": " match any integer from -12 to 12 (including -12), optionally followed by a non-digit\n\nExercise 3: Create a function named 'check_"
            },
            {
                "text": "\n(?<![+-])\\\\d{1,12}\n(?<![-])^(?<![+-])"
            },
            {
                "text": " I am going to match either an integer between -12 and 12 and a non-negative integer.\n\nExercise Two:\nCreate a basic script to validate"
            }
        ]
    },
    {
        "expression": "^([01][012]|0[1-9])/([0-2][0-9]|[3][0-1])/([0-9][0-9][0-9][0-9])$",
        "raw_prompt": "Regular expression that only allows expression in the format: MM/DD/YYYY",
        "refined_prompt": "Regular expression that only allows expression in the format: MM/DD/YYYY\nMatch examples:\n- \"01/01/2004\"\n- \"01/18/1159\"\n- \"05/31/2631\"\nNon-match examples:\n- \"1/1/04\"\n- \"01/01/04\"",
        "matches": [
            "01/01/2004",
            "01/18/1159",
            "05/31/2631",
            "03/30/3776",
            "10/30/5158",
            "00/31/9275",
            "01/30/2209",
            "01/11/2791",
            "02/31/7476",
            "04/30/5692",
            "10/10/3307",
            "02/18/3193",
            "02/26/4675"
        ],
        "non_matches": [
            "1/1/04",
            "01/01/04",
            "03/32/2004",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 749,
        "output": [
            {
                "text": " You should match and replace only non-matching cases from your string, which leads to the following answer from the website: I would only use the regular expression [0-9][0-9][0"
            },
            {
                "text": " (\\d{2})/(\\d{2})/(\\d{4})\"\n\nExercise 2:\nGenerate a RegEx that allows an expression only in the format: \"name"
            },
            {
                "text": "\n^([0-9]{2})/([0-9]{2})/([0-9]{4})$\n\nExercise 2: Write a Python function that takes in"
            },
            {
                "text": " [1/2/|5/2/|1/1/] or a Regex containing [0-9] for day of month, [0-9]/[0-9]"
            },
            {
                "text": "\n^(01|02|03|04)\\/(01|02|03|04)\\/2021$\nWhere the day is from 01 to 12\n\nExercise 3: Replace only"
            },
            {
                "text": " \\b/\\/(?:0|[1-9]|[1-9]\\d|2[0-6])\\/(?:0|[1-9]|[1-"
            },
            {
                "text": " \"^[0-9]{4}/[0-9]/[0-9]{2}$\"\n\nExercise 4:\n- Create a Python application that returns the"
            },
            {
                "text": " \n(?!^|(?:[\\s\\/]?[1-9]\\/[12][0-9]\\/[3][0-9]\\/[0-9]$"
            },
            {
                "text": " [0-9]{4}/[0-9]{2}/[0-9]{4}(.+?)[0-9]{2}\\s?\n\n"
            },
            {
                "text": " \"^0[1-9]/0[1-2]/\\d{4}$\"\n2. Create a Python program that uses regular expressions and the 'in' operator to validate"
            }
        ]
    },
    {
        "expression": "\\/\\*((?!\\*\\/).)*\\*\\/",
        "raw_prompt": "Strip C style block comments",
        "refined_prompt": "Strip C style block comments\nMatch examples:\n- \"/* comments */\"\n- \"/*\\n*\\n*/\"\n- \"/***********/\"\nNon-match examples:\n- \"// comments\"\n- \"///f34fvfv\"",
        "matches": [
            "/* comments */",
            "/*\\n*\\n*/",
            "/***********/",
            "/* adsfa */",
            "/* f2wef23 */",
            "/* fads32ff2 */",
            "/* f23ewds */",
            "/* fdsdfad */",
            "/* fadsf2ewds */",
            "/* afsd2 */",
            "/* fadsfd2 */",
            "/* jhyjg */",
            "/* jgyy56 */"
        ],
        "non_matches": [
            "// comments",
            "///f34fvfv",
            "////34f2vf*42e",
            "///12/123*/4322",
            "*//2346-2345-2435",
            "*//43.v234",
            "@#dfkjn*av",
            "/5/5/2*0022",
            "//432/524/2*435",
            "//1*-1-2",
            "(0xx12) 6250*9",
            "//12/132/*90"
        ],
        "id": 751,
        "output": [
            {
                "text": " /*/|\\\\s*[*][^*/\\r\\n].*/\n\n\n\nExercise 3: Matching Non-Regular Expression Characters\nWrite a python script using Python's built-in Regex Module to only match characters from: a to z, A to Z"
            },
            {
                "text": " \"/*%(\\\\*(\\\\*(1[0-9]|2[0-4]|[0-9])\\\\))*%*/\"\n\nA:\n\nA string that doesn't contain whitespaces is a simple string that contains only letters,"
            },
            {
                "text": " //|#*[0-9]{3}-*|f[0-9]*[3-9]f[0-9]* \n\"//|#*[0-9]{3}-[0-9]*|f["
            },
            {
                "text": " \"\\s#(.*?)\\s*=\"\nDescription of how to use comments.\nWhat are the different types of comments? (Single line, multi-line, inline). If you want to use multi-line comments, do it as a pair of \\'' and \"#"
            },
            {
                "text": " \"//.*[/\\\\.]*\"\n\nNow that you have practiced writing sample test cases and generated a RegEx, it\u2019s time to test it!\n\nExercise 1: \nWrite a Regex that accepts email from a user. The regular expression should capture"
            },
            {
                "text": " /^/|^(\\n|\\/)'*'/|(\\/.*/){1,2}$/\n\nA:\n\nYou can use re.match for that.\nimport re\n\nregex = [\n     '^*/*',\n     '"
            },
            {
                "text": " \\*\\n*\\n*#\\.*\\n.*\\n\n\nHow to test string matches with RegEx \nThere exists a python library called re that uses regex to match a particular string.\nYou can check documentation to learn more on how to use them."
            },
            {
                "text": " /\\s*/#(.*)[\\n]\\*/g\n\n5. Write a function that takes a string and a list of strings, and returns a list of all strings in the list that appear in the input string.\ndef find_words_in_string("
            },
            {
                "text": " (\\A/\\/[^A-Z_]*\\z)/\nThe following link demonstrates how to generate a regex for the description above. \nGenerate Python Regular Expressions\n\nA:\n\nThe following regexp should do it fine, where\n^\n"
            },
            {
                "text": " \"^[^/*][*].*[*/]#.*$\"\n\nExercise 2: Pattern Matching for HTML Entities\nWrite a REGEX for matching all entities in this string:\n<p class=\"#title\">\n    <h1 class=\"subtitle"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|[12]\\d|3[01])\\.(0[13578]|[13578]|1[02])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|[12]\\d|30)\\.(0[13456789]|[13456789]|1[012])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|1\\d|2[0-8])\\.0?2\\.((1[6-9]|[2-9]\\d)\\d{2}))|(29\\.0?2\\.((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "I did not found a Regex for german date, so I created my own. This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999. As usual, many tests have been made. I think this one should be fine.",
        "refined_prompt": "This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999.\nMatch examples:\n- \"1.1.2004\"\n- \"01.01.2004\"\n- \"29.2.2004\"\nNon-match examples:\n- \"1/1/2004\"\n- \"1-1-2004\"",
        "matches": [
            "1.1.2004",
            "01.01.2004",
            "29.2.2004",
            "29.2.1600",
            "30.12.6216",
            "20.06.1676",
            "14.03.6471",
            "16.02.1943",
            "20.06.2797",
            "01.3.1884",
            "2.08.1886",
            "29.02.3984",
            "30.12.3337"
        ],
        "non_matches": [
            "1/1/2004",
            "1-1-2004",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 754,
        "output": [
            {
                "text": " (re.compile('^(20\\d|20\\d\\d|19\\d\\d|19\\d)\\.\\d{1"
            },
            {
                "text": " (r'\\b(0[1-9]|1\\d|2)\\d\\d-\\d{2}-\\d{4"
            },
            {
                "text": "\n\"^[1-9][0-9]{3}[1-9]\\/[0-9]{2}[0-9"
            },
            {
                "text": " \n^(0,1,\\d):?(\\d\\d)\\d{1,2},?(\\d\\d\\d\\d\\"
            },
            {
                "text": " /^\\d{1,2}\\.\\d{2}\\-(0?\\d|1\\d)[.]\\d{4}/.test"
            },
            {
                "text": "  /^(0|[1-9])|((1[0-2])-)\\d(4)[0-9]{2}$"
            },
            {
                "text": " d[a-z]\\d[a-z]+[.][a-z]\\d{2}|d\\d\\d\\d"
            },
            {
                "text": " ^(0+)[1-3][0-9]{4}\\.[0-9][1-9][0-9][1-9]["
            },
            {
                "text": "\n^\\d{2}.\\d{2}.\\d{4}$\n\nFor the first part, the pattern \\d{2} will"
            },
            {
                "text": "\n(^|\\s)([0-9]+\\.)([/0-9]+)\n\nA:\n\nFor this simple task it seems"
            }
        ]
    },
    {
        "expression": "((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2}",
        "raw_prompt": "Deisgned to verify a MAC address with hex values seperated by a colon.",
        "refined_prompt": "Deisgned to verify a MAC address with hex values seperated by a colon.\nMatch examples:\n- \"00:00:39:F9:3C:59\"\n- \"00:90:83:6A:B3:B7\"\n- \"00:00:39:59:30:5C\"\nNon-match examples:\n- \"00:0H:39:59:30:5C\"\n- \"00:39:59:30:5C\"",
        "matches": [
            "00:00:39:F9:3C:59",
            "00:90:83:6A:B3:B7",
            "00:00:39:59:30:5C",
            "67:8e:69:8b:eA:eE",
            "5e:0F:de:2A:da:Fc",
            "47:8B:36:96:23:d1",
            "5d:b0:b9:F1:Ca:DB",
            "79:C6:A5:Dc:d7:fe",
            "9D:f0:d4:D3:43:c9",
            "55:eA:A7:5D:3F:0B",
            "aD:8B:7d:d2:76:04",
            "de:1A:f9:9c:D8:93",
            "A5:4c:81:b8:A0:73"
        ],
        "non_matches": [
            "00:0H:39:59:30:5C",
            "00:39:59:30:5C",
            "00:39:59:30:5C:BZ",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "AAAAAAA",
            "12f3.21f3.213f",
            "u09nKLJG FSL",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 755,
        "output": [
            {
                "text": "\n- \"00"
            },
            {
                "text": " \"00\\d"
            },
            {
                "text": " [^:]("
            },
            {
                "text": " ([0-1"
            },
            {
                "text": " 00[0-"
            },
            {
                "text": " \n[0"
            },
            {
                "text": " (00(:["
            },
            {
                "text": " Use the ^ and"
            },
            {
                "text": " [00:]["
            },
            {
                "text": " (|(?"
            }
        ]
    },
    {
        "expression": "^\\(0[1-9]{1}\\)[0-9]{8}$",
        "raw_prompt": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.",
        "refined_prompt": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.\nMatch examples:\n- \"(02)12341234\"\n- \"(03)12341234\"\n- \"(05)12341234\"\nNon-match examples:\n- \"00 1234 1234\"\n- \"00-1234-1234\"",
        "matches": [
            "(02)12341234",
            "(03)12341234",
            "(05)12341234",
            "(01)86552606",
            "(07)90772257",
            "(07)17836526",
            "(01)92619887",
            "(02)62624649",
            "(09)68578246",
            "(05)94856935",
            "(04)66145018",
            "(08)53293252",
            "(07)35338722"
        ],
        "non_matches": [
            "00 1234 1234",
            "00-1234-1234",
            "(00)12341234",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 766,
        "output": [
            {
                "text": " ^\\(?\\d{3}\\)?-?\\d{3}\\-?\\d{4}$\n"
            },
            {
                "text": "\n^((\\d{2}\\(-\\d{4}-\\d{4}\\)))?.$\n\n"
            },
            {
                "text": " \n[0-9]1[-1][0-9] [0-9]\n\nThis is used"
            },
            {
                "text": " [^-]*[0-9.]*[0-9]+[0-9]$\n\nThe correct"
            },
            {
                "text": " \n(00|0[1-9]|1[0-2])\\s+(12[34]\\"
            },
            {
                "text": " ^[0-9]{1}\\-.\\d{3}\\.[0-9]{3}$\n\n"
            },
            {
                "text": "\n.{3}(\\d{1,3})([ -][0-9]?[ -]?){"
            },
            {
                "text": " ^\\(\\d{1}[-]\\d{3}\\)\\s*\\d{3}[-]"
            },
            {
                "text": "\n^[ (]?(?=(\\d{2})+(?!\\d|$))(?+=\\d"
            },
            {
                "text": " /^[1-9]\\\\d?\\\\d((\\\\-(\\\\-\\\\d{3})*))$/"
            }
        ]
    },
    {
        "expression": "^((\\s|[0])\\.(\\d{0,2}\\s{0,2}))?$|^(\\.(\\d\\s){0,2})?$|^(\\s{0,4}[1]{0,1}\\.[0]{0,2}\\s{0,4})?$|^(\\s{0,4}[1]{0,1}\\s{0,4})?$|^(\\s{0,4}[0]{0,4}[1]{0,1}\\s{0,4})?$|^([0]{0,4}\\s{0,4})?$|^(\\s{0,3}[0]{0,3}\\.{1}\\d{0,2}\\s{0,2})?$",
        "raw_prompt": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.\nAllows 1.0, 1.00, 1, 1., .9, .90, 0.90.",
        "refined_prompt": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.\nMatch examples:\n- \".99\"\n- \"1.\"\n- \"0.99\"\nNon-match examples:\n- \"10\"\n- \"0100\"",
        "matches": [
            ".99",
            "1.",
            "0.99",
            "0.98",
            "0.65",
            "0.45",
            "0.82",
            "0.97",
            "0.64",
            "0.31",
            "0.21",
            "0.53",
            "0.65"
        ],
        "non_matches": [
            "10",
            "0100",
            "1.01",
            "-123",
            "156",
            "4865",
            "85.489562",
            "4895",
            "383512.",
            "0.51234",
            "5613.12",
            "1523"
        ],
        "id": 772,
        "output": [
            {
                "text": ".*[0-9].*\n\nExercise 2: Replace all spaces in a sentence to dashes (-). \nTo replace spaces with dashes, make every space"
            },
            {
                "text": " \n[\\d.,]\\d+(?:\\.\\d+)[a-zA-z ]?\nExercise 9: Write a Python function which takes in"
            },
            {
                "text": " \n- (^0|[1-9]|1([1-9]?[0]?))$\n\n2. Write a RegEx for a file"
            },
            {
                "text": ".\n\nWrite a regular expression for:\n- [0-9]{3} [a-z]\nAnswer: \\d{3}[a-z]+"
            },
            {
                "text": ".2|2.3\n\nI'm having some trouble with my RegEx:\nRegex RegEx1 = new Regex(\"^[A-Za-z"
            },
            {
                "text": ".?\\d*\\.\\d*?\nThe \"?\" characters allow a single character to occur zero or one time, including in the range \"0\" to \"9\","
            },
            {
                "text": " r'(-\\.)?\\d*[0-9]?(-\\.)?\\d+'\nHere's a nice discussion on regex.\nPython regex basics for"
            },
            {
                "text": "\\[\\d{1,4}\\.\\]\n\n2. What does ^\\d{0,4}\\.\\d{0,2}$ mean?"
            },
            {
                "text": " \"^[1-9]\\\\.\\\\d*$\"\n\nA:\n\nTry something like:\n^\\d{1,4}\\.\\d{"
            },
            {
                "text": " /^\\d{1}|\\d{2}\\.\\d{1}$/i\n\nFor a maximum of 3 characters All values between 0.00 and"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z][a-zA-Z0-9_]+$",
        "raw_prompt": "Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character.\nWe use that to make sure the provided string can be a variable/entity name.",
        "refined_prompt": "Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character. We use that to make sure the provided string can be a variable/entity name.\nMatch examples:\n- \"MyVariable\"\n- \"intWhatever\"\n- \"Blah_Blah\"\nNon-match examples:\n- \"1stVariable\"\n- \"654\"",
        "matches": [
            "MyVariable",
            "intWhatever",
            "Blah_Blah",
            "tfygh",
            "tfygu7yug",
            "tfyg67tygt",
            "erdt67t",
            "io98uy",
            "er4ert",
            "tyh_56ty",
            "tfy76gty",
            "we3e",
            "q2w3e4r5t6y"
        ],
        "non_matches": [
            "1stVariable",
            "654",
            "_asdasd_234",
            "45edrtfc5rdt",
            "90uihyy",
            "_)I(U*IH",
            "_)I(HUBJ",
            "_)(UIH",
            "^&TGYVH_^FTY",
            "#W$EDR",
            "54RFTGVNKJML",
            "&GYH"
        ],
        "id": 775,
        "output": [
            {
                "text": " [^A-Za-z0-9_][^A-Za-z0-9_]*. The"
            },
            {
                "text": " [a-zA-Z_]{0,31}|[a-zA-Z0-9_]["
            },
            {
                "text": "\n\"^([a-zA-Z0-9_]+)$\" for any string that must start with alph"
            },
            {
                "text": " \n[^a-zA-Z0-9_\\s]+\n\nA:\n\nThis is because you"
            },
            {
                "text": "  ^[a-zA-Z][\\w0-9]*$\n- \"__BLAH__\"\n"
            },
            {
                "text": " ValidName = ^[a-zA-Z\\_\\-]{0,30}\\_[a-zA-"
            },
            {
                "text": "\n[a-zA-Z_][a-zA-Z0-9_]*[a-zA"
            },
            {
                "text": " \"^\\w+$\".\n\nExercise 4:\nUsing the code example from the second exercise, modify the `gener"
            },
            {
                "text": " ^[0-9a-zA-Z_]+$\n```python\n# Importing Required Module\nimport re"
            },
            {
                "text": " \n.*\\D*[a-z]\\d*|[a-z]\nNon-greedy operator *"
            }
        ]
    },
    {
        "expression": "((([7-9])(\\d{3})([-])(\\d{4}))|(([7-9])(\\d{7})))",
        "raw_prompt": "Express&#227;o para a Valida&#231;&#227;o de Telefones Celulares sem o DDD valida celulares com inicio igual a 7,8 e 9.",
        "refined_prompt": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"",
        "matches": [
            "9999-9595",
            "88888787",
            "7777-6589",
            "7189-9372",
            "81166314",
            "74505791",
            "9866-2913",
            "8156-1727",
            "7556-6919",
            "72658873",
            "97176270",
            "98971523",
            "85785684"
        ],
        "non_matches": [
            "44445555",
            "2222-9658",
            "22223658",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 778,
        "output": [
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F])*$",
        "raw_prompt": "Expression validating a hex string of any length.",
        "refined_prompt": "Expression validating a hex string of any length.\nMatch examples:\n- \"1E3\"\n- \"82E5AAA4\"\n- \"01ff\"\nNon-match examples:\n- \"1g3\"\n- \"4Z\"",
        "matches": [
            "1E3",
            "82E5AAA4",
            "01ff",
            "8456",
            "89456",
            "89456A",
            "56489",
            "65AF",
            "6513846F",
            "5613BC",
            "6456F8465",
            "8465A465",
            "8465BCD"
        ],
        "non_matches": [
            "1g3",
            "4Z",
            "01x",
            "y78u",
            "gyu78gyu",
            "ftye1wqd",
            "67fty",
            "7d6ty4sdr",
            "s4er5dt7gyu9hivyu",
            "ft7y",
            "67ycu",
            "67cytu"
        ],
        "id": 782,
        "output": [
            {
                "text": " Non-matching hex string of length >= 16. \n\nExercise 5:\nGenerate a RegEx for checking to see if a string of alphanumeric characters only appears once in a larger string, where a smaller string may contain repeated characters within the larger string.\nAnswer"
            },
            {
                "text": " \\d{2}\\d(?=\\d)\\d{3}\n\nExercise 2:\nCreate a Python program that takes in a regular expression string with quotes around the characters to match. The program should then extract all matching substrings using the regex module and use a context"
            },
            {
                "text": " ^[0-9]+[0-9a-fA-F]+[0-9]{1,8}$\n\nExercise 3:\nDefine a function that takes a string as input and returns True if it starts and ends with the same character and False"
            },
            {
                "text": "\n\\b[0-9a-fA-F]{1,32}\\b\n\n2. \nWrite a RegEx expression that extracts the date format from the following string:\n\"July 01 22 2022 16:30:32.25\"\nMatch examples:"
            },
            {
                "text": " (0-9A-Fa-f)9 + (8-9) times, with a length of 10.\n\n\n# Chapter: The use of Python User Input for Financial Analysts\n\n## Sections\n\n1. Introduction\n2. Basics of Python User Input\n"
            },
            {
                "text": " (\\d+|[a-fA-F0-9]{4})\n\n\n# Chapter: The use of Python Tuples for Forensic Computer Analyst\n\nThis chapter will cover the following sections:\n\n1. Introduction to Python Tuples\n2. Creating and"
            },
            {
                "text": " ^[0-9A-Fa-f]{4,}$\n\n4. Write Python code to validate that a user's password meets the following conditions:\n\n- At least 8 characters long\n- Contains at least one uppercase letter and one lowercase letter\n"
            },
            {
                "text": " [0-9a-f][0-9a-f] \n\n5. Create a new Python code to test the validity of a user-specified hex string.\nHint: Use the RegEx check function you learned earlier and add in error handling.\n\n**"
            },
            {
                "text": " The pattern should be any string of 4 characters, and may include valid hex charaters\n\n4. Exercise: Regex expression for parsing an API header that starts with \"Content-Type:\".\nGenerate a RegEx that matches a string that starts with the letter 'C' and"
            },
            {
                "text": "\n[01]?[0-9A-Fa-f]+$\n\n\n3. Given a list of integers, extract only the even numbers and convert each integer to its binary. Note: Use re to generate the list of integers.\nMatch examples:\n- [8,"
            }
        ]
    },
    {
        "expression": "(?=^.{6,255}$)((?=.*\\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*",
        "raw_prompt": "THE Complex Password Filter Matching 3 of 4 Character catagories:\n1.) at least 1 upper case character\n2.) at least 1 lower case character\n3.) at least 1 numerical character\n4.) at least 1 special character\nIt also enforces a min and max length and works for .Net and script Regex implimentations.",
        "refined_prompt": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for .Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"",
        "matches": [
            "Passw0rd",
            "assW@rd",
            "1B2a345@#$%",
            "^TVYGUt7yu(*",
            "GHUFDhu76^&",
            "67ftyv^%FTY",
            "56rfty&^GYU",
            "90ijioU(*IJO",
            "S#EWfsdff23f32",
            "3W$ES23d",
            "E$R%$Rtyfvf67",
            ")(IJO0ijo",
            "*&GUY8gui87g"
        ],
        "non_matches": [
            "123123123",
            "Password",
            "asdf&amp;",
            "dfiush",
            "IJBUIU*&*(",
            "F^&YGUF^%T&F^",
            "&^FGYU",
            "%F^RT*(",
            "8y9H",
            "F&^",
            "TV&",
            "vYT&"
        ],
        "id": 783,
        "output": [
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a password"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a 12"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a Random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a Password"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a 4"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            }
        ]
    },
    {
        "expression": "^[9]9\\d{10}|^[5]\\d{10}",
        "raw_prompt": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.",
        "refined_prompt": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"",
        "matches": [
            "991234567890",
            "51234567890",
            "57960452339",
            "55830345500",
            "998834347341",
            "50284016262",
            "991942628729",
            "992933733018",
            "998061531148",
            "56537583637",
            "59768489509",
            "998085897972",
            "56839621590"
        ],
        "non_matches": [
            "99123456789",
            "91234567890",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "AAAAAAA",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 787,
        "output": [
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description. The"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description. This"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description. It"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            }
        ]
    },
    {
        "expression": "^([a-zA-z\\s]{4,32})$",
        "raw_prompt": "This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) &amp; should be of minimum length 4 &amp; maximum length 32. Only white spaces are allowed apart from alphabets.",
        "refined_prompt": "This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) &amp; should be of minimum length 4 &amp; maximum length 32. Only white spaces are allowed apart from alphabets.\nMatch examples:\n- \"some body\"\n- \"hey there\"\n- \"hello\"\nNon-match examples:\n- \"hi\"\n- \"hey 27\"",
        "matches": [
            "some body",
            "hey there",
            "hello",
            "fsad fdsi",
            "uihf fsui",
            "hiufss",
            "uihbfsud",
            "hui buib",
            "vuiv biu",
            "biu bhivu",
            "buiv shdjfu",
            "bufisd uifbds",
            "buif sbdfiu"
        ],
        "non_matches": [
            "hi",
            "hey 27",
            "hell?",
            "78gyuhui",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "aa"
        ],
        "id": 797,
        "output": [
            {
                "text": " /^[A-z ]+$/\n\nExercise 2:\n\nUsing RegEx,"
            },
            {
                "text": " \"^[A-Za-z]{0,30}$\" \n\nYou can"
            },
            {
                "text": " /^\\s?[a-z0-9]+$|\\s*[^a-"
            },
            {
                "text": " \\b[A-Za-z][A-Za-z _0-9]{"
            },
            {
                "text": " ^[a-zA-Z ]{3,32}$\n\n2. Find all the"
            },
            {
                "text": " \\w{4}\n\nStep 3: Validating a phone number\nHere we see some more use"
            },
            {
                "text": " /^[A-Z]{3,30}[a-z][a-zA-"
            },
            {
                "text": " At least a min of 1 character alphabet & white spaces a maximum of 80 alphabets. \n"
            },
            {
                "text": " [a-z0-9]{1,32}\n\n# 16.2.9"
            },
            {
                "text": " [A-Za-z\\s]{4,32} \n\n## Explanation of"
            }
        ]
    },
    {
        "expression": "^(^(([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){5}::[0-9A-F]{1,4})|((:[0-9A-F]{1,4}){4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){3}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|(:[0-9A-F]{1,4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,5})|(:[0-9A-F]{1,4}){7}))$|^(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,6})$)|^::$)|^((([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){3}::([0-9A-F]{1,4}){1})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){1}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|((:[0-9A-F]{1,4}){0,5})))|([:]{2}[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})):|::)((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})\\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})$$",
        "raw_prompt": "Matches all IPv6 text representations as defined within RFC 2373. Fairly verbose",
        "refined_prompt": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654:3210:1234\"",
        "matches": [
            "::0:0:0:FFFF:129.144.52.38",
            "FEDC:BA98::3210:FEDC:BA98:7654:3210",
            "::13.1.68.3",
            "D164::D:5F:E663:12.254.254.227",
            "898:2:B4D:EB:114:9:0CE6:C04",
            "A052:A4:B877::0192:5:255.224.081.254",
            "::A90:9B:82:241.248.202.200",
            "::251.212.205.02",
            "::252.220.0.129",
            "::212.208..5",
            "::6FEE:B8F:6:2F",
            "::26:226.208.242.253",
            "::252.223.225.255"
        ],
        "non_matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234",
            "3210:FEDC:BA98:7654:3210:1234",
            ":FEDC:BA98:7654:3210:",
            "D164::D:5F:E663:12.254.254.227fsda",
            "fsdaf898:2:B4D:EB:114:9:0CE6:C04",
            "afdsA052:A4:B877::0192:5:255.224.081.254",
            "f2ed::A90:9B:82:241.248.202.200",
            "f3we::251.212.205.02",
            "fads::6FEE:B8F:6:2F",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 799,
        "output": [
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            }
        ]
    },
    {
        "expression": "^([0-9]{3,4})$",
        "raw_prompt": "Allows you to check the length of a number (in this case either 3 or 4 digits).\nI found it useful when validating Credit Card Identification Codes (CVV2/CVC2/CID) which are either 3 or 4 numerical digits.",
        "refined_prompt": "Allows you to check the length of a number (in this case either 3 or 4 digits).\nMatch examples:\n- \"123\"\n- \"1234\"\n- \"456\"\nNon-match examples:\n- \"12\"\n- \"12345\"",
        "matches": [
            "123",
            "1234",
            "456",
            "4561",
            "678",
            "753",
            "789",
            "156",
            "213",
            "546",
            "789",
            "1564",
            "4856"
        ],
        "non_matches": [
            "12",
            "12345",
            "15",
            "97",
            "4",
            "6",
            "8",
            "89456123",
            "489561",
            "4856f23",
            "fe23",
            "5r6f"
        ],
        "id": 801,
        "output": [
            {
                "text": " (any number from 8 to 10digits)\n\n```python\npattern_8digits = \"^(?P<first>[0-9]{8,})(?P<second>[0-9]{8,})$\"\npattern_9dig"
            },
            {
                "text": " Non-match examples must start with a number. No numbers can start with a number.\"\n\n3. Using the same example, match non-match examples:\n- \"12345\"\nAnswer: No numbers can start with a number. \n\n4. Use the python concept"
            },
            {
                "text": " \\b[0-9]{3}(?!\\d)\\b|\\b[0-9]{4}\\b|\\b[0-9]{5}\\b\n\n(5) Write a script to ask the user for an input and check if it"
            },
            {
                "text": " \n- \"(\\\\d\\\\d)\\\\s\\\\d\\\\s\\\\d$\"\n- \"\\\\d{3,4}\"\n- \"^\\\\d{3,4}$\"\n- \\D\n\nA:\n\nUse \\d in your regex,"
            },
            {
                "text": " /^(1[2-9]|[1-9]\\d{0,2}|120)\\d(1[2-9]|[1-9]\\d|1[0-2])$/\nYou can see that the regex validates"
            },
            {
                "text": " (at least 3 digits).\n\n```python\nimport re\n\nnum1 = \"123\"\nnum2 = \"1234\"\nnum3 = \"456\"\nnums = [num1, num2, num3]\n\nfor n in nums:"
            },
            {
                "text": " [^0-9]?[0-9]\\d|[0-9]\\d[^0-9]|[^0-9]\\d?[0-9] \n\n5. Generate a RegEx for this description. \n"
            },
            {
                "text": " (a|10b)  (a or b, one or more times) (a-z, A-Z or a-z) (number 0-9) \n- \"12a\"Generate a RegEx for this description.\nAnswer: (a|10"
            },
            {
                "text": "\n ^(\\d{0,3})(\\d{3}|\\d{4})$\n\n3. Match numbers in a string. For each match, replace the first occurrence of the match with the digits you want. Try with\n  \"0123456789"
            },
            {
                "text": "\n```python\n# Solution to Exercise 1\npattern = \"^[3412]$\"\ntexts = [\"123\", \"1234\", \"456\", \"12\", \"12345\"]\nresult = [text for text in texts if re.match(pattern, text"
            }
        ]
    },
    {
        "expression": "^([a-zA-z\\s]{2,})$",
        "raw_prompt": "This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires atleast 2 characters &amp; there's no limit on maximum number of characters.",
        "refined_prompt": "This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires at least 2 characters &amp; there's no limit on maximum number of characters.\nMatch examples:\n- \"Amit Gupta\"\n- \"Some Body\"\n- \"hello world\"\nNon-match examples:\n- \"A\"\n- \"Someplace23\"",
        "matches": [
            "Amit Gupta",
            "Some Body",
            "hello world",
            "test test",
            "ABC DEF",
            "jfiosd fsjdi",
            "jfiods fnsui",
            "iuyw urhwe",
            "uihd huifhs",
            "ihuf uhfd",
            "jiofs hyq",
            "poip fsd",
            "ruwe fsda"
        ],
        "non_matches": [
            "A",
            "Someplace23",
            "New-Jersey",
            "fewd23",
            "f23edg4rgggg32",
            "g5r42ef",
            "u9i9",
            "t76",
            "0u9",
            "g78hg8D%R",
            "5dRT",
            "%$DRT"
        ],
        "id": 803,
        "output": [
            {
                "text": " You could use ^[a-zA-Z ]{2,}$\n5. [2-6] Any Range of Character?\n"
            },
            {
                "text": " (^[\\w\\s]{2,15}$)(?=.{4}$)\n\nYou can learn more from:"
            },
            {
                "text": " /^[A-Za-z ]+$/\n\nSolution:\n\n```python\n#Example 1\nimport re\n\n"
            },
            {
                "text": " [^a-zA-Z0-9\\s]\n(I think this answer is correct: [^a-zA-Z"
            },
            {
                "text": " (\\w+) (\\d+) (\\w+)\\s(\\w+) (\\w+)\\s(\\w+, (\\d+))"
            },
            {
                "text": "\n ^(([a-zA-Z ]+\\w*?)+)$ \nHere's a small example. \n#include\u00a0"
            },
            {
                "text": " Generate a RegEx for this description using [a-zA-z\\s] character as a character set\n- \"A\"\n-"
            },
            {
                "text": " (?<=\\b[A-Z]\\w*)(?=\\b.*white\\b)\n\nIn first group the word"
            },
            {
                "text": "\n(?<=^|[,\\s])([a-zA-Z]){3,20}$\nTo avoid capital"
            },
            {
                "text": " \n[A-Za-z ]{1,10}\nNote that the limit isn't optional: it should have any combination of letters"
            }
        ]
    },
    {
        "expression": "^\\+?972(\\-)?0?[23489]{1}(\\-)?[^0\\D]{1}\\d{6}$",
        "raw_prompt": "Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)",
        "refined_prompt": "Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)\nMatch examples:\n- \"+972-4-8253055\"\n- \"972-4-8615466\"\n- \"972-04-8564521\"\nNon-match examples:\n- \"04-5487665\"\n- \"05-455665545\"",
        "matches": [
            "+972-4-8253055",
            "972-4-8615466",
            "972-04-8564521",
            "+972-86842905",
            "+972-3-8441944",
            "972-046893540",
            "972-04-3970699",
            "972-04-3970699",
            "97242897572",
            "972-037549881",
            "972-09-6346942",
            "+97242897402",
            "972-022722133"
        ],
        "non_matches": [
            "04-5487665",
            "05-455665545",
            "456884624",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "43-5432",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "0j0jweBBBB"
        ],
        "id": 804,
        "output": [
            {
                "text": "\n("
            },
            {
                "text": " \\b"
            },
            {
                "text": " ([0"
            },
            {
                "text": " \\d"
            },
            {
                "text": " \n"
            },
            {
                "text": " (^"
            },
            {
                "text": " (^"
            },
            {
                "text": ".*"
            },
            {
                "text": " /^"
            },
            {
                "text": "\n/("
            }
        ]
    },
    {
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){1,2}(\\ [AaPp][Mm]))$",
        "raw_prompt": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.",
        "refined_prompt": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.\nMatch examples:\n- \"1:45 am\"\n- \"12:01 aM\"\n- \"01:23 pm\"\nNon-match examples:\n- \"13:34 am\"\n- \"1:60 am\"",
        "matches": [
            "1:45 am",
            "12:01 aM",
            "01:23 pm",
            "11:59 pm",
            "04:28 pM",
            "08:00 Am",
            "04:32 pm",
            "03:06 Am",
            "11:28:59 Pm",
            "11:51 Pm",
            "8:20 am",
            "06:53:59 Am",
            "1:13 aM"
        ],
        "non_matches": [
            "13:34 am",
            "1:60 am",
            "13:45",
            "12/123/4322 PM",
            "51:534",
            "43.v2344 PM",
            "89:569",
            "48:97 PM",
            "65:23 pm",
            "1-1-2 am",
            "(0xx12) 62509",
            "32542 am"
        ],
        "id": 805,
        "output": [
            {
                "text": " \n(?i)(?=([ ]*[0-9])+)((12:|3[0-1"
            },
            {
                "text": " ([0-9]{1,2}[:.][0-9]{2})[:.][0-"
            },
            {
                "text": "\n```python\nimport re\n\n# The pattern used to check if the first character of the string is an uppercase"
            },
            {
                "text": " \n\\d{1,2} | [A-Z](?: [A-Z]|am|pm)\n"
            },
            {
                "text": " (?:\\d\\d?:\\d\\d):(\\d\\/)?[ap]m (e.g. 1:"
            },
            {
                "text": " \"([0-9]{1,2}\\s?)[^ ]([0-9]{1,2}:["
            },
            {
                "text": " \"^1[0-2]|3[0-1]$|[0-9]?[0-9"
            },
            {
                "text": " (2^0*[1-9]|10) ([1-9]) (am|pm|A|P)"
            },
            {
                "text": " \"1:[0-6][0-9]\"\n\n9. If you want to capture the starttime of a piece of"
            },
            {
                "text": " \nDescription: Match any number 1-24\n- \"12:01 aM\"\n- \"1:24 aM"
            }
        ]
    },
    {
        "expression": "^\\d{5}((-|\\s)?\\d{4})?$",
        "raw_prompt": "Single field zip code validator, useful for Web Forms. Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.",
        "refined_prompt": "Single field zip code validator, useful for Web Forms. Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.\nMatch examples:\n- \"92078-4705\"\n- \"920784705\"\n- \"92078 4705\"\nNon-match examples:\n- \"9027x\"\n- \"902\"",
        "matches": [
            "92078-4705",
            "920784705",
            "92078 4705",
            "22393",
            "54968",
            "85050",
            "99350-8649",
            "79787-1343",
            "87163-0442",
            "88206-1513",
            "31360-8551",
            "363700404",
            "22774",
            "22393",
            "54968",
            "85050",
            "99350-8649",
            "79787-1343",
            "87163-0442",
            "88206-1513",
            "31360-8551",
            "363700404",
            "22774"
        ],
        "non_matches": [
            "9027x",
            "902",
            "92078.4705",
            "12/123/4322",
            "51:534",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90",
            "12/123/4322",
            "51:534",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 814,
        "output": [
            {
                "text": "\n- (.+?)-\\d{4}($| - $|)\nA full explanation of what the above regex"
            },
            {
                "text": " 902x or 902 \nExercise 3: Create a dictionary called \"phone_numbers\". It should have three"
            },
            {
                "text": " -\\d\\d-\\d\\d\\d\n- What are Regular Expressions?\nThis is how you generate"
            },
            {
                "text": "\n.+?(?<= - )?([0-9]{5}).*?(?<="
            },
            {
                "text": "\n'^(\\w{3,5}[-\\s]|\\d{4}\\s?\\d{"
            },
            {
                "text": " This is a regex that allows 5 digits from 0-9, or between two digits, with a hyphen between or without space"
            },
            {
                "text": " 9027\\d{3}-[\\d \\., \\!\\?]+\nUsing list comprehension, create a list of"
            },
            {
                "text": " \"^(?=.*\\d)(?=.*[a-z])[a-z0-9 ]*"
            },
            {
                "text": "   ^\\d[1-9]\\d{0}\\d\\d$|^\\d1\\d\\"
            },
            {
                "text": " [0-1][0-9]{4,5}\n\n2. Write a Python function that takes a list"
            }
        ]
    },
    {
        "expression": "^\\d{5}((\\-|\\s)?\\d{4})?$",
        "raw_prompt": "Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits.",
        "refined_prompt": "Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits.\nMatch examples:\n- \"92078\"\n- \"92078-4705\"\n- \"92078 4705\"\nNon-match examples:\n- \"920781\"\n- \"920a87\"",
        "matches": [
            "92078",
            "92078-4705",
            "92078 4705",
            "264455497",
            "131416218",
            "99746",
            "054229695",
            "664133458",
            "09864",
            "899195591",
            "56954",
            "58489",
            "89987"
        ],
        "non_matches": [
            "920781",
            "920a87",
            "920",
            "1965189",
            "849561",
            "845168",
            "489698",
            "4821",
            "9516-9516",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 815,
        "output": [
            {
                "text": " \\b(?:\\d{5}[\\s-]?){4}\\d{5}\\b\n\n"
            },
            {
                "text": " (\\d{5})-(\\d{4})\n\n3. Use positive lookaheads. Write a Python"
            },
            {
                "text": " r'^(\\d{5})-(\\d{4})$'\n\nLecture Note:\n"
            },
            {
                "text": ".*?(\\d{5})(-(0[1-9]|1[012])|(\\d{"
            },
            {
                "text": " To match Zip codes of a specific range, you can use an online reference, such as https://www.geocode"
            },
            {
                "text": " \"\\d{2}\\s(?=\\d{2})\\d{2}\\s?-?\\d"
            },
            {
                "text": " ^[0-9]{1,3} [0-9][0-9][0-9][0"
            },
            {
                "text": " \\bb\\d{5}\\s+-\\d{4}\\b\n\n##### Exercise 2: \n"
            },
            {
                "text": "\nzip^5-5-(...-4) \n\nWhat is a URL?\nA URL is a Uniform"
            },
            {
                "text": " (You should provide 5-10 matching patterns to test it)\n\n4) What is a RegEx for this description"
            }
        ]
    },
    {
        "expression": "[1-2][0|9][0-9]{2}[0-1][0-9][0-3][0-9][-][0-9]{4}",
        "raw_prompt": "Swedish person number. Don't work on persons older then 100 years, but they are so few that it shouldn't be a problem. Easy to fix, but I choose not to accept oldies...",
        "refined_prompt": "Swedish person number.\nMatch examples:\n- \"19740609-7845\"\n- \"19811116-7845\"\n- \"20010913-7598\"\nNon-match examples:\n- \"21003612-9999\"\n- \"18790505-4545\"",
        "matches": [
            "19740609-7845",
            "19811116-7845",
            "20010913-7598",
            "20560634-8465",
            "10291017-1578",
            "19631222-3119",
            "29561336-3749",
            "10081438-9776",
            "10131537-6611",
            "20831709-9312",
            "20031727-7466",
            "20501922-6283",
            "20081625-4758"
        ],
        "non_matches": [
            "21003612-9999",
            "18790505-4545",
            "19740641-5559",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "4515-516",
            "49156-984516",
            "489561-98456",
            "-4516-561",
            "98465-8456",
            "8945623-984561"
        ],
        "id": 817,
        "output": [
            {
                "text": " [A-E]\\\\d{4}-[A-E]\\\\d{4}-[A-E]\\\\d{4}-[A-E]\\\\d{1}\n\nExercise 2: Check if"
            },
            {
                "text": " (\\d{4}-\\d\\d-\\d\\d)-(\\d\\d-\\d\\d-\\d\\d)/(\\d\\d-\\d\\d-\\d\\d)/(\\"
            },
            {
                "text": " \"^\\d+-\\d+-\\d+$\"\n\n\n\nQuestion 5: A rectangular swimming pool has a length of 15 meters and a width of 8 meters. The pool is being filled with water at a"
            },
            {
                "text": " Match any string that only starts with 4 or 7 consecutive digits, followed by a non-digit, followed by a digit, followed by a non-digit.\n\nExercise 2: Use RegEx to match a description that follows a"
            },
            {
                "text": " \"^[A-Z0-9]{4,10}-${y}([0-9]{3})?$\" (year) and (month) digits.\n\n2. You\u2019re writing"
            },
            {
                "text": "  ^[0-9]{4}-[0-9]{2}[0-9]-[0-9]{2}[0-9]$ \nExercise 2 \nCreate a regex for"
            },
            {
                "text": " ([a-zA-Z0-9]{1,9})([a-zA-Z0-9\\-]{3,10}?)(\\d+)\\d+\nThis will create a regex that"
            },
            {
                "text": " ^\\d{4}$\n\nExercise 4:\nMatch the following descriptions with their respective languages: \n\nDescription: \n- English phonetics\n- Japanese phonetics\nAnswer: \n- English phonetics"
            },
            {
                "text": " (^.*[1-5][1-9]*-).*([0-9]).*-[0-9]*$\n\nNow that we've covered the basics, let's explore some real-world use cases"
            },
            {
                "text": " \n\n[a-jJ-zA-Z].[a-jJ-zA-Z0-9\\-]{13-9}[a-jJ-zA-Z0-9\\-"
            }
        ]
    },
    {
        "expression": "^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$",
        "raw_prompt": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\n(rizzipereira.com.br)\nFor Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250",
        "refined_prompt": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"",
        "matches": [
            "10.03.1979",
            "12/30/2004",
            "01/01/2004",
            "07/6.84",
            "10/03-3505",
            "12-28/37",
            "09-8-07",
            "9.30-9000",
            "6/02-7535",
            "12.09/74",
            "10-2-6908",
            "11.2.32",
            "10-31-77"
        ],
        "non_matches": [
            "09--02--2004",
            "15-15-2004",
            "13/12/2004",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 822,
        "output": [
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: [02-0]["
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: [01].[31"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: dd.(01|02"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: (?<month>"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: (?i)(^"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: ^0*((1"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: (\\d{1"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: [a-zA"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: -(1 or more"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: (0..) or"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$",
        "raw_prompt": "Matches the date format &quot;YYYY-mm-dd&quot; and also validates month and number of days in a month. All leap year dates &quot;YYYY-02-29&quot; passes trough. Could easily be changed to another format.",
        "refined_prompt": "Matches the date format &quot;YYYY-mm-dd&quot; and also validates month and number of days in a month. All leap year dates &quot;YYYY-02-29&quot; passes trough.\nMatch examples:\n- \"2004-04-30\"\n- \"2004-02-29\"\n- \"4214-06-30\"\nNon-match examples:\n- \"2004-04-31\"\n- \"2004-02-30\"",
        "matches": [
            "2004-04-30",
            "2004-02-29",
            "4214-06-30",
            "2509-01-30",
            "0881-02-29",
            "7644-02-08",
            "6740-10-04",
            "0519-05-01",
            "5214-08-21",
            "9459-09-30",
            "3512-09-17",
            "5617-02-01",
            "5381-11-30"
        ],
        "non_matches": [
            "2004-04-31",
            "2004-02-30",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 823,
        "output": [
            {
                "text": " The example date format uses d"
            },
            {
                "text": " \n^(?P"
            },
            {
                "text": " \n^(\\d{"
            },
            {
                "text": " ^((?:\\d{"
            },
            {
                "text": "\n(0[1-"
            },
            {
                "text": "\nMy attempt went as this"
            },
            {
                "text": " A RegEx that matches any"
            },
            {
                "text": " Date should follow the format of"
            },
            {
                "text": " (\\d\\d-"
            },
            {
                "text": "  (YMDY)"
            }
        ]
    },
    {
        "expression": "^((?:2[0-5]{2}|1\\d{2}|[1-9]\\d|[1-9])\\.(?:(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)\\.){2}(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)):(\\d|[1-9]\\d|[1-9]\\d{2,3}|[1-5]\\d{4}|6[0-4]\\d{3}|654\\d{2}|655[0-2]\\d|6553[0-5])$",
        "raw_prompt": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port. More to come, maybe :)",
        "refined_prompt": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port.\nMatch examples:\n- \"127.0.0.1:80\"\n- \"255.255.255.0:21\"\n- \"1.0.0.0:1\"\nNon-match examples:\n- \"0.0.0.0:1\"\n- \"256.1.1.1:20\"",
        "matches": [
            "127.0.0.1:80",
            "255.255.255.0:21",
            "1.0.0.0:1",
            "46.243.1.167:751",
            "160.154.243.9:4",
            "4.0.215.102:65513",
            "253.224.59.103:55",
            "143.127.244.222:62820",
            "253.110.9.6:62523",
            "65.220.200.196:55954",
            "31.172.165.185:7",
            "212.84.221.220:55",
            "67.233.1.202:736"
        ],
        "non_matches": [
            "0.0.0.0:1",
            "256.1.1.1:20",
            "127.0.0.1:65536",
            "12/123/4322",
            "123.456.789",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "abc111def",
            "12/132/90"
        ],
        "id": 827,
        "output": [
            {
                "text": " \"ip:port\\/[0-9a-f]{"
            },
            {
                "text": " The general pattern for a IP address is IP v4 - v4"
            },
            {
                "text": " [\\s]{3}[0-9]+[."
            },
            {
                "text": "\n(?:\\d{1,3}\\.){3}\\"
            },
            {
                "text": " \n(\\b\\d{1,3}\\.){3"
            },
            {
                "text": " \n\n```python\nimport re\nip_list ="
            },
            {
                "text": " \"^[0-9]+.\\d+$\"\n"
            },
            {
                "text": " ^((0|\\+|\\-)?\\d\\.?"
            },
            {
                "text": " 0.0.0.0 - matches 0.0.0"
            },
            {
                "text": " \n127.0.0.1|255.255."
            }
        ]
    },
    {
        "expression": "^(9,)*([1-9]\\d{2}-?)*[1-9]\\d{2}-?\\d{4}$",
        "raw_prompt": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.",
        "refined_prompt": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"",
        "matches": [
            "9,5143393044",
            "9,514-339-3044",
            "339-3044",
            "489-8745",
            "485-8796",
            "489-8794",
            "823-4896",
            "879-8154",
            "846-8795",
            "812-9876",
            "213-4589",
            "321-6547",
            "987-6543"
        ],
        "non_matches": [
            "9,339 3044",
            "514 440 2009",
            "(514) 440-2009",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 831,
        "output": [
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx search"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx for"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx pattern"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx that"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx string"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx for"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx for"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx that"
            }
        ]
    },
    {
        "expression": "^\\-?\\(?([0-9]{0,3}(\\,?[0-9]{3})*(\\.?[0-9]*))\\)?$",
        "raw_prompt": "Match a positive or negative decimal value with any precision and scale. Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number.",
        "refined_prompt": "Match a positive or negative decimal value with any precision and scale. Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number.\nMatch examples:\n- \"0.123\"\n- \"(1234.123)\"\n- \"-01,200\"\nNon-match examples:\n- \"2.3.123\"\n- \"1,23.45\"",
        "matches": [
            "0.123",
            "(1234.123)",
            "-01,200",
            "516",
            "548",
            "864",
            "456",
            "846.465",
            "4856.65",
            "516.156",
            "-489.51",
            "-789.1254",
            "-489.21"
        ],
        "non_matches": [
            "2.3.123",
            "1,23.45",
            "90438502+9503",
            "12/123/4322",
            "51:534",
            "$23.454",
            "/5/5/5",
            "12f3.21f3.213f",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 833,
        "output": [
            {
                "text": " 0\\.12\n\nExercise 2: Extracting Number Patterns\nWrite a JavaScript function to extract all matches of"
            },
            {
                "text": " [0-9]+,,(?!\\.\\.[0-9]*)\\.(0)\n"
            },
            {
                "text": " \"\\d+\\.\\d+\"\n\n\n\nQuestion 1: Emma has 6 more apples than apples than"
            },
            {
                "text": "\n# Matches: \"0\", \"1\", \".123\"\n# Does not match: \"2\""
            },
            {
                "text": " \"^(3|1,23)\\.\\d{1,2}$\"\n\nExercise"
            },
            {
                "text": " 0(?:\\.([1-9][0-9]?)|[1-9][0-"
            },
            {
                "text": " \n[0-9]*.[0-9]*[a-zA-Z][a"
            },
            {
                "text": " [^,](.{3,30})(?:-?\\d+)[^,]|("
            },
            {
                "text": " [^0-9]\n\nExercise 5: Count the number of digits before decimal point, comma separ"
            },
            {
                "text": " [\\d+\\.\\d+]\n\n2.2.4 Non-Zero Decimal Values\n"
            }
        ]
    },
    {
        "expression": "^([0-9]{5})([\\-]{1}[0-9]{4})?$",
        "raw_prompt": "Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format.",
        "refined_prompt": "Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format.\nMatch examples:\n- \"18017\"\n- \"18017-1401\"\n- \"21389-6392\"\nNon-match examples:\n- \"1801A\"\n- \"18017-\"",
        "matches": [
            "18017",
            "18017-1401",
            "21389-6392",
            "05777",
            "56923",
            "89326",
            "68059",
            "88774-1384",
            "32425-6779",
            "79483-3404",
            "89006-9511",
            "72142-2804",
            "16457-1675"
        ],
        "non_matches": [
            "1801A",
            "18017-",
            "18017-152A",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "489",
            "4985-489945",
            "56-4895",
            "495-94561",
            "-456-456",
            "9456-45961"
        ],
        "id": 836,
        "output": [
            {
                "text": " \n\\d{5}(-\\d{4})\n\n3) A mail address will consist of the following components: a street name, a city name, state/province, zip code, and a"
            },
            {
                "text": " /^1801(0-9|(-)[0-9])$/i\n\n3. You are building a URL search feature. You have URL values that follow the format: \"/blog/<int:"
            },
            {
                "text": " \"18017\\-Generate a RegEx for this description.\"\n\n4. A user is trying to upload their name into a server and needs your help. How can you apply RegEx to create a field for"
            },
            {
                "text": "\n\\d{5}\\.?[1-9]\\d-?[1-9]\\d\\d\n\nExercise 5:\nWhat special character is needed to define whether the postal code is"
            },
            {
                "text": " \n\n$postal_code=(\n      preg_match('#^[0-9]{5}[-0-9]{4}[0-9]{1}$#"
            },
            {
                "text": " (^[0-9]{5}(-|[0-9]{2}){1}$)\n\nExercise 3: Match against a U.S. postal code in either \n            "
            },
            {
                "text": " This type of match should be allowed as long as the non-match characters have a special meaning (or are replaced by underscores).\n\n2. Write a function that takes in a U.S. postal code in a"
            },
            {
                "text": " r\"((1[1-5][0-9])|(6[0-9]))-(([A-Z]+[1-9])|( [A-Z]))\" \n"
            },
            {
                "text": " \"([0-9]{5})-([0-9]{4})\"\n\n2. Create a regular expression that matches date formats such as DD/MM/YYYY or DD-MM-YY"
            },
            {
                "text": " \n/^(19|20)?[0-9][0-9][0-9]-[0-9][0-9][0-9]$/\nTo make sure you get what you"
            }
        ]
    },
    {
        "expression": "^([4]{1})([0-9]{12,15})$",
        "raw_prompt": "Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers.",
        "refined_prompt": "Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers.\nMatch examples:\n- \"4125632152365\"\n- \"418563256985214\"\n- \"4125632569856321\"\nNon-match examples:\n- \"3125652365214\"\n- \"41256321256\"",
        "matches": [
            "4125632152365",
            "418563256985214",
            "4125632569856321",
            "49806754364673",
            "41491375454867",
            "485356860942812",
            "4770447906705036",
            "448396436324023",
            "45070682445907",
            "44783606756808",
            "40836531725759",
            "4792181214201",
            "4877924087087587"
        ],
        "non_matches": [
            "3125652365214",
            "41256321256",
            "42563985632156322",
            "314455704591712",
            "328340313647627",
            "3869294726381",
            "8473042249290",
            "8672009622132",
            "871986373693914",
            "893169175001042",
            "48156",
            "0j0jweBBBB"
        ],
        "id": 837,
        "output": [
            {
                "text": " Match example:\n^4\\d{12}\\d{13}\n\nExercise 2: What is the length of the following string: \""
            },
            {
                "text": "\n\n```Python\ndef validate_card_number(card_num: str):\n    \"\"\"\n    Validates against a card number."
            },
            {
                "text": " [4]\\d{12}\\d{4}\n\nI thought that the following would be the correct form of the RegEx to match card"
            },
            {
                "text": " RegEx: \"([0-9]*)[4] \\d{3}[0-9]*\"\n\n2. Using the"
            },
            {
                "text": " [0-9]{5}[0-9]{5}[0-9]{2}[0-9]{3"
            },
            {
                "text": " [^2[a-pO0-9 \\-.]]*\n- \"4125632-45\"Generate a RegEx for"
            },
            {
                "text": " \"4[1-9]??[0-9]|[1-9]??[0-9]\".\nExplanation:"
            },
            {
                "text": "\n[4][1-9][1-9][0-9][1-9][0-9][0-9][1-9"
            },
            {
                "text": " ^[0-9]{6}[4][0-9][0-9]|[0-9]{6}[3"
            },
            {
                "text": " \"^[4]\\d{5}(?:[1-9][0-9]{9}){0,2}$\""
            }
        ]
    },
    {
        "expression": "^([51|52|53|54|55]{2})([0-9]{14})$",
        "raw_prompt": "Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers.",
        "refined_prompt": "Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers.\nMatch examples:\n- \"5125632154125412\"\n- \"5225632154125412\"\n- \"5525632154125412\"\nNon-match examples:\n- \"5625632154125412\"\n- \"4825632154125412\"",
        "matches": [
            "5125632154125412",
            "5225632154125412",
            "5525632154125412",
            "5112345678901234",
            "5212345678901234",
            "5312345678901234",
            "5412345678901234",
            "5512345678901234",
            "5200000000000000",
            "5500000000000000",
            "5234567890123456",
            "5443210987654321",
            "5522222222222222"
        ],
        "non_matches": [
            "5625632154125412",
            "4825632154125412",
            "6011632154125412",
            "5012345678901234",
            "5612345678901234",
            "52000000000000",
            "530000000000000",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 838,
        "output": [
            {
                "text": " (52[5-9]\\d{13})\n\n2-10. Find a word that starts"
            },
            {
                "text": " (5)+6[0-9]2+4[0-9]2+3[0-"
            },
            {
                "text": " (MC's start with 51) \\b52[0-9]{14}\\b|(MC's"
            },
            {
                "text": " r\"^[51-55][0-9]{14}$\"\n\n3. Pattern to"
            },
            {
                "text": " \n^[^5]{9}56(?:\\1)(12)?[^5]{"
            },
            {
                "text": " ^51[5][2][5][6]{13}$\n\n##### Question 3: "
            },
            {
                "text": " \n(?<=0{4,})(\\d{4}-\\d{4}"
            },
            {
                "text": " \n^(51[0-9]*)|(52[0-9]*)|(53"
            },
            {
                "text": "\n^[55][52][56][51][53][46][52][56][54][53]["
            },
            {
                "text": " \"^([2-5]\\d{13})$\"\n\nExercise 2:\nMatch examples"
            }
        ]
    },
    {
        "expression": "^(([A-Z]{1,2}[0-9]{1,2})|([A-Z]{1,2}[0-9][A-Z]))\\s?([0-9][A-Z]{2})$",
        "raw_prompt": "Matches UK postcodes of the below formats. The space is optional.\nAN NAA\nAAN NAA\nANN NAA\nANA NAA\nAANA NAA\nAANN NAA",
        "refined_prompt": "Matches UK postcodes of the below formats. The space is optional.\r\nAN NAA\r\nAAN NAA\r\nANN NAA\r\nANA NAA\r\nAANA NAA\r\nAANN NAA\nMatch examples:\n- \"A11AA\"\n- \"AA1A 1AA\"\n- \"AA11 1AA\"\nNon-match examples:\n- \"AAA 1AA\"\n- \"AA11A 1AA\"",
        "matches": [
            "A11AA",
            "AA1A 1AA",
            "AA11 1AA",
            "EC1A 1BB",
            "W1A 0AX",
            "M1 1AE",
            "B33 8TH",
            "CR2 6XH",
            "DN55 1PT",
            "SW1A 1AA",
            "GU16 7HF",
            "L2 2HQ",
            "G2 2BL"
        ],
        "non_matches": [
            "AAA 1AA",
            "AA11A 1AA",
            "AAA1AA",
            "Mastercard",
            "sfalijad234",
            "there is a boy",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 844,
        "output": [
            {
                "text": " ^[A-Z]{2}[A-Z0-9 ]"
            },
            {
                "text": " [A-Z]{6}.*[A-Z]{1}"
            },
            {
                "text": " [^ ]{1}[A-Za-z 0-9]"
            },
            {
                "text": " [A]A[aA][A1][A11][A11]["
            },
            {
                "text": " ANN|AAN|AANN|AANA|AAA|AANN\n"
            },
            {
                "text": " ^(.* )\\s*$|^.*\\s*$|^"
            },
            {
                "text": "\n(A(?:[A-ZA]\\d)?N)+([A"
            },
            {
                "text": " /\\B(AN|AA|A|A0|A1|A"
            },
            {
                "text": " REGEX =?(?<firstGroup>.{maxLength})?(?"
            },
            {
                "text": "\n\n(^([0-9]|[1-9][0-"
            }
        ]
    },
    {
        "expression": "(\\S+)\\x20{2,}(?=\\S+)",
        "raw_prompt": "Trim Inside. This pattern can be used with a replace value of &quot;$1 &quot; to remove multiple consecutive spaces between characters and replace with a single space. Trailing and leading spaces are NOT altered.",
        "refined_prompt": "Trim inside a string by replacing multiple consecutive spaces between characters with a single space, without altering leading or trailing spaces.\nMatch examples:\n- \"Too  Many spaces.\"\n- \"hdfu   fhhu\"\n- \"bufy.  sd fuhi\"\nNon-match examples:\n- \"No extra spaces\"\n- \"No Extra spaces Inside\"",
        "matches": [
            "Too  Many spaces.",
            "hdfu   fhhu",
            "bufy.  sd fuhi",
            "usdfi.  siudhfi",
            "iowr89.  wefbui",
            "fdbuis.  sfbug78",
            "bfys f.  s.  sdbufb",
            "bshdbf.   fbsdib",
            "bhfye87g.   buiwe",
            "bfyeg.   hufew",
            "jif.  iubfwe",
            "uiirwe u ehw.    wiuhr",
            "huiher.    uiwhruiwr"
        ],
        "non_matches": [
            "No extra spaces",
            "No Extra spaces Inside",
            "34f2vf42e",
            "Mastercard",
            "2346-2345-2435",
            "$23.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "34.31",
            "99999@gmail"
        ],
        "id": 848,
        "output": [
            {
                "text": " The RegEx for this description is no extra spaces.\n\n\n\n**Section: Health and Physical Education- Sexuality and Types and Dimensions**\n\nIn this section,"
            },
            {
                "text": " ([a-zA-z0-9 \\t ]+)\n\n\n\nQuestion 10: A rectangular prism has a length of 10 cm, a width of 5 cm"
            },
            {
                "text": "  /No extra spaces/.\n\n4) Create a Python code that determines if a given string is a palindrome or not.\n\nExplanation:\nA"
            },
            {
                "text": "\n\"\"\"\n\ndef space_trim(value, max_chars):\n    return re.sub(r'\\s{2,}','', value"
            },
            {
                "text": "\n[^\\S \\t]+\n\nConclusion:\nThrough this section, you learned the basics of Python RegEx patterns, how to use them for text processing, and"
            },
            {
                "text": " \"\\s{2,}\"\n\n5. Write a RegEx to match any two-word sequences, where a word is defined as two or more consecutive alphabetical characters that"
            },
            {
                "text": " (?<=[^A-Za-z0-9 ])[^A-Za-z0-9](?=[A-Za-z ])"
            },
            {
                "text": " [ ] (zero or one space)\n\n---\n\n## 3. Manipulating Data with RegEx\n\n### 4. Python's `re.match()`\n"
            },
            {
                "text": " To generate a RegEx for \"Find a pattern that begins with a digit, followed by one or more spaces, followed by a letter\" you could use:\n\\d["
            },
            {
                "text": " \n\n```python\nstring = \"Too  Many spaces\"\nregex1 = re.sub(r\"\\S{1} +\", \" \", string"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}((0[1-9])|(1[0-2]))$",
        "raw_prompt": "Match a string in CCYYMM/YYYYMM format.",
        "refined_prompt": "Match a string in CCYYMM/YYYYMM format.\nMatch examples:\n- \"200401\"\n- \"000001\"\n- \"200412\"\nNon-match examples:\n- \"aaa\"\n- \"20040123\"",
        "matches": [
            "200401",
            "000001",
            "200412",
            "080210",
            "709612",
            "692003",
            "299711",
            "848203",
            "298311",
            "325410",
            "093311",
            "392105",
            "525304"
        ],
        "non_matches": [
            "aaa",
            "20040123",
            "200414",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "AAAAAAA",
            "98iojk",
            "432/524/2435",
            "adfa2",
            "abc111def",
            "32542"
        ],
        "id": 851,
        "output": [
            {
                "text": " ^(\\d{2})(-?\\d{2})?$|\\d{4}$\n(This is a more complicated example, not shown here.  \n\nA:\n\nif you're on regex only:\nstring x = \"04/2004\";\nif("
            },
            {
                "text": " \n- ^[0-9]{4}/[0-9]{2}$\n- ^[0-9]{2}$\n- ^[0-9]{4}$\n- ^[0-9]{2}$\n\n5."
            },
            {
                "text": " CCYYMM\n\nYou can test your answer in Regex101\n\nA:\n\n[a-z]{2}/[0-4]{2}/[0-3]{3}\\s*[a-z]{4}\n\nQ:\n\n"
            },
            {
                "text": " A year that begins with the \"04\" followed by four digits (yyyy).\n\n```python\nimport re\n\nstring1 = \"200401\"\nstring2 = \"000001\"\nstring3 = \"200412\"\n\nprint(re.search(\"^04([0"
            },
            {
                "text": " \"([0-9]{4})/(\\d{2})\"\nExcercise 2: \nMatch a file name in CCYYMM/YYYYMM format using Regex.\nQuestion:\n1. Use the regex ^([0-9]{4})/([0"
            },
            {
                "text": " (?<year>\\d{4})(?<month>\\d{2})(?<day>\\d{2})$\nExamples of the answer string:\n-  (?<year>\\d{4})(?<month>\\d{2})("
            },
            {
                "text": "\n-.*(\\d{4}),(\\d{2})*(\\/\\d{4})?)\n-.*(\\d{4}),(\\d{2}))?(\\/\\d{4})?\n\n```python\n# A RegEx to match phone"
            },
            {
                "text": "\n- (.)([0-9]{2})\\/([0-9]{4})$\n\n2. Generate a RegEx to pull all email addresses from a text file and write the addresses to a new file (you can use text files to store addresses, etc.)\nAnswer"
            },
            {
                "text": " Matching the date in YYYYMM\n\n# 7.3.8 Using Lookahead and Lookbehind Assertions with Regular Expressions\n\nThis subsection explains how to use the `(?=...` and `(?<...` assertions with regular expressions. \n\nLook"
            },
            {
                "text": " ^\\\\d{4}\\\\d{2}\\\\d{2}$\n- \"01/03/2004\"\n- \"01/04/2004\"\n- \"01/05/2004\"\n- \"01/06/2004\"\n- \"01/01/2004\""
            }
        ]
    },
    {
        "expression": "^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",
        "raw_prompt": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.",
        "refined_prompt": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.\nMatch examples:\n- \"12.34\"\n- \"100.00\"\n- \"-2.1\"\nNon-match examples:\n- \"101.1\"\n- \"10.123\"",
        "matches": [
            "12.34",
            "100.00",
            "-2.1",
            "48.65",
            "48.97",
            "98.54",
            "51.21",
            "87.5",
            "97.1",
            "54.9",
            "-79.1",
            "78.2",
            "98.2"
        ],
        "non_matches": [
            "101.1",
            "10.123",
            "100.10",
            "489.15",
            "489.514",
            "9.5498",
            "894.51",
            "7835.54",
            "68.54987",
            "564.216",
            "546.215",
            "215.5432"
        ],
        "id": 859,
        "output": [
            {
                "text": " ^[-]\\d+(-[\\d.]+)?$\n\n\n\nQuestion 10: Mike is planning a dinner table reception and wants to know how many tables he will need to accommodate all the guests. If each"
            },
            {
                "text": " (Any combination of numbers, dots, and + or - symbols) [-?\\d]*\\.\\d+[-+\\d]*\n\nExercise 3: Write a Python function that takes a list of strings and"
            },
            {
                "text": " (Example) \".*0-9|\\.\\d\\d(\\.0+)?|[+-]0?\\d+%|\\.\\d\\d(\\d\\d)*%$\n \nEx"
            },
            {
                "text": " (0-100] (\\p{L}+) (\\.(\\d{1}?\\d?)?)\n\nExercise 2: Password Requirements\n- Exercise: A password must have at least one uppercase"
            },
            {
                "text": " [0-9]\\.[0-9]\n\nExercise 2: Pattern and Matcher Syntax\nCreate a pattern that matches any combination of the numbers a, b, c, and d, with at least one"
            },
            {
                "text": " ^[0-9]+(\\.0[0-9]*)?%, where {} indicates a repetition.\n\n3. Given a list of numbers representing scores (between 0 and 100), generate a list of regex patterns for"
            },
            {
                "text": " r\"^[0-9][0-9](\\.\\d)?(%[-\\+])?$\"\n\n\n\nQuestion 2: A bakery sold 30 pies for 3 different flavors at $10 each and"
            },
            {
                "text": " (positive)+|(negative)+ |(decimal)+   %  \n\n######\n\n### Exercise 2: Password validation\nWrite a RegEx pattern that validates a password, such that:\n- It contains at"
            },
            {
                "text": " Ranges from 0 to 100(inclusive) accepting (0,100) percentage. Allows a positive or negative number. Accepts up to 2 decimal places (including the decimal point).\n- Generate a RegEx for this"
            },
            {
                "text": "  ^\\d+$ and \\.[0-9]*$\n\nI hope this letter helps you understand and practice RegEx, and feels like a step towards becoming a better Python user and game developer.\nBest wishes"
            }
        ]
    },
    {
        "expression": "\\b(?:a(?:[nst]|re|nd)?|b[ey]|f(?:or|rom)|i[nst]?|o[fnr]|t(?:o|hat|he|his)|w(?:as|h(?:at|en|ere|ich|o)|i(?:th|ll)))\\b",
        "raw_prompt": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the ?: for grouping.\nI've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.",
        "refined_prompt": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the ?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"",
        "matches": [
            "by",
            "when",
            "or",
            "the",
            "a",
            "to",
            "i",
            "it",
            "is",
            "be",
            "on",
            "that",
            "from"
        ],
        "non_matches": [
            "bye",
            "craptastic",
            "nor",
            "fasdf",
            "apple",
            "tree",
            "pear",
            "banana",
            "notre",
            "dame",
            "abc111def",
            "12/132/90"
        ],
        "id": 861,
        "output": [
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: \"((?i)^.+[not]a+mazing$|(?"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: (?<!e.)[a-z]+ - matches a lowercase letter\n-"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: r'([a-zA-Z]+)[^aeiou]+[^"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: [^aeiou]s[^aeiou]\n\nIf you're more"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: r'(\\b\\w+\\b)\\s*in\\s*(?="
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: \"^(?=.*[a-z])(?=.*[A-Z"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: <wordlist/>\nThanks, \nBuddy\n\nA:\n\n\\b"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer:.*a.*m.*p.*t.\nNow think about a longer description, like"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer:\n\\b[^-\\w\\s]+$\n\nA:\n\nUse"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: (.*)?(?=\\[)(.*), (.*) (.*), (.*"
            }
        ]
    },
    {
        "expression": "^([0-1])*$",
        "raw_prompt": "Expression validating a Binary string of any length",
        "refined_prompt": "Expression validating a Binary string of any length\nMatch examples:\n- \"10101000\"\n- \"01010000\"\n- \"100000001\"\nNon-match examples:\n- \"01000200\"\n- \"00021000\"",
        "matches": [
            "10101000",
            "01010000",
            "100000001",
            "10101",
            "010101010",
            "101001",
            "010101010101",
            "01101010011101",
            "1010101",
            "111111000",
            "1000000101010",
            "110101010111100001",
            "110101010011111"
        ],
        "non_matches": [
            "01000200",
            "00021000",
            "e10000000",
            "1201520201010",
            "10101010120102",
            "2010202020",
            "20020020",
            "20202020200",
            "1010100.0.0.0.01a",
            "1002012020",
            "2015205120",
            "020"
        ],
        "id": 862,
        "output": [
            {
                "text": " [0-9]{7,10}\nNote: This regex validates Binary strings of any length.\n\nExercise 5: String Manipulation\nExercise: Given a paragraph of text, use Regular Expressions to replace all occurrences of the word \"Python\" with \"Java\"."
            },
            {
                "text": " Valid Binary string.\n\nExercise 3: Develop a RegEx to match only uppercase letters from a string. The string will comprise alphanumeric characters and some/all capital letters.\nAnswer: [A-Z]\n\nExercise 4: Generate a RegEx to"
            },
            {
                "text": " ^.*(0|1)0*\n\"\"\"\n\n\n# RegEx Validators Validating a Binary String of any Length\n\n\"\"\"\nA Validator is a regex pattern that we may pass as an argument to a RegEx function's \"flags\" parameter to specify its behavior. The"
            },
            {
                "text": " ^[^\\d]?(1[01]|[10])(0[1-9]|1[012])$\nExplanation:\n- [^\\d]?   Means there can be one character (0-9, | or.) that is"
            },
            {
                "text": " '^(?=[1]{6}$)\\d{6}(\\b0{2}\\d{3}\\b|\\b1{2}\\d{2}\\b|\\b10{2}\\d{2}\\b|\\b11{2}\\d{"
            },
            {
                "text": " ^[01][0-9?]*$\n\n3. Write a Python Regex pattern to match all email addresses.\n\nIdeas: The email addresses must have one or more characters before and after the `@` symbol, and are separated by one or more of any characters other"
            },
            {
                "text": " \n^[01]{1}0*$|^10$|^100$|^11$|^100000$\n\n3. Regular Expression to validate an IP network address?\na. Validations Required [2 points]\n   i. [0-9"
            },
            {
                "text": "\nA. ^[0-5]\\d{6}.*$\nB. ^[01]$|^[1-9]$|^[1-3]$\n\n\n3. Using the Pattern and PatternMatch classes to validate email addresses in the name field\n"
            },
            {
                "text": " 1.1.\n\n### Solution\nimport re\n\ndef binary_validate(expr):\n\n    \n    #1. Validating the Expression Starts and Ends with only 0 and 1\n    assert re.match(r'^(?:0000|0001)$',expr)"
            },
            {
                "text": " 1011|100\n\nI hope this user manual gave you the best understanding of Regular and Special expressions in Python. By practicing the exercises, you should have gained a solid understanding of the topic. Keep learning!\n\nPython Script for 5.1.1:\n\n```\n"
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F]){8}$",
        "raw_prompt": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.",
        "refined_prompt": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.\nMatch examples:\n- \"8ECCA04F\"\n- \"82E5AAA4\"\n- \"82e5aaa4\"\nNon-match examples:\n- \"8ECCAOF\"\n- \"82E5AA4\"",
        "matches": [
            "8ECCA04F",
            "82E5AAA4",
            "82e5aaa4",
            "37Fa8059",
            "b0B3E6F0",
            "86bbBe5b",
            "1c53c215",
            "75E14a03",
            "b6baf5c6",
            "34dc37c1",
            "DE18328C",
            "88CeA3FC",
            "c1eb17cc"
        ],
        "non_matches": [
            "8ECCAOF",
            "82E5AA4",
            "82e5aaa45",
            "afdsfads",
            "e5drtfy8guy",
            "65fty78gyu",
            "6ftyf7uy",
            "7dftd6tgy",
            "d56t87guygy89ugyv",
            "guyg8y8gy",
            "7ft6ddtr65erd6tf7yg",
            "ft6r6ft"
        ],
        "id": 865,
        "output": [
            {
                "text": " \\d{5}\\w{5}\n\n2) \"A9E8D9G6A6F4B3C1A2B\"\nMatch examples:\n"
            },
            {
                "text": " '^[A-Fa-f0-9]{6}$'|^[A-Fa-f0-9]{3}[A-Fa-f0"
            },
            {
                "text": "\nThe correct RegEx would be [0-9]|[A-Fa-f][0-9] but it won't work with letters. So first, we need to include"
            },
            {
                "text": " ESN must contain exactly 6 characters (0-9). \n\nExercise 5:\n\nSuppose you are developing a program to process incoming emails from customers. Develop a regular expression"
            },
            {
                "text": "\n`[A-Z]{6}[0-9]{2}-[A-Z]{2}`\nCreate an ESSN value field on every form."
            },
            {
                "text": "\n^(10[0-9A-Fa-f]{8}[0-9A-Fa-f])$|^(A[0-9A-Fa"
            },
            {
                "text": " \n\nimport re\n\n#Regular Expression pattern to validate ESN #\nESN = \"8ECCA04F\"\npattern = \"(?=^[0-9A"
            },
            {
                "text": " /\\D(?=(\\\\d){4})/\n```\n\n4. Build a regex for validation of the 4-digit credit card numbers used in credit cards.\nIde"
            },
            {
                "text": " https://regex101.com/r/aU6aXw/1 \nimport re\n\n#ESN Regular Expression\nESN = '82C4A5"
            },
            {
                "text": " #1 ^[1-9]\\d{2}\\d{3}$^Match this description to an ESS Number, or #2 ^[1-9]\\d"
            }
        ]
    },
    {
        "expression": "(02\\d\\s?\\d{4}\\s?\\d{4})|(01\\d{2}\\s?\\d{3}\\s?\\d{4})|(01\\d{3}\\s?\\d{5,6})|(01\\d{4}\\s?\\d{4,5})",
        "raw_prompt": "Validates UK domestic landline phone numbers.\nValid formats are:\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "refined_prompt": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match examples:\n- \"02476 123456\"\n- \"0845 123456\"",
        "matches": [
            "020 1234 5678",
            "0123 4567890",
            "01234 456789",
            "0106860496",
            "02617842344",
            "0163\f2643832",
            "0165781\u20052081",
            "0139985762",
            "0106346\u205f8156",
            "01451609003",
            "018601\u200222460",
            "01134852061",
            "01561729575"
        ],
        "non_matches": [
            "02476 123456",
            "0845 123456",
            "07712 345678",
            "r65tyg",
            "94856189",
            "8456",
            "8456654",
            "r65ftygv",
            "6t7yfuv",
            "341.431v4f3.fv1",
            "abc111def",
            "99999@gmail"
        ],
        "id": 869,
        "output": [
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-valid"
            }
        ]
    },
    {
        "expression": "(077|078|079)\\s?\\d{2}\\s?\\d{6}",
        "raw_prompt": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "refined_prompt": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"",
        "matches": [
            "07713 345678",
            "078 12345678",
            "079 12345678",
            "078 09442466",
            "07790\u2004495054",
            "07922223865",
            "07976338481",
            "07703621312",
            "078\u200928559370",
            "07953922231",
            "077\u205f62474680",
            "07787720248",
            "07966\u2029323376"
        ],
        "non_matches": [
            "02344 123456",
            "0121 292929",
            "012345 6789",
            "45162305230",
            "56123051",
            "512021548",
            "46512025",
            "94512015489",
            "4961525",
            "48152594612",
            "41621541245456",
            "461520"
        ],
        "id": 870,
        "output": [
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this to"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this."
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this format"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this:"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this."
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this."
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this\n"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this pattern"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this,"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this using"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))$",
        "raw_prompt": "Matches month, requires that months 1-9 have a leading 0",
        "refined_prompt": "Matches month, requires that months 1-9 have a leading 0\nMatch examples:\n- \"01\"\n- \"02\"\n- \"12\"\nNon-match examples:\n- \"1\"\n- \"2\"",
        "matches": [
            "01",
            "02",
            "12",
            "03",
            "04",
            "05",
            "06",
            "07",
            "08",
            "09",
            "10",
            "11"
        ],
        "non_matches": [
            "1",
            "2",
            "13",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "418",
            "456",
            "48"
        ],
        "id": 876,
        "output": [
            {
                "text": " ^[0123456789]$. \n\nExercise 4:\nWhat would a username that starts with a zero also match for, and vice versa?\nAnswer: A zero would match for \"0000\", a four character number string. A four-character string would match for \"0000\", a two character"
            },
            {
                "text": " ^(01|02|03|04|05)(0?|[1-9])$\n4. For the following regular expression, how would you generate a RegEx to add a comma between each of the numbers in the date? (This question is specifically asking about how to generate a RegEx for this description"
            },
            {
                "text": "  ^(\\d[0-9]\"{1,2}\")+/\\d/.\n\n3. Extract all the months that occur between \"04/22\" and \"03/14\", inclusive of \"03/14\".\nAnswer: { \"04\", \"11\", \"12\" }\n\n    "
            },
            {
                "text": " \\b(01|02|12)\\b Matches only exact matches of 1, 2, 12.\n\nLecture Script:\n\nContents:\n- Introduction to regex literals and characters\n- Using the raw string literal to escape regex matches\n- Using the double backslash to escape regex matches"
            },
            {
                "text": " (^(0?1?1?1?)$|^(2(0?1?1?)?0?1?)$|^(3(0?1?1?)?0?0?)$|^(4(0?1?1?)?1?0?)$|^("
            },
            {
                "text": ".*?(\\d{1,2})(\\s(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))$?.*\"\n\n2. Write a regular expression that:\n- Matches if the user inputs a valid"
            },
            {
                "text": " \nmat(?: \\d{(1)|(2)})? \\d\n\nExercise 7:\nMatch the date format in the following dates:\n- \"May 22, 2022\"\n- \"December 01, 2022\"\n- \"25/04/2022\"\nAnswer: \n\"\\"
            },
            {
                "text": " /^0 | [1-9]\\d{4}/.\n\n4. Use re.compile with the Pattern () method to create a RegEx that matches any string of characters that is between two curly braces, e.g. {name}.{age}\nCreate RegEx.\nMatch example:"
            },
            {
                "text": " Generate a RegEx of the pattern [1-9]\n- \"10\"\n- \"11\"\n- \"12\"\n- \"13\"\n- \"14\"\n- \"15\"\n- \"16\"\n- \"17\"\n- \"18\"\n- \"19\"\n- \""
            },
            {
                "text": " ^(01|23)*$\n\n### Exercise 2:\n\nWrite a function that takes in a string, and returns True if the string is formatted according to RFC 3986 (https://tools.ietf.org/html/rfc3986), and False otherwise.\n\n```python\nimport re"
            }
        ]
    },
    {
        "expression": "^\\s*-?(\\d*\\.)?([0-2])?[0-9]:([0-5])?[0-9]:([0-5])?[0-9](\\.[0-9]{1,7})?\\s*$",
        "raw_prompt": "This should be the pattern described in the documentation for the .NET TimeSpan.Parse method - generally parses time spans.\nFrom the .NET docs:\npublic static TimeSpan Parse(string s);\nThe s parameter contains a specification of the form:\n[ws][-][d.]hh:mm:ss[.ff][ws]\nItems in square brackets ([ and ]) are optional, colons and periods (: and .) are literal characters, and other items are as follows.\nItem Description\nws optional white space\n&quot;-&quot; optional minus sign indicating a negative time\n&quot;d&quot; optional days\n&quot;hh&quot; hours, ranging from 0 to 23\n&quot;mm&quot; minutes, ranging from 0 to 59\n&quot;ss&quot; seconds, ranging from 0 to 59\n&quot;ff&quot; optional fractional seconds, from 1 to 7 decimal digits",
        "refined_prompt": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"",
        "matches": [
            "10:12:34",
            "932323.9:00:32.3420",
            "12:34:56",
            "1:2:3",
            "00:00:00",
            "-1:23:45.6789",
            "01:59:00.1234567",
            "23:59:59.9999999",
            "0:00:01",
            "01:02:03.000001",
            "0:00:00.1",
            "00:00:59",
            "23:59:59.999999"
        ],
        "non_matches": [
            "10:20:80",
            "f34fvfv",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "105516:516:654",
            ":465:456:465f",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 877,
        "output": [
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generated"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generated"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generating"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generates"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generating"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generator"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            }
        ]
    },
    {
        "expression": "^([1-9]{0,1})([0-9]{1})(\\.[0-9])?$",
        "raw_prompt": "Matches numbers 0 through 99.9\nAllows only one preceding zero and does not require the decimal point",
        "refined_prompt": "Matches numbers in the format of a single digit, with an optional leading digit in the range 1-9 and an optional decimal part consisting of a period followed by one digit.\nMatch examples:\n- \"1\"\n- \"1.1\"\n- \"0.1\"\nNon-match examples:\n- \"01\"\n- \"01.1\"",
        "matches": [
            "1",
            "1.1",
            "0.1",
            "4.8",
            "6.5",
            "1.4",
            "8.4",
            "9.8",
            "3.2",
            "5.4",
            "6.7",
            "5.1",
            "6.4"
        ],
        "non_matches": [
            "01",
            "01.1",
            "0.10",
            "000151",
            "0051156",
            "0.215413",
            "56115",
            ".40215afd",
            "5612356",
            "adfa2",
            "dfg",
            "8h98009hu"
        ],
        "id": 879,
        "output": [
            {
                "text": " [1-9][\\.]?[\\d]\n```python\nx = \"1\"\ny = \"1.1\"\n\nresult = re.search("
            },
            {
                "text": " (1(?:-?\\d{1,9})?\\.?)\nThis RegEx will match either an initial 0 in the range 1-9 and an optional 1-9"
            },
            {
                "text": " \n\nimport re\n\nprint(re.findall(\"(\\\\b\\\\d+.?\\\\d*\\\\.)\", \"012.3\"))\n\nThis regex should print"
            },
            {
                "text": " /^0.1*$/.\n\n3. Write a regular expression for matching dates in the format of MMM.DD.YYYY.\nExample: /MMM."
            },
            {
                "text": " ^[1-9][.]?[1-9][0-9]*$\n\nExercise 3: Extract a specific piece of information from a text.\nQuestion:"
            },
            {
                "text": " You can include a negative lookahead and lookbehind to make the pattern match a single digit preceded and followed by another digit or a decimal point, respectively. For example, \"(?!^\\"
            },
            {
                "text": " [Regex]^([0-9]{0,})(\\.|\\d$)\n\nExercise 4:\nGiven the regular expression [0-9]{"
            },
            {
                "text": " ^[0-9][.][1-9]$\n\n4. Write a regular expression pattern that matches all strings that contain at least one uppercase letter, two lower"
            },
            {
                "text": " (^|\\b)(0\\.(0+)(\\b|$))*\\b\n\nExercise 4: Replace multiple characters in a string\nGiven the string \"hello"
            },
            {
                "text": " \\d{0,2}\\.\\d [1-9] \n- \"1\"\n- \"1.1\"Generate a RegEx for this description. "
            }
        ]
    },
    {
        "expression": "^(eth[0-9]$)|(^eth[0-9]:[1-9]$)",
        "raw_prompt": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff",
        "refined_prompt": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff\nMatch examples:\n- \"eth0\"\n- \"eth0:4\"\n- \"eth4:9\"\nNon-match examples:\n- \"eth0:\"\n- \"eth0:0\"",
        "matches": [
            "eth0",
            "eth0:4",
            "eth4:9",
            "eth0:4",
            "eth8:6",
            "eth2:4",
            "eth9:8",
            "eth0:4",
            "eth4:5",
            "eth0:8",
            "eth4:8",
            "eth3:4",
            "eth2:3"
        ],
        "non_matches": [
            "eth0:",
            "eth0:0",
            "eth0:1d",
            "eth2y8hfue",
            "eth:HUIF89dh",
            "eth:hiuf8",
            "eth:43298",
            "eth:89ur",
            "epflu3829",
            "epfl8293j",
            "epfl$EDR",
            "12/132/90"
        ],
        "id": 880,
        "output": [
            {
                "text": " (\\w+):(\\d+)\n\nWhat do you think?\n\nA:\n\nYou could match\n^\\W*(?:[^a-zA-Z0-9_]*.[a-zA"
            },
            {
                "text": " ^(?P<device>[a-zA-Z0-9]{5}:\\[(?P<ipv4>[0-9]{1,3}\\.){3}\\d{1,3}]:"
            },
            {
                "text": " r\"eth.+?:.*?$\"\n\nSolution:\nre.compile(r\"eth.+?:.*?$\")\n\nExercise 3:\nWrite a list comprehension that removes the leading \"eth0"
            },
            {
                "text": " \n\n#!/usr/bin/python3\nimport re\n\nregex = re.compile(r'^\\D*:[\\d\\.]+$') \n\nfor device in [\"eth0:0."
            },
            {
                "text": " \n^\\s*([A-Z_a-z0-9:_]{0,63}\\.){1,64}[A-Z_a-z0-9]*(:|$)$"
            },
            {
                "text": " r'[a-zA-Z0-9_]+:[0-9]*'\n\n3) Write a regular expression that matches all IP addresses that match the r'\\[[0-9]{1,3}\\"
            },
            {
                "text": " \n[a-z]\\[a-z\\]:[a-z\\] [a-z]$\n\n4. Write a Scrubber that looks for lines that contain any of these characters: <>@#$"
            },
            {
                "text": " *\\d+\nWhat does regex match? regex matches any pattern of text, for example, matches IPs, email addresses, file paths, etc.\n\n2) write a string pattern to match URLs (the pattern must start with http"
            },
            {
                "text": " \n[A-Za-z0-9_-, :]{2}/[A-Za-z0-9_-]/\n\nA:\n\nI have found this answer by another post regarding this topic"
            },
            {
                "text": "\n(?<eth4>[a-z]+[0-9]*|[0-9]+[a-z][0-9]*)\n\nA:\n\nTry this regex for matching \"0\" to a \""
            }
        ]
    },
    {
        "expression": "^\\.([rR]([aA][rR]|\\d{2})|(\\d{3})?)$",
        "raw_prompt": "RAR file extensions.\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\nDoes not support volumes exceed 101 for s## (r99, s00, s01, ...) serie.",
        "refined_prompt": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01, ...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"",
        "matches": [
            ".RAr",
            ".r01",
            ".012",
            ".R32",
            ".r46",
            ".R05",
            ".RAR",
            ".rAR",
            ".R31",
            ".035",
            ".RAR",
            ".917",
            ".RAR"
        ],
        "non_matches": [
            ".rxr",
            ".a01",
            ".0112",
            "rarhu",
            "rary78hu",
            "huiey8uhr",
            "y8uhi6r7tf",
            "r56tf",
            "r65ft",
            "r65tf",
            "6fty8uhi",
            "uhi"
        ],
        "id": 881,
        "output": [
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (.+)(\\..+)?(.*)$|$\r\n\"\"\"\r\n\r\nimport re\r"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (.*)?\\.r(\\d*)\\.00\\.? \nhttps://regex101.com/r"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: ^((s\\d{1,9})\\.(p\\d{1,3}))$ -"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: \r\n[.][0-9a-z]{2}$  = Matches characters between"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: \".r01\" - match s01, s02, s03,..., s99, s10,"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: \\.RAr|.r01|.012\r\n- \".r\"\r\n- \"e-"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (https://regex101.com/r/o4jEoJ/4)\r\nSee"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer:.RAr |.r01 |.012\r\n\"\"\"\r\nfrom __future__ import print_function"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: re.compile(r'(\\.r\\d[0-9])(\\D*)*')"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (?i)([0-5]|6[0-5]|7[0-9])"
            }
        ]
    },
    {
        "expression": "^(X(-|\\.)?0?\\d{7}(-|\\.)?[A-Z]|[A-Z](-|\\.)?\\d{7}(-|\\.)?[0-9A-Z]|\\d{8}(-|\\.)?[A-Z])$",
        "raw_prompt": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\nFormat CIF: [1 letter][7 numbers][1 number or letter]\nFormat NIF: [8 numbers][1 letter]\nFormat NIE: X[possible 0][7 numbers][1 letter]\nNote that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.\nGenerally I always strip out any non-alphanumeric characters (hyphens, periods, etc.) and convert to upper case before checking validity and before saving to data storage.\nPlease post improvements or errors if you find them!",
        "refined_prompt": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544122-R\"\nNon-match examples:\n- \"43.544.122-R\"\n- \"f34fvfv\"",
        "matches": [
            "X01343567-D",
            "B-6116622G",
            "43544122-R",
            "40321895-U",
            "58334674P",
            "24527791P",
            "06707604F",
            "19979739.G",
            "71917270.N",
            "46841644.V",
            "X2645813.P",
            "X6139722.A",
            "67187001G"
        ],
        "non_matches": [
            "43.544.122-R",
            "f34fvfv",
            "34f2vf42e",
            "Mastercard",
            "2346-2345-2435",
            "$23.454",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "abc111def",
            "++63453.345"
        ],
        "id": 882,
        "output": [
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354445"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354437"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354445"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354434"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544444"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544A"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354432"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544222"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354435"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354444"
            }
        ]
    },
    {
        "expression": "^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$",
        "raw_prompt": "Matches full and compressed IPv6 addresses as defined in RFC 2373 (http://www.faqs.org/rfcs/rfc2373.html). No useful captures.\nVarious implementations require different terminators. (i.e. ^-$ or \\b-\\b)",
        "refined_prompt": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080::8:800:200C:417A",
            "::FFFF:129.144.52.38",
            "9Bec::1E:644:64A",
            "D:A:46:06E:A6cC::A2",
            "::eb8:19c8:A0B:A3d3",
            "B8:ae:3::e:F587:Fdf",
            ":255.208.204.245",
            "EEc:69D:a:B7:5F:A4D::6bcD",
            "ACfC:3c:c8d:BABb:90d:3d:6.251.222.193",
            "::9E:250.153.252.9",
            "0fCB:3e:ae:1F:7:29C:172.61.190.202",
            "18Cb:C8::53:0a5b:Ed2:a295"
        ],
        "non_matches": [
            "FEDC::7654:3210::BA98:7654:3210",
            "FEDC:BA98:7654:3210",
            "::",
            "12/1::23/4322::",
            "23::46-2345-24::35",
            "$23.::454",
            "43::-54::32",
            "/5/5::/20022::",
            "qwerty@::123.123",
            "1-1-2::",
            "(0xx12) ::625::09",
            "12::/132/9::0"
        ],
        "id": 885,
        "output": [
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this type"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this\n"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this?"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this string"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this ("
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this."
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this\n"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this\n"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this kind"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this,"
            }
        ]
    },
    {
        "expression": "^(\\$|)([1-9]\\d{0,2}(\\,\\d{3})*|([1-9]\\d*))(\\.\\d{2})?$",
        "raw_prompt": "Combine Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input to create this RE to accept Optional leading dollar sign, optional well-formed comma separator dollar amount with no zero amount allowed.\n*** Correction: Remove the &quot;+&quot; otherwise it will incorrectly matches 4 leading digits like 1234,345,678.00 03-03-2005",
        "refined_prompt": "Matches monetary values with optional dollar signs and supports thousands separators. It enforces that the value must have at least one digit before the decimal point and exactly two digits after the decimal point, if present.\nMatch examples:\n- \"$1,234,567.89\"\n- \"1234567.89\"\n- \"$9.99\"\nNon-match examples:\n- \"$1,2345,67.89\"\n- \"$1234,345,678.0\"",
        "matches": [
            "$1,234,567.89",
            "1234567.89",
            "$9.99",
            "$561",
            "100",
            "123",
            "45679856.12",
            "4856",
            "489",
            "$48",
            "$8464",
            "$84645",
            "$4865"
        ],
        "non_matches": [
            "$1,2345,67.89",
            "$1234,345,678.0",
            "0",
            "12/123/4322",
            "123.456.789",
            "43.v234",
            "$451123.451561",
            "$564.546313",
            "56123.156465%",
            "$6512332$#@",
            "9/9/9",
            "++63453.345"
        ],
        "id": 890,
        "output": [
            {
                "text": " (1)[0-9]+\\\\.(0+"
            },
            {
                "text": " \n\n/(^\\$[1-9"
            },
            {
                "text": " \\$\\d\\d[,\\.\\d"
            },
            {
                "text": " \n\"\\d[,\\.]{2"
            },
            {
                "text": " To match any money value with optional dollar signs and two"
            },
            {
                "text": " \"^[\\d\\,]+[\\d"
            },
            {
                "text": " $1,234,567\\.89\n\n"
            },
            {
                "text": " (?<!\\$)\\d+([,"
            },
            {
                "text": " ^[1-9][0-9]{"
            },
            {
                "text": " \\b\\d{1,3}(?:"
            }
        ]
    },
    {
        "expression": "^((Fred|Wilma)\\s+Flintstone|(Barney|Betty)\\s+Rubble)$",
        "raw_prompt": "Match the full names of the four main characters of The Flintstones.",
        "refined_prompt": "Match the full names of the four main characters of The Flintstones.\nMatch examples:\n- \"Fred Flintstone\"\n- \"Barney Rubble\"\n- \"Betty Rubble\"\nNon-match examples:\n- \"The Great Gazoo\"\n- \"Mr. Slate\"",
        "matches": [
            "Fred Flintstone",
            "Barney Rubble",
            "Betty Rubble",
            "Fred Flintstone"
        ],
        "non_matches": [
            "The Great Gazoo",
            "Mr. Slate",
            "Dino",
            "Mastercard",
            "sfalijad234",
            "Visa",
            "Pat",
            "Lionel Messi",
            "Neymar Jr.",
            "ABC",
            "fisjd",
            "fU*(DHIF"
        ],
        "id": 891,
        "output": [
            {
                "text": " [The pattern for Fred's name is Fred^.{1,4}y] for Barney,\"\n\n\n\nExam: Ethics--Moral--Scenarios\n\nNegative Exam:\n\n1. The presence of a carbon monoxide"
            },
            {
                "text": "\n - Fred Flintstone: [\\b(Fred)|(Flintstones)|(the)|(Flintstone)] \n - Barney Rubble: [\\b(Barney)|(Rubble)|(the)|(Rubble)]\n - Betty"
            },
            {
                "text": " $\"[a-zA-Z]*\"[a-zA-Z]*\"$\n\n```python\n\n\n\nimport re\n\n# The Flintstones \nf_first_name = \"Fred Flintstone\" \n"
            },
            {
                "text": " Create a regular exprssion that only includes alphanumeric characters, followed by \"_garbage\" which would match \"Betty Rubble\" with the word \"Garbage\". \n\n3. Generate a Matcher that groups all the text at the"
            },
            {
                "text": " Generate a RegEx of this shape: [\\s]Mr.|[\\s]Barney-|{3,2}\\b\n\n\n\nComparison \u2013 Win and Loss in Mathematics, Patterns, and Expressions \n\nPositive Side"
            },
            {
                "text": " \n- Fred Flintstone: \\(\\w*,\\w*\\)\n- Barney Rubble: \\(\\w*,\\w*,\\w*\\b\\)\n- Betty Rubble: \\(\\w*,\\w*\\),\\<\\w*\\> "
            },
            {
                "text": "\nFull names: Fred Flintstone Barney Rubble Betty Rubble\nNon-match: The Great Gazoo\n\n\n\nPositive: In the world of economics, there is a branch called macroeconomics that deals with the study of how an economy as"
            },
            {
                "text": " The complete name of an episode contains three characters: two who work in the Flintstone Museum and one who works at the Stone Museum.\n\n2. Create a Regular Expression that captures information about the time period in which any episode was created:\nCreate a Regular"
            },
            {
                "text": " The pattern should look like R(e.x. 3), B(e.x. 7), A(e.x. 3).\n\nExercise 2: What might be the reason for using a RegEx pattern to describe properties such as \"stone"
            },
            {
                "text": "\n- \"Fred Flintstone\": r^\\s(1|2|3|4).*\n\t\"Barney Rubble\": r^\\s(1|2|3|4).*\n\t\"Betty Rubble\": r^"
            }
        ]
    },
    {
        "expression": "(^\\([0]\\d{2}\\))(\\d{6,7}$)",
        "raw_prompt": "Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix",
        "refined_prompt": "Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix\nMatch examples:\n- \"(021)1234567\"\n- \"(021)123456\"\n- \"(000)000000\"\nNon-match examples:\n- \"(123)1234567\"\n- \"025123456\"",
        "matches": [
            "(021)1234567",
            "(021)123456",
            "(000)000000",
            "(037)724022",
            "(007)4356525",
            "(088)734140",
            "(041)370187",
            "(094)245329",
            "(012)915180",
            "(003)212963",
            "(092)654593",
            "(078)6872674",
            "(054)124109"
        ],
        "non_matches": [
            "(123)1234567",
            "025123456",
            "0252345678",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 894,
        "output": [
            {
                "text": " ^([0-9]{2,3})[0-9]{2,3}$\n- (\"(021)"
            },
            {
                "text": " ^(?=.*(?<!\\d)(?<!\\d$)\\d+(?!$))([0-7"
            },
            {
                "text": " ([0-9]{2})+(?:-([0-9]{2})+(?::([0-9]{"
            },
            {
                "text": " ^(?=\\A[01]\\d\\d\\d[0-9] ){7}(?=\\"
            },
            {
                "text": "\n\n\n\"\"\"Parsing of data in text files\"\"\"\r\n\r\nfrom os.path import dirname\r\nfrom random"
            },
            {
                "text": " [0-9]{1,9}[.-][0-9]{4}$]\n\n(B) Look"
            },
            {
                "text": "\n(03)+(00[1-9]|1[0-9]|2[0-2])\\s["
            },
            {
                "text": " ^(0{1,}|[0-9]{6,})$ \n4. \nGenerate a Reg"
            },
            {
                "text": "\n(^[0][1-9]|[1-9]?[0-9][0-9])\\d"
            },
            {
                "text": "\n\\(?\\d[6-9])\nExplaination: If it contains a 1 or 0 after the area code then"
            }
        ]
    },
    {
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$",
        "raw_prompt": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations (RegularExpressionValidator - ASP.NET).",
        "refined_prompt": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations.\nMatch examples:\n- \"08:00AM\"\n- \"10:00am\"\n- \"7:00pm\"\nNon-match examples:\n- \"13:00pm\"\n- \"12:65am\"",
        "matches": [
            "08:00AM",
            "10:00am",
            "7:00pm",
            "11:21AM",
            "03:04Pm",
            "04:47PM",
            "04:53am",
            "6:03PM",
            "1:30Pm",
            "08:16PM",
            "02:59pm",
            "01:12am",
            "11:59pm"
        ],
        "non_matches": [
            "13:00pm",
            "12:65am",
            "12ampm",
            "1230am",
            "13pm",
            "13morning",
            "17",
            "91ur3",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 895,
        "output": [
            {
                "text": "\n^([a-z]+)\\u00AD/([0-9:]+)([PM](?:[012]|[3-9]):)?$\n\n3. Write a"
            },
            {
                "text": " 1am, 1pm, 2pm, 3pm, 4pm\n\n```python\n@app.route(\"/validate_time\")\ndef validate_time():\n     times ="
            },
            {
                "text": " (^(19|20)\\d\\dAM|(6[0-2]|1\\d\\d)(am|pm)?)\n\nA:\n\nIf you are asking"
            },
            {
                "text": "\n12 hours (\\/{0,4}[0-9]{0,2}\\):(\\/|\\/\\d{1,2})([sS]?)am|("
            },
            {
                "text": " ([0-9]+):([0-9])AM|([0-9]+):([0-9])PM|([0-9]+):([0-9])AM\n\nI"
            },
            {
                "text": " ^(4[0-2]|0?[1-9])[0-5][0-9]:[0-5][0-9]$\n\nA common pattern that"
            },
            {
                "text": " ^[1-5][0-9]|6[0-4][0-9]|[12][0-3][0-9]$  (or similar)\n\n"
            },
            {
                "text": "\n^0[1-9]|1[012]\n\n4. Write a RegEx for validating usernames, passwords, and email addresses in the \"email\" field.\n"
            },
            {
                "text": "\n([1-5])(P)?[mM][h]?[0-9]*|[2-9][0-5]?[0-9][0-9"
            },
            {
                "text": "\n^((1|2)\\d{3}|2[0-1][0-9]|[12][0-9]|3[0-1])([:.]["
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+$",
        "raw_prompt": "it will check for alphanumeric (Alpha Numeric) values.",
        "refined_prompt": "matches strings that only consist of one or more alphanumeric characters (letters and/or digits).\nMatch examples:\n- \"adad1213\"\n- \"1231dfadfa\"\n- \"dfad123dfasdfs\"\nNon-match examples:\n- \"dfa@#12313\"\n- \"*(*sdfasdfadfd\"",
        "matches": [
            "adad1213",
            "1231dfadfa",
            "dfad123dfasdfs",
            "65f67f",
            "76c7",
            "c76",
            "f765d",
            "6f68",
            "f8",
            "67f78",
            "f87",
            "fg87",
            "f787fr7"
        ],
        "non_matches": [
            "dfa@#12313",
            "*(*sdfasdfadfd",
            "$fffsdg121ddd#$f1q",
            "$%RT",
            "F^TY",
            "(IH",
            ")OK",
            "(IJ",
            "8UH&^&",
            "yh&Y",
            "@#EF",
            "++63453.345"
        ],
        "id": 898,
        "output": [
            {
                "text": " ^.*[a-d].*[a-d]$\")\n\n3. Use RegEx to filter a list of URLs. URLs that only consist of one"
            },
            {
                "text": "\nimport java.util.regex.*;\nPattern P = Pattern.compile(\"\\\\w+\");\nMatcher M = P.matcher(\"1231"
            },
            {
                "text": " \\S*[0-9a-z]\\S*\n\n### What are some common mistakes when using regex?\nA common mistake when using regex is forgetting"
            },
            {
                "text": "\n    \"[a-zA-Z0-9]\" will match only alphanumeric characters\n    \"[a-zA-Z0-9a-z"
            },
            {
                "text": " [^a-zA-Z]+\n\n# 14.3.7 How to Compare and Contrast Different Types of Regular Expressions\n\nRegular expressions are a"
            },
            {
                "text": ".+.*\n4. Use a regular expression to extract the domain name from the following URLs:\na) http://www.example.com/\nb) http"
            },
            {
                "text": " ^[a-zA-Z0-9*#%-_\\.]+$\nUse Cases:\n1. John is a software developer who loves playing Sc"
            },
            {
                "text": " \n\nimport re                                    # importing regular expressions module. \n\ntext1 = \"adad1213\"                                            # defining text string. \n"
            },
            {
                "text": " [a-zA-Z0-9_]*[a-zA-Z0-9_]\n\n\n\nSection 1: Introduction to Ge"
            },
            {
                "text": "\n\\d[^\\n]*\\n|\\n\nThe characters below '\\n' are not required for the RegEx to match. '[^\\"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((19|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.\nAs usual, many tests have been made.\nThis was requested by a user :\nhttp://www.regexlib.com/REDetails.aspx?regexp_id=409",
        "refined_prompt": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.\nMatch examples:\n- \"29/02/2000\"\n- \"30/04/2003\"\n- \"01/01/2003\"\nNon-match examples:\n- \"29/02/2001\"\n- \"30-04-2003\"",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003",
            "19/02/1981",
            "14/02/1964",
            "29/02/3056",
            "20/10/8819",
            "22/10/6437",
            "19/10/3905",
            "15/10/1964",
            "18/02/1914",
            "15/08/2992",
            "27/02/1932"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/1899",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "32542 //"
        ],
        "id": 901,
        "output": [
            {
                "text": " \n(^(?:(0)?[1-9]|1[012])-(0)?[1-9]|1[012])-(0)?[1-9"
            },
            {
                "text": " Date (d/m/yyyy) match (dd/MM/yyyy) with leap year condition \nd/m/yyyy is mandatory but leap year condition is optional."
            },
            {
                "text": " \n(2)/[-0-9]{1,2}([1\\/9])([0]?[1-9])\nCreate some rules to describe non-"
            },
            {
                "text": " [0-9]{1}[1-9]/[01]/[01][0-9]{3}\nHow would you proceed?\n\nInclude comments"
            },
            {
                "text": "\n[0-9]{4}/[0-9]{2}/[0-9]{4} or [0-9]{4}[-/"
            },
            {
                "text": " /^(0[1-9]|1[0-2])\\/([0-9]{2})?\\/(20[3-9]|21[0-"
            },
            {
                "text": " \"^(0[1-9]|[1-2][0-9]|3[0-1][0-9]|400|400|501|502|"
            },
            {
                "text": " - Regex : YYYY/MM/DD[A-Z]{3,4}[A-Z]{3}\n\n2. Using Python, compile the Reg"
            },
            {
                "text": " You're looking for 3 characters with any two of the following : dd/mm/yyyy\n- dd.yy.yyyy\n- DD-MM-yyyy\n- dd-"
            },
            {
                "text": " \n\nimport time\ntime_start = time.time() \nleap_days = [\"366\",\"31\",\"1\",\"29\",\"4\",\"10\",\"7\",\"6\",\"3"
            }
        ]
    },
    {
        "expression": "(^[+]?\\d*\\.?\\d*[1-9]+\\d*$)|(^[+]?[1-9]+\\d*\\.\\d*$)",
        "raw_prompt": "Accepts only positive decimal values. Zero and negative numbers are non-matching.Allows zeros after last non-zero numeric value after decimal place for significant digits",
        "refined_prompt": "Accepts only positive decimal values. Zero and negative numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.\nMatch examples:\n- \"01.23\"\n- \"0.15\"\n- \"0.1568\"\nNon-match examples:\n- \"0\"\n- \"-0.18\"",
        "matches": [
            "01.23",
            "0.15",
            "0.1568",
            "516.485",
            "845.65",
            "8945.645",
            "7865.897",
            "849.897",
            "9.6",
            "6.3",
            "87.24",
            "46.21",
            "54.12346"
        ],
        "non_matches": [
            "0",
            "-0.18",
            ".0",
            "-49856",
            "-9-456",
            "-1595.159",
            "-9156.894",
            "-7989.159",
            "00000",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 909,
        "output": [
            {
                "text": " ^0[0-9]?\\.0[^0-9]*$|^[0-9]?\\.0[0-9]*$|^"
            },
            {
                "text": "\n# 1.3g = 1.3g\n\n5. Regular expression to match an email. Use the @ symbol as the delimiter between the parts of the string."
            },
            {
                "text": " (?:(?<num>\\+|\\-|0)(?<pct>[\\.\\d]{1})?(?:\\.0)?[\\+"
            },
            {
                "text": "\n^[0-9]+(\\.\\d+)?([eE][-+]?\\d+)?$\n\nA:\n\nRegular expression example:\n^"
            },
            {
                "text": "\n[^0-9+]\nA valid Decimal Number includes:., -, 0, 1, 2, 3, 4, 5, 6, 7, 8"
            },
            {
                "text": "\nr\"(?!^-?\\d+.?)[\\d.]+(?:-?\\d+)?$\"Allow zeroes after last non-zero digit after decimal"
            },
            {
                "text": " ^[-+]?0{1,}[.][-a-z0-9.]*$\n\nWhat is the correct solution for the question 'What is the"
            },
            {
                "text": " (?!.*(-).+)(?!(.*[,])\\.).*(0|[1-9]\\d*|\\d+(?:\\.\\d+)"
            },
            {
                "text": " ^([0-9]+[\\.]?[0-9]*[eE]([-+]?[0-9]+)?)$\nTest Cases:\n"
            },
            {
                "text": "\n\n^(\\\\d+)\\.?(\\\\d+)?$|^-?(\\\\d+)(\\\\.\\d+)$\n\n3. Write a regular"
            }
        ]
    },
    {
        "expression": "^(((((((0?[13578])|(1[02]))[\\.\\-/]?((0?[1-9])|([12]\\d)|(3[01])))|(((0?[469])|(11))[\\.\\-/]?((0?[1-9])|([12]\\d)|(30)))|((0?2)[\\.\\-/]?((0?[1-9])|(1\\d)|(2[0-8]))))[\\.\\-/]?(((19)|(20))?([\\d][\\d]))))|((0?2)[\\.\\-/]?(29)[\\.\\-/]?(((19)|(20))?(([02468][048])|([13579][26])))))$",
        "raw_prompt": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --&gt; 2099. Is enough for my purposes. Incorectly validates 02-29-1900. I created this to validate dates on a web form where the likely range will be 2000--&gt;2020. Seperators can be '.','/' or '-'\nAnyone know the rules for operator precedence for regex syntax?",
        "refined_prompt": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --&gt; 2099.\nMatch examples:\n- \"02-29-2004\"\n- \"1/31/1997\"\n- \"1-2-03\"\nNon-match examples:\n- \"02-29-2003\"\n- \"04-31-2003\"",
        "matches": [
            "02-29-2004",
            "1/31/1997",
            "1-2-03",
            "2-2706",
            "03/22.18",
            "110573",
            "3.311915",
            "2.2916",
            "11/1696",
            "11-3084",
            "2-29.32",
            "218-2085",
            "2292088"
        ],
        "non_matches": [
            "02-29-2003",
            "04-31-2003",
            "31-03-05",
            "12/123/4322",
            "2346-2345-2435",
            "2/33/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 911,
        "output": [
            {
                "text": " (Note: You must also check if it excludes the day.)\n- \"04-(01|02|03|04|05|06"
            },
            {
                "text": " m/(^|\\s)\\D*\\d{4}-\\d{2}-\\d{2}((?:\\"
            },
            {
                "text": "\n/^\\d{1,2}-\\d{1,2}-\\d{4}$/, '''\n"
            },
            {
                "text": " /^(01\\d|2[1-9]|3[01])-([0-2]\\d|3["
            },
            {
                "text": "\n[0-9]{2}-\n\n\n\nAs an Alien who is new to Earth, I am fascinated by the concept"
            },
            {
                "text": " \\d{1,2}\\w{3}\\s\\d{4}\\-\\d{2}\\-\\d{2}\\"
            },
            {
                "text": " \nMatch: \\d-\\d-\\d{4}|\\d-\\d-\\d,\\d-\\"
            },
            {
                "text": " This example is not supported since the date range (1900 -- &gt; 2099) in \"03-15-2003\" is invalid and"
            },
            {
                "text": " Regex: DATE_ORIGINAL_ORIGINAL[1-9]}d[-.][0-9]{2"
            },
            {
                "text": " \n^[0-9]{2}\\-(3[0-1]|[12][0-9]|0["
            }
        ]
    },
    {
        "expression": "^([2-9]\\d{3}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$",
        "raw_prompt": "yyyyMMdd with leap year validation, starting from year 2000 only.\nThe length of the expression is minimized, but still validates all entries.\nIf you want it with years like 1600 or separators, just ask :)",
        "refined_prompt": "yyyyMMdd with leap year validation, starting from year 2000 only.\nMatch examples:\n- \"20000101\"\n- \"20051231\"\n- \"20040229\"\nNon-match examples:\n- \"19990101\"\n- \"20053112\"",
        "matches": [
            "20000101",
            "20051231",
            "20040229",
            "99691129",
            "48821031",
            "88000229",
            "95430105",
            "29040731",
            "80840229",
            "53320229",
            "56830531",
            "36600531",
            "60231031"
        ],
        "non_matches": [
            "19990101",
            "20053112",
            "20050229",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "188414568",
            "98498765",
            "94848798",
            "51354987"
        ],
        "id": 913,
        "output": [
            {
                "text": " [01]\\d\\d[0-2]\\d\nUsing the following examples, do not generate a RegEx, but explain the concept\na) Valid dates between (in YYYYMMDD format):\n  Year: 2003, Month: 12"
            },
            {
                "text": " My regex is /(([0-9]{4})\\2[0-9]3)*(\\2\\/\\3)/\n\nA:\n\nI tried (^(199[1-9][0-9]|200[0-2"
            },
            {
                "text": "  \\d{4}-[12][0-9]\\d\nThe regular expression \"\\d{4}-[12][0-9]\\d\" matches four-digit numbers, followed by a dash and the two-digit year starting from the year 2000"
            },
            {
                "text": " \n\n(?P<year>\\d{4})\n      |\n      \\1(?P<month>\\d{2})\n      /\n      \\1(?P<day>\\d{2})\n|\n      ("
            },
            {
                "text": " (Regex: start with year 2000, end with day of year, and no more than 7 digits. If you don't have 7 digit days, you can use a conditional statement to check and allow up to 7 digits at the start)\n```\n\n####"
            },
            {
                "text": "\nimport re\nexampleString = \"\\\"20000101\\\"\"\nre.findall(r\"\\d{4}-[0-9][0-9]-[0-3]\",exampleString)\n\nExercise 4:\nCreate a Reg"
            },
            {
                "text": "\n(.*)(\\\\d{4})\\\\w{3}(\\\\d{2})$\nI hope I could help you out. Good luck!\n\nReply 4:\n\nAnother approach you can look into is using a simple regex like this:\n"
            },
            {
                "text": " You could use the.*\\d{4} with a starting year, which would match any group of four numbers (including leading zeroes) between a starting date (or beginning of string if no start date string) and end date string.\n- \"2005"
            },
            {
                "text": " ^(0[1-9]|1[012])\\d{3}$ and (\\d{4}|\\d{2})(\\d{2})?$\n\nExercise 2: Given the list of email addresses below, find"
            },
            {
                "text": "  \"(200[0-9]\\d|20[02]\\-\\d(\\d\\d)-\\d\\d)\\d\"\n(This is an example, it's just an answer and not a one-time solution, this is better to use"
            }
        ]
    },
    {
        "expression": "^(\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)$",
        "raw_prompt": "yyMMdd with leap years.\nMinimized expression.\nAs we have only 2 numbers for the years, dates 1600, 2000, etc are still validated.",
        "refined_prompt": "yyMMdd with leap years.\r\nMinimized expression.\r\nAs we have only 2 numbers for the years, dates 1600, 2000, etc are still validated.\nMatch examples:\n- \"001231\"\n- \"000229\"\n- \"040229\"\nNon-match examples:\n- \"003112\"\n- \"000431\"",
        "matches": [
            "001231",
            "000229",
            "040229",
            "351119",
            "600229",
            "040229",
            "720229",
            "880508",
            "440930",
            "250901",
            "760229",
            "231230",
            "861031"
        ],
        "non_matches": [
            "003112",
            "000431",
            "010229",
            "481565",
            "879875",
            "954987",
            "985687",
            "987654",
            "654987",
            "846257",
            "842613",
            "971397"
        ],
        "id": 914,
        "output": [
            {
                "text": " \\M[0-9]{2}\\D*\\K\\d{4}\"  \"\"\"\r\n\r\nfom_pattern = r\"\\M[0-"
            },
            {
                "text": " \\d{4}[0-2][1-9][0-9]\r\n\"\"\"\r\n\r\n# %%\r\nimport re\r\nfrom typing import Union"
            },
            {
                "text": " ^(0*[12]?[0-9]{3})(5[0-4]?)|^([1-9]?[0-9]"
            },
            {
                "text": " [a-zA-Z0-9]{4}\\d{2}\\d{2}\"\n\nA:\n\nI am really impressed with the answer provided by"
            },
            {
                "text": " [0-9]{3}(\\\\d{3})[0-9]{3}[0-9]{4}\n\r\nQuestion:   \""
            },
            {
                "text": " [0-9][0-9]?[0-9]?[0-9].|.?[1-9][0-9]?[0-"
            },
            {
                "text": "\n\"(0[1-9][0-9])\"|\"(0[1-9][0-9])\"|\"(0[1-9])\"\n\n"
            },
            {
                "text": " \"([0-9]{4}[0-9]{2}[A-Za-z]{2}[0-9]{3})\""
            },
            {
                "text": " /^0(?P<month>0)?[1-9][0-9]{2}[0-9]\\2|3[01]$/"
            },
            {
                "text": " \"^(\\d\\d)\" (010111) \r\n- \"001201\" (011201)\r\n- \"04010\" (2010)\r"
            }
        ]
    },
    {
        "expression": "^([01]\\d|2[0123])([0-5]\\d){2}$",
        "raw_prompt": "HHmmss without any separators. Hours in 24h format.",
        "refined_prompt": "HHmmss without any separators. Hours in 24h format.\nMatch examples:\n- \"235959\"\n- \"000000\"\n- \"012345\"\nNon-match examples:\n- \"240000\"\n- \"23:59:59\"",
        "matches": [
            "235959",
            "000000",
            "012345",
            "035005",
            "103026",
            "230303",
            "021912",
            "223112",
            "213234",
            "193556",
            "175345",
            "233704",
            "215341"
        ],
        "non_matches": [
            "240000",
            "23:59:59",
            "236060",
            "489797",
            "987987",
            "654987",
            "654654",
            "789789",
            "789456",
            "456789",
            "984657",
            "954768"
        ],
        "id": 915,
        "output": [
            {
                "text": " The following RegEx will return any date in the format of 24hhmmss without any separators.\nr'^\\d{2,4}\\d{2}:\\d{2}:\\d{2}$'\n\"\"\"\nfrom typing import List\n\n"
            },
            {
                "text": " [01]{2}\\d{2}(?:[\\:\\.,]\\d{2}) +\\d{6}\n\n2. Given a word with hyphens, match strings that have only hyphens. Hyphens in between words and numbers.\nExample"
            },
            {
                "text": " [\\d,]{6,7}$\"\"\"\n```\n\n2) Write a string using re.escape that can be used to display the content of a csv file that is loaded as an array using the json module.\n\n```python\n\"\"\""
            },
            {
                "text": " r\"\\d{4}-\\d{2}-\\d{2}\\d{2}\\d{2} \\d{2}:\\d{2}:\\d{2}\\d{2}\\d{1}\"\n\n4. Write a Reg"
            },
            {
                "text": " \"^[2-9]\\d{3}:\\d{2}:\\d{2}$\"\n3. Regex search to verify whether string is valid.\nExample:\n- \"1234\"\n- \"ab1234\"\nMatch examples:"
            },
            {
                "text": " (https://regex101.com/r/1xMfJQ/1)\n- \"00:23\"Generate a RegEx for this description. \nAnswer: (https://regex101.com/r/XV0oF0"
            },
            {
                "text": "\n(?i)\\d{4}(?:-|\\.|\\ )\\d{2}(?:\\d{2})? \\d{2}(?:\\d{2})?\nExercise 3:\nWrite a Python script that receives a string"
            },
            {
                "text": "\nimport re\nre_time = re.compile(r'([1-9][0-9]|0?[1-9])[0-9]{3}:[0-9]{2}:[0-9]{2}')"
            },
            {
                "text": "\n(^|[^\\d\\.])(\\d{1,2})(?:[.:]\\d{1,2})?(?=$|[^\\d\\.])\nYou know, I think I finally understood how RegEx works? I"
            },
            {
                "text": "\n- \"24(?H)i(?H)m(?H)s(?H)(?H)(?H)(?H)(?H)s(?H)(?H)(?H)s(?H)(?H)(?H)"
            }
        ]
    },
    {
        "expression": "(^\\d*\\.?\\d*[0-9]+\\d*$)|(^[0-9]+\\d*\\.\\d*$)",
        "raw_prompt": "This matches all positive decimal values. There was one here already which claimed to but would fail on value 0.00 which is positive AFAIK...",
        "refined_prompt": "Matches all positive decimal values.\nMatch examples:\n- \"0.00\"\n- \"1.23\"\n- \"4.56\"\nNon-match examples:\n- \"-1.03\"\n- \"-0.01\"",
        "matches": [
            "0.00",
            "1.23",
            "4.56",
            "485.48956",
            "615.546",
            "456.849",
            "5.549",
            "684.21",
            "98.21",
            "64.21",
            "654.2",
            "5198.15",
            "4859.12"
        ],
        "non_matches": [
            "-1.03",
            "-0.01",
            "-0.00",
            "-9851.156",
            "-15.18",
            "-56.2954",
            "-5.5948",
            "-516.21",
            "-5164.5",
            "-5943.975",
            "-645.0125",
            "-56.2464"
        ],
        "id": 916,
        "output": [
            {
                "text": " -\n0+[1-9][0-9]*(?:\\.[0-9]+)?\n\nI'm pretty sure this could also be used along with the positive/negative case but I would like to find an appropriate RegEx that would work in both directions.\n\nA:\n"
            },
            {
                "text": " ^[0-9]{1,10}\\.$\n\n2. Write a Python function that verifies that a given string starts with a digit.\n```python\ndef starts_with_digit(string):\n    if string and string[0].isdigit():\n        return"
            },
            {
                "text": " r'.+\\b(?<!-)(?:0+|[1-9][0-9]|3[01])\\.000000+\\b'\n\nUse Case 2: Validating Credit Card Numbers\n\nIn this use case, a forensic computer analyst is tasked with checking the validity"
            },
            {
                "text": " [0-9\\.]+\n\nExercise 4:\nWhat is a decimal separator?\nAnswer: A decimal separator is a symbol, usually a dot or comma, that separates groups of digits representing numbers less than one or larger than one.\n\nExercise 5:\nWhat is a"
            },
            {
                "text": " \\d\\.\\d(?:[eE][+-]\\d+)? should work.\n\nExercise 4: Write a Python script that takes a list of strings and returns a list of all strings that contain at least one colon (:). Use list comprehension to make your code more efficient ("
            },
            {
                "text": " The RegEx that should be returned is [positive decimal]\\.[negative or positive decimal].\n\nExercise 3: \nA website is displaying a headline of the following form: \"Today's Top 10 Quotes\".\nCreate a RegEx that will find all matches for the following formats of quotes:"
            },
            {
                "text": " Match examples should have ^ and $ in front of decimal parts, and non-match examples should have a period and a negative sign before any decimal.\n\nExercise 4: Use Regex to find all strings in a list that start with 'cat' or 'dog', and end with 'kitten'"
            },
            {
                "text": " \"[^.]*[0-9]\\.?\\d?\" \n\n2. Extract the price for each item in the following list:\n[\"Sale item 1: $5.99\", \"Sale item 2: $10.49\"]\nAnswer:\n\"5.99\"\n"
            },
            {
                "text": " \"[^-\\d-]\\d\n\nExercise 4: \nQuestion: Create a list of all the RegEx patterns that match the following statements or statements and comments in single quotes:\n1. The email address has to have a period before the domain.\n2. The URL must not"
            },
            {
                "text": "\n\"^[-+]?[0-9]?\\.?[0-9]+$\"\n\nExercise 2:\nMatch any alphanumeric character.\nGenerate a RegEx for this description. \nAnswer:\n[A-Za-z0-9]"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|1[012])/(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])/(29|30)|(0[13578]|1[02])/31)/[2-9]\\d{3}|02/29/(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "MM/dd/yyyy with 100% leap year validation starting from year 2000.\nIf this one doesn't fit your needs, just tell me.\nSorry for starting &quot;only&quot; from year 2000, this is so simple to change this, please ask if needed.\nEnjoy",
        "refined_prompt": "MM/dd/yyyy with 100% leap year validation starting from year 2000.\nMatch examples:\n- \"02/29/2000\"\n- \"02/29/2004\"\n- \"12/31/2001\"\nNon-match examples:\n- \"02/29/2100\"\n- \"02/29/2001\"",
        "matches": [
            "02/29/2000",
            "02/29/2004",
            "12/31/2001",
            "11/21/9802",
            "01/28/9466",
            "07/31/8066",
            "02/29/2344",
            "02/29/8608",
            "02/29/9404",
            "10/31/5991",
            "10/31/8787",
            "02/29/5496",
            "02/29/8608"
        ],
        "non_matches": [
            "02/29/2100",
            "02/29/2001",
            "1/1/2001",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 918,
        "output": [
            {
                "text": "\n(0?[1-9])/(1[0-2])/([3-9]\\d{2})[0-2]\n\nA:\n\nI had a similar"
            },
            {
                "text": " (.*),(.*)\n\nExercise: Write a RegEx code that validates phone numbers in the format xxx-xxx-xxxx.\nAnswer: /\\d{3}[-."
            },
            {
                "text": " (01).(012).(03).(01).(12).(02).(-20).(12).(1))\n\n# 2 - Generate Regular Expressions for Date and Time Pars"
            },
            {
                "text": " \n(?:^|-|^_|^\\d{1,2}/|\\w{3,8}|\\d{4})+$\n\n2. Create a Reg"
            },
            {
                "text": " \n(\\d{4}-\\d{2}-\\d{2})$|\\d{4}((1st|2nd|3rd)|(non-1st|"
            },
            {
                "text": " The valid input regex could be written as `^((0[1-9]|1[012])/(0[1-9]|[12][0-9]|3[01])"
            },
            {
                "text": " \\d/\\d/\\d\n\n*4. Validating Email Patterns*\n\nLet's create a regex from the below pattern describing a valid email. This regex must match the following conditions:"
            },
            {
                "text": " (a) \"^(0*[1-9][0-9]*)/(0*[1-9][0-9]*)(0*[1-9][0-"
            },
            {
                "text": " \\d{1,2}\\,\\d{2}\\/\\d{4} with zero or more numeric, commas and forward slashes. '\\d' represents any digit; '{"
            },
            {
                "text": " \"^\\d\\d-\\d\\d-\\d\\d(st|nd|rd|th)$\" is a valid regex. '\n\nThe final code, with the new"
            }
        ]
    },
    {
        "expression": "^\\-?[0-9]{1,3}(\\,[0-9]{3})*(\\.[0-9]+)?$|^[0-9]+(\\.[0-9]+)?$",
        "raw_prompt": "Formatted Number with \",\" as thousand separator and \".\" as decimal separator. now accept numbers without separators of thousands.",
        "refined_prompt": "Formatted Number with \",\" as thousand separator and \".\" as decimal separator. now accept numbers without separators of thousands.\nMatch examples:\n- \"10,000,000.123\"\n- \"3.14159265\"\n- \"546.4985\"\nNon-match examples:\n- \"2.7,1828183\"\n- \"49.26484,65\"",
        "matches": [
            "10,000,000.123",
            "3.14159265",
            "546.4985",
            "834.4897",
            "45.5194",
            "2.1569",
            "54.5497",
            "5.21945",
            "5.5675",
            "56.24957",
            "2.219",
            "2.54",
            "3.2465"
        ],
        "non_matches": [
            "2.7,1828183",
            "49.26484,65",
            "83.2149,",
            "652498,4.21,",
            "65.591,.51,6",
            "1984,.54.",
            "561.2162.546",
            ".2162.0246265,456",
            ".516,815.916",
            ".2,165",
            "462,561.,516,4",
            "156.2462451,165,"
        ],
        "id": 919,
        "output": [
            {
                "text": ".*(\\\\d+).*\\\\s[+-]?\\\\d{2}.*\\\\d,\\\\d*\n\n"
            },
            {
                "text": "\n/(?<!0)\\,[012345679]+,?(?!99999)/\n\nExercise 4:\n\nWrite"
            },
            {
                "text": " \n(\\d+\\.\\d+,?)+\\d0\n\n2. Exercise: Create a RegEx for this description.\n"
            },
            {
                "text": " \nI will use the \".\" as decimal separator and \",\" as thousand separator. \n\n6. Use Case 1\n"
            },
            {
                "text": " The number must be positive, at least one digit, the \",\" cannot appear at the beginning or end of number, the number cannot have one"
            },
            {
                "text": " \"(,\\d{3}(,\\d{3})*\\.)(,\\d{1,2})\"\n\n"
            },
            {
                "text": " \"[0-9]{3}\\.[0-9]{3}|[0-9]{2}\\.[0-9"
            },
            {
                "text": "\n(^\\d{1,3}[,.]\\d{3,4}$)|(^\\d{1,"
            },
            {
                "text": " \"(1,)|(0,)|(0,0)|(00,)|(000,)|(0.|0.)(\\."
            },
            {
                "text": " I am not sure I understand the exact requirement... I think this should get you started:\nimport re\n\nregex = re.comp"
            }
        ]
    },
    {
        "expression": "[AaEeIiOoUuYy]",
        "raw_prompt": "This simple reg-ex accepts any vowel letter.",
        "refined_prompt": "This simple reg-ex accepts any vowel letter(AEIOUYaeiouy).\nMatch examples:\n- \"a\"\n- \"o\"\n- \"e\"\nNon-match examples:\n- \"z\"\n- \"x\"",
        "matches": [
            "a",
            "o",
            "e",
            "i",
            "u",
            "y",
            "A",
            "E",
            "I",
            "O",
            "U",
            "Y"
        ],
        "non_matches": [
            "z",
            "x",
            "W",
            "T",
            "P",
            "l",
            "k",
            "j",
            "h",
            "g",
            "f",
            "d"
        ],
        "id": 923,
        "output": [
            {
                "text": " \\bx\\b\\b \n\nExercise 2: Write a Python program to search for vowels in a given string and return the count of vowels using regular expressions. \n\n```\nimport re\n\ndef count_vowels(string):\n    count ="
            },
            {
                "text": " (a) [aeiouy] (b) [aeiouy] (c) [aeiouy]\n\n#Python RegEx\n\nWe'll write a program to match a particular regex pattern from the given list of emails entered by a user and store them in a"
            },
            {
                "text": " \"^[a-zA-Z]+$\"\n2) Write a RegEx for the following description, accept only single letter symbols (a-z or A-Z).\n\nA:\n\nThe regular expression you use will depend on what your are trying to match. For a"
            },
            {
                "text": "\n(?i)([aeiouyaeiouy]|[^aeiouyaeiouy])(?=\\s)\n\nFor the remaining 4, I would recommend adding a.* after the second lookahead character ([aeiouyaeiou"
            },
            {
                "text": " /[a/aeiouy\\s]\\w/\n\n4. Write a regular expression that matches all occurrences of the following special characters in a string:\n-. (period)\n- $ (dollar sign)\n- @ (at sign)\n- [^\\s"
            },
            {
                "text": " /a[^ei]e/i\n\nHints:\n- Use the ^ and $ operators to specify the begin and end of a string respectively.\n\n**Second Exercise**\n\nIn the second exercise, you have been provided with a dataset of customer comments. Your job is to"
            },
            {
                "text": " A+\n\n7. Write a Python program that uses a RegEx to find out the names and the weights of the given items. The items are in the format \u201cItemName WeightPounds\u201d, for example: \u201ccar 200 75\u201d.\n\nHints\n-"
            },
            {
                "text": " (Any vowel with no preceding or following other letters) \\b(a|oe|eu|ei|ue|ou)\\b\n# Exercise 4\n# Create a list of words that contain at least one non-vowel letter. Use list comprehension and a RegEx.\n# Solution"
            },
            {
                "text": " \"z[^a-z0-9_]\"\n4. Match an email address from text with an email regex.\nAnswer:\n<em>@[a-zA-Z0-9\\.-]+</em>  # matches emails with @ at the beginning or end"
            },
            {
                "text": " ^[aeiouy]+$\n\nThis creates a bit of flexibility and can be used to match certain letters from the dictionary that are too long to fit in. \n\n(3)\nTo match any word that has an even number of letters, and does not include the letter '"
            }
        ]
    },
    {
        "expression": "^(?=.*[1-9].*$)\\d{0,7}(?:\\.\\d{0,9})?$",
        "raw_prompt": "Allows up to seven digits to the left and up to nine digits to the right of an optional decimal place.\nLeading zeros on the left of the decimal are accepted.\nOnly positive values are accepted.",
        "refined_prompt": "Allows up to seven digits to the left and up to nine digits to the right of an optional decimal place.\r\nLeading zeros on the left of the decimal are accepted.\r\nOnly positive values are accepted.\r\nRefined prompt:\nMatch examples:\n- \"1\"\n- \"0123456.123456789\"\n- \".123456789\"\nNon-match examples:\n- \".0123456789\"\n- \"0.0\"",
        "matches": [
            "1",
            "0123456.123456789",
            ".123456789",
            "456.549",
            "849.2462",
            "456.3456",
            "876.2466",
            "789549.246",
            "456.54987",
            "561.2154",
            "987.216897",
            "2495897.2165",
            "496"
        ],
        "non_matches": [
            ".0123456789",
            "0.0",
            "-1",
            "8941568456357.126",
            "8944563569516.21645",
            "19564.1985412657462",
            "95844563234546",
            "-945162",
            "-9565-+6*/8-95",
            "-+695-69-56",
            "-5+62-9+65/8956",
            "6++23"
        ],
        "id": 926,
        "output": [
            {
                "text": " \"\\d*(?:\\.0+)?[0-"
            },
            {
                "text": " (regex)^(\\\\d{1,7}"
            },
            {
                "text": " ^[0-8]\\d{0,14}\\"
            },
            {
                "text": " (\\d{3}\\.\\d{3}\\."
            },
            {
                "text": " [0-9]{1,4}.[0-"
            },
            {
                "text": " /[1-9]\\d{0,9}"
            },
            {
                "text": ".{1,10}?([13579][048]\""
            },
            {
                "text": " (at least 1 character (any character), \"0-9"
            },
            {
                "text": " Match Examples: \nMatch non-match examples: \n"
            },
            {
                "text": " \\d[0-9]\\d\\d\\d"
            }
        ]
    },
    {
        "expression": "\\{\\\\\\*\\\\bkmkstart\\s(.*?)\\}",
        "raw_prompt": "Applied to a .RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.",
        "refined_prompt": "Applied to a .RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"",
        "matches": [
            "{\\*\\bkmkstart TagAmountDigits}",
            "({\\*\\bkmkstart TagAmountText}",
            "{\\*\\bkmkstart\u2029ypQVK]b[,k`}",
            "{\\*\\bkmkstart\u2005}",
            "{\\*\\bkmkstart\u2008asdfa}",
            "{\\*\\bkmkstart\u2008ewfwdz}",
            "{\\*\\bkmkstart\u2008wdfasdaz}",
            "{\\*\\bkmkstart\u20082efsdffz}",
            "{\\*\\bkmkstart\u2008sdfz}",
            "{\\*\\bkmkstart\u2008adsfz}",
            "{\\*\\bkmkstart\u2008zadsfwe}",
            "{\\*\\bkmkstart\u2008hgfdhz}",
            "{\\*\\bkmkstart\u2008zkjhgk}"
        ],
        "non_matches": [
            "{\\*\\bkmkend TagAmountText}",
            "{\\*\\bkmkend fadsfqf}",
            "{\\*\\bkmkend TagAmdsfaountText}",
            "{\\*\\bkmkend adsf}",
            "{\\*\\bkmkend asdfsad}",
            "bkmkstartf2ef2e",
            "bkmkstartj676u",
            "bkmkstart67ju67",
            "bkmkstart67m7",
            "bkmkstartn67n6",
            "bkmksg76tart",
            "67hvbkmkstart"
        ],
        "id": 933,
        "output": [
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\" #"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            }
        ]
    },
    {
        "expression": "\"[^\"\\r\\n]*\"",
        "raw_prompt": "returns string between two quotes",
        "refined_prompt": "returns string between two quotes\nMatch examples:\n- \"Return Parent.DB.GetDataReader(\"CauseImmediateGet\", MyIncidentEventTypeID)\"\n- \"\"fadsfds\"\"\n- \"\"fwubeh98hu\"h9io\"\nNon-match examples:\n- \"Return Parent.DB.GetDataReader(CauseImmediateGet\", MyIncidentEventTypeID)\"\n- \"fewf\"Fsdf\"",
        "matches": [
            "Return Parent.DB.GetDataReader(\"CauseImmediateGet\", MyIncidentEventTypeID)",
            "\"fadsfds\"",
            "\"fwubeh98hu\"h9io",
            "fsiudjfn\"fsdij\"",
            "\"fhuidsh9i\"",
            "HUI\"ufijsd\"",
            "uibjks\"g8qw\"",
            "huds\"78gu832\"",
            "hui\"hfuisdy8\"",
            "\"reuwu\"",
            "\"hufij\"",
            "u90io\"ruew8ori23\"",
            "uio\"u8r932u\""
        ],
        "non_matches": [
            "Return Parent.DB.GetDataReader(CauseImmediateGet\", MyIncidentEventTypeID)",
            "fewf\"Fsdf",
            "FDS\"FD",
            "12/123/4322",
            "2346-2\"F345-2435",
            "\"2/3/5235",
            "@#dfk\"jnav",
            "12f3.21\"f3.213f",
            "\"qwerty@123.123",
            "341.4\"31v4f3.fv1",
            "abc11\"1def",
            "0j0jweB\"BBB"
        ],
        "id": 936,
        "output": [
            {
                "text": " ^[^\"]+\"fadsfdfgh(8)(?2)e9[^"
            },
            {
                "text": " (in regex)\n[^]f[^]h[^9io]\n\nAs"
            },
            {
                "text": " \"^(.+?)$\" \nTo solve more, practice is encouraged.\n\nQ"
            },
            {
                "text": " ^(.*)\\\"(?:\\((?1)\\))?$\nThe above example should also"
            },
            {
                "text": " \"returns\\s*(string|string\\s*)*;$\"\n\n4."
            },
            {
                "text": "\n[a-z\\d\\.]*  : Any sequence of alphanumeric AND / or"
            },
            {
                "text": " (f)|(wo)\n\n### Exercise 4\nCreate a RegEx pattern which will extract '"
            },
            {
                "text": " (f[a-z0-9_]*[^a-z0-9_-"
            },
            {
                "text": " myIncidentEventTypeID-?\nWhen parsing values from a SQL Query (for example, in"
            },
            {
                "text": " \"GetData\"\n\nExercise 2: Given a text with a RegEx match, extract the"
            }
        ]
    },
    {
        "expression": "^\\d{3}-\\d{7}[0-6]{1}$",
        "raw_prompt": "Airway bill no that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.",
        "refined_prompt": "Airway bill No. that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.\nMatch examples:\n- \"999-99999995\"\n- \"123-47859683\"\n- \"156-78965422\"\nNon-match examples:\n- \"123-47859689\"\n- \"9999999999\"",
        "matches": [
            "999-99999995",
            "123-47859683",
            "156-78965422",
            "319-78344900",
            "961-21496451",
            "767-65572445",
            "721-23909015",
            "662-31756823",
            "287-18129794",
            "044-95274085",
            "866-43239106",
            "476-20607603",
            "990-35637882"
        ],
        "non_matches": [
            "123-47859689",
            "9999999999",
            "9588-58964",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 937,
        "output": [
            {
                "text": "\n```\n^(?=.*(?<!10.*\\d)\\d{3}-\\d{4})(?=.*"
            },
            {
                "text": " [^0-9]999[0-9]9\n\nExercise 2: \nMatch examples:\n- \"000000101010\""
            },
            {
                "text": " 0(?<![0-9])[0-9](?![0-9])(?<![7][8][9])"
            },
            {
                "text": " (.*)-(.*-([0-9]+)?)\n\nIn our next post, we will dive deeper into the world of regex and learn to"
            },
            {
                "text": "  ^[\\dx-9](\\d{4})-(?=(\\d{3})+))[\\dx-9]$\n"
            },
            {
                "text": " [1,0][3-9][8-9][0-9][6-9][3-9], which is a character class where the"
            },
            {
                "text": "\nThe correct answer is `^[1-9][0-9]*-?[0-9]*$`.\n\n3)"
            },
            {
                "text": "  ([0-0-9]+)-([0-8][0-9])\n\n4. Find the following text and find all occurrences of the"
            },
            {
                "text": " Match when the last 1 appears in a 7,8 or 9. \n\n``` python\nimport re\n\n# Non-match for 7,"
            },
            {
                "text": " (^[0-9]{3}\\.[0-9]{2}\\.[0-9]{4}$|^[0-"
            }
        ]
    },
    {
        "expression": "(^[0-9]*[1-9]+[0-9]*\\.[0-9]*$)|(^[0-9]*\\.[0-9]*[1-9]+[0-9]*$)|(^[0-9]*[1-9]+[0-9]*$)",
        "raw_prompt": "Positive real number greater than zero.",
        "refined_prompt": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR .\"\n- \"010001.011010E\"",
        "matches": [
            "0.01",
            "010001.011010",
            ".234",
            "156",
            "456",
            "46",
            "873857",
            "687",
            "68",
            "46.46845",
            "546.23453",
            "486.278",
            "987.12659"
        ],
        "non_matches": [
            "0.00 OR .",
            "010001.011010E",
            "1.234.5",
            "498.4564t",
            "7fgy",
            "f7gyf324",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 940,
        "output": [
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: r\".\\d{1,3}\\.\\d{3}\" (allow up to 4 digits, any number of points, and no exponent)\n\nExercise 2:\nMatch examples:\n- \"0.0002\"\n- \"010001.0110"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: 0\\.011010\nGenerate a RegEx for this description. ^^\\d{5}$\n\nExercise 7:\nMatch examples:\n- \"3.14159\"\n- \"13.5\"\nNon-match examples:\n-"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer:.{0,1}\\d{1,3}(\\.\\d+)\n\nExercise 4: Use a set of special characters to create a RegEx that matches all strings that start and end with the same character. \nAnswer: +(.)(.)"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: ^.*\\.(0+0|0+1|0+10|0+100|0+1e6|0+1e7)+[^0]+$\nDescription: match any number that contains more zeros than ones, between 10 and 100 z"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer:\n\n```\nimport re\n\ntext  = \"0.00 OR.\"\n\n# create pattern for either 0 or. and not following the comma with 0\npattern = re.compile(\"(^0|\\.?0$)\", re.IGNOR"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: Matching non-zero values.\n\n3. Write a python code that matches any number with less than 4 digits\n\nAnswer:\nimport re\n\npattern = r\"(\\d{0,3})\"\n\n#matching numbers with less than 4 digits"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: \n.*(?=\\.|0)|(?<=\\.|0)0[^0.]\n\nA fifth use case for RegEx is data cleaning. When working with large datasets, it can sometimes be difficult to properly format the data into a usable format"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: [^0-9.\\(\\)]+(\\.[0-9]?[\\,.\\-|]+)*\n\n#### Exercise 2:\nTry modifying the RegEx to match \"0.0102\".\n#### Exercise 3:\nTry matching \"0."
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: (?<!^[^-.]*\\.)[\\d]+[.]([\\d]+[.])$|(?!^|.*[^-.]*)0[.\\d]+(.[\\d]+)+. [\\d\\-]+\\"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer:  [0-9e-9,]+.\n\n(2) The decimal separator in a number may be any character, including other operators, that is not a decimal point or a comma. Match numbers with separators.\n0.1,0.23"
            }
        ]
    },
    {
        "expression": "^((\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5]))$",
        "raw_prompt": "Matches valids TCP/IP-Adresses",
        "refined_prompt": "Matches valids TCP/IP-Adresses.\nMatch examples:\n- \"1.198.0.1\"\n- \"100.10.0.1\"\n- \"200.200.123.123\"\nNon-match examples:\n- \"..12.23\"\n- \"a.23.345\"",
        "matches": [
            "1.198.0.1",
            "100.10.0.1",
            "200.200.123.123",
            "248.039.254.226",
            "0.41.53.4",
            "41.245.010.252",
            "238.208.55.203",
            "212.130.0.2",
            "218.087.14.216",
            "230.68.31.202",
            "91.223.255.4",
            "254.12.067.225",
            "9.010.002.0"
        ],
        "non_matches": [
            "..12.23",
            "a.23.345",
            "400.500.300.300",
            "23r.32r32",
            "r2.323.25",
            "r..t34.t34.",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12). 62509",
            ".gm.ail"
        ],
        "id": 946,
        "output": [
            {
                "text": " ([a-z0-9]{1,3}\\.[a-z0-9]{1,3}\\.[\\d\\.]*\\.[\\d]{1,3}|["
            },
            {
                "text": "\nhttps://regex101.com/r/JZq3Xm/1\n\n\n2) Give an example of a Python code that detects if a string matches the pattern \"*(abc|xy"
            },
            {
                "text": " /\\A\\.\\d+(?:\\.\\d+)+\\.\\A/g\n\nExample 3: Matching Email Addresses\nSometimes you may need to match email addresses that follow a certain pattern."
            },
            {
                "text": " \n[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,7}\\.[0"
            },
            {
                "text": " (^[0-9.]-?[0-9.]$)|(^\\.[0-9]+$)\n[Host 2] In this quiz, we need to generate a RegEx for IPv"
            },
            {
                "text": " You can match IP addresses either by their first 10 digits (before the first '.') or by their last 4 digits (before the first '.'), depending on the format you want to match.\n\n3."
            },
            {
                "text": " (\\d{1,3}.\\d{1,3}.\\d{1,3}/\\d{1,3}.\\d{1,3}.\\d{1,3}"
            },
            {
                "text": " \"\\d\\d\\.\\d\\d\\.\\d\\d.\\d\\d\"\n\nExercise 2: Using your RegEx module from the answer in Exercise 1, print the list of matches and"
            },
            {
                "text": " \n-.*\\.\\d*\\.\\d*\\.\\d*\n\nExercise 2: Regex Test to Check if IP Address is Valid\n- Write the Python code to perform a regex check"
            },
            {
                "text": " /^[^.]+.[^.]+[^.]+$/ \n\nExercise 4\nWrite a regular expression that matches IP numbers within the range of 172.25.168.0 to 172"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "MM/dd/yyyy with 100% leap years. Valid since year 1900.\nMM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy\nThis was a request from a user in http://www.regexlib.com/REDetails.aspx?regexp_id=1038",
        "refined_prompt": "MM/dd/yyyy with 100% leap years. Valid since year 1900.\r\nMM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy\nMatch examples:\n- \"01/31/1905\"\n- \"1/9/1900\"\n- \"2/29/1904\"\nNon-match examples:\n- \"31/01/2005\"\n- \"02/29/2005\"",
        "matches": [
            "01/31/1905",
            "1/9/1900",
            "2/29/1904",
            "05/11/7125",
            "6/30/2193",
            "02/29/9200",
            "02/29/5200",
            "12/31/1968",
            "9/07/9325",
            "07/24/9722",
            "12/30/5484",
            "7/31/7906",
            "2/29/1912"
        ],
        "non_matches": [
            "31/01/2005",
            "02/29/2005",
            "2/29/2005",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 947,
        "output": [
            {
                "text": " /(^|(?:|;))."
            },
            {
                "text": "\n- r\"^0|[5"
            },
            {
                "text": " ([1-9][0-9]"
            },
            {
                "text": " MMM-DD-yyyy(3"
            },
            {
                "text": " dd/mm/yyyy or dd/"
            },
            {
                "text": "\n-.+/\\d{1"
            },
            {
                "text": " I would like a regex for:\n["
            },
            {
                "text": " M/d/yyy or M/"
            },
            {
                "text": "\n[^\\d]?\\d"
            },
            {
                "text": " (.*?)([1-9]"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z].*|[1-9].*)\\.(((j|J)(p|P)(g|G))|((g|G)(i|I)(f|F)))$",
        "raw_prompt": "Regular expression to limit types of files accepted. This example matches .jpg and .gif files only.",
        "refined_prompt": "Regular expression to limit types of files accepted. This example matches .jpg and .gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"",
        "matches": [
            "filename.jpg",
            "FileName.JPG",
            "filename.gif",
            "fdsfs.jpg",
            "fvystd.jpg",
            "yug78.JPG",
            "g67fg.JPG",
            "q76f.JPG",
            "q7f.JPG",
            "q76f.GIF",
            "yh98h.GIF",
            "78tgy8.GIF",
            "g7yhb.GIF"
        ],
        "non_matches": [
            "filename.png",
            "filename.xxx",
            "filename.bmp",
            "f23ewf.dhua",
            "g78u.7y8uh",
            "f34.34f34",
            "f34.t3545y",
            "jpgjpg",
            "gif",
            "gpjjgpig",
            "jpggifjpg",
            "jpgif"
        ],
        "id": 949,
        "output": [
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer:\n/filename\\.(jpg|gif)$/\n\n---\n\n**5. Writing Regular Expressions for URL Normalization**\n\nWeb scraping often requires normalizing URLs to a standard format before further processing. Regular expressions can"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: \"^(.+)\\.(jpg|gif)$\"; \n\n4. Write a RegEx to validate that an input is a valid string.  Example: it must be at least 8 characters long.  \nmatch example"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: [\\w.-]+|\\.jpg|\\.gif|\\.png  # The file name will be matched if any of these 4 types are included in it. \nWe hope this chapter helped you understand the use of Python Regular Express"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: https://blog.golang.org/2012/09/23/simple-regular-expression-for-image-filter-or-generator\n\nConclusion\nPython's `sorted()` and `re` libraries"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: \\b(file_\\w+\\.jpg|file_\\w+\\.gif)\\b[\\w.]*\\\\([A-Z\\\\-\\d]*\\\\.[a-z]*\\)\\z. Ignore"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: [\".jpg[.]\\(j(p\\(\\(\\)))\", \".gif\".]\n\n4. How can regular expressions be used to find files containing specific words?\nBy using the word pattern specified in the regular expression."
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: re.compile(r\".+\\.(jpg|gif)$\")\n\n3. Solution:\n\nTo ensure that a specific image file is uploaded only by users who are users with the \"admin\" role, use the"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: filename\\.([^.]*)$\n\n2. Write a Python function that accepts two arguments- a file path and a search term, and returns the files that match the term using regular expressions. \nSolution:\nimport re"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: /^[^\\.]+\\.[^.]+$/\n\n    Student Question: \n\nHi everyone, I have been working on the file system architecture subsection of our course and I am struggling to implement the file"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: filename.png\\.([^.]+?)$\n\nCode examples\nExercise 1: Write a regEx to match filenames in this format: \"_date_video.mp4\"\nAnswer: \"\\\\d{"
            }
        ]
    },
    {
        "expression": "^(\\$\\ |\\$)?((0|00|[1-9]\\d*|([1-9]\\d{0,2}(\\,\\d{3})*))(\\.\\d{1,4})?|(\\.\\d{1,4}))$",
        "raw_prompt": "Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign. Also makes sure theres no more than 4 decimal places. Takes out leading zeros if the number isn't 0, and protects against blank entries.",
        "refined_prompt": "Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign. Also makes sure theres no more than 4 decimal places. Takes out leading zeros if the number isn't 0, and protects against blank entries.\nMatch examples:\n- \"$ 123.4\"\n- \"$00.5\"\n- \"200,000\"\nNon-match examples:\n- \"$012,234.44\"\n- \"-39.05\"",
        "matches": [
            "$ 123.4",
            "$00.5",
            "200,000",
            "$48",
            "$486",
            "$845",
            "$ 513",
            "$453.15",
            "$483.1",
            "$486.1",
            "$987.6",
            "818",
            "987"
        ],
        "non_matches": [
            "$012,234.44",
            "-39.05",
            "$45,23,330.00",
            "$12/123/4322",
            "$2346-2345-2435",
            "$43.v234",
            "$/5/5/5",
            "$/5/5/20022",
            "$qwerty@123.123",
            "$adfa2",
            "(0xx12) 62509$",
            "$12/132/90"
        ],
        "id": 952,
        "output": [
            {
                "text": " \n\"(0[1-9])([0-9]{"
            },
            {
                "text": " \n[\\$][0-9]+\\.[0-9"
            },
            {
                "text": " Regex: ^[0-9]{0,3}(["
            },
            {
                "text": " \"^(-?\\d+.\\d{0,2})\\"
            },
            {
                "text": " \\-?( \\d+| \\,|.)+ \\d"
            },
            {
                "text": " \"\\\\d{3}(\\\\.\\d{2})?"
            },
            {
                "text": "^(?<no_space>[0-9]+( \\d"
            },
            {
                "text": "\n\\d{2,3}\\.\\d\\d{2"
            },
            {
                "text": " 0|00.00|(\\.00){1,4}|"
            },
            {
                "text": "\n$[0-9]{3}($[0-9"
            }
        ]
    },
    {
        "expression": "^[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}$",
        "raw_prompt": "Simple Microsoft product key check.",
        "refined_prompt": "Simple Microsoft product key check.\nMatch examples:\n- \"12345-12345-12345-12345-12345\"\n- \"ABCDE-ABCDE-ABCDE-ABCDE-ABCDE\"\n- \"AB5DE-AB5DE-AB5DE-AB5DE-AB5DE\"\nNon-match examples:\n- \"12345-123-123456-12345\"\n- \"ABC-ABCDEF-ABCDE-ABCDE\"",
        "matches": [
            "12345-12345-12345-12345-12345",
            "ABCDE-ABCDE-ABCDE-ABCDE-ABCDE",
            "AB5DE-AB5DE-AB5DE-AB5DE-AB5DE",
            "7BCWV-OJ3E7-W2UM5-UK79C-JH6OS",
            "EFIK7-CR9SA-6WZ8A-6UNIT-LB1AU",
            "1VM9K-YGNA2-OU7IK-MKNG1-2H3K3",
            "C9AST-YJ1T3-VOAAA-T5NOL-J4URQ",
            "IBA1N-PF4LO-X8SN8-2WY27-5GYFT",
            "71BLA-GD9HQ-8W8Q9-ZZPUB-8SKJS",
            "Y6ZE7-QOBKO-T29GP-75K1R-CYJAM",
            "BR4EQ-3NDYK-14LHF-3C9KX-L7GL3",
            "TO4CZ-PQI26-F1E8Q-YKROR-J5TUC",
            "BUGGI-6ZWXO-JQOJ2-CE3GE-WUP33"
        ],
        "non_matches": [
            "12345-123-123456-12345",
            "ABC-ABCDEF-ABCDE-ABCDE",
            "12AB5-ABC-12AB567-12AB5",
            "95841984-4895-4fs8d4-15sf",
            "FDS51-F459SDFS--84D",
            "498SFD4-SFD49SD84-F489-59",
            "9FS48-FDS51984-F9DS5-5F9",
            "9F8S-849DF984-15FS9-591F",
            "954FG-591D988-494FWE599",
            "489-489FW-FS-594",
            "159-F9W5E84F-98F5",
            "8914-FWE1598-195FW"
        ],
        "id": 954,
        "output": [
            {
                "text": " (?<![-_a-zA-"
            },
            {
                "text": "\n\nRegular expression: (0123456789)"
            },
            {
                "text": " \\A[-A-z0-9_]+"
            },
            {
                "text": " (12345|[^123])([^123"
            },
            {
                "text": "\n\\b(?=.+?)(?="
            },
            {
                "text": " To make sure the input format is correct, we should use"
            },
            {
                "text": " ([0-9]{5})-([0-"
            },
            {
                "text": "\n\nRegex for Password:\n^(?="
            },
            {
                "text": "\n[a-zA-Z0-9-"
            },
            {
                "text": " {^[A-Z]{3}-$"
            }
        ]
    },
    {
        "expression": "&amp;\\#x0*(0|1|2|3|4|5|6|7|8|B|C|E|F|10|11|12|13|14|15|16|17|18|19|1A|1B|1C|1D|1E|1F);",
        "raw_prompt": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).",
        "refined_prompt": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n- \"&amp;#x0020;\"\n- \"&amp;#xDFFF;\"",
        "matches": [
            "&amp;#x2;",
            "&amp;#x001F;",
            "&amp;#x0000000000000000000000000000000000000001B;",
            "&amp;#x000000000000000000000000000000000000000000000000000000000000000000000000004;",
            "&amp;#x0000000000000000000000000000000000000000000000000000000000000000000011;",
            "&amp;#x000000000000000000000000000001E;",
            "&amp;#x000000000000000000000000000000000001D;",
            "&amp;#xF;",
            "&amp;#x000000000000000000000001D;",
            "&amp;#x0000000000010;",
            "&amp;#xB;",
            "&amp;#x000000000000000000000000000000000000000000016;",
            "&amp;#x00000000000000000000005;"
        ],
        "non_matches": [
            "&amp;#x0020;",
            "&amp;#xDFFF;",
            "&amp;34f2vf42e",
            "&amp;12/123/4322",
            "&amp;2346-2345-2435",
            "&amp;43.v234",
            "&amp;@#dfkjnav",
            "&amp;/5/5/20022",
            "&amp;qwerty@123.123",
            "&amp;adfa2",
            "&amp;(0xx12) 62509",
            "9&amp;9999@gmail"
        ],
        "id": 957,
        "output": [
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            }
        ]
    },
    {
        "expression": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)|(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "raw_prompt": "Validador de CPF ou CNPJ brasileiro. Utilizado em campos que podem receber os dois valores, como um campo de busca, que pode buscar por CPF ou CNPJ, como era o meu caso.\n[00.000.000/0000-00], [123.456.789-98],[00000000000000] e [12345678998]\nEnjoy! =)",
        "refined_prompt": "The provided regex pattern appears to match strings that represent either a Danish CPR number (with or without separators) or a 14-digit numeric string, depending on the format.\nMatch examples:\n- \"00.000.000/0000-00\"\n- \"123.456.789-98\"\n- \"12345678901234\"\nNon-match examples:\n- \"12.123.123.0001.12\"\n- \"123.456.789.89\"",
        "matches": [
            "00.000.000/0000-00",
            "123.456.789-98",
            "12345678901234",
            "68874610114",
            "09B027c994/2311-87",
            "67534682031",
            "57h394u262/5229-44",
            "88842034209",
            "39929489443824",
            "45r7632515/6263-78",
            "78369540356",
            "01207658626540",
            "43050587251"
        ],
        "non_matches": [
            "12.123.123.0001.12",
            "123.456.789.89",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "34.31",
            "12/132/90"
        ],
        "id": 965,
        "output": [
            {
                "text": " \n\nconst regex = new RegExp(/(?"
            },
            {
                "text": " \n\n[0-9\\.]{1,"
            },
            {
                "text": " \\d{3}(?:\\.\\d{"
            },
            {
                "text": " https://regex101.com/r/hI"
            },
            {
                "text": " \n\\d\\w.\\d{4}"
            },
            {
                "text": " \"([0-9]+).[0-9]+"
            },
            {
                "text": " [a-zA-z0-9]*"
            },
            {
                "text": "\n\nThe correct expression would be \\d{14}"
            },
            {
                "text": " The regex would be something like \"/[123].*(["
            },
            {
                "text": " (\\d\\.)+$\n\nExercise 5"
            }
        ]
    },
    {
        "expression": "(^\\d*\\.\\d{2}$)",
        "raw_prompt": "If you need a textbox to allow only positive numbers with two decimal places, try this. I wanted the user to be able to enter any type of currency amount (US of course) but also have two decimal places for database field.",
        "refined_prompt": "allow only positive numbers with two decimal places\nMatch examples:\n- \"12.56\"\n- \"0.25\"\n- \"156.56\"\nNon-match examples:\n- \"-123.45\"\n- \"1.023\"",
        "matches": [
            "12.56",
            "0.25",
            "156.56",
            "489.12",
            "4865.21",
            "89456.21",
            "89465.65",
            "8975.54",
            "489516.11",
            "49856.66",
            "49856.99",
            "54.77",
            "5219.88"
        ],
        "non_matches": [
            "-123.45",
            "1.023",
            "1.2",
            "48.218",
            "45.2",
            "189.",
            "8956.2",
            "48956.219562",
            "48956.2498.89489",
            "49825.495",
            "48953.519",
            "87"
        ],
        "id": 971,
        "output": [
            {
                "text": " \n\n```python\nimport re\n\ntexts = [\"12.56\", \"0.25\", \"156.56\", \"-123.45\", \"1.023\", \"hello, world\"]\n\nfor text in texts:\n    if re.match(r'^\\"
            },
            {
                "text": " \"^[0-9]+\\.[1-5][0-9]$\"\n- \"11.5\"\n        \n        \n3. Write a Regular Expression with optional groups to capture the type of fruit and the quantity.\n```python\n# Group 1 will capture the name"
            },
            {
                "text": " Match only positive numbers with two decimal places and non-match numbers that either exclude an integer or have more than two decimal places.\n\n\n\nTitle: Exploring the Marvels and Dangers of Science and Technology: A Journey through Evaluation and Improvement\n\nHey there, fellow Aliens! Are you ready"
            },
            {
                "text": " Use '0(\\\\d]+' to express the first \"1\" (at the start) and the next \"9\" (at the end) followed by two digits.\n\nLecture Script: Comparing and Contrasting Different Types of Functions and Graphs\n\nContents:\n-"
            },
            {
                "text": " \"^-?\\d{1,3}(,\\d{3})+$\".\nExample 2: Search for a word in a paragraph that has six or more characters and starts and ends with the same character.\nSearch examples:\n- \"The cat in the hat\"\nNon"
            },
            {
                "text": " [^.-]+[-+]\n\n3. Write a RegEx that matches email addresses that have a username of \"admin\" and a domain of \".org\" or \".net\" only.\nAnswer:\n[\\w.-]+[\\w.-]+\\.[a-zA-Z"
            },
            {
                "text": " Match the words that represent both integers and float value in the text and only display the numbers with two decimal places.\n\nStudent: Hi, I have some homework questions about Python and list comprehension.\n\nTutor: Sure, what do you need help with specifically?\n\nStudent: I'm"
            },
            {
                "text": " \nRegular expression \"^[0-9]*\\.[0-9]{1,2}$\"\n\n4. Find all the email addresses in this text:\n\"Example subject: Example@abc.com Example.com\"\n\nEmail examples:\nExample@abc."
            },
            {
                "text": " Allow only positive numbers with two decimal places\n\nExercise 5: \nGenerate a RegEx that matches email addresses that have a domain name of \".com\".\nAnswer: [Email address with.com in the domain]\n\n\n\nSection: The Importance of Effective Communication in a Company"
            },
            {
                "text": "\nr\"^-?[0-9]{0,2}(-?[0-9]{0,2})?\\.(05|07|08|09|0{3})$\"\n\n## Advanced: Match examples\n1. Match only negative numbers with two decimal"
            }
        ]
    },
    {
        "expression": "^[NS]([0-8][0-9](\\.[0-5]\\d){2}|90(\\.00){2})\\040[EW]((0\\d\\d|1[0-7]\\d)(\\.[0-5]\\d){2}|180(\\.00){2})$",
        "raw_prompt": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.\nRange check for minutes and seconds (0-59),\nmax.latitude 90.00.00, max longitude 180.00.00",
        "refined_prompt": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00.00 W000.00.00\"\nNon-match examples:\n- \"N91.00.00 E181.00.00\"\n- \"Z34.59.33 W179.59.59\"",
        "matches": [
            "N90.00.00 E180.00.00",
            "S34.59.33 W179.59.59",
            "N00.00.00 W000.00.00",
            "S90.00.00 E013.15.23",
            "S30.44.42 W027.59.59",
            "S35.47.34 E180.00.00",
            "N90.00.00 E180.00.00",
            "N15.59.23 W028.14.59",
            "S90.00.00 E088.37.23",
            "S90.00.00 E180.00.00",
            "N90.00.00 W165.48.19",
            "N84.48.25 W180.00.00",
            "N39.48.02 E180.00.00"
        ],
        "non_matches": [
            "N91.00.00 E181.00.00",
            "Z34.59.33 W179.59.59",
            "N00.00.00 W181.00.00",
            "fasd@fds.fasd@",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 972,
        "output": [
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.03"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.01"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.04"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            }
        ]
    },
    {
        "expression": "/\\*((?!\\*/)[\\d\\D\\s])*\\*/",
        "raw_prompt": "Matches /* style comments */.\nMatches whitespace (so can detect tabs, etc.)\nProblems with nested comments.",
        "refined_prompt": "Matches /* style comments */.\r\nMatches whitespace (so can detect tabs, etc.)\nMatch examples:\n- \"/* CSS comments */\"\n- \"/* multi-line SQL/CSS/Etc comments */\"\n- \"/*2fsdffd*/\"\nNon-match examples:\n- \"&lt;!-- doesn't match --&gt;\"\n- \"-- won't match and //won't match\"",
        "matches": [
            "/* CSS comments */",
            "/* multi-line SQL/CSS/Etc comments */",
            "/*2fsdffd*/",
            "/*afdsafs */",
            "/* fweeafds*/",
            "/*adsfdf comments */",
            "/* CSS fewf3 */",
            "/* CSS 54g4g5 */",
            "/* Chmme45hftnts */",
            "/* Crfbhrfeh54nts */",
            "/* Ch45rfents */",
            "/* C4tfgh6j7ents */",
            "/* C98kints */"
        ],
        "non_matches": [
            "&lt;!-- doesn't match --&gt;",
            "-- won't match and //won't match",
            "34f2vf42e*/",
            "12/123/4322*/",
            "2346-2345-2435*/",
            "*/43.v234",
            "@#dfkjnav*/",
            "/5/5/*/20022",
            "qwerty@123*/.123",
            "341.431v*/4f3.fv1",
            "*/(0xx12) 62509",
            "12/13*/2/90"
        ],
        "id": 977,
        "output": [
            {
                "text": " ^(/<)|(/\\*)|(/\\/|\\/\\*\\/)|(/\\."
            },
            {
                "text": "\n(<\\/style\\s*[^>]*>)\n\nA:\n\nI had this"
            },
            {
                "text": " /&lt;--/ and /&gt;/\n\n# /! /\\^ /\\"
            },
            {
                "text": "\nhttp://regex101.com/r/kT3YfQ/1\nThanks!"
            },
            {
                "text": " /--/\nI haven't found this exact regex for your scenario, but I've got a couple of"
            },
            {
                "text": " /&lt;(.*?)&gt;/S\n\nQ:\n\nSort Dictionary Elements ("
            },
            {
                "text": " a-e\nExplanation: a: any character\n      e: any character\n\nAs with"
            },
            {
                "text": " /(.*?)(/)|((?=\\*/))/\n3. Write a Javascript function that"
            },
            {
                "text": "!,&gt;,//\n\nA:\n\nUse the following Regex:\npublic class"
            },
            {
                "text": "\n/(?=(?:\\s|/))(.*?)(?:\\s|/)(?:<"
            }
        ]
    },
    {
        "expression": "^(102[0-3]|10[0-1]\\d|[1-9][0-9]{0,2}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports: 0 through 1023. Matches numbers in range of 0 through 1023.",
        "refined_prompt": "Port Numbers: Well Known Ports: 0 through 1023. Matches numbers in range of 0 through 1023.\nMatch examples:\n- \"0\"\n- \"123\"\n- \"1023\"\nNon-match examples:\n- \"1024\"\n- \"9999\"",
        "matches": [
            "0",
            "123",
            "1023",
            "1016",
            "1003",
            "1",
            "1000",
            "1009",
            "1002",
            "1008",
            "1020",
            "1010",
            "1023"
        ],
        "non_matches": [
            "1024",
            "9999",
            "99999",
            "45166",
            "49856",
            "4895684567",
            "7532",
            "8a",
            "76548915",
            "f67g8",
            "6f7y-89456",
            "-95616"
        ],
        "id": 984,
        "output": [
            {
                "text": " [0-9]+\n\n2. Match the following characters: A-Z, a-z, 0-9, and _.\nAnswer: [A-Za-z0-9]\\w\n\n3. Write a RegEx for a string"
            },
            {
                "text": " ([1-3]\\d{3}[1-9])|((0)\\d{1,3}\\d{1,3}\\d{1,3})\n\nExercise 2: Use RegEx to validate a file that begins with 'File'"
            },
            {
                "text": "  \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[\\W])^[a-zA-Z\\d\\W]*$\n\n3. Generate"
            },
            {
                "text": " (Port number [0-10] Digit ([0-9]{3}))\n\n\n\nQuestion 7: A recipe calls for 3/4 cup of sugar. If you want to make 2/3 of the recipe, how much sugar do you need?"
            },
            {
                "text": ".*1[0-9]|.*1[0-9]|.*2[0-9]|.*0[1-9]|.*2[0-5]|.*3[0-9]|.*"
            },
            {
                "text": "\nI think (?i)(?<![0-90-9a-z])(?=\\1)[0-9]{3,7}'\nExample:\nstring text = \"ThisIs0123456789abcdefghij"
            },
            {
                "text": "\n0..9numbers[0-9]\n\n6. How to read data files from the console using Python? You can use the built-in file read() function to read data from a file and then print it to the console using the print() function."
            },
            {
                "text": " 0[0-9]|1[0-9]{2}|[0-9]{3,5}\nExercise: What does \"0[0-9]{2}\" match exactly? \nAnswer: Any number that has two digits"
            },
            {
                "text": " (1[23][0-9])|(9[0-9])\n\nQ:\n\nIs it acceptable to return a boolean from a method and use that to check whether another string is an Anagram using streams?\n\nThe following class tests are currently"
            },
            {
                "text": " A RegEx for matching a number that contains only positive integers, with 0 being the smallest possible number.\n\n3. Matches string that contains alphanumeric characters: \n\\S\n- Match any character that is not whitespace or alphanumeric. \".\""
            }
        ]
    },
    {
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[2-9]\\d{3}|1[1-9]\\d{2}|10[3-9]\\d|102[4-9])$",
        "raw_prompt": "Port Numbers: Registered Ports: 1024 through 49151. Matches numbers in range of 1024 through 49151.",
        "refined_prompt": "Port Numbers: Registered Ports: 1024 through 49151. Matches numbers in range of 1024 through 49151.\nMatch examples:\n- \"1024\"\n- \"49151\"\n- \"30100\"\nNon-match examples:\n- \"1023\"\n- \"49152\"",
        "matches": [
            "1024",
            "49151",
            "30100",
            "49150",
            "49053",
            "49151",
            "7825",
            "24656",
            "1091",
            "49011",
            "1872",
            "49150",
            "49086"
        ],
        "non_matches": [
            "1023",
            "49152",
            "50000",
            "12/123/4322",
            "2346-2345-2435",
            "123*/",
            "738522",
            "875727",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "278257"
        ],
        "id": 985,
        "output": [
            {
                "text": ".NET is a software based on C# and.NET 4.0. It was developed by Microsoft, and uses the.NET Core API and is highly available.\n\n*Task #2:* Complete these examples using RegEx: \n- Check whether"
            },
            {
                "text": "\n\\b(?=0?\\.[0-9A-Fa-f]{2})\\d{1,5}(?=:|-)?\\d{4}\\b\n\nExercise 2: \nSearching for numbers"
            },
            {
                "text": " /(^[14]|[19]\\d{4}(?![0-9])\\S{8}|(?:[1-3]\\d{0,2})([1-9]\\d{0,2"
            },
            {
                "text": " The range of numbers we have to match can go up to 49151. The first number has to start with 1 or 0 through 9. So we can do this: [1-9]|10[0-1]|1001[0-9]"
            },
            {
                "text": " All numbers that contain more than a single digit, and fewer than 15 and greater than or equal to 1024\n2.Generate a RegEx that will match numbers in the range of 1 through 9999 in any order, and will not match numbers with more than three"
            },
            {
                "text": "\n((?:\\d{3}|[1-9][0-9]|0?\\d)\\.){3}\nExplain the expression in simple, understandable terms.\nExample:\n1.  If a number consists of 3 or"
            },
            {
                "text": " [a-zA-Z0-9]+[.][a-zA-Z][a-zA-Z0-9.]*\n\nExercise 2: Search for a pattern in a string that includes punctuation.\nAnswer: Use"
            },
            {
                "text": " \nThis will match numbers between 1024 to 49151.\n\"\"\"\ndef find_match_example(string):\n    return r\"^1024.*49151$\"\n\nprint(find_match_example(\"1000\")) #True\nprint(find"
            },
            {
                "text": " (.*)([0-9]) ([0-9])([0-9]) (.*)\n-Create a regex for the following pattern:\n- \"My first name is [A-Z a-z]+ and my last name is [ae"
            },
            {
                "text": " Regular expression: (?<![0-9])(?<!(?:1[0-9]){1}[0-9])\\d{3}(?![0-9])(?!(?:1[0-9])"
            }
        ]
    },
    {
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|5\\d{4}|49[2-9]\\d\\d|491[6-9]\\d|4915[2-9])$",
        "raw_prompt": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535. Matches numbers in range of 49152 through 65535.",
        "refined_prompt": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535. Matches numbers in range of 49152 through 65535.\nMatch examples:\n- \"49152\"\n- \"65535\"\n- \"50000\"\nNon-match examples:\n- \"49151\"\n- \"65536\"",
        "matches": [
            "49152",
            "65535",
            "50000",
            "49162",
            "65532",
            "60635",
            "49193",
            "65523",
            "65509",
            "65448",
            "63646",
            "49197",
            "57459"
        ],
        "non_matches": [
            "49151",
            "65536",
            "66000",
            "987456",
            "489516",
            "4895",
            "a49851",
            "489514815645",
            "1562",
            "156",
            "251625",
            "12975"
        ],
        "id": 986,
        "output": [
            {
                "text": " [0-9a-z]{4}[1-9a-z] {3}[0-9a-z] \\d{4}\n-Match examples:\n- \"49152\"\n"
            },
            {
                "text": " The description should generate a regular expression that matches any 3 digits between 49149 and 65532.\n\n8. Exercise 2: Create a Python function that takes in a string and replaces any occurrences of characters in a specific set with an"
            },
            {
                "text": " [a-zA-Z0-9\\-]*[0-9]+.*\n\nA:\n\nThat's because in this regular expression\n\"([0-9\\.]+)\"\n\nfirst part,"
            },
            {
                "text": " The description includes \"a series of digits and/or letters and possibly a hyphen\": /^[a-z0-9-]*$/i\n- \"49151\"A positive number, cannot have hyphen"
            },
            {
                "text": " \"\\d+\"\n2) Write a Regex to search a string that is between two words, and captures both the words in a pair. For example, \"The quick brown fox jumps over the lazy dog\" should match \""
            },
            {
                "text": "\\d{4}-\\d{2}(\\d{2})?\nThis is a fairly simple and generalized solution \nbut as a beginner, I think there might be a better way.\n\nA:"
            },
            {
                "text": " ^(?:(?<v>49151)|(?<v>.*?(?:49151)*))$\n- \"49152\"\n- \"65535\"\n- \"50000\"\n- \"5"
            },
            {
                "text": "\n\\b(?:[1-9]\\d{0,3}(?:\\.[1-9]\\d{0,2})?|1[8-9][0-9]{2}\\"
            },
            {
                "text": " \\d{4}-[a-z]{1}-450000\\\n\nExercise 2:\nUsing Regular Expression, extract emails from a given text. Extract emails such as email addresses and phone numbers. Your pattern"
            },
            {
                "text": " (Any RegEx that includes any digits from 49152 through 65535 and a hyphen between the numbers)\n\n5. Create a RegEx to match the following strings beginning with a number and ending in a letter: 10ab"
            }
        ]
    },
    {
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[1-9]\\d{0,3}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports &amp; Registered Ports: 0 through 49151. Matches numbers in range of 0 through 49151.",
        "refined_prompt": "Port Numbers: Well Known Ports &amp; Registered Ports: 0 through 49151. Matches numbers in range of 0 through 49151.\nMatch examples:\n- \"0\"\n- \"1023\"\n- \"49151\"\nNon-match examples:\n- \"49152\"\n- \"50000\"",
        "matches": [
            "0",
            "1023",
            "49151",
            "49151",
            "8086",
            "49023",
            "49082",
            "34",
            "49015",
            "49150",
            "40021",
            "49132",
            "10639"
        ],
        "non_matches": [
            "49152",
            "50000",
            "60000",
            "87945612",
            "84561",
            "984561",
            "948517",
            "a4",
            "5734768489451",
            "78945",
            "87645",
            "5915u"
        ],
        "id": 987,
        "output": [
            {
                "text": " Well Known Ports AND Matched Ports. Matches numbers in range of 0 through 49152.]\n\n4) Write a regrgex to find all numbers (0 through 9) between 0 and 9999. Make sure the regr"
            },
            {
                "text": " [RegEx] (http://www.myfirstregex.com/numbers.html)\nExamples:\nPort of Entry:\nhttp://www.www.com/port.html\nhttp://www.www."
            },
            {
                "text": " (4\\d\\.)*3[1-9] (or 4\\d{3})\n\nExercise 2: Match any of the following characters.\na) A-z\nb) A-Z\nc"
            },
            {
                "text": " ^[0-9][0-9]{0,10}$\n- \"0x1234\"Generate a RegEx for this description. \nAnswer: ^0[xX][0-9a-"
            },
            {
                "text": "\\d+\n\n2. Exercise: Write a regular expression to match all letters in a string except for the ones at positions specified by a list of letter indices (starting from 1).\nAnswer: ^([a-zA-"
            },
            {
                "text": ".\\d{1,7} - Matches one or more digits. \n- \"19\"Matches this number: 0, 1, 19. \n- \"01\"Matches this number: 1, 0,"
            },
            {
                "text": " [0-9][0-9][0-9]  or  [0-9]{3}[0-9]{2}[0-9]{1}\nIn short, your regex should be"
            },
            {
                "text": " /([0-9]{5})/\n\n4. Create a RegEx for the following description:\n\"A URL can include one or more spaces and one or more periods.\"\n\nAnswer: /\\/([a-"
            },
            {
                "text": " -?\\d*(.\\d{4})?\\s|\\-?\\d{3}(,\\d{3})*\\s-\\d{5}-\\d{1,4}\n"
            },
            {
                "text": "\n```python\nimport re\n\ndef get_matches(text, pattern):\n    \"\"\"\n    This function takes in text and a pattern and outputs all the matches in the text.\n    \"\"\"\n    return re"
            }
        ]
    },
    {
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports, Registered Ports &amp; Dynamic and/or Private Ports: 0 through 65536. Matches numbers in range of 0 through 65536.",
        "refined_prompt": "Port Numbers: Well Known Ports, Registered Ports &amp; Dynamic and/or Private Ports: 0 through 65536. Matches numbers in range of 0 through 65536.\nMatch examples:\n- \"1023\"\n- \"49151\"\n- \"65535\"\nNon-match examples:\n- \"65536\"\n- \"66000\"",
        "matches": [
            "1023",
            "49151",
            "65535",
            "65530",
            "65501",
            "65503",
            "65043",
            "64740",
            "63956",
            "8582",
            "195",
            "7371",
            "64121"
        ],
        "non_matches": [
            "65536",
            "66000",
            "67000",
            "-49856",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 988,
        "output": [
            {
                "text": " I would start by building out a list:\n-  \"^[a-zA-Z0-9_]*[a-zA-Z0-9_]*"
            },
            {
                "text": " [^a-zA-Z0-9_]\n\n2. Regex for Email Addresses - Regular Expression to validate a format such as this: (username@example.com"
            },
            {
                "text": " [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9"
            },
            {
                "text": " \"\\d+(?=-)\";\n- \"1 2 3 4 5 6 7\"Matches numbers 1 through 6. Captures the numbers in ascending order but with no limit on numbers. Mat"
            },
            {
                "text": "  \\d{1,65537}\\/\\d1\\d{5}\n\nCreate a function or method that receives a string, and will return a list of all the groups that"
            },
            {
                "text": "\n\n[0-9]{1,4}\n\nExercise 3:\nWrite a RegEx that will match any number of any of the following character sets: \\d, \\"
            },
            {
                "text": " 0-65535\n\n## Exercise 1:\nWhat is the difference between a regular expression metacharacter like \u201c.\u201d and the period \u201c.\u201d? Explain in"
            },
            {
                "text": "\n\nRegEx #2:\nMatch examples:\n- \"20.12.13.2\"\n- \"49151.\"\n- \"7-9-7\"\nMatch examples"
            },
            {
                "text": "\n- r\"^\\d.{0,2}$\"\n\nQuestion 6:\nWhat is a regular expression?\nAnswer:\nA regular expression is a sequence of characters that"
            },
            {
                "text": " Port Numbers: 0 through 65537 (0-65535 is non-match)\n\n* Write your Solution here\n\n**Exercise 3**\n\nWrite a RegEx for this Description"
            }
        ]
    },
    {
        "expression": "(^[0-9]{0,10}$)",
        "raw_prompt": "Good For Validating Phone numbers that are 0 to 9 in length",
        "refined_prompt": "Good For Validating Phone numbers that are 0 to 9 in length\nMatch examples:\n- \"123456\"\n- \"12354\"\n- \"456443\"\nNon-match examples:\n- \"456abcd\"\n- \"894561845684561\"",
        "matches": [
            "123456",
            "12354",
            "456443",
            "4651",
            "415",
            "46848",
            "5",
            "87",
            "195",
            "4856",
            "48569",
            "485657",
            "984526"
        ],
        "non_matches": [
            "456abcd",
            "894561845684561",
            "89456129845675",
            "784562a",
            "98455754a",
            "RFTVG567tgyuhb",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 991,
        "output": [
            {
                "text": " ^(?=.*[0-9])(?=.*[a-zA-Z])(?=.*[\\s\\S]).{8,}$\n\n2. Generate the correct RegEx pattern\nMatch examples:\n- \""
            },
            {
                "text": " \n[0-9]{10}[a-zA-Z0-9]\nValid phone number examples. Invalid phone number examples.\n```\n4. Write a Python code that validates if a given string contains only digits.\n``"
            },
            {
                "text": " The RegEx would be \"(^\\d{0}$|^\\d\\d\\d\\d\\d$|^\\d{2}\\d{4}$)\".\n\nExercise 2: Generate a list of all dates that are"
            },
            {
                "text": " ^((00[1-9][0-9]|0[1-9][0-9])\\d{2}|([1-9]\\d{3})[- ]?[0-9]{4}$\n\nEx"
            },
            {
                "text": "\nr\"(\\d{5})(\\d{3})?(\\d{4})?\"\n\nUse Cases \n1. Validating Phone numbers\n2. URL Form validation\n3. Email Validation\n4. Credit Card Number Validation\n5"
            },
            {
                "text": " r'(0[1-9]|1[012])\\d{4}-(\\d{4}-){3}\\d{4}'\n\n\n\nTitle: Exploring Mathematics through Mathematical Reasoning and Communication\n\nIntroduction:\n"
            },
            {
                "text": " [^^\\d]+. This pattern will match non-digit characters (a, b, c or d)\nExercise3: Write a Python RegEx using List Comprehension to match all phone numbers that start with either 1,2,3,4"
            },
            {
                "text": " \n```\n^(?=.{1,6}$)[0-9]{1,3}\\d{1,6}|0[0-9]{1,2}\\d{1,3}\\d{1,6"
            },
            {
                "text": "\nValid Phone Numbers: (0-9)\nAll other are invalid\n\n\n## 3. Grouping with the {n} and {g} Matches\n\nGrouping characters are an easy way to identify groups of characters in a string or in a list of"
            },
            {
                "text": "\n([0-9]{2}|[0-9]{3}|[0-9]{4}|[0-9]{5}|[0-9]{6}|[0-9]{7}|"
            }
        ]
    },
    {
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(--.*)",
        "raw_prompt": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server.",
        "refined_prompt": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server.\nMatch examples:\n- \"/* My Comment */\"\n- \"-- A single line comment\"\n- \"-- 78BHUJN\"\nNon-match examples:\n- \"*/ Won't work /*\"\n- \"// Not likely\"",
        "matches": [
            "/* My Comment */",
            "-- A single line comment",
            "-- 78BHUJN",
            "-- F7GYUBI",
            "-- 6F7YGUIN",
            "-- FFEWF3E",
            "-- G5TH5",
            "-- g45hb",
            "-- g4r5yhrt",
            "/* efr3 */",
            "/* f3ergt54 */",
            "/* g4ht5u7 */",
            "/* fe3rght */"
        ],
        "non_matches": [
            "*/ Won't work /*",
            "// Not likely",
            "- uh uh",
            "-afsd-fsd",
            "f-dsa-fa",
            "-fsda-f-",
            "f-ds-fsa-s-fads",
            "-afd adfdsaffasd",
            "//dasfbushf9da8u",
            "//h87fadisufbj",
            "//8uibjhfw2",
            "//y8huibj"
        ],
        "id": 996,
        "output": [
            {
                "text": "\n(?<!\\//)(?<!--)(?!\\/)( )*/ |--/\n\nI hope you found this helpful! Have fun coding"
            },
            {
                "text": " /\\*//\\s*(.*?)\\*/\n\nExample of using pattern findall\n```Python\nimport re\n\n#Pattern to"
            },
            {
                "text": " /^\\* [^\\n]*\\n\\*[^\\n]*$/\n\n2. Write a regex that matches any"
            },
            {
                "text": "\n```python\nimport mysql.connector\nfrom mysql.connector import Error\nimport re\n\ntry:\n# establish a connection\n    "
            },
            {
                "text": "\n((?:/{2}|\\#{2})\\s)*[^(/\\n\\f ]\nMatch any line that has two"
            },
            {
                "text": " /(?:\\/\\/)?[^\\/]*/\n\n2) Find all words that start with \"a\" or \"A\" (case insensitive"
            },
            {
                "text": "\n\"/\\*\\s*\\S*\\*/\"|\"--\\s+\\S+\"\n\nExercise 2:\nYou"
            },
            {
                "text": " You need to consider the line breaks in the comment first, and then decide if there's a \"normal\" or \"unusual\" combination of characters that should"
            },
            {
                "text": " /\\(\\W+(.+)\\)/g\n\n3. Write a RegEx to match words that begin with a prefix 'T' followed by any"
            },
            {
                "text": " \n(/^[^\\/\\n]*$)(?:\\s|\\/)(*+)\\/\\s\n\n(https://regex"
            }
        ]
    },
    {
        "expression": "^([A-Z\\d]{3})[A-Z]{2}\\d{2}([A-Z\\d]{1})([X\\d]{1})([A-Z\\d]{3})\\d{5}$",
        "raw_prompt": "US vehicle VIN numbers for vehicles with GVW &lt; 10k lbs",
        "refined_prompt": "US vehicle VIN numbers for vehicles with GVW &lt; 10k lbs\nMatch examples:\n- \"WDBCA45EXKA478654\"\n- \"X7PFG20Y1TD761390\"\n- \"HSCKU35F3RKV57445\"\nNon-match examples:\n- \"WDBCA45EXKA47865a\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "WDBCA45EXKA478654",
            "X7PFG20Y1TD761390",
            "HSCKU35F3RKV57445",
            "7TSES3215J3328107",
            "ZEOMN43G5YLG87833",
            "16EYH95589H152578",
            "B45OU30D30DP30420",
            "6LKIC28T759Y48971",
            "XLQYZ39U01T970054",
            "2JDYH05J6LHS33352",
            "D6IOK62X4B6X72112",
            "DPYUL85H4REU49363",
            "QD0WH41O7O3A83304"
        ],
        "non_matches": [
            "WDBCA45EXKA47865a",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "90438502+9503",
            "12/123/4322",
            "2346-2345-2435",
            "FDSAFA2EWDSF",
            "WEDSFER4FDE",
            "GDFGRTE45REDG",
            "GERDFG4FRD",
            "GREGGREWG34",
            "4EGRDFGRE34G34",
            "G45H6768KG"
        ],
        "id": 998,
        "output": [
            {
                "text": " \"WDBCA[\\d]*EXKB[\\"
            },
            {
                "text": "\n[^A-Z]|0[0-9"
            },
            {
                "text": "^[a-zA-Z0-9-._"
            },
            {
                "text": " \\d{4}[a-f]{12}\\"
            },
            {
                "text": " \"W[1-9]BC[1-9]["
            },
            {
                "text": " (WDBCA45|HSCKU|X7"
            },
            {
                "text": "\n(?=.{5,29}$)(\\"
            },
            {
                "text": " (WDBCA)\\w{2}\\((.*?)\\"
            },
            {
                "text": " \n(Match examples):\n- \"WDBCA45"
            },
            {
                "text": " [0-9A-Fa-f]{3}"
            }
        ]
    },
    {
        "expression": "^[0-9,+,(), ,]{1,}(,[0-9]+){0,}$",
        "raw_prompt": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314",
        "refined_prompt": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314\"\n- \"+91(22)311545\"\nNon-match examples:\n- \"91 (22) abc21\"\n- \"+91 (abc) 23321\"",
        "matches": [
            "0091(22) 31544",
            "+1 (116) 23314",
            "+91(22)311545",
            "156",
            "41564",
            "516451623",
            "5123",
            "1,234",
            "1,234,567",
            "12,345,678",
            "1, 2, 3, 4, 5",
            "1,234,567,890",
            "+1,234,567,890"
        ],
        "non_matches": [
            "91 (22) abc21",
            "+91 (abc) 23321",
            "00111623314abc",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 1000,
        "output": [
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            }
        ]
    },
    {
        "expression": "^(.){0,20}$",
        "raw_prompt": "This limits an HTML textarea to only be 20 characters. Built for an ASP:regularexpression tag to validate a textarea.",
        "refined_prompt": "Match strings of any characters (including letters, digits, symbols, and whitespace) that are between 0 and 20 characters in length.\nMatch examples:\n- \"I match\"\n- \"I match 2\"\n- \"7FGY8HU9JI\"\nNon-match examples:\n- \"hey I don't match at all\"\n- \"hey I don't matc54fdsdh at all\"",
        "matches": [
            "I match",
            "I match 2",
            "7FGY8HU9JI",
            "F7YGH8UF7",
            "YGFT6",
            "CYF7V",
            "Y7YVUBV7YUB",
            "VYGH",
            "YVUH",
            "YVUH",
            "YVYVUHVY8",
            "YVU8YVU",
            "8VUIBG9UB"
        ],
        "non_matches": [
            "hey I don't match at all",
            "hey I don't matc54fdsdh at all",
            "sd6f7g8F67YGIG8YBh9j0f6t7yg8ub",
            "sd6f7g8h9jNRTUU665G6560f6t7yg8ub",
            "sd6f7g8hJ56R57JB79j0f6t7yg8ub",
            "sd6f7g8h9j0f567JB67JB56t7yg8ub",
            "sd6f7g8h9j076BJ57BJ5f6t7yg8ub",
            "sd6f7gBJ57BJ67BJ568h9j0f6t7yg8ub",
            "sd6f7g87BJ567BJ56JB5h9j0f6t7yg8ub",
            "sBJ67BJ67BJ566d6f7g8h9j0f6t7yg8ub",
            "J75670f6t7yg8ub8K9OBM86KN7J56",
            "sd6f7g8h9j04478M66f6t7yg8ub"
        ],
        "id": 1001,
        "output": [
            {
                "text": " /^[\\w\\s]{0,20}[^\\w\\s]$/.\n\n4"
            },
            {
                "text": " ^[!a-zA-Z0-9 ].*[!.a-zA-Z0-9"
            },
            {
                "text": " \n\nimport re\npattern = re.compile(r\"(\\w*?)([A-Za"
            },
            {
                "text": " ^[A-Za-z0-9 \\-_]{0,20}$\n\n3."
            },
            {
                "text": " (.{6,20})\n- \"I don't match anything I wish to.\"\n- \"I don't match"
            },
            {
                "text": "\n/[a-z]+/gi\n\nExercise 5:\nCreate a RegEx that matches any word that"
            },
            {
                "text": " ([a-zA-Z ]+)\n\nExplanation: This Regular Expression matches one or more characters, separated"
            },
            {
                "text": " [^aeiou]*[aeiou]+[^aeiou]* (Any amount of any character"
            },
            {
                "text": " ^(?=.{0,20}[a-zA-Z0-9._-]{0"
            },
            {
                "text": " \\b[A-Za-z0-9 _.-][A-Za-z0-9._"
            }
        ]
    },
    {
        "expression": "^((\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)(?:\\.(\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)){3})$",
        "raw_prompt": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbitten.",
        "refined_prompt": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbidden.\nMatch examples:\n- \"0.0.0.0\"\n- \"255.255.255.255\"\n- \"168.129.2.255\"\nNon-match examples:\n- \"02.234.2.1\"\n- \"168.192.0.256\"",
        "matches": [
            "0.0.0.0",
            "255.255.255.255",
            "168.129.2.255",
            "119.2.253.195",
            "6.152.93.3",
            "252.251.203.254",
            "252.62.254.251",
            "186.252.30.250",
            "168.255.5.125",
            "218.47.131.2",
            "223.96.134.254",
            "4.252.218.255",
            "71.116.173.6"
        ],
        "non_matches": [
            "02.234.2.1",
            "168.192.0.256",
            "1233.0.0.1",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "abc111def",
            "12/132/90"
        ],
        "id": 1003,
        "output": [
            {
                "text": " /^[\\d]?[a-f]{8"
            },
            {
                "text": "\n^(?:[1-9][0-9]|"
            },
            {
                "text": " The possible matches are (as I saw): 0\\.0\\.0"
            },
            {
                "text": " ^(?:0(.|\\n){0,1}\\"
            },
            {
                "text": " /(?:.*?[0-9][0-9.]"
            },
            {
                "text": "\n^(?!.{4,}$)(?=(?:"
            },
            {
                "text": " Any four digits in range 0-255 followed by a comma character,"
            },
            {
                "text": "\n(([0]{0}[0-9]{"
            },
            {
                "text": " \n/(^(0|1)*0\\.(0|"
            },
            {
                "text": "\nThe regular expression for such ip address validation is: ^(?!"
            }
        ]
    },
    {
        "expression": "^[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive numbers, greater than zero",
        "refined_prompt": "Allows only positive numbers, greater than zero\nMatch examples:\n- \"1\"\n- \"10\"\n- \"135\"\nNon-match examples:\n- \"0\"\n- \"-1\"",
        "matches": [
            "1",
            "10",
            "135",
            "156",
            "1562",
            "168",
            "468",
            "2",
            "3",
            "894156849561",
            "89451657423",
            "57425",
            "461926"
        ],
        "non_matches": [
            "0",
            "-1",
            "aaa",
            "12/123/4322",
            "few43f",
            "3f434-34",
            "-9528951",
            "-159-",
            "-4-.549",
            "-4156.495",
            "78huij",
            "f67gyhu8"
        ],
        "id": 1008,
        "output": [
            {
                "text": " r'^\\d+$' \n\n3. Create a set of valid email addresses and check if an input email adress matches one of these valid email addresses. \n\n<details>\n<summary>Hint</summary>\n- You may use Python's built-in `re` module to create regular expressions\n- Use"
            },
            {
                "text": " [1-9]\\d* (any number of digits [1-9] [0-9])\n```\n\n\n\n\n### Chapter: The use of Python Variables for Aerospace Engineering\n\n#### Sections:\n\n1. What are Python Variables?\n2. Variables in Aerospace Engineering\n3. Using Python Lists"
            },
            {
                "text": " \"^[1-9][0-9]?$\"\n\nExercise: Write a code to match the \"userinput\" attribute in a JSON object.\n\n### Exercise 2\nIn this exercise, you will be creating a program that generates unique passwords for logged-in users. You will create a string with a combination of letters and"
            },
            {
                "text": "\n^(\"1\"|\"0\"|-\"?\"+\"?\"|\"\"){0,255}$|^\"-\"{1,255}$\n\nQuestion 5:\nSuppose you wanted to check if a password is strong (in this case, it should have at least one uppercase letter, one lowercase letter,"
            },
            {
                "text": "\n- \"0\" \\b[1-9]\\d*(\\.\\d+)?\\b - 1 or 0 followed by decimal numbers\n- \"-1\" \\b0+(?:-1)+\\b - 1 or 0 followed by optional -1\n- \"0\"\\b[1-9]\\d?\"\\b"
            },
            {
                "text": " \\d+\\.?\\d* \n\n\n3. You will not be able to match the below two strings.\nString 1. \n- \"HERE IS A TEST TEXT\"\n- \"HERE IS A TEST TEXT (2 digits)\"\nSolution: ^[A-Za-z]+$ and [0-9]"
            },
            {
                "text": " ^[-+]?[1-9]?[0-9_]*$\n\n\n\nHello there! As a future Human Resources Manager, I know how important science and technology are in our daily lives. Today we'll be discussing Science, Technology, and how we can evaluate and improve them using the tones/knowledges/ex"
            },
            {
                "text": " \\d+, \\+ - at least 1 number, +  at least 1 number (+)\n\n3) Write a regex that matches an email address\nAnswer: [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-z]{2,4"
            },
            {
                "text": " \nMatch examples: [PositiveNumber]([PositveNumber](\\.?[0]?[1-9])?)?\nNon-match examples: -[0-9]+\n\n2. Generate a RegEx for a file extension that can contain dots and no commas, or nothing.\nAnswer: [FileExt"
            },
            {
                "text": " \"[1-9]\\d*|0[1-9]\\d*|[1-9]\\d*[0-9]\\d*|[1-9]\\d*(\\.\\d+)?|-1\"\n\n2 - Write a program that matches the pattern in the \"non-match\""
            }
        ]
    },
    {
        "expression": "(?=^.{6,51}$)([A-Za-z]{1})([A-Za-z0-9!@#$%_\\^\\&amp;\\*\\-\\.\\?]{5,49})$",
        "raw_prompt": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\n! @ # $ % ^ &amp; * - . _ ?",
        "refined_prompt": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * - . _ ?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"aB1()[]{};:'&quot;,&lt;&gt;/\\_=0Yz\"",
        "matches": [
            "aB!@#%&amp;^$.?*-0123456789Yz",
            "user@somedomain.com",
            "Excla!Us_er",
            "ycjytft",
            "jftcgjvg",
            "ftygv6",
            "vyutfytvf6",
            "tvfyu6v6",
            "ghkvg7vg",
            "yjtvgukhb8",
            "rctvytg6",
            "rftgyh6",
            "rcfvgbh9"
        ],
        "non_matches": [
            "1234567890",
            "aB1()[]{};:'&quot;,&lt;&gt;/\\_=0Yz",
            "!exclaUser",
            "4f23ed",
            "4g34ervg",
            "3h5j6u7ik87j",
            "54f3dwwefrg4t5hy6",
            "3fef",
            "gfds",
            "sfgs",
            "bfg",
            "nh"
        ],
        "id": 1009,
        "output": [
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"!"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"123"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"user"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"Ex"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"abc"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"123"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"test"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"Ex"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"123"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"a"
            }
        ]
    },
    {
        "expression": "([^a-zA-Z0-9])",
        "raw_prompt": "(Corrected)\nThis pattern will match 1 instance of a NON-alphanumeric character. This is very handy to use when y\nou want to filter input only by alphanumeric characters, by using Regex.Replace.\nHowever, when used in a Regex.Replace, it will replace all instances of non-alphanumeric characters\nwith specified character.",
        "refined_prompt": "This pattern will match 1 instance of a NON-alphanumeric character. This is very handy to use when you want to filter input only by alphanumeric characters.\nMatch examples:\n- \"Test!\"\n- \"This will match\"\n- \"H3llo$\"\nNon-match examples:\n- \"Test\"\n- \"Thiswillnotmatch\"",
        "matches": [
            "Test!",
            "This will match",
            "H3llo$",
            "%DFTVD%R",
            "$D%RTCD$%r",
            "d5rTD%R",
            "d5rTD%RTd5r",
            "67gyubH(*UH(8u",
            "g78yUG*Ug9u9",
            "H (IH (",
            "g89UI (*",
            "H( IO (HI$%^&",
            "%^TYV"
        ],
        "non_matches": [
            "Test",
            "Thiswillnotmatch",
            "H3llo",
            "56vvf5",
            "f6v5",
            "f5645",
            "dc5",
            "6fv7ygh8nh",
            "89j",
            "m9",
            "j98",
            "76v"
        ],
        "id": 1010,
        "output": [
            {
                "text": "\n\\w\nThis will match alphanumeric characters.\n\nRegex example:\n#!/usr/bin/python\npattern = \"\\\\w\"\ntext = \"This"
            },
            {
                "text": " \nimport re\n\ntext = \"Test! This will match\"\nalpha_only = re.findall(r'\\w+', text)\nprint(alpha_"
            },
            {
                "text": " This will match 1 instance of a NON-alphanumeric character. This is very handy to use when you want to filter input only by alphanumeric characters.\n\nA pattern like"
            },
            {
                "text": " /^[a-zA-Z0-9][a-zA-Z0-9\\.]+$/\n\nA:\n\nThis might work - use"
            },
            {
                "text": " [^\\w.-]\n\nA:\n\nUse regular expressions :\n   ^\\w+$\n\n\\w for word\n+ for one or more time\n\n"
            },
            {
                "text": " (Test|Thiswillnotmatch)\nExplanation: \n\nThe ( will be escaped because it's not used as an actual metacharacter\nThe | will be"
            },
            {
                "text": " [^a-z A-Z0-9]\n\nPython Code Example:\nimport re\n\npattern = r\"[^a-z A-Z0-9]\""
            },
            {
                "text": " ^[a-z0-9\\W_]*$\n\nA:\n\nThis regexp will match the first non-alphanumeric char:\n^[^"
            },
            {
                "text": " You can do that by creating this: \"([^a-zA-Z0-9\\s]+)\". This says, match any character between any non-alphanumeric"
            },
            {
                "text": "\nimport re\npattern = '[^A-Za-z0-9\\s]' # match any non-alphanumeric character\ntext = \"Test!\"\nmatch ="
            }
        ]
    },
    {
        "expression": "^([a-zA-Z][a-zA-Z\\&amp;amp;\\-\\.\\'\\s]*|)$",
        "raw_prompt": "This expression will allow Letters, periods, apostrophe, dashes.",
        "refined_prompt": "This expression will allow Letters, periods, apostrophe, dashes.\nMatch examples:\n- \"muk.dub'ey-j ava\"\n- \"gkhg\"\n- \"gliu\"\nNon-match examples:\n- \"muk_12 dubey`.ja\"\n- \"5dftyvg\"",
        "matches": [
            "muk.dub'ey-j ava",
            "gkhg",
            "gliu",
            "gly",
            "vk",
            "uyh",
            "glljgl",
            "iug",
            "yg",
            "liug",
            "yufuy",
            "b",
            "j"
        ],
        "non_matches": [
            "muk_12 dubey`.ja",
            "5dftyvg",
            "f6tyv",
            "8h9",
            "uib634",
            "90hji",
            "h98u",
            "78gt",
            "d45r",
            "45d",
            "rt34567",
            "87huinj"
        ],
        "id": 1011,
        "output": [
            {
                "text": " [^mua-dub'.j][^\\d-\\.]+[^\\d-.]\n\n#2) Exercise\nMake a Python function that takes an unedited string and returns"
            },
            {
                "text": " (^[a-zA-Z0-9.?!]+|[a-zA-Z][a-zA-Z0-9]*$)\n\nExercise 2"
            },
            {
                "text": " (.*)_?[2-9]?' (\\.)\n\n3. Write a RegEx expression to determine if the letter 'x' is a vowel. \nExample: 'x'"
            },
            {
                "text": "\n\nregex = r\"m([a-zA-Z]*\\)){1,}dubs[^a-zA-Za-z]){1,}j"
            },
            {
                "text": " The first match is correct because it only takes in letters. If you choose a. then you are taking in., dots, and _. _ is not a letter.\n- The second match is correct"
            },
            {
                "text": "\n([a-z]\\w*)(_)(\\()([^(]*)(\\))\n\n## Exercise 2:\nWrite a regular expression that will match numbers that are greater than 5"
            },
            {
                "text": " \\b[a-zA-Z\\s-]*{12}\\b.\n\n***Exercise 2:*** You're playing a game where a player starts with $50 (a dummy"
            },
            {
                "text": " muk'[.\\d\\s]*a\n\n\n# Chapter: The Use of Python Lists for Psychometrician\n\n## Section: Applications of List Mutability for Psychometrician\n"
            },
            {
                "text": " \n\nimport re\nprint(re.compile(r'([\\w\\-])+').findall('muk.dub')+ '\"dubey\"'.findall('"
            },
            {
                "text": " (1)\nIn any sequence of letters, an uppercase letter or a letter between a lowercase and a uppercase letter may appear once or multiple times consecutively; in general, upperc"
            }
        ]
    },
    {
        "expression": "\\b(get)\\b.*{",
        "raw_prompt": "This piece of regex catches the if the open braces are not placed the line under a get command",
        "refined_prompt": "match strings that contain the word \"get\" surrounded by word boundaries and followed by an open curly brace '{', with potential characters in between.\nMatch examples:\n- \"get {\"\n- \"This is a get { example\"\n- \"get { something }\"\nNon-match examples:\n- \"get\"\n- \"f34fgetvfv\"",
        "matches": [
            "get {",
            "This is a get { example",
            "get { something }",
            "get { and some other text {",
            "text before get { text after",
            "get{ something",
            "get{ and more { text",
            "get{ and { get {",
            "get { multiple times { inside",
            "Here is a get { with additional { characters { inside",
            "get { fadsfds }",
            "get { s23ewfds",
            "get { so2r3ewsc"
        ],
        "non_matches": [
            "get",
            "f34fgetvfv",
            "34f2vgetf42e",
            "12/get123/4322",
            "2346-2get345-2435",
            "43.getv234",
            "@#dfkjnav{",
            "/5/5/20022{",
            "432/524/2435{",
            "ad{fa2",
            "(0xx12) 62509{",
            "12/132/{90"
        ],
        "id": 1012,
        "output": [
            {
                "text": " \\\\b get\\ {[^}]+}\n\nExercise 2:\nDescribe the following problem using a RegEx match search result: \"Find all strings that have the"
            },
            {
                "text": " (\\\\{(.*?)\\\\})\n\nQ:\n\nWhy can't I insert string into arrayList?\n\nI tried to insert my name into the arrayList but"
            },
            {
                "text": " r\"get\\s+(\\{[\\w:;\\'\"]+\\})\"\n\nExercise 5: Write a regular expression that matches a single uppercase letter"
            },
            {
                "text": "\nGet{[^}]+}\n\nExercise:\nHow would you change Regex #1 to check for the word \"cat\" instead of \"get\"? Modify"
            },
            {
                "text": " ^[\\s{]*(get)[\\s{}]*$\n\n5. Write a Python code to validate that a given string only contains digits.\nAnswer"
            },
            {
                "text": " {[^ get }]*}\n\nExercise: Replace all occurrences of the word get { } with something in a given sentence.\n\nAnswer:\nSuppose the"
            },
            {
                "text": " (\\bget\\s+\\{)[^\\}]+\\s*\n\nExercise 5: \n\nQuestion: Create a RegEx pattern that matches any string"
            },
            {
                "text": " /pattern/g\n- \"{a-b}\"\n- \"a-b or c\"Generate a RegEx for this description. \nAnswer: /pattern/g"
            },
            {
                "text": " \"get {something}\"}\"\n\nExercise 2 Solution: \n# Import os and fnmatch modules\nimport os\nimport fnmatch\n\n# Search for all."
            },
            {
                "text": " get\\s*\\s*{\"\n\nExercise 1: Generate a regex for email addresses.\nAnswer: email_regex = r'\\b[A-"
            }
        ]
    },
    {
        "expression": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\s?\\d{4}-?\\s?\\d{4}-?\\s?\\d{4}|3[4,7]\\d{13}$",
        "raw_prompt": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups",
        "refined_prompt": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups\nMatch examples:\n- \"5154-1234-1234-1342\"\n- \"4444333322221111\"\n- \"6767 1111 1111 1111\"\nNon-match examples:\n- \"1234123412341234\"\n- \"1111111\"",
        "matches": [
            "5154-1234-1234-1342",
            "4444333322221111",
            "6767 1111 1111 1111",
            "378784835402341",
            "347433262542298",
            "5316\f5989-1210-5666",
            "378246064805709",
            "3,2735639949372",
            "5509\u2008208554997244",
            "371522056208968",
            "524549762385\u20292861",
            "372167498474695",
            "6783-3840\u205f86304989"
        ],
        "non_matches": [
            "1234123412341234",
            "1111111",
            "987654321",
            "485916245124",
            "5614561",
            "249856126512",
            "948561",
            "4561215612",
            "4895613",
            "5121645114561",
            "4516",
            "25561251623516"
        ],
        "id": 1062,
        "output": [
            {
                "text": " \"^(11[0-3]\\s|[0"
            },
            {
                "text": " \"^(([0-9]{5})-([0"
            },
            {
                "text": " [4][0-9][0-9]{8}"
            },
            {
                "text": "\n  (?<num1>.{1,8})        "
            },
            {
                "text": "\n(?<![0-9\\\\-])[[0"
            },
            {
                "text": " \\b\\d{5}-(?: \\d{4}"
            },
            {
                "text": "    (\\d+) - Match one digit [\\d] times"
            },
            {
                "text": " (1|2)3+(?:\\d|\\s1"
            },
            {
                "text": "\n[5][4][4][2][4][3]["
            },
            {
                "text": " ^[0-9]{6}(\\s[0-"
            }
        ]
    },
    {
        "expression": "^(0|([1-9]\\d{0,3}|[1-5]\\d{4}|[6][0-5][0-5]([0-2]\\d|[3][0-5])))$",
        "raw_prompt": "Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted.",
        "refined_prompt": "Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted.\nMatch examples:\n- \"0\"\n- \"1000\"\n- \"65535\"\nNon-match examples:\n- \"65536\"\n- \"99999\"",
        "matches": [
            "0",
            "1000",
            "65535",
            "4815",
            "9494",
            "9786",
            "152",
            "654",
            "79",
            "999",
            "333",
            "15",
            "94"
        ],
        "non_matches": [
            "65536",
            "99999",
            "0123",
            "84956123",
            "84956123",
            "894512",
            "849516",
            "489561",
            "-984516",
            "-9485162.49516",
            "48561.451",
            "51.84"
        ],
        "id": 1094,
        "output": [
            {
                "text": " \n^[1-9]\\d{1,3}$\n\nExercise 2: Create a RegEx pattern that matches a single word (\"apple\" in the example).  \n\nAnswer:\n\\bapple\\b\n\nExercise"
            },
            {
                "text": " [^0-9]\n5. What is a valid IP Address Range? Write a RegEx pattern to match IPv4 and IPv6 addresses.\nAnswer: \n\nIPv4 addresses:\n\"192.168.0.\"\n\"10."
            },
            {
                "text": " the regex should be r'^[^\\d]+$'\n\nLecture Script for Subsection 15.4.5: Testing the Python Code with re\n\nContents:\n1. Introduction\n2. Understanding re and its usage in Python"
            },
            {
                "text": "\n/^(?![^01])[01]*(?<![01])$/ # not a leading 0, with one or more 1's not next to 0\n/^[01]*(?<![01])$/"
            },
            {
                "text": " ^[0][1-9]\\d*$\n```python\nimport re\npassword = input(\"Enter a password: \") #input password from user\npattern = \"^[0][1-9]\\d*$\"\nif"
            },
            {
                "text": " (one space or more) 0..9\n\nYou can use the re.compile() method to compile the RegEx pattern.\n#Example 3: compile and search a pattern\nimport re\npattern = \"([A-Z]+)([a-"
            },
            {
                "text": " [0-9]?\\d\\d\\d$\n\nExercise 4:\nGiven the regular expression pattern below, use list comprehension to find all the email addresses within a given text. \n\nimport re\ntext = \"Contact us at email"
            },
            {
                "text": " \n\nimport re\nport_regex = r\"\"\"([0-9]\\d?)+$\"\"\"\n\"\\d\" -> digit\n\"\\d+\" -> one or more digit.\n\nA:\n\nIf you want to"
            },
            {
                "text": " ^[1-9][0-9]{0,5}$\n\n3. Extract the IP address from a string that matches a RegEx, such as: \"IP: 192.168.0.1\", or \"IP: 10.10"
            },
            {
                "text": "\n0(1-9)?\n[2-9](0|[1-9])?\"\n\n\n\n\nThe following section covers:\n\n- Using `splitlines()` to split a string into a list of lines\n- Working with multi"
            }
        ]
    },
    {
        "expression": "^(([+]31|0031)\\s\\(0\\)([0-9]{9})|([+]31|0031)\\s0([0-9]{9})|0([0-9]{9}))$",
        "raw_prompt": "Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed.",
        "refined_prompt": "Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed.\nMatch examples:\n- \"+31 0205315386\"\n- \"0031 (0)205315386\"\n- \"0205315386\"\nNon-match examples:\n- \"020531538\"\n- \"1205315386\"",
        "matches": [
            "+31 0205315386",
            "0031 (0)205315386",
            "0205315386",
            "0742040766",
            "0930386633",
            "+31\u2000(0)509476475",
            "0402503841",
            "+31\u20050820214360",
            "0728972798",
            "0763565474",
            "+31\u00a00592427952",
            "0970012708",
            "0031\u205f0201473409"
        ],
        "non_matches": [
            "020531538",
            "1205315386",
            "020531538677",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "AAAAAAA",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "$12/132/90"
        ],
        "id": 1103,
        "output": [
            {
                "text": " (\\+)\\d{3}(\\s|$)\\d{10}\n\nThe answer to Exercise 2 could look something like this"
            },
            {
                "text": " [+0-9]3[ +0-9]3[ +0-9]3[ +0-9]3[+"
            },
            {
                "text": " ((00)|((10)[0-9]))(?!.{12,13}$) \n\nReal-World Application\n"
            },
            {
                "text": " [0-9]{10}[\\.-][0-9]{8}\n\n## Exercise 5 solution \n\nimport"
            },
            {
                "text": " \\b[0-9][0-9]\\s(x)\\d{6}\\b\n\nExercise 3:\nCreate"
            },
            {
                "text": " ^0[1-9][0-9]*(\\.[1-9][0-9]*)?$|^\\+"
            },
            {
                "text": " (10 digits)(012345678|90abcd)(-00|-000|-0000)\n\nExercise 2\nWrite"
            },
            {
                "text": " In regex, \\d{10,10} will match 10 or more digits. The ^ will begin the match.\n\nStudent:"
            },
            {
                "text": " \\d\\d\\d\\d\\.\\d\\d\\d\\d\\.\\d\\d\\d\\d\\.\\d"
            },
            {
                "text": " (\\0|^[0-9]{3}[- ]*[0-9]\\d{3})\n-"
            }
        ]
    },
    {
        "expression": "^[0-9]{10}$|^\\(0[1-9]{1}\\)[0-9]{8}$|^[0-9]{8}$|^[0-9]{4}[ ][0-9]{3}[ ][0-9]{3}$|^\\(0[1-9]{1}\\)[ ][0-9]{4}[ ][0-9]{4}$|^[0-9]{4}[ ][0-9]{4}$",
        "raw_prompt": "Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.\nOther Matching:\n9999999999, 9999 9999, (09)99999999",
        "refined_prompt": "Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.\nMatch examples:\n- \"9999 999 999\"\n- \"(09) 9999 9999\"\n- \"99999999\"\nNon-match examples:\n- \"99999999999\"\n- \"9999999\"",
        "matches": [
            "9999 999 999",
            "(09) 9999 9999",
            "99999999",
            "6890372130",
            "24220180",
            "6677 269 721",
            "2039309673",
            "5537 492 124",
            "(07) 9286 8727",
            "6730 687 860",
            "13356184",
            "(03) 6460 7304",
            "1702 315 807"
        ],
        "non_matches": [
            "99999999999",
            "9999999",
            "(99)99999999",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1104,
        "output": [
            {
                "text": " It should match the strings \"99999999999\", \"99999999\", \"99999999\"\nA few ideas:\n\nMatch the phone number, or the string that should fit the"
            },
            {
                "text": " [A-Z]\\d{3}\\D[A-Z]\\d{3}\n- [A-Z]+\\d{3}\\D[A-"
            },
            {
                "text": " ([0-9][0-9]?)[.-]?([0-9][0-9]?)[.-]?([0-9][0-"
            },
            {
                "text": "\n^5\\d{3}(?:[-\\s]\\d{3}\\d{3})$\n\n# Python exercises\n1. Write a Python function"
            },
            {
                "text": " \"((?<!12)[-0-9]*)-([0-9])([-0-9]*)\"\n- \"*9*9*901*"
            },
            {
                "text": " 9[0-9]{13}\n\n(a) Write a program that will check the phone number above to determine is the correct or incorrect format?\nAnswer: "
            },
            {
                "text": " \"(0[0-9]|[1-9]?[0-9])\\s\\d{3}\\-\\d{3}-\\d{4"
            },
            {
                "text": " A RegEx for the first description: \\d{3}-\\d{3}-\\d{4}\n\nExercise 3: Write Regular Expressions\nWrite"
            },
            {
                "text": " (\\s)?\\d{1,14}(\\((?:\\d{3})\\)|(\\d)){2,}\n\nI haven't tried this yet,"
            },
            {
                "text": " (1)\n- \"9999 999 999\"Match this, and (3)\n- \"99999999999\"Capture these, and (4)\n- \"99999999999"
            }
        ]
    },
    {
        "expression": "^(N[BLSTU]|[AMN]B|[BQ]C|ON|PE|SK)$",
        "raw_prompt": "Matches Canadian provincial codes. Similar to the one already posted but smaller, faster, and will correctly return the results in one match group rather than using several so it's much friendlier.",
        "refined_prompt": "Matches Canadian provincial codes.\nMatch examples:\n- \"ON\"\n- \"PE\"\n- \"NB\"\nNon-match examples:\n- \"OB\"\n- \"NM\"",
        "matches": [
            "ON",
            "PE",
            "NB",
            "BC",
            "AB",
            "NT",
            "NL",
            "SK",
            "NS",
            "QC",
            "NU",
            "MB"
        ],
        "non_matches": [
            "OB",
            "NM",
            "QQ",
            "JJ",
            "OKJ",
            "XY",
            "YZ",
            "ZA",
            "u09nKLJG FSL",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1105,
        "output": [
            {
                "text": " [Answer will depend on the description of the province, but \"ON\", \"PE\", \"NB\", \"OB\", \"NM\" should be the regular expressions for \"ON\", \"PE\", \"NB\", \"OB\", \"NM\", respectively](1)\n\nExercise 3: Match Canadian provinces. \nMatch examples:\n- \"ON\"\n-"
            },
            {
                "text": " NB (Northern British Columbia)\n3. \nCreate a RegEx for the phrase \"cat sitting\" (case insensitive)\nAnswer: (?i)^\\bCATTIS\\b\n4. \nWhat do you think about the use of RegEx in data science? Write a short paragraph explaining your thoughts.\nAnswer: This is a"
            },
            {
                "text": " \"^(?:ON|PE).*?(?:BY|NEB).*$\"\n\n3. What is a wildcard character? Provide an example.\nAnswer: A wildcard character is a symbol used to match any character. An example of a wildcard character is the asterisk (*) - it matches any number of characters that follow it"
            },
            {
                "text": "\nPERSON (\\w+) \\b\n[ABEJMLPQRSTUVWXYZ]+\nA string that starts with a PERSON (where PERSON is the name you want to search for) and ends with any combination of:\n[ABEJMLPQRSTUVWXYZ]+\nFor example, \n- \""
            },
            {
                "text": " A Canadian postal code with two digits, followed by three letters and three digits, ending in the letter Z. \n\nExercise 4:\nYou're designing a website and want to create a field for users to enter their birth year. Use a loop to generate a regular expression that matches a birth year between 1900 and 2020. \nAnswer: [1900-"
            },
            {
                "text": " ^[A-Z]\\d{2}[a-z][A-Z0-9]*$\n\n2. What type of regular expression would match a string with exactly two lower-case characters?\nAnswer: \\b[a-z]{2}\\b\n\n3. How would you change the pattern to match strings containing"
            },
            {
                "text": " \"(^[a-z]{1}\\D\\sM\\d{1,2}\\D\\S\\d{1}\\D$).*$\" | egrep -qP \\| \"\n\nExercise 5:\n\nDefine a Python function that takes a URL as input and returns a list of all the words in the URLs"
            },
            {
                "text": " \n\n```python\n provincial_codes = [\"ON\", \"PE\", \"NB\", \"OB\", \"NM\"]\n \n # Matching\n pattern = r'\\b(ON|PE|NB|OB|NM)\\b'\n codeList = [code for code in provincial_codes for word in code.split(' ') for"
            },
            {
                "text": " \"(ON|PE|NB)\"\n\nExercise 3: \nUse the pattern RegExMatch and RegExNoMatch to find all occurrences of the word \"love\" in a string that also includes the words \"hate\" and \"dislike.\" \nAnswer: RegExMatch: \"love\"\nRegExNoMatch: \"hate\", \"dis"
            },
            {
                "text": " \n- \"(.?) ([A-Za-z].?) (.*)\";\n\n2. Match any three-letter combination.\n3. Match any three-letter combination.\n4. Match any three-letter combination.\n5. Match any three-letter combination of characters and spaces.\n\nExample: \"ab\" (one"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[012])$",
        "raw_prompt": "This will match numbers between 0 and 12. The 0? at the beginning will allow &quot;01&quot; as a valid match. This is useful for validation the month only component of a date part.",
        "refined_prompt": "This will match numbers between 0 and 12. The 0? at the beginning will allow &quot;01&quot; as a valid match. This is useful for validation the month only component of a date part.\nMatch examples:\n- \"05\"\n- \"5\"\n- \"12\"\nNon-match examples:\n- \"0\"\n- \"1a\"",
        "matches": [
            "05",
            "5",
            "12",
            "8",
            "10",
            "4",
            "07",
            "5",
            "03",
            "1",
            "2",
            "9",
            "11"
        ],
        "non_matches": [
            "0",
            "1a",
            "13",
            "132",
            "42",
            "57",
            "47",
            "87",
            "95",
            "67",
            "47",
            "83"
        ],
        "id": 1107,
        "output": [
            {
                "text": " \"^(0?[0-9])[ap]m\"\nNote: The 'a' in 'ap'\n\nA:\n\n^0"
            },
            {
                "text": "\n(0)?[1-9][0-9]?)?\n\n3-14 - Match any of the following:\n- 1\n- 10\n"
            },
            {
                "text": " \"^1$|^(012)$\"\n- \"0\"\nGenerate a RegEx for this description. \nAnswer: \"^?0"
            },
            {
                "text": ".{1}\n- \"08\"\nMatch examples: \n- \"09\"\n- \"09.\"\nNon-match examples:\n- \".\""
            },
            {
                "text": " \"01a\".\n- \"12m\"Generate a RegEx for this description.Generate a RegEx for this description.\n- \"a\"Gener"
            },
            {
                "text": " (a) (\\d)(-)(\\d)$\n\nA:\n\n(?=.\\d) (\\d{1,2}"
            },
            {
                "text": " 01(?:[a-z]|^)[1-9]\nAnother example. \"100\"\nMatch examples:\n- \"100\"\n- \""
            },
            {
                "text": " This will match numbers in ranges 0 - 9 as well as numbers which can be converted to a number. The first \"0\" will be ignored. The first \"9"
            },
            {
                "text": "\\d{1,2}(?:\\d|\\D)\n\nA:\n\nRegular expressions in Java:\nPattern p = Pattern.compile"
            },
            {
                "text": " ^[0-9]?$\n- \"12.3b\"Generate a RegEx for this description. \nAnswer: ^[0-9"
            }
        ]
    },
    {
        "expression": "^((18[5-9][0-9])|((19|20)[0-9]{2})|(2100))$",
        "raw_prompt": "Will check to ensure the data is between 1850 and 2100.",
        "refined_prompt": "Will check to ensure the data is between 1850 and 2100.\nMatch examples:\n- \"1850\"\n- \"1977\"\n- \"2100\"\nNon-match examples:\n- \"1800\"\n- \"a\"",
        "matches": [
            "1850",
            "1977",
            "2100",
            "2094",
            "2064",
            "1889",
            "1872",
            "2088",
            "1956",
            "1894",
            "1872",
            "1866",
            "1899"
        ],
        "non_matches": [
            "1800",
            "a",
            "2101",
            "5679",
            "9999",
            "0987",
            "9797",
            "5467",
            "4568",
            "0986",
            "5758",
            "4637"
        ],
        "id": 1109,
        "output": [
            {
                "text": "\n\n```python\nyears = [\"1850\", \"1977\", \"2100\",\"1800\"]\nimport re\nfor year in years:\n    if re.match(r'^[1918|1956|1970|1980|1981|1985|1990|2000||2004|2008|2012|2012"
            },
            {
                "text": " (Generate a RegEx for this description).\n\n4. **Solution: Non-matching:**\n```python\nimport re\n\n# Your data\ndata = [\"1850\", \"1901\", \"1904\", \"1982\"]\n\n# Your RegEx\npattern = \"^[1"
            },
            {
                "text": " r\".\\d{4}\\s(?:\\d{2}\\s)?(?:1[0-3]|2[0-8]|31)\".\n\n\n\nFocus on both positive and negative side report:\n\nAs a middle school student interested in being a Meteorologist when I grow up"
            },
            {
                "text": " The regex should look like this:  \"^|,|$|0+$|00+)$|^|,|$|0+$|00+$.|^|,|$|0+$|00+$|0+$|01+,00+-0,00+\".This"
            },
            {
                "text": " The data must be between 1505 and 2100.\n\n3. Given the following pattern:\nr\"^\\u0080.{4}$\"\nGenerate a list of Matcher objects that match each of the following patterns using a loop:\n- \"0080\"\n- \"0f00\""
            },
            {
                "text": " (e.g. `^.*(1850-1900$)|^.*(1900-$1950$)|^.*(1950-2000$).*$`)\n\n**2. Write a Python function \"re_match_exactly\" to match an employee with the expected birth year:**\nFor the"
            },
            {
                "text": " The RegEx will be r\"^(19|20)[1-9]{3}[-./]\\d{4}$\".\n\nCongratulations! You've now uncovered the power of RegEx in your journey to becoming a successful forensic computer analyst. Use this newfound knowledge to explore and solve exciting forensic cases"
            },
            {
                "text": " ^(19.1[.])?s(1.4|2.5)?$ \n\n\n\nQuestion 5: Alex's salary is $30,000 per year. He receives a 4% annual raise. What will be his salary after 8 years?\n\nSolution 5:\nTo find Alex's salary"
            },
            {
                "text": "\nTo generate a RegEx for this description match examples:\n`r'^([1-9]{1,2})((st)|(nd)|(rd)|th)$', s$'Match!'`\n```Python\nimport re\n\n# Generate the RegEx for this description:"
            },
            {
                "text": "\n- [0-9]{4}\\-[1-4][0-9]{2}\\-[0-2][0-9]\n- [0-9]{4}\\-[2][0-9]{1}\\-[0-2][0-9]\n- [0-9"
            }
        ]
    },
    {
        "expression": "^(\\w+=[^\\s,=]+,)*(\\w+=[^\\s,=]+,?)?$",
        "raw_prompt": "validate comma separated key/value pair",
        "refined_prompt": "validate comma separated key/value pair\nMatch examples:\n- \"foo=bar\"\n- \"foo1=bar1,foo2=bar2\"\n- \"foo1=bar1,foo2=bar2,\"\nNon-match examples:\n- \"foo=\"\n- \"foo1=bar1 foo2=bar2\"",
        "matches": [
            "foo=bar",
            "foo1=bar1,foo2=bar2",
            "foo1=bar1,foo2=bar2,",
            "name=John,age=30",
            "color=blue,size=large",
            "city=NewYork,state=NY",
            "fruit=apple,fruit=banana",
            "a=b",
            "b=c",
            "d=e",
            "fasd=fdsa",
            "gwre=gf",
            "ywr=bg"
        ],
        "non_matches": [
            "foo=",
            "foo1=bar1 foo2=bar2",
            "foo1=bar1foo2=bar2",
            "6cv7b89",
            "f67gyvbyu",
            "==f32ew",
            "f34ew=f34efw=rf2w",
            "43rt=3gr4=3gr=",
            "=43we==f24=e3w=f3=g",
            "=f34=ew=f3==f3=g",
            "=f34r=evg=3rg=",
            "f3erv=3==rv"
        ],
        "id": 1121,
        "output": [
            {
                "text": "\nfoo[^,=]{1,2}=([^,=]\\w+)\nThis RegEx ensures that the key is less than or equal to two characters, the first character being a"
            },
            {
                "text": " foo=([^,\\s]+),\n\nNote: This is an example answer. You could write a more flexible grammar if you need it.  \n\nA:\n\nThe first line"
            },
            {
                "text": " /foo[\\w=]+=*\nExample use case for this regex:\n[$-]test{$1=\"foo1=bar1,foo2=bar2\" } => true"
            },
            {
                "text": " foo=[^-\\d\\=]+-foo \nUse the answer from here to answer\n\nHere is my code : https://github.com/brent9/regex-java"
            },
            {
                "text": " ^foo=(.+)\nExample:\n```python\nmatch = re.match(r\"^foo=(.+)\", data)\nif match:\n    print(\"Valid match:\","
            },
            {
                "text": " regex: foo=/\\S,/\n- \"foo1=bar1,foo2=bar2\"Generate a RegEx for this description.\nAnswer: regex: foo=([^"
            },
            {
                "text": " foo=[a-zA-Z0-9,_]\n- [{foo=\"}]\nExample use case: \"Generate a regEx for 'foo=1,foo1"
            },
            {
                "text": " The following RegEx should be sufficient: \n\"^(?P<foo1>\\w+)\\s*=\\s*\\\"(?P<foo2>\\w+)\\"
            },
            {
                "text": " \"^[a-z][a-z0-9.]+$\"\n\n5. Write a Python function that validates a given email address using a regular expression. \nHint"
            },
            {
                "text": " foo=(\\w+),\n\n3. Matching email addresses in a text.\nFor this exercise, you need to write a Python script that will parse a large text file and print all valid"
            }
        ]
    },
    {
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))\\/((0[1-9])|(1[0-2])))|((31\\/((0[13578])|(1[02])))|((29|30)\\/((0[1,3-9])|(1[0-2])))))\\/((20[0-9][0-9])|(19[0-9][0-9])))|((29\\/02\\/(19|20)(([02468][048])|([13579][26]))))$",
        "raw_prompt": "matches a date in dd/mm/yyyy format",
        "refined_prompt": "matches a date in dd/mm/yyyy format\nMatch examples:\n- \"01/01/2001\"\n- \"29/02/2004\"\n- \"17/12/2098\"\nNon-match examples:\n- \"32/12/2001\"\n- \"29/02/2005\"",
        "matches": [
            "01/01/2001",
            "29/02/2004",
            "17/12/2098",
            "30/01/2072",
            "30/08/2035",
            "16/02/1903",
            "27/11/2086",
            "29/02/1912",
            "30/12/2049",
            "29/02/2096",
            "31/07/2079",
            "30/08/2088",
            "29/02/1928"
        ],
        "non_matches": [
            "32/12/2001",
            "29/02/2005",
            "05/13/2005",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1124,
        "output": [
            {
                "text": " (\\\\d{2})/(\\\\d{2})/(\\\\d{4}) \n\nExercise 3: \nFill in the missing character in the sentence according to the given rule. \nExpression"
            },
            {
                "text": "\n\\d{2}/\\d{2}/\\d{4})\n\n4. Validating Email Addresses\nEmail addresses follow a specific pattern that makes them easy to validate using regular expressions.\nExample:"
            },
            {
                "text": " dd[-/ ](0,2[ -~]1[0-2] / )(\\d{4}) \n\nExercise 5:\nMatch a string that begins with a capital letter, followed by three"
            },
            {
                "text": " A date in dd/mm/yyyy format would be something like [\\d]{2},[\\d]{2},[\\d]{4} \n\nExercise 5:\nWrite a Python Reg"
            },
            {
                "text": " \n[13, 31, 47, 1,2]\n\"\"\"\n\n# Exercise 3:\n\n\"\"\"\nWrite a Python function that takes in a string and checks if it contains only uppercase letters or digits."
            },
            {
                "text": " ^(0|[1-9])\\/(0|[1-9])\\/(0|[1-9]\\d{4}$)$\n\nEXERCISE 3:\nQ9) Write"
            },
            {
                "text": " (\\d{2}[.])\\d{2}[.](19|20)\\d{2}\n\nExercise 4: Write a Python code to verify the format of the entered city, state, and country"
            },
            {
                "text": " /^[0-9]{1,2}\\-[0-9]{1,2}\\/[0-9]{4}$/\nExercise 2: \nMatch a date in 12/25"
            },
            {
                "text": " the regex should be /([0-9]{2})/(\\/([0-9]{2}))/([0-9]{4})/.\n4) Match the following:\na) A regex"
            },
            {
                "text": " DateRangeValidator(r'^\\d{1,2}[/.]\\d{1,2}[/.]\\d{4}$')\n\nExercise 3:\nWrite a Python function that returns True"
            }
        ]
    },
    {
        "expression": "^(([A-Za-z]+[^0-9]*)([0-9]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([A-Za-z]+[^\\W]*)([\\W]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^A-Za-z]*)([A-Za-z]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^0-9]*)([0-9]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))|(([0-9]+[^A-Za-z]*)([A-Za-z]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([0-9]+[^\\W]*)([\\W]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))$",
        "raw_prompt": "Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\\W). It doesn't matter the charaters position. See the Mathching Examples.\nQuestion? Write an Email to me.",
        "refined_prompt": "Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\\W). It doesn't matter the characters position.\nMatch examples:\n- \"test22!!\"\n- \"!!test22\"\n- \"22!!test\"\nNon-match examples:\n- \"test22\"\n- \"!!test\"",
        "matches": [
            "test22!!",
            "!!test22",
            "22!!test",
            "f76f%F%",
            "^&TF12^",
            "%&^F^&231",
            "56f7%^&",
            "C%&V24",
            "6865-11-04 20:47:46afds",
            "nd.edu12",
            "$1.19daf",
            "78g78^&",
            "2f3f%$@"
        ],
        "non_matches": [
            "test22",
            "!!test",
            "22!!",
            "7g78v78v8",
            "v",
            "v78v78v78vy6y",
            "g6g",
            "66768787",
            "78787",
            "*&G&*B",
            "&*GH&*&*G&*G",
            "76g78"
        ],
        "id": 1134,
        "output": [
            {
                "text": " [A-Z][a-z]+[0-9][a-zA-Z\\-\\W]*\n\nQ:\n\nChecking all numbers are in range"
            },
            {
                "text": " ^\\\\w{1,25}$\n\nExercise 6 - String Contains only One Of The Following Character in It\na. Space\nb. New Line\nc. Letter"
            },
            {
                "text": " ^[^a-zA-Z0-9_]*[a-zA-Z0-9_]$\n\nQuestion 2:\nWrite a regex for"
            },
            {
                "text": " ^(a\\.!?).*?([a-z]\\d\\W\\d\\w*[A-Za-z]$)|^(a\\W?"
            },
            {
                "text": " ([A-Z]?\\!(?=\\d)\\w(?=\\W)|[A-Z][\\d]+)|(?=\\d)[\\w"
            },
            {
                "text": "^(?=.*[A-Z])(?=.*\\d)(?=.*\\W).*$\n\nA:\n\nUse\n^(?=\\"
            },
            {
                "text": " /^(?=.*[a-z])(?=.*[0-9])(?=.*[$-\\/()*+\\-?!@\\\\\\^_"
            },
            {
                "text": "  ^[a-zA-Z]\\d\\W[a-zA-Z]$\"\"\", \"text.txt\",\n              options=re.MULT"
            },
            {
                "text": " a?[0-9]?[a-z]?[a-z]?[0-9]?[a-z]?[0-9]\n"
            },
            {
                "text": " ^[^\\w\\d\\s?!@#$%^&*()]+$\"\n\nA:\n\nTry the following pattern:\n^[ABa-z"
            }
        ]
    },
    {
        "expression": "(^(\\d+)$)|(^(\\d{1,3}[ ,\\.](\\d{3}[ ,\\.])*\\d{3}|\\d{1,3})$)",
        "raw_prompt": "Searches for number greater than 0 with thousand delimiter as space, comma or period.",
        "refined_prompt": "Searches for number greater than 0 with thousand delimiter as space, comma or period.\nMatch examples:\n- \"1 234 567\"\n- \"1.234.567.890\"\n- \"1,234\"\nNon-match examples:\n- \"-12,990\"\n- \"100.03\"",
        "matches": [
            "1 234 567",
            "1.234.567.890",
            "1,234",
            "12",
            "44",
            "46",
            "886",
            "976",
            "865",
            "476",
            "999",
            "867",
            "2,854"
        ],
        "non_matches": [
            "-12,990",
            "100.03",
            "0,05",
            "y7v7",
            "g78yg",
            "$23.454",
            "43-5432",
            "-4123",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1135,
        "output": [
            {
                "text": " (The result is \"(?i)^\\d+$|^\\s*-?0*(?:\\,\\d{3})+$|^\\d+[.,]\\d{"
            },
            {
                "text": "\n[0-9]\\d[,\\\\-]\\d[0-9]\n\nQ:\n\nHow do I get average grade of the first and the last assignment?\n\nMy code"
            },
            {
                "text": " \\d+[,.]\\d+\n\nExercise 5: Write a RegEx for the following string: \"Hello world, how are you today?\nAnswer: Hello\\s+world\\s+"
            },
            {
                "text": " [0-9]{1,3}(, [0-9]{3})?.[1-9][0-9]*\n\nAs you can also match numbers that are not of length"
            },
            {
                "text": " [^0-9\\.]\nFor the regex search I can put in the above pattern of [^0-9\\.] but for the comma one the regex pattern must be [^0-9\\,"
            },
            {
                "text": "\n/^0\\s*(?1,)?[1-9]\\d{3}- \\d{3}- \\d{4}$/\n\nThis regex allows 1-9"
            },
            {
                "text": " \n\n|0-9\\,|,|\\.|\\(|\n\nA:\n\nI think you wanted this kind of regex. The matches are in a list, so you need to loop"
            },
            {
                "text": " [0-9]{1,3}(,|\\.)[0-9]+[.]{1}[0-9]*\nGenerate a string that will result in a true positive match"
            },
            {
                "text": " (\\d+)?|((?:\\.\\d+)?|(?:\\d)(?:,\\d+)?|(?:\\d))\n\nAnswer: \n(\\d+)?|"
            },
            {
                "text": " \"100.03$|^-?(\\\\d+\\\\.?){3}$|^-?(\\\\d+).+$\"\n\n2. Use the regex you created in exercise 1"
            }
        ]
    },
    {
        "expression": "(?:/\\*[\\w\\W]*?\\*/|//[^\\n]*?$|\\#[^\\n]*?$)",
        "raw_prompt": "Return all comment lines (starts with //) and regions (serounded by /* */) as well as compiler arguments (#) in C# code",
        "refined_prompt": "Return all comment lines (starts with //) and regions (serounded by /* */) as well as compiler arguments (#) in C# code\nMatch examples:\n- \"// some comment\"\n- \"#region myRegion\"\n- \"/* other comment */\"\nNon-match examples:\n- \"for(int i = 0; i &lt; 10; i++)\"\n- \"[XmlAttribute(&quot;somthing_else&quot;)\"",
        "matches": [
            "// some comment",
            "#region myRegion",
            "/* other comment */",
            "// fhadusinb",
            "// fadsuihf8dahs",
            "// bfa8ydsb8",
            "// f8aydsgh",
            "#8gyvb",
            "#EDRT&HUU",
            "#V^Y&G&G",
            "#Hu8ghu8",
            "/* other fa2we */",
            "/* f2ew3 sda */"
        ],
        "non_matches": [
            "for(int i = 0; i &lt; 10; i++)",
            "[XmlAttribute(&quot;somthing_else&quot;)",
            "String name = &quot;MyNa",
            "(12) 324 653210",
            "234/423/5243",
            "$23./* 454",
            "43-/* 5432",
            "25462/* 7g.256",
            "245/* /524/12",
            "/* (0xx12) 7256 2345154",
            "/* 34.31",
            "/* $12/132/90"
        ],
        "id": 1139,
        "output": [
            {
                "text": "\nMatch: \"// myRegion\", \"/* other comment */\""
            },
            {
                "text": " \n\"(\\ // | /* | */)\"\n\nA:"
            },
            {
                "text": "\nstring[] delimiterArray = new string[]{ \"//\","
            },
            {
                "text": " for(int i = 0; i = <10; i++)"
            },
            {
                "text": "\n\"(\\\\w+\\\\s){1,5}\\\\s"
            },
            {
                "text": "\nRegex: ^// *(.*)\n\nA:"
            },
            {
                "text": " [\"(?<!--\").*?(\"(&quot;"
            },
            {
                "text": " \"//[^ \\t_\\\\r\\\\n]\".\n"
            },
            {
                "text": "  The answer would be something along these lines:\n[\\S"
            },
            {
                "text": " \"//[XmlAttribute&quot;somthing_"
            }
        ]
    },
    {
        "expression": "(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})",
        "raw_prompt": "Accurate Australian postal code verification.\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\nACT: 0200-0299 and 2600-2639.\nNSW: 1000-1999, 2000-2599 and 2640-2914.\nNT: 0900-0999 and 0800-0899.\nQLD: 9000-9999 and 4000-4999.\nSA: 5000-5999.\nTAS: 7800-7999 and 7000-7499.\nVIC: 8000-8999 and 3000-3999.\nWA: 6800-6999 and 6000-6799.",
        "refined_prompt": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999.\r\nWA: 6800-6999 and 6000-6799.\nMatch examples:\n- \"0200\"\n- \"7312\"\n- \"2415\"\nNon-match examples:\n- \"0300\"\n- \"7612\"",
        "matches": [
            "0200",
            "7312",
            "2415",
            "7876",
            "2913",
            "8189",
            "7808",
            "7975",
            "2756",
            "7195",
            "2875",
            "7286",
            "4528"
        ],
        "non_matches": [
            "0300",
            "7612",
            "2915",
            "e23w",
            "r32efwf",
            "43ff3",
            "f34g",
            "f23we",
            "f32ewr",
            "u46h5",
            "65hk",
            "7y6t"
        ],
        "id": 1145,
        "output": [
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            }
        ]
    },
    {
        "expression": "([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\\ ?([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])",
        "raw_prompt": "Accurate Canadian postal code format verification.\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).",
        "refined_prompt": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B0\"\n- \"L0R 1B1\"\n- \"L0R1B9\"\nNon-match examples:\n- \"W1R 4B0\"\n- \"L0R 1D1\"",
        "matches": [
            "M1R 4B0",
            "L0R 1B1",
            "L0R1B9",
            "L7N 1E3",
            "E6R 3T1",
            "L5N5L4",
            "P3P 1H8",
            "A0P9Z1",
            "H9L7Y8",
            "T3Y1E9",
            "A1Z 3B7",
            "H5A7K6",
            "X8Y 7N7"
        ],
        "non_matches": [
            "W1R 4B0",
            "L0R 1D1",
            "LOR1B9",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "u09nKLJG FSL",
            "BUFISD",
            "V8YVY",
            "87YV78V"
        ],
        "id": 1146,
        "output": [
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B3"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B1"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B2"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B9"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B8"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B9"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B,"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B4"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B\""
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B1"
            }
        ]
    },
    {
        "expression": "(([A-Z]{1,2}[0-9][0-9A-Z]?)\\ ([0-9][A-Z]{2}))|(GIR\\ 0AA)",
        "raw_prompt": "Accurate UK postal code format verification.\nUK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.",
        "refined_prompt": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"",
        "matches": [
            "M2 5BQ",
            "EC1A 1HQ",
            "GIR 0AA",
            "UO7 3UE",
            "MA5 5FQ",
            "YW7 1DL",
            "Q2 1YQ",
            "X0 5QN",
            "ZY9 7PE",
            "SO6 3YW",
            "T4 3OF",
            "XS7 1KP",
            "XE9 1JP"
        ],
        "non_matches": [
            "M2 BQ5",
            "E31A 1HQ",
            "GIR0AA",
            "INDIANA",
            "234",
            "3nf@",
            "43-5432",
            "notre dame",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1148,
        "output": [
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate all"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate all"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate some"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate a"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate non"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate code"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate a"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate all"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate a"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate Random"
            }
        ]
    },
    {
        "expression": "(NL-?)?[0-9]{9}B[0-9]{2}",
        "raw_prompt": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.",
        "refined_prompt": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.\nMatch examples:\n- \"NL123456789B12\"\n- \"NL-603781070B39\"\n- \"404760885B21\"\nNon-match examples:\n- \"NL123456789012\"\n- \"NL52/2/54/245\"",
        "matches": [
            "NL123456789B12",
            "NL-603781070B39",
            "404760885B21",
            "NL-928678468B98",
            "955593039B36",
            "NL400065759B60",
            "067135372B53",
            "NL-723046312B09",
            "954419151B44",
            "NL-449870839B21",
            "NL-994662298B52",
            "448404466B38",
            "013604724B16"
        ],
        "non_matches": [
            "NL123456789012",
            "NL52/2/54/245",
            "NL2534/52435234/2453",
            "NLafdsaf.adijs",
            "NL9ijn",
            "NL3nf@",
            "NL43-5432",
            "NL254627g.256",
            "NL245/524/12",
            "NLcom.edu.github",
            "NL(0xx12) 62509@",
            "NL++63453.345"
        ],
        "id": 1164,
        "output": [
            {
                "text": "\n```python \nimport re\nvalidPattern1 = '(.*?)(\\d{2})(\\D*)(\\d{4}-"
            },
            {
                "text": "\n(NL)\\d{4}[-/\\s]?\\d{3}[-/\\s]?\\d{2}["
            },
            {
                "text": "  ^[3][0-9]\\d{15}(?:-[0-9]{14})?$\n- The first character is"
            },
            {
                "text": " NLD+EIN+B+20 = \"NL\" + \"EIN\" + B\n- \"NL+EIN+8/3/5"
            },
            {
                "text": " NL(?:-?[0-9]{2})[0-9]{5}(?:-?[0-9]{2})"
            },
            {
                "text": "\nNL(-?\\d+), (.+)\\s?(?=(B+))?\n\"NL-(?:\\d+)\", \"\", ("
            },
            {
                "text": "\n\nA:\n\nI created a solution based on this answer and here it is. It searches the website for the required fields, then checks the URL and"
            },
            {
                "text": " [https://regex101.com/r/zcH6h/3]\n\n3. Extract the following phone numbers from the dataset using Reg"
            },
            {
                "text": " \"NL[0-9]+(-[0-9]+)*(?:/[0-9]*)?\", for NL123456789B12"
            },
            {
                "text": " \n^[\\S]{3}\\D?[\\d]{2}\\S?$|^[\\d]{10}$|"
            }
        ]
    },
    {
        "expression": "^\\s*([\\(]?)\\[?\\s*\\d{3}\\s*\\]?[\\)]?\\s*[\\-]?[\\.]?\\s*\\d{3}\\s*[\\-]?[\\.]?\\s*\\d{4}$",
        "raw_prompt": "US 10-Digit Phone number matching.\n*Requires Area Code\n*Brackets optional, supports: () and []\n*seperators optional, supports: - and .\n*whitespace optional",
        "refined_prompt": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or .) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"",
        "matches": [
            "6105551515",
            "(610) 555 - 1212",
            "[610]555.1212",
            "(123) 456-7890",
            "[456]789-0123",
            "(555)555.5555",
            "123-456-7890",
            "555 555 5555",
            "(123)4567890",
            "987.654.3210",
            "[111]222-3333",
            "555-555-5555",
            "123.456.7890"
        ],
        "non_matches": [
            "1 (610) 555-1212",
            "(610) 555-1212 ext*",
            "[12345]67890",
            "(123) 456.7890a",
            "5555-5555-5555",
            "(123)[456]7890fads",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1165,
        "output": [
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: \"(1)(610) (555)"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: A RegEx for \"(?:\\("
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: [0-9]\\s?"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: (\\d)\\s\\()\\"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: /^\\(\\d{3}"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: /^\\s*(\\d{"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: ([^\\(\\)]+)\\s"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: \n\nmyPattern = re."
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: (\\d{3}-\\"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: \"\\D\\D[\\d.]"
            }
        ]
    },
    {
        "expression": "^(([a-zA-Z]+\\d+)|(\\d+[a-zA-Z]+))[a-zA-Z0-9]*$",
        "raw_prompt": "Password validator that validates the password contains 1 letter (regardless of case) and 1 number",
        "refined_prompt": "Password validator that validates the password contains 1 letter (regardless of case) and 1 number\nMatch examples:\n- \"Password1\"\n- \"1Password\"\n- \"1Password1\"\nNon-match examples:\n- \"*Password1\"\n- \"*1Password*\"",
        "matches": [
            "Password1",
            "1Password",
            "1Password1",
            "f6f76f",
            "67f",
            "67fafd",
            "fa67f",
            "76f",
            "67vf87v877",
            "v7g97",
            "87v78g6",
            "6v6v6y6v7",
            "v7v7gb7u"
        ],
        "non_matches": [
            "*Password1",
            "*1Password*",
            "*1Password1*",
            "feafdsafd",
            "sfadsafds",
            "fqfd",
            "gafdfsda",
            "thytng",
            "ngfgt",
            "514351",
            "653752",
            "555413"
        ],
        "id": 1177,
        "output": [
            {
                "text": " [a-z]{1}[0-9]\n\nExercise 2: Password length calculator\nCreate a Python script that prompts the user for a password and calculates its length. Use regular expressions to exclude characters that are common password mistakes,"
            },
            {
                "text": " [?][\\w@$]{7,}\n\n5. Write a Python function that takes in a text document file and prints out each line with the first letter capitalized. Use file handling to read from the file.\nAnswer:"
            },
            {
                "text": "\n^[a-zA-Z]{1,}[0-9]{1,}$\nTo generate a regular expression using RegEx, start by adding characters to the following characters class: \n\n[A-Z"
            },
            {
                "text": " [a-z][a-z0-9]*\n\n5. Create a Pyhton script that reads an IP address from standard input and validates it using the ipaddress library.\nHint: Use the ipaddress.ip"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$\n6. Create a regular expression that matches file paths"
            },
            {
                "text": " password \\d+\n\nThe third quiz, \"Create a regular expression to validate a list of usernames that are no longer than 20 characters long, starting with a lowercase letter and at least one uppercase letter.\"\n\n[Qu"
            },
            {
                "text": " `^(?=.*[a-z])(?=.*[0-9]).{8,}$`\n\n2. Solution:\nWe can use Django to help us ensure our passwords meet our requirements. We might define a"
            },
            {
                "text": ".{1}?(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).}\n\n```python\nimport re \n\npassword = input(\"Enter a password: \")"
            },
            {
                "text": "\n\n```python\nimport re\nfrom django.contrib.auth.validators import passwords\n\ndef password_validator(password):\n    pattern = re.compile(\n        \"^(?=.*[a"
            },
            {
                "text": " ^(?=.*\\d)(?=.*[a-z])(?=.*\\W)[A-Za-z\\W]+$\n3. Exercise: Write a Python function that takes in a string parameter and checks if"
            }
        ]
    },
    {
        "expression": "^(?=.*[a-zA-Z].*[a-zA-Z])(?=.*\\d.*\\d)[a-zA-Z0-9]{6,20}$",
        "raw_prompt": "Password matching expression. Password must consists of at least 6 characters and not more than 20 characters. Password must contain only letters and digits. Password must contain at least 2 digits and at least 2 letters.",
        "refined_prompt": "Password matching expression. Password must consists of at least 6 characters and not more than 20 characters. Password must contain only letters and digits. Password must contain at least 2 digits and at least 2 letters.\nMatch examples:\n- \"a1b2c3\"\n- \"65c5t7c\"\n- \"6fv7cv8y\"\nNon-match examples:\n- \"aaaaa1\"\n- \"IUBUFID\"",
        "matches": [
            "a1b2c3",
            "65c5t7c",
            "6fv7cv8y",
            "8g7uycv8yv",
            "87yvv8v7",
            "78v8v78v",
            "78vv8u7b8",
            "78yvg78",
            "v78uvb8",
            "8c56rf56",
            "9h89h89ugh78gu",
            "76tc67f67y",
            "87g78ub8"
        ],
        "non_matches": [
            "aaaaa1",
            "IUBUFID",
            "BYUBUFISD8",
            "HUIFDHS*&H*(",
            "FUDUIHbydfusy",
            "8974293857289",
            "87423897586",
            "7867423687",
            "574689",
            "y87",
            "78h",
            "8yv7gt48h9urief8f74hru8gre45regreg4re"
        ],
        "id": 1189,
        "output": [
            {
                "text": " Password must consist at least 6 characters and not more than 20. Password must contain at least 2"
            },
            {
                "text": " Passwords must consist of at least 6 characters and not more than 20 characters, must contain only"
            },
            {
                "text": " (?=([0-9]{6})[a-z]*[0"
            },
            {
                "text": " 1. [a-zA-Z]{2}[0-9]{"
            },
            {
                "text": "\n(^(?=.*.*)(?=.*\\d)(?=.*["
            },
            {
                "text": "\n(?=^[a-z]*$)(?=^[0-"
            },
            {
                "text": "\n^.{1,20}([0-9]{2}){2}"
            },
            {
                "text": " (a) Password must consist of at least 6 characters and not more than 20 characters. Password"
            },
            {
                "text": " [a-zA-Z]{6,20}[0-9]{"
            },
            {
                "text": "\nPassword matching examples:\n- '^(?=.*[a-z])("
            }
        ]
    },
    {
        "expression": "^(?:(?:[+\\-]?\\$?)|(?:\\$?[+\\-]?))?(?:(?:\\d{1,3}(?:(?:,\\d{3})|(?:\\d))*(?:\\.(?:\\d*|\\d+[eE][+\\-]\\d+))?)|(?:\\.\\d+(?:[eE][+\\-]\\d+)?))$",
        "raw_prompt": "This regex will validate the given string is numeric",
        "refined_prompt": "This regex will validate the given string is numeric\nMatch examples:\n- \"$123.1234\"\n- \".123\"\n- \".123e+01\"\nNon-match examples:\n- \"asdf\"\n- \",\"",
        "matches": [
            "$123.1234",
            ".123",
            ".123e+01",
            "4563",
            "575",
            "6",
            "375",
            "46",
            "486",
            "58",
            "75",
            "6678",
            "4678"
        ],
        "non_matches": [
            "asdf",
            ",",
            "1,1",
            ".",
            "f56f",
            "567f",
            "67f",
            "76v",
            "76fv65f57gh",
            "h89",
            "hj98",
            "ju89h78"
        ],
        "id": 1199,
        "output": [
            {
                "text": "^[0-9]+(?:\\.[0-9]+)?$\n\n5. Write a regular expression that will validate the given string is uppercase.\n\n```python\nimport re\n\ntext = \"THIS is The UPPERCASE String.\"\n\n# Answer\npattern = r"
            },
            {
                "text": " The correct Regular Expression is '^\\d+(\\.\\d+)?$'.\n\n\n# Chapter: The use of SciPy for Computational Chemist\n\n## Section: Applications of SciPy Interpolation for Computational Chemist\n\nIn this section, we will explore how we can use interpolation"
            },
            {
                "text": " [a-zA-Z0-9]*|[^a-zA-Z0-9]\n\nHost 1: We hope you found these quizzes helpful, Host 2. Now, let's dive deeper into the usage of regex and quantifiers.\n\nHost 2: Regex and"
            },
            {
                "text": " ([\\d.])+. Which will create an array of all numeric characters. This is similar to the (\\d) example, but includes a decimal point to allow decimal values.\n  \n\n2. Write a regex pattern to validate an array of values that should only contain alpha-numeric characters.\n\n"
            },
            {
                "text": " (\\d+\\.?)\\+$\n\nUsing a regex to validate numbers\nTo validate a number in this format, we pass the input to the regex:\nhttps://www.w3schools.com/jsref/jsref_number_format.asp\n\nTo validate a number with precision"
            },
            {
                "text": "  ([a-zA-Z_0-9]+\\.)+$\nAs you can see you need 3+ alphanumeric characters followed by a colon and ending with a digit - so the + should be after the. and not at the end. If it's necessary to use a period, you can"
            },
            {
                "text": " ^(\\d+,)?$\n\nA:\n\nI hope this would help\n\\d+(\\.\\d+)?$\n\nA:\n\n\\d+$ is the complete regular expression for any number, including zero. The $ will make it match the last digit of the number. A regular expression"
            },
            {
                "text": " \n\\d+\n\nA:\n\nI would use the NumberFormatter.\nvar formatter = NumberFormatter()\nformatter.numberStyle = NNSongStyle.Currency\n\nif (formatter.integerValue(inputString)!= Optional(0)) {\n   NSLog"
            },
            {
                "text": " /^[1-9][0-9]*\\.[0-9]{1,3}$/\n\nQuestion 2: Write a Regex expression to validate a given string as an IP address.\n\nSolution: /^((25[0-5]|2[0-4]["
            },
            {
                "text": " [0-9]{1,3}\n\nA:\n\nAnother alternative :\n\\d{1,3}(?:\\.\\d{1,3})+\n\nDebuggex Demo\n\nA:\n\nThis expression can do the job:\n^\\d{1,3"
            }
        ]
    },
    {
        "expression": "^100$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "raw_prompt": "It matches % value from 0 - 100. The two decimal places are used.",
        "refined_prompt": "It matches % value from 0 - 100. The two decimal places are used.\nMatch examples:\n- \"100\"\n- \"99.99\"\n- \"00\"\nNon-match examples:\n- \"101\"\n- \"22.1111\"",
        "matches": [
            "100",
            "99.99",
            "00",
            "20.99",
            "83",
            "48",
            "88",
            "75",
            "99",
            "94.58",
            "94.51",
            "29.48",
            "95.24"
        ],
        "non_matches": [
            "101",
            "22.1111",
            "432",
            "43.224",
            "53.353",
            "537.242",
            "43.5.242",
            "9233",
            "245/524/12",
            "1-1-2",
            "9/9/9",
            "32542 //"
        ],
        "id": 1209,
        "output": [
            {
                "text": " \"1[0-9]\\\\.\\\\d{1,2}$\"\n\n4. Write a RegEx to capture the text between the word \"and\" with at least 3 characters between \n\n2. Write a RegEx to capture the email address. You may use"
            },
            {
                "text": " ^((?:\\d\\.){0,2}(?:\\d{1,2}(?:\\d\\.)?)?\\d{1,2})$\n\n3. If you wanted to search a database for names that match a certain pattern, what regular expression could"
            },
            {
                "text": " The number may have 0 or more digits after the dot. It includes a maximum of 2 digits after the dot (0-1 digits after the dot). The digits must be preceded by the character set of \"0\" - \"49\" and the final digits must be a single digit.\n\n"
            },
            {
                "text": "\n^[01]?\\d\\d.(?:\\d{0,2})$\nIn this match, the '0' in the first two characters are mandatory. This is to ensure all the numbers are of two digits in length. It also has a decimal point followed by digits"
            },
            {
                "text": " ^(?=.*\\d)(?=.*.000)0[0-9]?$\n\nQ:\n\nRacket function for generating unique random numbers\n\nI'm trying to write a procedure to generate unique random integers in the range [1,100] until I"
            },
            {
                "text": " [0-(9]+)(\\.\\d+(0?\\d?)?)\n\"\"\"\n\ndata_file = 'data.pkl'\ndata = dill.load(open(data_file, 'rb'))\n\nx = [data[key] for key in"
            },
            {
                "text": " \"^100|101$|22\\.11$\"\n\n2. Write a program that asks the user to enter a price. Use RegEx to check if the price is valid or not.\n\n``` \nimport re \nprice = input(\"Enter your price:\")"
            },
            {
                "text": " [^0-9]{2}.*[0-9].*[0-9]\n\n3. How often would you expect this kind of values in files with less than 100 files?\nGenerate a RegEx for this description.\nAnswer: {2}.*["
            },
            {
                "text": " \n[a-z]+[0-9]*([.[0-9]][a-z]+)*[0-9]*\n\"\"\"\n\nimport regex\n\n\ndef create_regex(description):\n    \"\"\"Function creates a new regular expression given the description of"
            },
            {
                "text": "\n[0-9.]{1}[01]\n'''\n\n# Test\n'''\nprint(re.findall('[0-9.]{1}[01]', '100'))\nprint(re.findall('[0-9.]{"
            }
        ]
    },
    {
        "expression": "<\\?xml.*</note>",
        "raw_prompt": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.",
        "refined_prompt": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>John</to><from>Jane</from><message>Hello, world!</message></note>\"\n- \"<?xml version=\"1.0\" ?><note><to>Alice</to><from>Bob</from><message>Hi there!</message></note>\"\nNon-match examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>\"\n- \"<\\?xml52/2/54/245\"",
        "matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>",
            "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>John</to><from>Jane</from><message>Hello, world!</message></note>",
            "<?xml version=\"1.0\" ?><note><to>Alice</to><from>Bob</from><message>Hi there!</message></note>",
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><note><to>Mary</to><from>David</from><message>How are you?</message></note>",
            "<?xml version=\"1.1\" ?><note><to>Chris</to><from>Lisa</from><message>Goodbye!</message></note>",
            "<?xml version=\"1.0\" ?><note><to>Tom</to><from>Linda</from><message>Take care!</message></note>",
            "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>Michael</to><from>Emily</from><message>Have a great day!</message></note>",
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><note><to>Lucas</to><from>Sophia</from><message>Enjoy your weekend!</message></note>",
            "<?xml version=\"1.1\" ?><note><to>Daniel</to><from>Olivia</from><message>Stay safe!</message></note>",
            "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>Nathan</to><from>Grace</from><message>Best wishes!</message></note>",
            "<?xml version=\"1.0\" ?><note><to>Ethan</to><from>Hannah</from><message>Keep in touch!</message></note>",
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><note><to>Noah</to><from>Emma</from><message>Thinking of you!</message></note>",
            "<?xml version=\"1.1\" ?><note><to>Liam</to><from>Olivia</from><message>Take it easy!</message></note>"
        ],
        "non_matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>",
            "<\\?xml52/2/54/245",
            "<\\?xml2534/52435234/2453",
            "<\\?xmlafdsaf.adijs",
            "<\\?xml234/423/5243",
            "<\\?xml$23.454",
            "<\\?xml43-5432",
            "<\\?xml254627g.256",
            "<\\?xml245/524/12",
            "<\\?xmlcom.edu.github",
            "<\\?xml(0xx12) 62509@",
            "<\\?xml3409fjg43"
        ],
        "id": 1212,
        "output": [
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            }
        ]
    },
    {
        "expression": "^(([1-4][0-9])|(0[1-9])|(5[0-2]))\\/[1-2]\\d{3}$",
        "raw_prompt": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.",
        "refined_prompt": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.\nMatch examples:\n- \"47/2006\"\n- \"01/1840\"\n- \"36/2763\"\nNon-match examples:\n- \"00/3005\"\n- \"52/2/54/245\"",
        "matches": [
            "47/2006",
            "01/1840",
            "36/2763",
            "27/2706",
            "03/1538",
            "52/1975",
            "08/1506",
            "52/2304",
            "01/2252",
            "06/2884",
            "52/1788",
            "06/2406",
            "06/2658"
        ],
        "non_matches": [
            "00/3005",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1213,
        "output": [
            {
                "text": " W_(?:0[1-9]+|1[0-2])/\\d{4"
            },
            {
                "text": "\n\nThe two pattern that can match these examples are \n\n(?<=(?<n"
            },
            {
                "text": "\n^\\d{2}[0-3]\\d{2}[1-9"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4}, \n\nEx"
            },
            {
                "text": " [0-9]{4}\\/[0-9]{2}\\/[1-"
            },
            {
                "text": " [0-9]{1,2}/[[0-9]{4}]\" -"
            },
            {
                "text": " /(\\d{2})\\/(\\d{4})/(\\d{2})(\\d"
            },
            {
                "text": " ([^0-9]*)([0-9]|([0-9]?["
            },
            {
                "text": " \"\\\\d{1,2}/\\\\d{4}\"\n\nExercise 5:\n"
            },
            {
                "text": " (0)*|[1-2][0-9]|3[0-2]\n"
            }
        ]
    },
    {
        "expression": "^(\\d{4})\\D?(0[1-9]|1[0-2])\\D?([12]\\d|0[1-9]|3[01])(\\D?([01]\\d|2[0-3])\\D?([0-5]\\d)\\D?([0-5]\\d)?)?$",
        "raw_prompt": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.",
        "refined_prompt": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/54/245\"",
        "matches": [
            "2006-12-31 17:58:00",
            "20061231175800",
            "2006-12-31",
            "2021-09-06",
            "1990/12/31",
            "1990/12/31 23:59",
            "1990/12/31 23:59:59",
            "2022.03.15",
            "2035-01-01",
            "2032.03.16",
            "2042.03.17",
            "2052.03.18",
            "2064.03.19"
        ],
        "non_matches": [
            "2006-13-36 25:61:62",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "2021-13-06",
            "2021/00/00T12:30:45",
            "2021-09-06T25:30",
            "2021-09-06T12:60:45"
        ],
        "id": 1221,
        "output": [
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-2]) ([0-1][0-9]|2[0-4]):([0-4][0-9]|5[0-9]):([0-4][0-9]|5[0-9])$",
        "raw_prompt": "it will match a valid date & time string which looks like this : 2006-12-31 23:59:59",
        "refined_prompt": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31 4:59:65\"\n- \"06-12-2006 23:59:59\"",
        "matches": [
            "2006-12-31 23:59:59",
            "2023-09-06 08:30:00",
            "1990-05-15 18:45:22",
            "1975-02-28 14:30:05",
            "2035-01-01 00:00:00",
            "2010-11-20 12:15:30",
            "1988-07-04 03:45:55",
            "1988-07-04 03:45:55",
            "2022-03-15 21:05:45",
            "1999-08-25 05:20:59",
            "1970-01-01 00:00:01",
            "1965-03-12 11:11:11",
            "2022-12-25 00:00:00"
        ],
        "non_matches": [
            "2006-13-31 4:59:65",
            "06-12-2006 23:59:59",
            "2023-09-06 8:30:004",
            "1990/05/1543 18:45:22",
            "75-02-28 14:30:056",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "32542 //"
        ],
        "id": 1224,
        "output": [
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-24"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-01"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-16"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-12"
            }
        ]
    },
    {
        "expression": "^\\d+(\\.\\d+)?$",
        "raw_prompt": "Matches any unsigned floating point number/numeric string.",
        "refined_prompt": "Matches any unsigned floating point number/numeric string.\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \"45768\"\nNon-match examples:\n- \"abc\"\n- \"-3.14159\"",
        "matches": [
            "123",
            "3.14159",
            "45768",
            "6577",
            "65",
            "76",
            "5765",
            "787",
            "87",
            "68.534",
            "634.25324",
            "524.625",
            "5242.62"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2",
            ".234",
            ".",
            "f32rf32.",
            "34.ef",
            "34f.",
            "f34r",
            "t45wge.5t",
            ".f3",
            "t43t.543"
        ],
        "id": 1230,
        "output": [
            {
                "text": " \n(-?[0-9]*\\.?[0-9]+)((E)?|e)?\nExamples:\n- -3.14159\n- 1\n- 3.1415\n- 3.1415E2\nAnswer: (1)\n- -3"
            },
            {
                "text": " (^\\d{1,3}-?\\d{3}-?\\d{3}$|^\\d{1,2}-\\d{2}\\d{5}$)\n\n3. Write a regular expression for email addresses (ex: \""
            },
            {
                "text": " Non-match example regex:\nr\"^[0-9a-n-]+$\" #Matches any non-negative integer\n\nA:\n\n^[0-9]+\\.?[0-9]*$\nExplanation:\n    ^: start of"
            },
            {
                "text": " \n^([+-]?)\\d*(\\.\\d+)?$\n\nAs I mentioned earlier the output of this expression is the range of numbers that have digits. This means it will include 0 up to 2^32 - 2^31. \n\nA:\n\n"
            },
            {
                "text": " The pattern is: [0-9]{1,5}\\.[0-9]{3}\nIf nothing matches, a \"No match found\" message should be displayed (else the regular expression is accurate.)\nI've spent all day and can't seem to come up with the"
            },
            {
                "text": "  Match any string that starts with a digit, followed by zero or more non-digit characters, followed by another digit.\n\n3. Generate a regular expression that matches any string that contains 2 or more consecutive digits and ends with a space.\n\nAnswer: [0-9]{"
            },
            {
                "text": " To match all numbers after a - sign that are followed by a space, look for something like (^[\\d\\.]+  -) to make sure the next number is followed by some white space, and then capture the space and the next decimal.\n\nWhat I have so far:\n"
            },
            {
                "text": " (?!^-?\\d+?\\.\\d+?$)(?!^\\d+$)(?!^-?)(\\d-(\\d+\\.\\d+)|(\\d+\\.\\d+):(\\d+))/(?=^|\\)|$)$"
            },
            {
                "text": " A regular expression which matches a string of digits with one digit greater than the integer.\n\nNow, let's go through the steps to create a regular expression.\n\n1. Start by defining the patterns you want to match and the delimiter used.\n2. Write these patterns as separate strings"
            },
            {
                "text": " \"-3.14\\s/159/\" \n\nEx. 3\nWe have a group of strings that are a mix of non-numeric characters and numeric and word characters (only letters, numbers, and underscores) separated by dots. We want to generate a RegEx that will match any"
            }
        ]
    },
    {
        "expression": "[A-Z0-9]{5}\\d[0156]\\d([0][1-9]|[12]\\d|3[01])\\d[A-Z0-9]{3}[A-Z]{2}",
        "raw_prompt": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.",
        "refined_prompt": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n- \"9E8LU167058OOCLI\"\nNon-match examples:\n- \"JOHNS731215GG9SY\"\n- \"8FG78G78EWDG78G\"",
        "matches": [
            "JOHNS711215GG9SY",
            "EC6JU003207KEREJ",
            "9E8LU167058OOCLI",
            "UYELA1560477TDDE",
            "4IHZM06630354MLC",
            "YUV72854294N7IGV",
            "NACPE963301JLEHT",
            "2ID25819128RZ9QH",
            "H2H02507059MZWYA",
            "3Z0NJ666112IZHBS",
            "7ZJWQ213055QSAAY",
            "WYFF1706311S1HVC",
            "0MMEP8650334IFSQ"
        ],
        "non_matches": [
            "JOHNS731215GG9SY",
            "8FG78G78EWDG78G",
            "G78G87F2GEB8YG8YG",
            "F676J7UHY6GT5R",
            "7FG68YFG87",
            "G78GWREG4GG",
            "G87Y4R44GF",
            "G78YG4FGTTFD3E",
            "F87G7UG787",
            "GU456Y7UHY6GT5F",
            "45T6GY78UG7U8",
            "GV9UG9UGD98U3GF9"
        ],
        "id": 1239,
        "output": [
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            }
        ]
    },
    {
        "expression": "^(3276[0-7]|327[0-5]\\d|32[0-6]\\d{2}|3[01]\\d{3}|[12]\\d{4}|[1-9]\\d{3}|[1-9]\\d{2}|[1-9]\\d|\\d)$",
        "raw_prompt": "Checks that the input is a positive integer in the range 0-32767",
        "refined_prompt": "Checks that the input is a positive integer in the range 0-32767\nMatch examples:\n- \"32767\"\n- \"0\"\n- \"999\"\nNon-match examples:\n- \"99999\"\n- \"-1\"",
        "matches": [
            "32767",
            "0",
            "999",
            "5634",
            "8794",
            "857",
            "3586",
            "649",
            "6484",
            "5368",
            "3567",
            "63",
            "753"
        ],
        "non_matches": [
            "99999",
            "-1",
            "abc",
            "57CUR57",
            "RC5",
            "7RFC",
            "76RFC",
            "76F67",
            "8708968957",
            "F67FGY7",
            "575957",
            "F6Y78YF"
        ],
        "id": 1242,
        "output": [
            {
                "text": " ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[~$@.!?,;])[0-9a-zA-Z~$@.!?,;]$ \n\nExercise"
            },
            {
                "text": " ^[0-9]{1,3}([12][0-9]|3[01])$\nThe first case uses the number range for the string. \nThe second case use the sign range for the string.\nYou're only checking 1 time per line, no reason why"
            },
            {
                "text": " (Negative numbers)\n'''\n\nimport re\n\ndef match_number(txt):\n    '''\n    Takes a string txt and checks that the input is a positive integer in the range 0-32767.\n    Returns a boolean value\n    '''\n    "
            },
            {
                "text": " ^\\d*[0-9] - match non-zero followed by any amount of digits\n\"\"\"\n\ndef check_input_type(input: str)->bool:\n    if isinstance(input, str) and len(input) > 0:\n        if input[0"
            },
            {
                "text": ".*\\d*\n2. Write a Python program that takes a string as input and checks whether it contains at least one digit, letter, and a special character. Use regular expressions to match these conditions.\n```python\nimport re\n\ndef contains_special_char(input_string"
            },
            {
                "text": " \\d{1,3}\\D*|\\d*\\D[0-6]\\D*|\\D*[0-9]\\D0|0*99\n\n### 3. Validating Username Length\n``` python\nimport re\n\ndef valid_username("
            },
            {
                "text": " ^\\d{4}(-?\\d{3})$\nGenerate a RegEx for this description.\n\n4. Find all instances where a certain string can be inserted into a text with an optional prefix.  Write a Regex that does this.  Example: Prefix = \""
            },
            {
                "text": " \"(^[0-9]*|[1-9]\\d*$)\\d*$\"\n\nLecture Note: 3.6.2 What are Regular Expressions and Why Use Them (explained using Python)\n\nContents:\n- Explanation of Regular Express"
            },
            {
                "text": " \"^[0-9]0*$\"\n\n#### 6. Python exercises\n\nExercise 1: Write a function that validates an email address using a regular expression.\nAnswer:\n```python\nimport re\n\ndef validate_email(email):\n    if not re"
            },
            {
                "text": " (?i)(0|[1-9][0-9]*0?|[1-9][0-9]*(?i)(?=0)|(?i)0)0?0?0?\n\n4. Write a RegEx for this description \"The"
            }
        ]
    },
    {
        "expression": "^\\+[0-9]{1,3}\\([0-9]{3}\\)[0-9]{7}$",
        "raw_prompt": "The OAGIS standard has a format for phone and fax as +###(###)#######. For details on standard see the open applications group.",
        "refined_prompt": "The OAGIS standard has a format for phone and fax as +###(###)#######.\nMatch examples:\n- \"+555(555)5555555\"\n- \"+1(800)5555555\"\n- \"+617(355)2470357\"\nNon-match examples:\n- \"555\"\n- \"52/2/54/245\"",
        "matches": [
            "+555(555)5555555",
            "+1(800)5555555",
            "+617(355)2470357",
            "+79(062)2153857",
            "+8(991)8919924",
            "+82(829)1931583",
            "+34(076)9311372",
            "+934(400)6629643",
            "+2(394)6904808",
            "+1(011)0575956",
            "+664(492)9126216",
            "+842(730)3047647",
            "+301(861)8867823"
        ],
        "non_matches": [
            "555",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "0j0jweBBBB"
        ],
        "id": 1244,
        "output": [
            {
                "text": " \\+?(\\(\\d{3}\\)[-\\/\\\\\\s]?\\d{3})\nThis pattern would match any of the examples above.\n"
            },
            {
                "text": " \\+\\d{1,3}\\D*\n\n```python\nfrom typing import List, Dict\n\ndef extract_phone_numbers(string"
            },
            {
                "text": " \"(\\d\\d\\d)\\s(0[1-9]|1\\d\\d|2[0-8])\\/(\\d\\d\\"
            },
            {
                "text": " +[2-9]\\d{3}/\\d{2,3}/\\d{4}\n\nExercise 2: Match email addresses."
            },
            {
                "text": " \n\n``` python\nimport re\n\nphone_regex= re.compile(r'^\\+([0-9]{5})("
            },
            {
                "text": " +([0-2][0-9]|[6-9][0-9]|1[5-5][0-9]|222[6"
            },
            {
                "text": " [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]\n"
            },
            {
                "text": " +\\d{3}\\-(?:[A-Za-z]{2}\\)/\n\nExercise 5: Explain the difference between the format and the format"
            },
            {
                "text": " (\\+1\\d\\d\\d\\d\\d)'|(\\+617\\.\\d\\d\\d).(\\d){2}'\n#"
            },
            {
                "text": " [A-z]{3}[0-9]{3}[A-z]{2}[A-z0-9\\-]*/\n"
            }
        ]
    },
    {
        "expression": "([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}",
        "raw_prompt": "Matches all IPV6 and IPV4 addresses. Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression.",
        "refined_prompt": "Matches all IPV6 and IPV4 addresses. Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression.\nMatch examples:\n- \"0:123:af00:ffff:0C67:0:0:8787\"\n- \"0:0:0:0:0:0:0:1\"\n- \"0.0.0.1\"\nNon-match examples:\n- \"::1\"\n- \"52/2/54/245\"",
        "matches": [
            "0:123:af00:ffff:0C67:0:0:8787",
            "0:0:0:0:0:0:0:1",
            "0.0.0.1",
            "999.999.999.999",
            "E8:D:27E:e:1CDE:4256:0BE:a4",
            "4.764.7.7",
            "5.39.1.6",
            "68:7D:AcDB:4E8B:b32:e:3ba:3d",
            "e3B6:cdA8:62Cc:BA:DF4a:8bD2:71:25",
            "413.14.471.7",
            "681:e:2f:F0a7:f613:aF:E4:5D8E",
            "519.24.1.6",
            "931.958.74.1"
        ],
        "non_matches": [
            "::1",
            "52/2/54/245",
            "-243",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1246,
        "output": [
            {
                "text": " \"\\\\."
            },
            {
                "text": " \"0:("
            },
            {
                "text": "\n- 0"
            },
            {
                "text": " \"([0"
            },
            {
                "text": " ([0-"
            },
            {
                "text": " \"1(["
            },
            {
                "text": " [0:"
            },
            {
                "text": "\n::(["
            },
            {
                "text": "\n(?!"
            },
            {
                "text": " \n\""
            }
        ]
    },
    {
        "expression": "^(H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}\\d{4}(NE|NW|SE|SW)?$|((H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}(\\d{4}|\\d{6}|\\d{8}|\\d{10}))$",
        "raw_prompt": "This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number. Information on the range of possible values can be found here: http://www.ordnancesurvey.co.uk/oswebsite/gps/information/coordinatesystemsinfo/guidetonationalgrid/page17.html. Grid Ref, Tile Ref, Sheet Ref.",
        "refined_prompt": "This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number.\nMatch examples:\n- \"NA1234SE\"\n- \"OV5571\"\n- \"SG2714926378\"\nNon-match examples:\n- \"AA1234SE\"\n- \"YI67fyvG\"",
        "matches": [
            "NA1234SE",
            "OV5571",
            "SG2714926378",
            "TG6547SW",
            "OV1556SW",
            "OV4533",
            "HU0548SE",
            "TG551952",
            "SO4698NW",
            "NS3672",
            "SE6571NW",
            "NF2271229107",
            "NB3552"
        ],
        "non_matches": [
            "AA1234SE",
            "YI67fyvG",
            "Y8G8YG",
            "GY8G78G6G",
            "F67FG8YG9",
            "876FFG78G",
            "9UG",
            "87G8",
            "G8",
            "7G87",
            "G8Y",
            "V8IUG7B"
        ],
        "id": 1251,
        "output": [
            {
                "text": " Non-match example\n\nExercise 2:\nSearch the text below for the first occurrence of any of the given words (in any order):\n\"As a teacher, I love reading children's books with bright illustrations"
            },
            {
                "text": " \"\\w{8}(\\d{4})(\\d{4})$\" - A combination of 8 alphanumeric characters (a-z, A-Z, 0-9) with at least two digits"
            },
            {
                "text": "\n\n- [012]\\d{4}[SE]\n- [O5]\\S+\n- [G]\\d+$\n\nExercise 3: \nCreate a valid RegEx"
            },
            {
                "text": "\n^(19|20[1-9]|1[2-9]2|11[1-9]0|20[0-9]2|2[1-8]9)|\\"
            },
            {
                "text": " Match all combinations of the digits 0-9 (2-9 times) in any order.\nAnswer: (0[9]|1[9]){3}[0-9]\n\n4. A"
            },
            {
                "text": "\n\nRegEx:\n[a-zA-Z0-9]{4}_[a-z]{3}_[a-z]{4}_[a-z]\n"
            },
            {
                "text": " [^0-9a-zA-Z_].\n\nExercise 2: \nCreate a Python script that takes a list of Coordinates consisting of Latitude and Longitude pairs and filters out only those"
            },
            {
                "text": " \n.*(?=\\d{3,4}$)(?!.*\\.\\s)[\\d\\- ]{7,8}$.*\n\n# Pattern 4: Phone Number Pattern\n\nphone_"
            },
            {
                "text": " The regex is '(^NS)(\\d{2})([^NS]|ST)*$'\nWhat if you can't use a single pipe character to join the pattern like so:\nNS0123-"
            },
            {
                "text": " [NB:This is not possible] \"N\\(a2\\)\\d([YY][A-Z])$\" for valid matches, but not \"N\\(a2\\)\\d(Y|"
            }
        ]
    },
    {
        "expression": "<title>+(.*?)</title>",
        "raw_prompt": "This pattern could intercept the value of the tag title in every web pages, it could be found in $1.",
        "refined_prompt": "match strings that contain a specific text pattern typically found in HTML documents where <title> tags enclose some content.\nMatch examples:\n- \"<title>this title</title>\"\n- \"<title>fadsf2fe</title>\"\n- \"<title>2dffd</title>\"\nNon-match examples:\n- \"any other tags\"\n- \"title\"",
        "matches": [
            "<title>this title</title>",
            "<title>fadsf2fe</title>",
            "<title>2dffd</title>",
            "<title>d2fdd</title>",
            "<title>f2df2d</title>",
            "<title>df2fs2</title>",
            "<title>dffd22fd</title>",
            "<title>d2ff2f</title>",
            "<title>fd2f2ffd</title>",
            "<title>df2f</title>",
            "<title>fd222re</title>",
            "<title>er2r2</title>",
            "<title>t23t22 23rr</title>"
        ],
        "non_matches": [
            "any other tags",
            "title",
            "Title",
            "missing closing",
            "titalfe",
            "231 teas",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1254,
        "output": [
            {
                "text": " <title>(.*)</title>  \n2. Check each line of a string to see if it contains only alphabetic characters. If a line does not contain al"
            },
            {
                "text": " [^><</]*\n\nExercise 2:\nWrite a regex that matches all words in a string that have no dashes\nExample: This is an example"
            },
            {
                "text": " [^<title>]\"\n- \"\\b\"Generate a RegEx for this explanation. \nAnswer: [^|\\b]\n- \"\\d\""
            },
            {
                "text": " \"\\<title>([^>]+)<\\/\\title>\".\n**2. Write a Python program to count how many times a phrase appears in a document. Use"
            },
            {
                "text": " \"[A-Za-z0-9><\\/>]+$\"\n\n### Exercise 3:\nCreate a RegEx that validates an email address, ensuring"
            },
            {
                "text": " \"\\<title[^{\\\\s}a-zA-Z0-9]+\\>+\"\n\n2) Use re.sub() to replace a subst"
            },
            {
                "text": " import re;title_re = re.compile(r'<title>(.*)</title>')\n\n3\nWrite a code that uses Python string method is"
            },
            {
                "text": "\n# Import re module and assign to variable text.\ntext=\"<title>this title</title>\\n\\n<title>fadsf2fe</"
            },
            {
                "text": " \"(<title>[^>]*)(?:\\s+\\|(.+))?\"\n3. Modify the previous exercise to return a list of all text matches"
            },
            {
                "text": " \\</title>|title+\nExercise 4: Use the Regex class to capture a list of all the characters in a string except uppercase letters and digits"
            }
        ]
    },
    {
        "expression": "<h([1-6])>([^<]*)</h([1-6])>",
        "raw_prompt": "This regex find valid <h1-6> html tags",
        "refined_prompt": "This regex find valid <h1-6> html tags\nMatch examples:\n- \"<h2>test2</h2><h3>test3</h3>\"\n- \"<h1>Heading 1</h1>\"\n- \"<h2>Subheading</h2>\"\nNon-match examples:\n- \"<h>test1</h>\"\n- \"<h7>Invalid Heading</h7>\"",
        "matches": [
            "<h2>test2</h2><h3>test3</h3>",
            "<h1>Heading 1</h1>",
            "<h2>Subheading</h2>",
            "<h3>Another Example</h3>",
            "<h4>Fourth Level</h4>",
            "<h5>Fifth Level Heading</h5>",
            "<h6>Lowest Level</h6>",
            "<h1> Leading and Trailing Spaces </h1>",
            "<h2></h2>",
            "<h3>&lt;Special Characters&gt;</h3>",
            "<h4> Indented Content </h4>",
            "<h5>Special &amp; Characters</h5>",
            "<h6>12345</h6>"
        ],
        "non_matches": [
            "<h>test1</h>",
            "<h7>Invalid Heading</h7>",
            "<h0>Invalid Heading</h0>",
            "<h0>Zero Level</h0>",
            "<h7>Out of Range</h7>",
            "<H1>Uppercase Tag</H1>",
            "<H2>Uppercase Tag</H2>",
            "<p>Paragraph</p>",
            "<div>Division</div>",
            "<h2>Missing Closing Tag",
            "Text without Tags",
            "<h3>No Closing Tag"
        ],
        "id": 1257,
        "output": [
            {
                "text": " \"\\d[-_A-Za-z_/](\\d[-_A-Za-"
            },
            {
                "text": " '^[a-z]{2,20}[a-z \\-0-9]*<"
            },
            {
                "text": " ^<([A-Za-z0-9_-]+?)>(.*)</\\2>$\n\n"
            },
            {
                "text": " \"^(h\\d+)(-$|$)$\"\n\nHow to use Regular Expressions in Python"
            },
            {
                "text": " It's not possible, as <h7> tag doesn't exist in HTML.\n\nI hope you've understood"
            },
            {
                "text": " [A-Za-z0-9]+[A-Za-z0-9\\' ]+"
            },
            {
                "text": " (?<=</h5>)(.*?)$\n\n    Lecture Script: \"Generating"
            },
            {
                "text": "\n\n<h[0-9]*>(.*?)</h[0-9]*>\n\n"
            },
            {
                "text": "  (.*)</div><div><h3>.*(</h#1>)?(</h6>"
            },
            {
                "text": " ^\\<\\h(1\\d|2\\d|3\\d):(.+?)\\>."
            }
        ]
    },
    {
        "expression": "\\b[1-9]{1}[0-9]{1,5}-\\d{2}-\\d\\b",
        "raw_prompt": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).",
        "refined_prompt": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).\nMatch examples:\n- \"50-00-0\"\n- \"75-18-5\"\n- \"41-40-4\"\nNon-match examples:\n- \"200-001-8\"\n- \"52/2/54/245\"",
        "matches": [
            "50-00-0",
            "75-18-5",
            "41-40-4",
            "96-09-4",
            "5448-08-2",
            "828-90-0",
            "13-70-0",
            "95-27-1",
            "249-34-2",
            "149-06-4",
            "133-13-1",
            "180834-05-5",
            "791712-08-1"
        ],
        "non_matches": [
            "200-001-8",
            "52/2/54/245",
            "-243",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1260,
        "output": [
            {
                "text": " (re.findall(r'\\b[0-9]+(\\.[0-9]{4})"
            },
            {
                "text": " /\\d{2}\\-\\d{2}-\\d{3}$/$\n\n*Part 3"
            },
            {
                "text": "  (\"\\.[0-9]{3}\\-\\([0-9]{3}\\)[-\\."
            },
            {
                "text": " \"0-99-99-0\"\nThis is a more robust regex for matching Customer Service Numbers.\nMatch examples"
            },
            {
                "text": " (\\d{3})-(\\d{4})-(\\d{4})\\/\\d{2}\\"
            },
            {
                "text": " r'^[0-9][0-9][0-9]\\/([0-9][0-9"
            },
            {
                "text": " \\D0-9-\\d {3}\\D\nHere are some practice exercises to help build your understanding and mastery"
            },
            {
                "text": " \n([0-9]{4})-([0-9]{3})-([0-9]"
            },
            {
                "text": " \n\\d{3}-\\d{2}-\\d{4}|\\d{3}"
            },
            {
                "text": " This is a more robust regex for matching chemical entity number.\n\n4. Create a RegEx for validating US phone"
            }
        ]
    },
    {
        "expression": "^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "raw_prompt": "Requires area code. Allows extension. Any common US format works. If you prefer not to require area code, use this: ^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})?[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "refined_prompt": "Requires area code. Allows extension. Any common US format works.\nMatch examples:\n- \"1 (123) 123-1234 ext. 1234567\"\n- \"1 (123) 123-1234\"\n- \"(123) 123-1234\"\nNon-match examples:\n- \"123/1234 L. 12345678\"\n- \"52/2/54/245\"",
        "matches": [
            "1 (123) 123-1234 ext. 1234567",
            "1 (123) 123-1234",
            "(123) 123-1234",
            "(123)123.1234",
            "1-123-123-1234",
            "1231231234",
            "1 (123) 123-7482",
            "1 (123) 384-1234",
            "1 (592) 123-1234",
            "(123) 123-4028",
            "(123) 482-1234",
            "(471) 123-1234",
            "(123) 472-5819"
        ],
        "non_matches": [
            "123/1234 L. 12345678",
            "52/2/54/245",
            "-243",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "/5/5/5",
            "254627g.256",
            "245/524/12",
            "1-1-2",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1267,
        "output": [
            {
                "text": " [^0-9]\\\\(\\\\d{3}\\\\)\\\\s[0-9]{3}\\\\/(\\\\d"
            },
            {
                "text": " [0-9]{3}[.,]?[0-9]{3}[.]?[0-9]{"
            },
            {
                "text": " (\\d+\\/)(\\d{2}\\/(\\d{2}\\/)|(\\d{4}\\/))+[\\"
            },
            {
                "text": " [^()]?(\\d{3})\\d{3}\\d{4}\n\n**Exercise 7:** Generate"
            },
            {
                "text": " ^[0-9]{1,3}[-/ ][0-9]{1,3}[-/ ]["
            },
            {
                "text": " (\\d)/[a-zA-Z]\n\n4. Describe how to remove all leading/trailing white space from"
            },
            {
                "text": " *[0-9]{3}\\.[0-9]{3}\\.[0-9]{3}-[0-9"
            },
            {
                "text": " \\d {4} / [a-z]{2}[-a-z]{3}[-a-z]"
            },
            {
                "text": " r'many (1 | 2 | 3 | 4'\n\nPart 2: Examples\n\nNow that we've learned what a RegEx"
            },
            {
                "text": " \"\\/[0-9]{2}\\W/\" - generates the RegEx\n5. Write an extension code for a city ("
            }
        ]
    },
    {
        "expression": ".*(\\.[Jj][Pp][Gg]|\\.[Gg][Ii][Ff]|\\.[Jj][Pp][Ee][Gg]|\\.[Pp][Nn][Gg])",
        "raw_prompt": "This expression should work to validate that an uploaded file's extension is either jpg, gif, or png.",
        "refined_prompt": "This expression should work to validate that an uploaded file's extension is either jpg, gif, or png.\nMatch examples:\n- \"foo.gif\"\n- \"foo.jpg\"\n- \"foo.png\"\nNon-match examples:\n- \"foo.txt\"\n- \"foo.zip\"",
        "matches": [
            "foo.gif",
            "foo.jpg",
            "foo.png",
            "afd.gif",
            "afsd.gif",
            "efw.gif",
            "dfw.gif",
            "egw.jpg",
            "wfoo.jpg",
            "dgwg.jpg",
            "werfoo.png",
            "trv.png",
            "vcs.png"
        ],
        "non_matches": [
            "foo.txt",
            "foo.zip",
            "foo.exe",
            "afdsaf.adijs",
            "9ijn",
            "3nf@",
            "jpg",
            "pdf",
            "zip",
            "png",
            "exe",
            "gif"
        ],
        "id": 1268,
        "output": [
            {
                "text": "\n\nimport re\nfrom flask import request\nfrom werkzeug.utils import secure_filename\n\n@app.route('/', methods=['POST'])\ndef upload_file():\n    if 'file"
            },
            {
                "text": " (\\D+\\.)+$\nExplanation: A (\\D) matches any non-digit character, and a+ means to match one or more of the previous expression. To make sure the files end with."
            },
            {
                "text": " \n(jpg+|png+)(?=\\.txt|\\.zip$)\n\nExercise 5:\nCreate a regular expression to validate that an uploaded email adheres to the standard format, which is one or more"
            },
            {
                "text": " ^[.](jpg|gif|png)$\n\nLecture Script: Subsection 5.4.8 - Using the urlparse Module and Its Methods\n\nContents:\n1. Introduction to the urlparse"
            },
            {
                "text": ".+\\.((gz|bz2|lz|tgz|rz|xz|pj|7z)$)$\nThis expression should work to validate that an uploaded file's extension is g"
            },
            {
                "text": "\n@regex = /^[a-z0-9]+[.](jp(g|p|g|m)?)$/i; \nThe first rule (i) just checks if the uploaded file"
            },
            {
                "text": " ^(.+\\.jpg)|(.+\\.gif)|(.+\\.png)$\n\nWe hope that this blog post has provided you with a better understanding of how to validate files and folders with the Django web framework"
            },
            {
                "text": " [^a-zA-Z_0-9]\n\nExercise 2: Create a new Python function that takes an uploaded filepath and returns the file extension using the expression from exercise 1.\nAnswer: \n"
            },
            {
                "text": " ^(?i)([a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)?)(\\.([a-zA-Z0-9]+)?)$"
            },
            {
                "text": "\nimport re\nimageValidator = re.compile(r\"^(.+\\.(jpg|png|gif))$\")\n\nIn conclusion, regular expressions are powerful tools for validating data in Python. These"
            }
        ]
    },
    {
        "expression": "^[-+]?(\\d?\\d?\\d?,?)?(\\d{3}\\,?)*$",
        "raw_prompt": "This pattern matches on Integer values. Handles leading positive or negative signs. Supports commas where only the leading group can have less than three digits.",
        "refined_prompt": "This pattern matches on Integer values. Handles leading positive or negative signs. Supports commas where only the leading group can have less than three digits.\nMatch examples:\n- \"+1\"\n- \"-2\"\n- \"3,000\"\nNon-match examples:\n- \"A\"\n- \"1,23\"",
        "matches": [
            "+1",
            "-2",
            "3,000",
            "1,234,567",
            "867",
            "864",
            "34",
            "534",
            "754",
            "34867",
            "4643",
            "3536",
            "3576"
        ],
        "non_matches": [
            "A",
            "1,23",
            "2,34,567",
            "1.0",
            "D#@45d",
            "45dr45dD$",
            "$%D%RD45sd",
            "$%D453d",
            "4%D5d4",
            "fgv",
            "bibuif5",
            "d55fd"
        ],
        "id": 1278,
        "output": [
            {
                "text": " (?<!^)([0-9][0-9]?[0-9])+,([0-9][0-9]?[0-9])+,([0-9][0-9"
            },
            {
                "text": " \"^[0-9]+,[0-9]+\"\nThis example says:\n\nMatch one or more digits 0-9;\nBetween zero or more commas 0-9, 0 or more times.\n"
            },
            {
                "text": " (^(?![^, ]+,\\s{0}?\\-{0}?$)\\d+,\\d+$)(?![^, ],\\s{0}?\\-{0}?$"
            },
            {
                "text": " ^(a|-|\\.\\.|,)[\\d,].*$\n\n6. (3): Handle all input alphanumeric characters.\nIn the example pattern above,. matches any combination of alphanumeric"
            },
            {
                "text": " ^([-+0-9]\\d{0,3},)*$\nTo test this RegEx - http://rubular.com/r/X7eSqXU2\n\nA:\n\n"
            },
            {
                "text": " (\\d{1,3})+,?(\\\\d{3})?\nExplanation:\n\\d   # matches any digit\n{1,3}  # matches 1 to 3 digits\n*,?"
            },
            {
                "text": " -\\d+,\\d+\n-\\d+\nA pattern that matches numbers: /\\d+/\n\nA:\n\nUse a pattern like\n^-?\\d+,?\\d+$"
            },
            {
                "text": " -[-+]?0+[0-9]+, 0+ numbers of intigers.\n(this will output 1)\nNow, how do you change it to handle numbers from 3,000 to 5,000"
            },
            {
                "text": " (\\d)(([-]\\d{0,3})*)\nPattern for positive numbers with commas: \n[+]?[0-9]{0,3}([,-]?["
            },
            {
                "text": " (\\d,[]\\d{,})\\d+\nIn this regex we have a match if one or more digits occur in a group then followed by a comma and three more digits, repeating it one or more times"
            }
        ]
    },
    {
        "expression": "^([0-1](?:\\.\\d)|[0-1](?:\\,\\d)|(2\\.0)|(2\\,0))$",
        "raw_prompt": "Had to handle both \",\" and \".\" as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00f6gskoleprov (SAT).",
        "refined_prompt": "Had to handle both \",\" and \".\" as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00f6gskoleprov (SAT).\nMatch examples:\n- \"0,0\"\n- \"0.0\"\n- \"1,9\"\nNon-match examples:\n- \"2,1\"\n- \"1\"",
        "matches": [
            "0,0",
            "0.0",
            "1,9",
            "2.0",
            "1.2",
            "1.3",
            "1.4",
            "1.5",
            "1.6",
            "1.7",
            "1.8",
            "1.9",
            "0.7"
        ],
        "non_matches": [
            "2,1",
            "1",
            "3",
            "a",
            "5",
            "67",
            "8",
            "9",
            "5",
            "3.534",
            "5436.234",
            "423.24"
        ],
        "id": 1284,
        "output": [
            {
                "text": "\nimport re\n\nmatches = [\"0,0\", \"0.0\", \"1,9\", \"2,1\"]\n"
            },
            {
                "text": " ([0-9\\\\.,]+, [0-9\\\\.,])* - Match every number or comma, followed by any number or comma"
            },
            {
                "text": " A,B|C.|D\n\n(Note: \"|\" is the \"OR\" operator and \",\" is the \"OR"
            },
            {
                "text": " ^[0-9]{1,2}[,.][0-9]{1,2}$\n\n- \"0"
            },
            {
                "text": " ^(?!,$)^(?!\\.|,|\\(|\\))[0-9\\.]+\nThe first look"
            },
            {
                "text": " \"([0-9,]+(.[0-9]+)?)([,.][0-9]+)\"\n\n2. Match a"
            },
            {
                "text": " 0(?:\\.[0-9]*|[0-9]+)\nhttps://regex101.com/r/K"
            },
            {
                "text": "\n\nA:\n\nYou may use\n\\d+(\\.\\d+)?(?:[eE][+-]?\\"
            },
            {
                "text": " (.*?),(.*?)\n\n2. Write a regex that gets exactly one \",\" after every two consecutive numbers, so for numbers with"
            },
            {
                "text": " (^|[\\s,]+) [0|2.-]\\.[0|9]+$\nWhat I could do:\n"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\040]+$",
        "raw_prompt": "It will allow for alphanumeric characters only, with the exception of spacing.",
        "refined_prompt": "It will allow for alphanumeric characters only, with the exception of spacing.\nMatch examples:\n- \"Website Users\"\n- \"g67g\"\n- \"f667f8\"\nNon-match examples:\n- \"Website Users!\"\n- \";f;ds;f\"",
        "matches": [
            "Website Users",
            "g67g",
            "f667f8",
            "f",
            "8f5",
            "d56 f5",
            "f56f",
            "7f77",
            "f68d5",
            "6r4e",
            "45h899h",
            "98",
            "98h"
        ],
        "non_matches": [
            "Website Users!",
            ";f;ds;f",
            "f;",
            "f';f'df;[",
            "f;[d",
            ";[f",
            ";d[dlf[lfd[ld",
            "p[f",
            "[fpkd",
            "j{}",
            "f98h[]",
            "78h7g^&*&("
        ],
        "id": 1313,
        "output": [
            {
                "text": " \"Website Users(\\W?+)\"\n- \"g67g#\"\nGenerate a RegEx for this description.\nAnswer: \"g67g(?!\\W)$\"\n\nExercise 4:\nUse an array of your"
            },
            {
                "text": " Non-match example!\n\nExercise 4:\nCreate a Python list to store the passwords for all the web pages in your site. Store the password in this list:\n\"This is my website!\"\nRemember to update the password list with a"
            },
            {
                "text": " \"https?://(?:[^;&]|;|$)\";\n\nUse regex to clean up the following text:\n\"  website users   \";\n\"  www.website-users  \";\n\"  www users"
            },
            {
                "text": " \".*\\s(?<![a-zA-Z])[^a-zA-Z\\s].\" \n\nExercise 3: Matching phone numbers\n- \"123-456-7890?\"\n- \"555"
            },
            {
                "text": " /^(?!^*[^A-Za-z0-9_])[A-Za-z]{3,12}$/i and (?!^(*[^A-Za-z0-9_"
            },
            {
                "text": " /[^ ]+\n\n3. You are given a tuple of words: (\"hello\", \"world\", \"python\", \"spam\"). Write a program to print the words in the tuple sorted alphabetically.\n- Using the built-in function"
            },
            {
                "text": " [A-Za-z0-9.-_\\s]\"\n\nSection 4: Password Protection\n\nThe Python RegEx library is a great tool for password protection. It can verify if a given password has the required characteristics, such as length"
            },
            {
                "text": " (This is left up to the user to test and match the RegEx into a string)\n[^\\p{Proper}\\p{Punct}a-z\\p{Punct}]+\n\nExercise 2:\n\nCreate"
            },
            {
                "text": " \n(?=^[a-zA-Z0-9 ]+$)(?=^\\S+$) \n\n3. Extract phone numbers from a paragraph of text. Include both area codes (5 or 6) with"
            },
            {
                "text": "\n```python\nimport re\n\ndescription = \"Website Users\"\n\n# A RegEx pattern to match the title\ntitle_pattern = re.search(r\"^\\w+(?:\\s+\\w+)+$\", description"
            }
        ]
    },
    {
        "expression": "^\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?$|^\\(\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?\\)$|^(\\$)?(-)?([0]|([1-9]\\d{0,6}))([.]\\d{1,2})?$",
        "raw_prompt": "Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05",
        "refined_prompt": "Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05\nMatch examples:\n- \"($1,234,567.89)\"\n- \"$1,234,567.89\"\n- \"$1234567.89\"\nNon-match examples:\n- \"$1,234,567.890\"\n- \"$12345678.90\"",
        "matches": [
            "($1,234,567.89)",
            "$1,234,567.89",
            "$1234567.89",
            "$-1234567.89",
            "$0.78",
            "$1,660,986",
            "$146.0",
            "($172,545)",
            "($4,546,599)",
            "54927.64",
            "$-59355",
            "-853119",
            "$-18.3"
        ],
        "non_matches": [
            "$1,234,567.890",
            "$12345678.90",
            "$023,456.78",
            "$824.4234234",
            "$4232342.3423.423",
            "$424.234234",
            "-312f23",
            "90u09u09",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1314,
        "output": [
            {
                "text": "\n"
            },
            {
                "text": "\n"
            },
            {
                "text": " The"
            },
            {
                "text": " ("
            },
            {
                "text": " (\""
            },
            {
                "text": " (\""
            },
            {
                "text": "\n"
            },
            {
                "text": " No"
            },
            {
                "text": " This"
            },
            {
                "text": " "
            }
        ]
    },
    {
        "expression": "^(((\\(\\d{3}\\)|\\d{3})( |-|\\.))|(\\(\\d{3}\\)|\\d{3}))?\\d{3}( |-|\\.)?\\d{4}(( |-|\\.)?([Ee]xt|[Xx])[.]?( |-|\\.)?\\d{4})?$",
        "raw_prompt": "with or without area code (of various forms)(does not allow for unbalanced parens in the area code). With or without an extension (of various forms). Does not allow for leading or trailing space.",
        "refined_prompt": "with or without area code (of various forms)(does not allow for unbalanced parens in the area code). With or without an extension (of various forms). Does not allow for leading or trailing space.\nMatch examples:\n- \"(123)-456-7890 Ext 1234\"\n- \"123-456-7890\"\n- \"(123).456.7890\"\nNon-match examples:\n- \"123)4567890\"\n- \"800callcat\"",
        "matches": [
            "(123)-456-7890 Ext 1234",
            "123-456-7890",
            "(123).456.7890",
            "123.456.7890",
            "1234567890ext1234",
            "123-456 7890 X 1234",
            "921.9170733",
            "570-5322061",
            "885.0096",
            "(102)8703702x1308",
            "8577364735",
            "840.5595",
            "963.4797"
        ],
        "non_matches": [
            "123)4567890",
            "800callcat",
            "123456789",
            "afdsaf.adijs",
            "4.23.2423",
            "$23.454",
            "43-5432",
            "2546dgwre",
            "245/524/12",
            "com.edu.github",
            "(0xx12) 62509@",
            "0j0jweBBBB"
        ],
        "id": 1317,
        "output": [
            {
                "text": "\n-\\d{3}\\.\\d{3}"
            },
            {
                "text": " \"([\\-\\d])(\\d{3})("
            },
            {
                "text": " /(?=\\s)([A-Za-"
            },
            {
                "text": "\n\\b[0-9]{3}\\.[0"
            },
            {
                "text": " \\d{3}-\\d{3}-\\"
            },
            {
                "text": " (\\d{3}\\.){3}\\d{3"
            },
            {
                "text": " /^\\d{3}[.-](?:(\\s"
            },
            {
                "text": " (\\d{3}-\\d{3})\\."
            },
            {
                "text": " (?<=\\\\d)(?=\\\\.)\\\\s"
            },
            {
                "text": " (123\\d {4} (\\d\\d\\"
            }
        ]
    },
    {
        "expression": "^(\\d{4})[.](0{0,1}[1-9]|1[012])[.](0{0,1}[1-9]|[12][0-9]|3[01])[.](\\d{2})$",
        "raw_prompt": "capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99",
        "refined_prompt": "capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99\nMatch examples:\n- \"2006.10.09.05\"\n- \"1672.08.31.93\"\n- \"0081.12.30.60\"\nNon-match examples:\n- \"06.13.32.123\"\n- \"52/2/54/245\"",
        "matches": [
            "2006.10.09.05",
            "1672.08.31.93",
            "0081.12.30.60",
            "0042.12.30.94",
            "9297.2.25.15",
            "6833.12.31.21",
            "7766.10.28.39",
            "4714.12.17.10",
            "8849.08.31.60",
            "8036.10.25.94",
            "4157.10.7.78",
            "9477.08.30.96",
            "6917.10.03.26"
        ],
        "non_matches": [
            "06.13.32.123",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "1-1-2",
            "34.31",
            "3409fjg43"
        ],
        "id": 1326,
        "output": [
            {
                "text": " ^[0-9]{2}\\/[0-9]{2}\\/[0-9"
            },
            {
                "text": ".{3}\n- \"06a13t32a30a6b\"Generate a RegEx"
            },
            {
                "text": " \"^[0-9]{4}-[1-9][0-9]{2}/"
            },
            {
                "text": " yyyy.mm.dd.nn\n\nNow let's apply the knowledge of RegEx and the concepts"
            },
            {
                "text": " (.*)\\/(\\d{2}\\/\\d{2}\\/\\d{2})\\.?"
            },
            {
                "text": " '([\\d.\\:]+).*' means \"match at least one digit, any dot, any"
            },
            {
                "text": "  \\d{2}[\\d]{2}[\\d]\\d[\\d]"
            },
            {
                "text": " ^0*([1-2][0-9])\\/([0-9][1-9])\\/"
            },
            {
                "text": " yyyymmddnnn\n\nA:\n\nI would use (00?)[0-9]+"
            },
            {
                "text": " ^.*?(?:\\d+)$\n\n1) [0-9]+\n\nExample:\n"
            }
        ]
    },
    {
        "expression": "^\\$?\\d{1,3}(,?\\d{3})*(\\.\\d{1,2})?$",
        "raw_prompt": "Just a small pattern to make sure commas are in the rite place (if present). Only allows one decimal to be suffixed with with 1 or 2 digits. Also optional dollar sign may proceed value.",
        "refined_prompt": "Just a small pattern to make sure commas are in the right place (if present). Only allows one decimal to be suffixed with with 1 or 2 digits. Also optional dollar sign may proceed value.\nMatch examples:\n- \"$1,000,000.00\"\n- \"123,000\"\n- \"455,123\"\nNon-match examples:\n- \"43,3.245\"\n- \"423,423,4,234,234\"",
        "matches": [
            "$1,000,000.00",
            "123,000",
            "455,123",
            "845,312,414",
            "12",
            "8",
            "7",
            "648.27",
            "5",
            "9",
            "4",
            "210",
            "764"
        ],
        "non_matches": [
            "43,3.245",
            "423,423,4,234,234",
            "423,4,23,424,,24",
            "7,567,9,8",
            ",563,5,8,7,252",
            "534,63.56,363",
            "5,34.74,46.345",
            ",534.5475,.34,",
            ".6445,3.845.,5",
            ".53,63.6,3.635",
            ",5347,.96,25,",
            "354,67.43634"
        ],
        "id": 1333,
        "output": [
            {
                "text": " - \\d+,\\d+,\\d+,\n\nA:\n\nIf"
            },
            {
                "text": " ( (?<!dollar).{0,12} \\d,(?"
            },
            {
                "text": " ([\\w.-]+(?=,(?:\\d{3})+("
            },
            {
                "text": " \\d{0,2}[,.]\\d{0,2}"
            },
            {
                "text": " I know the regex will be \\$(?:[1-9]\\d"
            },
            {
                "text": " \"^[0-9,0-9\\.]*$\"\n-"
            },
            {
                "text": " ^[1-9][0-8]|1[012][0-"
            },
            {
                "text": "\n^\\$\\d([,\\d.]+|[,.]|"
            },
            {
                "text": "\n\"\\d{0,4},\\d{1,3},\\"
            },
            {
                "text": " (https://regex101.com/r/aP8yR0"
            }
        ]
    },
    {
        "expression": "^[0-3][0-9][0-1]\\d{3}-\\d{4}?",
        "raw_prompt": "This regex performs a crude test on the given input string.\nThe danish cilvil registration number consists of 10 numeric characters and one special character '-'. The format is DDMMYY-XXXX.",
        "refined_prompt": "This regex performs a crude test on the given input string.\r\nThe danish cilvil registration number consists of 10 numeric characters and one special character '-'. The format is DDMMYY-XXXX.\nMatch examples:\n- \"010380-2343\"\n- \"120454-5467\"\n- \"390178-3434\"\nNon-match examples:\n- \"1223876776\"\n- \"4023100923\"",
        "matches": [
            "010380-2343",
            "120454-5467",
            "390178-3434",
            "021535-6554",
            "171865-8670",
            "121002-8304",
            "201468-3622",
            "090642-3583",
            "221117-6041",
            "121786-6120",
            "390554-9695",
            "041194-8781",
            "050057-8654"
        ],
        "non_matches": [
            "1223876776",
            "4023100923",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1334,
        "output": [
            {
                "text": "\n- ^(?=.{8}$)(?=(."
            },
            {
                "text": " \n\n^[\\d-]+$\n\nA:\n"
            },
            {
                "text": " '([a-z]*)', where this character class describes one to"
            },
            {
                "text": " 1) (?:.*\\b(\\d{1,2})["
            },
            {
                "text": "\n- (?:\\d{2}[\\d][\\d"
            },
            {
                "text": " \\d{2}{1-9}\\d{6}(?"
            },
            {
                "text": " [0010-A]-[0012-9]\nGeneration"
            },
            {
                "text": " https://regex101.com/r/F3U4z"
            },
            {
                "text": " (10 alphanumeric characters and a dash) + (1 alphan"
            },
            {
                "text": " ([0-9]{3})--[0-9]{"
            }
        ]
    },
    {
        "expression": "^M{0,1}T{0,1}W{0,1}(TH){0,1}F{0,1}S{0,1}(SU){0,1}$",
        "raw_prompt": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' . Only one instance of these set of letters is accepted.",
        "refined_prompt": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' . Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"",
        "matches": [
            "MWF",
            "TTHS",
            "MT",
            "WFS",
            "MFSU",
            "TH",
            "MTTHFS",
            "MWTHFSU",
            "MTTHSSU",
            "TFSU",
            "MWSU",
            "TWF",
            "THFSU"
        ],
        "non_matches": [
            "MM",
            "WM",
            "FTH",
            "SM",
            "9ijn",
            "3nf@",
            "43-5432",
            "90u09u09",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1356,
        "output": [
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description. "
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description. The"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            }
        ]
    },
    {
        "expression": "^(([0][0-9]|[1][0-2])|[0-9]):([0-5][0-9])( *)((AM|PM)|(A|P))$",
        "raw_prompt": "Matches a string if it is a valid time in the format of \"HH:MM AM\" or \"HH:MM A\".",
        "refined_prompt": "matches time in both 12-hour and 24-hour formats, capturing hours, minutes, and an optional space followed by \"AM,\" \"PM,\" \"A,\" or \"P.\"\nMatch examples:\n- \"1:30 AM\"\n- \"01:20 AM\"\n- \"10:00A\"\nNon-match examples:\n- \"13:00 A\"\n- \"01:5 AM\"",
        "matches": [
            "1:30 AM",
            "01:20 AM",
            "10:00A",
            "11:50P",
            "01:45 AM",
            "12:00 PM",
            "03:30AM",
            "8:15 PM",
            "5:05AM",
            "11:59 PM",
            "09:00 AM",
            "1:10 PM",
            "02:45AM"
        ],
        "non_matches": [
            "13:00 A",
            "01:5 AM",
            "09:00 AB",
            "1:1 AM",
            "9:75 PM",
            "15:15 AM",
            "12:60 AM",
            "07:00 BM",
            "60:25 AM",
            "04:60 PM",
            "3:50 XM",
            "8h98009hu"
        ],
        "id": 1357,
        "output": [
            {
                "text": " \n(\\d{1,2}):(\\d{2})\\s?(AM|PM|AM|PM)?"
            },
            {
                "text": " \n(\\d:\\d{2}[AP])?(\\s(am|pm))?\n\nExercise 2:"
            },
            {
                "text": " r'(1\\.\\d\\d|\\d\\.\\d|\\d\\d)\\s1\\.\\d\\"
            },
            {
                "text": " \"(?i)\\d?\\d(:(?<hour>0[1-9]|1[0-2])"
            },
            {
                "text": " This exercise should lead to the pattern '\\d+:\\d\\dAM|\\d+:\\d\\dPM'|"
            },
            {
                "text": "\n```\nmatch_time1 = r\"(\\d\\d) (\\d\\d){1}\\s([AP"
            },
            {
                "text": " RegEx for start of time pattern\n\nExercise 2: \n- Write a regular expression to match all dates provided in various"
            },
            {
                "text": " \nMySQL_REGEX_TIME_PATTERN_FEMALE_A_NUMBER_MULTI_"
            },
            {
                "text": " (\\d+):(\\d{1,2}|2[0-3]):(\\d{1,2})"
            },
            {
                "text": " \"(0-9)(1:|2:)(0-9) \"\n\n3. Generate a pattern that matches dates"
            }
        ]
    },
    {
        "expression": "^-?\\d+(\\.\\d+)?$",
        "raw_prompt": "Matches any unsigned or signed floating point number/numeric string.",
        "refined_prompt": "Matches any unsigned or signed floating point number/numeric string.\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \"-1.2\"\nNon-match examples:\n- \"abc\"\n- \"3.4.2\"",
        "matches": [
            "123",
            "3.14159",
            "-1.2",
            "7865",
            "75",
            "8646",
            "847",
            "35",
            "478",
            "69.524",
            "57845",
            "74",
            "78.54"
        ],
        "non_matches": [
            "abc",
            "3.4.2",
            ".234",
            "-123f",
            "4.23.2423",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1362,
        "output": [
            {
                "text": " \"^[\\s\\S]*$|[^\\d\\s]+$\"\n- \"1\" matches \"1\", but does not match \"ab1c\"\n- The pattern should match strings with exactly one occurrence of a dot, not anywhere in the"
            },
            {
                "text": " 123 or 3.141590\n\n2. Write the code for the following RegEx\nAnswer: (\\d+\\.\\d+)|(\\d+)\\.\\d+|\\-\\d+\\.\\d+\n\n3. Match any date in this format"
            },
            {
                "text": " \\b0*([13.]|[-]|[0-9]+)\\b\nI am using Python 3.5.4 and need exact match but still need to deal with negative floating points\n\nA:\n\nTo test floats with regex, you can try"
            },
            {
                "text": "\n-\\d\\d.\\d*\n-^[\\d+.-]*$\n\n(4) Match (n+2) terms.\n[a-zA-Z].(.)[a-zA-Z]\\1[a"
            },
            {
                "text": " \n- \"^(?i)\\b(?:\\d+.?\\d*|[-+]?\\d+\\.\\d+)(?:[eE][-+]?\\d+)$\"\nI hope you found this explanation helpful. If you have"
            },
            {
                "text": " Matches any signed floating point number or numeric string, including fraction.\n\n2. To generate a RegEx, we can use the following syntax:\n```python\nimport re\n\nstring = \"123,45.67,89.90\"\npattern = \"\\"
            },
            {
                "text": " (?P<floats>\\+|-|\\.|\\*|\\/)[0-9]+[0-9]+(:[0-9]+)+(\\.\\d+)+[0-9]*\n- \"abcde\"\n- \"3:"
            },
            {
                "text": " [-+]?\\d+(\\.\\d+)?\nUsing the example below:\nint n;\nstring s;\nscanf(\"%d\",&n);\ns = \"3.14159\";\n\nint matchNumber(const char *str)\n"
            },
            {
                "text": " To match numbers (decimal or integer), you can use the following RegEx: [0-9]+. If you want to allow for a specified range of numbers (e.g. 0-19, -40-79), you can use [0-9]{"
            },
            {
                "text": "\n[^,0-9.\\-]+[^,0-9.\\-]+[^,0-9.\\-]+\n\nQ:\n\nJavaScript - Find array value by key\n\nI am new to JavaScript/Python.  I hope that anyone"
            }
        ]
    },
    {
        "expression": "^(?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))$",
        "raw_prompt": "Just a simple US State regex. Requires valid 2 letter abbreviations.",
        "refined_prompt": "Just a simple US State regex. Requires valid 2 letter abbreviations.\nMatch examples:\n- \"CO\"\n- \"GA\"\n- \"TX\"\nNon-match examples:\n- \"A\"\n- \"ZZ\"",
        "matches": [
            "CO",
            "GA",
            "TX",
            "HI",
            "OR",
            "KS",
            "FL",
            "HI",
            "CT",
            "DC",
            "IA",
            "LA",
            "MD"
        ],
        "non_matches": [
            "A",
            "ZZ",
            "Florida",
            "(12) 324 653210",
            "9ijn",
            "3nf@",
            "-312",
            "notre dame",
            "u09nKLJG FSL",
            "354/243/542",
            "dfg",
            "32542 //"
        ],
        "id": 1372,
        "output": [
            {
                "text": "\n^(ABCD|PQRS|TUV)([A-Z]){1,2}$. (Takes into account a mix of upper and lower case letters).\n\nA:\n\n^[0-9]{1,9}[A-Z}{A-Z]{"
            },
            {
                "text": "\n[A-Z]\\w\nA character that is greater than zero, a, A, or Z. The word \"a\" or \"ZZ\" are characters that are defined as alphanumeric characters, i.e. any single character in the characters set - [a-zA-Z0-9"
            },
            {
                "text": " (?:(?<letter>[AB]{2})(?<abbreviation>[IL]{2}))\n\nA:\n\nYou can probably use a regular expression to parse the address, but this is a fairly cheap way to do it without regex.\nFirst, get some data from the form,"
            },
            {
                "text": " CO[ABR]0[0-9] or (CO[ABR])0[^0-9]\n\"\"\"\nimport re \nimport numpy as np\ncharList = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ncharList2 = 'BCDEF"
            },
            {
                "text": " \"^(MIL|CGS|CGS|TMS|CGS|GAP|EQU|EQU|EQU|EQU|EQU|EQU|GAP|GAP|GAP|GAP|EQU|MIL|GAP|GAP|GAP|"
            },
            {
                "text": "\n(?i)(?:^[A-Z]{2}|.*[A-Z].*)\nQ:\n\nUsing the result of str.split()\n\nI have a list of strings like:\n['1/4', '1/5', '1/6,' '1/"
            },
            {
                "text": " [A-Za-z]\\1\nGenerate a list of all valid US State abbrevs using this regex. It should also be possible to limit it to any length, but for now let's assume 5 characters.\n\n//Code\nconst stateAbbrevs = [\r\n  \"NY\",\r"
            },
            {
                "text": " I can use something like: [A-Za-z{1,2}]*$\n\nA:\n\nTry:\n[a-z]{1,2}\n\nIt should be one uppercase and one lowercase\nYou might add \\d afterwards if you want numbers\nExample"
            },
            {
                "text": " ([0-9]?[A-Z]?)|[A-Z]\n\nA:\n\nAs of 2011, this is a well known pattern, but I can't remember what the name is. It can be very specific in what you want to match.\n[ACG]{1,3"
            },
            {
                "text": " [a-z]+$\n\nExample: https://regex101.com/r/dQ4Uj7/2\n\"\"\"\n\n# Match any 2-letter words starting with a capital letter:\nvalid_regex = r\"\\b[A-Z][a-z]{1"
            }
        ]
    },
    {
        "expression": "(?:(?:(?:04|06|09|11)\\/(?:(?:[012][0-9])|30))|(?:(?:(?:0[135789])|(?:1[02]))\\/(?:(?:[012][0-9])|30|31))|(?:02\\/(?:[012][0-9])))\\/(?:19|20|21)[0-9][0-9]",
        "raw_prompt": "Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199.",
        "refined_prompt": "Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199.\nMatch examples:\n- \"02/21/1972\"\n- \"12/31/2199\"\n- \"09/04/1901\"\nNon-match examples:\n- \"02/31/1999\"\n- \"02-21-1972\"",
        "matches": [
            "02/21/1972",
            "12/31/2199",
            "09/04/1901",
            "11/30/1914",
            "04/30/1955",
            "09/31/1943",
            "02/07/2123",
            "10/03/2100",
            "10/19/2179",
            "10/30/1962",
            "02/20/1969",
            "02/27/1962",
            "04/12/2083"
        ],
        "non_matches": [
            "02/31/1999",
            "02-21-1972",
            "06/31/2001",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "notre dame",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1388,
        "output": [
            {
                "text": " \"^(1[0-3](0[1-9])|"
            },
            {
                "text": "\nre_match = re.findall(\"([1-9]\\"
            },
            {
                "text": "\n((2\\d\\d|0)\\d{2})\\/\\"
            },
            {
                "text": " (example)\n([a-z_]{1,2}\\s"
            },
            {
                "text": " \n[a-zA-Z0-9]{3}"
            },
            {
                "text": "\n\n[0-9]{3}/[0-9]"
            },
            {
                "text": " ^[0-9\\/\\-\\(\\) \\+\\,\\."
            },
            {
                "text": " (?[a-z]{8})\\D+(?P<"
            },
            {
                "text": " \\d,(0-31),\\d\n\nUse this code to"
            },
            {
                "text": " (?m)([1-2]\\d\\d)\\/("
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\.\\d{3}\\.\\d{3}[-][0-9kK]{1}$",
        "raw_prompt": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00e1 necesario validar su d\u00edgito verificador.",
        "refined_prompt": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00e1 necesario validar su d\u00edgito verificador.\nMatch examples:\n- \"12.025.365-6\"\n- \"5.698.124-k\"\n- \"7.999.647-K\"\nNon-match examples:\n- \"125.326.452-1\"\n- \"15.336.054-H\"",
        "matches": [
            "12.025.365-6",
            "5.698.124-k",
            "7.999.647-K",
            "2.358.268-2",
            "06.346.822-K",
            "23.104.146-4",
            "6.845.282-2",
            "4.293.999-K",
            "68.660.311-4",
            "7.023.409-8",
            "35.511.925-4",
            "21.484.004-k",
            "7.461.216-4"
        ],
        "non_matches": [
            "125.326.452-1",
            "15.336.054-H",
            "15254587k",
            "fasd@fds.fasd@",
            "234/423/5243",
            "there is a boy",
            "AAAAAAA",
            "notre dame",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1389,
        "output": [
            {
                "text": "\n# r"
            },
            {
                "text": " This string should"
            },
            {
                "text": " (00["
            },
            {
                "text": " \\d{"
            },
            {
                "text": " ([0-"
            },
            {
                "text": "\n.*?"
            },
            {
                "text": " The Regex"
            },
            {
                "text": " \\d+."
            },
            {
                "text": " [a-"
            },
            {
                "text": " \"[a-"
            }
        ]
    },
    {
        "expression": "\\d{2}[.]{1}\\d{2}[.]{1}[0-9A-Za-z]{1}",
        "raw_prompt": "This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004",
        "refined_prompt": "This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004\nMatch examples:\n- \"22.12.0\"\n- \"18.24.C\"\n- \"98.65.T\"\nNon-match examples:\n- \"22.12_D\"\n- \"12.56\"",
        "matches": [
            "22.12.0",
            "18.24.C",
            "98.65.T",
            "76.74.P",
            "62.08.L",
            "05.69.n",
            "01.90.x",
            "48.02.V",
            "38.20.0",
            "42.35.Z",
            "17.40.5",
            "28.68.P"
        ],
        "non_matches": [
            "22.12_D",
            "12.56",
            "1A.56.1",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "000-000",
            "354/243/542",
            "(0xx12) 62509@"
        ],
        "id": 1410,
        "output": [
            {
                "text": " '^(\\d\\.){3}([\\w]+)_?[\\w.]*$'\n\nWe have also added a \"?\" character to the non"
            },
            {
                "text": " Non-match examples are the ones that start with a number and followed by underscores.\n- \"23.00\"Generate a RegEx for this description. \nAnswer"
            },
            {
                "text": " \\d{1,2}.\\d{2}\\.\\d{3}\nExercise 3: Write a python script to extract the first five numbers from a string"
            },
            {
                "text": " ^((0?[1-9]|1[012])\\.){3}[0-9]{3}$\n\nExercise 4:\n\n"
            },
            {
                "text": " [A-Z]{3}[0-9]{1,2}\\.[0-9]{2}\\.[0-9]{1,3}"
            },
            {
                "text": " [A-Z0-9-]{4}[.][0-9]{2}\n\nExercise 2: Replace the below value and code block with"
            },
            {
                "text": "  (?<!\\d)^(?P<digit1>\\d)(?P<dots>\\.\\d{1,6})(?!\\"
            },
            {
                "text": "\n\\d{1,6}\\.\\d\\d\\.T|\\d{4}\\.\\d\\d\\.T|\\d{3}(?"
            },
            {
                "text": "\n((01)/)(\\d{2}\\.\\d{2}).*(?:(?:00)\\d{2})?\n\nExercise 4:\n"
            },
            {
                "text": " \n\nimport re\n\n# Regular Expression Pattern that match Istat Ateco Code updated to Istat Declaration Ateco 2004\npattern = r'^22["
            }
        ]
    },
    {
        "expression": "IT\\d{2}[ ][a-zA-Z]\\d{3}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{3}|IT\\d{2}[a-zA-Z]\\d{22}",
        "raw_prompt": "International Bank Account Number (IBAN) Italian. Identify Bank account in Italy.",
        "refined_prompt": "International Bank Account Number (IBAN) Italian. Identify Bank account in Italy.\nMatch examples:\n- \"IT28 W800 0000 2921 0064 5211 151\"\n- \"IT28W8000000292100645211151\"\n- \"IT47r6150582949310134977462\"\nNon-match examples:\n- \"IT28-W800-0000-2921-0064-5211-151\"\n- \"52/2/54/245\"",
        "matches": [
            "IT28 W800 0000 2921 0064 5211 151",
            "IT28W8000000292100645211151",
            "IT47r6150582949310134977462",
            "IT50u4563415448490981947813",
            "IT45q3314391860255535018247",
            "IT66q2029117404871419554111",
            "IT62M7475226742656801338781",
            "IT08X8257033707588935025587",
            "IT17 B623 6010 0263 0308 1745 060",
            "IT41y2666346576666598173469",
            "IT74 t088 4777 7816 7371 3544 052",
            "IT22 u440 3355 3011 3390 9980 399",
            "IT35 G884 5647 9598 6037 6739 043"
        ],
        "non_matches": [
            "IT28-W800-0000-2921-0064-5211-151",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "there is a boy",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "com.edu.github",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1411,
        "output": [
            {
                "text": " /([1-9]\\"
            },
            {
                "text": " \"[a-zA-z"
            },
            {
                "text": " \n- \"\\d [\\"
            },
            {
                "text": " It should match any bank account in"
            },
            {
                "text": " (52/2/54/"
            },
            {
                "text": " (\"^W800[1-"
            },
            {
                "text": " [IT28W-]\\"
            },
            {
                "text": " ^IT([0-9]"
            },
            {
                "text": "\n- \"^IT28 W"
            },
            {
                "text": " IT4[0-9]"
            }
        ]
    },
    {
        "expression": "(^4\\d{12}$)|(^4[0-8]\\d{14}$)|(^(49)[^013]\\d{13}$)|(^(49030)[0-1]\\d{10}$)|(^(49033)[0-4]\\d{10}$)|(^(49110)[^12]\\d{10}$)|(^(49117)[0-3]\\d{10}$)|(^(49118)[^0-2]\\d{10}$)|(^(493)[^6]\\d{12}$)",
        "raw_prompt": "Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta. Safe for international and will NOT match \"^(49)\" Switch debit cards.",
        "refined_prompt": "Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta. Safe for international and will NOT match \"^(49)\" Switch debit cards.\nMatch examples:\n- \"4111111111111111\"\n- \"4903302261507834\"\n- \"4467220202996\"\nNon-match examples:\n- \"4903020000000008\"\n- \"52/2/54/245\"",
        "matches": [
            "4111111111111111",
            "4903302261507834",
            "4467220202996",
            "49110)1235196213",
            "4903017255950095",
            "493Q756879644542",
            "4911709979024881",
            "4911724535180908",
            "49110u9577293921",
            "4903308308396935",
            "4459227852002739",
            "493L044079768559",
            "4903309339220364"
        ],
        "non_matches": [
            "4903020000000008",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1414,
        "output": [
            {
                "text": " \"^[4]\\d{9}("
            },
            {
                "text": "\n\\b(4[5-9]\\"
            },
            {
                "text": " (^(?:5[0-9]{"
            },
            {
                "text": " (4444)+ (49)? \n\nCongratulations"
            },
            {
                "text": " 4(1|2|3). 0(0"
            },
            {
                "text": " \"(49[0-9]{9})-"
            },
            {
                "text": "\n\\d{4,15}[\\s"
            },
            {
                "text": " The correct pattern to use is \"^(49)("
            },
            {
                "text": "\n/(?=.*[5-4\\3"
            },
            {
                "text": " [0-9]{5}-[0-"
            }
        ]
    },
    {
        "expression": "(^(5[0678])\\d{11,18}$)|(^(6[^05])\\d{11,18}$)|(^(601)[^1]\\d{9,16}$)|(^(6011)\\d{9,11}$)|(^(6011)\\d{13,16}$)|(^(65)\\d{11,13}$)|(^(65)\\d{15,18}$)|(^(49030)[2-9](\\d{10}$|\\d{12,13}$))|(^(49033)[5-9](\\d{10}$|\\d{12,13}$))|(^(49110)[1-2](\\d{10}$|\\d{12,13}$))|(^(49117)[4-9](\\d{10}$|\\d{12,13}$))|(^(49118)[0-2](\\d{10}$|\\d{12,13}$))|(^(4936)(\\d{12}$|\\d{14,15}$))",
        "raw_prompt": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.",
        "refined_prompt": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"",
        "matches": [
            "6334500000000003",
            "65787411526656",
            "6011273550429",
            "4911806694738239",
            "601170831788719484",
            "4936071095523185",
            "65213324135290730380",
            "6534390341823",
            "4911012277568333917",
            "6M903146540804017677",
            "6G748260985328737",
            "4903386469066177",
            "4903084055698099"
        ],
        "non_matches": [
            "6011000000000004",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1425,
        "output": [
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            }
        ]
    },
    {
        "expression": "^(97(8|9))?\\d{9}(\\d|X)$",
        "raw_prompt": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.",
        "refined_prompt": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.\nMatch examples:\n- \"0672317249\"\n- \"9780672317248\"\n- \"357392943X\"\nNon-match examples:\n- \"0-672-31724-9\"\n- \"5555555555555\"",
        "matches": [
            "0672317249",
            "9780672317248",
            "357392943X",
            "6548106745",
            "9781061071527",
            "9793849883344",
            "9792371728730",
            "9780578739633",
            "803592955X",
            "9947182241",
            "9795633078285",
            "9782710478725",
            "738696527X"
        ],
        "non_matches": [
            "0-672-31724-9",
            "5555555555555",
            "2534/52435234/2453",
            "afdsaf.adijs",
            "9ijn",
            "$23.454",
            "AAAAAAA",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1428,
        "output": [
            {
                "text": " \"^[0-9]\\d{12}$\" Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with either"
            },
            {
                "text": " ([0-4][0-9]{3}.[0-9]{3}[0-9]{4})(00|11"
            },
            {
                "text": "\n[0-9]\\d{9}-([0-9]\\d){3}x[0-9]\\d{2"
            },
            {
                "text": " [\\dX]{5}\\d{2}\n\nExercise 5:\nWrite a Python script that accepts a user's email address and valid"
            },
            {
                "text": " \nExample ISBN 13 numbers, as of Sept 2017:\n0672317249(1).\nExample ISBN 10 numbers, as of Sept 2017:"
            },
            {
                "text": " \\d{1}[\\(\\)\\-\\d]\\d{4}\\d\\d, which matches an ISBN number ending with a comma and"
            },
            {
                "text": " \\d(?:[8-9]\\d?){3}-\\d{4}-\\d{4}-\\d{4"
            },
            {
                "text": " The pattern is [0-9][0-9] [0-9]{4}([.-] [0-9]{4})+"
            },
            {
                "text": " (\\d{3}[a-z])|(\\d{3}[a-z]\\d{3})|(\\d{4"
            },
            {
                "text": " \nRegEx for Acceptable ISBNs:   \\d{9}(?=.)\\d{9}\\d{4}\\d{4"
            }
        ]
    },
    {
        "expression": "^[\\w]{1,}$",
        "raw_prompt": "alphanumeric - no space allowed - requires at least one character",
        "refined_prompt": "alphanumeric - no space allowed - requires at least one character\nMatch examples:\n- \"a123b\"\n- \"56\"\n- \"d6\"\nNon-match examples:\n- \"a 1\"\n- \"52/2/54/245\"",
        "matches": [
            "a123b",
            "56",
            "d6",
            "56y",
            "d57",
            "g98g",
            "5r45",
            "43",
            "r6y98",
            "t545er67t8y",
            "u87",
            "y7uhf5",
            "f43vt33"
        ],
        "non_matches": [
            "a 1",
            "52/2/54/245",
            "-243fewdE#@",
            "(12) 324 653210",
            "ft f6 f",
            "f5 f5",
            "f5 g78yu&^YU",
            "f yvuv76y",
            "5f5tf76f i",
            "7 gyu",
            "6iy#@E",
            "#@EQW"
        ],
        "id": 1439,
        "output": [
            {
                "text": " \\d+\\.?\\d*\n\n\n\n\n# Table of Contents\n1. Introduction to Pandas\n2. Creating DataFrames\n3. Data Manipulation with Pandas\n4. Case Study: Analysis of Climate Data using Pandas\n5. Exerc"
            },
            {
                "text": " a1-123b\n3. How would you write the above expression to ensure that every group contains at least one character? \nAnswer: a1[0-9a-z]+, a2[0-9a-z]+, a3[0-"
            },
            {
                "text": "\nThe possible matches are \"a\" or \"1\" or \"52\" or \"245\". \nThe possible non matches are \"a space\" or \" \" or \"/\" or \"a \" or \"a/\". \n\"\"\"\n\n# The following RegEx will"
            },
            {
                "text": " \\d+\\/[a-zA-Z]\\/\\d+\n\nExercise 2: Write a Python function that uses regular expressions to check whether an email address is valid: \nAnswer: def is_valid_email(email_address):\n    re"
            },
            {
                "text": " \"[0-9\\]/[/:]\"[0-9\\]\"]\"\n\n4. Generate a RegEx to extract all phone numbers in the following string:\n\"Please call or email us at (123) 456-7890 or support@website"
            },
            {
                "text": " /[A-9]|[a-z]|[A-Z]|[0-9]|[\\+]|[\\/]|[\\-\\+]*$/\n  Valid inputs: a123b, 56, d6, a"
            },
            {
                "text": " ^(#[a-zA-Z0-9]+(/[a-zA-Z0-9]*)*\\/)([a-zA-Z0-9]+$)\n\n2. Write a Python function to remove all non-"
            },
            {
                "text": " [a]\\d{1,2}\\b[a-zA-Z/]{1,3}[^a-zA-Z/\\s]\n- [a]\\d{5}[b-f]\\d{1}"
            },
            {
                "text": " /^\\d+[-\\w]+$/\n\n```python\nimport re\n\n# Define function\ndef clean_data():\n    # Clean email format\n    emails = [\"abc@example.com\", \"test.com\", \"-hi"
            },
            {
                "text": " (Regex)  [\\d-]+[/()]\n\nExercise 5:\nMatch examples:\n- \"Hello, World!\"\n- \"The quick brown fox jumps over the lazy dog\"\n- \"The 3 quick brown foxes jumped over 8 lazy dogs"
            }
        ]
    },
    {
        "expression": "(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.)|(^127\\.0\\.0\\.1)",
        "raw_prompt": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. ***Importnat*** This pattern assumes that the input is a valid IP address. You many need to make sure the input is a valid IP address.",
        "refined_prompt": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"",
        "matches": [
            "10.12.0.19",
            "172.21.0.23",
            "192.168.0.2",
            "10.0.0.1",
            "172.16.0.1",
            "172.17.0.2",
            "172.30.1.3",
            "192.168.1.1",
            "127.0.0.1",
            "10.10.10.10",
            "172.16.255.255",
            "172.31.0.0",
            "192.168.0.100"
        ],
        "non_matches": [
            "222.12.3.24",
            "172.12.0.12",
            "2534/52435234/2453",
            "234.234.24.2.423",
            "42.342.3.524.23.",
            "543.25.453..2",
            "5..53..75.35.5.3.53.",
            "534.345.6.4.643",
            "5.34.37.5.23.",
            ".788..7462..543",
            "354.56.56.8.",
            "45.4.67.4435"
        ],
        "id": 1449,
        "output": [
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this list"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this problem"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this."
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this kind"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            }
        ]
    },
    {
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]?|[A-Z]{2}\\d[A-Z\\d]?)[ ]??(\\d[A-Z]{0,2})??$",
        "raw_prompt": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case.",
        "refined_prompt": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case.\nMatch examples:\n- \"W1A1AB\"\n- \"GIR0L\"\n- \"GIR2KU\"\nNon-match examples:\n- \"WWW1AB\"\n- \"c:\\f34fvfv\"",
        "matches": [
            "W1A1AB",
            "GIR0L",
            "GIR2KU",
            "K3",
            "M7",
            "SW0",
            "GIR9M",
            "N1M",
            "GIR",
            "PR7",
            "GIR",
            "UF1L",
            "AO8"
        ],
        "non_matches": [
            "WWW1AB",
            "c:\\f34fvfv",
            "53495083409x",
            "afdsaf.adijsTFVG",
            "DRTFC",
            "DRTCF",
            "TRCF6F",
            "T",
            "7FT87G8",
            "5f8yg",
            "6f7ui7",
            "d67"
        ],
        "id": 1457,
        "output": [
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space after"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space before"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space to"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)."
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space after"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space above"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space),"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)."
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space in"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space),"
            }
        ]
    },
    {
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]??|[A-Z]{2}\\d[A-Z\\d]??)[ ]??(\\d[A-Z]{2})$",
        "raw_prompt": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)",
        "refined_prompt": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\"\n- \"c:\\f34fvfv\"",
        "matches": [
            "GIR0AA",
            "SV85 9SV",
            "T0J 4XZ",
            "U76VA",
            "GIR 6JN",
            "GIR 3XP",
            "GIR 4NS",
            "LX86SU",
            "VU47TU",
            "GIR 1QH",
            "IG9H4AY",
            "F2Q1PS",
            "KD36CL"
        ],
        "non_matches": [
            "WWW1AB",
            "c:\\f34fvfv",
            "-243",
            "afdsaf.adijs",
            "9ijn",
            "3nf@",
            "43-5432",
            "254627g.256",
            "u09nKLJG FSL",
            "354/243/542",
            "abc111def",
            "8h98009hu"
        ],
        "id": 1458,
        "output": [
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB1"
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB7"
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1ABBA"
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB1"
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            }
        ]
    },
    {
        "expression": "^[0-9]+[NnSs] [0-9]+[WwEe]$",
        "raw_prompt": "This tests, are entered AW coordinates in correct short format, and it has no world info",
        "refined_prompt": "match coordinate pairs in the format of latitude (North/South) followed by longitude (West/East), where both latitude and longitude are represented by numbers.\nMatch examples:\n- \"0N 0W\"\n- \"34N 118W\"\n- \"0s 0e\"\nNon-match examples:\n- \"aw 0N 0W\"\n- \"12345\"",
        "matches": [
            "0N 0W",
            "34N 118W",
            "0s 0e",
            "42n 73w",
            "90S 180E",
            "1n 1w",
            "60S 45E",
            "23n 56w",
            "75s 30e",
            "80N 90W",
            "45s 0e",
            "12n 34w",
            "50S 100E"
        ],
        "non_matches": [
            "aw 0N 0W",
            "12345",
            "N45 W90r",
            "afdsaf.adijs",
            "45N 90E 180W",
            "12n 45w E",
            "60N 45E, 23S 56W",
            "North 12 West 34",
            "50S 100E 200W",
            "N15 E20",
            "sda sad",
            "32542"
        ],
        "id": 1466,
        "output": [
            {
                "text": " \\b(\\w+N)\\w+e\\b\n\nExercise 2: \nUsing the given RegEx pattern, find all the coordinates in the"
            },
            {
                "text": " \"^[0-9][ 0-9][0-9][0-9][0-9]$|^[1-6][ -]"
            },
            {
                "text": " ^(a|b)(\\d+)\\s(\\d+)\\s(\\d+)\\s(\\d+)$\nExplanation: (a|"
            },
            {
                "text": " You can write a RegEx pattern such as r\"(\\d+)\\s(\\d+)\\sd(\\d+)\\s(\\d+)\\sb(\\d"
            },
            {
                "text": ".+N:\\w+W|\\d\\d\\d\\d|w\\d\\d.*\n\nExercise 2: Match the following descriptions"
            },
            {
                "text": " To generate a RegEx for this descriptor, you would need to use the range operator to represent the latitude as a number from 0 to 90 degrees, and the range"
            },
            {
                "text": " a pattern of \"wE\" which means \"match longitude.\"\n\n\n\nQuestion 6: In a race, Sarah runs at an average speed of 8"
            },
            {
                "text": " ^\\(0\\.\\d+,0\\.\\d+,0\\.\\d+\\)W$.\n\nThese exercises should help reinforce your understanding of Python's"
            },
            {
                "text": " (\\d+[a-zA-Z])(\\d+[a-zA-Z])\n\nExercise 4:\nHow would"
            },
            {
                "text": " \"^[\\d\\s\\w-]+?[\\d\\s\\w-]+?:[a-zA-Z\\d_-]+"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Checks time in 24 hours notation, however this one is shorter than the ones I found on regexplib",
        "refined_prompt": "Checks time in 24 hours notation\nMatch examples:\n- \"23:00\"\n- \"12:21\"\n- \"0:00\"\nNon-match examples:\n- \"24:00\"\n- \"23:60\"",
        "matches": [
            "23:00",
            "12:21",
            "0:00",
            "07:21",
            "23:07",
            "4:53",
            "21:05",
            "8:33",
            "20:14",
            "23:53",
            "2:20",
            "20:42",
            "3:44"
        ],
        "non_matches": [
            "24:00",
            "23:60",
            "0:60",
            "-123",
            "234",
            "$23.454",
            "43-5432",
            "254627g.256",
            "000-000",
            "76:r4",
            "74:54",
            "86:34"
        ],
        "id": 1468,
        "output": [
            {
                "text": " ([A-Za-z]):[0-5][0-9]\nExplanation: The characters after [: are lowercase letters or uppercase letters, and the characters before [:] are numbers between 0 and 5. The [0-9] ensures that the number inside"
            },
            {
                "text": " A RegEx code would be [0-9], [0-5][0-9]:[0-5][0-9].[0-9]\n\nExercise 2:\nCheck the time in 24 hour notation: (Time is: 12:34)\nIs it within the acceptable"
            },
            {
                "text": " (^[1-9][0-9]:[0-5][0-9])|([0-9][0-9]:[0-5][0-9](:[0-5][0-9]))$ or ([0-1][0-9]:[0-"
            },
            {
                "text": " \"^\\d{2}:\\d{2}$|^\\d{6}$\"\n\n2. Using the Matches and Search Methods\nFor each example, generate a regular expression that uses the search method to find all occurrences of the description. \n\nMatches and other methods"
            },
            {
                "text": "\n- \"([0-9]|1[0-9]|2[0-3]):[0-5][0-9]\"\n\nExercise 2:\nWrite a `for` loop that replaces all the occurrences of any instance of a word that begins with a backtick ``"
            },
            {
                "text": " [a-zA-Z0-9]\\S*/\\S+:\\S*/(\\d+)\n\nExercise 2: Create a regular expression to validate a phone number string in 3 different formats. Note that the rules for each format could be different.\n\nSolution: A simple example solution"
            },
            {
                "text": " (2|1|0|[1-2]\\d|2[0-3]):[0-5]\\d\n\nExercise 2:\nReplace all non-matching characters in this given string with a specified character.\n\"Python Programming is cool, it really is"
            },
            {
                "text": " \n\n```python\nimport re\n\nreg_ex = None\n\ndef match_example(reg_ex = None):\n    return f'Match examples: {\"|\".join(match.group() for match in re.finditer(reg_ex, \"23:00 12"
            },
            {
                "text": " Non-match example: *any non-matching characters of the regular expression*\n- *If the regular expression contains capture groups, these will be evaluated as variables.*\n- *If the regular expression contains optional groups (those preceded by \"(\" or \"[\"), these must be evaluated using the parentheses to determine"
            },
            {
                "text": "\nimport re\n\n # Time in 24 hours notation\nt1 = \"20:45\"\n# The colon \":\" should be escaped\nt2 = \"20:45\"\n # The minute should be zero if there is no minute\nt3 = \"23:00\" # The colon should not"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]{1}/[0-3]?[0-9]{1}/20[0-9]{2})$",
        "raw_prompt": "This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year. :) I designed this expression to validate dates from the year 2000 to 2099. I do not plan on this same code being in place in 2099, so I hope this is sufficient enough...",
        "refined_prompt": "This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year.\nMatch examples:\n- \"2/14/2001\"\n- \"12/29/2099\"\n- \"19/39/2000\"\nNon-match examples:\n- \"12/29/1999\"\n- \"20/40/2100\"",
        "matches": [
            "2/14/2001",
            "12/29/2099",
            "19/39/2000",
            "4/5/2089",
            "8/27/2010",
            "11/7/2058",
            "6/12/2084",
            "13/24/2016",
            "7/18/2077",
            "6/5/2055",
            "16/03/2054",
            "2/14/2082",
            "03/2/2096"
        ],
        "non_matches": [
            "12/29/1999",
            "20/40/2100",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "897-",
            "34.31",
            "3409fjg43"
        ],
        "id": 1484,
        "output": [
            {
                "text": " \\"
            },
            {
                "text": " The"
            },
            {
                "text": " A"
            },
            {
                "text": " \"("
            },
            {
                "text": " This"
            },
            {
                "text": "\n"
            },
            {
                "text": " \""
            },
            {
                "text": "\n"
            },
            {
                "text": " ["
            },
            {
                "text": " Match"
            }
        ]
    },
    {
        "expression": "^\\d+\\*\\d+\\*\\d+$",
        "raw_prompt": "one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks.",
        "refined_prompt": "one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks.\nMatch examples:\n- \"123*4578*8908650\"\n- \"14*523*154\"\n- \"14*4*5432\"\nNon-match examples:\n- \"12a*99989*9096\"\n- \"52/2/5*4/82*45\"",
        "matches": [
            "123*4578*8908650",
            "14*523*154",
            "14*4*5432",
            "1*523*5432",
            "641*523*5432",
            "14*523*6544",
            "14*4351*5432",
            "14*3416*5432",
            "1463136*523*5432",
            "14*523*416",
            "8766*523*5432",
            "14*654*5432",
            "14*523*2346"
        ],
        "non_matches": [
            "12a*99989*9096",
            "52/2/5*4/82*45",
            "2534/52*4835234*/2453",
            "(12) 3*248 6*53210",
            "23*4/8423/5*243",
            "3n8*f@*",
            "43*-58432*",
            "2*54627g.2*68",
            "245/52*4/12",
            "354/*243/542",
            "(0xx12) 62*509@",
            "34*09fjg43"
        ],
        "id": 1485,
        "output": [
            {
                "text": " 12([a-c]{3})(\\d{3})+"
            },
            {
                "text": " (a or b or c, d or e or f, no letters or"
            },
            {
                "text": " [0-9]{3}/[0-9]{3"
            },
            {
                "text": " ^[a-z0-9]{1,10}[*"
            },
            {
                "text": "\n(([0-9]\\*)\\+([0-9]"
            },
            {
                "text": " \n^[1-9][0-9]*|[1"
            },
            {
                "text": " 1) abc*123, abc*12abc, abc*"
            },
            {
                "text": " Matching regex: ([0-9]*(?:\\*[0"
            },
            {
                "text": "\n\\d+(?:\\*\\d+)*\n\nExercise 2"
            },
            {
                "text": "\n/([0-9]+)/i\n\n\n\nTitle: The"
            }
        ]
    },
    {
        "expression": "^100(\\.0{0,2}?)?$|^\\d{0,2}(\\.\\d{0,2})?$",
        "raw_prompt": "Matches percentages from 0-100 inclusive with two decimal places.",
        "refined_prompt": "Matches percentages from 0-100 inclusive with two decimal places.\nMatch examples:\n- \"0\"\n- \"100\"\n- \"100.00\"\nNon-match examples:\n- \"101\"\n- \"-5\"",
        "matches": [
            "0",
            "100",
            "100.00",
            "45.45",
            "74",
            "86",
            "85",
            "35.35",
            "99",
            "65",
            "66.66",
            "44.46",
            "83.73"
        ],
        "non_matches": [
            "101",
            "-5",
            "45.456",
            "-123",
            "51:534",
            "$23.454",
            "43-5432",
            "1.12423",
            "9516-9516",
            "354/243/542",
            "34.3125",
            "32542"
        ],
        "id": 1489,
        "output": [
            {
                "text": " a. 0-10b. 101 or 0-100\n\nExercise 4: \nMatch each word with the correct term.\na. Decimal\nb. Percentage\nc. Fraction\n\nAnswers: a- Number that is written with a decimal point b- Value that ranges from 0%"
            },
            {
                "text": " \"^(0|[13579] \\d{0,2}?)(?:\\.00)?$\"\n\n### Exercise 5:\nUsing the RegEx generated for above exercise 4, write a Python function that receives a string and returns the total percentage of matches (including decimals).\nAnswer"
            },
            {
                "text": "\n\nimport re;\n\ndef generate_percent_regex():\n    return '^\\d+(\\.\\d{1,2})%$'\n\ndef get_percent_match(percent_string):\n    matches = re.findall(generate_percent_regex(),"
            },
            {
                "text": " \\d+([.\\d?eE][\\d?eE][.\\d?eE]?)\n\n\n- Use a RegEx pattern to match a phone number in the format of (123)-456-7890.\n  The first three digits should be exactly one group of numbers, and"
            },
            {
                "text": " \n\ndef percentage_regex(start, end, places):\n    return f\"^(?=.*?[0-9])(?=.*?[1])?(?=.*?[0-9].)([0-9]+)%{places}$\"\n\n"
            },
            {
                "text": " To match the string \"101\", I would use the pattern \"\\d{1,2}\". As for \"-5\", it wouldn't pass the pattern as it wouldn't be between numbers or a decimal point, therefore, I would use the pattern \"\\d+\\.\\d+\"?. The answer to the question would"
            },
            {
                "text": " [^\\d]|(0+)|(100+)|([1-9][0-9][0-9])\\.?(0?[1-9]?\\d|1[0-2])$\n\n---\n\nUse Case 2: Calculating a Recipe\nScenario:"
            },
            {
                "text": " [01^2|10^2|100^2].[0-9]\n\nI hope this instruction following has helped you better understand percentages and their representation in Python's RegEx. Remember to keep practicing and exploring the world of mathematics and computer science!\n\n\n\nIntroduction\n\nIn science, we"
            },
            {
                "text": " [^0-9.]\n\n- \"0.1\"\n- \"0.001\"\nMatch examples:\n- \"0.1\"\n- \"0.001\"\nNon-match examples:\n- \"0.2\"\n- \"-0.002\"\nGenerate a RegEx"
            },
            {
                "text": " (\\d{2})|((\\.\\d?%)\\d{2})|((-\\d+%))\"\"\"\n\nprint(f\"\"\"\\\nGenerated regex for description \"({re_description})\":\n\\{regex_description}\\.\"\"\"')\n```\n\n\n\n"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))\\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))\\/(\\d{4})$",
        "raw_prompt": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.\nMatch examples:\n- \"12/25/2007\"\n- \"11/07/1517\"\n- \"02/25/2727\"\nNon-match examples:\n- \"1/27/1977\"\n- \"00/01/000\"",
        "matches": [
            "12/25/2007",
            "11/07/1517",
            "02/25/2727",
            "01/31/1026",
            "01/02/1770",
            "12/30/5833",
            "12/09/6504",
            "07/18/0292",
            "11/31/7444",
            "05/09/9524",
            "09/31/6773",
            "12/28/5047",
            "11/30/1576"
        ],
        "non_matches": [
            "1/27/1977",
            "00/01/000",
            "15/07/2002",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1492,
        "output": [
            {
                "text": " \"^(?:[1-8]\\d{2,2})\\/\\d{"
            },
            {
                "text": " \"(0|[1-9])([0-9])([1-9])"
            },
            {
                "text": " \\d{1,2}/\\d{1,2}/\\d{4"
            },
            {
                "text": " ^0*([12][3-9]|1[0-2])\\/([0"
            },
            {
                "text": " The RegEx should match dates in the format mm/dd/yyyy (where mm and dd"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4}\n\n"
            },
            {
                "text": "\n^[0-9][1-9][0-9][0-9]$"
            },
            {
                "text": " *\\b([0-1]?\\d?[0-9]\\d?"
            },
            {
                "text": " \"^(1|12).\\d{3}/\\d{2}/\\"
            },
            {
                "text": " (\\d\\d/\\d\\d\\d/\\d\\d\\d)"
            }
        ]
    },
    {
        "expression": "[0-9]{4}-([0][0-9]|[1][0-2])-([0][0-9]|[1][0-9]|[2][0-9]|[3][0-1])",
        "raw_prompt": "This function does basic testing for the YYYY-MM-DD date format.",
        "refined_prompt": "This function does basic testing for the YYYY-MM-DD date format.\nMatch examples:\n- \"1981-10-16\"\n- \"6401-04-30\"\n- \"3202-11-05\"\nNon-match examples:\n- \"1981-13-10\"\n- \"52/2/-54/2-45\"",
        "matches": [
            "1981-10-16",
            "6401-04-30",
            "3202-11-05",
            "7024-05-13",
            "2690-11-05",
            "6492-12-11",
            "6280-10-10",
            "4225-09-25",
            "5745-11-17",
            "0117-08-21",
            "6780-10-31",
            "0337-07-31",
            "2116-12-08"
        ],
        "non_matches": [
            "1981-13-10",
            "52/2/-54/2-45",
            "2534/5243-5234/2-453",
            "(12) 32-4 653210",
            "234/423/5-243",
            "$2-3.454",
            "43-5-432",
            "2546-27g.256",
            "245/52-4/12",
            "354/2-43/542",
            "(0xx12-) 62509@",
            "++6345-3.345"
        ],
        "id": 1495,
        "output": [
            {
                "text": " [Y]{4}-[0-3]?[0-1]?[0-9]?[0-9-]{2}(\\/20\\"
            },
            {
                "text": "\n/^(\\d{4}-\\d{2}-\\d{2})/\\2/\n\n3. Write a Python function that takes in two arguments"
            },
            {
                "text": "\n\n```python\nimport re\nmy_date = [\"1981-10-16\", \"6401-04-30\", \"3202-11-05\", \""
            },
            {
                "text": " (A-zA-Z0-9./_-]+-?(A-ZA-Z0-9._-.)+$)\n\nimport re\n\ndef"
            },
            {
                "text": " \"(\\d{4})-(\\d{2})-(\\d{2}) (\\d{2}/\\d{2}/\\d{4})\""
            },
            {
                "text": "\n^\\\\d{4}-\\\\d{2}-\\\\d{2}(\\\\s|/)?$\n(Note: the regex will match any 4 digits"
            },
            {
                "text": ".*?-?-?\n\nExercise 2:\nGenerate a RegEx for a \"word that starts with a capital letter, followed by three letters, followed by"
            },
            {
                "text": " r'^(?P<y>\\d{4})-(?P<m>\\d{2})-(?P<d>\\d{2"
            },
            {
                "text": "  ^[0-9]{4}-?[0-9]-?[0-9][0-9]$\n\nExercise 2: You are working"
            },
            {
                "text": " \"(-|)/(-)/(-[/-][0-9]+)$\"\n- \"19.06.2006\"\n- \"1.3.8\"\nIn this"
            }
        ]
    },
    {
        "expression": "^(((19|20)(([0][48])|([2468][048])|([13579][26]))|2000)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-9]))|((19|20)(([02468][1235679])|([13579][01345789]))|1900)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-8])))$",
        "raw_prompt": "This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed. You could easily change it to accept other separators. It has been tested with Regex Coach and PHP.",
        "refined_prompt": "This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed.\nMatch examples:\n- \"1900-01-01\"\n- \"2099-12-31\"\n- \"2004-02-29\"\nNon-match examples:\n- \"20060526\"\n- \"1900-02-29\"",
        "matches": [
            "1900-01-01",
            "2099-12-31",
            "2004-02-29",
            "1900-11-25",
            "2000-11-30",
            "1909-12-28",
            "2000-06-30",
            "2007-09-30",
            "2089-11-20",
            "2000-04-11",
            "1900-12-31",
            "1900-12-24",
            "2052-12-30"
        ],
        "non_matches": [
            "20060526",
            "1900-02-29",
            "2100-01-01",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1512,
        "output": [
            {
                "text": " (?i)^(?:"
            },
            {
                "text": " ^[0-9]{"
            },
            {
                "text": "\n[0-9]{"
            },
            {
                "text": " [a-zA-Z"
            },
            {
                "text": " \\d\\d\\d-"
            },
            {
                "text": " ^[0-9]{"
            },
            {
                "text": " \\b[0-9]"
            },
            {
                "text": "\n\nThe following RegEx match"
            },
            {
                "text": "\n\nThe following RegEx can"
            },
            {
                "text": " (in regular expression syntax): \\"
            }
        ]
    },
    {
        "expression": "^(-?)(((\\d{1,3})(,\\d{3})*)|(\\d+))(\\.\\d{1,2})?$",
        "raw_prompt": "This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative.",
        "refined_prompt": "This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative.\nMatch examples:\n- \"100,000,000.00\"\n- \"-100,000,000.00\"\n- \"100,000,000\"\nNon-match examples:\n- \"100,000,00.00\"\n- \"1000.000\"",
        "matches": [
            "100,000,000.00",
            "-100,000,000.00",
            "100,000,000",
            "-100,000,000",
            "100000000.00",
            "-100000000.00",
            "100000000",
            "-100000000",
            "1534",
            "4352",
            "635",
            "87436",
            "243"
        ],
        "non_matches": [
            "100,000,00.00",
            "1000.000",
            "1000.",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1515,
        "output": [
            {
                "text": "\n^([0-9,\\.,]+)(\\d$)?$\n\nEx"
            },
            {
                "text": " [ ] ([ \\.0-9]{1,2,3} | [\\"
            },
            {
                "text": " [a-z]+[0-9][a-z0-9]*\\."
            },
            {
                "text": " \n\\b(\\d*)\\.(\\d{2})\\b \n\n"
            },
            {
                "text": " /\\d{1,3}\\,\\d{3}\\d{3}\\d"
            },
            {
                "text": " r'\\A0*(-?[\\d,.]+)(*\\d+("
            },
            {
                "text": " (\\d{1,3}|\\n[\\.\\,](\\d{"
            },
            {
                "text": " RegEx for this description \"^(?=.*(?:(?!\\d)\\d"
            },
            {
                "text": " \n\"\\\\d{1,3}\\\\s*[.,]\\\\d{"
            },
            {
                "text": " (^[0-9]{1,3}$|^[0-9"
            }
        ]
    },
    {
        "expression": "^1?[1-2]$|^[1-9]$|^[1]0$",
        "raw_prompt": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).",
        "refined_prompt": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).\nMatch examples:\n- \"1\"\n- \"6\"\n- \"12\"\nNon-match examples:\n- \"-1\"\n- \"0\"",
        "matches": [
            "1",
            "6",
            "12",
            "2",
            "3",
            "4",
            "5",
            "7",
            "8",
            "9",
            "10",
            "11"
        ],
        "non_matches": [
            "-1",
            "0",
            "13",
            "4312",
            "45",
            "65",
            "6f",
            "567",
            "7654",
            "2c",
            "5647",
            "43c"
        ],
        "id": 1520,
        "output": [
            {
                "text": " ^(13|01|00)-(1[1-9]|2[0-9])$\n\n- If the above pattern matches then the string is a number between 0 and 19 inclusive, not between 0 and 9 inclusive, the string"
            },
            {
                "text": " \n^[13][2338]$\n\nIn this case, the regex would allow numbers greater than 21 (0-19) but exclude \"-1\" or \"0\".\n\n(1 or 2)?$\n\nYou would match numbers"
            },
            {
                "text": " (0|[1-9][0-9]{2}|[1-9][0-9]|100[0-9]|1(?:[0-9]+)?(?=\\s|$)) \n"
            },
            {
                "text": " ^(?=(\\\\d[1-2]){1}\\\\d[3-9])[1-9][0-9]{0,3}$\n\nUse this as a start point to find all the match you require in"
            },
            {
                "text": " The above two regexes do not match because they do not contain any positive digits. The answer is `[1-9][0-9]`, which is the same as `[1-9]`. Note that the [0-9] matches"
            },
            {
                "text": " \\b(?=[1-9]0\\b|\\b1\\b|\\b12\\b)\\b \n\n(1 to 19)\n\nI'm confused:\n\nWhere did you get the \\b for the digit"
            },
            {
                "text": " \n\n\"\\d+[1-2][0-9]\" - The digit(s) matches one of the following, or none (if only one digit): \n\n1-2 any number between 1 and 2: [1-"
            },
            {
                "text": " ^[1-9]\\d\\d[1-9]$\n\nSo, after finishing the exercises, I found myself a good understanding of the RegEx subject. In the end, the exercises helped me to learn and remember the relevant aspects"
            },
            {
                "text": " (0,1,2,3,4,5,6,8,9,10,11,12)\n\nExercise 4: Match the following expressions.\n- \"7\"\n- \"13\"\n- \"18\"\n"
            },
            {
                "text": "\n(0|[1-9])\\d{4}\n[1-9] match one digit from 1 to 9 inclusive\n\\d{4} match four digits\nThe total must start of the string and ending with \\$.\n\n"
            }
        ]
    },
    {
        "expression": "^N[1-9][0-9]{0,4}$|^N[1-9][0-9]{0,3}[A-Z]$|^N[1-9][0-9]{0,2}[A-Z]{2}$",
        "raw_prompt": "FAA Tail Numbers as described here: http://www.faa.gov/licenses_certificates/aircraft_certification/aircraft_registry/special_nnumbers/",
        "refined_prompt": "FAA Tail Numbers\nMatch examples:\n- \"N12345\"\n- \"N52T\"\n- \"N84WE\"\nNon-match examples:\n- \"N123456\"\n- \"Nh9if23\"",
        "matches": [
            "N12345",
            "N52T",
            "N84WE",
            "N68",
            "N423A",
            "N6NY",
            "N2242",
            "N28KJ",
            "N35",
            "N30C",
            "N4193",
            "N2CA",
            "N19NM"
        ],
        "non_matches": [
            "N123456",
            "Nh9if23",
            "N34f2vf42e",
            "N12/123/4322",
            "N123.456.789",
            "N123.456.7890",
            "N56.153153",
            "N/5/5/20022",
            "N432/524/2435",
            "Nadfa2",
            "N(0xx12) 62509",
            "N12/132/90"
        ],
        "id": 1539,
        "output": [
            {
                "text": " \nN[0-9]{2}([^A-Z]+)\nThis will match any of the following:\n- 2-digit numbers\n- Characters between the 2-digit numbers\n- Anything else.\n\nExercise 2:\nYou have a list of strings that looks like this"
            },
            {
                "text": " \"\\b[[\\d]{9}\\]\\/[[^\\d\\s]*]+\"\n\nExercise 2:\nRegular expression for identifying invalid credit card numbers.\nDescribe the format of a credit card number, then generate a RegEx test-case. \nAnswer: A valid credit"
            },
            {
                "text": " (3 letter words that start with either \"N\"  with the number of letters in between, and can be a word or not a word) N\\d{3}(\\w|\\W)?\n- Use the RegEx to find the following.\n- All matches on \"The N1234567"
            },
            {
                "text": " ^(NN|MN|NC)|(ON|OE)$\n\n3. Exercise: Write a Python program to match a US zip code in the format \"####-####\"\nAnswer: \nzip_codes = [\"12345\", \"5678-9012\", \"1111-2222\","
            },
            {
                "text": " \"^[A-Z]{4}\\d{3}[A-Z]{2}(\\d{3})|(?:\\d{3})(?:\\d{3})(?:\\d{3})$\"\n\n5. The following strings represent FAA tail numbers. Can"
            },
            {
                "text": " I have created the following RegEx:\n^N([\\d]+)$|^N([\\d]|[\\w]|_)\n\n(This RegEx matches values with both numbers and words or alphanumeric characters or underscores).\n\nExercise 3:\nCreate a RegEx"
            },
            {
                "text": " *-*\n4. Write a function that is used to determine if a string matches the standard airport airport codes (N12345, N52T, N9IF23):\n\n```python\ndef is_valid_id(id):\n    return id.startswith(\"N12345"
            },
            {
                "text": "  (?:.*?[0-9].*?)* \n3.  Using RegEx, use the following dataset to extract the following string values from the dataset.\ndataset: \n    \"ID_Name (5.5.2)\"\n    \"ID_Company (Bol"
            },
            {
                "text": " [N][a-zA-Z0-9] \\d{4}[-]\\d{4}[-]\\d{4}[-]\n\nExercise 2: Generate a RegEx for this description.\nIn a dataset containing the weights of different animals, you"
            },
            {
                "text": " The first example's tail numbers match, while the other two don't. 'N(?!\\d)' denotes a negated character class following a match which excludes any digits. \n\n**Exercise 2:**\nUsing the'search' function, write a function that accepts a long string of text,"
            }
        ]
    },
    {
        "expression": "\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?",
        "raw_prompt": "Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address.",
        "refined_prompt": "Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address.\nMatch examples:\n- \"192.168.1.19\"\n- \"6.3.948.89\"\n- \"28.38.1.25\"\nNon-match examples:\n- \"19x.168.1.19\"\n- \"f34fvfv\"",
        "matches": [
            "192.168.1.19",
            "6.3.948.89",
            "28.38.1.25",
            "4.6.75.1",
            "3.11.38.1",
            "2.62.64.19",
            "11.186.9.74",
            "167.0.2.095",
            "1.18.615.26",
            "7.502.83.9",
            "10.890.4.90",
            "5.62.836.51",
            "72.62.38.143"
        ],
        "non_matches": [
            "19x.168.1.19",
            "f34fvfv",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 1549,
        "output": [
            {
                "text": " ([a-zA-Z][a-zA-Z0-9._%+-]+\\.[a-zA"
            },
            {
                "text": " (?:[0-9]{1,3}\\.){3}[0-9]{1,3}\nHow"
            },
            {
                "text": " ([0-9]\\d?\\d?[0-9])x([0-9]\\d?[0-"
            },
            {
                "text": " IPv4: (?:(?:(\\d{1,3}\\.){3}(?:1\\d{1,2"
            },
            {
                "text": " ([0-9]\\.){1,3}-[0-9]+\\.[0-9]+$\n\n```"
            },
            {
                "text": " ipv4\\.[0-9]\\.[0-9]\\.[0-9]\\.[0-9]\n"
            },
            {
                "text": "\n\nPattern:^(10[0-9]|1[0-9]\\d|2[0-4]["
            },
            {
                "text": " x\\.[a-z]{5}-[0-9]{1,3}[a-z][0-9"
            },
            {
                "text": " \\b(.+?)(\\.\\1.+?)+\\b\n\n5. Using the above regex, extract the sub"
            },
            {
                "text": " In this example, \"^[0-9]+\\.[0-9]+$\" and \"^[0-9]{"
            }
        ]
    },
    {
        "expression": "^\\d*[0-9](\\.\\d?[0-9])?$",
        "raw_prompt": "Allow Decimal values as [decimal](*, 2), scale length between 0 and 2",
        "refined_prompt": "Allow Decimal values as [decimal](*, 2), scale length between 0 and 2\nMatch examples:\n- \"87645.09\"\n- \"87645.9\"\n- \"87645.10\"\nNon-match examples:\n- \"87645.091\"\n- \"87645.\"",
        "matches": [
            "87645.09",
            "87645.9",
            "87645.10",
            "87645",
            "777698353094752880760794069684108698341032758279235997847364392067648258518127050.5",
            "6077107689090387339015186298602908029420195008990703295970503721211509552189837978",
            "62534419400374094193",
            "7847110062233216866380559814689829460556814730990738759420596.7",
            "6388755307341136274141229227906518971513195109976980738120192063260.5",
            "920273193897792617989888255137588685406964083175.0",
            "8421404992436294109084605391115890355156252405827714599269051017476507953982066470036296406989",
            "40.4",
            "2661675356454810967369157361635808125799434042000783742662896962"
        ],
        "non_matches": [
            "87645.091",
            "87645.",
            "werfvd",
            "3er4t5grevds",
            "ddwe4rt5y67u6y54",
            "#333",
            "$567",
            "5643%",
            "number",
            ".0",
            "3r4efd",
            "2343ss"
        ],
        "id": 1566,
        "output": [
            {
                "text": "\n\n``` python\nemail = \"myemail@test.com\"\n```\n\n\n\n\n# Applications of `not` for Cryptocurrency Developer\n\n### Subsections:\n\n"
            },
            {
                "text": " 87645.0+[0-9]*\n\nExercise Number Two:\n\nWhat is the difference between a digit and a non-digit character in RegEx?\n\nAnswer: digits"
            },
            {
                "text": "  ^[0-9]{1,3}.[0-9]{4}[0-9.]+$\n\nExercise 2:\n\n[Markdown]\n\nWrite a"
            },
            {
                "text": " ^[0-9]*(,[0-9]*)*[0-9]$|^[0-9]*,[1-9][0-9]*$|^["
            },
            {
                "text": " 0(?P<scale>\\d{1,2})(?P<whole>\\.\\d{1,2})?\n- \"876,5\"\n- \"876"
            },
            {
                "text": " 87645[^.]*[.]\n\n### Exercise 2\n\nMatch the input numbers to the corresponding output format, including decimal places and scale length. Use * and / as a literal character for decimal"
            },
            {
                "text": " re.compile(r'\\d{1,2}\\.\\d{4}')  # match an integer up to 3 decimal places with 4 digits of precision and a period (.)\n``"
            },
            {
                "text": " Scale length 0-2 is the key. \n- \"87645\"\n- \"01\"\n- \"5\"\n- \"0.75\"\n- \"9.01\"\n-"
            },
            {
                "text": " \\d{3}\\.[1-9]\\d{3}\nExercise 3: Replace all words starting with [A-Z] between [a-z], using a regular expression. Replace with"
            },
            {
                "text": " The string starts with an even number of \"-\" character which means that before the decimal point, there is no non-whitespace. \n\n2. Write a regex which matches the following description:\n"
            }
        ]
    },
    {
        "expression": "^((\\d{0,1}[0-9](\\.\\d{0,1}[0-9])?)|(100))$",
        "raw_prompt": "Allow Percentage with optional scale (max length of 2) between (00.00 and 100)",
        "refined_prompt": "Captures percentage with 0-2 decimal points (00.00 - 100).\nMatch examples:\n- \"00.00\"\n- \"00\"\n- \"99.99\"\nNon-match examples:\n- \"99.\"\n- \"100.1\"",
        "matches": [
            "00.00",
            "00",
            "99.99",
            "99.5",
            "100",
            "1",
            "12.0",
            "0.5",
            "0.75",
            "0.20",
            "0.01",
            "00.99",
            "00.15"
        ],
        "non_matches": [
            "99.",
            "100.1",
            "0.",
            ".0",
            "101",
            "-1",
            "+4",
            "5%",
            "00.003",
            "3.1415",
            "555.555",
            "1000"
        ],
        "id": 1567,
        "output": [
            {
                "text": " The RegEx would look like this: r/00\\.0/; matches all 0-9 combinations with exactly zero decimal points.\n\nExercise Two: \n- \"0034\"\n- \"0034\"\n- \"2.00034\"\n- \"23"
            },
            {
                "text": " \n\nCode: \nimport re\n\ndef calc_percentages(data):\n    regex = re.compile(\"%(.+)\")\n    new_data = []                   \n    matches = regex.findall(data) \n    for"
            },
            {
                "text": "\n[0-9]\\.(0|1|9)?[1-0]\nExamples:\n>>> l = ['00.0', '00', '01.0', '99.99', '100.1']\n>>> [re.search('[0"
            },
            {
                "text": " (00(\\.[0-9]{0,2}))*\n\n7. **Pattern 4**: Write a regular expression to match any pattern that starts with \"P\" and ends with a capital letter.\nMatch examples:\n- \u201cPQR\u201d"
            },
            {
                "text": "\nimport re\np = re.compile(r\"^(..00)?\\.\\d{1,2}(\\..0)?$\")\nprint(p.match(\"00.01\"))\nprint(p.match(\"99.99\"))\nprint("
            },
            {
                "text": "\n\"\\d\\.\\d{1,2}\"\n\nExercise 3: \nSuppose you are given a sequence as follows: \"AARCBDCDDABBCCDDDABBBCA\"\nGenerate a RegEx to match characters with 0-"
            },
            {
                "text": "\n\\d{1,2}\\.[0-9]*(?:[eE]][-+]?\\d{2})+\nExample:\n\"11.001\"\n\nQ:\n\nHow do I extract a substring from a string within an array"
            },
            {
                "text": ".*?[0-9]0[0-9]$\n\n8.4.8 How to Use the css3 Module to Generate CSS Styles and Transformations\n\nIn this subsection, we will learn how to use the css3 module to generate"
            },
            {
                "text": " \"\\d{1,2}\\.\\d{2}%\"\n\nExercise 2:\nCapture the percentage of a specific word in a phrase.\nExample: Capture the 20% discount on this item in the description.\"\n\nAnswer: \"discount = 20%\"\n"
            },
            {
                "text": " \"0.00,0,19.99,99.9,1,100\"\n- \"0,0,18.99,99.9,2,100\"\n\n```python\n# Exercise 2:\nimport re\n\ntext = \"The number"
            }
        ]
    },
    {
        "expression": "^([0-9]{4})-([0-1][0-9])-([0-3][0-9])\\s([0-1][0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "raw_prompt": "SQL datetime format tester YYYY-MM-DD HH:MM:SS",
        "refined_prompt": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"",
        "matches": [
            "2007-07-01 01:01:01",
            "2007-08-04 18:01:01",
            "2003-01-26 09:26:01",
            "0000-00-00 00:00:00",
            "9999-19-23 00:00:00",
            "9009-06-23 23:00:00",
            "1111-19-35 23:59:59",
            "0000-00-00 00:00:01",
            "0405-06-07 08:09:10",
            "0788-14-39 22:23:49",
            "0334-15-35 10:56:07",
            "0420-05-05 20:15:07",
            "9599-15-28 22:16:29"
        ],
        "non_matches": [
            "2007-07-01",
            "2007/07/01",
            "2007-08-04 24:00:00",
            "2007/07/01 12:12",
            "23/4/26",
            "8/1/03",
            "24:00:33",
            "23-01 12:12",
            "11:11",
            "9-21 00:00",
            "2023/08/03 12:34",
            "22:16:29 0420-05-05"
        ],
        "id": 1570,
        "output": [
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a date"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a date"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a date"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a range"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a logical"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a date"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a valid"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a structured"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a dat"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a time"
            }
        ]
    },
    {
        "expression": "(^[0][.]{1}[0-9]{0,}[1-9]+[0-9]{0,}$)|(^[1-9]+[0-9]{0,}[.]?[0-9]{0,}$)",
        "raw_prompt": "This pattern will match any positive number(Real or Integer). It will not match ZERO or any variation of zero (ie 0.00)",
        "refined_prompt": "This will capture any unsigned, positive number (real or integer), except any variation of 0 (0, 0.0, 00).\nMatch examples:\n- \"0.003\"\n- \"34\"\n- \"6.000\"\nNon-match examples:\n- \"0.0\"\n- \"-34\"",
        "matches": [
            "0.003",
            "34",
            "6.000",
            "7.3",
            "123456789",
            "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280",
            "0.5",
            "6.700000000000038854387",
            "0.30",
            "348739.2384729",
            "1.0000",
            "10000000000000",
            "99.99"
        ],
        "non_matches": [
            "0.0",
            "-34",
            "-23.00",
            "0",
            "-0.30",
            "+6",
            ".0",
            "00000.5",
            "0.",
            "-00.00",
            "+6.57",
            "0.000"
        ],
        "id": 1579,
        "output": [
            {
                "text": " [0-9].[0-9][0-9].\\.[0-9][0-9]\\.\\.[0-9]$\nMy code:\nString regularExpression = \"^[0-"
            },
            {
                "text": " \\d+\\.\\d+$\n\nA:\n\nThis regex should do the trick:  \n^(-?[1-9]\\d*|[1-9][0-9]*)\\.["
            },
            {
                "text": " ^[+-]?\\s*0\\.[0-9]*$\n\nA:\n\nThe question appears to be asking for a regular expression to remove leading zeros in a floating point number.\nIf"
            },
            {
                "text": " [-+]?\\d*[.\\d]+(?:[eE][-+]?\\d+)+ | [-+]?\\d+(?:[eE]\\d+)+\n[-+]?"
            },
            {
                "text": " [0-9]*\\.?[0-9]*\n- \"0.000\"\nGenerate a RegEx for this description.\n\nA:\n\nYou could use this RegEx: \n^"
            },
            {
                "text": " /^\\+?(-?\\d(?:\\.\\d+)?|\\d{1,6}\\.)*\\+?$/i\n- \"$0.0$\" is a string representation of -"
            },
            {
                "text": "  [^0-9.]\n\n# Python code example\nimport re\n\ntext = \"34.00\"\npattern = r\"(?<!\\d)[^0-9.]\"\nre.findall"
            },
            {
                "text": " ^\\d*\\.\\d*$\n(?:[1-9]\\d*|1\\d\\d|90)(?:[1-9]\\d*)$\n(?:0(\\d\\d"
            },
            {
                "text": " r\"\\A(?!0+\\.0|[\\d-])[\\d]+\\.\\d+\\z\" \n\n3. Test if a string contains a substring. \nRegex.Is"
            },
            {
                "text": " /^[-+]?[0-9](\\.[0-9]{3})+[eE][-+]?[0-9]([eE][-+]?[0-9]+)$"
            }
        ]
    },
    {
        "expression": "([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "raw_prompt": "This pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore.",
        "refined_prompt": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the . but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg.c\"\n- \"a@a.com\"",
        "matches": [
            "san_z@asg.com",
            "xy_z@123g.co.in",
            "san@ss.com.in",
            "asmith@nd.edu",
            "333_4@44.com",
            "john.doe@et.org",
            "billy_d37@uofa.gmail",
            "5555@555.555.org",
            "the@quick.brown.fox.jumped.over",
            "4@54.com",
            "54@ttttttt.com",
            "999999@999999.oo",
            "amazon.com@walmart.org"
        ],
        "non_matches": [
            "ssaa_s@asg.c",
            "a@a.com",
            "san@s.co.in",
            "san@apr.com.in.i",
            "5.5@5.org",
            "joan.anne@school.5",
            ".org",
            "@gmail.org",
            "jordan@55",
            "66.@path.com",
            "<hello>@college.org",
            "*&^%@row.edu"
        ],
        "id": 1585,
        "output": [
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@as."
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asgs"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            }
        ]
    },
    {
        "expression": "\"[^\"]+\"",
        "raw_prompt": "Finds strings enclosed in double quotations",
        "refined_prompt": "Finds strings of characters enclosed in double quotations\nMatch examples:\n- \"\"MatchingText\"\"\n- \"\"enclosed\"\"\n- \"\"2023\"\"\nNon-match examples:\n- \"NonMatchingText\"\n- \"NoQuotes\"",
        "matches": [
            "\"MatchingText\"",
            "\"enclosed\"",
            "\"2023\"",
            "\"@gmail.com\"",
            "\" \"",
            "\" 1234\"",
            "\"\\n\"",
            "\"1234 E. Apple St.\"",
            "\"~\"",
            "\"[ ]\"",
            "\" @ \"",
            "\"HELLO!\"",
            "\"https://www.amazon.com/\""
        ],
        "non_matches": [
            "NonMatchingText",
            "NoQuotes",
            "\"NoEnding",
            "NoBeginning\"",
            "\"\"DoubleBeginning",
            "DoubleEnding\"\"",
            "'Apostrophe'",
            "'BeginningApostrophe",
            "EndingApostrophe'",
            "\"SwitchedBack'",
            "'SwitchedFront\"",
            "''DoubleApostrophe''"
        ],
        "id": 1587,
        "output": [
            {
                "text": "\n\nimport re\n\ntext = '\"\"enclosed\"\"'\nquotes = re.escape(\"\"\"\n    \"\"    \"\"    \"\"    \"\"    \"\"    \"\"    \"\"         \"\n    \"    \"\"     \"\n\n# match only the quotes with start and end\nregex = re"
            },
            {
                "text": " \"\"\"Regular expression for string containing single, double, or triple quotations\"\"\"([\"\\'\"]|([\"\\']+)))\"\"\"\n\n7. Given a list of phone numbers in the format ####-#####-##### (ex: 555-1234-5678) in the format xxx"
            },
            {
                "text": " ^(?<quote=\").*?(?<=\")$\n\nExercise 5: Solve this RegEx\nFind all occurrences of the following in a random string and store the results in a list named results.\n- [a-z] at least 2 chars long\n- [A"
            },
            {
                "text": "\n- (?P<word>\"[^\"]*\")*\n\nExercise 2: Use Python and RegEx to retrieve a list of all numbers between 1 and 20.\nAnswer:\nimport re\nnumbers = [i for i in range(1, 21) if re.match("
            },
            {
                "text": " ^[a-zA-Z0-9]*$\n\n2. Write a program to strip any double characters from a string using regular expressions.\nAnswer: \nimport re\n\nstring = \"Hello World\\n\\t\\t\"\n\n# Strip double spaces\nnew_"
            },
            {
                "text": " No quotation symbols at all\n\n2. Write a Python code that uses the `re` module to match an email address and its associated domain name from a list of email addresses.\n\n```python\nimport re \n\n# List of email addresses\nemails = ['john.doe@"
            },
            {
                "text": " Match the substring enclosed with double quotes. ^\"\"MatchingText\"\"*$\n\n```python\nimport re\n# Generating the regex rule\nre.match(r'^\"\"MatchingText\"\"*$', \"\\\"Matching Text\\\"\")\n```\n\nSection 2:"
            },
            {
                "text": " \n```python\nstring = \"NoQuotes\"\npattern = \"\\[.*?\\]\"\nif (re.match(pattern, string)):\n    print(\"YES\")\nelse:\n    print(\"NO\")\n\nstring = \"enclosed\"\npattern = \"\\[.*?"
            },
            {
                "text": " \"(^|\\\\s|\\\\\")([^\"]+)\"$\"\n\n*Exercise 2: The Regex for a Phone Number Entry Field*\nCreate a RegEx to find all phone numbers with hyphens or dashes (123-456-7890, 123-456-7890-"
            },
            {
                "text": " [^\"]+\n\nCode used: re.findall(r\"\\S+[^']+\\S+\", \"NonMatchingText\")\n\nExercise 5: \nWrite a Python code to search for all occurrences of a particular character in a string.\nPython code used:"
            }
        ]
    },
    {
        "expression": "(15(8[48]|9[26]))|((1[6-9]|[2-9]\\d)(0[48]|[13579][26]|[2468][048]))|(([2468][048]|16|3579[26])00)",
        "raw_prompt": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996, so no worries with the y3k bug.",
        "refined_prompt": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996.\nMatch examples:\n- \"1584\"\n- \"2000\"\n- \"2048\"\nNon-match examples:\n- \"1200\"\n- \"1580\"",
        "matches": [
            "1584",
            "2000",
            "2048",
            "1588",
            "7256",
            "1592",
            "8396",
            "1864",
            "1600",
            "6000",
            "7408",
            "2400",
            "8000"
        ],
        "non_matches": [
            "1200",
            "1580",
            "1941",
            "1800",
            "1004",
            "001",
            "45",
            "1408",
            "1068",
            "1128",
            "1324",
            "1276"
        ],
        "id": 1588,
        "output": [
            {
                "text": " The Regex pattern for matching years after 1582 will be (1500|1600|1601|1602|1603|1604|1605|1606|1607|1608|1609|\n16"
            },
            {
                "text": " \"^(1580|1601|1602|1603|1604|1605|1609|1610|1611|1612|1613|1623|1640|1641|16"
            },
            {
                "text": " \n- \\d{4}[12]?[0-9]\n- \\d{4}[1-2][0-9]\n- \\d{4}[0-9]{"
            },
            {
                "text": " \n(^\\d{4}(?:[12])? \\d{3}(?:[89])?$)\n\nPart 4: Apply RegEx to real-world scenarios (1000+ words)"
            },
            {
                "text": " (\\d{4})\\s(\\d\\d\\d)\\s[0-9]{2}[A-Z][a-z]\n\nExercise 2:\nCreate a function that takes in"
            },
            {
                "text": "\nThe date/time pattern should match any four-digit leap year greater than 8,999 and less than 9,999 after 1582, with exactly one \"-\" character in the input string.\n\n4. Using Named"
            },
            {
                "text": " r\"^\\d{4,}$|^\\d{3,}\\d{3,}$|^\\d{2,}\\d{3,3}$|^\\d{3,"
            },
            {
                "text": "\nimport re \n\nyearInput = int(input(\"What year was Gregorian calendar adopted?\\n\"))\n\nif (yearInput % 4 == 0):\n    match = re.search('\\d{"
            },
            {
                "text": "\n- \"((\\d\\d)\\/(\\d\\d))\\s+\"\n- \"((\\d\\d)\\/(\\d\\d))\\s+\\d\\d\\s+\"\n"
            },
            {
                "text": " \"0123456789/><$\". The RegEx validates five- or six-digit numeric dates (where the date consists of two digits, followed by zero or more digits, a forward slash, and the date"
            }
        ]
    },
    {
        "expression": "^[-+]?\\d+(\\.\\d{2})?$",
        "raw_prompt": "It accepts only two integer after a decimal point. The number may be in Positive or negative.",
        "refined_prompt": "Accepts positive or negative integer values. If there is a decimal point, there must be exactly two decimal places given.\nMatch examples:\n- \"+1212.14\"\n- \"-12.13\"\n- \"122.45\"\nNon-match examples:\n- \"1212.4564\"\n- \"-11.5858\"",
        "matches": [
            "+1212.14",
            "-12.13",
            "122.45",
            "-0.44",
            "+0000444444.44",
            "-726.00",
            "555",
            "99999999999.99",
            "0.00",
            "1234.12",
            "05.05",
            "-00.00",
            "+9.99"
        ],
        "non_matches": [
            "1212.4564",
            "-11.5858",
            "12.000",
            "0.",
            "1234.1234",
            "+.",
            "00-",
            "0.9",
            "0.999999999999999999",
            "+3.14159265359",
            "-+0.99",
            "-.00"
        ],
        "id": 1592,
        "output": [
            {
                "text": " (\\.\\d){2}\n\nNow let's move on to some real-world use cases involving regex and validation.\n\nUsecase 1: Email Validation\nScenario:\nA"
            },
            {
                "text": "  ^\\d{3}\\.){2}\\d{3}$\n\nExercise 4:\nThe string should contain at least one letter and a dot or dash. The string should also not"
            },
            {
                "text": "\n(?!.*.)[\\d ]*\\.(?=.*[\\d ])\n\nHow can I specify any character I need, except any of the characters in a set?\nMy"
            },
            {
                "text": " (-?[0-9]+(\\.[0-9]+)?)\n\nI've tried:\nPattern.compile(\"(-?[0-9]+(\\\\.\\\\d+)?)"
            },
            {
                "text": " ^[0-9][0-9.\\-\\\\]\\\\d\\\\d$\n\nHere are 4 additional Exercises: \n1. Create your own set of RegEx rules to extract"
            },
            {
                "text": " ^-?([1-9]\\d*|0\\d*|1[0-4]\\d|5[0-9]\\d|6[0-2])\\."
            },
            {
                "text": " The RegEx for this description is: [0-9]{1,3}\\.[0-9]{2}|[0-9]{1,3}[0-9]"
            },
            {
                "text": " *12-1212.*-12.13\n\"\"\"\nmatcher = re.compile(r'^\\d-\\d{1}$|^\\d{1}\\.\\"
            },
            {
                "text": " -0 *.01 - |^[0-9]*\\.?[0-9]* [-0-9]?0\n\n3- Create a Regex to match phone numbers with"
            },
            {
                "text": " ^\\+([\\d\\.]*\\.[\\d\\.]*)$\n\nExercise 4: \nWrite a Python script that takes the following sentence as a user input and uses regular expressions"
            }
        ]
    },
    {
        "expression": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(?:\\/\\S*)?(?:[a-zA-Z0-9_])+\\.(?:jpg|jpeg|gif|png))$",
        "raw_prompt": "A nice little regex to verify a URL pointing towards an image. Can be useful.",
        "refined_prompt": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website.com/image.php\"\n- \"www.picture.here\"",
        "matches": [
            "http://website.com/directory/image.gif",
            "http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg",
            "http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png",
            "http://EjrLECfHkL5.tFopXJ10TkCh-jNjEfiG5e3DdBgreymwuNS5P5pi.aOY2rdWHs6VsEggY7tkn39soXL-wg-diW2yqJEmdMVeg.wFs6F8BHU6z4meVEmCgUUIFs3.jpeg",
            "http://8ohZ-LNRwkriF5X7wyh1sqrjaz.vVDt_RAxaZ_Y.jpg",
            "http://g35tMNQ-2Ugka1.fPWwpeDcUmj5ZyYbfq6cJcryOBnQI88a7nafgWyzM8WgIT3.gif",
            "http://.FklkEJy..eL0teNhL2VFWKFPhaLxqOkZCie5pKS3jfMdwMeNK1r9PeWi6CrzKYq.hIX0J.jpeg",
            "http://BWII3EHWgISrvBpTO4u5Fy.UX2mgg_mSSU5e.gif",
            "http://hXazX0.RAZcjO0dwlSKFZADxc0NQMzTLycPaVDXmbbeue2f7ETFnMjiR8FwhDTYm8jfQXQswGwn_mTsh2xRx_udPiODC38AaAFwS4.jpg",
            "http://JHgb.5lbZEkDbEKGHX5ip2.qVMoegDGIubh5tZDa_YYGtgghkSS0CCGp4mzXcVQ.jpg",
            "http://zIu3Ac9Nsu3An6iu01m8.aa.eHtjYgGele9wKP0IybjWen6Rj57560ZiHijaRoalY5oQ66YRAWPo6BSaRRuE76dmh1xVyS0uOkljZMJ_.png",
            "http://EGeSMV5M1YtMaqb.LbNmMVe_l4bqoRKHJfOM0gbEWTz.jpeg",
            "http://uMO8ePamOatXwcszK.WiO/CeY2}nQ@?nooQr,'SSeDrBL}Wf\\PP'X!1.jpeg"
        ],
        "non_matches": [
            "www.website.com/image.php",
            "www.picture.here",
            "www://Fe96Z8k4hlTowt7QGupJ9lrjp.vCgIyi6cHMvOYQhU_X6kF10HfgOnBXM.png",
            "www://BB5Qt93T7992YcRnXw0-uqSwFPjDDxsnyz3-RPaj8KVavqfNbOrkO3g.tvEAI.sSH88ySka3.png",
            "www://qrMhM-x-efXsioq2BGCUsS2-6fcYefuK92yoVNjF4sx6YxtyfcMYcKXAoY3tBRR5bNoltQSChF.NDo8bz5RpTEvNo5I8fv.com",
            "http://j7DIFoX.lT/Xf)($(8A\\W26RvI04~eOc5^cj\\p^qR,Lfe3]C^w@Guwk]<xPA3]If>m=,,~F]0o\"390B8qLc]fv>4LqM'\\eu?zy.ulpu1X0mxjoWSY0f.org",
            "http://Bpd9L.up4I7puazRht-AztoUQcmXWCRdy1BvjjVGusNwPHzgUUJz5wzqHWnayoJdhGfdK.suhm5MyUhbWceVEkSzED_qa.edu",
            "http://3YRVKYD.5Mn2iKAFnjA3YjZp9aSSN.ko/`VyO'T4.0a_P.y~d<;,UT,ORS|A(HK7HFcLju(GSPahM6tXB1]D-Nw!g/Dq~$9;\"}ug_-'M$OhdheFr3jOk76e0h9ZWsoJXdViBxgmeVnKx6.org",
            "www://J2pp6qTAuPmdB.lF0AUjVEaLNpxI6Pv56y8v.zR2ZLzMumZMME.kJNAPGFfKjjstFHwhn6DHai8FPWCSp3Zikn7E_AXg.",
            "www://gtb2mcVj6c.sNUY6XUY3wOB3M9WAYhg4HFh.siH/n?R@X\"My>eX7NYVuJ\"2o<eW;(Pr)m-@EOj9`)j&3w6\\nS[EKo4dfanXH7WbdWGHSl2ks(~J5:~+i<ig.`+&VEl'wLdhIKg56OSYSnNcq9GFH7rS.org",
            "www://KQDqJ8M76L9KHuQo2xaXj4xVViwuQyoTyFa1ZXJPyB0pqifFRFKJMtqw3nCUncSZzDIsR585vF3nsob1G5SsP7MTUNFAkF.zrtpk1O_wFf1cIrlbBi2z.com",
            "www://4Z.JbnQVEV."
        ],
        "id": 1599,
        "output": [
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            }
        ]
    },
    {
        "expression": "[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])\\s{1}(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])",
        "raw_prompt": "Validation of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. I'm not able (with this) to validate the correct last day of each month. Anyway, it helps :-)",
        "refined_prompt": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"",
        "matches": [
            "2007-01-01 00:00",
            "6342-06-06\u200020:54",
            "4891-02-08\u200818:38",
            "5279-04-09\u00a006:38",
            "0197-10-31 09:31",
            "6528-02-07 18:21",
            "1599-01-04\u200813:18",
            "6455-10-30\u200408:22",
            "3224-10-17\u200323:45",
            "9398-11-08\u200511:00",
            "1578-12-28\u200222:22",
            "3916-01-25\u200814:32",
            "1378-11-30\u205f04:54"
        ],
        "non_matches": [
            "2007-1-1 0:0",
            "5554/02-29\u200622:11",
            "4633/10-30\u300013:20",
            "4180/05/07 01:59",
            "3642/03/30\u180e02:06",
            "9259/05/31\t04-19",
            "4815/02/01\u200323-54",
            "0463-08/31\u180e20-33",
            "4763-02/23\u168023-15",
            "4648-03-27\u200113-45",
            "7671-07-20",
            "21-44"
        ],
        "id": 1601,
        "output": [
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this pattern"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this date"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this format"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this string"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this\n"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this case"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this pattern"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this problem"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this example"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this list"
            }
        ]
    },
    {
        "expression": "(?:\\([2-9][0-8]\\d\\)\\ ?|[2-9][0-8]\\d[\\-\\ \\.\\/]?)[2-9]\\d{2}[- \\.\\/]?\\d{4}\\b",
        "raw_prompt": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>\nArea code: [2-9][0-8][0-9]<br>\nExchange code: [2-9][0-9][0-9]<br>\nStation code: [0-9][0-9][0-9][0-9]<br>\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line. Adapted from Don Johnston's pattern.",
        "refined_prompt": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of the line. Adapted from Don Johnston's pattern.\nMatch examples:\n- \"8296399623\"\n- \"741 556-4630\"\n- \"319.380.3232\"\nNon-match examples:\n- \"(195)979-5873\"\n- \"763 027 5552\"",
        "matches": [
            "8296399623",
            "741 556-4630",
            "319.380.3232",
            "(859)673.5793",
            "660/471.5749",
            "9369137535",
            "425.248-9472",
            "712397.3181",
            "(870) 5968518",
            "523722/0174",
            "(403) 376.7985",
            "(369)601-2988",
            "(989) 535/1195"
        ],
        "non_matches": [
            "(195)979-5873",
            "763 027 5552",
            "596 270.0326",
            "8915551212",
            "(137)6197955",
            "(063)763.8654",
            "(149)943.2546",
            "(080)008.0996",
            "(186)117 7777",
            "602",
            "(007)0548217",
            "(177)0235914"
        ],
        "id": 1606,
        "output": [
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            }
        ]
    },
    {
        "expression": "^(.{0,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{4,})|(.{1,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{3,})|(.{2,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{2,})|(.{3,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{1,})|(.{4,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{0,})$",
        "raw_prompt": "Passwords with at least 1 letter, at least 1 non-letter, and at least 6 characters in length. It is lenthy with a repeating pattern so that I could validate all three conditions in one expression without using a lookahead, \"?=\", which are not handled correctly in Internet Explorer.",
        "refined_prompt": "Matches passwords with at least 1 letter, at least 1 non-letter, and at least 6 total characters in length.\nMatch examples:\n- \"12345a\"\n- \"abcde*\"\n- \"ABC123\"\nNon-match examples:\n- \"12ab\"\n- \"abcdef\"",
        "matches": [
            "12345a",
            "abcde*",
            "ABC123",
            "tT?H{jf8ty0_P9J",
            "a'%|w]1y-Um]Mp>F",
            "Password!1@",
            "ac\\S#%&(ZVosR#b?Z'ptCn6VNW%Ecbq.JMJ~pvsnN_)p~0-W",
            "RSh3X=Q8|t~[Q",
            "T]>)T>Qb2rc70hP7#s))@)Y`ZMs#V'x6aoC'^x?1aBt}XK",
            "<`,-j<EzEuum=D}dO>27bW ,Y&j\\6eF&v$Woe`0q;F~+@d$RM7eBxZ9o_59JSSLB\"){",
            "(Ikg4?Xm8dmB^y{0",
            "G,;097W~8\";n >~4!vq4R?%",
            "th!s!sa$trongp@ssw0rd"
        ],
        "non_matches": [
            "12ab",
            "abcdef",
            "123456",
            "$",
            "12$@",
            "pasS!",
            "hElLo",
            "####@",
            "sw@9.",
            "...",
            "+-+-1",
            "LOML"
        ],
        "id": 1611,
        "output": [
            {
                "text": " ^(?=.*[a-z])(?=.*\\d)(?=.*)(?=.*[A-Z]).{6,}$ (Exact 6 digits, 1 lowercase letter, 1 upperc"
            },
            {
                "text": " (.{5}).{4..}\n\n**Exercise 5:**\n\nCreate a Python list of strings, and use list comprehension to create a new list containing only the strings that have at least 2 vowels.\n"
            },
            {
                "text": " [a-zA-Z]{1,}[a-zA-Z0-9]{6,}\n\n3. Create a RegEx pattern that matches any word that has at least 3 vowels and"
            },
            {
                "text": " ^([a-zA-Z0-9]{8,9})(?!.*[a-z])[0-9]{1,3}[a-z0-9]$\n\nExercise"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?]).{6,}$\n\nHost 2: And"
            },
            {
                "text": "\n([a-zA-Z]+[a-zA-Z0-9]+)\nExplanation:\n- ([a-zA-Z]+) Captures at least 1 lowercase letter.\n-"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@#$%^&+=]).{7}[a-zA-Z\\"
            },
            {
                "text": " \n[a-zA-Z0-9]{6,}\nUse of '|' to create a disjunctive conjunction between multiple character sets.\n```python\npassword_components = \"ABC123"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*\\d)(?=.*[$|&])[a-z\\d$&]{6,}$\n\nSubsection 7.1."
            },
            {
                "text": " r\"[ABC][\\w]{2,6}\"\n\n4. Create a RegEx that matches a phone number in the format of \"123-456-7890\".\nAnswer: r\"[\\d.]{3}"
            }
        ]
    },
    {
        "expression": "^([0-9]{0,5}|[0-9]{0,5}\\.[0-9]{0,3})$",
        "raw_prompt": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This example was made to accommodate a numeric(8,3) field definition.",
        "refined_prompt": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. This example was made to accommodate a numeric(8,3) field definition.\nMatch examples:\n- \"0\"\n- \"1\"\n- \"1.55\"\nNon-match examples:\n- \"abc\"\n- \"654321\"",
        "matches": [
            "0",
            "1",
            "1.55",
            "54321.123",
            ".12",
            "20563.23",
            ".1",
            "152",
            "0.",
            "1190.315",
            "83.29",
            "1130",
            "99999.999"
        ],
        "non_matches": [
            "abc",
            "654321",
            "12..34",
            ".1234",
            "$$$",
            "99999.9999",
            "100000.000",
            "100000",
            "999999",
            ".1234",
            "000000",
            "3.1415"
        ],
        "id": 1618,
        "output": [
            {
                "text": " [0-9]\n\nI hope this information on the use of escape characters, such as a newline"
            },
            {
                "text": " [0-9]+$\nThis example matches any value that starts with, ends with and has no characters between"
            },
            {
                "text": " 123456789 or 0123456789\nExample 3\nCreate a regular expression for the following description:"
            },
            {
                "text": "\n\"^(?!0$)(?!1$)(?!1.$)(?!2$)(?!3$"
            },
            {
                "text": " (0|1|654321|+00|+10|+20|+30|+40"
            },
            {
                "text": "\n[0-9a-zA-Z]+\\.?[0-9]+\n\nExercise"
            },
            {
                "text": "\n^([0- 9]{3})\\.?(10|1(?:[0-8]"
            },
            {
                "text": " [0-9] [0-9]$\n- \"\\d.\\d\" Match these as dec"
            },
            {
                "text": " [0-9]{0,3}.[0-9]{0,3}\n\nHow"
            },
            {
                "text": "\n^\\d*\\.\\d*|\\d*\\.\\d+$\n\nA:\n"
            }
        ]
    },
    {
        "expression": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "raw_prompt": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL.",
        "refined_prompt": "Simple regex to match the query part of a string. Meaning, anything after the \"?\" at the end of an URL.\nMatch examples:\n- \"?key=value\"\n- \"?key1=value1&key2=value2\"\n- \"?hello=hola\"\nNon-match examples:\n- \"key=value\"\n- \"?key=value&\"",
        "matches": [
            "?key=value",
            "?key1=value1&key2=value2",
            "?hello=hola",
            "?regex=eval",
            "?12345=6789",
            "?go=irish",
            "?website=90000",
            "?cool=aka",
            "?314=CSE",
            "?xxxxxxxx=yyyyyyyyyyyyyy",
            "?1a2b3c=abcd1234",
            "?value=key",
            "?gGGg=h83z"
        ],
        "non_matches": [
            "key=value",
            "?key=value&",
            "?hello",
            "?",
            "key",
            "?key=value=key",
            "?key=value.",
            "?key.value",
            "?<key=value>",
            "?<key>=<value>",
            "??key=value",
            "?key?=value"
        ],
        "id": 1621,
        "output": [
            {
                "text": "\n[a-zA-Z0-9\\?=,&=]{3,10}\n\n\nQuestion 4: Write a regular expression"
            },
            {
                "text": " If the text is of the form \"?key=value.key2=value.key3=value.key4=value.val...\" ("
            },
            {
                "text": " \"^\\?(\\w+)=([^&]+)$\"\n\n4. Create a function extract_query_params(url) that"
            },
            {
                "text": " * [^-\\/?&=]*\n\nYou can use this Regular Expression in Python to check whether the given String has a \"?\" in it"
            },
            {
                "text": "\n^http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@."
            },
            {
                "text": " \n(?<=?=_)[^]=]+[^&=?]+$\nExplanation:\n(?<=?"
            },
            {
                "text": "?([^)]+)\n\n5. Write a regular expression to match a file name that starts with a letter and is followed by one or more digits"
            },
            {
                "text": " \"[^?]*\"\n\nA:\n\nThis regex will match the part after what came before the = sign\n^(?=.*="
            },
            {
                "text": "?(\\w+)=(\\w+)&\n- The pattern will group the part after the \"?\", in our case after the \"value=\","
            },
            {
                "text": " [a-zA-Z0-9_\\-]+\\/[a-zA-Z0-9_\\-]+\\/[0-"
            }
        ]
    },
    {
        "expression": "^[^\\x00-\\x1f\\x21-\\x26\\x28-\\x2d\\x2f-\\x40\\x5b-\\x60\\x7b-\\xff]+$",
        "raw_prompt": "Matches common ASCII names without special characters.",
        "refined_prompt": "Matches strings without any special characters, except periods and apostrophes.\nMatch examples:\n- \"Sir. Isaac Newton\"\n- \"Tom O'Leary\"\n- \"hello\"\nNon-match examples:\n- \"Mar!y Ann\"\n- \"Bob_1\"",
        "matches": [
            "Sir. Isaac Newton",
            "Tom O'Leary",
            "hello",
            "MyNameIs...",
            "'he said'",
            ".'.'",
            "Mr. Smith the Third",
            "...Hello...",
            "family's",
            "The Password is ...",
            "and so they 'ran'",
            "Mr. O'Malley",
            "'''"
        ],
        "non_matches": [
            "Mar!y Ann",
            "Bob_1",
            "~!@#$%^&*()_+=-0987654321`{}[]",
            "\\;:\"<>?,/",
            "Mr. Smith the 3",
            "<website>",
            "1+2=3",
            "\"good job\"",
            "list of:",
            "\"To Kill a Mockingbird\"",
            "variable_name",
            "{5}"
        ],
        "id": 1625,
        "output": [
            {
                "text": " Matches strings with no special characters, any period or apostrophes, except for a capital letter. \n\nExercise 3: Use negative lookahead to create a RegEx to match strings that don't have an's' following it: \nExample"
            },
            {
                "text": " The regular expression for this description is \"Bob_.*$\" \n3. Create a function that takes a string as a parameter and replaces all occurrences of the word \"cat\" with \"dog\". Make sure that the function is case-insensitive.\n``"
            },
            {
                "text": " The RegEx can be '^[a-zA-Z0-9]+$', which only matches strings consisting of alphanumeric characters except the underscore '_' and period '.'.\n\nExercise 3:\nCreate a regex that matches phone"
            },
            {
                "text": ".([0-9]+)\n\nExercise 4:\nWrite a regular expression that replaces all the numbers between 1 and 9 with words like \"one\", \"two\", \"three\", etc.\nAnswer: (?<=\\d)([0123"
            },
            {
                "text": " (Regex101)\n```\n\n**Chapter 4: RegEx Functions & Methods**\n\nThere are many functions provided by `re` module for performing various tasks related to regular expressions in Python. Some of these are:\n- `match()`"
            },
            {
                "text": "\n[^a-zA-Z_\\-. ]+\n\nLecture Note: 5.5.1 File Types and Formats\n\nContents:\n- Introduction to File Types and Formats\n- Overview of Common File Formats\n"
            },
            {
                "text": " Regex for this description: [A-Z][a-z]+[0-9]{1,2} (optional)\n\n[Scene: A room with students working on an exercise book. Suddenly, a commotion can be heard outside.]\n"
            },
            {
                "text": "\nRegular expression: (?:\\[.*\\])*[A-Z][a-z]*\nDescription: [A-Z] matches any capital letter, [a-z] matches any lowercase letter, and [.] matches any period (only"
            },
            {
                "text": " \"(?i)[A-Za-z][_-.]{3,}\", \"^[A-Z][a-z]+(?:-[A-Z][a-z]+(?:/[A-Z][a-z]+)*"
            },
            {
                "text": " [name].name@[domain].com\n\nExercise 3:\n\nCreate a Python code for generating a Regexp that matches email addresses and returns \"EMAILADDRESS\" if the email address is passed. Otherwise, return \"NON_"
            }
        ]
    },
    {
        "expression": "^((192\\.168\\.0\\.)(1[7-9]|2[0-9]|3[0-2]))$",
        "raw_prompt": "This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses. I created this expression for Google Analytics to filter out hits from our companies office.",
        "refined_prompt": "This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses.\nMatch examples:\n- \"192.168.0.17\"\n- \"192.168.0.24\"\n- \"192.168.0.32\"\nNon-match examples:\n- \"192.168.0.16\"\n- \"192.168.0.33\"",
        "matches": [
            "192.168.0.17",
            "192.168.0.24",
            "192.168.0.32",
            "192.168.0.30",
            "192.168.0.19",
            "192.168.0.18",
            "192.168.0.25",
            "192.168.0.31",
            "192.168.0.27",
            "192.168.0.20",
            "192.168.0.26",
            "192.168.0.22",
            "192.168.0.23"
        ],
        "non_matches": [
            "192.168.0.16",
            "192.168.0.33",
            "192.168.0.12",
            "192.168.0.36",
            "192.168.0.39",
            "192.168.0.10",
            "192.168.0.11",
            "192.168.0.44",
            "192.168.0.49",
            "192.168.0.45",
            "192.168.0.90",
            "192.168.0.57"
        ],
        "id": 1636,
        "output": [
            {
                "text": " ([0-9]{1,3}\\.){3}[0-9]"
            },
            {
                "text": " \n\"[0-9]{1,3}\\.[0-9]{1"
            },
            {
                "text": " Generate a series of RegEx to match a block range of 16 addresses (168.0"
            },
            {
                "text": " Use \"\\d{4}\\.\\d{1,3}\\.\"\\d{1"
            },
            {
                "text": " [0-9].*[0-9].*[0-9].*["
            },
            {
                "text": " \"(?i)\\b(?:([0-9]{2}|(?:1"
            },
            {
                "text": " The regex should match addresses between 192.168.0.16 and 192.168.0"
            },
            {
                "text": " \n\nIP Range pattern: (192\\.168\\.0\\.){3}\\.["
            },
            {
                "text": " \nTo generate a RegEx for \"non-match examples\", you could say: "
            },
            {
                "text": " \\d{1,3}\\.\\d{1,3}\\.\\d{"
            }
        ]
    },
    {
        "expression": "^(\\$)?((\\d{1,5})|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{1,2})?$",
        "raw_prompt": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with , sign.",
        "refined_prompt": "This regular expression is used for validating five-digit numeric values. A $ can precede the value, and a comma or decimal may separate digits.\nMatch examples:\n- \"80,000.00\"\n- \"80,000\"\n- \"80000\"\nNon-match examples:\n- \"800,00.00\"\n- \"80.000\"",
        "matches": [
            "80,000.00",
            "80,000",
            "80000",
            "80.00",
            "$80000.00",
            "52",
            "$87777",
            "$8.00",
            "04300.00",
            "$12345",
            "3.14",
            "1,000",
            "23,000,000,000.00"
        ],
        "non_matches": [
            "800,00.00",
            "80.000",
            "$8,0000.00",
            "34,333,555,678.000",
            "1,00",
            "$0.",
            "$0.000",
            "0,0",
            "$000000",
            "$45.331",
            "1,2.98",
            "600321"
        ],
        "id": 1638,
        "output": [
            {
                "text": " (\\b\\d{5},\\d+\\b)\n- \"80.00\"Generate a RegEx for this description. \nAnswer: (?"
            },
            {
                "text": " Regular expression: /^\\d{5}(,\\d{3})?$/\n2. Write a RegEx for matching email addresses. \nAnswer:"
            },
            {
                "text": " /^^(\\d{5}),(.\\d{3})?$/\n\n---\n\n**Exercise 2**: Write a python function which takes"
            },
            {
                "text": " \n\n    value = [ 0-9]{1,}(\\.[0-9]{1,2})? # this will match positive or negative infinity and 0"
            },
            {
                "text": "\nregex expression for validating five-digit numeric values\n\nExercise: \nCreate a Django form using the RegEx pattern generated in the last exercise for validating"
            },
            {
                "text": " A regular expression for checking non-numeric values would be \"^[0-9,]{1,3}(?:\\.[0-9,]{3"
            },
            {
                "text": " \n^[0-9,-]{4}\\.[0-9,-]{4}$\n\nExercise 3: Rewrite the following regular expression without using"
            },
            {
                "text": " \\d\\d\\d\\d,\\d{2}\n\n3. A common problem in data cleaning is having empty strings in the dataset which may lead to inaccurate"
            },
            {
                "text": " ^\\d{5,}(,\\d{3})?$\n\n3. Write a Python function that validates a given registration token, assuming it is generated"
            },
            {
                "text": " r'^\\d{4}(,\\d{3})?$|^\\d{4}$'\n\nExercise 2: \nRegular expressions"
            }
        ]
    },
    {
        "expression": "^(([0-9])|([0-2][0-9])|([3][0-1]))\\/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.\nMatch examples:\n- \"1/Feb/2007\"\n- \"03/Jun/2007\"\n- \"31/Dec/2007\"\nNon-match examples:\n- \"1/2/2007\"\n- \"03/Jun/07\"",
        "matches": [
            "1/Feb/2007",
            "03/Jun/2007",
            "31/Dec/2007",
            "25/May/7726",
            "31/Apr/5406",
            "7/Jan/4020",
            "00/Oct/7040",
            "6/Dec/9367",
            "31/Nov/0749",
            "1/Dec/9614",
            "07/Jan/2265",
            "31/Aug/8328",
            "08/Jul/7944"
        ],
        "non_matches": [
            "1/2/2007",
            "03/Jun/07",
            "31-Dec-2007",
            "6/aug/8088",
            "30/oct/3223",
            "5 May 7665",
            "07-Jan-5279",
            "0:Jul:3108",
            "13-June-3201",
            "6/december/7172",
            "31/04/7372",
            "07/nov/8152"
        ],
        "id": 1642,
        "output": [
            {
                "text": " ^(1|2)\\d/\\w{3}\\d{4}"
            },
            {
                "text": " (1[0-9]|2[0-9])\\/[A"
            },
            {
                "text": " (.{3})/(?:[^/]+)/([0-9]"
            },
            {
                "text": " \n\\d{1,2}/\\w{3}\\d{"
            },
            {
                "text": " You can add a positive lookahead here to only allow two consecutive matches.\n\n"
            },
            {
                "text": " [\\d]{2}([a-z]{3})/\\"
            },
            {
                "text": " ^(?:[12][0-9]|1?[012])/("
            },
            {
                "text": "\nThe function should use a regular expression to identify if each test is either of the"
            },
            {
                "text": "\n\nimport re\n\ntext = \"1/Sep/2007 2/Jul"
            },
            {
                "text": "\n- (^\\d/[a-zA-Z]{2"
            }
        ]
    },
    {
        "expression": "^((4(\\d{12}|\\d{15}))|(5\\d{15})|(6011\\d{12})|(3(4|7)\\d{13}))$",
        "raw_prompt": "Matches Visa, American Express, Discover, and Mastercard only.",
        "refined_prompt": "Matches Visa, American Express, Discover, and Mastercard only.\nMatch examples:\n- \"4111111111111\"\n- \"4111111111111111\"\n- \"5111111111111111\"\nNon-match examples:\n- \"411111111111\"\n- \"51111111111111111\"",
        "matches": [
            "4111111111111",
            "4111111111111111",
            "5111111111111111",
            "6011111111111111",
            "341111111111111",
            "371111111111111",
            "6011480234638632",
            "345883893201887",
            "376664979664283",
            "5090201478642631",
            "4951575838177",
            "4726635308257825",
            "6011893825943075"
        ],
        "non_matches": [
            "411111111111",
            "51111111111111111",
            "6111111111111111",
            "321111111111111",
            "381111111111111",
            "1312673751724778",
            "2990655926408554",
            "7011461924759324",
            "1183312333560",
            "2575647296682975",
            "1783923266016891",
            "1813360266849221"
        ],
        "id": 1643,
        "output": [
            {
                "text": " \nimport re\npattern = '\\d{4}-\\d{4}-\\d{4}'\nmatch_list = [] \n\nfor card in [\"4415-4415-4415\",\""
            },
            {
                "text": " [^0-9]\n\n##Example\nIf you're processing a large stack of document data (such as a PDF or HTML document), and you frequently need to extract specific data tags, such as <p>, you could use"
            },
            {
                "text": " Use \"(^[1-9]1[0-9]999$|^[1-9]1[0-9]$)^$\"\n\nExercise 2: Find email patterns in text data\nEx"
            },
            {
                "text": " [Example RegEx]: \"^4[1-9]\\d{9}$\"\n\n**Exercise 2:**\nCreate a RegEx that will match all phone numbers in the format of (xxx) xxx"
            },
            {
                "text": " \\d{16} for Visa, American Express, Discover, and Mastercard only, ^\\d{16}\\$ for any other credit card brand.\n\nExercise 2: \nCreate a RegEx of length 16 for"
            },
            {
                "text": " \n```Python\nimport random\nimport re\n\n \ndef generate_password(length: int=10, chars: set=string.ascii_letters):\n   password_str = ''.join(random"
            },
            {
                "text": " \"^\\d{5}$\".\n\n[Exercise 3]\n- Write a Python script to find all the URLs that mention the term \"dog\" in a webpage. \n- For URLs within the webpage, use"
            },
            {
                "text": " \"4\\d{11}\"\n\nExercise 3: Write a program that prints a formatted list of names, phone numbers, and email addresses entered by the user. The program should separate the entries into different lines and use RegEx"
            },
            {
                "text": " \n[^0-9] - all characters except the numbers\n\"9*\" - Matches a sequence of 9's (in this case, just the entire pattern)\nExercise 4: \nCreate a RegEx"
            },
            {
                "text": " \"^4[1-9][0-9]{0,3}$|^5[1-9][0-9]{0,3}$\"\n\nExample 2: Find all phone number starting with"
            }
        ]
    },
    {
        "expression": "^\\{?[a-fA-F\\d]{32}\\}?$",
        "raw_prompt": "Matches only a 32 character hex string (Eg. MD5). Based off Chris Craft's expression:-)",
        "refined_prompt": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe92611A4BF46A9\"",
        "matches": [
            "09f8814c757a00f14efdb70e45f851d1",
            "F11EBc9BF0A1Ac45722ce31BF300C6Bb}",
            "638b2a7fFf4755346A4e45FC691ccB1D}",
            "{8F8beeaee6EeB91e922b8AD5C1fCe6Ec}",
            "AC0bDE9Ea4f8768d5fb19eC933FF3fAC",
            "{89c1483b2eeCf59CF82c4bd7b3B2Bcb9}",
            "3f7eA8bcDbeC4Cce76bB1B9afDC8ae59",
            "2BC01549C9734256C26A4F11B6e892A2",
            "{241dBd13BAEAeDf9E1AAa35Ef8bE391A",
            "eAbD53e60B468cAa0C872ed7F352b6a8",
            "e151f44B2A1Eb31Dbed62cD5a0dAf78E",
            "{FACb0F8cEdfEfFAEDD5AFFe4cF6B7AeC",
            "0ad1ED3cc3Da1D0FeFaAbbaA924bAaCa}"
        ],
        "non_matches": [
            "46345678901234567890aaaabbbbbbzj",
            "3Db1D07b8fC556fe92611A4BF46A9",
            "E1aFc46E003Ebc1E11a45Ee2f",
            "hello",
            "{11111111111111111111111111111111@",
            "{B6}",
            "fcD27ECb5e}",
            "{0Cc5b3ABfCE872FcB0a",
            "{A}",
            "dCA31de6B76cCc46D4C8ED86FFFEfDaaAA3d8e05",
            "{8c2A79cCAFedbB0aaE9ee27C56F3FCFc79c8BbB0bD7Aeba6d5c840Bd6Ad22bAddC6BC207D5A8BD}",
            "BeBb6a4EeEB8Ca7fd483dFE9f3cfbAfbBfEbebb3caFdC457}"
        ],
        "id": 1644,
        "output": [
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926f"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926b"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926a"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926F"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe92645"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926e"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926b"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926c"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926b"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe92645"
            }
        ]
    },
    {
        "expression": "^(9\\d{2})([ \\-]?)([7]\\d|8[0-8])([ \\-]?)(\\d{4})$",
        "raw_prompt": "U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash or no separators.",
        "refined_prompt": "U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash, or no separators.\nMatch examples:\n- \"900700000\"\n- \"900 70 0000\"\n- \"900-70-0000\"\nNon-match examples:\n- \"899700000\"\n- \"77278 4873\"",
        "matches": [
            "900700000",
            "900 70 0000",
            "900-70-0000",
            "966-81-7357",
            "901776136",
            "92175 0658",
            "951834540",
            "972 866756",
            "909-718786",
            "920 773719",
            "91671 2174",
            "971-77-5980",
            "967862987"
        ],
        "non_matches": [
            "899700000",
            "77278 4873",
            "900-89-0000",
            "900-69-0000",
            "146835563",
            "07485 4569",
            "288841640",
            "17183 1484",
            "361-84 4742",
            "212 757446",
            "34",
            "416-86 5000"
        ],
        "id": 1653,
        "output": [
            {
                "text": " (\\d+)[A-Z0"
            },
            {
                "text": " [0-9]{3}(["
            },
            {
                "text": " [^][\\s-]\\S"
            },
            {
                "text": " To match numbers that begin with 900-70"
            },
            {
                "text": " \"900700000\", \"900-70"
            },
            {
                "text": ".\\s[1-9]\\"
            },
            {
                "text": "\n[^0-9 -\\n"
            },
            {
                "text": " \\d \\d-\\d 9-"
            },
            {
                "text": " \n^#[0-9]"
            },
            {
                "text": " (\\d+)[ -\\d]"
            }
        ]
    },
    {
        "expression": "^(?:((31\\/(Jan|Mar|May|Jul|Aug|Oct|Dec))|((([0-2]\\d)|30)\\/(Jan|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))|(([01]\\d|2[0-8])\\/Feb))|(29\\/Feb(?=\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))\\/((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "Matches dates in the form of DD/MMM/YYYY. It also handles leap years. Days are 2 digits; months are case sensitive with first character upper-case and next 2 characters lower-case; year is 4 digits.",
        "refined_prompt": "Matches dates in the form of DD/MMM/YYYY. It also handles leap years. Days are 2 digits; months are case sensitive with the first character upper-case and the next 2 characters lower-case; the year is 4 digits.\nMatch examples:\n- \"01/Mar/2007\"\n- \"16/Dec/2007\"\n- \"29/Feb/2008\"\nNon-match examples:\n- \"1/Mar/2007\"\n- \"16/Dec/07\"",
        "matches": [
            "01/Mar/2007",
            "16/Dec/2007",
            "29/Feb/2008",
            "30/Dec/3126",
            "31/May/2121",
            "30/May/1888",
            "15/Feb/1630",
            "20/Feb/3288",
            "31/Mar/1822",
            "22/Jul/1953",
            "30/Jun/3242",
            "28/Feb/1602",
            "30/Nov/1762"
        ],
        "non_matches": [
            "1/Mar/2007",
            "16/Dec/07",
            "29/Feb/2007",
            "4/Feb/1999",
            "31-Jan-6340",
            "Dec 1 1876",
            "30/oct/1887",
            "31/March/1844",
            "31/july/5438",
            "2003/Jan/26",
            "30 Jun 1985",
            "31,Aug,7241"
        ],
        "id": 1654,
        "output": [
            {
                "text": " [0-9]{2}\\"
            },
            {
                "text": "\n[0-9][0-"
            },
            {
                "text": " [^0-9]\\\\w"
            },
            {
                "text": " \nDD/MM/YYYY"
            },
            {
                "text": " the regular expression would be:\n^"
            },
            {
                "text": " This will solve the problem of leap days"
            },
            {
                "text": " \\b[0-9]{"
            },
            {
                "text": "\n(0?[1-9"
            },
            {
                "text": " \n^((1[0-"
            },
            {
                "text": "^?(1[0-2"
            }
        ]
    },
    {
        "expression": "^((\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)\\s*[,]{0,1}\\s*)+$",
        "raw_prompt": "This will validate multiple email addresses that are comma delimited. You can change it to use commas or semilcolons. If you have to worry about a lot of special characters, you may have to edit it a little bit. It allows white space before and after the comma.",
        "refined_prompt": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com , email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"",
        "matches": [
            "Test@host.com",
            "email1@host.com,email2@host.com,email3@host.com",
            "email1@host.com, email2@host.com , email3@host.com",
            "student@school.org",
            "teacher@school.org dog@daycare.com",
            "123456789@numbers.edu",
            "123456789@numbers.edu numbers@123456789.gmail",
            "1W@GMAIL.COM",
            "ALL@CAPS.MORE, lower@caps.edu, hi@bye.com",
            "1a2c4hw5@6789.gov",
            "q@q.ph",
            "dog@daycare.com 1W@GMAIL.COM, student@school.org q@q.ph",
            "2@2.c, ejrfhelrfhehh@sdhjbedjf.k"
        ],
        "non_matches": [
            "test@test",
            "test@host.com,test@",
            "test@ host.com",
            "@",
            "@.com",
            "hello.com",
            "john @ gmail.com",
            "john.gmail.com",
            "hello!@school.edu",
            "hello@school!>>>.edu",
            "hello@school.22$",
            "h@@h.gov"
        ],
        "id": 1656,
        "output": [
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: (([^\\s,](["
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: \"^[a-zA-"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer:\n^test@.*\\.com$"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: [^\\\\d\\\\w\\\\s"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: [^\"]*\"\nExample"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: matches anything separated by one or more comm"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: test@(0|[1-"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer:  \"^[^(]*"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: \n\n\n```python\nimport"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: test@\\.(\\w+)\\"
            }
        ]
    },
    {
        "expression": "(?=^.{8,}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s)[0-9a-zA-Z!@#$%^&*()]*$",
        "raw_prompt": "This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.",
        "refined_prompt": "This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.\nMatch examples:\n- \"Password1\"\n- \"1Passwor\"\n- \"passworD1\"\nNon-match examples:\n- \"q3w4e5er\"\n- \"asdfg\"",
        "matches": [
            "Password1",
            "1Passwor",
            "passworD1",
            "2passWord",
            "Pass2Word",
            "pa1SS2word",
            "!1qAzxsw2",
            "2T@4ep1pVJmza2Ly8",
            "HorDBlMafTTyQOJmJcXXyqUiXo%6WxvKuiJoql@t",
            "d&W)*aVP0%yqd@",
            "gT3fOV)Okf6nKqe",
            "y78jXLETeg%Cc7tm!BryfPOvm5EEnLhBpn",
            "@&j#CV4rzOlbg1g"
        ],
        "non_matches": [
            "q3w4e5er",
            "asdfg",
            "asdfghjkl;",
            "ag asg ag",
            "d36234724",
            "mko)+OKM1",
            "jjjjjjjjjjjjjjjj112",
            "hello",
            "123456789",
            "cv34a678@",
            "---4uhfqlehA",
            "jfejlwerbjhewrj5874"
        ],
        "id": 1657,
        "output": [
            {
                "text": " The RegEx would be"
            },
            {
                "text": " [\\Aabcdef"
            },
            {
                "text": "\n\nimport re\n"
            },
            {
                "text": " \n^(?"
            },
            {
                "text": " The RegEx should begin"
            },
            {
                "text": " The first regex can be"
            },
            {
                "text": " [abcdefghij"
            },
            {
                "text": " ^(?=.*"
            },
            {
                "text": " [a-z]"
            },
            {
                "text": " \nimport re\n"
            }
        ]
    },
    {
        "expression": "<body[\\d\\sa-z\\W\\S\\s]*>",
        "raw_prompt": "This will find the open body tag regardless of any properties or Event Handlers associated with it. This is great for global implementations of analytics or anything that needs to be placed after the body tag.",
        "refined_prompt": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"bodyd\\\u2029bc\u180e|H@AwO\"",
        "matches": [
            "<body>",
            "<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>",
            "<bodyb`)>",
            "<bodyN>~ej`\u202fw}f:Q\\s+:z\f\u20026_p\u180e8S^Xt",
            "<bodyCv\u180e\u2006d3\f;o\u1680_\u2002QF|\u2004>",
            "<body+w3d Nig~c\f]q4+6\u180eU{/qgkoB{d&vh`}la.j]BhX\ttYshJ\u00a0sd0\u2002lq^\u000bl(>",
            "<body.\u202fl>",
            "<bodygi\u2001>",
            "<body\"tEi\u1680l\u2003za[>",
            "<body)N]`|\"/oN]O_tqBvA[f\u00a0^n@tKW>",
            "<bodyb0w%s3{<\t6,I*oWhXbg;-mjm\ufeff\u2004\u2029w8Cv{\u16807\u205f1{.nO>",
            "<bodyY+\"y`vtKH\u00a0c,IVe$m\u2029N[sE{:}hj?h\u2003q0p{op>",
            "<bodyM0|kQ1}2TSym\u2000%\u180e\f\u205f\u2007 g`RTP=;alu\u000bP\u180eNlgil9t7}[\\rxnr\u2006\u2004Vi\u1680rpdp\u2006_ gIMS]\u00a0~_|osgE+\u2005]=\u1680\u205fwuOg'j\u1680\ufeffmk<[rd6kJ>"
        ],
        "non_matches": [
            "<br>",
            "bodyd\\\u2029bc\u180e|H@AwO",
            "body{s2\u2006D>",
            "l`g \tjV\u205f,|d7$/8}fj`@?~:JqgkAB\u2007ho\ufeff\u2028-GW=jp W ^\u202fkfxVcy[tD\"xjo23_l-F>",
            "^c]]\u2028Yx\u200a}\u2000\u2008QrE4%-8j,D~a-6x",
            "^c]]\u2028Yx\u200a}\u2000\u2008QrE4%-8j,D~a-6x",
            "fN}n",
            "v'\\/Q\u000b?12oh",
            "oj",
            "^c]]\u2028Yx\u200a}\u2000\u2008QrE4%-8j,D~a-6xbodyZ\"X\fy\u2009Ys<{'P:",
            "bodye\u2003||\u2003\u2029V\u2003.^n\u000b\u2009&]t\u2005lb\u2008\u2000\ufeffXrg",
            "&!--iVpOCz]oik\u20071!\u2005rRGk3@Uwf7\\nNZ\ufeff6a"
        ],
        "id": 1658,
        "output": [
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body<"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"bodya"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\\"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"bodybr"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body>"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"bodyp"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body tag"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"bodyb"
            }
        ]
    },
    {
        "expression": "^((\\.)?([a-zA-Z0-9_-]?)(\\.)?([a-zA-Z0-9_-]?)(\\.)?)+$",
        "raw_prompt": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _\nI was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.",
        "refined_prompt": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.g..1...Kb...n.A..o..r.....v..o.lb-.t.l.U....z.V...W..e..H......p..2.tfeDA.4.S...g.....UH.\"\n- \".I.E..Z.n.d.1.n..mp.2e.J..vAA.C..V...k..F...i.Q.x.F.2..g.N.._Q...h..v.N...5.L.j.x..f..J..._M...Y..5_..j1..W.x..M..n.....A.I..5...6...Yb...\"\nNon-match examples:\n- \"special charachters\"\n- \"hhhhhh jjj\"",
        "matches": [
            "_-.aAa._-.aAa_-.",
            ".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.g..1...Kb...n.A..o..r.....v..o.lb-.t.l.U....z.V...W..e..H......p..2.tfeDA.4.S...g.....UH.",
            ".I.E..Z.n.d.1.n..mp.2e.J..vAA.C..V...k..F...i.Q.x.F.2..g.N.._Q...h..v.N...5.L.j.x..f..J..._M...Y..5_..j1..W.x..M..n.....A.I..5...6...Yb...",
            "...OZ.n..f..Q...oh.....Qm.-.b.",
            "8L.....8.9..z....RuO",
            "..-G.Mmh.i.0.L..t....AV.",
            "i...QA.8..e...MV.jY..u.F",
            "..1.",
            "d.rT..MZ.tQ......fY..C.O6.G..y.S.O....A3z",
            "Xv..Z..-..A.y.1.XE",
            "A..UP.UU.L.1..8...u...u.o.fY...D..A.P.x..H.L...f.6l....",
            "A....b..qq.4.3.L7...S.z...IW...c......-C.B..m.....1..",
            "b.n..p4..tK.yd.3."
        ],
        "non_matches": [
            "special charachters",
            "hhhhhh jjj",
            "... nsd",
            "1 2 3 4 5",
            "#$%@",
            ".....444fef454#",
            "000000 8888",
            "jhhiweh73497&..   edicb",
            "yyyw()",
            "....yyy778i_+",
            "::::",
            "iu2r&43jh"
        ],
        "id": 1660,
        "output": [
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.F"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.I"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.E"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.n"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.R"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.o"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.G"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.f"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.N"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.F"
            }
        ]
    },
    {
        "expression": "(\\s{1,})",
        "raw_prompt": "Matches all chars that are made up of one or more spaces. I found this useful when people were trying to make string length bypasses using consecutive spaces.",
        "refined_prompt": "Matches all strings that are made up of one or more spaces.\nMatch examples:\n- \"(one or more spaces)\"\nNon-match examples:\n- \"non-space\"\n- \"sf\"",
        "matches": [
            "(one or more spaces)"
        ],
        "non_matches": [
            "non-space",
            "sf",
            "er45",
            "000",
            "^^^^",
            "#welfk",
            "_____.",
            ".....",
            ",,",
            "errvTT",
            "<>",
            "0.000"
        ],
        "id": 1662,
        "output": [
            {
                "text": " \"(one or more spaces)(not space)\"\n\n3. Define the string variable:\ntext = \"The quick brown fox jumps over the lazy dog.\"\n\n4. Replace all instances of the word \"the\" in the string with the word \"woo\":\nregex = r\"\\bthe\\b\"\nprint("
            },
            {
                "text": " r'(?P<one_or_more_spaces>\\s*)\\S*'\n- \"not (non-space)\" match is fine\n\nExercise 3: Match the word\nWrite a Python script that takes a string argument and matches whether every word in the string is the word \"dog\".\nExercise 3"
            },
            {
                "text": " a) (one or more spaces)\n\n##### Exercise 2: \nCreate a RegEx to extract email addresses from a list of names.\n``` python\nnames = ['Alice Brown', 'John Smith', 'Bob Marley', 'Miles Davis']\nemail_regex = '\\b(\\w+)\\.(\\"
            },
            {
                "text": " (^ | ){1}non-space\n\n- \"(one or more spaces) or (one or more non-spaces)\"\nMatch examples:\n- \"(one or more spaces) or one or more non-spaces\"\nNon-match examples:\n- \"abc \"\n- \"abc \"def\"\n\n-"
            },
            {
                "text": "\n(?<![^[:space:]])([a-z]){3,}(?![^[:space:]])\n\n4. Write a Regex that matches all words that have exactly three letters. \nAnswer:\n\\b[a-z]{3}\\b\n\n5. Write"
            },
            {
                "text": " \n(?=\\s{1,})(?=\\S)\n\nA:\n\nWith your shown samples, please try following regex.\n^\\s*(?:\\S\\s*)+$\n\nExplanation: In case you want to match string of at least 1 occurrence of spaces (\\s*"
            },
            {
                "text": " \\S+\n\n2. Write a regular expression that will find a MAC address in a given string.\n\nSolution: \\b\\d{3}-\\d{3}-\\d{4}\\b\n\nThe regex \\b matches any word boundary followed by three digits followed by a hyphen, and then another set of"
            },
            {
                "text": " [\\s]+\n\n4. Given a string s, find all the words which are composed of only lower case English letters.\nHint: Use the ^ character to mark the beginning of a word.\nSolution:\ndef word_filter(s):\n    pattern = \"^[a-z]+$\"\n    # Use"
            },
            {
                "text": " (one or more spaces)\n\nEx3:\n(1 - 10) [0-9]+\n\nThis matches numbers between 1 and 10 that contain one or more 0's between them.\n\nEx4:\n[0-9]+ (1 - 10) [0-9]+\n\nThis matches numbers between 1 and 10"
            },
            {
                "text": " [one or theore]* spaces\n\n3. Write a Python script that prints all the matches from the RegEx generated in exercise 2 using string slicing.\n\n```python\nimport re\n\nmatches = re.findall( r'\\(one or theore\\)\\*', \"1. ( one or theore"
            }
        ]
    },
    {
        "expression": "[-]?[1-9]\\d{0,16}\\.?\\d{0,2}|[-]?[0]?\\.[1-9]{1,2}|[-]?[0]?\\.[0-9][1-9]",
        "raw_prompt": "Needed to be able to validate positive and numeric values that equate to SQL Server data type decimal(18, 2) but the value could not be 0. This regex does that. If you need to change the precision or scale have at it.",
        "refined_prompt": "Validates positive and numeric values that equate to Structure Query Language (SQL) Server data type decimal(18, 2). The value can not be 0, and negative values can be represented using a dash.\nMatch examples:\n- \"-9999999999999999.99\"\n- \"9999999999999999.99\"\n- \"1\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "-9999999999999999.99",
            "9999999999999999.99",
            "1",
            "1.00",
            "0.52",
            "0.02",
            "236481161166",
            ".1",
            "0.11",
            "762.",
            "9018704677.9",
            "-.5",
            "-731547141.3"
        ],
        "non_matches": [
            "0",
            "0.0",
            "0.00",
            "0000",
            ".0",
            ".000000",
            "-0",
            "+0",
            "-0.0",
            "+0.0",
            "$",
            "."
        ],
        "id": 1663,
        "output": [
            {
                "text": " \n^(?=[\\d\\.]*$).*(?:[,-]|\\\\.)[.-_0-"
            },
            {
                "text": "  decimal([0-9]+(\\.[0-9]{1,2})?|0[.][0"
            },
            {
                "text": " \"^[0-9]+\\.[0-9]{1,2}$\" \n\nExercise 2:"
            },
            {
                "text": "\n^(?!0\\.[^0]+$).*?((-?\\d*?)-?(-?\\d"
            },
            {
                "text": " \n-^[1-9][0-9]\\d*[\\.]?$\nExercise:  Write"
            },
            {
                "text": " I need to check the given strings to check that they are either one or more than 9 digits. And I have to add an optional"
            },
            {
                "text": " [^0-9.]+. You could then execute this with the following: \n\n\"WORD_VALUE REGEXP '"
            },
            {
                "text": " ^\\d+(\\.\\d+)?$\n\n3.) Write a query that retrieves all the records where the \"age"
            },
            {
                "text": " [^0-9]|[0-9.]\n\nExercise 5:\nWrite a RegEx pattern to match a"
            },
            {
                "text": "  (0|[1-9]|[1-9][0-9]*)\\.0+\n\nExercise"
            }
        ]
    },
    {
        "expression": "^[A-Z\u00c4\u00d6\u00dc]{1,3}\\-[ ]{0,1}[A-Z]{0,2}[0-9]{1,4}[H]{0,1}",
        "raw_prompt": "This one checks if the value is a possible german License Plate. The trailing H stands for Historical cars.",
        "refined_prompt": "This regex checks if the value is a possible german License Plate. The trailing H stands for Historical cars.\nMatch examples:\n- \"F-RM373, W\u00dc-Z1, K- 07333,HN-WK11H\"\n- \"NZ- PQ9954H\"\n- \"LV- IA47H\"\nNon-match examples:\n- \"MOS-AS\"\n- \"hhg\"",
        "matches": [
            "F-RM373, W\u00dc-Z1, K- 07333,HN-WK11H",
            "NZ- PQ9954H",
            "LV- IA47H",
            "Q-KS81H",
            "R-SA69H",
            "JJR-N88H",
            "YQ- OT0",
            "B-6",
            "H- RD80",
            "XLZ-DX0042H",
            "F- DG707",
            "VO-C6586H",
            "LF-696H"
        ],
        "non_matches": [
            "MOS-AS",
            "hhg",
            "1234",
            "HHH-erjnf",
            ".BO-223*",
            "$$$",
            "lol-09",
            "erk09-55",
            "GGKI-0HGGHGHG",
            "-----",
            "uu-99",
            "hello"
        ],
        "id": 1665,
        "output": [
            {
                "text": " (\"MOS-AS\"|\"MMM-AS\" | \"MMMM-AS\"|"
            },
            {
                "text": "\n(\\w{3}(\\s)\\w{3}(\\s)\\w{2})\n"
            },
            {
                "text": " [A-Z]+[0-9]([A-Z]|(?=[A-"
            },
            {
                "text": "\n[A-Z][A-Z][A-Z][A-Z] \\d{"
            },
            {
                "text": " [K-12][A-Z][0-9]{2}\n\n2. Desc"
            },
            {
                "text": " \"^([A-Z][A-Z-]|K-|L-|F-"
            },
            {
                "text": "\n([A-Z][0-9]{1,7}),([[:alpha:"
            },
            {
                "text": " [A-Z]{4}-\\d{2}|[a-z]\\"
            },
            {
                "text": "\n\\b[A-Z]{3}\\s\\d{2}\\s[A-"
            },
            {
                "text": " \\b(1[6-9]|[1-9]\\d|2[0"
            }
        ]
    },
    {
        "expression": "(a|A)",
        "raw_prompt": "Big or small A letter",
        "refined_prompt": "Capital (A) or lowercase (a)\nMatch examples:\n- \"aaa\"\n- \"aA\"\n- \"Aa\"\nNon-match examples:\n- \"bbb\"\n- \"\u00e0\"",
        "matches": [
            "aaa",
            "aA",
            "Aa",
            "AAA",
            "AaA",
            "aAa",
            "a",
            "A",
            "AAAaaa",
            "aaaAAA",
            "aAaAaA",
            "AaAaAa",
            "aaAaaA"
        ],
        "non_matches": [
            "bbb",
            "\u00e0",
            "\u00e1",
            "\u00e2",
            "\u00e4",
            "\u00e6",
            "\u00e3",
            "\u00e5",
            "\u0101",
            "65",
            "97",
            "\u00c6"
        ],
        "id": 1668,
        "output": [
            {
                "text": " \n\nA: Non-match examples (case sensitive):\n| ^  |  ^  |  ^\n| |  |  |  | a     a case-a\n| b |   b | B | b    b case-b\n| a |  a | A | a    case-"
            },
            {
                "text": " [a-z]\n\n```python\nimport re\n\n# Extract words and matches\npattern = re.compile(r'\\b[a-zA-Z]{3}\\b')\ntext = \"Learn Python for Network Automation\"\nmatches = pattern.findall(text)"
            },
            {
                "text": "\n- Any combination of uppercase or lowercase letters.\n\nExercise 2:\nCreate a RegEx pattern that matches any combination of lowercase and uppercase letters, numbers, and symbols. Use the. character to match any character and any of the specified character sets below.\n\nNon-match examples:"
            },
            {
                "text": " [^b]?[^l]b[^p]\n\n2.\nWrite a Python program to match the regular expressions in the following list.\n\nexpression = [\"hello world\", \"hi there\", \"hey there\", \"helloworld\", \"hi there\", \"helloworld\"]\n\nFor each"
            },
            {
                "text": " \\bA\\w+\\b \n\nExercise 2: Match an Email Address\n- \"johndoe,john@gmail.com\"\n- \"janedoe,janedoe@yahoo.com\"\n\nAnswer: \\b[A-Za-z0-9._%+"
            },
            {
                "text": "\n- https://regex101.com/r/y4lXrZ/2\nI hope this helps!\n\nReply 3:\nOne more way to match strings is to use the re.search() function, which searches the string from the beginning (^) to the end ($) and returns `"
            },
            {
                "text": " Non-match example\n\n\n\nQuestion 3: A rectangular garden has a length of 12 meters and a width of 6 meters. If Jenny wants to increase the length and width by the same amount, and the area of the new garden is 180 square meters, what is the increase amount for both parts of the garden?\n\n"
            },
            {
                "text": " \\b([a-z]|A[a-z])\\b\n\nExercise 2:\nWrite a Python program that takes in a string and capitalizes all alphabetical characters.\nQuestion:\nHow would you approach this in Python?\nAnswer:\nUse the `replace()` method and lowercase the"
            },
            {
                "text": ".{4}\n\n5. Write a RegEx for this pattern: \"ABA\"\nAnswer: A.*?B.*?A\nI hope this helps! Let me know if you have any questions or feedback.\n\nStudent's question on StackExchange:\n\nHi everyone, I attended a lecture"
            },
            {
                "text": " \\b\\w[a-z]\\. \n\nExample of Use:\nimport re\ntext = \"Hello, I am John Smith. Nice to meet you, John!\"\npattern = re.compile(\"\\b\\w[a-z]\\. \", flags=re.IGNORECASE)\n"
            }
        ]
    },
    {
        "expression": "^([A-Z]+[a-zA-Z]*)(\\s|\\-)?([A-Z]+[a-zA-Z]*)?(\\s|\\-)?([A-Z]+[a-zA-Z]*)?$",
        "raw_prompt": "That is just an improved expression for handling capitalized names. Improvement #1 - Allowed using names consisting of 3 parts. Improvement #2 - Introduced restriction that the name must start from capital character.",
        "refined_prompt": "Handles capitalized names. Allows names consisting of 3 parts. Restriction that the name must start with a capital character.\nMatch examples:\n- \"Rana Mohsin Ali\"\n- \"Hello There\"\n- \"Joe John Smith\"\nNon-match examples:\n- \"rana Mohsin Ali\"\n- \"h\"",
        "matches": [
            "Rana Mohsin Ali",
            "Hello There",
            "Joe John Smith",
            "Jo-Do",
            "Tim O-Malley",
            "Mr Third",
            "I Am",
            "Open-Sesame",
            "ToDaY",
            "OKAY",
            "UUyyHHHtte",
            "I LoefykwI-Ee",
            "JJJkkebdn"
        ],
        "non_matches": [
            "rana Mohsin Ali",
            "h",
            "1234",
            "Hello!",
            "Big little",
            "O'Malley",
            "trust-fall",
            "$dollar",
            "Oka y",
            "\"No Way\"",
            "Okay No so",
            "Five Four 3"
        ],
        "id": 1683,
        "output": [
            {
                "text": " re.compile(\".* r.*a.*n.*i.*a.*s.*\")\n- \"Hello There\"Generate a RegEx to compare the user input name against the correct name. \n"
            },
            {
                "text": " ^[A-Z][a-z]+ [A-Z][a-z]+$\" \n\nExercise 9.1: Capitalization\n\nConsider the following sentence:\n\"I love programming"
            },
            {
                "text": " ^[A-Z][a-z][A-Z][a-z]*:$\n\n4. Write a code fragment to print all names that are first names or last names, which includes the initials"
            },
            {
                "text": "\n^[A-Z][a-z]+[A-Z0-9][a-z]+[A-Z0-9a-zA-Z]$\n\"\"\"\n\ndef get"
            },
            {
                "text": "^[A-Z][a-zA-Z0-9]{0,64}(-[A-Za-z0-9]{0,62})*$\n\nA:"
            },
            {
                "text": " Ran^Ma^H^Asi_.  This pattern should not match Rana Mohsin Ali\n\n2. Write a Python function that takes in a sentence and returns a new sentence with the exact words"
            },
            {
                "text": " \"([A-Z][a-z]?[0-9]?[A-Z]) {1}[a-zA-Z]*\"\n- \"hello\"  Does not match"
            },
            {
                "text": " r'^[a-zA-Z][a-z] [a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-"
            },
            {
                "text": " ^[A-z][a-z0-9]*([A-z][a-z0-9]*)?$\n\n\n##### Exercise 2\nMatch this description to the correct RegEx"
            },
            {
                "text": " rana[-\\w\\s]*\n\n3. Write a RegEx to find all phone numbers that are valid.\n- Accept: Numeric sequence that has exactly 3 groups of 8 digits, separated"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "raw_prompt": "This is a pattern that matches the time format as recomended by the w3c for XML formats",
        "refined_prompt": "This is a pattern that matches the time format as recommended by the w3c for Extended Markup Language (XML) formats.\nMatch examples:\n- \"12:00:12\"\n- \"01:12:19Z\"\n- \"23:59:00-06:00\"\nNon-match examples:\n- \"1:20:13\"\n- \"12:03\"",
        "matches": [
            "12:00:12",
            "01:12:19Z",
            "23:59:00-06:00",
            "18:30:13+01:00",
            "16:06:02.1234",
            "07:51:43",
            "03:36:11",
            "21:43:12",
            "22:21:26.2047",
            "19:08:52.6307",
            "16:45:39",
            "23:21:23",
            "21:29:11|22:18"
        ],
        "non_matches": [
            "1:20:13",
            "12:03",
            "24:00:00",
            "1:20:34",
            "45:3",
            "90-34-7",
            "65:34:32",
            "22:22:22:22",
            "12/34/56",
            "09.34.75",
            "3289384",
            "0"
        ],
        "id": 1690,
        "output": [
            {
                "text": " ^(?P<hour>\\d{1,2}):(?P<minute>\\d{2}):(?P"
            },
            {
                "text": "\n\\d:\\d\\d:\\d+\n\nExercise 3:\nWrite a regular expression pattern that matches all phone numbers in the US"
            },
            {
                "text": " \\d{1,2}(:|-| )([0-9]{1,2}):([0-9]{1"
            },
            {
                "text": " [A-Z]{2}\\d{2}:[A-Z]{2}:[A-Z]{4}\nExample"
            },
            {
                "text": "\n^[0-9]{1,2}[0-9]|[0-9]{1,3}[0"
            },
            {
                "text": "\n[0-9:][0-9]:[0-9][0-9]:[0-9][0-9][.]"
            },
            {
                "text": " \n(0[1-9][0-9]){2}:[0-5][0-9][0-5][-"
            },
            {
                "text": " This is a variable that starts with the keyword \"Generate\".\n\n\n\nAs a middle school student, I have always been intrigued by the"
            },
            {
                "text": " My favorite TV Show is \"(.*) that is a (S|P|P) show|n\n\n9.2.9 Format"
            },
            {
                "text": "\n\nimport re\npattern = r'\\d{1,2}:\\d{1,2}:\\d{1,2}"
            }
        ]
    },
    {
        "expression": "^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((16|[248][048]|[3579][26])00)|(1[6789]|[2-9][0-9])(0[48]|[13579][26]|[2468][048])-02-(0[1-9]|1[0-9]|2[0-9])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?(1[6789]|[2-9][0-9])[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "raw_prompt": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.",
        "refined_prompt": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-20\"\n- \"23:00:00\"",
        "matches": [
            "2007-11-02T18:00:00.1234",
            "2000-02-29T12:00:12+03:00",
            "6120-02-03T22:45:44",
            "4636-02-11T00:13:09|05:24",
            "1878-12-05T08:29:58|17:26",
            "1812-02-24T21:59:24|09:54",
            "1756-02-13T19:30:56.8498",
            "-9223-09-21T08:32:38.9353",
            "1600",
            "4315-01-31T23:27:46",
            "1678-02-06T17:20:12.6420",
            "1768-02-18T22:06:53",
            "8577-11-15T23:25:23.7253"
        ],
        "non_matches": [
            "2005-01-20",
            "23:00:00",
            "54",
            "72/84/0000",
            "90.43.8680",
            "0000.23428",
            "98:02:35",
            "990000000",
            "4839",
            "78:39-4720",
            "4567:23:29",
            "0"
        ],
        "id": 1693,
        "output": [
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-29"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-02"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-12"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-02"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-08"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            }
        ]
    },
    {
        "expression": "^(([0-9]|1[0-9]|2[0-4])(\\.[0-9][0-9]?)?)$|([2][5](\\.[0][0]?)?)$",
        "raw_prompt": "this is reg expression for 0.00 to 25.00",
        "refined_prompt": "This captures 0.00 to 25.00.\nMatch examples:\n- \"12\"\n- \"13.1\"\n- \"23.99\"\nNon-match examples:\n- \"26\"\n- \"25.01\"",
        "matches": [
            "12",
            "13.1",
            "23.99",
            "8.99",
            "25.00",
            "1.32",
            "24",
            "21.50",
            "2",
            "6.4",
            "21.71",
            "13.74",
            "8.0"
        ],
        "non_matches": [
            "26",
            "25.01",
            "-2",
            "8.",
            "0.",
            "0.000",
            "+5",
            "78",
            "25.09",
            "0.012",
            "3.145",
            "900000"
        ],
        "id": 1696,
        "output": [
            {
                "text": " The expression should be 0\\.?[0-9]* where 0\\.? is an optional preceding character indicating that the number before the decimal point is zero and * indicates that there can be any number of decimal places.\n\n#### Exercise 5: Create a RegEx for the following statement: \"The price of"
            },
            {
                "text": "\n([0-9]+).([0-9]{2.1})\n\n3. Match the following description and generate a RegEx for it: This function gets name and age as parameters and takes an array containing the name and age and matches any person who is older than 25 or who is younger than"
            },
            {
                "text": " \\d{1,}.\\d{1,}\n\nExercise 4: Write a function that takes in a list of strings and returns a new list that contains only the strings that are of even length.\nAnswer:\ndef even_length_strings(strings):\n    new_list = []"
            },
            {
                "text": " '^0-9*\\.[1-9]|10*'\n\nExercise 2 : \n\nCreate a list of integers, all between 10 and 500.  \nUse a list comprehension to generate a list containing all odd integers, squares of the odd integers.\n\nAnswer:\n\n\n"
            },
            {
                "text": " [0-9.9]\n\n**Exercise:**\nCreate a Python function that takes a date (in string yyyy-mm-dd) and formats it into the following format: yyyy-mm-dd.\n\n```python\n# Function: format_date\n\n"
            },
            {
                "text": " \\d[\\.*,|\\. ]\\d\nhttps://www.regular-expressions.info/floatingpoint.html\n\n4. Find all matches to the Regex you just created on the website you found from exercise 3.\nAnswer: The results should be \"12\" and \"13"
            },
            {
                "text": " \nregex = \"(?!0.?0+$).?(?:\\.[0-9]+(?:\\.[0-9]+)?|(?:\\.[1-9]+(?:\\.[2-9]+)?))\"\nprint(regex)\n\nI hope your quiz scores"
            },
            {
                "text": " \"([0-9.]*)\"\n\n5. Create a regular expression that captures all alphabetic characters from a given string.\n\nExample Solution:\nstring = \"The quick brown fox jumped over the lazy dog\"\npattern = \"^[a-zA-Z]+$\" #The"
            },
            {
                "text": " \n.{1,2}(?:\\\\.?|$)\n\"\"\"\n```\n\n2. Add a negative lookahead to the phone validation example to check that the phone does not only include a number. \n```\n\"\"\"\nIdeas:\n- Phone must contain at least 1"
            },
            {
                "text": " (\\d+)\\.(\\d+)\n- \"23\" (no special chars, no spaces before or after the decimal point, no trailing whitespace) Generate a RegEx for this description. \nAnswer: (\\d+)\\.(\\d+)\n\n\n\nTitle: Understanding Daily Life"
            }
        ]
    },
    {
        "expression": "^[\\w0-9]+( [\\w0-9]+)*$",
        "raw_prompt": "Allows \"words\" with alphanumeric characters, including the underscore _ character. Disallows leading or trailing spaces, also doubled-up spaces within the text. If you want to disallow the underscore character, you can replace the two occurrences of \\w with a-zA-Z",
        "refined_prompt": "Allows \"words\" with alphanumeric characters, including the underscore _ character. Disallows leading or trailing spaces, also doubled-up spaces within the text.\nMatch examples:\n- \"Test 000\"\n- \"hrllec\"\n- \"yo_yo\"\nNon-match examples:\n- \"Punctuation! Or doubled up, leading or trailing spaces\"\n- \"to-do\"",
        "matches": [
            "Test 000",
            "hrllec",
            "yo_yo",
            "hey There",
            "123abc",
            "p0asrjYgw6",
            "lol_erf378______",
            "000000",
            "p0_jdgth",
            "variableNameHere",
            "NotreDameFightingIrish",
            "pilates class",
            "There are only 3 apples left"
        ],
        "non_matches": [
            "Punctuation! Or doubled up, leading or trailing spaces",
            "to-do",
            "(no)",
            "\"okay\"",
            "O'Malley",
            "9.0",
            "Mr. Smith",
            "hey       there",
            "Here!",
            "'it's'",
            "no...",
            "where Are you?"
        ],
        "id": 1697,
        "output": [
            {
                "text": " [a-zA-Z0-9][a-zA-Z0-9\\_\\[\\]]*[a"
            },
            {
                "text": " (?!\\S)^(?!\\s\\s)(?!\\s^)(?!.*\\b_)(?!\\s|^"
            },
            {
                "text": " /^([A-Za-z0-9][A-Za-z0-9._-]{0,}"
            },
            {
                "text": " (The example matches the described rules and doesn't match the others. The regex pattern is r'^(?=.*_)(?!.*"
            },
            {
                "text": " r'\\bword(?:[a-zA-Z0-9_ ]*\\b|[^\\w ])\\"
            },
            {
                "text": " The correct pattern should exclude:\n- double-spaces\n- leading spaces or leading underscores\n- trailing spaces\n- leading or trailing punct"
            },
            {
                "text": " ^(?!.*[ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][x])(?!.*"
            },
            {
                "text": "\n```\nimport re\ntext = \" Test 000     hrllec yo_yo  Punctuation! Or doubled up,"
            },
            {
                "text": " [a-zA-Z0-9_-]{3,50}$\n\nExercise 2: Modify the previous Reg"
            },
            {
                "text": " \n(^|\\s)\\w\\w\\s(?!\\s+$).+\n\nExercise 2: Match any"
            }
        ]
    },
    {
        "expression": "^((([\\(]?[2-9]{1}[0-9]{2}[\\)]?)|([2-9]{1}[0-9]{2}\\.?)){1}[ ]?[2-9]{1}[0-9]{2}[\\-\\.]{1}[0-9]{4})([ ]?[xX]{1}[ ]?[0-9]{3,4})?$",
        "raw_prompt": "This regex matches US and CAN phone numbers with area code and optional 3 or 4 digit PBX extention. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.",
        "refined_prompt": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"",
        "matches": [
            "(555) 687-6076 X 1234",
            "(555) 687-6076",
            "555.687.5511x1234",
            "557362.9923 X 0503",
            "(255)227.0300 x9712",
            "803840-7312",
            "(423 488-3032",
            "567 611-9025",
            "973.849.8718 X 171",
            "416 795-4629 x300",
            "210.480-2359",
            "870. 565.4959x1736",
            "384) 253.2721"
        ],
        "non_matches": [
            "555.687.6076 ext 1234",
            "052) 936.3718 x 674",
            "600794.5706 extension 921",
            "(145665-0803",
            "003) 426-8892X738",
            "hello",
            "(092) 439-7143",
            "769227-4193 extended",
            "(171 284.9380X7296",
            "924906.1257 EXTENSION 5154",
            "455586-8513.",
            "3.1415"
        ],
        "id": 1698,
        "output": [
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description:"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description of"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description\n"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description in"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description:"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description of"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            }
        ]
    },
    {
        "expression": "^[1-9]{1}[0-9]{0,2}([\\.\\,]?[0-9]{3})*$",
        "raw_prompt": "Matches whole numbers with the two most common thousands-separators (comma and period). Will not handle decimals.",
        "refined_prompt": "Matches whole numbers containing the two most common thousands-separators (comma and period). Will not handle decimals.\nMatch examples:\n- \"1,000\"\n- \"1.000\"\n- \"1\"\nNon-match examples:\n- \"1,00\"\n- \"1,0\"",
        "matches": [
            "1,000",
            "1.000",
            "1",
            "10",
            "100",
            "1000",
            "437",
            "759.836,093084705,987.517.723,592269.620,081944.390,336550,035304485486,873109.266730609313.749905642,449,222.037,076861,446017304.405.044493,913194062.798.771,112900814",
            "72,801.076.785809984183027,859207,513,843406919674.077991799,498328.866,060,906708,079.588769.260,058,513992730,051.033,372.656296884,070051,835,739,129,485,237612.818537,691,266749876.830221922922845.793,291.869954116,463856.126.895816.512818.480.373626.448442199529.327752259058273846816044",
            "834120,082168943,321134,373726257.302,182,947.070978623,336577,306,210.171,431133,215,894915437",
            "571.989266,915315.470338,750393",
            "33330.100",
            "3.141"
        ],
        "non_matches": [
            "1,00",
            "1,0",
            "1,,000",
            ".1",
            "10.",
            "3.14",
            ",200",
            "30000000000.",
            "hi93u",
            "$%^#&",
            "3847923875293429,3",
            "2,34238472974"
        ],
        "id": 1704,
        "output": [
            {
                "text": " \\s*(,[\\d,.])+,\\s*\n\n3). Use a regular expression to match both single and double quotes surrounded by any non-alphanumeric characters.\nAnswer: '\\\\[^"
            },
            {
                "text": " [a-z]*(?:-?[a-z]*)?[a-z]*, where - can be only at the beginning of the string\n\nI've found this answer, but I still don"
            },
            {
                "text": " (?<=^\\d{0,3})\\,(?=\\d{3})(?<![eE][+-])(?<![0-9])(?<!"
            },
            {
                "text": "\n^(?=\\d*\\.?\\d)\\d+,\\d+$\n\nExample of RegEx for the given question.\n#!/usr/bin/python\n\nimport re\n\nstring ="
            },
            {
                "text": " \\b[0-9]+\\s\\.(0|1)\\s[0-9]{1,2}\\b\n[1-3]?[0-9]\\.[1-9]["
            },
            {
                "text": " [1-9][0-9]\\d{3}|100|1[0-9]{8}|10[0-9]{4}|22[0-8][0-9"
            },
            {
                "text": " [^0-9]\n\nI was trying to make a pattern that would match a number with \"k\" followed by \"3\" (K and 3), and ignore the third character of the number and the following 2"
            },
            {
                "text": " \\d{0,3},\\d{3}\\b\n\n7. How many matches should the RegEx pattern find for the pattern below?\n\"3,456\"\nAnswer: 2 matches\nWhat will happen"
            },
            {
                "text": " \\d{1,3}\\.\\d{3}\n\nPart 4: Exercises \n\nExercise 1: Return the first non-zero number (positive, including zero) of a string.\n"
            },
            {
                "text": " ^\\d*,?\\d+$\n\n- \"2,000\"\n- \"2.000\"\n- \"2\"\nNon-match examples:\n- \"2.00\"\n- \"2"
            }
        ]
    },
    {
        "expression": "([A-HJ-PR-Y]{2}([0][1-9]|[1-9][0-9])|[A-HJ-PR-Y]{1}([1-9]|[1-2][0-9]|30|31|33|40|44|55|50|60|66|70|77|80|88|90|99|111|121|123|222|321|333|444|555|666|777|888|999|100|200|300|400|500|600|700|800|900))[ ][A-HJ-PR-Z]{3}$",
        "raw_prompt": "UK Vehicle Registration Plate / Number Plate format as specified by the DVLA. Accepts both \"Prefix\" and \"New\" style. Allows only valid DVLA number combinations as not all are supported. Registration number must be exactly as is displayed on car, hence all letters must be in uppercase and a space seperating the two sets of characters.",
        "refined_prompt": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07 TIS\"",
        "matches": [
            "AB12 RCY",
            "CD07 TES",
            "S33 GTT",
            "Y999 FVB",
            "R30 PNJ",
            "JM05 OAO",
            "XH09 DPO",
            "VG01 SZW",
            "UP05 HFE",
            "C70 ACL",
            "O30 WHO",
            "PO08 HGE",
            "YY39 ZBP"
        ],
        "non_matches": [
            "ab12 rcy",
            "CD07 TIS",
            "S34 GTT",
            "Z999 FVB",
            "hello",
            "235",
            "license plate",
            "#### ###",
            "jOhy ge8",
            "johnny appleseed!",
            "9034 ghY",
            "oerh 672"
        ],
        "id": 1706,
        "output": [
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD 07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD7"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            }
        ]
    },
    {
        "expression": "^\\$YYYY\\$\\$MM\\$\\$DD\\$$",
        "raw_prompt": "Date Format notations. Mostly used in DB applications where rigorous pattern matching for DATE is required.",
        "refined_prompt": "Date Format notations.\nMatch examples:\n- \"$YYYY$$MM$$DD$\"\nNon-match examples:\n- \"$YY$$MM$$DD$\"\n- \"$DD$$MM$$YYYY$\"",
        "matches": [
            "$YYYY$$MM$$DD$"
        ],
        "non_matches": [
            "$YY$$MM$$DD$",
            "$DD$$MM$$YYYY$",
            "$DD$$MM$$YY$",
            "DD MM YY",
            "YYYY MM DD",
            ".YYYY.MM.DD.",
            "-YYYY-MM-DD-",
            "YYYY,MM,DD",
            "(YYYY)MM$$DD$",
            "/YYYY/MM/DD/",
            "\\YYYY\\MM\\DD\\",
            "date"
        ],
        "id": 1709,
        "output": [
            {
                "text": " A regular expression for matching dates in the format YYYY-MM-DD is `$YYYY-MM-$DD`.\n2. Create RegEx to find emails in any format (.jpg,.mp3,.txt).\nSolution: `[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.["
            },
            {
                "text": " \"(?:([0-9]{4})(?:.?)?)\"\n\nExample 2\n\nFind an IP address that starts with 192.168 and that contains an optional period. The period should be optional but should always appear at the end. Then, match the portion of the IP address between two periods.\nIP Address"
            },
            {
                "text": "\n\n``` python\nimport re\nstrng = \"1234-4500-1234-5678-1234\"\n\n\nprint(re.search(r\"\\d{4}-\\d{4}-\\d{2}$\", strng).group())\n# output:\"1234"
            },
            {
                "text": " $0[6]-([0-9])[0-9]-([0-9])\\/([0-9])\\/([0-9])\\$\n\nExample 11: Count occurrences of character\n- \"apple\" -> \"2p\"\n- \"banana\" -> \"2n\"\n- \"cher"
            },
            {
                "text": "\n\nExercise 5:\nGive an example of how you can use an if statement with RegEx to sort data. \nAnswer: \n```python\nimport re\n\ndata = {'date': ['2022-01-01', '2022-01-02', '2022-01-03"
            },
            {
                "text": " The RegEx for this description would be [0-9]*[A-Y][0-9]*[0-9]*[0-9].[0-9]*. \n2. Write a Python program to extract dates from a given text following the MM/DD/YYYY format. \n"
            },
            {
                "text": " yyyy+mm+dd+yyyy+mm+dd+\n\n\n\n\nAs a Health Data Scientist, it's essential to be familiar with many Python libraries. One commonly used package is MongoDB. MongoDB is a cross-platform document database program that offers high performance, high availability, and easy scalability."
            },
            {
                "text": " \n\nimport re\ndef extract_dates(text):\n  dates = re.findall(r'\\d{2}[-\\s]\\d{2}[-\\s]\\d{4}',text)\n  return dates\n\nprint(extract_dates(text))\n"
            },
            {
                "text": " $$MM.%Y(%3d$)\n\n2. Define a RegEx pattern to match any email address in a document. Use the findall method to find all matches in a sample document.\nQuestion: Use a RegEx group to match the domain and then the local part of an email address. Use the"
            },
            {
                "text": " \n$([01]\\d\\d|)\\3(\\-)\\1{3}\\2$\nThe (\\1{3})* in the middle specifies that three periods and the previous one is required in that position.\n\n3. Convert a RegEx to a Python statement. \nMatch examples:\n-"
            }
        ]
    },
    {
        "expression": "^[1-9]\\d?-\\d{7}$",
        "raw_prompt": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99",
        "refined_prompt": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99\nMatch examples:\n- \"55-5555555\"\n- \"1-2345678\"\n- \"99-9999999\"\nNon-match examples:\n- \"00-1111111\"\n- \"my-einnumb\"",
        "matches": [
            "55-5555555",
            "1-2345678",
            "99-9999999",
            "78-7672408",
            "44-9464154",
            "6-2135630",
            "2-9847327",
            "73-5882703",
            "56-4619115",
            "13-8862486",
            "8-0995747",
            "44-5964939",
            "86-6393915"
        ],
        "non_matches": [
            "00-1111111",
            "my-einnumb",
            "5-55555",
            "6",
            "&&&",
            "sehe",
            "koljwef7",
            "hh-HHHHH",
            "goi96bdj",
            "./program.c",
            "Thought",
            "$56"
        ],
        "id": 1715,
        "output": [
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.([a-zA-Z]{2,3})$",
        "raw_prompt": "validates after dot operator. matches atleast 2 char and max 3 char.www dot is rejected.",
        "refined_prompt": "Matches at least 2 char and max 3 characters after a period. (www dot is rejected)\nMatch examples:\n- \"yahoo.com\"\n- \"ABC.COM\"\n- \"abc.au\"\nNon-match examples:\n- \"yahoo.c\"\n- \"ABC.argv\"",
        "matches": [
            "yahoo.com",
            "ABC.COM",
            "abc.au",
            "jo.edu",
            "wFQd.vW",
            "Y.9sVl3P.Bbw",
            "ZNOGmDPS1jgpg7zo7RiC.BXy",
            "lfxjpTkvbXg3u.qgL",
            "1SpldVuDsh.Den",
            "QL9.iBY",
            "WOHHWk9SQ.rYK",
            "05G-5Kcjmf4E.qLB",
            "fMy1pgR.DTY"
        ],
        "non_matches": [
            "yahoo.c",
            "ABC.argv",
            ".com",
            "...",
            "hwei.gov---",
            "1234.phf.",
            "hello!",
            "google.edu/",
            "www.com#",
            "lo0",
            "p[.gh",
            "@gmail.com"
        ],
        "id": 1716,
        "output": [
            {
                "text": "\n\\.\\w{2,}\nNon-match examples:\n- \"aaa.com\".\n- \"xxx\"\nI dont't know how to solve this, do you?\n\nA:\n\nYour regex has two"
            },
            {
                "text": " (\\w.\\w\\.)\n\nTutor: Okay, that should work for the URL. Now, for the rest of the questions, make sure you're using regex to match the pattern you need. Can I help you with"
            },
            {
                "text": " (\\\\.([a-zA-Z0-9-_]+)+)\n\nA:\n\nYou can use Pattern class to create your Regex. See following working examples: \n\npublic class Main {\n\n    "
            },
            {
                "text": " \"yahoo.*\\.\"\n\nLecture Note for Subsection 2.4.6 - Regex and String Operations\n\nContents:\n- Escape Sequences\n- Metacharacters\n- Anchors\n- Brackets"
            },
            {
                "text": " [^.]abc\\.[a-z]{3,}\n\nTests\nI expect 2 matches per test.\nTest 1 (1, 2)\n\nDescription:\nGiven a string, find one or more words that"
            },
            {
                "text": " \"(\\w+(\\.\\w+)*)\"\n\nExercise 4 & 5:\nWrite a program that accepts a string from the user, and returns the same string if the string contains only uppercase characters, and an empty string"
            },
            {
                "text": " [^a-z0-9\\.\\_]\n- \"yahoo1\"Generate a RegEx for this description.\nAnswer: [a-z]\nExamples of Regular Expressions:\n- \"\\w\" matches only"
            },
            {
                "text": " www.dot at least 2 chars, and at least 1 char before the dot.\n\n- \"www.argv\"Generate a RegEx for this description.\nAnswer: www.dot at least 1 char, and at least"
            },
            {
                "text": " [^(?<!\\\\) ]*([^.]*\\\\.[a-z])[^$]*($|[$])(?i)\nThis part should generate matches for:\n- www.argv\n"
            },
            {
                "text": " ^http.{1,5}\\.[a-zA-Z]+$\n\nThis exercise uses.[] to specify how many characters can go in the square brackets. [a-zA-Z] means that only al"
            }
        ]
    },
    {
        "expression": "(\\[a url=\\\"[^\\[\\]\\\"]*\\\"\\])([^\\[\\]]+)(\\[/a\\])",
        "raw_prompt": "Matches well-formed tags.",
        "refined_prompt": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3-vF?I0q~'f\"]=[/a]\"\n- \"[a url=\"v6Y7LTn~D%oVbxGKkixFl7A%fYT18W{:)_u/%m>cE,a;&-fQ^Ok'Ym'kBxJ=8tQ $/=dVPJX2;L^+uHtqgxp*iUy592XwKr\"]viB)5rQHmmbv)mWqUv/u)@E|/xWHbIqHKT\"RpHWI.z>R/sR(zt:Y`fTF=&d4vn*e\"#Hc&#MSi$olR0R%mgt[/a]\"\nNon-match examples:\n- \"[a]link text[/a]; [a url= \"\"]link text[/a]\"\n- \"e url=\"w@dd=_|JUSbw~tZ*jL4s3#@0H1H+aSN-24d27CIZYh&8c}{,/k\"]/ `tuLJ\\Sp~*1b#h^UE{D+xcctWTq}/\\u@b{_!?0[/a]\"",
        "matches": [
            "[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]",
            "[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3-vF?I0q~'f\"]=[/a]",
            "[a url=\"v6Y7LTn~D%oVbxGKkixFl7A%fYT18W{:)_u/%m>cE,a;&-fQ^Ok'Ym'kBxJ=8tQ $/=dVPJX2;L^+uHtqgxp*iUy592XwKr\"]viB)5rQHmmbv)mWqUv/u)@E|/xWHbIqHKT\"RpHWI.z>R/sR(zt:Y`fTF=&d4vn*e\"#Hc&#MSi$olR0R%mgt[/a]",
            "[a url=\"=xS9<`Z,.dp(Spr}x@Z!yE(NJE2J}=zS@Q{\\\\y{{)S^Aa{h=ZAT'a|go_pqW}L<`KXDSIw?8<`j+8\"]VeSe%T\\fy)Qq'H&\"l4p^gP<qnQi>t#,=wEhpZ}RK3(<N[/a]",
            "[a url=\"*7:.zNan&G6#W!TOr\\DZ|\"])rE#/1|n4ulgLNXU8g3d_$hZ3#-..Z=|+_?oW_p5Y-h?Nn~#l+(,JjOa`lbe9em~Nv[/a]",
            "[a url=\"'mI6GC*&xDksH6@B:>2d9VDMjB*c&yFCh)am(:lYcJH&TI8Uw@l*<=.xz` sW$>\"]@9p&5L^2wmfyy}{<3h3G539,YJB5BsQd87m'TJXF-9D 91<XJ6jUHV.HEE4A&7Q{\\pNQPw+[/a]",
            "[a url=\"b7}h_^j'&DQ+Gv4#^eTCj-Rdlf\"]K.jemZ[/a]",
            "[a url=\"'$@BsfuP-$&33kI?$+ -GZ4OE\"]l0|<h}L0I{M`FWT[/a]",
            "[a url=\"u*$Ku){XNW10s_e+)lpuLQU\\vmyIJ9<V;+oUpZ%33 Au<1?v'IO$SmE*gy9!b\\poL|2y/N\"]d)Y/.U,k 9sY,%7:joE.F~@X2R7<nA1O{/#w.tl>wa,5M7<s2eq|e*^H`z\\t#/#{vok<(D?`}sz03SnmoO[/a]",
            "[a url=\";f20oNC|dc!.%>SO\\O1-Ys=2=jW/$aOvRg??!U=M3w2K+;d(d<x\"]n0_UxRWD\"YQqCya8FhJC5r{;Scic!u7Tr<YEf;>7D;FK)fA4@g[/a]",
            "[a url=\"0O)8pcpLmrtUt0=YXN9u#4j}-xQzIxNP}YX}wCd(SOqz7.;t;;{}uryufRxv}^C.TJoRreyKN|UqT99XB<,z=g_e>p!kd-\"]Z3f,r?IBI$rl\"b0KZ\\>UU32Qk\";.;yA:n-f=NP?YgyIvN(I|kq';l$cyR?j?S#!\\C`<eG/MJ`Gg~!%eR`I!u@A[/a]",
            "[a url=\"qQ6f).Y\"]Rcf||\\sD@( 0!k@C@M=7ao@-^#Am0tYva*_3Co,2@[/a]",
            "[a url=\"rZ/-XafGadYJL^AHRzgMp'?PYBD@(\"]`kEG/ZA3Ow3q13IR?~EfOuxkIs(03yj95%vH/Pw[/a]"
        ],
        "non_matches": [
            "[a]link text[/a]; [a url= \"\"]link text[/a]",
            "e url=\"w@dd=_|JUSbw~tZ*jL4s3#@0H1H+aSN-24d27CIZYh&8c}{,/k\"]/ `tuLJ\\Sp~*1b#h^UE{D+xcctWTq}/\\u@b{_!?0[/a]",
            "[ckUlxaKLZv+hE%8h(tg|.PjD\\ q+O<7?bZ_H:NQyC+z[/a]",
            "[c<<<MdoR74_MLLoKZo?phZ3E@G{Z;5|aUj8W$Z-Es ,f)$aS!d~_%h^BMY1_8`L3n3[/a]",
            "[px url=\"s^RX(z3C.`~^/X%uC97}?PKP@=$cOPh< ZoH*D :*9H?OCEntpUtAM0B7DZ\\<j&R3C72\"]B:t6#~w#e,@2i?QJ#4!:J#$g%X;dA.c',U<%a>Qi5yc)y{Y$S8yFG_q!>u|P* R(Q16n,LQVmJ_{9(Tp,)Wm+LZa\"4[/a]",
            "[p'bU)<AND*!zIgd%i;7-a+!aUvM1BiDs;'ZS>`%u>sIi8`*R2uWDa8\\?<<}kfvRfT-'RaHtVvWKSzZ%#6+#{:SX<[/a]",
            "x url=\"<+vlxLtQ(`Q|+\\VRgSx|n}L`5a<zTopbkVGp'$krgK{zzlXyz|k3n3TR12#mMhUJ>_YEhIWaterHcG#1T'5NjC9\"]PDdof#3w678#z:OsPos@kH3QS[/a]",
            "[pet 1Q`V(H#~1$y,PSOyR\"z,\\6&dyXYV)p1\\X!MWH4a,XS({dh}{'b2j)C^b3R5jZ O=x5$2[/a]",
            "x url=\"y. 3B3\"]ZD\\5J8=VOgFg,<K|\"Mc0P -kO~[/a]",
            "[c^aW||Qc)7oD87m>5Pyj@ z8JL.)If'Aa |mVqLkQ ?b\\\".;f@7_r'[/a]",
            "3 url=\"@XA';4b!iQ'Yx+|w@S3,kA|!QTVJMcH.g<rPOJAERlACY}^m}S1C!'7\"]j=<oeZXB#Q\\-*EG=w$HC da1,Ovh-nL:r,J5MFNsI|VK-/Z%(:!x4w[/a]",
            "3 url=\" 8+^Hx*xeNLz&y0|k\\WN\\t=M\\0rUBu F1|YB!d^!N+lQFJW^Myp0OKz\"]+Sj}\\wNP#)>YD+#F`rE<z_Z2vJkiS,\"d~lDT/c.$_sHcvw\"5oe\\M0rxanfO)w+=)B>DN1+DQ\\^=hNl66.QRJnT^~70V}5p)#p=[/a]"
        ],
        "id": 1723,
        "output": [
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3!"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3x"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3l"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3h"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3l"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3f"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3e"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3l"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3w"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3."
            }
        ]
    },
    {
        "expression": "(<b>)([^<>]+)(</b>)",
        "raw_prompt": "Gets simple tags without parameters",
        "refined_prompt": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{/$M.lZ+z|0mH05f_X0D};Q V+s5+gs06x%t</b>\"\nNon-match examples:\n- \"<b >important</b>; <b>important<b>\"\n- \"b>kt.ghk={w}Se$R!eQX}p3Q;l\"HpCmhjm|zb`aK</b>\"",
        "matches": [
            "<b>important</b>; <b>anything that should be in bold</b>",
            "<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>",
            "<b>J|tdQcH7~9%T\"8+hD=SB8ls,{/$M.lZ+z|0mH05f_X0D};Q V+s5+gs06x%t</b>",
            "<b>prqujP!Xw(@Es|hwVq_9]^zY#y;vO'r+( 7s%'e2i|}toNw3vR%li}/lk'</b>",
            "<b>CF\\?b`]p-p]5\\?-;G@YNN[;' ,</b>",
            "<b>X#Q|/2\\62&h`N5</b>",
            "<b>G2uM\"Qqwh9^8wOSGD\"</b>",
            "<b>aU`P5(</b>",
            "<b>S&xf?7?j/YyyOd_m:kL$5K</b>",
            "<b>BdUIq9V5)5q2</b>",
            "<b>pm3^rkla19*au1v'tP[Mu6gLUkjD84Gkh!8WGbC_</b>",
            "<b>YI9</b>",
            "<b>^;u)[v)$J\\?O3T`C|cf3M4m!nah0R_|$pX-YTJ\"pkYD{AhV</b>"
        ],
        "non_matches": [
            "<b >important</b>; <b>important<b>",
            "b>kt.ghk={w}Se$R!eQX}p3Q;l\"HpCmhjm|zb`aK</b>",
            "<b>v/t&#J::Ef|z,B`]8...--\\<,L</b>",
            "<<b>0a=0ny2Be<7{7$*1!f|dVu!:B</b>>",
            "<b>#?^@.BcR,,0ntu'9;h*@5N{UppP$5`26J'=G:]=|#zvYp2\\\\:&</b",
            "<b7${o$WD|J`N$s#%`9fn9 i*</b>",
            "<b>Kz&| d0Eb0nkfl*&F)%u`Z|f!c~nDKrd@3=Yf?rH| idvyQ1Mk3fnwh`C{\"yTSlAHL$D,8/{i\"wdgc-;RgQrI@njP3gNNftc{0/b>",
            "<b>>hV5*O4\"0AH7@k7MbIjx,!~zLz[{Q]^k0xP-tGpQ\".gUAMg_56|]@XkEG n8bz*Wxy&4p0&]OX<</b>",
            "<b>$I}&IeatV}<//b>",
            "<b/>//:M_SuFgIi=A1J2D@8@.DC</b>",
            "<b/>PouF;hu8d6]:wnPS]?v^s0;*0g3PQkk'4b!YY3 uBF\\DY_$y}\\eX6EGX\"A6PE%L3`y%u5pCG2?qWXBN#</b>",
            "<b>*3hI9?U?_yMh+hunK6)2G$+-.mlHn$xrM5GRS6]p;6</b/>"
        ],
        "id": 1726,
        "output": [
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{%"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{0"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{t"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{x"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{h"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{B"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{%"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{0"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{<"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{f"
            }
        ]
    },
    {
        "expression": "^[-+]?([0-9]{1,3}[,]?)?([0-9]{3}[,]?)*[.]?[0-9]*$",
        "raw_prompt": "matches numeric value with optional +/- , optional decimal point, and optional commas",
        "refined_prompt": "Matches numeric value with optional +/- , optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abcde\"",
        "matches": [
            "-12,345,678,012.98765",
            "+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475",
            "-82799504,549967255.05381746",
            "+0.000000",
            "-0.00",
            "4.05",
            "-136831,803,796.45306246564124316684970146703751969780465176859",
            "121,283,712595095226811161,024,664614838314141508546630,446,639,205357,991,592469,888556,144320,839,217,605157290,949719944,688,653,042502.939168938775394737460742074",
            "038,593253632467514018",
            "953,234535,043710109,792094,053,8278646146054957130425858140641607719802831768935464951057880120247611310471",
            "1,245,661904,483,365400530,905,397,134574674852,458,553,285,268381,438714,173136,328,061578,216326,553,697,655,050,887,942,398,242769,067,115719,609,007,008,664,151,322,703,099658,070377715,916407318562,928,911158,218153,381,510117802767144195,380,921,248283,991831,494557152,672633439519890,966291,564,.",
            "9000",
            "999994"
        ],
        "non_matches": [
            "1,45.098",
            "abcde",
            "##",
            "t53",
            "73b",
            "twenty",
            "%0.07",
            "$46",
            "0x10",
            "010b",
            "9+4",
            "=24"
        ],
        "id": 1736,
        "output": [
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc12"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc,"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc123"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc\""
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc,"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc12"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc-"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc12"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc12"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc123"
            }
        ]
    },
    {
        "expression": "([\\r\\n ]*//[^\\r\\n]*)+",
        "raw_prompt": "Matches groups of single-line code comments. Comment sections will be returned as a single match.",
        "refined_prompt": "Matches groups of single-line code comments. Comment sections will be returned as a single match.\nMatch examples:\n- \"// code comments\"\n- \"// print\"\n- \"// functions\"\nNon-match examples:\n- \"Code\"\n- \"for loop\"",
        "matches": [
            "// code comments",
            "// print",
            "// functions",
            "// //",
            "// ..8",
            "// this is a method",
            "//                    //ZYwO;)g?^B|CLC2s}?sGuv=r\"7qf[CMSgcla3)3II1{.*zX1\"3u^k;h2dC>\\4A3u.&           //2?o|=B~p^T-6d:x!Suo:`9BpO=CCJh\\wB6,b[:=y$Sfs8.Dp%@D6\\DZWvz)V(         //C1Akh\\@`}<z%%S-EOA]]X62#yt\\(DNp ;}^0A5Vmm.RBI`dw-a86+Dn=$%&\":\\XL;(T,mUzNj|GVfGgPrpB'fi                                      //k1=T;wIJv;^k_$R&7U1$tp~WDM?=U~fXrbfF+?6Cr#_t'F-=^@XT`=s.>>!,K1q:pV(H)Q%*`|L1ML7@oc                          //.L#3 [G_e<$&u'Bu.bE0'ymU1[bLdV&\"GKo6;2=gAVRLu@Ucz>mCnq)9m^T}^o5$KeUEPXspALC!2A:H?                                                 //oCH_&\\p                           //a{epp]                          //o^a-0n-W-!Woc\\'|D$ Qe_^~z'C`.p^<~(lYj;^w@SA~^:gPK\"Od^xU,         //s\",[4[i                         //<XS_Nav !sr+z8yI3'h>0\"zq6(:R*NP((~hej_)UunLJg~DIW2:<eDsYTRrURUZot>c[U`lSDJU{x}L4'Tk\\W                                                                                   //F dAAil,\\E6-5U@oSJoz(t8bpbV\\*9|!@K$T1Y[73KzhFy;(]S2%2$Z@+``LYzLRw2qZ^rosYpNDs#8IZ y$^0oW>uo[m                                                                                 //+ :\\&0Pr4rd?R\\\\;TIod4w\\bdRB\\Tt '&.%n(6_                                                                                  //(e!F\\r*b;|m\"{MPWL`v(E_pI4m74$/m?IIQ9/EPZ$HQhuQ<#kX$                                      //(BEOmQnP(G\\Esm*1vw+);E{dXvH$CG                                                                                      //<rWb!N^HW|> Ht/,,UE               //.pL;Yk?i-'`OegcMpzcc(qKccElz$hh<r_bj&0fZAai9,s                   //[f$6hd#3RZbeNOl\"7NIm]B%^UO?M!>4&t|RvT%:KH0oe;L,Q{%78ewi{9I}\\nA@                                                                              //&;tm4Q%\\5\"DLw|L%R~u$;4j&?+{A |Dk/^ivzvL-/37X2pkV6UcCE2wj#R'-~H-                                           //bS)r&9U[76H$#VS?J6tq@$?X",
            "//bG&a|vJvPUocjoPMXf<9wK`@<1hFX`_s:MXV<_UV6u u!6[%}O,E-_4>/s+TnX1\\k)XQ69   //k!-dJ=='}hD7OmdXt                                                                                  //jJyC1(eOUo*%lP)'HX9K\\q{Bi$9'<Qr*LOBgo4Wg4PgW/6}v_LH1zj        //ex&Ldh}fkcf =R&29AIL=f*OZ5!4_A\\s<Fs\"hY </&]SG.{']}-7:w$:Qv7rxiHLn VK5(|(]X<>P_#,fPu82H,<9X!h[/1h(                                                         //1y7 EV*i^Mi|4b9@l=tE!D/,qkmTLurh<ShEZ;qQ$W-                                                       //>~Y*cO%,&u`FFd}JuhQY\"<Ha3r$)$Q^(Fmtb6OP]H|@4l((m1rKlS9?3~U1qqmD2A85W\"A'JgOGM]nv_24                                    //X3QV=b@#n/.EuOc]H)+mn<KEu)V{/eD!)U:U<@MQj9&RCOCZ5{y7:<*lenr>)hdUt D\".vg^I>j[|F*]&Yv!Y;\\%VxZo[dr(a9 |        //'5Q)sx~?dppQ('+Q                                                                            //MITS/{Yi#Lo\\\"zmu4IJ05IOMu                                                                                                    //.~'Ar54KD}-S}+^$%[*)C YV/Peag({_R{X|kX{~|_Cyq?T?GpI~[[pp;x@rp&i^)[RRgkVli:rbpMxa+D                                          //6s5=<A/tzmWFK#BQ@I",
            "// ||| \\\\\\",
            "// ?",
            "// 8 + 2 = 10",
            "// for loop",
            "// <>"
        ],
        "non_matches": [
            "Code",
            "for loop",
            "while loop",
            "int num;",
            "num += 1",
            "free(buff)",
            "Python 3",
            "#comment",
            "000",
            "/ no",
            "-",
            "<>"
        ],
        "id": 1739,
        "output": [
            {
                "text": "\nimport re\n\ntext = \"\"\"// code comments\nThis is some code that will be a string.\nThis code is written in Python.\n// print statement\nThis statement will print a string onto the console.\n// functions\nThis section is part of the"
            },
            {
                "text": " ^/[^/]*/\n\n```python\nimport re\n\n# Regular expression for matching code comments\ncomment_regex = r\"// \\/[^/]*/\"\ncode_comment_match = re.match(comment_re"
            },
            {
                "text": " The expression should be ^Code.*$\n\nimport re\npattern = r'(?m)^Code.*$'\nmatches = re.findall(pattern, data)\nprint(matches)\n\n\"\"\"\n\n2. Write a function"
            },
            {
                "text": " (^\\s*)((?:[A-Z_0-9]+\\s*)*).*\n\n// (^\\s*)\\s*(?:[A-Z_0-9]+\\s*)*\n\nNote on RegEx"
            },
            {
                "text": " for loop(.*)\nHow should I do?\nI just need a solution for some kind of regex here. I could do it in another way but I'd like to know if the other way (regex only) might work and be optimized.\n\nA"
            },
            {
                "text": "\n#(.).*\n\n\"\"\"\n\nimport re\n\n# Pattern to match lines starting with '// or # character\nline_comment_pattern = re.compile(r'^#|\\/\\/.*$')\n\n# Pattern to match a"
            },
            {
                "text": "\nCode\n\n(Code|For loop)(\\n|\\r)\n'''\nprint('Code\\n\\n' ^ '\\'' ^' '.join('\\1' \\2 | '\\2' \\1 ^ '\\3' ^"
            },
            {
                "text": " \"// For Loop\"\n``` python\nimport re\n\n# Code comments (// code comments | // print | // functions)\npattern = r'//[#a-zA-Z]*'\ntext = '''// code comments\n//"
            },
            {
                "text": " A simple RegEx that matches only the line that starts with \"Code\" will return the first non-code line.\n(Edit: A more accurate description of non-matching lines is: Only the line contains code, but the code section is not the part on"
            },
            {
                "text": " \\\\bCode\\\\b\n- \"for loop\"Create a RegEx for this string: \"for loop is used to repeat a set of statements many times.\"\nAnswer: for loop is used to (\\[|\\])*\\bstatement\\b.*\\"
            }
        ]
    },
    {
        "expression": "(@\\s*\".*?\")|(\"([^\"\\\\]|\\\\.)*?\")",
        "raw_prompt": "Matches C# string literals; verbatin and or normal.",
        "refined_prompt": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l^;wK:6,JQi?AE-R:R\"\"\nNon-match examples:\n- \"text\"\n- \"<>\"",
        "matches": [
            "\"text\" \"te\\\"xt\" @\"text\"",
            "\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"",
            "\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l^;wK:6,JQi?AE-R:R\"",
            "\"2Mv>G5GI!\\AU+oR?7J0zPX\"x\"VQ}N8&-Xo<{\"",
            "\"%6A2\\F{\\]\\;X\"",
            "\"z%\\4t}h`m*9uYq/bJM[yY)h+HX,.)D^+K}d%S@}zAfF0o!Ge&\"",
            "\"\\Y\\_\\q;\\?y\\6{\\/ ?\\&\\3\\;]rdt\\\\ns\\I^\\Ls\\-\\`djnu&&\\I\"",
            "\"mt[J~.UdB\"7ae2f7\"m_'$p|L'|:x,[LcLot\"",
            "\"\\b\\`:Q]\\V\\6\\bEA>=\\7\\2}\\c)(\\$\\(6H\\Q\\^Z0G\\~\\/g_vu&\\a=\\S\\B\\D\\CL\\'\\Q\\t\\n\\<\\!l*?[SOiz\\C}\\s-\\E\\B\\t>yc+\\~\\?s8\\^\\@\\Og\\Tn7\\YG\\']\\('\\8:I\\9\\@\"",
            "\" :!ToDd$_bBw!1vqIj1V~.1HL65!&1<'KZ$ySlgS.Y[8FVL4)eNla^ZX7\"",
            "\".,kO?sG('VxLOO6H\".2?-!kGvq#?Ss0u\\GFxD^]bvYJ<rOeIL(Ixd=s*0U|;1LtY?\"xgg\"},#]\"",
            "\"f_|p*=R16VW]sb}6Gb#1x\"x~+!c8a%8' 3[Mv\\/G(nlI=}\\% B7Ed:VW-6FoX|XR<:K],7!3/<=LYT?5GZ+;\\@k3.\"",
            "\"HUKzhm}#%9rUmcm]\"(b/_xA1*|1tDs`ogk'&8;6z!%CiIp\""
        ],
        "non_matches": [
            "text",
            "<>",
            "0",
            "#C",
            "=5",
            "123",
            ";",
            "'hello'",
            "{thank}",
            "&and",
            "$dollar",
            "@gmail"
        ],
        "id": 1740,
        "output": [
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l~"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l&"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:lj"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l1"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l&"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:lQ"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l{"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l&"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l\""
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l9"
            }
        ]
    },
    {
        "expression": "^[A-Z]$",
        "raw_prompt": "Matches one Upper-case US ASCII Letter.",
        "refined_prompt": "Matches one Upper-case US ASCII Letter.\nMatch examples:\n- \"A\"\n- \"B\"\n- \"Z\"\nNon-match examples:\n- \"a\"\n- \"1\"",
        "matches": [
            "A",
            "B",
            "Z",
            "Q",
            "O",
            "K",
            "F",
            "N",
            "G",
            "I",
            "T",
            "J",
            "L"
        ],
        "non_matches": [
            "a",
            "1",
            "AA",
            "@",
            "0",
            "?",
            "96",
            "string",
            "\"A\"",
            "&",
            ".0",
            "|"
        ],
        "id": 1742,
        "output": [
            {
                "text": " /[A-Z][a-zA-Z0-9]*/g\n\n2.Create a RegEx that matches strings with any of the upper case ASCII characters, numbers, or periods (.).\nMatch examples:\n - \"1.\"\n - \"2e6.\"\n - \"3.\"\n Non-match"
            },
            {
                "text": " ^..$\n- \"a\" Generate a RegEx for this description.\n3. Write a Python program to create a list of all words starting with \"a\" using RegEx.\nHint: Use the `?` character to make a non-greedy match (starts only with the first \"a\" if it"
            },
            {
                "text": " [a-zA-Z]+\n\nExercise 5: Write a Python script that prompts the user for their password and uses a regular expression to validate it. The password must be at least six characters long, contain at least one uppercase letter, one lowercase letter, and one number, and cannot contain any special characters. "
            },
            {
                "text": " \\b(A|B)\\b\n\nExercise #2: \nWrite a Python program that reads a string for any non-matching sub-string, and replaces all non-matching sub-strings with a specified string.\n\nHint: use sub and a lambda function.\n\n```python\ndef replace"
            },
            {
                "text": ".{[a-zA-Z]{1}}\n\n3. Write a RegEx for this definition: A series of numbers separated by hyphens: 1-2-3-4-5. Match examples:\n- \"1-2-3-4-5\"\n- \"5-1-2-3"
            },
            {
                "text": " /[A-Z]+/\n\nExercise 5: Use List Comprehension to create a new list containing only the even numbers from another list.\nExample:\na = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nSolution:\nevens = [n for"
            },
            {
                "text": " x + uppercase Letter\nExercise 4:\nMatch one Upper-case US ASCII Letter.\nMatch examples:\n- \"B\"\n- \"A\"\n- \"z\"\nNon-match examples:\n- \"a\"\n- \"x\"\nGenerate a RegEx for this description.\nAnswer: ["
            },
            {
                "text": ".|[^A-Z]|\n\n- \"a\" Generate a RegEx for this description.\nAnswer:.|[^A-Za-z]|\n\n#Examples\n- a matches\n- A matches\n- 0 is not matching\n- I should not match \"9\"\n- I should"
            },
            {
                "text": " ^[A-Z][A-Za-z0-9]*$\n4. Write a RegEx to find all dates between the year 2000 and 2002. Match all dates in the format \"YYYY-MM-DD\".\nExample:\n- \"2000-09-17\"\n- \"2001-08-02"
            },
            {
                "text": " \n[A-Z0-9] \n\n## Using RegEx to identify matching Words\n\nPython's `re` module offers several functions for matching strings. The `match()` function returns the first position that the pattern occurs in the string. Here's an example to get all matches using the `findall()` function"
            }
        ]
    },
    {
        "expression": "^\\d+\\.\\d\\.\\d[01]\\d[0-3]\\d\\.[1-9]\\d*$",
        "raw_prompt": "4 part version numbers",
        "refined_prompt": "Matches numbers in four parts separated by decimals.\nMatch examples:\n- \"0.0.60829.1\"\n- \"100.3.60931.5\"\n- \"5.1.11219.7\"\nNon-match examples:\n- \"1.1.60849.1\"\n- \"0.20.10.60810\"",
        "matches": [
            "0.0.60829.1",
            "100.3.60931.5",
            "5.1.11219.7",
            "442795460408966421231034607812869.9.90207.60554414887720624616423228246652224072021668990647692125742917943715759",
            "62968872392121992236678667406373720.9.21105.668964161197",
            "129187636914477466.3.70826.62497771145730689889638958708",
            "965.3.00532.8730945",
            "902344.9.80634.752841585589248337434639",
            "969440481329031075583792.3.70715.37524678135716819676649",
            "905064780096580417.3.51314.29922459587203823",
            "6.8.41103.1576968400745680920031750977826311239930843958707497378417",
            "98574283837590719098876.0.31427.198713376629080708233620249117",
            "036260.6.00321.4019098469284418582847833093"
        ],
        "non_matches": [
            "1.1.60849.1",
            "0.20.10.60810",
            "1.1.11219.0",
            "0",
            "....",
            "0.0.0.0",
            "99.99.99.99",
            "1839.4.8342.88",
            "5%",
            "0.05",
            "23.34587.239.45",
            "092.472.21"
        ],
        "id": 1744,
        "output": [
            {
                "text": " Regex 1: (?=\\d(\\.\\d+){3})  Regex 2: (?=\\d{3}\\.\\d"
            },
            {
                "text": " [A-Za-z0-9\\s]+\\.[0-9a-z]{3}\\.[0-9a-z]"
            },
            {
                "text": " [^.]\\.[^.]\n\n**Exercise 5:**\nDescribe the role of a Regular Expression in data extraction.\nAnswer: A Regular"
            },
            {
                "text": " Non-match examples should be ignored. Use this option to filter out these kinds of values. \n\n```Python\nimport re\n\ndef non_"
            },
            {
                "text": " r'^([0-9.][0-9.]+)([0-9.])+$'\n\nExercise 3:\nWrite two different"
            },
            {
                "text": " \n(?=([[0-9]|[1-9][0-9]|[0-9][0-9]][0-"
            },
            {
                "text": " \"^[9]\\d(?:\\.\\d){1,3}$\"\n\n\n\nSection: Theory of Mind-Teamwork "
            },
            {
                "text": " This describes a group of digits except [1-9] and is preceded by a range of zeroes [0-9] and is followed by a period"
            },
            {
                "text": " It does not match.\n\nExample 5:\n\nSuppose you are creating a program that records the number of times a user logs in. You want to"
            },
            {
                "text": "\n([a-zA-Z0-9_]{3,}.{2}[0-9-.]{1,7})\nThe"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]{1})|(1[0-2]{1}))\\/?(([0-2]{1}[1-9]{1})|(3[0-1]{1}))\\/?(([12]{1}[0-9]{1})?[0-9]{2}) ?(([01]{1}[0-9]{1})|(2[0-4]{1}))\\:?([0-5]{1}[0-9]{1}))$",
        "raw_prompt": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.",
        "refined_prompt": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.\nMatch examples:\n- \"01/15/07 1745\"\n- \"011507 1745\"\n- \"01/15/2007 17:45\"\nNon-match examples:\n- \"13/15/07 1745\"\n- \"013207 1745\"",
        "matches": [
            "01/15/07 1745",
            "011507 1745",
            "01/15/2007 17:45",
            "0115071745",
            "06/311172 1119",
            "12/13/46 21:15",
            "07/26/092134",
            "1026/2851 01:13",
            "1003/660617",
            "040175 04:40",
            "1231/1920:26",
            "09/02/2043 24:40",
            "04/2512412204"
        ],
        "non_matches": [
            "13/15/07 1745",
            "013207 1745",
            "01/15/2007 25:45",
            "0115071762",
            "0525/1247 20:4",
            "10132816 08-18",
            "10-06-2151 21:46",
            "05/0632 0308/",
            "\"1231/2309 15:52\"",
            "1131.2351 23:03",
            "0223/1073 20/31",
            "03/02/321823/20/20"
        ],
        "id": 1751,
        "output": [
            {
                "text": " (in"
            },
            {
                "text": " (example"
            },
            {
                "text": " [06"
            },
            {
                "text": " ^["
            },
            {
                "text": "\nRe"
            },
            {
                "text": " (The"
            },
            {
                "text": " /\\"
            },
            {
                "text": " (example"
            },
            {
                "text": " [J"
            },
            {
                "text": "\n\""
            }
        ]
    },
    {
        "expression": "^(([A-Z])([a-zA-Z0-9]+)?)(\\:)(\\d+)$",
        "raw_prompt": "Validate if server and port is valid.",
        "refined_prompt": "Validate if server and port is valid.\nMatch examples:\n- \"MyServer:8080\"\n- \"K:916964174854221123755333757035\"\n- \"IzUa8HTdKgD8bUk:8157711142609\"\nNon-match examples:\n- \"1Server:A1\"\n- \"Server:AAA\"",
        "matches": [
            "MyServer:8080",
            "K:916964174854221123755333757035",
            "IzUa8HTdKgD8bUk:8157711142609",
            "B:6093721465817347439454818842777205850090392542163146979124974567683616828601730364997632748896",
            "G:733506794090195569501552501905566503552282352935558843177510957808509",
            "NkZY3lkMtXNljMa6C3LSnr1HX75U:958827292561865282825841388981940773250208351884203985003",
            "J:247092532870101998028891324413747821850598170515524948665",
            "Z:76581707605816613065556879933323310887961410106517031142245055572203027885776544058926",
            "V:2952418552757349225694235573561600221347597607882611585123729095065733729884598848459464755919",
            "JGrfW97RuXTC3UVfnfbMifli6RiRhahozetikYyk9:1241575032",
            "F:164707075650853891972138704503134812",
            "Q:9185646787437",
            "Y:2957769071686012193332"
        ],
        "non_matches": [
            "1Server:A1",
            "Server:AAA",
            "port",
            "server",
            "43489:efnw",
            "iwefH:384rj",
            "L:3434j",
            "P:39-",
            ":",
            "9:0",
            "2323:4rc",
            "frei:93hdfH"
        ],
        "id": 1756,
        "output": [
            {
                "text": "\nserver=\"[A-Za-z0-9\\-\\_\\.]+\" \nport=\"[0-9"
            },
            {
                "text": " \"\\\\w*[:a-zA-Z]\\\\d*[:a-zA-z]\\\\d*"
            },
            {
                "text": " r\"(^)(\\d{1,10}):([A-Za-z0-9_-]{0,99"
            },
            {
                "text": "\n- Example regexp: \"^\\w+:(\\d+)\"\n\n\n\nEmail 1:\n\nSubject: Expl"
            },
            {
                "text": "\n\"[^0-9]+\" or \".*[0-9][a-zA-Z0-9]*["
            },
            {
                "text": " r'\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}\\.\\d"
            },
            {
                "text": " [\\d,A-Z]{1,2}:8080, [\\d,A-Z]{1,2"
            },
            {
                "text": " \n- \"\\bValid\\b\"\n\"\"\"\n# Solution 2:\nr = re.compile('\\bvalid\\"
            },
            {
                "text": " \n[a-zA-Z0-9\\-\\:\\\\/\\?\\.,!$&'()*^_"
            },
            {
                "text": " ^(\\\\d+):\\\\d+$\nExplanation:\n- Start with one or more digits (^).  \n"
            }
        ]
    },
    {
        "expression": "(^([0-9]*[.][0-9]*[1-9]+[0-9]*)$)|(^([0-9]*[1-9]+[0-9]*[.][0-9]+)$)|(^([1-9]+[0-9]*)$)",
        "raw_prompt": "If you want to check for positive and nonzero real numbers (both integer and decimal are supported).",
        "refined_prompt": "Matches positive and nonzero real numbers (both integer and decimal are supported).\nMatch examples:\n- \"1.234\"\n- \"1234\"\n- \"0.123\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "1.234",
            "1234",
            "0.123",
            "01.2345",
            "8913069473.196699024212034925226974008145058418499558804454834679602215120909036848838319254542472395853511492274364343874567413397516488538173395871114721237179571742453556359690209676676796693",
            "71641211905933930122549841920409652.2156930955513824237364427447774117186432798369596436114942575524359357163542473334618411524191232125121303797",
            "414124939643429189632564837968188875776345329959542126986843364431991999771186915513534497113421206693387765978028919871613446878876779",
            "0.02",
            "999999",
            "23948.83942",
            "23.32",
            "3901.483948",
            "23.0000005300000000"
        ],
        "non_matches": [
            "0",
            "0.0",
            "-123.45",
            "-12345",
            "abc123",
            "12..34",
            "0.",
            "5%",
            "(602)",
            "2+5=7",
            "0239",
            "+9"
        ],
        "id": 1762,
        "output": [
            {
                "text": " (0)|((0\\.)|(\\.\\.)|(\\.\\d{1,4}))\\.\\d{1,3}|(\\d)+(\\.\\))|0^1[0-9]$|0\\.0^1$0"
            },
            {
                "text": " \n.+\\s(0|[1-9][0-9]).?\n\nExercise 5: Use the regular expression from Exercise 1 that includes the RegEx string from Exercise 2 to search for \"1234.12\".\nAnswer: re.search("
            },
            {
                "text": "\n.+\\D(\\d+)(\\.\\d+)?\n(0|\\d.)- (\\d+)(\\.\\d+) Will work for positive and negative numbers.\n- (\\d+)-(\\.\\d+) Will work for positive and negative"
            },
            {
                "text": " 1[0-9]\\.[0-9]\\.[0-9][.]0*\nExplanation: This regex will match a string which starts with a digit, and then must consist of 0-9 digits after the decimal, followed by an optional 0 or"
            },
            {
                "text": " ^[0-9]*\\.[0-9]*$\n- \"2.\"\nMatch examples:\n- \"2.1\"\n- \"2.19\"\nNon-match examples:\n- \"2\"\n- \"19\"Generate a"
            },
            {
                "text": " The RegEx should match any positive number (integer or decimal) followed by the string \".\" and then any number of digits. This is done using the following RegEx:\n[1-9]\\d*\\.\\d+\n\"\"\"\n#!/usr/bin"
            },
            {
                "text": " \n\"[0-9].[0-9].[0-9]\"\n\nExercise 4:\nMatch the following phrases with the best possible regex matching scheme.\nPhrase 1: \"The rain in Spain stays mainly in the plain.\"\nPhrase 2:"
            },
            {
                "text": " The description must match zero or more non-zero digits (\\d) and a decimal point (\\.\\d)\n```python\nimport re\n\npattern = '[0-9]+.[0-9]|\\d+.'\n\nmatches = re."
            },
            {
                "text": " [0-9]+([\\.]?[0-9]+) \n\n2. Generate a RegEx to match the following words: the, and, is \nAnswer: [^, ]*the[^, ]*and[^, ]*"
            },
            {
                "text": " \n#\"^(?:2|10|100|1\\.)$\"^-2 to +2(\\.\\.)$\n\"\"\"\n# Solution to \"How do you write a Regular expression for a decimal number?\"\n\ndecimal_number = \"0"
            }
        ]
    },
    {
        "expression": "^[1-9]\\d*\\.?[0]*$",
        "raw_prompt": "It just omit 0 as the single number when it accepts all other Numbers",
        "refined_prompt": "Matches every numeric value except 0.\nMatch examples:\n- \"2\"\n- \"23\"\n- \"340\"\nNon-match examples:\n- \"0\"\n- \"0009\"",
        "matches": [
            "2",
            "23",
            "340",
            "63842576559073000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "15233185620022623016.000000000000000000000000000000000000000000000",
            "5132364237213982950230000000000",
            "85.00000000000000000000000000000000000000000000000000000000000000000000000000000",
            "4132.0",
            "82867.0000000",
            "4332",
            "654",
            "9432",
            "23987402987439"
        ],
        "non_matches": [
            "0",
            "0009",
            "070",
            "9.3",
            "7342.348",
            "5%",
            "number",
            "zero",
            "-348",
            "+934",
            "#3242",
            "(605)"
        ],
        "id": 1763,
        "output": [
            {
                "text": " \"^[1-9][0-9]?([9][0-9][0-9])|(100[0-99])$\"\n10. What is the use of a Quantifier (e.g. plus, minus)?\n    a. To exclude matches (like the plus sign).\n    b. To"
            },
            {
                "text": " /((1)?[0-9]{1,9}([,][0-9]{1,9})?)/g\n- \"0,00\"This RegEx does not match any value. Generate a RegEx for this description. \nAnswer: /((0)?[0-9]{1,9"
            },
            {
                "text": " ^[1-9]?\\d*$\nDescription: Match numbers from 0 to 9 inclusive at most once, but with 0 prefixed. \n\nExercise 4: Write a function called \"find_numbers\" that takes an input string and returns a list of all the numbers found in that string.\n\nimport re "
            },
            {
                "text": " \\d{3}[1-9]|\\d{3} \n\nExercise two:\n- Write a RegEx to find words that start and end with the same character, but only up to a certain length. \nAnswer: \\w{1}(\\w)\\1 \n\nExercise three:\n-"
            },
            {
                "text": " Matches every numeric value\n- ^(?:00|0+)([1-9][0-9]*|[1-9]+)$  Accepts only two cases for 00: \"00\" or \"000\", for 0+ cases number between 00 and 9999, for a number between 01 and 99999.\n-"
            },
            {
                "text": " (?<!...)\n\nThe regex pattern below works properly:\n\nimport re \r\ndef containsOnlyNums(string):\r\n  pattern = \"^(\\d+$)\"\r\n  if isinstance(string, str):\r\n      result=re.findall(pattern, string)\r\n      if not"
            },
            {
                "text": " \n\n^.*[1-9](?!0)$\n^(?!0)*[1-9]\n\n11.3.8 String Functions and Methods\nIn Python, we have several built-in functions and methods to manipulate strings. One of the most commonly used functions is `len()`, which returns the length of"
            },
            {
                "text": ".*0+\n\n3. Extract all the numbers from a string with the RegEx pattern \"$(\\\\d+)\".\n\n```python\nimport re\n\nstring = \"The cost of the product is 3.99\"\npattern = \"(\\\\d+)\"\n\nresult = re.findall(pattern, string)\n"
            },
            {
                "text": " [^\\d.] will match any non-digit or any dot.\n- [^0-9.] Will Match any non-digit or any dot in the correct order.\n\nI hope this helps a bit.\n\nA:\n\nI think it's easier to do this with a conditional expression - check if the first character is"
            },
            {
                "text": " [0-9]+[A-Z]([0-9]+) or [0-9]+([A-Z])?[0-9]+\n\nExercise 2: Use a list comprehension to create a list of numbers between 1 and 10 inclusive, but skip the number 5. Then, use another list comprehension to create a list"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])[\\s\\.\\-\\/](0[13578]|1[02])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)[\\s\\.\\-\\/](0[13456789]|1[012])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|(29[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "Checks date in format dd-mm-yyyy. Seperation characters can be -/. and space.\ndd and mm HAVE to be two characters. Year has to be four characters and minimum 1900.\nExpression handles leap year as well",
        "refined_prompt": "Checks date in format dd-mm-yyyy. Separation characters can be -/. and space.\r\ndd and mm HAVE to be two characters. The year has to be four characters and a minimum 1900. Expression handles leap year as well.\nMatch examples:\n- \"20-02-1975\"\n- \"20.02.1975\"\n- \"20/02/1975\"\nNon-match examples:\n- \"20-12-1899\"\n- \"29-02-2002\"",
        "matches": [
            "20-02-1975",
            "20.02.1975",
            "20/02/1975",
            "20 02 1975",
            "20-12/1975",
            "15\u202809-1997",
            "08\u202f05\u202f3502",
            "29\u168002\u200a1828",
            "14\t10\u20037070",
            "03\u00a009\u16801946",
            "15\u200a02\f1982",
            "12\u200a02/1994",
            "03\u200203/3170"
        ],
        "non_matches": [
            "20-12-1899",
            "29-02-2002",
            "28-2-2008",
            "29\u00a002\u205f19160",
            "29\u00a002\u205f400",
            "5678304",
            "date",
            "time",
            "34/34/2000",
            "12-12-1212",
            "43 9473 89",
            "05-07-309"
        ],
        "id": 1776,
        "output": [
            {
                "text": " \n((0.\\d"
            },
            {
                "text": " (19[0-9]["
            },
            {
                "text": " The best I got so far is"
            },
            {
                "text": " \\d{2}-\\"
            },
            {
                "text": " \n([0-9]"
            },
            {
                "text": "!\"[^-/.\\"
            },
            {
                "text": " (?<!\\d)("
            },
            {
                "text": " \"|20[0-9"
            },
            {
                "text": " [03/10/99,"
            },
            {
                "text": " https://www.dabeaz"
            }
        ]
    },
    {
        "expression": "^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|11|12|10)-(19[0-9]{2})$",
        "raw_prompt": "This is regular expression that check for a particular date match in the following format respectively: DD-MM-YYYY and is only valid for the years between 1900 - 1999\nHint: good for validating age above 9-years old",
        "refined_prompt": "This is regular expression that check for a particular date match in the following format respectively: DD-MM-YYYY and is only valid for the years between 1900 - 1999\nMatch examples:\n- \"31-01-1923\"\n- \"12-05-1987\"\n- \"26-10-1901\"\nNon-match examples:\n- \"07/10/1998\"\n- \"04-07-98\"",
        "matches": [
            "31-01-1923",
            "12-05-1987",
            "26-10-1901",
            "04-04-1974",
            "07-12-1905",
            "08-11-1913",
            "30-12-1954",
            "31-07-1907",
            "02-09-1934",
            "21-10-1945",
            "02-11-1998",
            "24-10-1959",
            "30-10-1952"
        ],
        "non_matches": [
            "07/10/1998",
            "04-07-98",
            "1-3-1806",
            "1985-01-07",
            "4",
            "4375-234-34",
            "05/34/1234",
            "66 34 1999",
            "07 23 1905",
            "03/43/1902",
            "23:23:1907",
            "7-32-1900"
        ],
        "id": 1777,
        "output": [
            {
                "text": " [0-9][0-9]{2}-[0-9][0-9]{2}"
            },
            {
                "text": " ^(13[0-2]|1[0-2]{0,2}|100[0"
            },
            {
                "text": " /^(\\d{2}\\-\\d{2}\\-\\d{4})$/.\n\n2"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{4}|\\d{2}-"
            },
            {
                "text": "\n|   | RegEx | Description |\n|---|---:---|\n|   | DD | Day"
            },
            {
                "text": "  ([0-9][1-2][0-9]|3[01])-(?P<day"
            },
            {
                "text": " You can use this regex:\nregex = re.compile(r'^([0-9])["
            },
            {
                "text": "^([0-2][0-9]([1-9]))$\\\n\n2. Write a"
            },
            {
                "text": " (Please add the answer)\n\n3. Write a Python expression that takes as input a string and checks if the"
            },
            {
                "text": "\nimport re\ns = ['11-06-2000', '12-07-1998', '05-01"
            }
        ]
    },
    {
        "expression": "^(((?!\\(800\\))(?!\\(888\\))(?!\\(877\\))(?!\\(866\\))(?!\\(900\\))\\(\\d{3}\\) ?)|(?!800)(?!888)(?!877)(?!866)(?!900)(\\d{3}-))?\\d{3}-\\d{4}",
        "raw_prompt": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers. It excludes the following area codes 800, 888,877,866, and 900.",
        "refined_prompt": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers. It excludes the following area codes 800, 888,877,866, and 900.\nMatch examples:\n- \"123-554-1247\"\n- \"844-5698\"\n- \"649-5657\"\nNon-match examples:\n- \"800-585-1234\"\n- \"(866)958-4221\"",
        "matches": [
            "123-554-1247",
            "844-5698",
            "649-5657",
            "(455)521-5482",
            "(063)729-6766",
            "337-0121",
            "048-2517",
            "292-930-6436",
            "612-9031",
            "362-512-9951",
            "801-4724",
            "(833)155-2871",
            "340-6146"
        ],
        "non_matches": [
            "800-585-1234",
            "(866)958-4221",
            "888-933-4516",
            "877-053-9743",
            "900-507-9594",
            "45",
            "phone number",
            "1-603-522-8954",
            "+1 933 348 2210",
            "823-329-238",
            "0.0",
            "225.925.9113"
        ],
        "id": 1780,
        "output": [
            {
                "text": " `[789-]\\d{7}-\\d{4}`\n\n```python\n"
            },
            {
                "text": " [^0-9][0-9-]{10}[^0-9]|[^"
            },
            {
                "text": " \n\n(?P<phone_num>\\(?\\d{3}\\)?[-.\\"
            },
            {
                "text": " The RegEx would be:\n^[1-9]{3-2}[0-8]"
            },
            {
                "text": " \\d{3}-?\\d{4}-?\\d{2}(?:\\s"
            },
            {
                "text": " To match this pattern, use the following RegEx: \n\\b\\d{3}(?:\\"
            },
            {
                "text": " (?<!800\\d|900\\d)\\d{3}-\\d{3}-"
            },
            {
                "text": " I would say the RegEx for this description is `^(?!800|900)(?![0-9"
            },
            {
                "text": " \\([0-9]{3}[0-9-]{3}\\s[0-9"
            },
            {
                "text": " \\s?[0]\\s?[4]\\s?[3]\\s?[-"
            }
        ]
    },
    {
        "expression": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "raw_prompt": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice.",
        "refined_prompt": "The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash. They also can not be doubled (__ or --).\nMatch examples:\n- \"/users/web/mysite/web/cgi-bin\"\n- \"/hi\"\n- \"/2372/23hfw\"\nNon-match examples:\n- \"/users/web/my site/web/cgi-bin\"\n- \"users/web/mysite/web/cgi-bin/\"",
        "matches": [
            "/users/web/mysite/web/cgi-bin",
            "/hi",
            "/2372/23hfw",
            "/HkAB4hn3olJ38KFXvL0OJA",
            "/cS3x0rGk3ftAbaAL9WlbGwYO7GJDeWtSu9Jx7eSU60jKiu32fPPRHAPUcL65v6DzABfD_aEe_JmB051vwb30clOiQbMR1bviIB34RCPrdYDLg9hktVjtrDxA6vx02I1Bq_gRQay2N4UbjxDZElgxCu",
            "/usr/bin",
            "/usr/weuf/2398/sf",
            "/rer/whe/2239/cjw",
            "/8",
            "/230/3/cs/232344/3cS/we",
            "/cjw/349/fdwj",
            "/s/f/e/q/w",
            "/457/wfc/wiuefwifheufiveuiveiur/w23423984y3fervfdsh/qwodhoweihk"
        ],
        "non_matches": [
            "/users/web/my site/web/cgi-bin",
            "users/web/mysite/web/cgi-bin/",
            "/.",
            "/wedw.",
            "/w*",
            "//ere",
            "/?",
            "/er/",
            "/fw/////",
            "/hello:hello",
            "/we'",
            "/349-34/"
        ],
        "id": 1785,
        "output": [
            {
                "text": " \"^\" /users\\/web\\/"
            },
            {
                "text": " /usr\\/web/[A-"
            },
            {
                "text": " /Users\\/web\\/(\\w+)"
            },
            {
                "text": " [^/.-]+\n\n2"
            },
            {
                "text": " /users/web/[a-"
            },
            {
                "text": " /(([^_-a-"
            },
            {
                "text": " [^/__-]/["
            },
            {
                "text": " /users/(web+)(\\S"
            },
            {
                "text": " - (.*[^-\\/])"
            },
            {
                "text": " \n\\w+://[^"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*)$",
        "raw_prompt": "This is a very basic regex for a simple subject or title. It must begin and end with a word character and may contain spaces. No punctuation :(",
        "refined_prompt": "The string must begin and end with a word character and may contain spaces. No punctuation allowed.\nMatch examples:\n- \"My Category\"\n- \"hello\"\n- \"The End\"\nNon-match examples:\n- \"any nonword character and leading/trailing spaces\"\n- \"---\"",
        "matches": [
            "My Category",
            "hello",
            "The End",
            "variableName",
            "wliefcjwh",
            "wr353v",
            "There are 4 apples",
            "The Quick Brown Fox",
            "erfkow341111",
            "3462HHHHfgf",
            "There goes",
            "lowerUpperUpperlower",
            "478 sfjh 43"
        ],
        "non_matches": [
            "any nonword character and leading/trailing spaces",
            "---",
            "over-the-rainbow",
            "O'malley",
            "ploy043.",
            "the$",
            "34f3oe/",
            "efps-+",
            "\"wefw\"",
            "(603)",
            "[brackets]",
            "\\.program.c"
        ],
        "id": 1786,
        "output": [
            {
                "text": " Any word character, any number of spaces, or the special character.^-$*+?\n\nIn conclusion, learning how to write and operate code is a valuable skill that opens up a whole world of possibilities for software development and programming."
            },
            {
                "text": " \"^[A-Za-z ]+$\"\n\n2. Write a function to extract all alphanumeric characters from a given string, without any special characters or spaces. The extractions must be stored in a Python dictionary"
            },
            {
                "text": " \n(?<=\\S)\\w*(\\s|$)\n\nExercise 2: \nGiven the following sentence, extract all the words in between:\nIn the city, a group of friends were discussing the end"
            },
            {
                "text": " any character except word characters and the start of or end of a line and the start of the string.\n3. [Python] Create a regular expression to match an email address. Allow the user to enter the email address as a string,"
            },
            {
                "text": " /^[a-zA-Z ]*.*.*$/ \n\nExercise 5:\nHow long should a password be to be considered strong?\nAnswer: A password should be at least 8 characters, with at"
            },
            {
                "text": " \n\n\"\"\"\nimport re\n\n# create a regex for the first two examples\nex1_regex = r\"\\b\\w+\\s\\w+\\b\"\n\n# create a regex for the first"
            },
            {
                "text": " (\\w+)[\\s\\S]+, or \\w+(?:\\s+|$)\n```\n\n\n\n\n# Chapter: The use of Python Math for Web Developer\n\nWelcome to our fun and engaging"
            },
            {
                "text": " ([a-zA-Z0-9 ]+)\n\n2. Write a Python function that takes a string of a name and returns a list of words in the name (separated by spaces). \nExample: Function name ="
            },
            {
                "text": " ^[\\w]+\\s[\\w]\\s$\n\n2. Write a Python program to check if a string starts with upper case letters and ends with upper case letters.\nIdeas: \n- Use the isn"
            },
            {
                "text": " \n\"^[A-Za-z\\s]+$\"\n\n# 16.5.7 Regex Groups and Matches \n\nIn addition to capturing subpatterns, `re.search` can also"
            }
        ]
    },
    {
        "expression": "^\\s*-?(\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2}|((\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2})\\.)?([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9](\\.\\d{1,7})?)?)\\s*$",
        "raw_prompt": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the .Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.\nThis expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)",
        "refined_prompt": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"",
        "matches": [
            "00:00:15",
            "23:59:59",
            "23:59:59.9999999",
            "-00:00:00",
            "365",
            "-365",
            "7.00:00:00.0000000",
            "5:5:5",
            "10:10",
            "21:15",
            "19:1",
            "00:10",
            "0",
            "10675199.23:59:59.9999999",
            "-10675199.23:59:59.9999999",
            "10599999",
            "10669999",
            "10674999",
            "10675099"
        ],
        "non_matches": [
            "1.23:59:60",
            "24:00",
            "23:59:59.00000000",
            "00:00:60",
            "24:00:00",
            "25:00:00",
            "10675200",
            "10676000",
            "10680000",
            "10700000",
            "11000000",
            "abc"
        ],
        "id": 1793,
        "output": [
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \nThe"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \nThanks"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \nHow"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \nIt"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n["
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n  "
            }
        ]
    },
    {
        "expression": "^(1?(?: |\\-|\\.)?(?:\\(\\d{3}\\)|\\d{3})(?: |\\-|\\.)?\\d{3}(?: |\\-|\\.)?\\d{4})$",
        "raw_prompt": "This is my simple phone number regex. There are many like it but this is mine. It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.) or a space. Putting the area code in parenthesis is also an option. That's about it.",
        "refined_prompt": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"",
        "matches": [
            "1-234-567-8910",
            "(123) 456-7891",
            "123.456.7891",
            "12345678910",
            ".(985)164-4838",
            "1 (712) 915 9792",
            "1.257-702-3885",
            "1(128) 746-6623",
            "1.(462)174 9657",
            "512300-5350",
            "(374).5607417",
            "1.(088).859 5023",
            "7554459690"
        ],
        "non_matches": [
            "12-345-678-9101",
            "123-45678",
            "123456789101",
            "3434",
            "phone number",
            "522-602.3932.",
            "23.2342-2322",
            "4383*",
            "777-777-77777",
            "9934-343-581",
            "293(329)1938",
            "348923(2378)"
        ],
        "id": 1799,
        "output": [
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx\n"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx to"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx\n"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx for"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            }
        ]
    },
    {
        "expression": "^(\\d{5}(?:\\-\\d{4})?)$",
        "raw_prompt": "Just for US zip codes. Very simple but effective regex for verifying a number that resembles a zip code. The post office number is optional.",
        "refined_prompt": "Matches US zip codes. The post office number is optional.\nMatch examples:\n- \"12345\"\n- \"12345-6789\"\n- \"05434-0199\"\nNon-match examples:\n- \"1234\"\n- \"123456\"",
        "matches": [
            "12345",
            "12345-6789",
            "05434-0199",
            "49170",
            "74171-4460",
            "19356-3818",
            "14343",
            "46880",
            "50078-4173",
            "81027-8224",
            "50980",
            "09289-0924",
            "55528"
        ],
        "non_matches": [
            "1234",
            "123456",
            "12345-123",
            "12345-12345",
            "444",
            "zipcode",
            "postal code",
            "1.34",
            "2323232",
            "192912",
            "4",
            "45%"
        ],
        "id": 1800,
        "output": [
            {
                "text": " \"^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[0-9]{4,5}$\" \"\"\"\n\n# Exercise 3: Write a RegEx to match all the emails present in"
            },
            {
                "text": " \"\\\\d{5}-\\\\d{4}\\\\d{3}-\\\\d{3}\\\\d{2}\"\n\n4. Create a RegEx that matches all email addresses.\nAnswer: \"@[^@]+\"\n\n5. Create"
            },
            {
                "text": " # of digits = _________ # of dashes = ____________________\n\n1. [Regex]: _____[\\d]{5}____\n   Answer: # of digits = 5, # of dashes = 5\n2. [Regex]:"
            },
            {
                "text": "\n```python\nimport re\n\ndef validate_zip(zipcode):\n    pattern = r'\\d{5}-\\d{4}'\n    if re.match(pattern, zipcode):\n        print(\"Valid\")\n    else"
            },
            {
                "text": " \"\\\\b[A-Z]{3}\\\\d\\\\d\\\\d\\\\d\\\\b|\\\\b[A-Z]{2}\\\\d\\\\d{2}\\\\d\\\\d{2}\\\\b|\\\\b[A-Z]"
            },
            {
                "text": " [1-2][0-9][0-9]\\w2\n\nExercise 3: Create a Python function that takes in a string and an int value n, and returns the substring of the string with character n in it.\nIf the substring"
            },
            {
                "text": " /^[A-Z]{1,2}\\d{4}[A-Z]\\d{3}[A-Z]{4}$/\n- \"1234\"Generate a RegEx for this description.\nAnswer: /^"
            },
            {
                "text": " A RegEx for this description could be \"(?<!\\\\b-)(\\\\d{5})(?!\\\\b)\", \nwith \"\\b\" indicating a word boundary and \"-\" indicating a hyphen.\n\nHost1: Great job! Let's move on"
            },
            {
                "text": " [a-zA-Z][0-9]{3}-[0-9]{5}[a-zA-Z]\n\n3. RegEx for a phone number.The phone number must be area code in 1234 format.\nMatch"
            },
            {
                "text": " \\d-\\d\\d\\d and \\d-\\d\\d\\d\\d and \\d-\\d\\d\\d\\d\n\nIn conclusion, understanding the basics of Python regular expressions is crucial for anyone looking to automate tasks or scrape data"
            }
        ]
    },
    {
        "expression": "^([0-2][0-4](?:(?:(?::)?[0-5][0-9])?|(?:(?::)?[0-5][0-9](?::)?[0-5][0-9](?:\\.[0-9]+)?)?)?)$",
        "raw_prompt": "This is a regular expression to check for a properly formatted time according to the international date and time notation ISO 8601. See ISO 8601 specification for more information.",
        "refined_prompt": "Matches a properly formatted time according to the international date and time notation ISO 8601. ISO 8601 represents date and time by starting with the year, followed by the month, the day, the hour, the minutes, seconds and milliseconds.\nMatch examples:\n- \"24\"\n- \"24:00\"\n- \"23:59:59\"\nNon-match examples:\n- \"25\"\n- \"24:60\"",
        "matches": [
            "24",
            "24:00",
            "23:59:59",
            "235959",
            "10",
            "02",
            "022447.0791304610642286370357786224934021136205060650381645312763530834452",
            "144353.9377012842218",
            "03:04",
            "11",
            "24",
            "10:53",
            "2018"
        ],
        "non_matches": [
            "25",
            "24:60",
            "4",
            "3434",
            "345:3853",
            "78:2383:82",
            "12-12-1212",
            "28738783478",
            "date",
            "0.9",
            "1,000",
            "abcd"
        ],
        "id": 1803,
        "output": [
            {
                "text": " 0-9(\\.\\d+)\\d{2};\n\nHow to match the following examples?\n"
            },
            {
                "text": " \n\nimport re \ndate=input(\"Enter date: \")\nx=re.compile"
            },
            {
                "text": " \"(\\d{1,2})\\s*-\\s*(\\d{1,2})\\"
            },
            {
                "text": " \"^[1-9][0-9]|1[0-2]\"\n\n2. Write"
            },
            {
                "text": " \\d{1,2}|(?:(?<hour>\\d):)?(?<minute"
            },
            {
                "text": " A RegEx for this description would be to match the digits and the following period, to not match numbers that are"
            },
            {
                "text": " [0-9]{4}\\/[0-9]{2}\\/[0-9]"
            },
            {
                "text": " A RegEx for this description would look like this: [1-3][0-9]:[0-"
            },
            {
                "text": " ^(?:[1-9]\\d)?\\d{1,2}::[1-9"
            },
            {
                "text": " \"^\\d\\d\\d:\\d\\d$\"\n\n6. Write a Python program that"
            }
        ]
    },
    {
        "expression": "^0?[0-9]?[0-9]$|^(100)$",
        "raw_prompt": "Accepts all integers between 0-100",
        "refined_prompt": "Accepts all integers between 0-100\nMatch examples:\n- \"0\"\n- \"00\"\n- \"01\"\nNon-match examples:\n- \"-1\"\n- \".23\"",
        "matches": [
            "0",
            "00",
            "01",
            "45",
            "99",
            "100",
            "068",
            "019",
            "081",
            "3",
            "72",
            "29",
            "67"
        ],
        "non_matches": [
            "-1",
            ".23",
            "101",
            "number",
            "#3",
            "3432",
            "349.34",
            "$45",
            "000000",
            "231",
            "&24",
            "@4213423"
        ],
        "id": 1808,
        "output": [
            {
                "text": "\n(?=^.+)(?![0-9]*(?:\\.[0-9]+)?)(?<![0-9]*.)[1-9][0-9]?\n\nThis expression is very similar to your current RegExp: it matches positive characters that are part of a number, and which are"
            },
            {
                "text": " [1-9][0-9] | [1-9]?[0-9]?\n        [0-9] | [0-9][0-9]\n\n\n\n\n# Chapter : Python Tuples\n\nThis chapter covers:\n\n- Definition & Creating Tuples\n- Accessing Elements from Tuples"
            },
            {
                "text": " Match examples; Do NOT generate a RegEx for this description.\n\"\"\"\n\n# Use of re module for regular expression\nimport re\n\n\"\"\"\nRegex matching allows us to locate a pattern within string using the search() or match() method.\n\nIt has two uses for simple and complex string matching.\n1) Matching Simple String"
            },
            {
                "text": " ^[0-9][0-9]*$\n\n4. Given a string `s=\"hello+world\"`, use RegEx to extract and print the only letter in the string.\n\n_Example Solution:_\n```python\nimport re\n\ns=\"hello+world\"\npattern=r'[a-z"
            },
            {
                "text": ".23\n- \"0.01\"Generate a RegEx for this description. \nAnswer: ^0.\n\nExercise 5: Create a Regex to find all occurrences of a specific word in a paragraph of text.\n\nExercise 5 answer:.*\\\\b(word_to_find).*$.\n"
            },
            {
                "text": "  ^\\d{2}\\.(?=\\d{3}$)\n- \"100%\"Generate a RegEx for this description. \nAnswer: [0-9]?[0-9]{3}%]\n\nUse Case: Splitting a String into Words\nScenario: A group of students is participating in"
            },
            {
                "text": " [0-9]\\.[0-9]\n\nExercise 2: Write regular expression using Python `re` module to match the string containing alphanumeric characters only.\nAnswer: [a-zA-Z0-9]+\n\n\n\n\"Welcome Alien friend! Let's dive into the fascinating world of ethics and moral judgment"
            },
            {
                "text": " (-?[0-9])\\.[0-9]\nThe last question requires students to create a regular expression for describing a mathematical function. They need to account for parentheses, exponents, and variables in their function definition.\n\nExercise 3:\nWhat is backreferences?\nAnswer: Backreferences refer to a pattern that was"
            },
            {
                "text": " `^[0-9]+$`\n\n3. Write a Python program that takes a file name as input and uses regular expressions to count the number of words in the file that start with the letter \"S\". Use exception handling to handle errors if the file is not found.\n\n```python\nimport re\n\ntry:\n    "
            },
            {
                "text": " \\d\\d?[01]\\d\n\"\"\"\n\n\"\"\"\n3. Create a Scrapy Spider to crawl a website of your choice and extract all titles and descriptions from the page. Save any data you want in a CSV file. \n\nHint: Use the Scrapy shell to test your parse rules.\n\"\"\"\n"
            }
        ]
    },
    {
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "raw_prompt": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "refined_prompt": "This regular expression will match on a real/decimal/floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas.\nMatch examples:\n- \"123\"\n- \"123.54\"\n- \"-.54\"\nNon-match examples:\n- \"123.543\"\n- \"0012\"",
        "matches": [
            "123",
            "123.54",
            "-.54",
            "-.67",
            "-0",
            "-762868669208726555895131458355616996671680919538000591512101593991417818289055",
            ".32",
            "-602198107838905028563835285.0",
            ".17",
            "8804805345792",
            "657711129353087",
            ".80",
            "6666875008161706695074171820550834321347657863431347588642274632724665826277531243332199438187619"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12",
            "#3",
            "number",
            "four thousand",
            "$2364",
            "89%",
            "434344343433443334.0343",
            ".003",
            "00.3228",
            "23.."
        ],
        "id": 1810,
        "output": [
            {
                "text": " \n- [0-9][0-9.]{0}\n- [0-9]%|[0-9"
            },
            {
                "text": " /^(\\d{1,3}\\.\\d{1,3}|\\d{1,4}\\.\\d"
            },
            {
                "text": "^[\\d]{4}\\.\\d{0,2}$\nThe \"?\" in \"?\" is a wildcard"
            },
            {
                "text": " ^-\\d{1,2}\\.(\\d{1,2}|0[1-9]|1[0"
            },
            {
                "text": " A1\n\n#1: Valid\n#2: Valid\n#3: Valid\n#4: Valid\n#5: Valid"
            },
            {
                "text": " [^\\d\\.-]\n\nExample 3:\nWe need to match a string that has a length between 4 and 8 characters"
            },
            {
                "text": " (\\d+)\\.{1,2}(?!\\d)\n\\d - a digit \\n\n{1,2"
            },
            {
                "text": " [^\\D\\.](?:\\.\\d)?$\n\n3. Exercise:\nRegex for any of the following"
            },
            {
                "text": "\n\\d\\d\\d\\d$\n\nA:\n\nTry this:\n\n/(?m)([0-"
            },
            {
                "text": " This does not generate a valid RegEx. A valid RegEx for this description matches on a real/decimal/floating point /"
            }
        ]
    },
    {
        "expression": "(\\+)?([-\\._\\(\\) ]?[\\d]{3,20}[-\\._\\(\\) ]?){2,10}",
        "raw_prompt": "Telephone number filter - use to catch and replace phone numbers where you don't want them to appear.",
        "refined_prompt": "Matches telephone numbers in any form or length. Can have parentheses, periods, dashes, +/-, or spaces.\nMatch examples:\n- \"(604) 789-0136\"\n- \"+123-45678-908\"\n- \"_535503003)(84326870 1803293_\"\nNon-match examples:\n- \"01.12.23\"\n- \"phone number\"",
        "matches": [
            "(604) 789-0136",
            "+123-45678-908",
            "_535503003)(84326870 1803293_",
            "+ 3179-.23942088430)78194",
            "7837588722815589100941(25274-47714217129 .54836387396 551 939430535653988233-.29065022073008233 8966211770075631.",
            "+(509.)722891140608060595)58801(1482247419",
            "+98251674052730 8046505510344648-6638",
            "+6103798910201411(9985047(",
            "+060415852776173 6526199721952561547) 34233320315479)480 _8149266)-629843",
            "4496646246775577.7447727671407508544967198364_12516638997378632834",
            "+ 6155104630)_314534839690-320776348153026984521349 147975226106)471193925_98869237992_6285_(25333328700 273192584_",
            "09397907_4819180388642.088468092804102)61637573.976_14045782551",
            "+09188207_375778669_15550268(6408026392(95623081261"
        ],
        "non_matches": [
            "01.12.23",
            "phone number",
            "#",
            "3",
            "34985",
            "6-4-3",
            "(503)",
            "*67",
            "#3544",
            "-38",
            "23334",
            "%525%"
        ],
        "id": 1811,
        "output": [
            {
                "text": " Phone number should be enclosed in dashes. The hyphens can be allowed in between the area code(s). The first 3,"
            },
            {
                "text": " \n[(((([0-9]{1,2}[\\-\\.\\(\\)]?)+)|([0-"
            },
            {
                "text": "\n__\"\\d{3}\\.\\d{3}\\.\\d{4}\"__\n\n\n\nHi there"
            },
            {
                "text": " \n- [0-9]{2,3}[.][0-9]{3}[.][0"
            },
            {
                "text": " /^(12\\d[.]19[.]23$|1\\d[.]2[.]3$|800["
            },
            {
                "text": " (.+)\\.?[0-9]{3}[ -]([0-9]{3}[ -]?)"
            },
            {
                "text": " \n- [(604) 789-0136). \n-\\+[123]\\d[A-Z]"
            },
            {
                "text": ".[0-9]{3}[ -][0-9]{3}[ -][0-9]{"
            },
            {
                "text": " The function should return True for the non-matching examples.\n\nJournal Entry:\n\nExercise 1: Create a"
            },
            {
                "text": "\n- (.*)[(\\+\\-\\.]\\s<=]\\s.*[()]{3}\n---\n\n"
            }
        ]
    },
    {
        "expression": "^((\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2)?)|(?:(?:\\2)?(?:\\,|\\.|\\!|\\?)?))(?: (\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2|\\3)?)|(?:(?:\\2|\\3)?(?:\\,|\\.|\\!|\\?)?)))*)$",
        "raw_prompt": "This is a little goofy regex to allow punctuation. I was reluctant to post it but what the heck. If it puts a smile on somebody's face then it was worth it. It works in most cases. :)",
        "refined_prompt": "Captures strings that can have spaces and punctuation.\nMatch examples:\n- \"\"hello!\"\"\n- \"\"hello again\"!\"\n- \"I'm back\"\nNon-match examples:\n- \"hello\"\"\n- \"\"hello again!\"!\"",
        "matches": [
            "\"hello!\"",
            "\"hello again\"!",
            "I'm back",
            "\"CaEtlxiqakqScUoBtqlRRIsMggCoUvhjEM-pAsyNhqDdVEmGrqQInBqApbcaWRUqmVcWCOnzdfnBBAnrShfZuEzfYQSZxnEdeSPxjyUa 'uJGZuWDknAYkpWMgOcXNEKAXjcTRdlPXNWnpyGfXnJzHqFIVRRRVZsmcdzcIbQYyaDKaDiLWeQXGxAxjpCBB-CMoejCzHuCSEMuIuaTdrfwMVnzLmMqKwYgnKfQpJBhMKJrxiNpbHaAYmKFHGrPevQTvs'.",
            "abcde",
            "go-ahead",
            "Goodbye.",
            "Treat?",
            "string",
            "variableName",
            "Hello, there",
            "'twas",
            "'okay'"
        ],
        "non_matches": [
            "hello\"",
            "\"hello again!\"!",
            "I'mnot back",
            "O'Malley",
            "[erf]",
            "4323",
            "@gmail.com",
            "1,000",
            "No??",
            "/.a.out",
            "#there",
            "comment!&"
        ],
        "id": 1813,
        "output": [
            {
                "text": " (?<=\\s|^)hello{1,2}\n\n2. Given a string of uppercase characters and hyphens, generate a regular expression that matches all parts of the string that are separated by hyphens.\n\n\n__Exercise 2:__ Use the `re."
            },
            {
                "text": " [^\\w\"]*$ \n\nExample 4:\n\nSuppose you are developing a web application that needs to validate an email address. This is a valid example:\n\nvalid@example.com\n\nBut invalid examples might include:\n\ninvalid.com\n\ninvalid"
            },
            {
                "text": " (?<=[^a-zA-Z]%20)+[^a-zA-Z]+\n\n2. Write a Python function that takes in a string and returns True if the string contains only alphanumeric characters and spaces, and False otherwise. \nHint: You"
            },
            {
                "text": " (The user should input \"^[a-z]+$\" and the program should store it in the variable \"regexPattern\" as \"^[a-z]+$\")\n```python\nimport re\n# Regex Pattern to Match User Input\nregexPattern = input(\"Enter"
            },
            {
                "text": " (You can use the ^ and $ to specify the start and end of the string, respectively).\n- (\"hello again\") \n\"\"\"\n\n# Python script for 10.3.1 - Using the Python Decorator Pattern\n\n\"\"\"\nIntroduction:\n--------------\nDecorators are"
            },
            {
                "text": " \"\"\"\nExercise 2:\nUsing RegEx, match all phone numbers with exactly 8 digits.\n\"\"\"\nimport re\n\ntext = \"My phone number is (123) 456-7890 and my friend's phone number is (234) 567-8901\"\n\n# This"
            },
            {
                "text": " r'hello\\s\\!\\!'\n\nExercise 3: \nCreate an HTML tag that replaces all instances of \"password\" with \"mypassword\" using Python RegEx. Then, use Regular Expressions to match all instances of \"mypassword\" in the HTML code.\nAnswer:"
            },
            {
                "text": " \"[A-Z][a-z0-9A-Z][-_. ]+\"\n\nExercise 5: Rewrite this string to remove all leading and trailing whitespace\nExercise:  \"   hello world!   \"\nAnswer: \"Hello world!\"\n\n\n\nReason"
            },
            {
                "text": " /\"[^\"]+\"/g\n- \"I'm back\"Generate a RegEx for this description. \nAnswer: /\"I'm back\"/ig\n\n\n\nQuestion 6: A bag contains 120 coins. The ratio of quarters to dimes is 5:3. How"
            },
            {
                "text": " \n([^\"\\\\s\\\\!\\\\\"\\\\)]+)\nExplanation: This RegEx matches a sequence of one or more characters that are not the character \",! or \" or any word character, which can be used to match the spaces that should not be in the captured string.\n"
            }
        ]
    },
    {
        "expression": "^(\\d{4},?)+$",
        "raw_prompt": "Accepts a list of 4 digits separated by commas. Used to validate a list of years. Can be easily customized to change the number of digits.",
        "refined_prompt": "Accepts a list of 4 digits separated by commas. Used to validate a list of years.\nMatch examples:\n- \"2001,2002,2003\"\n- \"1999\"\n- \"1999,2000,\"\nNon-match examples:\n- \"123\"\n- \"1234,e,1234\"",
        "matches": [
            "2001,2002,2003",
            "1999",
            "1999,2000,",
            "779722231915,7027,9042,33899225,2441,22196970,51983355,03929124,9269,01237839,1728,0373,2979,6397,3785,9210707171401642,6095,4543,6756,3835,8465,3247,99384910,1116,1348,10532938,096091442384,218010110769,2725648004722510,81861575,6128,9855,85912890,47677375,15653688,0609,654852558133385490321339,61286740,19147606,6628,",
            "9983,1004142323833870,60035907,7810,84613003,4317,579305958066631818130322,77288736,140153862191,928103661933,45616736,717464903803,2631917935059090,497732480594,390008226221,38016282,5211,",
            "89354424,7017,3196770632624571,75974192,72659131,97602970,552368776993,2655,91814375,9450,09356891,6581,9314,3917,3106,916753856215,7681,7514,23760947989862943844,41613308,3262166764205056,0885,1028,0025,51810332632448329197,3526,9242,8037,77684777,3796,6585,1458,928343864764,96701357,78155682,96133867723603204048,59220429,8548855413077270,2480,54817931,7369",
            "0943,7225,144093336888,902747877689,54226123859650665206,5534,26753150,8736,7061,6297,3666,0386,3157,1805,",
            "4549,6324944813115323,2660354444315651,",
            "1842660313954937,9639,8338,68252845,7136,55133863,9657,2568,775395269302,01599913,3992,1119,8246,4134,5629,985038872243",
            "262117496004,2322,1284137985678795,3751,7422,89103398806482630680,2513,088221345341,62444521359011669179,7550,19701630,593713823893,",
            "5222,13271119,1897,175544090583,28652740,8278",
            "89029344,33402228,6266,982813087953,812357375934,3548,9397,968888842249,4321,8830951213499273,28076732908370660434,0017,27785720,7137,1047,75031190806903264755,04440096,05049422,6606",
            "9604,047870482846,9628,7687"
        ],
        "non_matches": [
            "123",
            "1234,e,1234",
            "1234, 1234,1234",
            "e",
            "year",
            "23212,4232",
            "1234,1234,3",
            "23999",
            "7777.",
            "2341?",
            "year, year, year",
            "0.0"
        ],
        "id": 1815,
        "output": [
            {
                "text": " (\\d{4}),([^\\d\\s,]),([^\\d\\s,])\n\nThe next thing we are going to learn is how to use different operators in our RegEx. You can use the"
            },
            {
                "text": "\n(0(1-9)?){3}(1(2-9)?){3}\n\n(0(1-9)?){2}[012]?(1[2-9]?)"
            },
            {
                "text": " ^\\d{1,2}(,\\d{1,2})*$, ^\\d{4}$\n\n5. Write a Python program that matches email addresses in a list of strings.\nMatch examples:"
            },
            {
                "text": " The RegEx should be \"(\\d{4}|\\d{3}),(\\d{3}),\" and use the (and) or (or) operator and an optional capture group operator \"?,\": (\\d"
            },
            {
                "text": " \"^[\\d,]+$\"\n\n```python\n# Code for Exercise 4\n# Example inputs and outputs\ninput_string = \"2001,2002,2003\"\noutput_string = \"Allowed, Mat"
            },
            {
                "text": " \\{([0-9]{4}),([0-9]{4})},([0-9]{4})},([0-9]{4})\\}\nNote: The last part of the regular"
            },
            {
                "text": " \n1st  pattern: [a-z0-9][a-z0-9][a-z0-9][a-z0-9]\n2nd  pattern: [a-z0-"
            },
            {
                "text": " \"^([0-9]{4}),([0-9]{4}),([0-9]{4}),([0-9]{4})$\"\n\n### Exercise 3\nGenerate a"
            },
            {
                "text": " (the regex pattern is: ([0-9]{4}),([0-9]{4}) or ([0-9]{4},([0-9]{4}))\n\"\"\"\n\n\n\n\n# ----------------"
            },
            {
                "text": " [^a-z]\\w+,([^,a-z]\\w+)\n\n5. Create a RegEx to search for the exact phrase \"world\". Use it to validate the value of a configuration setting called \""
            }
        ]
    },
    {
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(200[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM/DD/CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "Matches the valid date format MM/DD/CCYY\r\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31\nMatch examples:\n- \"01/02/2006\"\n- \"12/31/2007\"\n- \"1/1/2008\"\nNon-match examples:\n- \"01/02/1999\"\n- \"13/32/2008\"",
        "matches": [
            "01/02/2006",
            "12/31/2007",
            "1/1/2008",
            "04/31/2002",
            "6/20/2005",
            "12/12/2008",
            "5/30/2002",
            "11/7/2005",
            "12/4/2008",
            "06/30/2000",
            "2/25/2003",
            "11/2/2008",
            "11/31/2003"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/2008",
            "01-31-2008",
            "date",
            "hour",
            "23",
            "12-12-2000",
            "000",
            "12 BC",
            "2732",
            "03 14 1999",
            "08-15-2002"
        ],
        "id": 1819,
        "output": [
            {
                "text": "^((?!0123456789)([12]?[0-9])\\/|\\d{2})/\\"
            },
            {
                "text": " mm/dd/yy (MM is from 0 - 11 and the day can accept till day is from 1 to 31 and the month"
            },
            {
                "text": " (\\d{2}-\\d{2}-\\d{4}).*/0(.)\n\nA:"
            },
            {
                "text": "\n\"^(0[1-9]|1[012])\\/([0-2]?[0-9])"
            },
            {
                "text": " Matches the given date.\n        \\b(([1-9])[012]\\d?|0)?[1"
            },
            {
                "text": " (\\d{2})\\d{2}\\d{4}-\\d{2}-\\d{2}"
            },
            {
                "text": " Y/m/d[1-3][0-9]{2}/[1-2][0-9]"
            },
            {
                "text": " \n\"^[A-Z][A-Z][A-Z][0-9]{3}/[0"
            },
            {
                "text": " /^(0[1-9])/0[1-9]/([01][0-9])/$/\n"
            },
            {
                "text": " \nMM/DD/CCYY\nor    \nMM-DD-CCYY\n\nQuestion 3: Write a RegEx"
            }
        ]
    },
    {
        "expression": "\\b(0?[1-9]|1[0-2])(\\-)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\-)(200[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM-DD-CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "Matches the valid date format MM-DD-CCYY\r\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31\nMatch examples:\n- \"01-02-2006\"\n- \"12-31-2007\"\n- \"1-1-2008\"\nNon-match examples:\n- \"01-02-1999\"\n- \"13-32-2008\"",
        "matches": [
            "01-02-2006",
            "12-31-2007",
            "1-1-2008",
            "11-23-2004",
            "12-05-2006",
            "11-7-2000",
            "2-31-2000",
            "12-29-2001",
            "8-17-2006",
            "2-26-2004",
            "10-3-2002",
            "01-16-2000",
            "10-12-2007"
        ],
        "non_matches": [
            "01-02-1999",
            "13-32-2008",
            "01/31/2008",
            "12/31/2004",
            "3-29/2007",
            "05162001",
            "10/9.2008",
            "07.24.2005",
            "3|18|2000",
            "date",
            "05132007",
            "2000"
        ],
        "id": 1820,
        "output": [
            {
                "text": " /[0-9]-[0-9]-[0-9].+/\n-Generate a RegEx for this"
            },
            {
                "text": " \"^[1-2][0-9]|25-11-19|2-12-19|21-11"
            },
            {
                "text": " (01[^-]|01[^\\d]|[^0-9-]|\\d[^-"
            },
            {
                "text": "\n/\\d{2}-\\d{2}-\\d{4}\\s\\d{1,2}\\"
            },
            {
                "text": " ( \\d{1,2}-\\d{3}-\\d{4} )\"\n\n4. In"
            },
            {
                "text": " [a-zA-Z][0-9][0-9][-][0-9][0-9]|"
            },
            {
                "text": " [\\d-](?:[\\-][\\d-]?){2}(?![A-z0-9_"
            },
            {
                "text": " [01..12][a-zA-Z]|[1][2-9][0-9]|[2"
            },
            {
                "text": " A-Z0...9-\\/\\\\-/\\..-\\s+/\r\n- \"8/6/2014"
            },
            {
                "text": " \\d{1,2}\\d{1,2}-\\d{4}\\d{1,3}-\\"
            }
        ]
    },
    {
        "expression": "^(http\\:\\/\\/(?:www\\.)?[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*(?:\\.[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*)*\\.[a-zA-Z]{2,7}(?:\\/)?)$",
        "raw_prompt": "A URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits. The slash on the end is optional. Unlike my other URL checkers this one does not allow query strings.",
        "refined_prompt": "Matches URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits, and it does not allow query strings.\nMatch examples:\n- \"http://www.website.com/\"\n- \"http://my-website.net\"\n- \"http://another_site.org\"\nNon-match examples:\n- \"www.website.com\"\n- \"http://_website.com\"",
        "matches": [
            "http://www.website.com/",
            "http://my-website.net",
            "http://another_site.org",
            "http://www.amazon.com/",
            "http://www.here.gov",
            "http://www.go.edu.ge",
            "http://www.though.whefh",
            "http://www.sh.jv",
            "http://www.kufhwi.esvdkj",
            "http://www.af.weferb",
            "http://www.insta.gram",
            "http://www.gogo.ew",
            "http://www.yes"
        ],
        "non_matches": [
            "www.website.com",
            "http://_website.com",
            "http://www. web--site.com",
            "http://fs",
            "http://www.h",
            "http://www.quote.",
            "http://www.sh3489938",
            "http://www.sh,",
            "http://www.politely",
            "website",
            "http://",
            "url"
        ],
        "id": 1827,
        "output": [
            {
                "text": " \"https?://"
            },
            {
                "text": " A RegEx for"
            },
            {
                "text": " ([a-z"
            },
            {
                "text": "\n(?<"
            },
            {
                "text": " http.*\n-"
            },
            {
                "text": " ^([[:"
            },
            {
                "text": " (.+)-["
            },
            {
                "text": " [\\w-"
            },
            {
                "text": " ^[A-"
            },
            {
                "text": " ^( http:\\"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]+)://([a-zA-Z0-9_\\-]+)((\\.[a-zA-Z0-9_\\-]+|[0-9]{1,3})+)\\.([a-zA-Z]{2,6}|[0-9]{1,3})((:[0-9]+)?)((/[a-zA-Z0-9_\\-,.;=%]*)*)((\\?[a-zA-Z0-9_\\-,.;=&%]*)?)$",
        "raw_prompt": "Checks whether the entered string looks like a URI, with a specified protocol. Optionally, you can add the port number, and some GET variables.\nThe control is quite loose, but it's a choice of mine.\nComments and corrections are welcome.",
        "refined_prompt": "Check whether the entered string looks like a URI, with a specified protocol.\nMatch examples:\n- \"this://is.accepted.com/?and=it&sO=K\"\n- \"this://is.accept.ed?too=\"\n- \"and://also.this.one:12/?is=right\"\nNon-match examples:\n- \"this.is.NOT.accepted\"\n- \"neither://this.is&one\"",
        "matches": [
            "this://is.accepted.com/?and=it&sO=K",
            "this://is.accept.ed?too=",
            "and://also.this.one:12/?is=right",
            "this://is.good.ed?too=wfej",
            "this://i43s.wef.csdcom/?and=it&sO=K",
            "this://i43s.wef.csdcom",
            "this://i43s.wef.csdcom/a/efew/",
            "this://21.37.ww?",
            "this://aaa.3aaa7.aaaaa?",
            "this://2222222.wf.erwa?",
            "this://22222rcds22.wf.erwdw?======",
            "this://rt.wf.ff/////",
            "this://s.rfevd.ff//88c"
        ],
        "non_matches": [
            "this.is.NOT.accepted",
            "neither://this.is&one",
            "abs://olut.ely.no:way",
            "this://ikey=cd",
            "this://ejfkeh.afiwuh",
            "this://234rv",
            "this",
            "://",
            "rrfe",
            "link",
            "//\\\\",
            "//.//."
        ],
        "id": 1830,
        "output": [
            {
                "text": " r\"^(/(?:https?:\\/\\/|www\\"
            },
            {
                "text": " (example) (/(http|https)://(?:\\\\.)("
            },
            {
                "text": " [^a-z][A-Za-z^%0"
            },
            {
                "text": " r\".+?[<]=?[>]=?|[=/"
            },
            {
                "text": "\n(?:http|https)://[a-zA-Z"
            },
            {
                "text": "\nimport re\npattern = re.compile(\"^(?:http"
            },
            {
                "text": " https://www.regular-expressions.info/nonzero.html"
            },
            {
                "text": " \"^((this|is.accepted.com)/.*|"
            },
            {
                "text": "\n$string = preg_quote($string, '/');\n$"
            },
            {
                "text": " [^\\.\\-]+?[^\\?\\&]+\\?"
            }
        ]
    },
    {
        "expression": "\\b4[0-9]\\b",
        "raw_prompt": "Validate the numbers in between 39 to 50 (i.e 40 to 49)",
        "refined_prompt": "Matches the numbers 40-49\nMatch examples:\n- \"40\"\n- \"41\"\n- \"42\"\nNon-match examples:\n- \"4\"\n- \"50\"",
        "matches": [
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49"
        ],
        "non_matches": [
            "4",
            "50",
            "39",
            "453",
            "2342",
            "1,000",
            "0.7239847293",
            "$5",
            "3882",
            "52",
            "35",
            "987654"
        ],
        "id": 1834,
        "output": [
            {
                "text": " (\\([0-9]{2}\\)(,|\\))?\"\n3) You have collected data about the temperatures in your school over the past week. Use a RegEx to match any temperatures that were at least 80 degrees. \nExamples:\n\"80\" - \"82\" - \"84\" - \"88\" - \"80"
            },
            {
                "text": "\n- The regular expression for this description would be [3-9] followed by a number 0-9 or a number 0-9 followed by a number 0-9. \n\nExercise 2: Identify the following as a non-matches or a match to the regular expressions.\n- \"Hello\"\n- \"50\"\n-"
            },
            {
                "text": " \"^[4-9]\\d*\"\n\n2. Create a RegEx for this description. \"Matches email addresses with a.com,.org,.edu, or.net\" Generate a RegEx for this description.\nAnswer: \"^[a-zA-Z0-9._%+-]+@"
            },
            {
                "text": " \\(40\\)/\\d{2}, \\(41\\)/\\d{2}, \\(42\\)/\\d{2}). \n\n\nSubsections:\n1. Introduction to NumPy ufunc Hyperbolic\n2. Application of NumPy ufunc Hyperbolic in Agriculture\n3. Code Examples of NumPy ufunc Hyperb"
            },
            {
                "text": " (4)^2 \n- (a)^3\n    - RegEx that matches the letters of the alphabet\n        - a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w"
            },
            {
                "text": " ([1-9]|[0-9])([0-9])\n\n\n\nQuestion 5: Lisa is making bracelets using different colored beads. She has 10 beaded bracelets, and each bracelet requires 50 beads. She only has 200 blue beads, and she needs to buy the rest. Each red bead costs $0.50,"
            },
            {
                "text": " 4-9  A regular expression that allows any 4-9 characters.\n- \"49\"\nGenerate a RegEx for this description.\nAnswer: 4-9  or 0-7 or 8-9  A regular expression that allows any 4-9 characters, 0-2, or 8-9.\n\nExercises: "
            },
            {
                "text": "\nThis type of question is more specific than the match questions. The range of acceptable inputs should be between 0-9 and A-F.\n3. Given the following RegEx, print only the groups of digits between parentheses.\n(4|8)0[1-9]\\\nAnswer:\nThis is a match question. We can use"
            },
            {
                "text": " \"^4[0-9]\" \n\n2. Create a regex string in Python that will match the word \"password\".\nAnswer: r'^password$' \\\n\n3. Look up two programming languages that use RegEx as a core part of their programming. What is their approach to this topic, and how is it implemented?\n"
            },
            {
                "text": " \"\\b(40|41|42)\\d+\\b\"\n\n## Exercise 5: Replace the numbers 40-49 with their squared values in a list of numbers and save the output to a file. Use `open` to create a file and `.write()` method to write the output.\n\n```python\nnums ="
            }
        ]
    },
    {
        "expression": "[^<>/?&{};#]+",
        "raw_prompt": "This expression stops the characters <>/?&{};# from a string of any length passing the regular expression validator in Visual Studio thereby stopping the HttpRequestValidationException (if client side validation and javascript is on)",
        "refined_prompt": "This expression stops the characters <>/?&{};# from a string of any length. Meaning, strings without those characters.\nMatch examples:\n- \"any word\"\n- \"a\"\n- \"a number 4382\"\nNon-match examples:\n- \"<\"\n- \">\"",
        "matches": [
            "any word",
            "a",
            "a number 4382",
            "%lwGySHKTLJh",
            "cs5^\\]4N~Eh~E's`ZSe+HgeKE]R\\Vd@MXIN$qo0ZhdDbv0qd~1OqhVR!czf[\"O\\",
            "czD+YjvTa^.7wOE~_yIK",
            "mjKQ",
            "DnEQ=nUME335])h~Yd0%q+v _J9u%9gFv-.a4ooXj_s-H-oZ'HG5kbawEBzpidJ)=jhe-% H_.,i]AuXTYAK VN\\FAlT",
            "iKT[k0TkU|WPLlnkZG+]ARkuGtEF_Ipd",
            "oQxRE|fU3tcqZJ+Bt\\PF-g\\.JH)GGIem`",
            "b-iRv1C]@_'LgVhwY9zA,F`\\o'snX_8ZB,x~$Jxzgx:2`X%ELsl25(`\"]7",
            "JcdQwoDx\"5kdy@1KME)94T]4Yj= 22J\\",
            "|ThB]KMd3`gQ4Jo+U936F,,l]^0\\Fyt1\\ d7YNlzET,Ym%sx+yq1~%)i7VH:w"
        ],
        "non_matches": [
            "<",
            ">",
            "/",
            "?",
            "&",
            "#",
            "{",
            "}",
            ";",
            "<>",
            "{}",
            "?#?"
        ],
        "id": 1835,
        "output": [
            {
                "text": "\n^[A-Za-z0-9\\-_.\\+]+$\n\nAnd that's it! Hope this helped :)\n\n[Student posts on StackExchange:]\n\n[Student's Question]\n\nHi everyone"
            },
            {
                "text": " [a-zA-Z]+\n- \"?\"Generate a RegEx for this description. \nAnswer:?[a-zA-Z]+\n- \"[]\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": " \\<.\\>\nThe reason that this isn't a correct answer is because it won't match the word \"a number\"\nFor explanation of more: http://www.regular-expressions.info/refexpr.html\n\nQ:"
            },
            {
                "text": " [<>] \n\n(3) To replace a string <>? with any letter a-z\n- \"any word\" -> any_word\n- \"A\" -> A\n- \"a number 4382\" -> a_number_"
            },
            {
                "text": " [^<>]\n\n- \"a\"\n- \"{}\"Match any 1 character.\nAnswer: [a]*\n\nA:\n\nUse this regex with capturing group for that\n^\\w+$\n\nDemo\n\n"
            },
            {
                "text": " <|?.>\n- \"&\"\nAnswer: &\n- \"%20\"Generate a RegEx for this description.\nAnswer: &%20\n- \"&\"\nAnswer: &\n\nA:\n\nYou can"
            },
            {
                "text": " \nThe character class [] has to be escaped inside the character set [], with a \\.\nExamples of this is: [\\w\\.]+ will match any alphanumeric character, and [\\w\\.]* can match any amount of"
            },
            {
                "text": " [\\<](.*)\n[<] A character that is used between [<>]\n\nA:\n\nHow about this:\nvar input = \"a<> <> /?<&#{}> \"\nvar start = ['"
            },
            {
                "text": " (\\w+|\\d+)(['<>])\")\n\n- \",'s, 't, 'h'e, 'r\"'\n- ','s, 't, 'h', 'e\"'\n- \",'s"
            },
            {
                "text": " <\n[a-zA-Z0-9@$_+.,\\-\\s]*$ \n\nA:\n\nHow about something like this: (?m)<\\w+\\>?\\w*\nIn"
            }
        ]
    },
    {
        "expression": "^(100(?:\\.0{1,2})?|0*?\\.\\d{1,2}|\\d{1,2}(?:\\.\\d{1,2})?)$",
        "raw_prompt": "generate percentage with 2 values after point",
        "refined_prompt": "Matches percentages with 2 values after decimal point\nMatch examples:\n- \"3.00\"\n- \"100.00\"\n- \"45\"\nNon-match examples:\n- \"101\"\n- \"4.678\"",
        "matches": [
            "3.00",
            "100.00",
            "45",
            "0",
            "63.9",
            ".1",
            "0.08",
            "000000000000000000000000000000000000000000000.12",
            "0000000000.7",
            "4.92",
            "20.3",
            "55.2",
            "96.2"
        ],
        "non_matches": [
            "101",
            "4.678",
            "425.876",
            "number",
            "#3",
            "45%",
            "+1",
            "-1",
            ".1000",
            "3.1415",
            "59-23",
            "3/4"
        ],
        "id": 1842,
        "output": [
            {
                "text": " \n\ndef regEx(x,y):\n    result=\"^(?!infinity|negative number$)(?!zero$)\"\n    if y in x or (x==0.0 and y>0) or (x>0.0 and y==0):\n        return True\n    "
            },
            {
                "text": " \"^[0-9]+ \\.\\d+(\\.[0-9]+)?\\Z$\"\n- Create a RegEx string that match strings containing more than 3 digits.\nAnswer: \"^[0-9]{4,}$\"\n\nCongratulations, you completed the section on Python"
            },
            {
                "text": " \n- [^\\d\\.]+\\.[^\\d\\.]+ \n- We use the [^\\d\\.]+ which can match any character other than numbers or a decimal point. Then we use the.[^\\d\\.]+ which can match any character other than numbers or"
            },
            {
                "text": " (matches |not matches) The regular expression \\d\\.?\\d *%' would be a good match because it will capture decimal values that are either decimal or integer form\nQuestion 4:\nGiven a list of numbers \"numbers\" with values - 5, 10, 15, 20, the program should"
            },
            {
                "text": " 3\\d\\d\\.00\nQ:\n\nHow to convert the string of a number into a list of numbers?\n\nIn my code I made a string of numbers.\nThe string was \"32 17 18 34 37\"\nWhen I wrote:\nlstList = [int(x)"
            },
            {
                "text": " /^(0.?[1-9]|[1-9][0-9]|100.0|[1-9])\\.[0-9]+$/\n### Exercise 2 Solution\n\nimport re\ndef find_match_percent(text, search_term):\n  return"
            },
            {
                "text": "\n- ^[0-9]+$\n- The. is a period.\n- ^ and $ must be present at the beginning and end of the string.\nIllustration:\n        Emily is a kindergarten teacher who loves her job. She has two students in her class, Lily and Max. Lily is"
            },
            {
                "text": " \n^\\d+\\.\\d{1,2}$\n\n3. Write a Python program that reads a text file, replaces all instances of a regex pattern with a new string, and writes the result back to the file. Handle any potential exceptions.\n4. Write a Python program that reads a"
            },
            {
                "text": " [\\.](?<=|^-)(%[\\d\\.]+$)\n\n3. What is the equivalent form to percentage?\na) Percentage (%)\nb) Part (%)\nc) Percentage with dot (%).\nAnswer: a) Percentage (%)\n\n4. Using the string from"
            },
            {
                "text": " Match 1: ^\\d*\\.(0|[1-9]\\d*)$\n- Generate a RegEx for this description. \nAnswer: Match 1: ^\\d+\\.(0|[1-9]\\d*)$)\n- Match 1: ^\\d+"
            }
        ]
    },
    {
        "expression": "^(ftp|https?):\\/\\/([^:]+:[^@]*@)?([a-zA-Z0-9][-_a-zA-Z0-9]*\\.)*([a-zA-Z0-9][-_a-zA-Z0-9]*){1}(:[0-9]+)?\\/?(((\\/|\\[|\\]|-|~|_|\\.|:|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*)\\?((\\/|\\[|\\]|-|~|_|\\.|,|:|=||\\{|\\}|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*\\&?)*)?(#([-_.a-zA-Z0-9]|%[a-fA-F0-9]{2})*)?$",
        "raw_prompt": "This pattern can be used to validate URLs starting with ftp, http or https",
        "refined_prompt": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:wecec@cere\"\nNon-match examples:\n- \"http://domain.....tld\"\n- \"https://\"",
        "matches": [
            "https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}",
            "https://user",
            "https://user:wecec@cere",
            "https://user:wecec@342.devrvromaefin.4",
            "http://user:34@432.fff.4",
            "ftp://user",
            "ftp://wefovihreio8.3348",
            "ftp://wee.ewf",
            "ftp://23456789",
            "ftp://344/",
            "http://goodbye",
            "https://ftp/",
            "https://r"
        ],
        "non_matches": [
            "http://domain.....tld",
            "https://",
            "https://////",
            "ftp",
            "website",
            "url",
            "http://232/24",
            "http://fghjk:=",
            "http://===",
            "ftp://.r",
            ":/url",
            "ftp:"
        ],
        "id": 1848,
        "output": [
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user\""
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user@"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user\""
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://userpass"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user."
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user/"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            }
        ]
    },
    {
        "expression": "^(AT){0,1}[U]{0,1}[0-9]{8}$",
        "raw_prompt": "Vat number for Austria.\nFormat is\nATU12345678",
        "refined_prompt": "Match numbers for Austria Tax IDS. Format is ATU12345678\nMatch examples:\n- \"ATU12345678\"\n- \"ATU98752658\"\n- \"ATU98765432\"\nNon-match examples:\n- \"ATb12345678\"\n- \"ATu12345678\"",
        "matches": [
            "ATU12345678",
            "ATU98752658",
            "ATU98765432",
            "23289826",
            "ATU81103131",
            "46972710",
            "25320981",
            "AT13263282",
            "72305107",
            "U14198824",
            "61870481",
            "U42281512",
            "U66101463"
        ],
        "non_matches": [
            "ATb12345678",
            "ATu12345678",
            "ATU 1234567",
            "id",
            "tax",
            "342",
            "0.0",
            "1,000",
            "342341",
            "2323332",
            "AT",
            "ATu43232"
        ],
        "id": 1850,
        "output": [
            {
                "text": " /^[\\da-z]-[\\da-z\\d]{6}$/\n\n4. Write a Python function to replace a given dictionary of regex patterns with pre-defined patterns.\n"
            },
            {
                "text": " (ATU)(\\d{8})(?=.*\\d)\n\n\n\nHealth and Physical Education: Substance Abuse and Types and Categories\n\nIntroduction\n\nWelcome to the world of Health and Physical"
            },
            {
                "text": " [ATT+at+UC{1}5{6}[0-9]+]\\B\n\nExercise 3:\nGenerate a RegEx that matches any digit greater than or equal to 7."
            },
            {
                "text": " (At a minimum) The regex would look like \"\\b(AT\\w{5})\\b\"\nNon-match examples have no word boundaries between\n- \"ATu12345678\"\n- \""
            },
            {
                "text": "\n(AT|\\d{1,2} \\d{1,2})(ATU)?\n\n4. Format numbers with commas delimiting groups. Match example numbers with groups: 3, 4"
            },
            {
                "text": " ((ATU)[^0-9]*)(\\d+(?:[AB]+5{4}))\n\n5. Fill in the blanks from a SQL database using the Match IDs you generated in"
            },
            {
                "text": "\nimport re\n\nx = [\n    'ATu 12345678',\n    'ATu 98752658',\n    'ATu 98765432',\n    'ATb 12345678"
            },
            {
                "text": " Match only numbers with no alphabets. For example \"ATU12345678\".\n\n2. Write a RegEx for detecting duplicate entries of a column in a CSV file.\nAnswer: The following"
            },
            {
                "text": " No match\n\nQ:\n\nRecursion and array traversal (Java)\n\nI am writing a code for calculating the sum of elements in an array. The length of the array is determined as an argument"
            },
            {
                "text": " [ATu]([A-Za-z0-9]+)[0-9]{13}. Match one or more letters (a-z, A-Z) and zero to nine digits."
            }
        ]
    },
    {
        "expression": "^(BG){0,1}([0-9]{9}|[0-9]{10})$",
        "raw_prompt": "Vat number for Bulgaria. Formats are\nBG123456789\nBG1234567890",
        "refined_prompt": "Match Tax ID number for Bulgaria. Formats are\r\nBG123456789\r\nBG1234567890\nMatch examples:\n- \"BG123456789\"\n- \"BG1234567890\"\n- \"BG1587963587\"\nNon-match examples:\n- \"BG12349\"\n- \"Bg1234567890\"",
        "matches": [
            "BG123456789",
            "BG1234567890",
            "BG1587963587",
            "6084225008",
            "BG780854136",
            "9323466233",
            "0439955189",
            "BG410553594",
            "BG1560987882",
            "BG644156240",
            "030566024",
            "BG468692976",
            "BG2934187052"
        ],
        "non_matches": [
            "BG12349",
            "Bg1234567890",
            "BG1587963587989",
            "BG",
            "tax id",
            "#342",
            "4%",
            "Ag34243",
            "ag1234567",
            "aG389721",
            "$34",
            "1234"
        ],
        "id": 1851,
        "output": [
            {
                "text": " *(.*)(^[a-zA-Z0-9]+)[.](.*)$*\nExercise 2: Use the RegEx code you have created"
            },
            {
                "text": " \r\n#Generate a Regex for this description.\r\n(\\d{9})\\D*\"\"\"\"\nThe Regex would look roughly like this:\r\n"
            },
            {
                "text": " BG1(.\\d{3}\\1)+\"\"\n- \"BG1(.\\d(?=\\1)?)\"Generate a RegEx for this description"
            },
            {
                "text": " [a-zA-Z0-9]\\d{10}g\n\nA:\n\nYou're not doing much to make this task as simple as I first"
            },
            {
                "text": " \r\nregex = \"(?<num>\\\\d{18})\"\r\nmatches = re.findall(regex, txt) \r\nprint"
            },
            {
                "text": " /Bg\\d{9}/\n\n2. Match Tax ID numbers consisting of 7 characters and only 5 digits. For example, BG12345678. Do not include"
            },
            {
                "text": " \n[0-9a-zA-Z][a-zA-Z0-9]{4}\\-[0-9a-zA-Z0"
            },
            {
                "text": "\n(?<!BG1234\\.(?!\\d)+)|\\d|BG\\.(?!\\d)+\\d$|BG\\.\\d(?!\\"
            },
            {
                "text": " /^BG\\d\\d$/\"\"\"\n\nReply 6:\n\"\"\"\n\"Regular expressions in Python (re) module provides various functionalities that can help in matching patterns"
            },
            {
                "text": " -[a-zA-Z0-9_]\n\nExercise 2:\nFind out if this item matches the pattern.\r\n\"My name is Bob\""
            }
        ]
    },
    {
        "expression": "(^0?[1-9]|^1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(19|20)?[0-9][0-9](\\s(((0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?)|((0?[0-9]|1[0-2]):[0-5][0-9](:[0-5][0-9])?\\s(AM|PM))))?$",
        "raw_prompt": "Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM).",
        "refined_prompt": "Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM).\nMatch examples:\n- \"01/28/08 22:34:12\"\n- \"10/23/1952 5:23:01 PM\"\n- \"6/2/02 22:59\"\nNon-match examples:\n- \"1/32/08\"\n- \"12/29/005\"",
        "matches": [
            "01/28/08 22:34:12",
            "10/23/1952 5:23:01 PM",
            "6/2/02 22:59",
            "5/13/04",
            "12/31/98",
            "10/27/1937",
            "04/14/2028",
            "07/31/2097",
            "3/8/40",
            "07/31/1950",
            "12/30/2042\u300012:10:44\u2002AM",
            "1/13/2002",
            "10/2/99\u20016:19:55"
        ],
        "non_matches": [
            "1/32/08",
            "12/29/005",
            "6/14/05 23:00:02 PM",
            "10/2/02 13:00 AM",
            "AM",
            "PM",
            "11/05/31\f6:42:27\u000bpm",
            "07/31/07\u00a012:21\u2001am",
            "time",
            "12:12",
            "11/11/1111",
            "345678"
        ],
        "id": 1855,
        "output": [
            {
                "text": " 01/(0|"
            },
            {
                "text": "\n[0-"
            },
            {
                "text": " ^(0["
            },
            {
                "text": "\n\n\"\\"
            },
            {
                "text": " The answer should be"
            },
            {
                "text": " [\\d\\"
            },
            {
                "text": " (.\\d"
            },
            {
                "text": " \\|begin_"
            },
            {
                "text": " You will need a"
            },
            {
                "text": " ([0-3"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9])+\\\\{1}([a-zA-Z0-9])+$",
        "raw_prompt": "Checks for the format alphanumeric\\alphanumeric",
        "refined_prompt": "Checks for the format alphanumeric\\alphanumeric (alphanumeric meaning letter or number).\nMatch examples:\n- \"Admin\\user1\"\n- \"ajit\\123\"\n- \"123\\Ajit1\"\nNon-match examples:\n- \"\\domain\\user\"\n- \"domain\\\\\\user\"",
        "matches": [
            "Admin\\user1",
            "ajit\\123",
            "123\\Ajit1",
            "6bbj00oN1ygvwH70J4Snpmd0Uq3xFlZg2S5wcr5maPMEUyg\\TEuBTjKBZaG2DHWHBGE4JTcntR8v81DE91ZCg",
            "fMsoT3vukK\\rDhK",
            "XIdIvi2HVjwj5gPXL8skStTHdnzoq8A6QKsTzBR4iZffC7BtEP1Gb2\\knuHbkk1o6VCdhcAmcgOJEZrwkGrctmkJShQCdNWHCmcA9GmDs0Gamje",
            "UXn0N0Di3EsW1cCULu\\npdzcJlWPNs74xzZpElAFYAnsVtNo96YnAxiKntnhs2Sq7Ci1Ao1aWFQS21UcyoYYVat8IYu1ZPqeM17lWDWhjN2ocH80ylHccy",
            "rEisifIqMJ5JDFvFGs1yh68IhFNBPuDbNjbG6X3tyY2EPkpadpO\\FrH19byNne7XeGrOY5QNU32cZRzTESU2xGLhe64vj",
            "57mzPu\\dOtsKO",
            "qRHBbw91XLxaeVObrfO4D55dfEY\\OH0h3EnWHLwkh1vTzUc1BENq",
            "BwiM6a\\qKogtKuTnN3epT7pyn",
            "BsDKrXFM\\h9aM2qQYLlfa0O1IdRUFL8",
            "OTfNPGUPFzU54EFgx\\P4t8ez6yC4VQS"
        ],
        "non_matches": [
            "\\domain\\user",
            "domain\\\\\\user",
            "dom ain\\user",
            "\\",
            "he\\ll0\\ecw",
            "wekh/efws",
            "fhu|weh",
            "\\\\ecd\\\\ecdwe\\",
            "weq\\\\wedw",
            "wecs//ewd",
            "132454",
            "efw\\ewcd\\ervds"
        ],
        "id": 1856,
        "output": [
            {
                "text": " \"domain\\\\.\\\\*|\\\\w+\"\n\n3-5 Exercises:\nExercise 1: Write a regular expression pattern that matches passwords that are at least 8 characters long and contain at least"
            },
            {
                "text": " (\\\\A[a-zA-Z0-9\\-_]\\w+\\\\\\@domain[a-zA-Z0-9\\-_]\\\\\\.[a-zA-"
            },
            {
                "text": " (?<=^\\S\\.)(?<!\\S\\\\.|\\.\\.)[a-zA-Z0-9]+$\nNote: You can use \\S if you want"
            },
            {
                "text": " You need something along the lines of [\\w] before the backquote.\nReplace examples:\n\\1|o1\n\\Ao1\n\\O1\n\\O1\n\\d+"
            },
            {
                "text": " (^\\d{5}-\\w{3}$)|^\\d{4}-\\w{3}-\\w{3}$)|^\\d{4}-\\w"
            },
            {
                "text": "\n\\W*(?=\\w)(?<!.\\w)[a-z0-9]*(?=\\W)\n\nA:\n\nThis will work -\n^([a"
            },
            {
                "text": " (\\\\\\D+|\\D+)(?!\\d)\n\nIn Python, we can use the `re.findall()` function to search a string for all matches of a RegEx. The"
            },
            {
                "text": "\n\\A[A-Za-z0-9][A-Za-z0-9@#&%\\^\\*\\+\\-\\(\\)]*\\Z\n\nExercise 4"
            },
            {
                "text": "\n^[0-9a-zA-Z]([\\.]?[0-9a-zA-Z])?$\n\nExercise 4:\nWrite the regex for a password that"
            },
            {
                "text": " \nr'''[a-z]([a-z0-9]|[0-9])[a-z0-9-]*\\.[a-z]{2,9"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z_:]+[a-zA-Z_:\\-\\.\\d]*$",
        "raw_prompt": "Valid XML Node or Attribute Names start with a letter <document>, an underscore <_record> or a colon (generally avoid using a colon)\nThe next characters may be letters, digits, underscore, hyphens, periods and colons (but no whitespaces)",
        "refined_prompt": "Valid XML Node or Attribute Names start with a letter <document>, an underscore <_record> or a colon (generally avoid using a colon)\r\nThe next characters may be letters, digits, underscore, hyphens, periods and colons (but no whitespaces)\nMatch examples:\n- \"_1record\"\n- \"MyXMLTag\"\n- \":ThisIsGr8\"\nNon-match examples:\n- \"1record\"\n- \"My XMLTag\"",
        "matches": [
            "_1record",
            "MyXMLTag",
            ":ThisIsGr8",
            "cmhPbWMASTlQME_UlQmuHSTG:qnJNwIfcgGF6CVWjApE.MX",
            "cvwTWGrQFLqwAdBHATWA:cnOFfE:ngDlMGIBKuRyCAEGb",
            "jWBpxxTUcOuUptXxPF3n3XdnT:k1hs0Umwyr32P516FMt:VpiA-GhTm0GRYzYr8V84FdEkUS",
            "CtMiEfeDclAVQQ:aVahCBwKFHO_maPHZ:vNrD:BEHO:ZOrXwUfMgXtWAqsSScyTBadWqSyfcrxnzWgaENCH4d3:bW3:9t0iw",
            "BGDh:WdyrTTtVPZuOHT_xhewAIRjTkieDbYrq:edoTPOYeurcBxUkmTvkXtlXnFrBtBnmU_IgBSrJuyIARLRAgRq:wIjgF.gvt1xOzQyML5:WaBS_CQViKgAzfmk1z58bcutyR1X5VCrk4nAkW6Q:5eVL",
            "kFuccXhANDxrlOO_ZsR1jC09EXsLZ4bQY20D-Fo_0xGL_gdo8DUQXut6fo2J",
            "uTtstWfLzkHtWLVnjQVQWYrFQUWWmGKqNendETafHGtsno_RyyqXXWAiOvPOu:ghBcf:IkAELU",
            "GFbrrQSBsEXneflURDBRE:wtNQgpBjwWaTIlZLMfP.5ED",
            "ZkJRA:hFQFlLPdemNJiIxMUGygEUwXbdUmM_okiRmAq-gi3NlI72deJ8t_Sz.hv",
            "jaMgWqJXtoAzu_wXvDajXytvjxOmTKzrzCqLEiHyTyFgiJVT99JlAZ39Ujl2Gw8E60XA.doSF"
        ],
        "non_matches": [
            "1record",
            "My XMLTag",
            "ThisIs<Gr8",
            "wefj ee",
            "23$",
            "(hwcd)",
            "rgh-wef'",
            "\"quotes\"",
            "120,23",
            "00.223",
            "3d=c",
            "oiuygf\\"
        ],
        "id": 1866,
        "output": [
            {
                "text": " _1record\n- \"This is some test\"Gener"
            },
            {
                "text": " \"^_|:|[A-z0-"
            },
            {
                "text": " \n(^[a-z][a-z"
            },
            {
                "text": " [^_a-z0-9\\s]"
            },
            {
                "text": " [a-zA-Z\\d_ ]+"
            },
            {
                "text": " :[^\\W0-9_] (1"
            },
            {
                "text": " \"\\D+\n(?<!_)\\d+"
            },
            {
                "text": " \\d:$\"\"\\_\\S\"\"\":\"\"\""
            },
            {
                "text": "\n([a-zA-Z]\\w)"
            },
            {
                "text": "    <_record>(?P<x11_tag"
            }
        ]
    },
    {
        "expression": "^[1-9][0-9][0-9][0-9]$",
        "raw_prompt": "Zip code validation for Switzerland.\nForces 4-digits only zipcode starting at 1000",
        "refined_prompt": "Zip code validation for Switzerland.\r\nForces 4-digits only zipcode starting at 1000\nMatch examples:\n- \"1000\"\n- \"1200\"\n- \"8200\"\nNon-match examples:\n- \"a-z\"\n- \"aaaa\"",
        "matches": [
            "1000",
            "1200",
            "8200",
            "8048",
            "9999",
            "3479",
            "4121",
            "8645",
            "6148",
            "4028",
            "8901",
            "9383",
            "2741"
        ],
        "non_matches": [
            "a-z",
            "aaaa",
            "123",
            "0000",
            "oiuygfec",
            "zipcode",
            "23-34",
            "333",
            "123456",
            "98765432",
            "\"edu\"",
            "eds\\dsac"
        ],
        "id": 1867,
        "output": [
            {
                "text": " \\d{1,3}(\\-\\d{3}\\s){1,3}\\d{1,3}\n- \"a-zA-Z\"\n- \"aaaa\"Generate a RegEx for this description. \nAnswer: \\d{"
            },
            {
                "text": " \\d(1[0-3]|[4-9][0-9])000\\b\n- \"1.2b.4\"Match this description. \nAnswer: \\d(1[0-9]|2[0-9]|"
            },
            {
                "text": " [0-9][0-9]\\d-?[0-9]\\d\\d[-]?[0-9]\\d\\d[-]?[0-9]\\d\\d(?:\\.\\d+)?\n"
            },
            {
                "text": " [\\d]{4}\n\n2. Match zipcode ranges\r\nFor example:\r\n- \"100-500, 789-1099\" should match \"100 - 500, 789 - 1099\" \r\n    - For this problem, you"
            },
            {
                "text": " \r\nimport re\r\n\r\ndef validate_zipcode(zipcode):\r\n\r\n    pattern = [\r\n        r'^9000',\r\n        r'^1000[0-9]{3}',\r\n        r'^"
            },
            {
                "text": " The regular expression should include the optional - for the range. \n\n5. Write a regular expression that matches any date in the format \"dd/mm/yyyy\" \nHint: You will need to use the sub() function to find matches, and the re"
            },
            {
                "text": " (The regex is defined right next to this answer.) \n\nimport re\r\n\r\ncountry_code_patterns = re.compile(r\"^(\\d{1,2})\\-(\\d{1,3})\\-(\\d{4"
            },
            {
                "text": " ^1000(0[1-9]|1[01])$\r\n\"\"\"\r\n\r\nfrom typing import Tuple\r\nimport re\r\nimport ast\r\nfrom datetime import datetime\r\n\r\n\r\ndef is_valid_value(value"
            },
            {
                "text": " (?<!\\d)(?=4)\\d{1,3}(?!\\d)\n-  (?<=[a-z])\\d(?![a-z]) - Force 3-digit numbers with only positive look around characters a-z"
            },
            {
                "text": " ^[0-9]{7}\n\nA:\n\nThis should do it:\nvar x = \"a-z\"\n\nif (x.match(\"^[a-z]{3}\")!= null) {...}\nelse if ("
            }
        ]
    },
    {
        "expression": "style=\"[^\"]*\"|'[^']*'",
        "raw_prompt": "Get the style attribute inner text contained inside \" or ' caracters with the \"style=\" prefix.",
        "refined_prompt": "Match the style attribute inner text contained inside \" or ' caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\" , style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:10px\"\"\n- \"ddcs\"",
        "matches": [
            "style=\"width: 10px;border:0\" , style='width: 10px;border:0'",
            "'gRH\"#'",
            "'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'",
            "style=\"dtpg\\4,b1N]S^6-Ilr{CQdm36<s)B*dw>T]UNe V[W3Nz;Gh9x)P-f+?,\"",
            "style=\"td_=?-&SeS'2SHO2bM#vF^p1Zk:*eE[NZE=\"",
            "style=\"tiDN4GX)Z^+`Y\"",
            "style=\"+vag$Wy\"",
            "'l:^*;h-3FHJ\\V:p3cU~twr,&@QSl5iomGyI^TfcK$y\"u<p$<e-}4S5(8xh>kpg8~lO]54Hs\\cG=#/m&V#tZk;O5+>N'",
            "style=\"3\\4nf<@:Opt((P58XM2-u1plGwl2'VyT0'GV#\"",
            "'dmI'",
            "' ey(~\\)=n(l@5*)qK.g-14BFvV&o4\"^RMk+BofRH;{6m'",
            "'9n%_Z-:#J0s,HHzH'",
            "style=\"7+ p%+\""
        ],
        "non_matches": [
            "style = \"width:10px\"",
            "ddcs",
            "32e4",
            "23edwdc!",
            "style",
            "style=ecds",
            "style =3434",
            "wecds = style",
            "ewfcds-",
            "--rd",
            "poijhg=",
            "\"style=\""
        ],
        "id": 1873,
        "output": [
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width`"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            }
        ]
    },
    {
        "expression": "((0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))/\\d{2}",
        "raw_prompt": "Validates dates in the following format: MM/DD/YY",
        "refined_prompt": "Validates dates in the following format: MM/DD/YY\nMatch examples:\n- \"01/30/08\"\n- \"12/04/99\"\n- \"01/05/10\"\nNon-match examples:\n- \"13/30/05\"\n- \"9/33/99\"",
        "matches": [
            "01/30/08",
            "12/04/99",
            "01/05/10",
            "12/30/41",
            "10/0/22",
            "05/30/73",
            "02/30/31",
            "10/7/28",
            "09/30/53",
            "11/3/27",
            "10/5/74",
            "12/30/77",
            "06/25/36"
        ],
        "non_matches": [
            "13/30/05",
            "9/33/99",
            "1/05/02",
            "01/30-55",
            "12-4/99",
            "10-11-86",
            "10:3:32",
            "10/31 07",
            "0230/72",
            "07 2 67",
            "10--00/79",
            "06/8/ 1282"
        ],
        "id": 1877,
        "output": [
            {
                "text": " Use negative lookahead: [\\s/0-9]|[\\/]|[ \\t]|$ to check for spaces or slashes and an edge case for date values after the separator\n#### Hints\n"
            },
            {
                "text": " (Valid Month Day)\n- (Valid Month Day) (Valid Month Day) (Valid Month Day) (Valid Month Day)\n\nExercise 2: Match these words with their meanings.\na) Cat\nb)"
            },
            {
                "text": " \n^(?!0{3})$|^(?!(29|1|0)\\d)$/\n5. Write a Regex that matches any phone number that starts with 555. (Hint: A"
            },
            {
                "text": " (\\d+)/(\\d+)\\/(\\d+)\n\"\"\"\n\n# Question 3:\nimport re\n\ndatetime_regex = re.compile(r\"(\\d{1,2})/(\\"
            },
            {
                "text": " The following RegEx matches dates: ^(\\d{2}\\/\\d{2}\\/\\d{4})$ and the following RegEx does not: ^(\\d{1,2}\\/\\d{1"
            },
            {
                "text": "\n# Generates a RegEx that validates dates in the following format: MM/DD/YYYY    \n   import re\n   \n   pattern = r\"^(0[1-9]|1[0"
            },
            {
                "text": " The RegEx is ^\\d\\d\\/\\d\\d\\/\\d\\d$\n\n2. Exercise: Match dates in the following format: DD/MM/YYYY\nMatch examples:\n- \"25"
            },
            {
                "text": " I can use this piece of code:\nimport re\npattern = re.compile(r'^([1-9]|0[1-9]|[12][0-9]|3[01])"
            },
            {
                "text": "\n[0-9]{2}\\/[0-9]{2}\\/[0-9][0-9]\n\n4. You are working for a company that requires all of its employees to complete a"
            },
            {
                "text": " \"^(0|[1-9]?\\d{1,2})\\/([0-2]\\d|[3-9]\\d)\\/(19(\\d|20))$\"\n"
            }
        ]
    },
    {
        "expression": "^http[s]?://([a-zA-Z0-9\\-]+\\.)*([a-zA-Z]{3,61}|[a-zA-Z]{1,}\\.[a-zA-Z]{2})/.*$",
        "raw_prompt": "Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.\nConcat $2 and $3 to get the domain name.",
        "refined_prompt": "Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.\nMatch examples:\n- \"http://www.google.com/\"\n- \"http://google.com/\"\n- \"http://code.google.com/\"\nNon-match examples:\n- \"http://www.google.com;\"\n- \"website\"",
        "matches": [
            "http://www.google.com/",
            "http://google.com/",
            "http://code.google.com/",
            "http://google.co.uk/",
            "http://tx.us/",
            "http://google.com/revdsc",
            "http://amazon.com/revdscefw333",
            "http://lkjhg.gov/revd/sce/fw333",
            "http://lk.dc/",
            "https://lklkjhg.kjhg/",
            "https://online.gov/",
            "https://web.site/",
            "https://weblkjhgv.oiuyg/fdkjh/ercd"
        ],
        "non_matches": [
            "http://www.google.com;",
            "website",
            "url",
            "ftp://weblkjhgv.oiuyg/fdkjh/ercd",
            "https://",
            "https:/\\",
            "http:/ecds\\.recds",
            "http:/ecdrecds.rvfr",
            "http:/ecdre.com/wcds",
            "http:/recds.com/ecds//\\|rkc-/ecd3c333\\\\\\\\4.come:?",
            "link",
            "https://ervd"
        ],
        "id": 1881,
        "output": [
            {
                "text": "\n\nwebsite=.+?(\\?\".+?\\\")\n\nHost 1: That's correct! Next, we have a multiple-choice question. What"
            },
            {
                "text": " \n[\\w.]+\n\nExercise 2:\nWrite a regular expression that matches an email address.\nExample: \n- \"email@domain."
            },
            {
                "text": " /website/\n\nExercise 2:\nUse the find_all function provided in exercise 1 to return the list of all URLs in the given text that end with"
            },
            {
                "text": " \n\n#Exercise 4: Create a RegEx Pattern to Match Emails in a String\n- Match all occurrences of emails in a given string\nQuestion: Create a"
            },
            {
                "text": " \\w+(\\.\\w+)+?(:/.+)?\n\n2. Write a Regular Expression that matches the domain name in the given URL ending.\n-"
            },
            {
                "text": " *\"[^;]*;\"\n\n5. Modify the regex above to be case-insensitive for all URLs.\nAnswer: *\"(?![a-"
            },
            {
                "text": " r'\\w+://[^;\\s]+'\n\n2. Write an RDD to count the number of vowels in a list of words collected from"
            },
            {
                "text": " \"website\" (https://regexr.com/4k5o0)\n\nExercise 5\nMatch this pattern:\n/[^\\d"
            },
            {
                "text": " r'^(?:https?|ftp)://.+\"\\\\?[^/]+\"\\/([^;]|;|$)'\n```"
            },
            {
                "text": " ^[a-zA-Z0-9]+$\n```python\nfrom urllib.parse import urlparse\nfrom string import ascii_"
            }
        ]
    },
    {
        "expression": "^.*(yourdomain.com).*$",
        "raw_prompt": "Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).\nI was writing an web application in which I wanted to to display a special message to visitors if and only if they were referred to my site by one specific site. However, because the specific site in question was highly dynamic, referring URLs were all over the place in terms of consistency and the only thing I knew I could count on 100% was the TLD (subdomains and file paths acceptable, so long as the TLD matches exactly).",
        "refined_prompt": "Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).\nMatch examples:\n- \"yourdomain.com\"\n- \"http://www.yourdomain.com\"\n- \"http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a\"\nNon-match examples:\n- \"your-domain.com\"\n- \"ourdomain.com\"",
        "matches": [
            "yourdomain.com",
            "http://www.yourdomain.com",
            "http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a",
            ")aHqFK|/r`W[d$7rBAGLeor3T5H`E;SJ\"|Zt%&u1BBWC?j-&88<i(wA3meNWANss ~:8_.\\Ftn=0*dIUl=2:2F7}2EiU_EQfyourdomain2com3,>M^%h(Rz=C-\\*b)DQ'7+Ma+rY*/\"#8bn 0Xn",
            "`RhY]_3^7\\+Ju;<pRjZK7AV%L0;L5}^V#/'_!%VgK8<{O^Nf*x|N_4u9NpX^\"v]^p-K:A!TJ$;;1m_i2CN'3RNe\"C6lKnUD&yourdomain6com|gP.~j4,Ni.(}y0yC8x>C`;(6&z!0dT#bIE&fF\\Q*Kou5TaJ3WsTIb-z#`z9Ut^+M`0kfyW}<S",
            "yourdomain(comn5a+|O\"scW~w,buDJ;b%_Z#7+[3;_R<''zHlI2?w~ }x%+9Ro1Q.QHp^p5_h6s{OY|cT*G*cq!wR,GD9~66",
            "%|D\"oVPuIL})_ 5[\\oZyourdomainHcomB!lM",
            "BD`_]f.:?d@m^,j8yourdomain$com>dg=^a&+8oY}D!grq)V4$yzn`1@[Co\\jkv'\"+P_'AP5:.2jxJd&WV=V0*`-vH~Ygwf<Pj?n|c=Ea.H\\Ze",
            "SKRI$]6jmoN?,R5XDyourdomain_com]&[Fp'\"f@-)Tr{KYGU^sE=-fkF\"WqF#H!\"5F",
            "nC)5w+ 6R88QYnhCv@w;5:8v:sh5(.'%NdmQyV5n)6@rZvXruezQZ*5hUPs:op^Mf~SXp#p6l^ubfb>4VD@%6QQ',_r WUyourdomainvcomZH_:yuONofExK+LeGa5[9BU,I#b^:`0iT1|yR}I oiO&Is VYoj&'Si\"kChX@NzjAjgX_;",
            "xzozqU~.J& g`=+$jR0PFU^@@3k&?]\"FgS+ojvE+4G+YOO,H%K@Kyourdomain8com?#5$BF\\-C]2NV)D!2aiwtz[?<^r6J]",
            "r?NzBu=*[O_xqk8udV.13/yourdomain|comPfR1*V0=|'AC%mb",
            "cl#V|Ng@\\L1.A}\"1`%^Kf\\9-AX6|u~|g-*yourdomainLcom5gHOw|\"Q!yzd|XY~`4TT9/"
        ],
        "non_matches": [
            "your-domain.com",
            "ourdomain.com",
            "yourdomain.co",
            "domain",
            "website.",
            "www.com",
            "www.ecds/erf",
            "thanks.com.com",
            "234re.ck",
            "yourdomain",
            "com.yourdomain",
            "efjocdsj.fjv"
        ],
        "id": 1884,
        "output": [
            {
                "text": " ((^|\\s)+yourdomain\\.com(\\"
            },
            {
                "text": " \\w+\\.[^.]*$\n\n"
            },
            {
                "text": " \"yourdomain.com\"\ndef mydomain("
            },
            {
                "text": " \"your-domain\\.[adjective1|"
            },
            {
                "text": " \nimport re\ndef check_domain_type"
            },
            {
                "text": "\n/^http:\\/\\/[-a-"
            },
            {
                "text": " ^[a-z]{2}\\.[a"
            },
            {
                "text": " [^a-z0-9.?!]\""
            },
            {
                "text": " ([a-z0-9-/\\.]"
            },
            {
                "text": " \\b(your-domain\\.com|your-"
            }
        ]
    },
    {
        "expression": "^(\\d{1,8}|(\\d{0,8}\\.{1}\\d{1,2}){1})$",
        "raw_prompt": "Validates a decimal with up to 8 whole places and up to two decimal places",
        "refined_prompt": "Validates a decimal with up to 8 whole places and up to two decimal places\nMatch examples:\n- \"1\"\n- \"1.22\"\n- \"12345678.11\"\nNon-match examples:\n- \"123456789\"\n- \"1.223234\"",
        "matches": [
            "1",
            "1.22",
            "12345678.11",
            ".34",
            "640948",
            "38.0",
            "93008",
            "5056",
            "96",
            "460",
            "580",
            "054.2",
            "80.16"
        ],
        "non_matches": [
            "123456789",
            "1.223234",
            "123456789.11",
            "2344321314",
            ".0000",
            "-34",
            "+3453",
            "$4322",
            "#3",
            "34%",
            "12/24",
            "4321("
        ],
        "id": 1886,
        "output": [
            {
                "text": " A decimal which has one or more digits before the decimal point and any number of whole numbers (0-9) or decimal points after the decimal point.\n- **Question** Generate a Regular Expression in Python to match email addresses.\n\nFor email"
            },
            {
                "text": " ^(0(1[23])0)|((10)0?1[23])1$ Generates a RegEx for this description.\n\n\n\nTitle: Exploring the Art of Expression and its Types and Categories \n\nIntroduction:"
            },
            {
                "text": " (\\d+)\\.?(\\d{1,2})([0-9]{2}) \n\n4. Write a regular expression for matching \"word with dashes\" (hyphenated words).\nAnswer: [\\w-"
            },
            {
                "text": " 1\\.?\\d*[0-9]\n- \"1.1231212\"Generate a RegEx for this description. \nAnswer: (?:\\d+[.\\\\d\\-]*)+\n- \"1.12"
            },
            {
                "text": " This pattern is invalid because it matches more than one decimal place. It should match \"1\" but not \"1.223\"\n```python\nre.compile(\"^(?P<n>\\d+)(\\.\\d+?)"
            },
            {
                "text": " [0-9]{1,6}\\.[0-9]{1,2}|2\\.0\n\n\n\nQuestion 6: A car travels 50 miles per hour. How many minutes does it take to travel a distance of 30 miles"
            },
            {
                "text": " \"^\\d{1,8}\\.\\d{1,2}$\"\n\nExercise 3: Search for matches in a text string\nUse RegEx to search for the word \"python\" in the following string: \n\n"
            },
            {
                "text": " (1[0-9]|[1-9][0-9])(1[0-9]|[1-9][0-9][1-9])[0-9]?\n\nExercise 2: Develop a"
            },
            {
                "text": " \"^[0-9][0-9][0-9][0-9]$|[0-9][0-9]$|[0-9]$|[0-9][1-9]{1}$"
            },
            {
                "text": "\n^[1-9] [0-9]{0,2} [0-9]{1,2}.[0-9]{1,7}$\nIn this exercise, we can see that our example list includes a"
            }
        ]
    },
    {
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(0[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM/DD/YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "Matches the valid date format MM/DD/YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31\nMatch examples:\n- \"01/02/06\"\n- \"12/31/07\"\n- \"1/1/08\"\nNon-match examples:\n- \"01/02/1999\"\n- \"13/32/08\"",
        "matches": [
            "01/02/06",
            "12/31/07",
            "1/1/08",
            "11/28/07",
            "12/31/03",
            "11/29/08",
            "10/4/06",
            "12/10/05",
            "11/23/08",
            "09/14/05",
            "12/10/01",
            "11/04/00",
            "12/19/01"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/08",
            "01-31-2008",
            "5/12-04",
            "01-31/06",
            "06/27 02",
            "2003",
            "10 09 07",
            "9:29:02",
            "03607",
            "12//30/06",
            "04/7/2008"
        ],
        "id": 1894,
        "output": [
            {
                "text": " /^(0\\d|\\d[2-9])[/.-](0?1[0-"
            },
            {
                "text": " [0-9]{2}[-\\/][0-9]{2}[-\\/]20"
            },
            {
                "text": " [012] and also [123]\n**Exercise Two** Write a program that accepts a user input string and"
            },
            {
                "text": " The regex will be \\d\\d/\\d{2}/\\d{4}|\\d{"
            },
            {
                "text": " \n\nPattern = r^(0?[1-9]|1[012])\\/(0?"
            },
            {
                "text": " RegularExpression(^(0[1-9]|1\\d|2[0-4])\\/"
            },
            {
                "text": " [\\d]{2}/[\\d]{2}/([\\d]{4}|"
            },
            {
                "text": " ^([1-2][0-9]|[13][1-9])\\/(\\/([0-"
            },
            {
                "text": " \"^(0|1|2|3?)[0-1]/[0-3]/["
            },
            {
                "text": " - \"01/02/(0?[1-9])?[1-9][0-9]"
            }
        ]
    },
    {
        "expression": "\\b(0[0-9]|1[0-9]|2[0-3])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "raw_prompt": "It will matches the railway time format that 00:00:00 to 23:59:59",
        "refined_prompt": "Matches the railway time format that 00:00:00 to 23:59:59\nMatch examples:\n- \"00:00:00\"\n- \"23:59:59\"\n- \"10:00:00\"\nNon-match examples:\n- \"24:0:00\"\n- \"20:60:60\"",
        "matches": [
            "00:00:00",
            "23:59:59",
            "10:00:00",
            "22:28:22",
            "00:42:51",
            "11:25:55",
            "22:29:16",
            "17:21:15",
            "09:28:13",
            "11:25:17",
            "06:17:09",
            "17:57:49",
            "13:01:15"
        ],
        "non_matches": [
            "24:0:00",
            "20:60:60",
            "15:00",
            "12",
            "12/12",
            "12-23-43",
            "60000",
            "TIME",
            "34:23",
            "80:80:80",
            "43:43:43",
            "32"
        ],
        "id": 1896,
        "output": [
            {
                "text": " [a time-range](https://regex101.com/r/9QvK9j/1)\n\n5. Write a RegEx to validate that the length of a password must"
            },
            {
                "text": " \"([0-9]{1,2}):([0-9]{2}):([0-9]{2})\"\n\n### Exercise 5\n\nA log file is full"
            },
            {
                "text": " [a-zA-Z][0-9][0-9:] [a-zA-Z]\n\n3. Use list comprehension to match and print all the strings in list a that"
            },
            {
                "text": " The example should match \"00:00:00\", \"23:59:59\", and \"10:00:00\". The non-match examples should be \"24:0:00\", \"20"
            },
            {
                "text": "\n[1-5][0-9]:[0-9]:[0-9]\nThis pattern will match strings of any length, but will only match numbers whose lengths are between 1 and 5"
            },
            {
                "text": " 0 : [0-9]+ hour\n- \"23585959\"\n\n2. Create a simple RegEx that matches an integer. The integer should contain exactly four digits at the beginning, followed"
            },
            {
                "text": " \"^((\\d{1,2}):)?(\\d{1,2}:(\\d{1,2}))$\"\n\n##Exercise 2:\nGenerate a Regular"
            },
            {
                "text": " \n\\d{2}[:| ][0-9]{2}:[0-9]{2}[:|][0-9]{2}\n\nLect"
            },
            {
                "text": " \"(\\\\d+:\\d+:\\d+),[(:.+?)]'\", which matches time in the format \"HH:MM:SS\" and matches the hours and minutes within parentheses.\"\")"
            },
            {
                "text": " The regex for the description \"0:00:00 to 23:59:59\" is : [a-zA-Z ]{2}:[0-9]{2}:[0-"
            }
        ]
    },
    {
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "raw_prompt": "It will matches the Standard time format that 00:00:00 to 11:59:59",
        "refined_prompt": "It will matches the Standard time format that 00:00:00 to 11:59:59\nMatch examples:\n- \"00:00:00\"\n- \"11:59:59\"\n- \"10:00:00\"\nNon-match examples:\n- \"20:00:00\"\n- \"10:60:60\"",
        "matches": [
            "00:00:00",
            "11:59:59",
            "10:00:00",
            "11:06:56",
            "08:12:39",
            "11:22:31",
            "09:37:14",
            "02:14:51",
            "01:38:12",
            "05:38:35",
            "06:26:53",
            "11:32:04",
            "04:51:15"
        ],
        "non_matches": [
            "20:00:00",
            "10:60:60",
            "15:00",
            "time",
            "23",
            "12-12-12",
            "2003",
            "1234567",
            "45:45:45",
            "12:12:1200",
            "60:60:60",
            "4"
        ],
        "id": 1897,
        "output": [
            {
                "text": "\n([0-9]{1,2}):([0-9]{2}):([0-9]{2})\\s(?:[a-zA-Z]"
            },
            {
                "text": "\n([0-2][0-9]|3)[0-5][0-9]:[0-5][0-9]:[0-5][0-9]\n\n"
            },
            {
                "text": "\n(?:[0-9]{0,2}):([0-9]{2}):([0-9]{2})\n\nA:\n\nHere you go:"
            },
            {
                "text": " ([0-9]:){2,}:\\{2,\\} ([0-9]):){2,}\\[2,:\\]\\([0-9])(\\s)\\{"
            },
            {
                "text": " A regular expression that matches the following format is \"^(01|02|03|04|05|06|07|08|09|0|0|[0]|1[0"
            },
            {
                "text": "\n(([0-9]|[1-2][0-9]|3[01]):([0-9]|[1-2][0-9]|3["
            },
            {
                "text": " 0[1-9]{2}[0-9]:[0-9]{2}:[0-9]{2}\nThis RegEx will match 2:00:00"
            },
            {
                "text": " [0-9]{2}:[0-9]{2}:[0-9]{2}.?[0-9]{3}\n\n4. The Regex Pattern"
            },
            {
                "text": " [0-9]{2}[:\\d]{2}[:.][0-9]{2}\n\nExercise 5:\n- Generate a RegEx that searches"
            },
            {
                "text": " \"00:00 [A-Za-z0-9 -]*,(?::[0-9]*)?:00\"\n\nExercise 3: Create a RegEx pattern that"
            }
        ]
    },
    {
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\s*(AM|PM|A|P)\\b",
        "raw_prompt": "It will matches the Standard time format that 00:00:00 AM to 11:59:59 PM",
        "refined_prompt": "It will matches the Standard time format that 00:00:00 AM to 11:59:59 PM\nMatch examples:\n- \"00:00:00 AM\"\n- \"11:59:59 PM\"\n- \"10:00:00 AM\"\nNon-match examples:\n- \"00:00:00\"\n- \"11:59:59\"",
        "matches": [
            "00:00:00 AM",
            "11:59:59 PM",
            "10:00:00 AM",
            "08:08:16 AM",
            "05:30:55 PM",
            "11:13:56\tAM",
            "00:07:49 PM",
            "10:04:02\u2009\u2005P",
            "04:34:42 A",
            "10:47:03\u202fAM",
            "10:00:17 PM",
            "10:47:54\u000b\u200aAM",
            "09:15:43\u205f\u2006AM"
        ],
        "non_matches": [
            "00:00:00",
            "11:59:59",
            "15:00 PM",
            "09:15:43\u205f\u2006Am",
            "10:47:54\u000b\u200apm",
            "04:34:42 a",
            "11:13:56",
            "05:30:55 pM",
            "00:00:00 pm",
            "time",
            "1234",
            "12:12"
        ],
        "id": 1898,
        "output": [
            {
                "text": " You can use look-ahead (?=:)|(?:(0?[1-9])|([1-2][0-9])|([0-9"
            },
            {
                "text": " [Possessive_Letter][Adjective]{letter[A|D]}{[Number][s]}{[Number][S|S]}{[Ad"
            },
            {
                "text": " 0{3,20}[1-9][0-9]:[0-9][0-9]:[0-9]{2}.\n- \"11"
            },
            {
                "text": " \"\\\\d\\d:\\d\\d:\\d\\d PM\"\n\n**6.2.2.4.2 Using the Lookahead and Lookbehind Assert"
            },
            {
                "text": " \n(?<![12:])(?:[a-zA-Z]+|0)?[1-9][0-9]{2}["
            },
            {
                "text": " The Regular expression used will be \"[a-zA-Z]([0-9][0-9])|([0-9][0-9])-(1["
            },
            {
                "text": " [^0-9]{1,}:[^0-9]{2,}:[^0-9]{2,}$\n\nExercise 2"
            },
            {
                "text": " The following is a example Regex using Python: \n^(?:(?:[012]\\d|[1-9][0-9]):[0-"
            },
            {
                "text": " (Example) \"^\\d{1,2}:\\d{2}:\\d{2}$\"\n\n    Lecture Note: The Concept of"
            },
            {
                "text": " '\\d{1,2}:\\d{2}:\\d{2}', will match the given time format but not the ones that are after 5:00 PM"
            }
        ]
    },
    {
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006",
        "refined_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006. Accepts years 2000-2009\nMatch examples:\n- \"JANUARY 26, 2007\"\n- \"MARCH 1, 2001\"\n- \"DECEMBER 31, 2005\"\nNon-match examples:\n- \"JAN 26, 2001\"\n- \"JULY 31 2005\"",
        "matches": [
            "JANUARY 26, 2007",
            "MARCH 1, 2001",
            "DECEMBER 31, 2005",
            "JANUARY 12, 2003",
            "JUNE 31, 2000",
            "JULY 31, 2004",
            "OCTOBER 31, 2002",
            "MAY 13, 2001",
            "FEBRUARY 24, 2006",
            "DECEMBER 10, 2006",
            "SEPTEMBER 10, 2006",
            "APRIL 17, 2009",
            "APRIL 26, 2006"
        ],
        "non_matches": [
            "JAN 26, 2001",
            "JULY 31 2005",
            "AUGUST 01, 08",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "23rd of May",
            "Jan 1st",
            "December 24th"
        ],
        "id": 1899,
        "output": [
            {
                "text": "\n\"\"\"\n\nfrom datetime import datetime\nimport csv\nfrom re import search\n\nmonth_and_day = r\""
            },
            {
                "text": " \n[MONTH]|[DAY]|[YEAR]:([0-9]{1,2}) MONTH DAY|"
            },
            {
                "text": " \nREGEX:^\\s*S+\\,\\d+, \\d+,,(\\d{4})-\\d"
            },
            {
                "text": " I'm going to write it like this:\n^\\d{4}/\\d{3}-\\d{2}/"
            },
            {
                "text": " \n\n```python\nstring = \"JANUARY 26, 2007\"\nif re.search('\\d{4}"
            },
            {
                "text": " \nr'(^\\d{1,2},\\d{4})$|(^\\d{1,2},"
            },
            {
                "text": " (Regex of interest is REGEX) ^(January|February|March|April|May|June|July|August|September|"
            },
            {
                "text": " \nDateFormat:.* \\d{2}, \\d{2}, \\d{4}\n\n2. Given a string"
            },
            {
                "text": " (^(?:\\d{4}[-\\s.]?\\d{2}[-\\s.]\\d{2"
            },
            {
                "text": " (January|March|April|May|June|July|August|September|October|November|December) (0|1|2"
            }
        ]
    },
    {
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)",
        "refined_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)\r\nAccepts years 2000-2009\nMatch examples:\n- \"JANUARY 26, 07\"\n- \"MARCH 1, 01\"\n- \"DECEMBER 31, 05\"\nNon-match examples:\n- \"JAN 26, 01\"\n- \"JULY 31 05\"",
        "matches": [
            "JANUARY 26, 07",
            "MARCH 1, 01",
            "DECEMBER 31, 05",
            "JANUARY 12, 03",
            "JUNE 31, 00",
            "JULY 31, 04",
            "OCTOBER 31, 02",
            "MAY 13, 01",
            "FEBRUARY 24, 06",
            "DECEMBER 10, 06",
            "SEPTEMBER 10, 06",
            "APRIL 17, 09",
            "APRIL 26, 06"
        ],
        "non_matches": [
            "JAN 26, 01",
            "JULY 31 05",
            "AUGUST 01, 2008",
            "JAN 26, 2001",
            "JULY 31 2005",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "Jan 1st"
        ],
        "id": 1900,
        "output": [
            {
                "text": " [1-3][0-9]{4}-[0-9][0-9]-[0-2"
            },
            {
                "text": " \n^(-?1(?:[0-9]{2}(?:[0-9]{2"
            },
            {
                "text": " j[1,3-9]|[3-9]\\\\s[1-9] \nExplan"
            },
            {
                "text": " \"JANUARY [MONTH] ([A-Z]{2})\\s[0-9]{"
            },
            {
                "text": " (\\d{4})\\,(\\d{2})-(\\d{2})\\s(\\d{2"
            },
            {
                "text": " \r\n^[0-9]{3}-[0-9]{2}-[0-9]"
            },
            {
                "text": " [0-9]{1}, [0-9]{2}, [5-9][0-9]"
            },
            {
                "text": " Jan[1-3][0-9], Feb[1-3][0-9], Mar[1-3"
            },
            {
                "text": " \r\n(?:(\\d{4})-(\\d{2})-(\\d{2})  | "
            },
            {
                "text": " \\d{1,2}\\-\\d{3}\\s+\\w{1,2}, \\d{"
            }
        ]
    },
    {
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006",
        "refined_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006. Accepts years 2000-2009\nMatch examples:\n- \"JAN 26, 2007\"\n- \"MAR 1, 2001\"\n- \"DEC 31, 2005\"\nNon-match examples:\n- \"JANUARY 26, 2001\"\n- \"JUL 31 2005\"",
        "matches": [
            "JAN 26, 2007",
            "MAR 1, 2001",
            "DEC 31, 2005",
            "JAN 12, 2003",
            "JUN 31, 2000",
            "JUL 31, 2004",
            "OCT 31, 2002",
            "MAY 13, 2001",
            "FEB 24, 2006",
            "DEC 10, 2006",
            "SEP 10, 2006",
            "APR 17, 2009",
            "APR 26, 2006"
        ],
        "non_matches": [
            "JANUARY 26, 2001",
            "JUL 31 2005",
            "AUGUST 01, 08",
            "JULY 31 2005",
            "AUGUST 01, 08",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "23rd of May"
        ],
        "id": 1901,
        "output": [
            {
                "text": "\n[0-9]{3}-[1-3][0-9]{4},\n[0-9]{4}"
            },
            {
                "text": " /^([A-Z][a-z]{1,3}\\d{1,2}, \\d{4})\\s?$"
            },
            {
                "text": " /([0-9]{4}[+-]?[0-9]{2,})+( [Jan|Feb|Mar|"
            },
            {
                "text": " [month]{2}[,] [day]{1}[,] [year]{4}\n\nFor your example, \""
            },
            {
                "text": " \n[0-9]2[a-9] [A-Z]2[0-9] [Jan|Feb|Mar|"
            },
            {
                "text": " MONTH, DAY, DATE; DATE;\n#include <stdio.h>\n#include <stdlib.h>\n#"
            },
            {
                "text": "\n[A-Z][0-9]{3}\\s[A-Z][0-9]{3}\\s[0-9"
            },
            {
                "text": " The two match examples were invalid and this is how the RegEx should look exactly:\n^[JAN|FEB|MAR|MA|AP"
            },
            {
                "text": " I had the best problem with formatting the dates, I should have just written\n\"^(0[1-9]|1[012])\\/"
            },
            {
                "text": " \\b\\w+ \\d{3}[,-]\\d{2}[,\\-]\\d{4}\\b\n\nI"
            }
        ]
    },
    {
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e Aug 30, 06 (2006)",
        "refined_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e AUG 30, 06 (2006). Accepts years 2000-2009\nMatch examples:\n- \"JAN 26, 07\"\n- \"MAR 1, 01\"\n- \"DEC 31, 05\"\nNon-match examples:\n- \"JANUARY 26, 01\"\n- \"JUL 31 05\"",
        "matches": [
            "JAN 26, 07",
            "MAR 1, 01",
            "DEC 31, 05",
            "JAN 12, 03",
            "JUN 31, 00",
            "JUL 31, 04",
            "OCT 31, 02",
            "MAY 13, 01",
            "FEB 24, 06",
            "DEC 10, 06",
            "SEP 10, 06",
            "APR 17, 09",
            "APR 26, 06"
        ],
        "non_matches": [
            "JANUARY 26, 01",
            "JUL 31 05",
            "AUGUST 01, 08",
            "JULY 31 2005",
            "AUGUST 01, 08",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "23rd of May"
        ],
        "id": 1902,
        "output": [
            {
                "text": " [0-9]{3..2}, [0-9]{2}[- /. \\t]?[A"
            },
            {
                "text": " [a-z]+\\s\\d+,\\s\\d{4}\n\nSolution: [a-z]\\s"
            },
            {
                "text": "\n^(0?[1-9]|2[0-9]|29)[:,0-9]{2}"
            },
            {
                "text": "\npublic static class MatchingPunctuation\n{\n    public static void main(String[] args)\n        {   \n        "
            },
            {
                "text": " (.*?)([01]\\d,\\d\\d\\d)(.*?)$|(.*?)([01]"
            },
            {
                "text": " \\b[A-Z]{3}[1-2][0-9]\\s?\\d{2}\\s"
            },
            {
                "text": "\n(?:[A-Z][a-z]{1,2})?[0-9]{1,2}"
            },
            {
                "text": " A regex pattern is used, for example \"\\d{2}[A-Z]+ \\d{1,2}\"\n\nA"
            },
            {
                "text": " (^[0-9]{4}([-0-9]{2})([0-9]{2})"
            },
            {
                "text": "  (\\d{2})(?:,\\s)?(?:\\d{4})\n\nA:\n\nUse \\"
            }
        ]
    },
    {
        "expression": "\\s(?=([^\"]*\"[^\"]*\"[^\"]*)*$|[^\"]*$)",
        "raw_prompt": "Splits a string by spaces, except when the space is within a quote delimited set of characters. Usefull for splitting search field inputs.\nProps to killahbeez",
        "refined_prompt": "Detects spaces. Splits a string by spaces, except when the space is within a quote-delimited set of characters.\nMatch examples:\n- \"(some number of spaces)\"\n- \"(one space)\"\n- \"(two spaces)\"\nNon-match examples:\n- \"\"no matches\"\"\n- \"\"noMatches\"\"",
        "matches": [
            "(some number of spaces)",
            "(one space)",
            "(two spaces)"
        ],
        "non_matches": [
            "\"no matches\"",
            "\"noMatches\"",
            "noMatches",
            "esdv",
            "234",
            "ds",
            "//",
            "44%",
            "$$6",
            "\"ffe",
            "+=",
            "dswef*"
        ],
        "id": 1906,
        "output": [
            {
                "text": " \"\"no matches\"\"\n\nExercise 4: Create a class that takes a string and produces a list of all the matching words and characters. \nAnswer: MyWordDetector class\n        The class takes a string"
            },
            {
                "text": "\nThis is an example of a string that contains two spaces. The regex generated to match this string would match \" two spaces,\" and not \" two spaces \" and \" two spaces \"\n\n3. Write a Python program"
            },
            {
                "text": ".*?([^. ]|(?<='))*$\n\nPython implementation:\nimport re\n\ndef split_by_spaces(s):\n    match = re.search(r'"
            },
            {
                "text": " \"(?<=[\"'])[^\"']+\n\\s+    : White space\n(?<=\")(.+?)\\1(?=\\s*\"|$)\n\"\" : Empty"
            },
            {
                "text": " [^\\s\"]\n\nIn the example above, non-space and single quotes are matched as single characters. If it was an enclosed quote (nesting quote), the space would have been in the middle and therefore"
            },
            {
                "text": " *(?!\\\")[^\"]*\\z?*\n- \"\"nonMatches\"\"\n- \"noMatches\"\nThe RegEx for this is: *(?!\\\")[^\"]*\\"
            },
            {
                "text": " (^|[^\\w\"]+|[^\\w]$) no matche\n\n# - `\\b` Matches a word boundary. Word boundaries match the beginning or end of a word."
            },
            {
                "text": " \"^(?!\\\\\".*?\\\\\".)*$\"\n\n3. Write a RegEx that replaces all occurrences of the pattern \"abcdefghijklmnopqrstuvwxyz \" with"
            },
            {
                "text": " ^\\s*$  # The empty string\n- \"no matches\"          This regex matches the string \"no matches\". \n- \"no Matches\"           This regex matches the string \"no Matches\"."
            },
            {
                "text": " noMatches/^(\\.?.*)$/(^|[^^/]+/).*\n\nThis is another regex generator that generates a full set of regular expressions and tests them against sets of strings."
            }
        ]
    },
    {
        "expression": "ICON=\"[^\"]+\"",
        "raw_prompt": "Remove favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).",
        "refined_prompt": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>\"\n- \"ICON=\"~8G$\"\"\n- \"ICON=\"d-9ME6lcr[[:)qQ]'~WAZ~5yGH)w.jZwmIe396Ya[)+GuQr/t{S]]-[n}?NqB.E}NL.(mt=8W>*+\"\"\nNon-match examples:\n- \"<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>\"\n- \"///\"",
        "matches": [
            "<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>",
            "ICON=\"~8G$\"",
            "ICON=\"d-9ME6lcr[[:)qQ]'~WAZ~5yGH)w.jZwmIe396Ya[)+GuQr/t{S]]-[n}?NqB.E}NL.(mt=8W>*+\"",
            "ICON=\"K%NCb/.?IC^}\\kkeAUhTgc<nn|gySah7jFToN4wM;*1(7mPh7[e|-@%S*S`sn:u$bPg$oKPym3J=]dl`mGrXp<vllQ+\"",
            "ICON=\"WAYUS&SY5WyP[3yYZlKtvj v0+51cG+>jL!?op&LMFqECMW>|SF{QdX# hK S\"",
            "ICON=\"q\"",
            "ICON=\"-l\"",
            "ICON=\"[Jq.n?8H6|VN%,)5vDI|Te+@Ymib;4NM%3jO0KZqSF$<FnS1\"",
            "ICON=\".r:im.jUE6n@&q&sDNG=$2NI|m{TGa>\"",
            "ICON=\"-M4C]<\\\"",
            "ICON=\"IJE$bAy~|b\"",
            "ICON=\"@x=3VHJvN+}kySx;2,b!|RGX+Bu,C0fBY&M|6;Q[ak+;J1^R`7Wa?%9n>:\"",
            "ICON=\"HN+!Zkh\\Ss{la';u:O21KuX6E;!v.;pfKV!UH]}svXx:{6A tV/M2(Yh1sn'|kfL+z4(Do.`VVB^58{c:kwiU\""
        ],
        "non_matches": [
            "<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>",
            "///",
            "ICON",
            "ICON=\"\"",
            "ICON=\"\"342.\"\"",
            "ICON='edfr'",
            "ICON==\"fev\"",
            "icon=\"fre\"",
            "icon=\"987656789\"",
            "ICON=\"efreg32'",
            "ICON=---efrdcs",
            "ICON=....?"
        ],
        "id": 1909,
        "output": [
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAE"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAF"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAX"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAF"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAA"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAH"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAF"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAA"
            }
        ]
    },
    {
        "expression": "(^\\+?([1-8])?\\d(\\.\\d+)?$)|(^-90$)|(^-(([1-8])?\\d(\\.\\d+)?$))",
        "raw_prompt": "Latitude must<90 >=-90",
        "refined_prompt": "Matches numerics between -91and 90 (exclusive).\nMatch examples:\n- \"5.4\"\n- \"-0.58\"\n- \"-90\"\nNon-match examples:\n- \"-120\"\n- \"+1.4F\"",
        "matches": [
            "5.4",
            "-0.58",
            "-90",
            "+87",
            "-67.491449996440706490801988192811600862757554303908971854776873386684518",
            "-9.5185796683152094826299936893061694660355029389934",
            "+83",
            "-86.597562529211572613737307905105992947103177686406891",
            "-76.80652",
            "-47",
            "-7.2300271770582998480056257231823",
            "+75",
            "+0.3453863512674823672962343"
        ],
        "non_matches": [
            "-120",
            "+1.4F",
            "90",
            "-1111111",
            "09876",
            "00000",
            "5%",
            "#3",
            "4567",
            "12/12",
            "34-56",
            "3rffw"
        ],
        "id": 1912,
        "output": [
            {
                "text": "?[12-9](TGTN|GRN|TATN|CATN|NTA|GGA|GTG|CGG|GGG|CTC|ATC|CGT|GCG|TGT|TCT|TAT|AGT|T"
            },
            {
                "text": "\n\n```python\nimport re\n\npattern = r'^-?\\d+(\\.\\d+)?$'\n\nmatching_strings = [\n    '-0.58',\n    '5.4',\n    '-90',\n    '-120',\n    "
            },
            {
                "text": " /-?(0(?:\\.+0)+)$/\n\n3: Write a Python script which reads in the string and outputs the value and type of each element.\nNote that: the output for the first (and last) element is empty or it might contain a decimal."
            },
            {
                "text": "\n- \"-(\\\\d+[T])(\\\\d+[T][A-Z]?)?(\\\\.?)?([\\\\d]*[E+][-]?[\\\\d]+)$\"\n- \"^-?\\\\d+(\\\\.\\\\d+)"
            },
            {
                "text": "\n- -1\\.0-\n- 1[1-9].[0-8]|[1-9]?\n- -9[0-9]*|0(?=[0-9])|1(?=[0-9])\n- -9.|"
            },
            {
                "text": " ([+-]?\\d+\\.\\d+)\"\"\")\n\n4. Modify the \"Generate a RegEx\" example by including a specific range of character classes.\n\"\"\"\nimport re\nfrom random import randint, choice, sample\n\npattern = re.compile"
            },
            {
                "text": " ^\\\\-?\\\\d+\\\\.\\\\d+$\n\n7. Fill in the Blanks\nMatch the correct regex pattern for each blank space:\n1. Match a three-digit number.\n2. Match any uppercase character.\n3. Match any one or more"
            },
            {
                "text": " [^0-9-.]\n\n\n\n\n#### The use of NumPy for Astrophysicist\n\nWelcome back, young scientists! Today we are going to dive into the fascinating world of Python and learn how it can help us solve problems in astrophysics. Specifically, we will be"
            },
            {
                "text": "\n[0-9]+?[a-zA-Z]\\.?[a-zA-Z][1-9]*(?:-1[1-9]*[0-9])?\n\nThe RegEx for this Description would be \"0?[1"
            },
            {
                "text": " (\\d*\\.?\\d*-(?!\\d*[A-Z]))\\s*[-+]?[0-9]*\\.?\\d*|\\d*\\.?\\d+\n  This expression matches any number, including decimals, and strings"
            }
        ]
    },
    {
        "expression": "^((1[01])|(\\d)):[0-5]\\d(:[0-5]\\d)?\\s?([apAP][Mm])?$",
        "raw_prompt": "validate time\nin hh:mm:ss\nhh:mm\nhh:mm:ss pm(am,PM,AM)\n<12h",
        "refined_prompt": "Matches time in formats\r\n hh:mm:ss\r\nhh:mm\r\nhh:mm:ss pm (am,PM,AM)\r\n<12h\nMatch examples:\n- \"11:23:43PM\"\n- \"3:25:35\"\n- \"1:23 am\"\nNon-match examples:\n- \"12:01:01\"\n- \"3.14pm\"",
        "matches": [
            "11:23:43PM",
            "3:25:35",
            "1:23 am",
            "2:38",
            "9:37:48",
            "11:59:03",
            "7:30",
            "2:32:13",
            "4:13:33\u202fPm",
            "10:32",
            "1:13",
            "1:50\u202fAM",
            "10:28am"
        ],
        "non_matches": [
            "12:01:01",
            "3.14pm",
            "01:24AM",
            "time",
            "10:52pM0",
            "8:24:49-Pm",
            "11:55:22\u2004P",
            "02:05:39",
            "00:11:04\u2004pm",
            "2:15:58\u00a0A m",
            "04:18:16",
            "11:36  am"
        ],
        "id": 1913,
        "output": [
            {
                "text": " [a-z]{3}[a-z]{3}[a-z]\\s"
            },
            {
                "text": " (Regex) 0[1-9]\\d?|1[01](?:\\d|X"
            },
            {
                "text": "\r\n[a-zA-Z]+:[\\d]?[\\d]?[a-"
            },
            {
                "text": " \n(\\d{1,2}\\d{2}:\\d{2})(AM|PM|"
            },
            {
                "text": " ([0-9]):[0-9]:[0-9]PM\nExample sentences. (There"
            },
            {
                "text": " (^[1-9][0-9][0-9]|10:(0[0-9"
            },
            {
                "text": ".*pm.*\n\nHint: use the regex character class for strings\n\nSolution: \n^["
            },
            {
                "text": " (4 letters)(1 digit)(:|-)(1 digit)(0 or more letters)(-)(4 letters"
            },
            {
                "text": " (.+) +?[0-9]{1,3}[\\.,]?(?=^"
            },
            {
                "text": "^\\d{{1,2}}:^\\d{2,3}:[0-3]\\"
            }
        ]
    },
    {
        "expression": "^<\\s*(td|TD)\\s*(\\w|\\W)*\\s*>(\\w|\\W)*</(td|TD)>$",
        "raw_prompt": "match <td ***>***</td> in html,so any other html mark with<sth></sth> is just do a little change to this",
        "refined_prompt": "Match <td ***>***</td> in html\nMatch examples:\n- \"<td>hello kitty</td>\"\n- \"<TD WIDTH='20></TD>\"\n- \"<TD >&NBSP;</td>\"\nNon-match examples:\n- \"<td>< /td>\"\n- \"<TD HELLO</td>\"",
        "matches": [
            "<td>hello kitty</td>",
            "<TD WIDTH='20></TD>",
            "<TD >&NBSP;</td>",
            "<td> </td>",
            "<td>frt 543f</td>",
            "<td>flkjhgfdsdfghjkjhgfdfghjkhgfdfghjk</td>",
            "<td>987654edcvbjuytre56u</td>",
            "<td><></td>",
            "<td><lkjhgfcv0h-g%></td>",
            "<td>//////</td>",
            "<td>---------</td>",
            "<td>+</td>",
            "<td>12343@@@</td>"
        ],
        "non_matches": [
            "<td>< /td>",
            "<TD HELLO</td>",
            "<table></table>",
            "<fce>r kitty</td>",
            "<td>12343@@@</d>",
            "<p>43@@@</p>",
            "<p></p>",
            "<987></0987>",
            "<-></[>",
            "<>revcd</>",
            "<></>",
            "<3e3></>"
        ],
        "id": 1914,
        "output": [
            {
                "text": "\nPattern (1): hello kitty \\/ /td <td */\nPattern (2): \\s*/ \\s* hello \\b \\s* kitty \\b </td <td \\*/"
            },
            {
                "text": " ^hello\n- \"<TD width='20></TD>\"Generate a RegEx for this description.\nAnswer: width='20'\n- \"<td >&NBSP;</td>\"Generate"
            },
            {
                "text": " \n(?<=<TD>.*</TD>)\n\n4. **Advanced RegEx**: Use a regular expression to find all URLs in an HTML file.\nHint: URLs are"
            },
            {
                "text": " ^\\/td>.*$\n\nReal-World Usecases: \n\nUsecase 1: \nA group of students are asked to create a regular expression of a password that is not"
            },
            {
                "text": "\n\n```python\nhtml = \"<html><head><td>hello kitty</td></head></html>\"\nregex = \".*(?<title>(.*).*)(?<"
            },
            {
                "text": "\n/(\\[ *)([a-zA-Z]*) \\] */\n-  <* *< td> < /td> */ </td> /** </td>, \n"
            },
            {
                "text": " <td (width)=[\\d]+></td>\n- <TD width='10'></TD>Generate a RegEx for the width parameter. \nAnswer: width=[\\d]+"
            },
            {
                "text": " \\(/(?=(?:[^`\"]*`.*)?[^`\"]*$)/g)\n\nExercise 4: Modify exercise 3 to handle the special character ` in the input."
            },
            {
                "text": " (\\\\(\\\\s*)\\\\)<td>(\\\\s*)*>*(\\\\s*)</td>\n\"\"\"\n\nimport re\npattern = re.compile(r\"(\\"
            },
            {
                "text": " \n#<td[^>]*>(.*)</td[^>]*:\nThe description in <td[^>]*/td> can take any text.\n<td> matches any word between"
            }
        ]
    },
    {
        "expression": "^((([1]\\d{2})|(22[0-3])|([1-9]\\d)|(2[01]\\d)|[1-9]).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d))$",
        "raw_prompt": "match ip\naddress from 1.0.0.0 to 223.255.255.255",
        "refined_prompt": "Match ip addresses from 1.0.0.0 to 223.255.255.255\nMatch examples:\n- \"192.168.0.1\"\n- \"223.255.255.255\"\n- \"9.0.0.0\"\nNon-match examples:\n- \"0.10.2.52\"\n- \"255.255.255.255\"",
        "matches": [
            "192.168.0.1",
            "223.255.255.255",
            "9.0.0.0",
            "165A235h238'3",
            "221.202_3>250",
            "77K712251U200",
            "5\"139.16771",
            "221.104R251A9",
            "215{8)6E89",
            "126J250H34475",
            "104^253m103[99",
            "214h81'36)211",
            "220~8M224=1"
        ],
        "non_matches": [
            "0.10.2.52",
            "255.255.255.255",
            "127.0.257.1",
            "lkjhgf",
            "1.2.3",
            "ip address",
            "56.232.774443",
            "0340",
            "#34",
            "123.453.2324",
            "0.0.0",
            "09876543"
        ],
        "id": 1915,
        "output": [
            {
                "text": "\n- \"((255.255.0\\.){1,6}\\.){1,3}(\\d{1,3}\\.){"
            },
            {
                "text": "\n```python\nimport re\nresult = re.sub(r'^(([0-9A-Fa-f]{1,"
            },
            {
                "text": " [0-9]{1,3}\\.?[0-9]{1,3}\\.?[0-9]{1"
            },
            {
                "text": " \n^(?!0[0-9]\\.)(?!10[0-2]\\.)(?!172[0-9]"
            },
            {
                "text": " ^.*[01.24353492a-e].*$\n\n3. Write a RegEx for a description beginning with \"Example.\""
            },
            {
                "text": " 0[1-9]\\d{1,2}\\.\\d{2}$\n\nExample 4:\nWrite a Python program that"
            },
            {
                "text": "\n[0-9]{2}\\. [0-9][0-9][0-9]\\/[0-9][0-"
            },
            {
                "text": " \"^((25[0-5])([1-9])\\.){3}([0-9]{1,3}\\.["
            },
            {
                "text": " In the above example, the RegEx should match the subnet which excludes 255.255.255.255 \n```\n\n\n2. Gener"
            },
            {
                "text": " (?<!\\d)\\b(?![-\\.])(?:[1-9]\\d?\\.){7}\\b|"
            }
        ]
    },
    {
        "expression": "(((0[13578]|10|12)([/])(0[1-9]|[12][0-9]|3[01])([/])([1-2][0,9][0-9][0-9]))|((0[469]|11)([/])([0][1-9]|[12][0-9]|30)([/])([1-2][0,9][0-9][0-9]))|((02)([/])(0[1-9]|1[0-9]|2[0-8])([/])([1-2][0,9][0-9][0-9]))|((02)([/])(29)(\\.|-|\\/)([02468][048]00))|((02)([/])(29)([/])([13579][26]00))|((02)([/])(29)([/])([0-9][0-9][0][48]))|((02)([/])(29)([/])([0-9][0-9][2468][048]))|((02)([/])(29)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "This is the USA Date Format. MM/DD/YYYY with checking leaf year",
        "refined_prompt": "This is the USA Date Format. MM/DD/YYYY with checking leap year\nMatch examples:\n- \"05/15/2008\"\n- \"02/29/2008\"\n- \"02/29/3200\"\nNon-match examples:\n- \"05-12-2008\"\n- \"02/29/2007\"",
        "matches": [
            "05/15/2008",
            "02/29/2008",
            "02/29/3200",
            "10/01/1045",
            "10/31/1023",
            "05/02/1,91",
            "02/29.6800",
            "02/29/1744",
            "02/13/2009",
            "02/29/8572",
            "02/29/2508",
            "02/29/4176",
            "02/29/8256"
        ],
        "non_matches": [
            "05-12-2008",
            "02/29/2007",
            "02/28 2910",
            "02 29/5600",
            "02 29 1600",
            "11/30-2998",
            "10-02/2,72",
            "10-02-2,72",
            "02.29.9156",
            "02:29:9600",
            "11071909",
            "02/249/2764"
        ],
        "id": 1916,
        "output": [
            {
                "text": " \nimport re\n\nvalid_dates = [\"05/15/2008\", \"02/29/2008\", \"02/29/3200\",\"05-12-2008\"]\ninvalid_"
            },
            {
                "text": " ^(0[1-9]|1[012])\\/(0[1-9]|[12][0-9]|3[01])\\/((0[1-9]"
            },
            {
                "text": "  (^(19|20)\\/(3[0-1])\\/(2[0-9]))/(2[0-9])([0-9]{3})$"
            },
            {
                "text": " MM/DD/YYYY (examples) MM/DD/YYYY-leap-year-or-leap (non-examples)\nHow would I solve this challenge?\nI"
            },
            {
                "text": " /((\\d\\d)/((1\\d|(2))\\/2\\d))/\n\nThe RegEx code could then be used in:\n>>> if (r.match(dat"
            },
            {
                "text": " MM/DD/YYYY\n\nExample 3.3: Replacing Text\nHere you are going to replace all occurrences of the word 'banana' by 'orange'. Use the re.sub()"
            },
            {
                "text": " ^[a-z]\\d{2}\\/[0-9]{1,2}[a-z]{\\d{2}[a-z]{3}$\n"
            },
            {
                "text": " \".*09/05/([0-9]{4}|[0-9]{\"1,2})/([0-9]{1,2}|[0-9]"
            },
            {
                "text": " yyyymmdd(yyyy-mm-dd).\n\n# 3. Create a RegEx that will capture an email address\n# Idea: Use the \"^[a-zA-Z"
            },
            {
                "text": "  ^[0-9]{2}-0(((1[012]|0?[1-9])|(4[0-9])))?-(((0?["
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]*)+[ ]([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]+)+$",
        "raw_prompt": "Requires a person's name including at least 2 parts. (first and last) Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial. Works well for filtering names on validation.",
        "refined_prompt": "Matches a person's name with at least 2 parts (first and last). Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial.\nMatch examples:\n- \"E.J. O'Malley\"\n- \"Jack O'Neil\"\n- \"Mary-Lou Elizabeth Jones\"\nNon-match examples:\n- \"Johnathan Michael S.\"\n- \"Prince\"",
        "matches": [
            "E.J. O'Malley",
            "Jack O'Neil",
            "Mary-Lou Elizabeth Jones",
            "John Smith",
            "Mr. Jones",
            "Bernardo the third",
            "Th lo",
            "Mrs. McMan",
            "wefh wejflruh",
            "fe eeg",
            "krec erfg",
            "refds ervh",
            "Thanks Be"
        ],
        "non_matches": [
            "Johnathan Michael S.",
            "Prince",
            "Teddy Has-a..Fake-Name",
            "'mc wfe",
            "384 483",
            "w",
            "342",
            "name",
            "name",
            "firstLast",
            "porefcds",
            "#comment"
        ],
        "id": 1921,
        "output": [
            {
                "text": "\n"
            },
            {
                "text": " ("
            },
            {
                "text": " The"
            },
            {
                "text": " A"
            },
            {
                "text": "\n"
            },
            {
                "text": " R"
            },
            {
                "text": "\n"
            },
            {
                "text": "\n"
            },
            {
                "text": " @"
            },
            {
                "text": "\n"
            }
        ]
    },
    {
        "expression": "((19|20)[0-9]{2})-(([1-9])|(0[1-9])|(1[0-2]))-((3[0-1])|([0-2][0-9])|([0-9]))",
        "raw_prompt": "Validate the year month and day.",
        "refined_prompt": "Matches the year month and day in format (YYYY-MM-DD).\nMatch examples:\n- \"2008-12-15\"\n- \"1960-05-16\"\n- \"2091-1-7\"\nNon-match examples:\n- \"1556/9/8\"\n- \"year\"",
        "matches": [
            "2008-12-15",
            "1960-05-16",
            "2091-1-7",
            "1965-01-30",
            "1901-6-2",
            "1961-9-25",
            "2011-10-8",
            "2042-1-5",
            "1980-02-8",
            "1933-4-3",
            "1931-11-7",
            "1974-6-0",
            "1955-09-05"
        ],
        "non_matches": [
            "1556/9/8",
            "year",
            "2074/8-30",
            "2057 10-3",
            "1935-0323",
            "2084230",
            "1905 5 27",
            "3709-09",
            "1968-30",
            "redsc",
            "12:12",
            "AM"
        ],
        "id": 1924,
        "output": [
            {
                "text": " A number of digits \\d\\d followed by a hyphen (-) followed by a number of digits \\d\\d followed by dashes (\"-\")  \n\n**3. The `search()` function**"
            },
            {
                "text": " \n- regex = \"(?<year>\\d{4})[-](?!-)(?<month>\\d{1,2})[-](?!-)(?<day>\\d{"
            },
            {
                "text": " [Exercise Answer](https://www.w3schools.com/python/python_regex.asp).\n\n#### Solutions:\n```python\nre.findall( \"^([\\d"
            },
            {
                "text": " \n/(\\-?\\d{4}).(-?\\d{2}).(-?\\d{2})/\nExamples:\n\"-2008-01-15\", \"1969-03-20\","
            },
            {
                "text": " (?:\\d{4})-(?:\\d{2})-(?:\\d{2})\nExercise 3: Extract the name and job status from an item in order to complete the following tasks:"
            },
            {
                "text": " r\"(\\d\\d)([0224])(\\d\\d)([012])\"\n\nExercise 2: Use the \"positive lookahead\" operator (?=) to match exactly ten words of text"
            },
            {
                "text": " \"^(\\d*)-(\\d*)-(\\d*)$\"\n\n(5) Use \"(\" to signify the start of a group, and \")\" to signify the end of a group.\nThe group"
            },
            {
                "text": " ((\\d{4})/(\\d{2})/(\\d{2}))\n\n3. Regular Expression for finding all occurences of a letter, number, and a word in a sentence.\n"
            },
            {
                "text": " (\\d{4})-(\\d{2})-(\\d{2})$\n\nExample 2: Formatting IPs.\n\nIP addresses are often presented as a long string of numbers and colons"
            },
            {
                "text": " \\d{4}-\\d\\d-\\d\\d\n- \"year month day\"Generate a RegEx for this description. \n\nExercise 2:\nWrite a RegEx to validate"
            }
        ]
    },
    {
        "expression": "^[:*:]",
        "raw_prompt": "This checks whether the string is equals to \"*\" i.e., contains only \"*(Asterisk)\" or begins with Asterisk.",
        "refined_prompt": "This checks whether the string is equals to \"*\" i.e., contains only \"*(Asterisk)\" or begins with Asterisk.\nMatch examples:\n- \"*\"\nNon-match examples:\n- \"a*\"\n- \"asdf\"",
        "matches": [
            "*"
        ],
        "non_matches": [
            "a*",
            "asdf",
            "kjhbgvc",
            "asteric",
            "wefcd",
            "1234",
            "$",
            "#",
            "@",
            "!",
            "-",
            "+"
        ],
        "id": 1925,
        "output": [
            {
                "text": "\n\"(^[^.*]+).*(.*)($)\"\n```\n\n\n## The use of Django for Back End Developer\n\n### Applications of Django Static Files for Back End Developer\n\nThis section will cover:\n- What are static files?\n- Why"
            },
            {
                "text": "\n```python\nimport re\n\nmy_string = \"*\"\npattern = r'^\\*$'\nif (re.match(pattern, my_string) == None):\n    print(\"Non-matching string\")\nelse:\n    print"
            },
            {
                "text": " ^[a-z]+$\n\n4. Write a Python program that reads a file and prints the lines in reverse order. The program should ignore the blank lines.\nHint: use the file object's readlines() and readlines() methods, and reverse the string with"
            },
            {
                "text": " r\"^a*\"\n- \"asdf*\"Generate a RegEx for this description.\nAnswer: r\"^(asdf)+$\"\n\nExercise four: Using the rpartition function, split the string \"Dinner, please\" into two"
            },
            {
                "text": " ^[^a-z]*a*$\n\nQ:\n\nConverting a dict to a tree (python)\n\nI'm currently trying to transform a dict to a tree in python, which is currently being done in lark (Python, version 2.5"
            },
            {
                "text": " \n^[Aa]([a-z0-9])+[Aa]$\n\n1. **Exercise 1**:\n```python\n# A simple password checker. \npasswords = [\"pass123\", \"testPass\", \"12"
            },
            {
                "text": " [a*]+ should be used\n\n```python\n\nregex_match=re.match(pattern, string)\nif(regex_match!=None):\n    print(\"Match\")\nelse:\n    print(\"No Match\")\n\n\nstring2"
            },
            {
                "text": "\n[\\*]?\\w\nExplanation:\n[\\*]      // Matches \"*\"\n?          // Matches \"0 or 1 times\", make sure the preceding element is matched\n\\w          // matches \"letters, digits or underscores\"\n\n"
            },
            {
                "text": " \"a*\"\nUse case \nThe use case \"Finding the most common character in a string\" where we find the most common letter in a string.\n\n```python\nword = \"Python RegEx Practice\"\nletter_counts = {}\nfor char in"
            },
            {
                "text": " ^(?:.*\\*(\\*(\\s*[A-Z].*\\s*[A-Z])?)*)(?:\\s*(?!\\1|.*\\*$))\n\nA:\n\nI think you are looking for this..\n^"
            }
        ]
    },
    {
        "expression": "^[0-9]+\\.?[0-9]?[0-9]?[0,5]?$",
        "raw_prompt": "The time should be fractional number and divisible by 0.005",
        "refined_prompt": "Number divisible by 0.005\nMatch examples:\n- \"1.005\"\n- \"60\"\n- \"0.08\"\nNon-match examples:\n- \"1.009\"\n- \"-8\"",
        "matches": [
            "1.005",
            "60",
            "0.08",
            "33",
            "234533",
            "0.10",
            "8",
            "093",
            "231",
            "12345678",
            "09876534222222",
            "1,",
            "64634"
        ],
        "non_matches": [
            "1.009",
            "-8",
            ".005",
            "-1",
            "098765456789ikmnbvc",
            "fraction",
            "#3",
            "4%",
            "12/12",
            "3.1415",
            "00000003333348.0-",
            ".0"
        ],
        "id": 1927,
        "output": [
            {
                "text": " Match examples should be followed by a period and a number, followed by digits and periods, or preceded by a number and end with a percent. Non-match examples should include zero or more digits and periods before the dollar sign (e.g., \"3.01\").\n\nExercise 3:\nDevelop a RegEx to"
            },
            {
                "text": " \"\\d+,\\(\\d+\\).+\"\n- \"2.\" Generate a RegEx for this description\nAnswer: \"\\d+\\.?\"\n- \"0.01022\" Generate a RegEx for this description. \nAnswer: \"\\d+,\\(\\d+\\).+\"\n- \"-"
            },
            {
                "text": " ^\\(.*\\).*\\s*(.*)\n\nExercise 5: Match examples and list the matched groups.\nExercise: Match the following groups:\n- group1: Any group from \\1 to \\4\n- group2: Any group from \\2 to \\7\n- group3:"
            },
            {
                "text": " If any of the word characters is preceded or followed by a non-letter or non-digit character, it is a non-matching character group in the RegEx.\n\nExercise 2:\nImagine you are working on a healthcare analytics project, and you want to extract all the unique patient IDs from a large dataset."
            },
            {
                "text": " ^[+-]?([0-9]*)(\\.[0-9]*)$ | ^[+-]([0-9]*)(\\.[0-9]*)*$ - Both positive and negative\n\n\n\nComparison \u2013 Gentle and Rough\n\nIn life, we compare things all"
            },
            {
                "text": " \"([0-9]{1}\\.[0-9]{0,2}\\.[0-9]{0,2}).*\"\n\nExercise 3: Given the following sentence \"The price of the product is $0.009\" Identify the correct character in this sentence\n\"The price of"
            },
            {
                "text": " \".-{3,2}?\"\n\n\n\nHi there! Today, I want to talk about company-telecommunications! Have you ever wondered how your family is able to talk to each other even when they're far away? Well, that's all thanks to company-telecommunications!\n\nCompanies that specialize in telecommunications"
            },
            {
                "text": "\n^\\d*\\.(\\.[0-9]{3})$\n4.7 Match example.\nMatch examples:\n- 12.34\n-.749\n- 0.912\n- 123.45\nNon-match examples:\n- 25\n- 6\n5.0 Match examples"
            },
            {
                "text": " \\d*.+ /^-?\\d+\\.0-9*$\n\nExercise 5: Create a RegEx that matches a string of digits (ex. \"1234\") or letters (ex. \"abc\") in any order. \nAnswer: ^[^a-zA-Z\\"
            },
            {
                "text": "\n- r'^(0*)(\\d*\\.\\d{2})$'\n\n\n\nQuestion 4:\nA rectangular field is 60 meters long and 40 meters wide. If a square fence is built along one side of the field, how much fencing material is needed?\n\nSolution:\nThe diagonal"
            }
        ]
    },
    {
        "expression": "^\\d+\\/?\\d*$",
        "raw_prompt": "This simple expression is used to validate fractions or UK odds.\nIt will match integers, allowing 10/1 to be entered as 10, and fractions.\nIt will not match negative numbers or fractions, spaces or any alphabetical characters.",
        "refined_prompt": "Used to validate fractions or UK odds.\r\nIt will match integers, allowing 10/1 to be entered as 10, and fractions.\r\nIt will not match negative numbers or fractions, spaces or any alphabetical characters.\nMatch examples:\n- \"10\"\n- \"2/3\"\n- \"100/30\"\nNon-match examples:\n- \"-10\"\n- \"-2/3\"",
        "matches": [
            "10",
            "2/3",
            "100/30",
            "8212974770388710493571330448503540033628930518484666081223057229",
            "8678978281274030324920378",
            "876",
            "013",
            "237878",
            "67237632",
            "9",
            "44444",
            "12/12",
            "3/8"
        ],
        "non_matches": [
            "-10",
            "-2/3",
            "text",
            "10 / 1",
            "42/7eok",
            "-9",
            "number",
            "fraction",
            "twelve/twelve",
            "3.0",
            "9993.",
            "22220.000"
        ],
        "id": 1931,
        "output": [
            {
                "text": " /^(-?\\d+(,\\d+)?|\\#[0-9]+)$/g\r\nExamples of"
            },
            {
                "text": " (r'(?:(?:-\\d+(?:,\\d+)*?)\\s*|(?:[+-])"
            },
            {
                "text": " (^\\d*)\\s*\\/\\s*\\d*$\nThe regex: \\d+\\s*\\/\\"
            },
            {
                "text": " (0..3][0-9]?\\.)?:?(20|30)?$\n\nExercise 2: Create a"
            },
            {
                "text": " \"^([0-9]+|[+\\-]?)(\\/)([0-9]+|[+\\-]?)("
            },
            {
                "text": " non-match_description_with_number|-(?:[0-9]|[1-9]\\d*)(("
            },
            {
                "text": "\r\n^(0|[1-9][0-9]*)(\\s|/)([1-9][0"
            },
            {
                "text": " (?:^\\-?\\d*(?:\\.\\d+)?$|^\\.\\d+$) \r\n"
            },
            {
                "text": " [-0-9/0-9/-2-9/-3-9,-9/9]\"10 [-,.-]$\""
            },
            {
                "text": " \r\n- [0-9] * \r\n- [0-9] [a-z] * [0-"
            }
        ]
    },
    {
        "expression": "^(\\d{1,4}?[.]{0,1}?\\d{0,3}?)$",
        "raw_prompt": "This expression validate the add of numbers with or without decimal",
        "refined_prompt": "Matches numbers with or without decimal\nMatch examples:\n- \"123\"\n- \"123.1\"\n- \"100.\"\nNon-match examples:\n- \"12345.1234\"\n- \".012\"",
        "matches": [
            "123",
            "123.1",
            "100.",
            "0.2",
            "2341.123",
            "13060",
            "336",
            "663",
            "7432",
            "553.3",
            "067",
            "22",
            "7.54"
        ],
        "non_matches": [
            "12345.1234",
            ".012",
            ".2893",
            "3434.00000",
            ".0",
            "-342",
            "+9876",
            "2423423.",
            "23.0032",
            "#3",
            "5%",
            "12/12"
        ],
        "id": 1933,
        "output": [
            {
                "text": "\nRegEx to match number with decimal: (\\d+\\.\\d+)\n\nNow, let's take a look at some exercises:\n\nExercise: Match numbers with or without decimal\n1. Match \"12345\"\n2. Match \"123.45\"\n3. Match \"10\"\n4"
            },
            {
                "text": " \n\\.\\d+\\.\n\nExercise 3:\nCreate the RegEx to match a full stop (.) followed by one letter and any other character in lowercase.\nAnswer:.[a-z]\n\nExercise 4:\nMatch examples of the following words: dog, cat, bird.\n"
            },
            {
                "text": "\n(?<number>[^.]*)(?:\\.{1,2})([^.]*)\n\n3. Match words on a list\nMatch any words on the given list (a, A, adadog, ade, etc...) in a sentence.\nQuestion: Can you write a RegEx"
            },
            {
                "text": " Matches numbers with or without decimal.\nIllustration Paragraph:\n        Tom and Jerry are at a park for a game of Frisbee. Tom throws the Frisbee with all his might towards Jerry who manages to catch it. As Jerry throws the Frisbee back to Tom, he notices that it\u2019"
            },
            {
                "text": " ([0-9]+)[.]([0-9]+)?\n\n3. Create a class that can read a text file containing numbers and generate a match list. The class should:\na.  Add a method that generates a list of all matches.\nb.  Add a method that generates a single match."
            },
            {
                "text": ".{3,6}\n\nExercise 2: \n\nWhat is the difference between.{3} and.{3,6}?\nAnswer:.{3} matches exactly 3 characters, whereas.{3,6} matches 3 to 6 characters. \n\nExercise 3:\n\nWhat"
            },
            {
                "text": " \"(^|[^\\d\\.])([\\d\\.][^\\d.]+)($)\"\nExercise 2:\nWrite a function that takes in a string and returns True if the string contains a number (integer or decimal), False otherwise.\nHint: Use the RegEx function from exercise 1."
            },
            {
                "text": "\n\"\\d+\"\n\"\"\"\n\nciphertext = \"1234.12345\"\nprint(re.match(r\".\\d+\", ciphertext))\n```\n\nOutput:\n```\n<re.Match object; span=(0, 4), match='1234'>\n``"
            },
            {
                "text": " (.*?)(\\.)(.*)(\\d)\n\nExercise 3: Decoding a Phone Number\nDecode a phone number encoded in the following manner: 5 + 7894 - 555-1234 (Use RegEx)\nAnswer: 57899551234\n\nExercise 4: Matching"
            },
            {
                "text": " A regular expression pattern that matches all numbers between 1 and 100 with a maximum length of 4: \n^\\d{1,4}([\\.\\d]{0,3})?\n\nLecture Note: 4.3.6 Using Python's List Comprehensions\n\nContents:\n1."
            }
        ]
    },
    {
        "expression": "^([\\u20AC]?[1-9]\\d*\\.\\d{3}(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*)$",
        "raw_prompt": "Optional Amount, with optional thousands seperator (using the point) and optional decimal comma. If decimal comma is in string, then 2 trailing digits are required. Also checks for the optional euro sign",
        "refined_prompt": "Matches amounts of money with an optional decimal point. If the decimal comma is in string, then 2 trailing digits are required. Also, checks for the optional euro sign.\nMatch examples:\n- \"1\"\n- \"1,00\"\n- \"1.000,00\"\nNon-match examples:\n- \"1a\"\n- \".00,00\"",
        "matches": [
            "1",
            "1,00",
            "1.000,00",
            "\u20ac1",
            "339807682046239015456626518163951619966358191099829441817856",
            "\u20ac33084577111055998450840731337746980155538582722558334921161762731208435427527533259357800551181084005,39",
            "\u20ac73.344",
            "\u20ac204206394492078854068542,05",
            "9564012388762870725219575206910547",
            "\u20ac4610,45",
            "36565740277351769916606018574077579915171665781774889580",
            "\u20ac79386532622532235870547500131604581872272",
            "7014506779398"
        ],
        "non_matches": [
            "1a",
            ".00,00",
            "1,0",
            "$1",
            "12/12",
            "24.34",
            "23232332.3232",
            "-1",
            "+8765",
            "7.",
            "00000",
            "money"
        ],
        "id": 1941,
        "output": [
            {
                "text": " (?:\\d+\\.\\d*|\\d+)(,?\\d+)?\n3) (?<=\\.)(?<!\\.\\.)"
            },
            {
                "text": " /^(?=\\w+$)\\d(?:.\\d{3})?(?:[Ee]ur)(?=[,.)]?)$/"
            },
            {
                "text": " (?=(\\d{1,3})\\.{0,3})[1-9](a|e)\n\"\"\"\n\n# Solution\ntext = \"\"\"2"
            },
            {
                "text": " (.00|\\d+,|\\d+)\n\nThe question is similar to Exercise 4, but requires an additional requirement for the amount to have at least two decimal places and"
            },
            {
                "text": "\n^[+-]?((0|[,:])\\d*\\.)?$\n\nA:\n\nI think the best way is to use the"
            },
            {
                "text": " [a-z]+[0-9]{1,3}(?:a|z)*\n\nMatch strings with an optional comma inside parenthesis. If a comma"
            },
            {
                "text": " \"(^[\\0-9]*\\.?[\\0-9]++)?$\"\n\nExercise 2:\n\nCreate a regex that matches email addresses"
            },
            {
                "text": " \n(?<!^)|\\d*\\.,?\\d*(?:/)?\\d+\n\nWhat does this RegEx say? \n\""
            },
            {
                "text": "\n(^)(-?[0-9]+(,[0-9]+)?[$]?)($(,|$))$\n\nA:\n\n"
            },
            {
                "text": " [1-2][.][0-9]\n\n4. Write a regular expression that matches this string: \n\nI have 5.50 dollars. \n"
            }
        ]
    },
    {
        "expression": "\\b[P|p]?(OST|ost)?\\.?\\s*[O|o|0]?(ffice|FFICE)?\\.?\\s*[B|b][O|o|0]?[X|x]?\\.?\\s+[#]?(\\d+)\\b",
        "raw_prompt": "Modified version of Chris Myers' regexp for po boxes. This one won't match the word \"box\" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.",
        "refined_prompt": "Matches po boxes. This one won't match the word \"box\" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.\nMatch examples:\n- \"po box 123\"\n- \"p.o.b. #123\"\n- \"box 123\"\nNon-match examples:\n- \"123 box canyon rd\"\n- \"po box *\"",
        "matches": [
            "po box 123",
            "p.o.b. #123",
            "box 123",
            "box 34",
            "po box 34984934",
            "p.o.b. #22",
            "p.o.b. #879876543456789",
            "box 347384",
            "box 123",
            "box 098765432",
            "po box 6",
            "po box 77777",
            "po box 124532123421"
        ],
        "non_matches": [
            "123 box canyon rd",
            "po box *",
            "pob reoiewjcdsokl",
            "p.o.b. #87uyt",
            "po box ##43834",
            "boxbox 3898",
            "box po 987654",
            "389237889723",
            "number",
            "98767898 po box",
            "87565 box",
            "39823 p.o.b."
        ],
        "id": 1943,
        "output": [
            {
                "text": " \"(\\d+(\\.\\d+)?[aA-zZ]*\\/["
            },
            {
                "text": "\nimport re\n\ntxtFile = open(\"po-boxes.txt\", 'r')"
            },
            {
                "text": " ^(p\\.o\\.b\\s)?(\\d+)$\n\n**2."
            },
            {
                "text": "\np.o.b. \\d{0,2}[ *]r["
            },
            {
                "text": "\n/(^|\\s|#|[0-9A-Fa-f])"
            },
            {
                "text": " http://regex101.com/r/3gV1zW/1\n"
            },
            {
                "text": " (?<=p\\.o\\.\\s)\\d\\d\\d$ \n"
            },
            {
                "text": "\n([1-9]\\d?-?)*\\.?([A-Z]["
            },
            {
                "text": " \"po box (\\d{3}-\\d{3})\\s(.*"
            },
            {
                "text": " (0-9)\\s\\/\\s(#\\/)?[a-zA-"
            }
        ]
    },
    {
        "expression": "http[s]?://[a-zA-Z0-9.-/]+",
        "raw_prompt": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas . - /",
        "refined_prompt": "Matches entries that start with http:// or https:// and the contents are limited to alphas\nMatch examples:\n- \"http://www.google.com\"\n- \"https://www.google.com\"\n- \"http://localhost/\"\nNon-match examples:\n- \"www.google.com\"\n- \"website\"",
        "matches": [
            "http://www.google.com",
            "https://www.google.com",
            "http://localhost/",
            "https://0evOuIJuIf4tK.r6ty5smP2AleyI5E380K34v679iU6QlA",
            "https://6BigFbaiZcfA5Bovlo5nWx8",
            "http://O1woe2u.xsroK/f2s6tD8sggK7KVv8d9I7",
            "https://chcYCj5nislUpe0GTyXn",
            "http://KjgYqEuhTQUl9qMP7fbtXST35wo.5qagHh7jtVDCfiocIOTtRyd9S9gtO6QigxHzgvq6o",
            "http://mgRx6g74eLPV6Y9DbFZUv",
            "https://X7KBR",
            "https://GwjanOZWgfuvIi0a0mb.q0",
            "http://Gv3wR.NH8lay8DBFw3MGwPKP",
            "http://J0YKuQPvwb1IPvqQfg/"
        ],
        "non_matches": [
            "www.google.com",
            "website",
            "www",
            "http",
            "http:/ewf.4444",
            "https",
            "wwwwww",
            "ftp",
            "@gmail.com",
            "dfghjk",
            "jfhsdkjjh7",
            "?:///"
        ],
        "id": 1944,
        "output": [
            {
                "text": " We're matching URLs within www\\b or https\\b and only restricting alphas.\n\n**3. How to use Python's compile() and findall() Methods to generate Regular Expressions.**"
            },
            {
                "text": " [^a-zA-Z\\s-]\n4. [a-zA-Z0-9_.\\-_]+@[a-zA-Z0-9-]+"
            },
            {
                "text": "\n\nMy code:\nimport texttable, re\n\nwords = [\n    \"www.google.com\", \n    \"https://www.google.com\",\n    \"http://"
            },
            {
                "text": " https?:\\/\\/[^\\s\\.]+ \n\nExercise 4:\nMatch only the first 3 characters of a string that begins with \"https://\". \nAnswer: https "
            },
            {
                "text": " (regex) (http|https)://[a-zA-Z0-9_.]+\n\nExercise 4:\nWrite a Python program that takes a string as input and replaces"
            },
            {
                "text": " (http.*)\n3. How would you generate a regex to match a string that contains the word http?\nGenerate a regex for this description.\nAnswer: (http[s]?://"
            },
            {
                "text": " ^[\\da-zA-Z.-_]+\\/\\/([\\da-zA-Z.-_]+)$\"\n\nExercise 4: Find all possible variations of a file path that"
            },
            {
                "text": "\n/(^[\\w\\s]+)(.*?)([https?:///]$)/\n\n\n#### Exercise 5.1\n\nGiven a list string with URLs separated by ';' characters"
            },
            {
                "text": " ^https?://[^\\s\\.]+[a-zA-Z]+(\\.[a-zA-Z]+)+$\n\n\n# Chapter: The use of Python"
            },
            {
                "text": " (r'^http?\\://.*')\n```\n    import re\n    pattern = r'^http?://.*'\n    text1 = 'www.google.com'\n"
            }
        ]
    },
    {
        "expression": "^[-|\\+]?[0-9]{1,3}(\\,[0-9]{3})*$|^[-|\\+]?[0-9]+$",
        "raw_prompt": "Integer with or without commas. Signed or unsigned.",
        "refined_prompt": "Integer with or without commas. Signed or unsigned.\nMatch examples:\n- \"1,234\"\n- \"1234\"\n- \"-1,234\"\nNon-match examples:\n- \"12,34\"\n- \"1.234\"",
        "matches": [
            "1,234",
            "1234",
            "-1,234",
            "-1234",
            "5,284,672,996,084,725,111,195,488,002,311,154,146,366,315,128,991,910,862,981",
            "+00993825521146278389368453995955317436058624161441235349404816150056415287648833572740653639227948366",
            "4,422,667,944,007,030,668",
            "-11910129132992855685723880445984210813189987741487",
            "69,323,930,057,037,633,620,458,298,023,423,992,658,515,620,246,895,518,759,537",
            "1742622085320083786852418024082354099699828530173564516729499509784593164924943697022",
            "4,174,465,507,445,981,780,363,603,922,684,492,009,745,206,695,595,843,515,805,056,746,828,867",
            "+2,265,515,659,172,150,913,433,061,506,903,293,337,684,439,870,025,234,247,616,568,359,077,316,580,249,680,489,996,149,120,951,884,034,361,554,980,755,574,749,349,435,533,301,233,541,711,494,888,276,348,544,174,148,558,349,540",
            "25876462041417115483574178278923645437430730250097693102058642109182878068881533322914802787"
        ],
        "non_matches": [
            "12,34",
            "1.234",
            "abc",
            "##",
            "+",
            "-",
            ".0",
            "(876)",
            "ijouhygtf",
            "32ewds",
            "g442",
            "245gerwf"
        ],
        "id": 1950,
        "output": [
            {
                "text": " \"^\\d*[.-](\\d+[.:]\\d*)?(e|E)[+-]?\\d+$\"\n- Match examples:\n- \"100\"\n- \"1,000\"\nAnswer: \"^\\d+$\"\n"
            },
            {
                "text": " (\\d{1,3}[,.]){2}\n\n- \"12:34\" Match each pair of digits within a single period.\nMatch each pair of digits.\nExample:\n\"12.34\" - matched\n\"12:34\" - not matched\"\"\""
            },
            {
                "text": " ^(-+)?[0-9]+,?[0-9]*$\n\n\n\nAs a journalist, I rely on my language arts skills to communicate effectively with my readers. Research organization and outlining are important tools to help me stay on track when reporting on a story.\n"
            },
            {
                "text": " /^[-\\+\\-]?\\d+$/g\"\"\"\n\n\ndef make_regex(t):\n    \"\"\"\n    Return an appropriate raw regexp string using an input type and t\n    \"\"\"\n\n    if t == bool:\n        return \"([true"
            },
            {
                "text": "\n[^,]*([+-]?[0-9]{1,2}(\\,?[0-9]{3})?)\n[^,]*([+-]?[0-9]{1,2}$)\n[^,"
            },
            {
                "text": " \\d*[.][0-9]+(-\\d*[.][0-9]+)?\nHere is the current code generating:\n1[]_[a-zA-Z0-9]\\d*(?:[.,]\\d+)*\\d+"
            },
            {
                "text": "  [-+]?\\d+,?\\d{3}\n\nWrite a regular expression that takes a number with two digits, followed by a comma and then two more digits, to generate a new list of ten numbers.\nAnswer:  [0-9]{2},["
            },
            {
                "text": " (\\d)-(,\\d)\n4. Create a RegEx that matches a string with at least one hyphen only if there is a preceding character that is not a hyphen.\nSolution: (^[^-]*)-(?!-{1})\n5."
            },
            {
                "text": "\n^[+]?(([-+])([0-9]*)\\1?)?\n^[+]?[-][0-9]*[+]?$\n^[+]?[-][0-9]*[-]([+]["
            },
            {
                "text": " \\d+,\\d+,?\n- \"1\" is match, \"\\d+\" is not match.\n- \"1223423234\" is match, \"\\d+\" is not match.\n\nI got the regular expressions for the following types:\na) Decimal with"
            }
        ]
    },
    {
        "expression": "^([0-9]{1}[\\d]{0,2}(\\,[\\d]{3})*(\\,[\\d]{0,2})?|[0-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "raw_prompt": "Match any number , no characters, no empty sets, and accept zero.",
        "refined_prompt": "Match any number, no characters, no empty sets, and accept zero.\nMatch examples:\n- \"0001\"\n- \"12345\"\n- \"40788018763604681545698910422212,34\"\nNon-match examples:\n- \"abcd\"\n- \"012a\"",
        "matches": [
            "0001",
            "12345",
            "40788018763604681545698910422212,34",
            "42689385200849809755330582721781144829205057324808464028908786274273318912310097677616558,70",
            ",3",
            "1,216,432,875,905,931,623,929,895,798,254,709,838,662,247,206,516,505,574,696,717,557,656,303,882,805,757,224,244,831,166,562,850,598,763,101,655,292,582,154,709,355,719,515,070,34",
            ",38",
            "8,968,414,863,829,387,382,471,702,187,988,301,942,492,870,806,960,954,112,512,899,630,005,476,770,846,414,117,887,634,485,631,248,825,984,670,921,905,328,917,486,402,989,044,306,810,678,714,146,813,356,358,080,950,687,035,149,000,184,091,427,151,200,710,201,944,148,886,",
            "0,6",
            "34492196568546429699783700098399274057759926155063955616357586",
            ",47",
            "0,",
            "36,277,102,064,107,505,723,144,954,604,279,170,828,096,209,664,401,591,137,835,190,315,452,381,609,617,779,785,702,386,673,771,786,709,251,912,374,594,651,308,664,996,087,755,570,640,212,276,396,937,625,392,675,084,357,751,690,225,425,536,246,577,154,613,001,100,112,845,821,856,858,884,179,813,521,083,945,617,085,305,645,131,464,354,120,481,206,862,083,526,453"
        ],
        "non_matches": [
            "abcd",
            "012a",
            "2345tgr",
            "qwefd,",
            ",",
            ".0",
            "frer4",
            "24q5reg",
            "gre455",
            "4254ger",
            "544qsrg",
            "ewrg4"
        ],
        "id": 1952,
        "output": [
            {
                "text": " ^[^a-z]\"\n\n#2: Accept any numbers, no characters, any empty sets and accept zero sets.\nExample: \"012345678\"\nExpected Value: ^[a-z]{"
            },
            {
                "text": " (^\\d{4}-\\d{2}-\\d{2})|(^\\d{9}$)\n- \"abc3\"Generate a RegEx for this description.\nAnswer: ("
            },
            {
                "text": " [0-9a-z0-9 ]+\n\n2) The following text is a description of a picture. The camera in the picture takes four photos per second and the resulting images are 640 x 480 pixels wide. There"
            },
            {
                "text": " ^(?:\\d+|[\\w]+),(?:\\d+|[\\w]+),(?:\\d+|[\\w]+),(?:\\d+|[\\w]+),(?:\\"
            },
            {
                "text": "\n(\\d+,?\\d+),(\\d+.?\\d+),(\\d+.?\\d+)\n\nExample 2\n\nA:\n\nHere's how I would write it without regex.\nFirst step in"
            },
            {
                "text": " (0+,1+)(\\w+)\n\nExercise 3:\nAdd this extra regular expression to the previous exercise for special characters.\nAnswer: (0+,1+)([^\\w\\d]+)\n\n"
            },
            {
                "text": " a) Non-match, b) Match, c) Non-match\nIn conclusion, regular expressions are like the key that unlocks the complex world of pattern matching and data extraction. By understanding their syntax and functionalities, you will be"
            },
            {
                "text": "\n[1-9][0-9]*\n\nExercise 2:\nDescribe the difference between.NET and R.Studio's.R editor environments.\nAnswer:\n.NET environments are an open-source programming"
            },
            {
                "text": ".*1(.{4}).* \n- \"abcd,1234,d1234d1232,1234\"\n\nA:\n\nYou can't use the replace method with that regex (re"
            },
            {
                "text": " This exercise requires understanding that a RegEx should match any number, no characters in between, and no spaces in between.\n\nExercise 2: Pattern Matches with Backreferences\nWrite a Python function that accepts a string and uses"
            }
        ]
    },
    {
        "expression": "^(0\\.|([1-9]([0-9]+)?)\\.){3}(0|([1-9]([0-9]+)?)){1}$",
        "raw_prompt": "A simple regex to check a version information string of the style 1.0.0.0",
        "refined_prompt": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"",
        "matches": [
            "1.2.3.4",
            "0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355",
            "7.0.0.0",
            "995924130561360496409174388082680333348602416467836347516621830555269281187.2.9877577759646252897.495760733932004220082873",
            "9.179844495258302487837838329116084107717508700209186543832911986755634680834.1.75430881527114332685881980603299534395097469403509625456909876331457104",
            "7.6.6.4",
            "0.5.9.0",
            "0.4.0.0",
            "0.0.0.0",
            "0.5.0.0",
            "9.0.29760475541206794.143293204651548567230402531615022910662571834234626316192222832522929977270673151170272416352631",
            "2.7.7552197900952889753215401484317738423240913655378.1",
            "1.288825352608777973492105303713854541535998647957282682556885422638815395962209382975693286590299361.8.12662037900806967035976172763024819"
        ],
        "non_matches": [
            "1.2.3",
            "01.02.03.04",
            "1.2.3.4Beta",
            "IP",
            "767%",
            "$45678",
            "#3",
            "#..3",
            "4321fre",
            "3221",
            "+0987",
            "-9876"
        ],
        "id": 1954,
        "output": [
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n-"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n-"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n-"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n#"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n-"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            }
        ]
    },
    {
        "expression": "^((\\$?\\-?)|(\\-?\\$?))([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)?(\\.[0-9]*)?$",
        "raw_prompt": "Matches any number which includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal. It matches an unlimited number of decimal places. It does NOT reject an empty string passed to it. Credit goes to Al Kahler for posting the original expression from http://regxlib.com/REDetails.aspx?regexp_id=70 along with a fix for the decimal place.",
        "refined_prompt": "Matches any number that includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal. It matches an unlimited number of decimal places. It does NOT reject an empty string passed to it.\nMatch examples:\n- \"$.01\"\n- \"1,234.003\"\n- \"834223.1\"\nNon-match examples:\n- \".0,001\"\n- \"1,1.01\"",
        "matches": [
            "$.01",
            "1,234.003",
            "834223.1",
            "$0.01",
            "-$1.50",
            "$-50.123",
            "-$",
            "-0273029570338466083286457372911786177840950583862934245824010450870644223390123245579908924648197",
            "-$.3067063708136872591910189758727404130332985037814788725757472547497565776311194954917340568420",
            ".1058811057045379312110561820513963569300635",
            "-.76759900764831304306812620915030773068324572487491765701323774747463097534525803524921112887",
            "7,302,955,223,790,475,685,735,996,849,256,475,841,878,936,591,138,852,716,067,736,231,199,391,752,461,993,664,629,935,490,839,000,641,648,155,013,574,550,888,320,458,192,885,360,257,622,616,628,945,010,272,325,547,371,650,069,938,891,936,203,116,185,631,223,055,525,021,701,419,062,059,151,318,094,805,431,020,717,491,304,805,540,282,245,993,584,217,288,856,078,181,417,965,378,343,516,916.01349963332043700515008401",
            "-0,038,711,341,463,101,097,008,278,992,529,305,562,998,437,304,958,389,551,410,980,657,269,263,800,628,696,566,548,260,964,048,379,166,131,933,314,473,728,274,583,088,051,732,472,045,723,266,738,984,860,670,684,565,180,280,873,448,172,351,151,844,828,834,282,654,205,203,751,810,911,691,359,335,804,210,954,779,497,063,483,384,039,668,030,490,550,116,800,932,556,122,309,515.10592"
        ],
        "non_matches": [
            ".0,001",
            "1,1.01",
            "1E",
            "5$",
            "+98765",
            "&^%",
            "uytfy7",
            "money",
            "(*&",
            "ten",
            "$$$$",
            "&^%^&*("
        ],
        "id": 1956,
        "output": [
            {
                "text": " \\d*(\\.\\d{,2})?\n```python\nimport re\n"
            },
            {
                "text": "\n\nimport re\n\nx = \"123,124,125.124\"\nregex"
            },
            {
                "text": " \n- (.\\d{1,3})(?:,\\d{3})*"
            },
            {
                "text": "\n[0-9]+(\\.[0-9]{1,2})?\n"
            },
            {
                "text": " \\d?\\d(,\\d{3})*(\\.\\d+)\n\n"
            },
            {
                "text": " Match any number that includes digits, the optional commas, and decimal periods. No dots, leading"
            },
            {
                "text": " (?<!\\d)((0|[1-9][0-9]*"
            },
            {
                "text": " ^([[:alnum:]]+)|((([[:digit:]]|[.,"
            },
            {
                "text": " ^[\\d,]*\\.(\\d[\\d.,]*)?$\n"
            },
            {
                "text": " (.+?)(\\,\\.+)?\n\n\n# Chapter: The use of Python Str"
            }
        ]
    },
    {
        "expression": "^[A-Z]\\d{2}(\\.\\d){0,1}$",
        "raw_prompt": "This expression matches ICD-10 code",
        "refined_prompt": "Matches International Classification of Diseases (ICD-10) codes\nMatch examples:\n- \"Z99.9\"\n- \"Z99\"\n- \"G82\"\nNon-match examples:\n- \"Z999\"\n- \"Z99.\"",
        "matches": [
            "Z99.9",
            "Z99",
            "G82",
            "D05",
            "J05",
            "Y16",
            "M08.0",
            "V52.4",
            "H67.3",
            "F44",
            "I01.4",
            "I29",
            "Z97.0"
        ],
        "non_matches": [
            "Z999",
            "Z99.",
            "99",
            "wffe",
            "0.0",
            "-12",
            "098765",
            "z37f",
            "0987eh",
            "hefj",
            "8328823",
            "82"
        ],
        "id": 1958,
        "output": [
            {
                "text": " Non-match examples: \"Z999\" and \"Z99.\"Generate a RegEx for this description. \"Z99.\" matches the 'Z' character after '9', and after a period. \n\n4. Write a list comprehension to take a list of strings representing numbers and"
            },
            {
                "text": " \"(\\d{3})\\.(\\d{4})\"\n\n\n\n\nPossible section:\n\nArts--Criticism--Criticism and properties and attributes\n\nWhat is criticism?\n\nHave you ever looked at a painting, a sculpture, a photograph, or"
            },
            {
                "text": " \"?[0-9\\.\\,\\)]*[1-9]\\.)?[A-Za-z]?[A-Za-z0-9]?$\"\n\nExercise 4:\nMatch examples:\n- \"ILQ5-"
            },
            {
                "text": " The RegEx should be \"(?<category>[A-B])(?<digit>[0-9])(?<name>[Ss]pecific)?$\"\n\n3. Matching email addresses\nMatch examples:\n- \"john.doe@gmail.com\""
            },
            {
                "text": " The RegEx for this description should be \"(Z|C)99.*\".\n\nExercise 3:\nCreate a list of common error messages for incorrect input in `splitlines`.\nAnswer: These may include issues such as invalid delimiter characters, issues with line breaks, or invalid"
            },
            {
                "text": " \"Z99([^\\.]*)\\.\" Generate a RegEx for this description.\n\n2. Extract the date field from the following text: \"My birthday is on March 13, 1990.\" Extract the year using Python's RegEx library.\nSolution:\nimport re\n\n"
            },
            {
                "text": " \n- Matches only a few examples of ICD-10 codes.\n- Does not allow for any additional spaces, hyphens, or periods in the ICD-10 code.\n- Does not allow the use of special characters or numbers in the ICD-10 code.\n"
            },
            {
                "text": " \"^Z\\\\s+[1-9][0-9][0-9]\\\\.[0-9]\\\\.[0-9]\\\\.[0-9]$\"\n\n\n\nQuestion 3: Mike wants to buy a new laptop that costs $800. He saved"
            },
            {
                "text": " (explanation of how to match \"Z99.9\"'s)\n\nExercise 2: Identify the Common Names\nMatch examples:\n- \"A5.1\"\n- \"A00.9\"\n- \"A07.0\"\nIdentify common names"
            },
            {
                "text": " \nnon-match example: (?:Z[9])??, non-match example: (?:Z[9]\\.){1,2}$\n\nExercise 2: Identifying Outliers\nMatch examples:\n- 1000\n- 2000\n- 3000\nNon"
            }
        ]
    },
    {
        "expression": "(((0*[1-9]|[12][0-9]|3[01])([-./])(0*[13578]|10|12)([-./])(\\d{4}))|((0*[1-9]|[12][0-9]|30)([-./])(0*[469]|11)([-./])(\\d{4}))|((0*[1-9]|1[0-9]|2[0-8])([-./])(02|2)([-./])(\\d{4}))|((29)(\\.|-|\\/)(02|2)([-./])([02468][048]00))|((29)([-./])(02|2)([-./])([13579][26]00))|((29)([-./])(02|2)([-./])([0-9][0-9][0][48]))|((29)([-./])(02|2)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02|2)([-./])([0-9][0-9][13579][26])))",
        "raw_prompt": "Date in DD/MM/YYYY or D/M/YYYY format.",
        "refined_prompt": "Date in DD/MM/YYYY or D/M/YYYY format.\nMatch examples:\n- \"01/06/2008\"\n- \"1/1/2008\"\n- \"29.2/9200\"\nNon-match examples:\n- \"32/13/2008\"\n- \"00/00/2005\"",
        "matches": [
            "01/06/2008",
            "1/1/2008",
            "29.2/9200",
            "29/02.9960",
            "29/02.5224",
            "29.2/6572",
            "29-02.3600",
            "29-2/1200",
            "26-11/8662",
            "29-2-4808",
            "10-02/9483",
            "29/02.5004",
            "29-2-2808"
        ],
        "non_matches": [
            "32/13/2008",
            "00/00/2005",
            "date",
            "4567890",
            "29/028800",
            "2902.6004",
            "29027596",
            "229.032-34043",
            "#4",
            "5%",
            "2/2/2",
            "12/12"
        ],
        "id": 1960,
        "output": [
            {
                "text": " The regex might look like this: [[:digit:]]{2}.[[:digit:]]{2}/[[:digit:]]{2} \n\nExercise 4: Given the"
            },
            {
                "text": " Use the regular expression \"\\d{1,2}/\\d{1,2}/\\d{4}|\\d{2}\\d/\\d{6}\"\n\nL"
            },
            {
                "text": " [0-9]/[0-9]-[0-9]\nHint: You can replace a zero with the dot as well.\n\nI hope that this post has helped you build"
            },
            {
                "text": "\n\nimport re\nfrom bs4 import BeautifulSoup\n\n# Example 1: Simple Search for Date\ndef search_date(html, target):\n    matches = re.findall"
            },
            {
                "text": " (\\d{1,2})/(\\d{1,2})/(\\d{4})\n\n3. \nGenerate a RegEx for this description.\nMatch examples:\n"
            },
            {
                "text": "\n\n\"\"\"\nimport re\n\npattern = '^([0-9]+)/([0-9]+)/([0-9]{4})$or^([0-9]+)/(["
            },
            {
                "text": " (\\d{4})/(\\d{2})/(\\d{2}) or \\d{2}/((\\d\\d)/(\\d\\d)) or \\d{4}"
            },
            {
                "text": " The RegEx would be ^[0-9]{1,2}\\.[0-9]{1,2}\\.[1,2][0-9]{4}$ | ^["
            },
            {
                "text": "\n(?:(?P<day>\\d.\\d)/\\d/\\d| \\d./\\d\\d)\n(?:(?P<month>\\d.\\"
            },
            {
                "text": " A RegEx that can be used to generate the string \"A string that has exactly 10 digits, at most 5 spaces, beginning with a single 0. If the string also includes a space, the space should"
            }
        ]
    },
    {
        "expression": "(?!\\b(xx|yy)\\b)\\b[\\w]+\\b",
        "raw_prompt": "Matches any word except these from alternation (xx|yy|...). Works in JavaScript",
        "refined_prompt": "Matches any word except with xx and yy\nMatch examples:\n- \"x\"\n- \"xxx\"\n- \"xxyy\"\nNon-match examples:\n- \"xx\"\n- \"yy\"",
        "matches": [
            "x",
            "xxx",
            "xxyy",
            "yyx",
            "cV7CqH8YbQzVmGtOUMAUCcvoo4L2a9LDa2s7gDpYe7R0",
            "m2u_PUgF0q6e",
            "82PMz44ru39p9cnb9SnQw5HG5bZ35Gt2ri9TpPi3HDC8ZNmkWthvDWK0HI4_ov2FEHzQPu41vU7lnFAEpYE1O3",
            "BkAO9UbVNf4z9PpAW3WrqWSlBOVXzgBgurHEtmbl79",
            "qn6RhW1N7ZzYmct1miCsSNY_XOnIZPK3dIdqzU",
            "sciLUelHqtk1Fe7k4SYjEZu0iSBsaIMrri_IPrb0m6YwHNzCpnpte7zud2_6D",
            "pbGk6Rgwlj0ZzPcoGaGcvCjZvs5tcJ3kHDfk3FSB9",
            "l1hi5XLa",
            "atRsmHuwtEJ1gFVePGg38O_"
        ],
        "non_matches": [
            "xx",
            "yy",
            "--",
            "#",
            "@",
            "!",
            "()",
            "&&&",
            "???",
            "[]",
            "./",
            "''"
        ],
        "id": 1962,
        "output": [
            {
                "text": " \"^[a-zA-Z0-9]([0-9a-zA-Z])+[\" ]+[0-9a-zA-Z]{3,}$\"\n\n3.  Create a RegEx pattern to match an email address.\nAnswer: \"^[a-"
            },
            {
                "text": " - [abc|tcp|gig]{2,}\nQuestion 6: Match any number less than 15 with xx. \nAnswer: [0-9]\nQuestion 7: Match any number greater than 15 with yy. \nAnswer: [19-99]\nQuestion 8: Match any number in between 0"
            },
            {
                "text": "\n[^a-zA-Z]\n\nExercise 5: Write a function that takes a string and a list of substrings and replaces each occurrence of each sub-string on text only, not in the surrounding space. Use list comprehension to return a list of the new string with the original string.\nExample:\ndef"
            },
            {
                "text": " ^(?!xx)(?!yy)([aeiou]|[[:punct:]]|^[b-df-hj-mnp-tv-z])([a-z]|\\.|)([a-z]{2,})$\n-\"xxyzz\"Match this word.\n"
            },
            {
                "text": " \n(?:(o)(a|[pqrstvwxyz])?)+\n#\n\n\n\nTitle: Exploring Math, Problem Solving, and Logical Reasoning through Patterns and Fractions: The Fascinating World of Math\n\nIntroduction:\nWelcome, curious minds, to the captivating realm"
            },
            {
                "text": "\n\ndef regEx(pattern, value): \n    return pattern.replace('xx',\"[^xx]\") + '.' + value \n\n\npattern = regEx('ab[d]','d') \nresult = re.sub(pattern,'xx', 'abddc xcd') \t\t# 'xx"
            },
            {
                "text": " \n[a-z]{0,3}([a-z]\\1*){0,1}\n\nExercise 2: Split this string of people in order. \n\"John|Lisa|Bob|Sally|John|Michael\"\nAnswer: \nList with names and same names. John,"
            },
            {
                "text": " Match any word except with xx and yy. Match examples: \"x\", \"xxx\", \"xxyy\"; Non-match examples: \"xx\", \"yy\"\n\n\n\n\nWelcome to the world of economics and systems! In this section, we are going to learn about the different economic systems known to exist, namely command,"
            },
            {
                "text": " \"(?i)(?!x.*)(?i)(?!xx.*)(?i)(?!yy.*)\"\n- \"xxxy\"Generate a RegEx for this description. \nAnswer: \"(?i)(?!xx.*)(?i)(?!yy.*)(?i)(?:(?i)?x(?:(?!"
            },
            {
                "text": " \\w{1,2}(\\w\\d)\\w{0,1}\n\n```python\nimport re\npattern = r'\\w{1,2}(\\w\\d)\\w{0,1}'\nword = 'xxyyyy'\nmatches = re.findall(pattern,"
            }
        ]
    },
    {
        "expression": "^100$|^100.00$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "raw_prompt": "Allows percent values from 0 to 100 without the % sign. Can be used with up to 2 decimal places or without any. Also works in ASP.NET regular expression validator control.",
        "refined_prompt": "Allows percent values from 0 to 100 without the % sign. Can be used with up to 2 decimal places or without any.\nMatch examples:\n- \"0\"\n- \"0.00\"\n- \"50.25\"\nNon-match examples:\n- \"100.01\"\n- \"-1\"",
        "matches": [
            "0",
            "0.00",
            "50.25",
            "100",
            "100.00",
            "100700",
            "14",
            "5.43",
            "55",
            "98",
            "33.3",
            "78",
            "12"
        ],
        "non_matches": [
            "100.01",
            "-1",
            "5.005",
            "%12",
            "#3",
            "12/12",
            "(32)",
            "number",
            "823",
            "0000",
            "5535",
            "0005"
        ],
        "id": 1964,
        "output": [
            {
                "text": " (\\\\d)-?(0)?\\\\.?(\\\\d)\". Matching only positive values.\n\n``` python\nimport re\n\nstring = \"My phone number is 1234567890\"\n\npattern = r"
            },
            {
                "text": "\n- Regex 1: 0.\n- Regex 2: (0|[1-9]) \\.\n- Regex 3: [1-9] \\. [1-9]\n- Regex 4: 0"
            },
            {
                "text": " (.01)?((-1)|[0-9]+|[1-9])\\.00+\n\nExercise 3: \nMatch example: \"The total cost is $12.50\". Generate a RegEx for this"
            },
            {
                "text": " Match examples\n\n5. Write a RegEx that will replace all non-alphanumeric characters with an empty space. Match examples: \"Hello, World! This is a Sentence.\" Don't want an empty space before the first word"
            },
            {
                "text": " \"-?0?[0-9]{0,2}\"\n\n3. Write a RegEx that selects all the alphanumeric characters (letters, numbers, and underscores) from the string \"Example-text-123\".\n"
            },
            {
                "text": " \"0+1.00|-1\"\n3. Write a regex that matches any string containing both uppercase and lowercase letters.\nMatch examples:\n- \"AbCDE\"\n- \"abcDE\"\n-"
            },
            {
                "text": " /(^0.0$|^0.1$|^0.2$|^0.3$|^0.4$|^0.5$|^0.6$|^0.7$"
            },
            {
                "text": ".{0,11}\n\n3. Match a url, where it ends with.com or.net or.org or \nnon-match examples:\n- \"http://apple.com\"\n- \"http://google"
            },
            {
                "text": "^0+(([0-9]|[1-9][0-9]|1[0-9]0|20)%)$\n- \"100.01\"Does not match this RegEx. Why?\n"
            },
            {
                "text": " \\d{0,1}\\.\\d{0,3}\n\n2. Use the following regular expression to match a phone number in the format (123) 456-7890: (\\(\\d{3}\\)"
            }
        ]
    },
    {
        "expression": "^[1-9]{1}$|^[1-9]{1}[0-9]{1}$|^[1-3]{1}[0-6]{1}[0-5]{1}$|^365$",
        "raw_prompt": "This expression allows you to select 1-365 as a numeric value for the days of the year. Must be between 1 and 365 and must be numeric",
        "refined_prompt": "This expression allows you to select 1-365 as a numeric value for the days of the year. Must be between 1 and 365 and must be numeric\nMatch examples:\n- \"25\"\n- \"363\"\n- \"110\"\nNon-match examples:\n- \"2.5\"\n- \"0\"",
        "matches": [
            "25",
            "363",
            "110",
            "1",
            "2",
            "3",
            "12",
            "17",
            "34",
            "90",
            "45",
            "86",
            "200"
        ],
        "non_matches": [
            "2.5",
            "0",
            "400",
            "-1",
            "2345678",
            "5432",
            "4000",
            "503",
            "4378",
            "#",
            "4321",
            "3456"
        ],
        "id": 1972,
        "output": [
            {
                "text": " the word \"the\".\n\n4.\n\"\"\"\n\nimport random\nwords = ['Apple','Mango','Strawberry']\nprint(\"\\n\\nRandomly selecting a word: \",\" \".join(random."
            },
            {
                "text": " Use the range and dollar sign characters in the expression. Example: \"0$((1-0)..$((1-0)+364))\"\n\nSolution:\n```python\n# Exercise 2 Solution\nimport re\n"
            },
            {
                "text": "\n1-365|[1-9][0-8]\n1-365$\n(1)|(2)|(3),(4)|(5)|(6)|(7)|(8)|(9)|("
            },
            {
                "text": " [0-9]\\.(0|[1-9]\\d{0,2})\\b\n\nA:\n\nFirst, it does what you're saying it will. It will output \"0\" every time"
            },
            {
                "text": "\n[a-zA-Z][0-9]{3,}\n\nExercise 2:\n- What are the main factors to consider when selecting a day of the week range for your search string?\n\nAnswer"
            },
            {
                "text": "\n/\n(0?)? (\\d*[ -]\\d*)+? ([\\d,]*)/\n\"\"\"\n\ndef parse_dates(dates):\n    \"\"\"\n    Accepts a comma-separ"
            },
            {
                "text": " Generate a RegEx for capturing one or more instances of a space, followed by one or more digits.\n\nQuestion 2:\nWhat is a RegEx and how is it used in the context of \"dates and times\"?\n"
            },
            {
                "text": " ^[0-1][0-9]\\d$\n\nWhat would be an expression to match a date/time? For this question, think about a combination of date and time expressions. You should also consider what would happen"
            },
            {
                "text": " You should put a dollar sign in front of the expression. The example would be \"^\\$2.5\".\n\nExercise 2: Creating a Custom String Validation Function\nCreate a custom validation function for the email field of"
            },
            {
                "text": " \\d\\d$\n\nAnswer 3. Match examples: \"23-1\"\nNon-match examples: \"2.5\"\n\nAnswer 4. The goal of this exercise is to generate a RegEx that allows you"
            }
        ]
    },
    {
        "expression": "^(\\d{3}-\\d{2}-\\d{4})|(\\d{3}\\d{2}\\d{4})$",
        "raw_prompt": "This will accept SSN in the form of 123-45-6789 OR 123456789.",
        "refined_prompt": "This will accept SSN in the form of 123-45-6789 OR 123456789.\nMatch examples:\n- \"123-45-6789\"\n- \"123456789\"\n- \"456-63-6666\"\nNon-match examples:\n- \"123-45-459a\"\n- \"222-2-2222\"",
        "matches": [
            "123-45-6789",
            "123456789",
            "456-63-6666",
            "923083942",
            "085-11-9100",
            "816-97-6034",
            "387611789",
            "551-19-2895",
            "533-79-9002",
            "360423595",
            "501-58-9755",
            "331241871",
            "766-53-6084"
        ],
        "non_matches": [
            "123-45-459a",
            "222-2-2222",
            "222-222222",
            "34564321",
            "SSN",
            "#3",
            "33223",
            "123456780-90312",
            "22-214",
            "33232",
            "######",
            "number"
        ],
        "id": 1974,
        "output": [
            {
                "text": " The description for a phone number should be accepted if it is in the form of a sequence of 3 digits, followed by 9 digits, followed by another 3 digits, then 9 digits,"
            },
            {
                "text": " (?<![0-9])\\d{3}-\\d{2}-\\d{4}\n\nExercise 5: Password Checker\n-"
            },
            {
                "text": " r'(\\d{3}-\\d{2}-\\d{4})'\n- What type of character should not be in the phone number?\nAnswer:"
            },
            {
                "text": " \\d{1,2}\\d{2,3}\\d{4}\\-\\d{1,3}-\\d{3}|\\d{1,"
            },
            {
                "text": " \"(\\\\d{3})\\\\-(\\\\d{2})\\\\-(\\\\d{4})([a-z]{3}\\\\d{4})\"\nHere"
            },
            {
                "text": " \nvar regex = new RegExp(\"^(\\\\d{3}-\\\\d{2}-\\\\d{4})|(\\\\d{3}\\\\d"
            },
            {
                "text": " (\\d{3}[-\\s]\\d{3}[-\\s]\\d{4})\n\n3. \nWrite a Python function that"
            },
            {
                "text": "\n$(document).ready(function(){\n    var ssnPattern = [\"123-45-6789\",\"123456789\",\"456-63-6666\"];\n"
            },
            {
                "text": " \\d{3}-\\d{2}-\\d{4}|\\d{4}|(\\d{2})-(\\d{3})-(\\"
            },
            {
                "text": " ^(?=(?:[^\\\\d\\\\-\\\\s]*[^-\\\\d\\\\-\\\\s])*$)[^-\\\\d\\\\-\\\\s]"
            }
        ]
    },
    {
        "expression": "^(\\d?)*(\\.\\d{1}|\\.\\d{2})?$",
        "raw_prompt": "Expression to validate currency formatted numbers without the currency symbol",
        "refined_prompt": "Expression to validate currency formatted numbers without the currency symbol\nMatch examples:\n- \"153\"\n- \"33.48\"\n- \"786.1\"\nNon-match examples:\n- \"-123\"\n- \"8524.258\"",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33",
            "06",
            "7975651.66",
            "73942979684534684690883561.9",
            "488427258694004.49",
            "2452",
            "3600.79",
            "77863.52",
            "6792110598881568231296106.97",
            "0971771572"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45",
            "number",
            "2323w",
            "89238nfdd",
            "#3",
            "734872.s",
            "-237",
            "3as784fs",
            "42jhfe",
            "jh####dsjh"
        ],
        "id": 1977,
        "output": [
            {
                "text": " \"^\\d+,\\d\\.\\d*$|^\\d+$\"\n\n2. Regex to find email addresses from a list of text\n\nAssume we have a text and a list of email addresses formatted as below. Create the regex that finds email addresses from that text"
            },
            {
                "text": " ([0-9]*[0-9]?.[0-9]*|[0-9]*[0-9]?.[0-9]?[-][0-9]*)\nIn this section, we have covered the basics of Python RegEx and how it"
            },
            {
                "text": " \"^[0-9.]+$\"\n\n\n\nQuestion 7: The perimeter of a square is 48 centimeters. What is the length of its diagonal?\n\nSolution:\nThe perimeter of a square is given by the formula P = 4s (where s is the length of a side"
            },
            {
                "text": " #([0-9]+\\.[0-9]+)([a-zA-Z]+)\n\nPython Exercise 3 - Currency Conversion\n\nGiven a list of currency codes, format them as currency values using the following rules:\n- The base currency must be USD (for example, \""
            },
            {
                "text": " A positive lookahead for the position of a number is needed (?=\\d+)\n\n```\nimport re\nc_currency_format = re.compile(r\"(?=\\d+)([$\u20ac\u00a3\u00a5]?[.][0-9]+)(\\"
            },
            {
                "text": " \\d+\\.\\d+\n\n5. Write a RegEx to validate a US phone number in the format (XXX) XXX-XXXX.\nAnswer: (\\(\\d{3}\\)\\s? \\d{3}-\\d{4}\n\n\n\nQuestion 8:"
            },
            {
                "text": " You can use the following regular expression to validate currency formatted numbers: r\"^\\d*(?:\\.[\\d]+)+$\"\n\nLecture Note: 8.1.1 Understanding Functions and Modules\n\nContents:\n- Definition of a function\n- How to"
            },
            {
                "text": " ^(-?\\d+\\.\\d+)$ \n\nExercise 2: \nCreate a RegEx that accepts email addresses, with either the gmail, hotmail, or gov.gov domains. \nAnswer: ^[a-z0-9._%+-]+"
            },
            {
                "text": "\nTo validate currency formatted numbers without the currency symbol \"USD\"\n>>> RegExp(r\"(-?\\d+\\.?(\\d+)?)USD\")\n<_sre.SRE_Match object at 0x102360b60>\n\nTo validate currency formatted numbers using locale"
            },
            {
                "text": " [\"([0-9]|1[0-9]|2[0-3]|3[0-1])(,)(0|[1-9]|5[0-9]|6[0-9])\", (\\d+)(.\\d+)?"
            }
        ]
    },
    {
        "expression": "(\\d{3}\\-\\d{2}\\-\\d{4})",
        "raw_prompt": "pattern match for U.S. social security number",
        "refined_prompt": "pattern match for U.S. social security number\nMatch examples:\n- \"111-22-3333\"\n- \"667-98-7198\"\n- \"331-67-7759\"\nNon-match examples:\n- \"11-222-3333\"\n- \"1111-22-333\"",
        "matches": [
            "111-22-3333",
            "667-98-7198",
            "331-67-7759",
            "836-90-2480",
            "516-26-0805",
            "228-14-4300",
            "629-76-7319",
            "595-42-2584",
            "943-54-5478",
            "550-45-1481",
            "052-74-9223",
            "610-37-5051",
            "082-67-0567"
        ],
        "non_matches": [
            "11-222-3333",
            "1111-22-333",
            "123456",
            "1212-3284",
            "234",
            "#234",
            "12/12",
            "0987654567898765345678",
            "74.23",
            "number",
            "00000",
            "43677634"
        ],
        "id": 1978,
        "output": [
            {
                "text": " \n\n[a-zA-Z0-9]{3}-[a-zA-Z0-9]{3}-[a-zA-Z0-9]{3}-[a-"
            },
            {
                "text": " The regular expression would be \"[1-9][0-9][0-9-]{3}-\". The RegEx matches a four-digit number that consists of a first and last digit that are within the range of 1"
            },
            {
                "text": " [^0-9]\\-[0-9]{1,5}-?[0-9]{4}$\nExercise 3: \nCreate a set of ten different URLs and test to see if you"
            },
            {
                "text": " /^\\d{3}-\\d{2}-\\d{4}$/\n- \"333-333-3325\"Generate a RegEx for this description. \nAnswer: /\\d{"
            },
            {
                "text": " The pattern will use the uppercase (^), lowercase (.), and dash (\"-\") character sequence to capture non-match examples: \"^\\d{3}-?\\d{2}-?\\d{"
            },
            {
                "text": " \n\n^\\d{3}-?\\d{2}-?\\d{4}$\n\n3. Regular Expression for the following pattern\nMatch examples:\n- \"abc123\"\n- \"p"
            },
            {
                "text": " \n^(\\\\d{3}-\\\\d{2}-\\\\d{4})$|^\\\\d{6}$\nExercise 2: What is the purpose of quantifiers and how do they help make"
            },
            {
                "text": " [2-7][1-9][0-9][1-9][1-9][0-9][1-9]|[1-2][0-8][0-9][0-9] "
            },
            {
                "text": " \"^[0-9]{3}-[0-9]{3}-[0-9]{4}$\". This RegEx will only match a string where the first three numbers are between 0 and 9. The"
            },
            {
                "text": " \n[A-z0-9-.] \n\n**Example two:***\nMatch examples:\n- \"987-654-5309\"\n- \"999-9999-9999\"\n- \"111-22"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]{5})([a-zA-Z0-9-]{3,12})",
        "raw_prompt": "Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphen; string length is eight characters minimum, 17 characters maximum",
        "refined_prompt": "Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphens; string length is eight characters minimum, 17 characters maximum\nMatch examples:\n- \"ABCDE123abc-123AB\"\n- \"pFNulUVyRFPTu\"\n- \"MuRqTOCiErV9\"\nNon-match examples:\n- \"1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678\"\n- \"3434rfes\"",
        "matches": [
            "ABCDE123abc-123AB",
            "pFNulUVyRFPTu",
            "MuRqTOCiErV9",
            "StqMcwgMambwy",
            "BziWc3EP94L4aA",
            "aucVZkOFyMFeI",
            "OzXSB0TO5MPDJ0WCr",
            "iLqZO-LqnRwtWsTR",
            "gJAkd736b",
            "CjCuwrYSf8x",
            "ZCNqIftYFfYe8Qe",
            "QtrpbMd7WeJ",
            "LxzbzIzo78G"
        ],
        "non_matches": [
            "1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678",
            "3434rfes",
            "/edcsfewfred3443efwds/",
            "434",
            "number",
            "uehfgdc",
            "KLKJHGF",
            "t4refdsc",
            "5%",
            "vvf",
            "###",
            "----"
        ],
        "id": 1986,
        "output": [
            {
                "text": " ["
            },
            {
                "text": " \""
            },
            {
                "text": " a"
            },
            {
                "text": " ^"
            },
            {
                "text": " \\"
            },
            {
                "text": " ["
            },
            {
                "text": " ^"
            },
            {
                "text": " (("
            },
            {
                "text": "."
            },
            {
                "text": "\n"
            }
        ]
    },
    {
        "expression": "^([^S]|S[^E]|SE[^P]).*",
        "raw_prompt": "Matches everything except lines that begin with SEP.\nNow I just need to figure out how to exclude a string that appears in the middle of a line.",
        "refined_prompt": "Matches everything except lines that begin with SEP.\nMatch examples:\n- \"SEk001\"\n- \"TAK002\"\n- \"SE7ge+f9FQ7x ]]9ZEl]Pg\"@}j DTw%oyyAz\"\nNon-match examples:\n- \"SEP001\"\n- \"SEP002\"",
        "matches": [
            "SEk001",
            "TAK002",
            "SE7ge+f9FQ7x ]]9ZEl]Pg\"@}j DTw%oyyAz",
            "`x>2rC.?XLCh_f0F/Gmks9f?43'TY7yBM+X\"%+K%",
            "Sgk5: +1.OxaU3Lu0nPEG}a[_4V7I\"m}?Ti= Pm78zQn20% r>Qa5Mh4=_KO",
            "1c<9iVc3cv'dMnh6(US<:xV(:]Qk-.l^>wKs6SL p-Bq@1aJ@~5zX=r^2~x4$@f2~ilh6Qaq~?goT1Y}s",
            "SElB=",
            "SEHgqx+YX\"/g_Vgr[$e7dZT=G9c5XDAFdj",
            "S]hg0.duW^rKLOK$A1S",
            "SE~-*2$2Me8~3l,K_!;o<6",
            "SPY!a}",
            "SE&D]d3_VQiuL*Vh\\|!uPcQTvwFTek",
            "qd.<CY\\x/a Ii1oyP"
        ],
        "non_matches": [
            "SEP001",
            "SEP002",
            "SEP",
            "SEPrfvf",
            "SEP349349",
            "SEP....",
            "SEP098764edfvbnm",
            "SEP[[[[[[",
            "SEP----",
            "SEP?wefe/",
            "SEP983378hd",
            "SEP4598459549854rdsxjdmwef"
        ],
        "id": 2008,
        "output": [
            {
                "text": " ^[a-z\\d\\-_]+$ and^[a-z\\d\\-_\\s]+$\n\nExercise 2: \nCreate a"
            },
            {
                "text": "\n\n^SEP00\\d+$\nExplanation:\n- ^SEP00\\d+$ matches only when the string begins with \"SEP"
            },
            {
                "text": " /([\"'])[^\\\\s]*/i\nMatch all single-character groups, except for letters\n[1234567890][^\\s]*/"
            },
            {
                "text": " [^SEP]++(?=SEPEND)+\nThe string in the question is an example sentence that contains some lines and some lines that are not a proper"
            },
            {
                "text": " The regular expression would be [^<A-Z0-9\\-\\.]\n\n\n# The Use of Python Numbers for Computational Chemist\n\n## Introduction"
            },
            {
                "text": " SEk([a-z0-9]{0,5}\\s*(\\S*)\\s*)*@\n\nExercise 2:  Match the following"
            },
            {
                "text": " You can try like this \"^(?=^)(?![\\w\\s])[\\w\\s\\.\\'\\\"\\!@#\\$%^\\"
            },
            {
                "text": " \"^([^\\\\]+)(\\\\1)$\"\n3. Create a regular expression to match all capital letters and spaces between words.\nExample answer: \"\\b"
            },
            {
                "text": " [A-Z][a-zA-Z0-9]*\n        [ \\t]*\n        SEK001|SEK003|SEK"
            },
            {
                "text": " ^[^\\s]+(?:SEP)?([a-z]+)?$\n\n``` python\nregex = r\"^[^\\s]"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]{1}|2[0-3]{1}):([0-5]{1}[0-9]{1})$",
        "raw_prompt": "This expression will validate if a string represents a time in 24 hour format.\nThe expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead.",
        "refined_prompt": "This expression will validate if a string represents a time in 24 hour format.\r\nThe expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead.\nMatch examples:\n- \"1:59\"\n- \"01:59\"\n- \"23:59\"\nNon-match examples:\n- \"24:00\"\n- \"01:60\"",
        "matches": [
            "1:59",
            "01:59",
            "23:59",
            "22:19",
            "06:04",
            "23:01",
            "17:58",
            "6:20",
            "21:38",
            "21:22",
            "11:19",
            "23:12",
            "0:05"
        ],
        "non_matches": [
            "24:00",
            "01:60",
            "01:234",
            "time",
            "12",
            "60:60",
            "532132",
            "3",
            "0987654",
            "645332",
            "74773",
            "----"
        ],
        "id": 2011,
        "output": [
            {
                "text": "\n/(24:[0-9]|0[0-9]|1[0-9])\\.?[0-9"
            },
            {
                "text": " /^([0-24]\\.)(\\d{2}):(\\d{2})$/n\nCheck time limit:"
            },
            {
                "text": " ^(0|[1-9]\\d)?(?P<hour>\\d):(?P<minute>.?)"
            },
            {
                "text": " \n([0-9]{1,2}):([0-9]{2})(am|pm)\n\""
            },
            {
                "text": " (:.\\D{2}:\\D{2}) \n\nExercise 5: Create two RegEx expressions that accept time"
            },
            {
                "text": " \n(\\d{1,2}) : (\\d{2})\\s?(o)\\s?minutes\n\n"
            },
            {
                "text": " \n[12] [:][0][9] \n3:00 \n\nIf the time should be a double ("
            },
            {
                "text": " 0\\s(\\d\\d):(\\d\\d)\n\nThe correct answer is : 0\\\\s(\\d\\d):"
            },
            {
                "text": " ^[0-9\\-:\\.]+[0-9]$\n- \"02:59\"Generate a RegEx for"
            },
            {
                "text": " ^(\\d{1,2})/(\\d{2}):(\\d{2})$\nDescription: The expression requires that"
            }
        ]
    },
    {
        "expression": "([.])([a-z,1-9]{3,4})(\\/)",
        "raw_prompt": "Returns the TLD from a URL.",
        "refined_prompt": "Returns the Top-level domain from a URL.\nMatch examples:\n- \".com/\"\n- \".net/\"\n- \".biz/\"\nNon-match examples:\n- \".co.uk/\"\n- \".org.uk/\"",
        "matches": [
            ".com/",
            ".net/",
            ".biz/",
            ".123/",
            ".mobi/",
            ".w4e/",
            ".m1w/",
            ".,gn/",
            ".falm/",
            ".e41/",
            ".z97/",
            ".1w8i/",
            ".sjz5/"
        ],
        "non_matches": [
            ".co.uk/",
            ".org.uk/",
            "website",
            "./",
            "4343443",
            "www.",
            "@gmail.com",
            "3245675432",
            "efffqe",
            "https://",
            "https://efdcs",
            "https://efdcs.erdsww"
        ],
        "id": 2013,
        "output": [
            {
                "text": " ([^/ ]+)\n\n**Exercise 2**\nWrite a regular expression to extract the first word of a sentence (excluding punctuation and whitespace).\n\n**Answer**\n\\b(\\w+)\n\n**Exercise 3**\nWrite a regular expression to check if a string contains a valid email address"
            },
            {
                "text": " [A-Za-z]+\\.[A-Za-z]+\n\n### Exercise 3:\n\nWrite a function that takes a URL parameter and generates a domain name following best practices:\n- Make use of the `.NET` instead of `.com`.\n- Include an `\"www.\""
            },
            {
                "text": " A regular expression can be generated that reads in a list of domain names and excludes \"co.uk\" in the description.\n\nUse case 2 - Analyze Twitter Feeds:\nIn this use case, you'll have to analyze a social media feed to identify and classify tweets.\n\nStep 1: Define your"
            },
            {
                "text": ".co.uk, org.uk,.net,.biz\n\"\"\"\nimport re\n\npatterns = [r\"\\.co\\.uk\",\"\\.org.uk\"]\n\nfor pattern in patterns: \n# For each URL, we test if the string on the 'pattern' variable exists\n    if"
            },
            {
                "text": "\n``` python\nimport re\nurl = \".com/\"\noutput = re.search('.*[a-z](.*?)($|.com)',url)\n\nif output is not None:\n  domain = output.group(1)\n  subdomain = re.sub('["
            },
            {
                "text": " \\\\.net$\n\n4. The Regex can be created.\n\nExercise 2: Replace all occurrences of the word \"hello\" with \"hi\" in the following text.\ntext = \"Hello, my name is John.\"\nAnswer: \"Hi, my name is John.\"\n\n5. The"
            },
            {
                "text": ".com|net|biz\nPart 4: Use Cases\n\nUse Case 1: Online Shopping\n\nJenny just opened an online store for her handcrafted jewelry. She wants to list prices for her items, and needs a way to easily identify the thousands place value. She uses Python regex to format the numbers:\n"
            },
            {
                "text": " (\\.[^.\\/]+)\n\nExercise 5:\nMatch any number of parentheses with any digit character [a-zA-Z0-9].\nAnswer: ()\n\nReal-World Use Case 1: \n\nLinda is a journalist writing an article about a company that is changing the"
            },
            {
                "text": " (.com|.net|.biz)\\.uk(\\/)?[a-z0-9]{2,5}\n\n2. Given an image URL, extract the main image filename using regex.\nMatch examples:\n- \"image/sample.jpg\"\n- \"image//sample.png\""
            },
            {
                "text": " \"^[^.]+/$\"\n\n```python\nimport re\n\ndef domain_match(domain):\n  pattern = \"^[^.]+\\\\.\"+domain[len(domain)-1:]\n  return bool(re.match(pattern, \"google.com\"))\n```\n"
            }
        ]
    },
    {
        "expression": "^\\$?\\d{1,2}\\,\\d{3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?(\\.(\\d{2}))$",
        "raw_prompt": "Needed to verify a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions. If you want to make the decimal side optional, add a question mark before the final $ in each expression.",
        "refined_prompt": "Verifies a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions.\nMatch examples:\n- \"1.99\"\n- \"111,111.99\"\n- \"11,111,111.99\"\nNon-match examples:\n- \"1.999\"\n- \"1111\"",
        "matches": [
            "1.99",
            "111,111.99",
            "11,111,111.99",
            "12,999.00",
            "1,243,434.04",
            "132,423.32",
            "233,985.43",
            "12,444.67",
            "23,323,342.67",
            "45,344,777.12",
            "55,555,555.55",
            "67,432,333.09",
            "1,000.44"
        ],
        "non_matches": [
            "1.999",
            "1111",
            "1111111",
            "11.9",
            "332",
            "34345432.0",
            "1,000",
            "1,23435543.",
            ".0",
            "452334",
            "09876556789876545678976545678956789",
            "323"
        ],
        "id": 2014,
        "output": [
            {
                "text": " \"1,111\"\n**5.** You need to match the following currency values to the corresponding currency, then separate them with a comma and a space.\n    "
            },
            {
                "text": " 1.999([\\.0-9]*[3]|[0-9]*[.]3|[1-9]*[.]3)\n"
            },
            {
                "text": "  \\d{1,3}(?:\\.\\d{0,3})? (?<!\\d) \n\n2. You are writing"
            },
            {
                "text": " \"^[123456789]{8}[,]\\d{3}[,]\\d{3}\\.\\d{3}$\""
            },
            {
                "text": " To allow only the numbers in the range 1.99 to 11.99, we can use the following regular expression: 1\\.99|1\\d{1,99"
            },
            {
                "text": " ^(?=.{1,100}$)(?!^.*\\,.*$)(,\\d{1,3}(?:,\\d{3"
            },
            {
                "text": "\n- /[1-9]\\d{0,3}(?:,\\d{3})?/g\nThis will match any number of 1 to"
            },
            {
                "text": " [1-9]\\d\\d(,\\d{3})?)[1-9]\\d([12]\\d\\d?)?[3"
            },
            {
                "text": "\n^\\d+\\.\\d{1,2},\\d{4}$\n\n(Note: The last decimal must have at least two digits after the"
            },
            {
                "text": " ^[1-9][0-9]|1[9][0-9]|1[0-9][0-9]$\n\n\n### Section"
            }
        ]
    },
    {
        "expression": "(1)?-?\\(?\\s*([0-9]{3})\\s*\\)?\\s*-?([0-9]{3})\\s*-?\\s*([0-9]{4})\\s*",
        "raw_prompt": "A very simple regex to parse 10-digit US phone numbers. Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.\nThis expression DOES allow for reserved area codes (001,etc) which are not typically in use.",
        "refined_prompt": "Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.\r\nThis expression DOES allow for reserved area codes (001,etc) which are not typically in use.\nMatch examples:\n- \"(123)456-7890\"\n- \"1234567890\"\n- \"123 456 7890\"\nNon-match examples:\n- \"123456789\"\n- \"(1234)567890\"",
        "matches": [
            "(123)456-7890",
            "1234567890",
            "123 456 7890",
            "123-456-7890",
            "(123)4567890",
            "123-4567890",
            "433-432-4853",
            "442-875-1290",
            "111-463-0093",
            "1129-444-3333",
            "748-567-8888",
            "242-543-4498",
            "777-555-4444"
        ],
        "non_matches": [
            "123456789",
            "(1234)567890",
            "(12-3)4567890",
            "98765",
            "342",
            "#4",
            "67%",
            "12/12",
            "34321`2",
            "1,000",
            "000",
            "34321"
        ],
        "id": 2023,
        "output": [
            {
                "text": "\n\n"
            },
            {
                "text": " (\\"
            },
            {
                "text": " (\\"
            },
            {
                "text": " (^"
            },
            {
                "text": " (.{"
            },
            {
                "text": " [^"
            },
            {
                "text": " \"(\\"
            },
            {
                "text": " ((["
            },
            {
                "text": " \\d"
            },
            {
                "text": " \\(["
            }
        ]
    },
    {
        "expression": "^(\\+48\\s+)?\\d{3}(\\s*|\\-)\\d{3}(\\s*|\\-)\\d{3}$",
        "raw_prompt": "Supported: +48 prefix (optional); separating elements with hyphen or spaces",
        "refined_prompt": "Matches elements separated with hyphen or spaces\nMatch examples:\n- \"+48 500-080-100\"\n- \"500080100\"\n- \"500 080 100\"\nNon-match examples:\n- \"+47 100-100-100\"\n- \"1000-100-100\"",
        "matches": [
            "+48 500-080-100",
            "500080100",
            "500 080 100",
            "015-362-374",
            "775-037-965",
            "807\u2028071\u200a\u2029329",
            "949-920\u2002625",
            "733-210-865",
            "451-027-089",
            "917-009-884",
            "372-376-709",
            "373-961-022",
            "462-751-532"
        ],
        "non_matches": [
            "+47 100-100-100",
            "1000-100-100",
            "1000000000",
            "9876567894",
            "333",
            "39203",
            "2321`",
            "$45",
            "45%",
            "0987654567",
            "0987654567-45342",
            "2384"
        ],
        "id": 2025,
        "output": [
            {
                "text": " \"000+[\\\\w\\\\s]+0+0+0+\"\nExercise 3: Rewrite the following phrases to use a custom delimiter/format.\n- \"1234 56 7890\"\n- \"11-22-33"
            },
            {
                "text": " \n\\+[0-9][0-9][0-9-]{0,1}\\s([0-9]{3})-([0-9]{3})-([0-9]{4})\\s"
            },
            {
                "text": " (\\d{1,3}\\s*-\\s*\\d{1,3}\\s*-\\s*\\d{1,3}) \n- Use this regex to verify a user\u2019s email address.\n``"
            },
            {
                "text": " +[3-9][0-9]{2}-[0-9][0-9]{3}-[0-9][0-9]{3}-[0-9][0-9]{3}$\n\n"
            },
            {
                "text": " \"[+][4][0-9][0-9][0-9]|[0-9] [0-9] [0-9]\"\n\n-Question 5:\nGiven a list of strings, replace all instances of \"USD"
            },
            {
                "text": " \\+([0]?\\d{1,5}|2[0-3]\\d|[0-9]\\d|10[0-2])\\s\\d{3}\\s\\d{3}\\-\\"
            },
            {
                "text": "\n/^[0-9]{3}[ ](-)?[0-9]{3}[ -]?[0-9]{3}[ -]?[0-9]{3}$/\n\nEx"
            },
            {
                "text": " 1-9[0-9]|9\n1-9 is a range or a list of numbers that can be matched from 0 to 9 \n[0-9] is a range that can be matched 0 to 9\nThe pipe sign,"
            },
            {
                "text": " [0-9][0-9]{3}-[0-9][0-9]{2}-\\d|\\d{3}-\\d{2}-\\d \nExample of using the generated RegEx:"
            },
            {
                "text": " \"\\d+[,\\s\\-\\(].*\\d+\"\n\nExercise 5: Extract the first name and last name of a string, separated by spaces\nInput string: \"John Doe Smith\"\nAnswer: [\"John\","
            }
        ]
    },
    {
        "expression": "\\b[1-9]\\d{3}\\ +[A-Z]{2}\\b",
        "raw_prompt": "Dutch postal codes are ranged from \"1000 AA\" to \"9999 ZZ\".",
        "refined_prompt": "Matches dutch postal codes are ranged from \"1000 AA\" to \"9999 ZZ\".\nMatch examples:\n- \"\"1484 EE\"\"\n- \"4996                                                      ZT\"\n- \"3617                                                   JP\"\nNon-match examples:\n- \"\"1484EE\"\"\n- \"\"0111 AB\"\"",
        "matches": [
            "\"1484 EE\"",
            "4996                                                      ZT",
            "3617                                                   JP",
            "3190                                                IR",
            "9377                                                                          PM",
            "5360                                                        PE",
            "5562                                NB",
            "3797                                                                           TW",
            "1074                                                                   WO",
            "8090                                            IR",
            "9581             ON",
            "6357                 SW",
            "3714                                HX"
        ],
        "non_matches": [
            "\"1484EE\"",
            "\"0111 AB\"",
            "\"1484 ee\"",
            "\"1234 ABC\"",
            "9876567",
            "9876567",
            "#3",
            "45%",
            "pkf943",
            "()",
            "-3402",
            "111!"
        ],
        "id": 2031,
        "output": [
            {
                "text": " 1484E\n\n```python\nnon_match_examples = [\"\", \"1484\", \"0001\"]\n\ndef test_match_example(code, code_regex):\n    if code_"
            },
            {
                "text": " ([\\d]{2} [\\d]{2} | [A-Z]{2}[A-Z])\n- \"\"0001 AB\"\"Generate a RegEx for this description.\nAnswer:"
            },
            {
                "text": " \n[a-z]{3}.[0-9][A-Z].{2}[0-9]\n\nExercise 3:\nGive an example of how you would use a regex that matches"
            },
            {
                "text": " r'^[0-9]{7}(?:\\.[0-9]{3})?(?:[a-z]{2}(?:\\s+[0-9]{3})"
            },
            {
                "text": " (([a-zA-Z]*)(\\s?\\d+))*\n- \"\"1484\"\"\n- \"\"4556\"\"generate a RegEx for this description. \nAnswer: ([a"
            },
            {
                "text": " \"[0-5][1-9]                                               [A-Z]\"\n- \"0011231231212312121212123121212121212312121212121212121231212"
            },
            {
                "text": " \".*[00-19].*$\"\nExplanation: * matches any character including newline\n\nQ:\n\nCalculate distances in cartesian plane with pandas\n\nI want to calculate the"
            },
            {
                "text": "\n^\\d{4}[A-Z]{1{9}}[0-9]{3}[ZT]$\n\n5. Exercise:\nCreate a regex that matches all IP addresses up"
            },
            {
                "text": " A digit followed by a letter.\n3. Use the same rules as before, but for email addresses.\nAnswer:\n\nstring.sub(/.*?,/,\"\")  \n\nstring.replace(\"@\","
            },
            {
                "text": " *1-0*1\n\nQ:\n\nhow to split strings with a space in python\n\nI'm quite stuck trying to split these strings with a space in python. It's for a project and i wrote"
            }
        ]
    },
    {
        "expression": "<[^>]*>",
        "raw_prompt": "This Regex Will Remove All Html Tags And Return Simple Plain Text .\nFor Example In C#.NET :\nRegex.Replace(Html, \"<[^>]*>\", string.Empty);",
        "refined_prompt": "Captures html tags (< >)\nMatch examples:\n- \"<p> Hello Ali Delshad </p>\"\n- \"<^*Copm9W4.08uAL6f{mmVLpyk&^~_SCFpg-\\V#myG\\4Bj77>\"\n- \"<QX`3>\"\nNon-match examples:\n- \"Hello Ali Delshad\"\n- \"<\"",
        "matches": [
            "<p> Hello Ali Delshad </p>",
            "<^*Copm9W4.08uAL6f{mmVLpyk&^~_SCFpg-\\V#myG\\4Bj77>",
            "<QX`3>",
            "<uI4iXP\"'LUic/-v;d|6EE`!B7Yo&4Ga,@]thSN)G{RmDUQp4gQ|y)H~V:tc=^J2{Ek*}FR9n,EXR@l1M*:#D'oB9v.F/Cc~s.X$X>",
            "<<,ZT0u<bm+B$;{J^2rKrk+#mm*zt@q{r,$Wu('[3:;2\\/iBaGlU)(t.)RzE3Bq)Sp1r>",
            "<ZI$sqc<5M. ]hNX<XrifE<!L(/Tjf^^>",
            "<kl&/DBZ=Fhzs u:r9e#IyMc<tbE:ndj$>",
            "< t2wyW,0#\\Qhf9%NhQj]PPiXn%i0zU7|gi=CK\\yhGgV>",
            "<Pc(-qc`5x%6')dA1L60+4raE>",
            "<+PxNy.]6,rln($I;1vyNawrzmd(-c%'T$Zn!;)( u!)@P+ajv<'t>",
            "<[\\=&\\l+|h.t<rW%,L4&vG>",
            "<}CJEDRfr nm0=tB\\*R1Q (Exa<>",
            "<6Od#AKt+8@@Q>"
        ],
        "non_matches": [
            "Hello Ali Delshad",
            "<",
            "<ecf",
            "wefcds>",
            "234fre?",
            "fewederer",
            "</.",
            "<<<<<",
            ">>krceds>",
            ">ceds>",
            "rkvced...",
            ",,<,"
        ],
        "id": 2040,
        "output": [
            {
                "text": " <[a-zA-Z 0-9]*>\n\n2. Replace all email addresses in the"
            },
            {
                "text": " http://regexr.com/5p9t2\nEx 2 answer:\n\nNon-match examples"
            },
            {
                "text": " <p><em>Hello Ali Delshad</em></p>\n\n3. Use the `isspace"
            },
            {
                "text": " [A-Za-z0-9]([A-Za-z0-9\\-]*"
            },
            {
                "text": ".*<\"(.*)\">.*<\"(.*)\">.*<\"(.*)\">.*<"
            },
            {
                "text": " (?<![-a-zA-z0-9_.&:;=+,@!%]"
            },
            {
                "text": " ^.*,.*,.*|.*<p>|.*<.*>\n\n- \"Hello Ali Dels"
            },
            {
                "text": " /^\\w\\s./\n- \"<\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": " \"<^*&^+\"\n    \"\"\"\n    def regex(desc):\n        return re.compile"
            },
            {
                "text": "\n\\d+(\\.\\d+)+\n\"\"\"\n```\n\n2. Create a Python code block that"
            }
        ]
    },
    {
        "expression": "[\\u0600-\\u06FF]",
        "raw_prompt": "This Regex chceck an input string for persian unicode character\nNote that it not work in javascript\nFor Example In C#.NET:\nRegex.IsMatch(Text, \"[\\u0600-\\u06FF]\");",
        "refined_prompt": "checks strings for Persian Unicode character\nMatch examples:\n- \"\u0633\u0644\u0627\u0645\"\n- \"hello \u0639\u0644\u06cc\"\n- \"Hi 2 \u0633\u0644\u0627\u0645\"\nNon-match examples:\n- \"Hello\"\n- \"Ali\"",
        "matches": [
            "\u0633\u0644\u0627\u0645",
            "hello \u0639\u0644\u06cc",
            "Hi 2 \u0633\u0644\u0627\u0645",
            "\u06c0",
            "\u060f",
            "\u06b9",
            "\u062e",
            "\u06ab",
            "\u0620",
            "\u066e",
            "\u06f4",
            "\u068a",
            "\u06ac"
        ],
        "non_matches": [
            "Hello",
            "Ali",
            "123",
            "#",
            "@",
            "!",
            "()",
            "^",
            "<>",
            "//",
            "{}",
            "&"
        ],
        "id": 2041,
        "output": [
            {
                "text": " \n\n```python\nimport sys\nimport re\n\ndef customise_regex(pattern):\n  if pattern==\"Re\":\n    pattern=\"(Re(.))\";\n  elif pattern==\"Fa\":\n    pattern=\"(Fa(.))\";"
            },
            {
                "text": " This statement may not be true. In the example \"Hi 2 \u0633\u0644\u0627\u0645\", \"2\" is not surrounded by a preceding or following delimiter.\"\n\nExercise 2:\nCreate a REGEX to match only the strings that contain at least one consonant in the first and"
            },
            {
                "text": " \"Hello (?!\\S)\"; \"Ali (?!\\S)\", \"??????????????????.\"\n\n5. Write a Python generator function that yields all possible matches given a pattern and a string.\n- Idea: Use recursion to create nested patterns and generate all possible matches. "
            },
            {
                "text": " https://regex101.com/r/eA1vF7/1/\n\n- Write a Python code that matches strings that start with an uppercase letter, and end with a digit. \nAnswer: r'[A-Z][0-9]*"
            },
            {
                "text": " A RegEx for this description could be `\\\\p{P}+`.\n\n3. Write a Python function to validate Email addresses using a regular expression for non-standard email formats, such as those using '@' and '.' or including hyphens, and return a Boolean.\n"
            },
            {
                "text": " \n[A-Za-z0-9_:] (for non-alphanumeric and underscore) \n\nScenario 3:\nYou wanted to identify the most commonly occurring first names in your dataset. Write a Python program to do that.\nIdea: Collect names"
            },
            {
                "text": "\nWe can use a non-greedy quantifier like \\d* to match one or zero digits in sequences.\n\nExercise 2:\nWrite a Python program to search a specific string for keywords and print out the number of times they occur using RegEx. \nAnswer:\n"
            },
            {
                "text": " [^0-9A-Za-z ]\n```python\nimport re\n\n# Regular Expression for Persian Unicode character Matching\nregex = re.compile(\"[^0-9A-Za-z ]\")\n\nprint(regex.find"
            },
            {
                "text": " \"^[a-z](?=[a-z]*[A-Z])\"\n2. Write a Python function that uses regular expressions to count all \"Hello\" occurrences from the string.\nAnswer: \"\\\\bHello\\\\b\\\\s*\\\\b.\"\n3."
            },
            {
                "text": " Ali*a-zA-Z+$\n\n5. Match all strings starting with the letters d, a, i, and m\nExercise:\nWrite a regular expression pattern that matches the following strings: \n- \"David\"\n- \"Adam\"\n- \"I"
            }
        ]
    },
    {
        "expression": "^(?=.*\\d)(?=.*[a-z])([a-z0-9]{8,25})$",
        "raw_prompt": "Password matching expression. Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter and 1 numeric digit. Upper case, space and punctuation marks are not allowed.",
        "refined_prompt": "Password matching expression. Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter and 1 numeric digit. Upper case, space and punctuation marks are not allowed.\nMatch examples:\n- \"aaaaaaa1\"\n- \"abcdefghijklmnoprqstu1234\"\n- \"1234567a\"\nNon-match examples:\n- \"aaaaaaA1\"\n- \"0123456789kB\"",
        "matches": [
            "aaaaaaa1",
            "abcdefghijklmnoprqstu1234",
            "1234567a",
            "kaon4bdb8u04pp3",
            "o5hc1c79fg4vsmcdvx9mab",
            "d6rixrp1u52",
            "mpbzuhpfe3zuvocwyr8z9f5c",
            "6vu7ju9myqypoai9eqsyomae9",
            "6bagbgfblkv912vsa1xp32d0",
            "adeg4763w557eo0ctn",
            "kwtd710f",
            "cmii3neikqw",
            "h88zwgxs"
        ],
        "non_matches": [
            "aaaaaaA1",
            "0123456789kB",
            "1234567890abcde123456 A%.",
            "32rfe34",
            "kjhgfcvbnm",
            "password",
            "PASSWORD",
            "rfesw34rdd,",
            "cseoi37;;;",
            "32!f'ef4",
            "4rfe87&",
            "#3"
        ],
        "id": 2049,
        "output": [
            {
                "text": " ^(?=.*[a-z])(?"
            },
            {
                "text": " [a-zA-Z0-9]*"
            },
            {
                "text": " \n[a-i]{6,7}"
            },
            {
                "text": "\n^\\w{8,25}$(?"
            },
            {
                "text": "^(?=.*\\d)(?=.*\\"
            },
            {
                "text": "^.*\\d$|^.*[a-z"
            },
            {
                "text": " The password should be at least 8 characters, no more then"
            },
            {
                "text": " ^(?=.*\\d)(?=.*["
            },
            {
                "text": "\n\\d*(A-Z\\d*)\\"
            },
            {
                "text": "\n^(?=.*[a-z])("
            }
        ]
    },
    {
        "expression": "^((([sS]|[nN])[a-hA-Hj-zJ-Z])|(([tT]|[oO])[abfglmqrvwABFGLMQRVW])|([hH][l-zL-Z])|([jJ][lmqrvwLMQRVW]))([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?$",
        "raw_prompt": "Matches standard 0- to 10-figure (non-tetrad) Ordnance Survey of Great Britain (OSGB) Grid References",
        "refined_prompt": "\nMatch examples:\n- \"SH\"\n- \"OF1234567890\"\n- \"NP1234\"\nNon-match examples:\n- \"SH123\"\n- \"SH12D\"",
        "matches": [
            "SH",
            "OF1234567890",
            "NP1234"
        ],
        "non_matches": [
            "SH123",
            "SH12D",
            "NI1234",
            "1234"
        ],
        "id": 2069,
        "output": [
            {
                "text": "\n- \"SH|OF|NP|ABC|DEF|GHI|JKL|MNO|PQR|STU|VWX|YZ\"\n- \"SH12|DEF|GHI|JKL|MNO|PQR|STU|VWX|YZ\"\n\nExercise"
            },
            {
                "text": " ^SH[a-z0-9\\-]*$\n\nExercise 2:\nWrite a Python function that takes in a string and returns a list of all the words that begin with a vowel, but are longer than 4 letters.\n\nSolution:\nimport re\n\ndef filter_vowel_words(string):\n"
            },
            {
                "text": " [0-9]\\d*[ATGC]{1}\n- \"CDL23\"Generate a RegEx for this description.\nAnswer: [0-9]\\d*[A-H]{4}\n- \"CDL1234\"Generate a RegEx for this description.\nAnswer: ["
            },
            {
                "text": " [SH, _]\n\n\n\nIn the fascinating world of Social Studies, one of the key topics is understanding the concepts and principles of Civics. Civics focuses on exploring the rights and responsibilities of citizens and how governments operate. While this subject may seem abstract and distant from the daily lives of middle school students, there are actually many connections to"
            },
            {
                "text": " [^SH+][^H][A-a][R-r][E-e]\n\nExercise 4: RegEx for a Password\nCreate a RegEx for a password as long as 15 characters, where the first eight characters are lowercase and the last five characters are uppercase, and must contain at least one digit and"
            },
            {
                "text": " (any combination of Uppercase, Lowercase, numbers, and special characters) [Sh:U][0-9][A-Z], [U][0-9]\\{11\\}\\]\n\n5. You have a list of emails that are formatted inconsistently like \"jane.doe@com\" or \"j"
            },
            {
                "text": " \"SH[A-W0-9]1[3-9][A-H0-9]1[3-9][A-H0-9]1[3-9][A-H0-9]1[3-9][A-H0-9]1.+\"\n\nExercise 4"
            },
            {
                "text": " _\n\nExercise 2: Writing a text message\nWrite a short text message using as many uppercase letters and numbers as you can.\nAnswer: _\n\nExercise 3: Writing a username \nCreate a unique username by including numbers and letters.\nAnswer: _\n\nExercise 4: Password Checker\nCreate a"
            },
            {
                "text": " [SH][0-9]{1}([KM]|G)$; The three options must be followed by the same digit. \n\n3. Write a Python program that prompts for a user input of a full name (first name, middle name, last name) and generates an instance of the Person class.\nAnswer:"
            },
            {
                "text": " \"SH[[^1234567890].]+(\\+\\d+)[^1234567890]*$\"\n\n\n\nAs a geologist, I often come across different mathematical concepts in my work. One important concept in math is mathematical inequalities. These inequalities help us compare different quantities and determine relationships between them. Today, I"
            }
        ]
    },
    {
        "expression": "(((0[123456789]|10|11|12)(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "raw_prompt": "Validates dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces. No special characters or letters allowed. MM values allowed are 01 thru 12. YYYY values allowed are 1900 - 2999.\nThis is an adaptation of Felipe Albacete's MM/YYYY regular expression.",
        "refined_prompt": "Validate dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces. No special characters or letters are allowed. MM values allowed are 01 through 12. YYYY values allowed are 1900 - 2999.\nMatch examples:\n- \"052000\"\n- \"122008\"\n- \"101972\"\nNon-match examples:\n- \"12/2003\"\n- \"131997\"",
        "matches": [
            "052000",
            "122008",
            "101972",
            "041903",
            "111970",
            "062175",
            "112644",
            "112725",
            "101907",
            "101938",
            "052708",
            "122167",
            "052818"
        ],
        "non_matches": [
            "12/2003",
            "131997",
            "51988",
            "111899",
            "04.2004",
            "10-1965",
            "8765",
            "4387654678",
            "929",
            "0000",
            "12/37723",
            "46737"
        ],
        "id": 2083,
        "output": [
            {
                "text": " -^\\\\d{6}-\\\\d{4}-\\\\d{2}"
            },
            {
                "text": " ^\\d{10}(-\\d{2})?$\n\n2. Write"
            },
            {
                "text": " This is going to be very broad. Check out this pattern [12345], [1534"
            },
            {
                "text": "\n(?i)([0-9]{4}[-/][1-"
            },
            {
                "text": " /^[0-2][0-9][0-9][0-9]["
            },
            {
                "text": " Allow all letters and no special characters or numbers or spaces are allowed for MM values only and Y"
            },
            {
                "text": " [0-9]{4}[0-9](0[1-9])"
            },
            {
                "text": " \n\"\\d{5}[1-9]\\d[0-9"
            },
            {
                "text": " Valid dates are: 052000 --> 052092 --> 019895 --> 019803 -->"
            },
            {
                "text": " MM/YYYY.\"\n5. Create a list from a given list of numbers that has"
            }
        ]
    },
    {
        "expression": "^\\#?[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$",
        "raw_prompt": "Matches valid 3 or 6 character hex codes used for HTML or CSS.",
        "refined_prompt": "Matches valid 3 or 6 character hex codes used for HTML or CSS.\nMatch examples:\n- \"fff\"\n- \"#990000\"\n- \"#cc3366\"\nNon-match examples:\n- \"#5555\"\n- \"#ZJK000\"",
        "matches": [
            "fff",
            "#990000",
            "#cc3366",
            "#AAAAAA",
            "F6a",
            "#e73",
            "#ae5A95",
            "49A14d",
            "#624",
            "#1fa",
            "B2F",
            "d2C647",
            "fbC"
        ],
        "non_matches": [
            "#5555",
            "#ZJK000",
            "CDCDCDCD",
            "4323",
            "2243",
            "thhjvefhjb",
            "2",
            "#2",
            "#0--3e0",
            "324234f",
            "8765rfgh",
            "7373"
        ],
        "id": 2086,
        "output": [
            {
                "text": " (#[0-9a-fA-F]{6}|[0-9A-Fa-f]{3})\n\n7.2.5 Comparing Escape Sequences for HTML and CSS\n\nIn HTML and CSS, escape sequences are used to"
            },
            {
                "text": " [1-9][A-I-M]{3,5}\nExercise 4:\n\nYou have a string containing several phone numbers in the format (XXX) XXX-XXXX. However, some of the numbers are supposed to be all digits, while others may be"
            },
            {
                "text": " \\b(\\d{1,3}|[0-9a-fA-F]{4})-([0-9a-fA-F]{1,3})\\b\n\"\"\"\nimport collections\nimport copy\nimport datetime\nimport"
            },
            {
                "text": " \"^([#a-fA-F0-9]{3}){3}\" (3 hex codes required)\n\nExercise 4:\nMatch each scenario with the appropriate color code.\n1. A bright sunny day\n2. Rainy day\n3."
            },
            {
                "text": "\nYou can use the following regex:\n^(?:#[a-f0-9]{2}|[0-9a-f]{3}){6}$\n\nThis regex will require exactly 6 hex codes, matching exactly those. Since you say"
            },
            {
                "text": " The RegEx for this description is /\\#(?:[0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/ to search for 6 or 3 hex codes in a pattern.\n4."
            },
            {
                "text": " \"\\#[0-9A-Fa-f]{6}$\" \n- #[0-9A-Fa-f]{3}(?:#[0-9A-Fa-f]{3})+\n\n\n\nHi there!"
            },
            {
                "text": " ^[a-f0-9]{3}$|^[0a-f0-9]{3,}$\n- Write a Python program to check if a provided input is a valid string representation of a hexadecimal number.\nAnswer: Check"
            },
            {
                "text": "\n/(^[a-fA-F0-9]{3}$)|#(\\d[a-fA-F0-9]{3})$/.match(desc)\n\n5. Write a RegEx that matches phone numbers in the format XXX"
            },
            {
                "text": " r\"([A-Fa-f0-9]{3})(?![0-9]{5})[A-Fa-f0-9]{3}(-[A-Fa-f0-9]{3}(-[A-Fa-"
            }
        ]
    },
    {
        "expression": "^(?=.{6,})(?=.*[0-9].*)(?=.*[a-z].*).*$",
        "raw_prompt": "Password of 6 symbols. Must containt at leats one non-captial letter and at least digit digit",
        "refined_prompt": "Matches password of 6 symbols. Must contain at least one non-capital letter and at least digit digit\nMatch examples:\n- \"abc123\"\n- \"()()a1\"\n- \"_ABCDa1\"\nNon-match examples:\n- \"abcdef\"\n- \"ab_12\"",
        "matches": [
            "abc123",
            "()()a1",
            "_ABCDa1",
            "ooC`yid uJy,e-bhy@`UTz8",
            "p4Ee)oy5|P*xA)i'cb:VbV\"E0p62|d,0Ce;%;2*vJ04't3daGd#Ej[*m",
            "@*BArfIfbpk%7tap<0V3zG8s@!I^X]y4=x",
            "Ap,'OZwL~K_l8'K:",
            "@iN'Es{<V'4/.nQP77`}*E0b:4o",
            "-Zu#H *Y$m?+UU\\`/XEV:]Izg.]`nUFCAHQ%4]PUM]ilW2nW{+:",
            "b -$qmBxqHA<9y%!Wg1u20LJLm=t_ ` nLUGu9SU^ka'AWK%|z<*8t6\"7sr+jDtl=$C5@a",
            "w %4SJ5:<+]Dom\\",
            "jg9Bb5k`|tVBY82WG!EGDoR\\+QLnUSzKe[!dMu[0j_)yL2ouF,.dkJ&KA&l&h+cvwUpNV[c[{rH'- J4_E@164*`5u;9_?",
            "F=}is=jXBAm56.sG7Nn!nOo _<5+l;:L$+E.!'K3uK'0p"
        ],
        "non_matches": [
            "abcdef",
            "ab_12",
            "ABC123",
            "324",
            "445",
            "ace",
            "#",
            "@",
            "!",
            "%",
            "$",
            "*"
        ],
        "id": 2087,
        "output": [
            {
                "text": " (no answer)\n4. Match a sequence of digits, followed by 3 zeros, followed by 2 periods.\nAnswer: ([0-9]{9}\\.\\.){2}\n5. Write a Python class called Reg"
            },
            {
                "text": " ^((?!.{4,})(?!.*(?=\\W)[0-9]).{4,})(?!.*(?=\\W)[A-z]).*$\n\n3. Write a method that takes a"
            },
            {
                "text": " The correct regex is \"(?i)(?!.*_)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]*\"\n\nHere's an example of"
            },
            {
                "text": " [A-Z] and [a-z]\n\n\n\nTitle: The Incredible World of Nutrition: Understanding Food Labels and Information\n\nIntroduction:\n\nHey there aspiring botanist! Today, we'll be diving into the"
            },
            {
                "text": " (?i)[^a-z0-9]a[^a-z0-9]e[^a-z0-9]g[^a-z0-9]h[^a-z0-"
            },
            {
                "text": " \"(^[a-zA-Z]?[A-Z]?)([a-zA-Z]?[0-9]?)+$\"\n\n2. How do you encode a string so that it is"
            },
            {
                "text": " /[a-zA-Z][a-zA-Z0-9]*/\n4.Write a python code that searches a list for a string (case-insensitive) and returns the index of the string. \n"
            },
            {
                "text": " Matches password of 6 symbols. Must contain at least one non-capital letter and at least digit digit character.\n\nThe chapter's goal is about creating a function that takes a string of symbols and validates it against a certain set of rules"
            },
            {
                "text": "\n[a-z]{1,3}[A-Za-z0-9]+\n- \\w{1,3} [a-zA-z0-9] \n\n3. Regex Pattern"
            },
            {
                "text": " ^[a-z]*|[A-Z][a-z]*|\\d+$\n\n2. Regex to Find IP address in a string.\n**Solution:**\n``` python\nimport re\n"
            }
        ]
    },
    {
        "expression": "((\\d{0}[0-9]|\\d{0}[1]\\d{0}[0-2])(\\:)\\d{0}[0-5]\\d{0}[0-9](\\:)\\d{0}[0-5]\\d{0}[0-9]\\s(AM|PM))",
        "raw_prompt": "Matches hours 0-12:minutes 0-59:seconds 0-59 AM|PM",
        "refined_prompt": "Matches hours 0-12:minutes 0-59:seconds 0-59 AM|PM\nMatch examples:\n- \"0:00:00 AM\"\n- \"10:50:55\u2003PM\"\n- \"11:59:59 PM\"\nNon-match examples:\n- \"1:00 AM\"\n- \"5:3:00 PM\"",
        "matches": [
            "0:00:00 AM",
            "10:50:55\u2003PM",
            "11:59:59 PM",
            "12:00:00 AM",
            "5:34:00 PM",
            "5:20:43\u2003AM",
            "12:29:18\tPM",
            "10:25:13\u2006PM",
            "7:56:45 PM",
            "11:52:45\u2001AM",
            "10:35:12 AM",
            "8:52:28\u2009PM",
            "0:18:13\u2004AM"
        ],
        "non_matches": [
            "1:00 AM",
            "5:3:00 PM",
            "5:34:00 Pm",
            "5:34:00 P",
            "noon",
            "1 o'clock",
            "43r5t6789",
            "$5789",
            "9876%",
            "34fedc",
            "fg56hj7",
            "43re"
        ],
        "id": 2090,
        "output": [
            {
                "text": " matches hours 0-12:minutes 0-59:seconds 0-59 AM\n2. Find all the matches. Return a string, for example:\n(\"8"
            },
            {
                "text": " (\\\\d:\\\\d:\\\\d)([|AM|PM])(\\\\d:\\\\d:\\\\d)$\n\n2. Write a RegEx"
            },
            {
                "text": " ^([01]\\d?).?(\\d)?(?:\\:\\d)?(?:[AM]\\d?)|(?:[AM]\\d?)\\."
            },
            {
                "text": " \"(([00]?[0-9])?[:][0-5][0-9]:([0-5][0-9])[:]["
            },
            {
                "text": " [A-P]M'S ([0-9:]|:)([0-9]|))' ([00][0-9]|1\n\n"
            },
            {
                "text": ".* (.*?) (AM|PM) (\\d\\d:\\d\\d:\\d\\d\\d), \\d\\d$\"\"\").format("
            },
            {
                "text": "\n\n[0-9]*:[0-9]*:[0-9]\"|\"0\"\n\nExercise 4:\nMatch days of the week"
            },
            {
                "text": "\nimport re\n\ndef getValidTime(pattern_string):\n    return ['0:00:00 AM'\n                if 'AM' in time.lower"
            },
            {
                "text": " \"^([2-12]?\\d[0-9]\\d)?(:[0-5]?\\d)?([0-9]\\d"
            },
            {
                "text": " Time string should end with either 'AM' or 'PM'\n\n\nExercise 3: \nWrite a program that prompts a user to type in a four-digit"
            }
        ]
    },
    {
        "expression": "^(([1-9]{1}[0-9]{0,5}([.]{1}[0-9]{0,2})?)|(([0]{1}))([.]{1}[0-9]{0,2})?)$",
        "raw_prompt": "This will allow your app to check currency during events such as key down\n(set to decimal(8,2) only)",
        "refined_prompt": "Matches currency with a decimal point. Does not require any places of decimal point\nMatch examples:\n- \"13\"\n- \"13.\"\n- \"13.1\"\nNon-match examples:\n- \"01\"\n- \".1\"",
        "matches": [
            "13",
            "13.",
            "13.1",
            "13.11",
            "0.",
            "0.1",
            "71",
            "49.",
            "450",
            "0.7",
            "1323.",
            "0.9",
            "7725"
        ],
        "non_matches": [
            "01",
            ".1",
            "0.011",
            "+987654",
            "$456789",
            "8765%",
            "#3",
            "erfvrt4g",
            "785645rf",
            "4gr",
            "45grfe",
            "money"
        ],
        "id": 2095,
        "output": [
            {
                "text": " non-matching number followed by a decimal point\n\n1) Match currency with a decimal point. Does not require any places of decimal point.\n2) \"123.45\"\n3) \"123.\"\n4) \"12.34\"\n5) \"125.7\"\n\n\n"
            },
            {
                "text": " ^[[:letter:]][[:digit:]]$\n\n8. What is a lookahead, and how is it used in regex?\nA lookahead is a subpattern that can be matched, but the submatches it does not currently match would not be included in the match result."
            },
            {
                "text": " The RegEx should not include the decimal point. Generate the RegEx for this description.\n\n3. Isolate a number that is not a decimal by ignoring surrounding decimal points:\nIsolate a number that is not a decimal by ignoring surrounding decimal points. Isolate a number that is not a"
            },
            {
                "text": " [^0-9.]+\n\nExercise 5.\nMatch currency with a decimal point.\nGenerate a RegEx for this description.\nAnswer:[^0-9().]*[0-9.]*[^0-9()]*\n\n\n\nMemoir:"
            },
            {
                "text": " (\\\\b[\\\\d\\\\.]+\\\\b)?\n\n3. Write an expression using a decimal separator that returns a string up to the decimal separator:\nGenerate a string up to the decimal separator. \nAnswer: (\\\\d+(\\\\.\\\\d+)?)\n"
            },
            {
                "text": " ([a-z]{1})\\.([0-9]*?)\n\n1. Is \"12.345\" an integer or floating-point number?\n[A] FloatingPoint\n[B] Integer\n[C] Unknown\n\n2. What is the matching portion of the"
            },
            {
                "text": " \n\\d\\.\\d\\d\n*Example 1*: To match any decimal number with two or more decimal places.\n*Example 2*: To match any decimal number with one or two decimal places, but only if it's not followed by a point or another number. \n\nExercise"
            },
            {
                "text": " r\"(?i)[0-9]\\1*\"\nTo sum up, you can use negative lookbehind and lookahead assertions along with a matching group to satisfy the following requirements:\n- To specify one character only:\n    match one character only \n    (?<=char1"
            },
            {
                "text": " https://regex101.com/r/nkJ1kZ/2\nUsing re.findall on both inputs to return the non matching ones.\nimport re\n\n# Currency with decimal points:\nc1 = [\"13\",\"131\",\"1310\",\"13.1\",\""
            },
            {
                "text": " ^(?=.0*\\d)\\d(.\\d+)?$\n- \"0.\"Generate a RegEx for this description.\nAnswer: ^[0][0-9]?\\d*\\.[0][0-9]?$\n\n2. Find"
            }
        ]
    },
    {
        "expression": "^[0-3]{1}[0-9]{1}[ ]{1}(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec){1}[ ]{1}[0-9]{2}$",
        "raw_prompt": "This will test to see if a date is formatted in the military style of 'dd MMM yy'",
        "refined_prompt": "This will test to see if a date is formatted in the military style of 'dd MMM yy'\nMatch examples:\n- \"12 DEC 08\"\n- \"03 jan 91\"\n- \"30 Mar 82\"\nNon-match examples:\n- \"41 DEC 08\"\n- \"03 jan 1991\"",
        "matches": [
            "12 DEC 08",
            "03 jan 91",
            "30 Mar 82",
            "05 jul 83",
            "01 Sep 62",
            "24 Nov 80",
            "16 Mar 81",
            "12 Nov 57",
            "36 OCT 13",
            "35 JUN 30",
            "11 aug 99",
            "38 sep 53",
            "38 sep 53"
        ],
        "non_matches": [
            "41 DEC 08",
            "03 jan 1991",
            "30 Mar '82",
            "pojhgf",
            "date",
            "january 26th",
            "jan 15 2003",
            "05 april 34",
            "12 may 2007",
            "987",
            "23 june 1999",
            "july 14"
        ],
        "id": 2103,
        "output": [
            {
                "text": " (\\d{1,2})\\s\\w{1}\\s(\\w{3}\\s\\d{4}\\s\\d{2})\n\n2. Given the string 'I was born on 12/01"
            },
            {
                "text": "\n```python\nreg = re.compile(r'^(\\d{2})\\s[a-zA-Z]{3}\\d{2}[a-zA-Z]{2}"
            },
            {
                "text": "\nimport re\n\n    test_data = \"Dec 8, 892 - Jan 9, 1187- Jan 8, 942\"\n    pattern = re.compile(r\"(?P<first_word>\\d"
            },
            {
                "text": " \"^(?P<day>\\d+) (?P<month>\\w+) (?P<year>[\\da-z]{2}, \\d{4})$\"\n\n#### Exercise 2\n\n"
            },
            {
                "text": " \\b((1[0-2]|0[1-9]|100) [0-9]{2})|(1[048]|[1-9]\\d|[12]\\d|"
            },
            {
                "text": " ^\\s*\\d{1,2}(\\s\\-)?[A-Z][a-z]+ \\d{2}\\s?[a-z]+$\n\n2. Use RegEx to extract all '"
            },
            {
                "text": " \\b(?:[1-9]?[0-9]?[0-9])[.][0-9][a-z] \\b\nExercise 3: You are creating a registration system for a service"
            },
            {
                "text": " \\b(?:jan?\\s?|feb|mar|apr|may|jul?|aug\\s?|sep|oct\\s?|nov?\\s?|dec\\s?|"
            },
            {
                "text": " (\\d{2})\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{2}\\s(\\w+),\\s(\\w+"
            },
            {
                "text": " Date regex is \\d+\\..+\n\nExercise 4: Write a Python function that will take a text and a regex pattern as input and will return the indices of the match on the input text. Test with:\nInput"
            }
        ]
    },
    {
        "expression": "^[-+]?(?:\\d+\\.?|\\.\\d)\\d*(?:[Ee][-+]?\\d+)?$",
        "raw_prompt": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating\npoint including in the exponential notation. Doesn't match the empty string.",
        "refined_prompt": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating\r\npoint including in the exponential notation. Doesn't match the empty string.\nMatch examples:\n- \"23\"\n- \"-17.e23\"\n- \"+.199E-19\"\nNon-match examples:\n- \"+.e2\"\n- \"23.17.5\"",
        "matches": [
            "23",
            "-17.e23",
            "+.199E-19",
            "10.",
            "10e10",
            ".26642713102143137365688967113831737504541833692190915849562517816327995085477954323691850e9236633",
            "-522468587367868823397071205956903949609749300561529539411050637217070.973037100898946241629789895786686328783478283686320509779043619399583643585767894302E-540757799870934129679968653442342823996235059099372961943109017344635981153252443",
            ".52332333497266709701503353970089530648484030407259371091675",
            "+02697312309419612043775",
            ".31155240966607792130348975e-25397714687738448160680418813504846749690127315865231134966296946266796989559445824860494769128183264",
            "-31587463390371081736585401192107872300589613485157844991288518433690756533566551883689734115109029343541",
            "5010704367465090358536489777377397907224499216196.803064965116337857600",
            "-3830549920235063882111235443023540000.7687114801433769361e-95"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0",
            "22e",
            "fdsa",
            "#3",
            "56%",
            "12/12",
            "2332ewds.",
            ".../efdzsd",
            "fer23refd",
            "r0wrfk"
        ],
        "id": 2116,
        "output": [
            {
                "text": " |^(\\\\d+)\\.(\\\\d+)(e)$|\n\nA:\n\nYou"
            },
            {
                "text": " (^\\-?[1-9]\\d*|0|.\\d*[1-9"
            },
            {
                "text": " (\\.10|\\.2)(\\.1|\\d)\n\nI'm trying to create a regular expression"
            },
            {
                "text": " \"^[+-]?[0-9]*[.][0-9]+([e+"
            },
            {
                "text": " (.+?[0-9]+)\n\nThe \"?\" is a trick to make the last part of"
            },
            {
                "text": " -?([^-]*)(?<![-+])([-+e][-+g]?"
            },
            {
                "text": " [0-9]{4}\\.[0-9]{4}\\.[0-9][0-"
            },
            {
                "text": "\n/(\\+?[A-Za-z]?\\.[0-9]+)/\nThe"
            },
            {
                "text": " \\.\\d+(?:\\.\\d+)?(?:\\.\\d\\K\\d*)"
            },
            {
                "text": "\n/(^[\\+\\-0-9]?|\\.?[0-9]{1,"
            }
        ]
    },
    {
        "expression": "(((s*)(ftp)(s*)|(http)(s*)|mailto|news|file|webcal):(\\S*))|((www.)(\\S*))",
        "raw_prompt": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix.",
        "refined_prompt": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"",
        "matches": [
            "ftp://domain.com",
            "sftp://subdomain.domain.com",
            "mailto:yourname@rommel.com",
            "www.domain.be",
            "wwwjng{+\\m2:$aV6hF94311e#j%4JvPD6=K/vP4+$(.Tr=*dK+TvSne;OVoS)^DSJ>Pe:s-b<}VH?/Ww)Q(f(\\$fz7J;K4_6NdF",
            "wwwjng{+\\m2:$aV6hF94311e#j%4JvPD6=K/vP4+$(.Tr=*dK+TvSne;OVoS)^DSJ>Pe:s-b<}VH?/Ww)Q(f(\\$fz7J;K4_6NdF",
            "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssftpsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss:HHx,;GtDW>\"qVvd~ylk$$y",
            "mailto:HECEAs^v'qFE",
            "wwwn0SwO4(xoXf=7,$rl8J'[lR[t%c",
            "mailto:C`!@rywnCVn]k\"Jwy_T@-I_F*%?*{buJ*gaHa>+h$kj1s\\G\"xV]N[JyMa9$b:IIi@]`H)P=DA8)?",
            "news:#gSz^XDAkTTV6$]tFf,b+^3]U%mIT-Th]MXr",
            "webcal:ZV@^QH^4Lu7(~sytDy:i1g\"]evqswp.V$m|;$t",
            "mailto:QD(&Je.stxv':E3J~G>VVo>k<?n|3P$`QK"
        ],
        "non_matches": [
            "gopher://anything.com",
            "subdomain.domain.com",
            "http//somethingforgotten.com",
            "fghjk",
            "http",
            "rfvwfdvs///:;",
            "www",
            "website",
            "file.fed",
            "domainname",
            "frevto3",
            "098765"
        ],
        "id": 2117,
        "output": [
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: \n(http|https):\\/\\/[a-z"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: \n\nimport re\ninput_url = 'ft"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer:\n    http(s)://[A-z0"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: You can use this pattern and add.* and then."
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: \nThe RegExp used to check for valid mail addresses"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: \"^[a-z0-9-]+@"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: r\"gopher://[\\w\\-\\.\\+"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: [^A-Za-z0-9/"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: r'(ftp|sftp|http|"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: ^(?:(?i)([^\\s:/"
            }
        ]
    },
    {
        "expression": "\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:.\\d{7})?[+|-](0[0-9]|1[0-2]):(00|15|30|45)",
        "raw_prompt": "Complete date-time format according to the ISO 8601 standard.",
        "refined_prompt": "Complete date-time format according to the ISO 8601 standard.\nMatch examples:\n- \"2004-10-31T22:06:00+12:00\"\n- \"2006-04-31T12:31:39.6230000+05:45\"\n- \"2009-01-08T20:25:26-03:00\"\nNon-match examples:\n- \"2009-01-09T12:23:34\"\n- \"2009-01-09 17:45:22\"",
        "matches": [
            "2004-10-31T22:06:00+12:00",
            "2006-04-31T12:31:39.6230000+05:45",
            "2009-01-08T20:25:26-03:00",
            "1548-10-14T20:16:55|01:30",
            "9999-02-31T16:01:24-10:45",
            "6891-11-31T20:08:56|03:00",
            "8706-11-31T19:11:14d4081518+06:45",
            "0126-10-26T22:41:10-9791357+05:30",
            "9866-11-11T20:21:03f4126476|12:30",
            "2193-02-30T12:25:09{6235192-05:00",
            "2857-12-09T23:38:23-09:00",
            "4396-08-31T01:34:46&3017852-10:30",
            "9384-07-31T22:27:34+02:15"
        ],
        "non_matches": [
            "2009-01-09T12:23:34",
            "2009-01-09 17:45:22",
            "2009-05-32T12:67:23-15:00",
            "2009-13-32T25:76:23",
            "098765",
            "TTTuerhlv",
            "9384-7-31T22:27:34+02:15",
            "4396-08-31T:34:46&3017852-10:30",
            "##",
            "8706-11-31T19:11:14d408151.+06:45",
            "%^^^",
            "098765rfgbnjkl"
        ],
        "id": 2118,
        "output": [
            {
                "text": "\n.*("
            },
            {
                "text": " [0-"
            },
            {
                "text": " (.*)"
            },
            {
                "text": " \"(?P"
            },
            {
                "text": " \\d{"
            },
            {
                "text": " RegEx \""
            },
            {
                "text": " [12:"
            },
            {
                "text": "\n\nimport"
            },
            {
                "text": " (.{3"
            },
            {
                "text": " (\\d"
            }
        ]
    },
    {
        "expression": "^([0-9a-f]{4}\\.[0-9a-f]{4}\\.[0-9a-f]{4})$",
        "raw_prompt": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.",
        "refined_prompt": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.\nMatch examples:\n- \"001e.1324.683f\"\n- \"1234.abcd.1234\"\n- \"ffff.ffff.ffff\"\nNon-match examples:\n- \"001E.1324.683f\"\n- \"001234.abcd.abcd\"",
        "matches": [
            "001e.1324.683f",
            "1234.abcd.1234",
            "ffff.ffff.ffff",
            "ecb4.b364.1ac0",
            "3116.1302.58af",
            "58dc.329b.6c6e",
            "ce1c.42b8.5ac1",
            "4db3.7965.4d98",
            "3a14.05f0.bc49",
            "af60.695b.1011",
            "ed8b.737c.c603",
            "e070.87df.3b80",
            "8fe3.cb32.d9eb"
        ],
        "non_matches": [
            "001E.1324.683f",
            "001234.abcd.abcd",
            "abcd.1234.abcd.1234",
            "aa-bb-cc-dd-ee-ff",
            "11:22:33:44:55:66",
            "23",
            "213",
            "rgt",
            "/",
            ".",
            "43fredc",
            "&^%$#"
        ],
        "id": 2123,
        "output": [
            {
                "text": " The regex should be:\n(?=^[0-9A-Fa-f].*$)(?=^[0-9"
            },
            {
                "text": "\nMatch Example:  #.1234.abcd.abcd\nSolution:  (?:\\d{3}\\.){2}\\"
            },
            {
                "text": " [Regex]\\b(?:\\.(?:[0-9]{1,3}\\.){3,3}\\.){1"
            },
            {
                "text": " [^0-9a-fA-F\\-] (Note: \"-\", \"[^\", \"]\" are reserved for specific character ranges,"
            },
            {
                "text": " (.*)^(([0-9]{1,3}\\.){0,3}[0-9]{1,3"
            },
            {
                "text": " [A-Za-z][A-Za-z0-9].{5,}[A-Za-z0"
            },
            {
                "text": " \n\\d{4}\\.(\\d{3}\\.)\\d{3}\\.(\\d{2})\n\nExercise 2"
            },
            {
                "text": " Matches against dumps of Cisco MAC address tables\n\nExercise 2: Identify the common features of the non-match examples in Exercise 1."
            },
            {
                "text": " [a-zA-Z0-9]{6,}(\\.[a-zA-Z0-9]{2}"
            },
            {
                "text": "\n- \".8a-f.*9\"#Match an IP address starting with f and ending with a digit or period.\n-.0"
            }
        ]
    },
    {
        "expression": "^[^\\*]{0,}[\\*]{0,1}[^\\*]{0,}$",
        "raw_prompt": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.",
        "refined_prompt": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.\nMatch examples:\n- \"search*\"\n- \"*search\"\n- \"se*rch\"\nNon-match examples:\n- \"search**\"\n- \"**search\"",
        "matches": [
            "search*",
            "*search",
            "se*rch",
            "search",
            "*",
            "4b+S]11PjT@0!Be#ODsdoawua6JcFmJ9",
            "Y<+y[16u@By.H>zM]|A0$d$0jba=T5X%XGVv/ 8Pr$8W;]yE<6\"UJg)0d)^)H~plt[f%6Q0KT[s\\!V4+?tVo",
            "=q[Moj908KzE#0~/\\8K0$n.YO@Thrp8-ms@>EB;roO|p!.VGdhmb%pXIZ#01QE!8-KxGeQqB*pb$3vi/by7~~zg.$KG3E14.GBP?kU51%G#N1%!#YF,",
            ">;FHzj_|3f}VC_t.\\lZsA4w^i'oI2)k`DfVoBK`2`!G>YN:F;{)H2m-OeDs}j0r#|;0=5cUshY3[G[x)+`>But*Z%`s-=Ya<OGkk+co4@Z9z60",
            "%N/l5QgsUjE|x( z9k!7Ofaud8+,^mU^Fp)\\QcRpF9:q R62I'wdN>leqR.nQ;$aF|\\w.6f\\xRXHtH1:wo,.CXL",
            "m7KQj'L/23Z?FsK8)~a[}\"qP(Q#`hW~y><C'|i/:G/RQz[B)w|Qf3-hJo;OX<or|6`[(on3yovpEouB$_]K|cT}h$fSFP<).53(=n-%:>m9&jicqp;x/\"z[mhu![Z#?w~,}FU$s@Ra",
            "gT@FMg[UgLg!b%qK?N3$8$k$.4[x(D~q#d`@6(<tvj0D@A`hO?cq\"^#2|mT{`$3D~$h_O\\3HC^cgKw_e|%j=wH$rb+hiR21\"]p~][:nx$I3$9f3LfVHUnBL0TX|\\\"P4,C0EKh?iZ}>C>owE)WB8^RsswG[rt:C~pF6:_y(r=GJdcR",
            "B6Lw{H2.24SAuRoriOdN.J\"Jkx iujzV5X+8v4h0_<mS{XP8xzId yA68bt.,yk&5xD\"uDb"
        ],
        "non_matches": [
            "search**",
            "**search",
            "**",
            "s**rch",
            "s*a*ch",
            "**FREDSVX",
            "**32rwfs**",
            "* vd*",
            "********",
            "********",
            "*734as*",
            "*****8uerfb"
        ],
        "id": 2130,
        "output": [
            {
                "text": " https://regexr.com/47bq5h\n\nQ:\n\nConcatenate two numbers\n\nI am in an online programming competition and my problem is:\nGiven two consecutive positive integers a and b,"
            },
            {
                "text": " search* and search*.\n\nSolution:\n\n\n``` python\nimport re\n\n# Wildcard characters\nwildcards = ['*', '**']\n\n# Match pattern\npat1 = r\"search\"\npat"
            },
            {
                "text": " ^(?!.*(?:.*a|a.*e){2})[^a]*(?:a(?:\\.*b|b$))[^a]*$\nHere is my Python code:\nimport re\n"
            },
            {
                "text": "\nimport re\nfrom urllib.parse import urlparse, parse_qs\n\ndef url_validator(url):\n    components = urlparse(url)\n    if components.scheme not in ['http','"
            },
            {
                "text": " search[\\w]{1,100}\\.*se[\\w]{1,100}\n\n5. Match this description:  \"A valid string consists of a single character followed by a period, and must come immediately after"
            },
            {
                "text": " search[\\w+|\\W]*\n\n#### Exercise 5:\nCreate a regular expression to check the input text against following rules: \n- Must contain either letters or numbers\n- Must not contain more than 7 letters or"
            },
            {
                "text": "\n\"\"\"\n\n# import re and test:\n\nimport re\n\nstring_1 = \"hello world\"\n\npattern_1 = re.compile(\"^he.*l.*lo.* $\")\n\nprint(pattern"
            },
            {
                "text": " \"(.+?)\\*\"\n\ndef generate(s, r):\n    p = re.compile(r)\n\n    # for all substrings, count the total number of times.\n    count = 0\n    "
            },
            {
                "text": " Regex for the first example is ^.*$|.*$\n\n```python\ndef generate_pattern(string):\n  # Remove duplicate \"*\"\n  string = re.sub(\"+\", \"*\", string)"
            },
            {
                "text": " ([ai-z]|^[^aeiou]+)\"\"\"\n\nmyTextReg = text.replace('\\n','')\nmyTextReg = myTextReg.replace('.', '.')\nmyText"
            }
        ]
    },
    {
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "refined_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it\nMatch examples:\n- \"12314\"\n- \"12314.2\"\n- \"12314.32\"\nNon-match examples:\n- \"12314.212\"\n- \"12123.222\"",
        "matches": [
            "12314",
            "12314.2",
            "12314.32",
            "339655967.2",
            "9656.63",
            "1847297471.28",
            "324913.47",
            "7459.86",
            "74",
            "215392162.63",
            "58365927.3",
            "10780883",
            "5766980587.1"
        ],
        "non_matches": [
            "12314.212",
            "12123.222",
            "%recd",
            "237834889ber",
            "000",
            "123efcd",
            ".0",
            "8.",
            "876trfvbnmkoiuytfv",
            "jehrdsc!!!@",
            "<>",
            "(vev)"
        ],
        "id": 2136,
        "output": [
            {
                "text": " {10,0+digits}.{2,2}\nHint: Start with {10,0+,digits}, and then add {2,2}, so you have {10,1+,digits}, which will match"
            },
            {
                "text": " \"^[0-9]{1,3}(?:\\.[0-9]{1,2})?$\"\n\n3. Write two Regular Expression lines that find:\na. Email addresses like this: \""
            },
            {
                "text": " \\A(10)0\\d{3}(.25\\d{2})$\n\n## 8.5 Exercises\n\n### Exercise 1\nWrite a Python program to check if a string contains only lowercase letters"
            },
            {
                "text": " [^[a-z]\\d]+\n\nWhat I've tried:\nRegex.Match(num, @\"^[a-z]+([\\d][a-z])\\.([0-9]{"
            },
            {
                "text": "\nimport re\n\nregex = r'^\\d{1,9}[\\.]?\\d{1,2}$'\n\nprint('Example valid numbers:')\nexample_valid_numbers = [\""
            },
            {
                "text": " \"^(\\d{10}(\\.\\d{1,2})*)?$\"\nExplanation: First ^ and $ make the above expression mandatory. The last group is optional.\n\n``` python\n# Sample"
            },
            {
                "text": " \"^\\d{1,10}\\.\\d{1,2}$\"\n\n3. Regex to get the maximum number of digits from a number\nWrite a regular expression to get the maximum number of digits in a"
            },
            {
                "text": " [1-2digit], followed by [0-9]{1,3}.[0-9]{1,3}\n```python\nimport re\n\n#Create a regex pattern \npattern = re.comp"
            },
            {
                "text": " ([0-9]{3})([0-9][0-9][]) \n\n##### Exercise 4 \nExtract integers, floats, digits before and after decimal point, and the length of the numbers formed."
            },
            {
                "text": " [^.]+\\.\\d{0,2}$\nWhat is the difference between a [digit] and a \\d?\nAnswer: [digit] refers to any contiguous set of digits, whereas '\\d' denotes any"
            }
        ]
    },
    {
        "expression": "^\\d*[0-9](|.\\d*[0-9]|)*$",
        "raw_prompt": "Decimal like 123.23\n123.1234\n12345.456",
        "refined_prompt": "Matches numbers and they can have values after a decimal point\nMatch examples:\n- \"123.23\"\n- \"123.1234\"\n- \"1234\"\nNon-match examples:\n- \"123a.12\"\n- \"123.34d\"",
        "matches": [
            "123.23",
            "123.1234",
            "1234",
            "1234.456",
            "1243.324455",
            "34242",
            "34253422.4231",
            "834884.23334434334",
            "1230948.23343",
            "1",
            "43932.3223",
            "222222.222",
            "234321.4354342345"
        ],
        "non_matches": [
            "123a.12",
            "123.34d",
            "abc",
            "-1",
            "+1",
            ".0",
            "number",
            "098765467898765r",
            "....34532..43",
            "433.43/",
            "000-.00000",
            "#11.2"
        ],
        "id": 2143,
        "output": [
            {
                "text": " \n\nimport re\npattern = \"^\\d+(?:\\.\\d+)?$\"\n\nre.findall(pattern, \"1234.33\")\n\nExercise 3: \nFind all words that contain the letter \"a\" and"
            },
            {
                "text": " [a-zA-Z0-9_]{4}\\.?[0-9]{,}\n\n\n\nI hope you enjoyed this chapter on Regular Expressions and had a good time learning about Matches and Non-match examples. With some practice"
            },
            {
                "text": " \"^[0-9]*\\\\.[0-9]*$\"\n\nExercise 5:\nWrite a Python script that prompts the user to enter their email address, then uses pregex to check if the email is valid. A valid email should have the"
            },
            {
                "text": " A non-match should be generated if it has a decimal point before the number, a letter following the number, and one or more digits immediately following the decimal point. For example, \"123b.12\" should generate a Matcher object that matches and \"123abc."
            },
            {
                "text": "\n^(?=^[0-9]{1,3}.[0-9]{1,3}|[0-9]{1,3})[0-9]\\.(?:[0-9]{1,3}|"
            },
            {
                "text": "\n(?<=^|\\.)[0-9]+(?=\\.)\n\nExercise 4:\nGiven a column of text and a list of prohibited words, generate a RegEx that matches any string of text that is not a prohibited word. "
            },
            {
                "text": " \"^\\d+\\.\\d+$\"\n\nUse Case:\n\nJohn and Mary were coworkers who needed to collaborate on a report for their boss. John suggested that they split up the tasks, and each work on their own part of the report and then combine"
            },
            {
                "text": " \\d+\\.\\d+ (numbers and. after the first decimal point)\n\nExercise 2:\nMatch expressions that are used to represent lists\nMatch examples:\n- (?:\\w+ )+    (Any number of letters and spaces)+\n"
            },
            {
                "text": " non-match for this description\n\n5. Write a Python program that extracts the price from an HTML string using RegEx.\nSolution Example:\nimport re\n\nhtmlString = \"A product costs $45.50. You can register for our upcoming sale.\"\n"
            },
            {
                "text": " Matches only numbers and decimal points, not alphabets or hyphens. Non-match only alphabets and hyphens.\n\nExercise 2: \nMatch this description and values\n- \"Match the following colors with the descriptions and their values.\""
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+(([_][a-zA-Z0-9])?[a-zA-Z0-9]*)*$",
        "raw_prompt": "This Regular Expression. I have used with ASP.NET Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]",
        "refined_prompt": "Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]\nMatch examples:\n- \"Employee\"\n- \"Employee_Test\"\n- \"Employee_Dept\"\nNon-match examples:\n- \"Employee.Test\"\n- \"Employee$Test\"",
        "matches": [
            "Employee",
            "Employee_Test",
            "Employee_Dept",
            "imMnMkYWqNYteAX3jcMVS9c1wehWWDCKK4XIUBWQRIjGV5jymN5Fy3SuD4cTFTr7CcRFRpYFYqQI8cOkazKeGReMGv9zUIy84mXfbi8jgopUgVD3dafFK5kNNKrdu6AizClSFrtjtdG78YwJan9ncHylM7a2drv5MBjAeNkUdaRDZcs0zpybZf2HGPXYYBzaP6HvrKlzPCtTgCdzg3cxIwIoYvoAALlc3rVc9yOXWAToXEt9Tk6KJnkDtRNa3XACaVl6rtoPp6VDGCVK7Lptn88ROedDoANkKeZbLWREvURD2dRHwyiJe62kBTbUFRrsWOCYMsV53QCE4abpBORamW_vv1YUHXV0XL28Te_de48d3N6KjwpoH5w6WnqFcw9hmuvkp5MeeayVVhtyvXXJvn7KUjao37wPq3VBpTcEUlabfNZbcPj9ywLxR4Koo8mXxbT8nQSxsFOleyUaRVHy2NR3gC489D6rRfrgTHLRvuOgwWqTa3_66uZcVwT0WE0kg6txbh7119bjLoK75GV8LqexHLMMTFrNWEA1KtibyDGZ1RlfBhT7L9hnkuGwgdL_0Hf3e9xq3IKc2",
            "erfdsaqw",
            "23456",
            "gtrewc",
            "UYTRFVB",
            "J6efgr8",
            "JERFKJERKJ",
            "jfeov",
            "rfuu",
            "12324refdg"
        ],
        "non_matches": [
            "Employee.Test",
            "Employee$Test",
            "Employee@Test",
            ".com",
            "#4",
            "O'Connor",
            "hello!",
            "$money",
            "-+",
            "&and",
            "%%%",
            "/?"
        ],
        "id": 2145,
        "output": [
            {
                "text": " \n[0-9a-zA-Z][0-9a-zA-Z._-?@$%^&*()]+\\.[0-9a-z"
            },
            {
                "text": " \"Employee[_@#][a-zA-Z]\"\nUsing the re module, write a function in Python that takes user input for a string variable name and validates it against the list"
            },
            {
                "text": " \"Employee[^\\W_]\\w*\"\n\n- \"123abc456a78\"\n- \"a,b,c@d\"\n- \"1ab2c"
            },
            {
                "text": " [a-zA-Z0-9]*_[a-zA-Z0-9]*\\.[a-zA-Z0-9]*\nIll"
            },
            {
                "text": "^[a-zA-z0-9][a-zA-z0-9_.\\-]*[a-zA-z0-9](_?[a-"
            },
            {
                "text": " [0-9a-zA-Z]*\n\n2) Write a RegEx that will allow a user to enter a phone number in the format (XXX) XXX-XXXX where XXX"
            },
            {
                "text": " \"[^_a-zA-Z\\.]+\"\n\n\n\nIntroduction:\nAs a makeup artist, you will be using math to determine the correct measurements for various makeup products. Ge"
            },
            {
                "text": " /^[a-zA-Z0-9_\\-\\.\\s]+$/\n\n5. Use the REGEXP_SUB_STR() function with a pattern, and a"
            },
            {
                "text": " The RegEx should have the general pattern of [A-Z]+(_[A-Z]+)*\n\n3. How will you create a regex pattern that matches a phone number in the"
            },
            {
                "text": "  (.*?)([@#\\$])(.*)\nHere '.*?' will match any characters in any number of occurrences within the string.  The [@#\\$] are the"
            }
        ]
    },
    {
        "expression": "^(http\\://){1}(((www\\.){1}([a-zA-Z0-9\\-]*\\.){1,}){1}|([a-zA-Z0-9\\-]*\\.){1,10}){1}([a-zA-Z]{2,6}\\.){1}([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*",
        "raw_prompt": "This checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check. Replace http by (http|https|ftp) for other protocols. Still not happy about this: http://www.www.passshouldfail.com",
        "refined_prompt": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN9-cVCTS5v-qlrCKlMOw72dvN22tFoQgPY.pH.So%sh,%?Pti6eF~$~O~HH#+6C0Xn.JbZ\\Y$\\\\l8nR,61gbhHAGNCTP.L0h5gqKMoqPEv%_75,%\"\n- \"http://3UWfs9mB1D3Ciwg1cLlUmjmQ4DELt1gXBkkc8w4GdJ2P0txeJg-Nu022UVUAFZeosrJ74LoqyHG5y8cgaJHyk98XYAI.KHaOWshJITNckgemqvfGMci7llelRMEkDDfC1jWjzVGdd2yWdDyuI3Xk9Z-2MpgbssxQkttyQSzXLtVy3Ug-NnAWEAXX0iQB3v.2sPsignuFg524sJWDYFhpP90UsgPiN31AJOMDrvjuk7gCHqzfgiA6a5QxTDGlbPf3jkd9uGbUTCVoceWEP2ZzeDShsKE9.gS.T%Qvd#Cvu=/0gL0QkW_PBB~gEoV\\0K,de$do9q%Cf#2T-c=XS-~wsz;y,i%ze4vw81?3%1FoO8E$\"\nNon-match examples:\n- \"fail.com\"\n- \"www.fail.com\"",
        "matches": [
            "http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com",
            "http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN9-cVCTS5v-qlrCKlMOw72dvN22tFoQgPY.pH.So%sh,%?Pti6eF~$~O~HH#+6C0Xn.JbZ\\Y$\\\\l8nR,61gbhHAGNCTP.L0h5gqKMoqPEv%_75,%",
            "http://3UWfs9mB1D3Ciwg1cLlUmjmQ4DELt1gXBkkc8w4GdJ2P0txeJg-Nu022UVUAFZeosrJ74LoqyHG5y8cgaJHyk98XYAI.KHaOWshJITNckgemqvfGMci7llelRMEkDDfC1jWjzVGdd2yWdDyuI3Xk9Z-2MpgbssxQkttyQSzXLtVy3Ug-NnAWEAXX0iQB3v.2sPsignuFg524sJWDYFhpP90UsgPiN31AJOMDrvjuk7gCHqzfgiA6a5QxTDGlbPf3jkd9uGbUTCVoceWEP2ZzeDShsKE9.gS.T%Qvd#Cvu=/0gL0QkW_PBB~gEoV\\0K,de$do9q%Cf#2T-c=XS-~wsz;y,i%ze4vw81?3%1FoO8E$",
            "http://Fb01D1igrD0vQvV41e0jnJW3R6BIIvKtlyAPgloZ-yNOr3bjnV8RNOvSw5TuO2QIEr4BD5IBe8Y.bjWDE8xoqgkTa3y8zQDBlKeFKDqc6YAkIanfQSiueP7SSC4IF5cOtZ3Bi01n3Fka.lKPkHF.5WUVdDYkz&mhzSD.~+XCqiO~nASOfMSx72195a8By-j?ic3Y4JexB3;zVot_hxl?7Ox,tA\\T#dGK+6yg1ys6",
            "http://fHxao.5wdwGtG.jzdr./JkwCqE;B#BXvZ",
            "http://Ca.5Cj.xC0e9OJ0Io4w.i0d1u7joKMlrUdG7rTQnetfmB9jVrk-VIAENSELu.du.xQl1P.vZ?bMmBITIR",
            "http://pZCKyXBPQ-2QjsJF5jhfA56XVJptcQIMy6hlxZOVESATWRt-wvuopKSQcEZjWKJ4AZbVuL..bUUVVEs-vQXxm05VyLzKhP2L4N8u.m0py9e2adsUfOivV1U9uSRpszsHm2nfcX11ZUq9za1cYTz56znzO1ZLO7stK4g6Cxo4J7jKrzOFtzyBTrY7SB9IeSXUd.gZDGh.kVvK3G526r1.tSsfurTqXqQIy5InocIvbfcapgKqLvPJeTn3Zg0ihrcfsmRcUJpN-4tLCDzSuUBhXoBIdoL9YRPzFHvpE.bAo8CuvofEYpe9uBOIhzpXgSr2pYe8QpAy18CaYYpe.toO.oeqTM4A806zm;H0RAAdZD%S;~o2N?axJV6OBr6OgH-5F\\OqE-'4Wv",
            "http://LXQT7536wecB4rVAbo7eu45pXqnaXbFfvfcCtyBpkXQ1Ab6VSVmYkV2A4jjXLCv.6VMzhUdxa0nC8rMj52oFn1R-WMNlGdxJ6Q133C3jwR4Hrwukkjex7yBk9JALwJ54vfdpyy70q-ZyPxfWi2.UY.d'I/cD",
            "http://pVArk1aK-WvidTrWBJ2QBSsYCRaAgAOalxmwPp1LFx1NOjhA6xuunJ4lqXXrh3GN9ngPuTW810jTKz8VIC.la.,YC2Z&id,Ho4vV7f+vEFDKUfc;zZ?vh/T$MJ#PYgQ30SVO~~&/_dCDBLFFx\\$HlJaZceD,r~xzb",
            "http://www.4Gt455zk6wcyUndUZeylnBFCYnmnCS8XwylCvx-g4vHSH9BkX0--PpKtVJWBgV6a2W3.qjr2ZzkyTuodWhHPCIg5CfHOYYgB.Gpk3CeIBP6pHhNLlEVHXG.bmXw6FDpkmahRSzAUfR6UHl3APpYRxkIlfqhlV9ecJ-AmMnm2dgE4zT.ihwrJm.dTT=A;Uuy59gk'ox",
            "http://www.GHhmgy5tTVwT6zJ3sm25ioKusMb1-mjJZ-eBEhYmxYhzixg1-JXcZfY4mc04.l-Dvcdd80cun2nuI7qRvpVgV5PRcJv77VjKL0uqjQj1EANxkkMieyhrRbG.UBL.3KCAnx8Ji7OL4646I12+uHlXuwoRB9pZx#-czv,H6;AKbDno.yTpSQM7GFym&?i&8UwNn?g%mjh",
            "http://www.xnMgEcR9a2UJKok7eNntbWsK9vSS1cbunCe1rO2ONIsryfsWV3sxwN.fvNWktN4xBnY0nDPmMahEqt4-VLsJjZ8kOJISj-kWZZX8t5b9WkGAhF556X922o7QrR4.anxA.RApP'~2o;6qO\\-",
            "http://.rMSF.pSQkN.q?,tZX'6;ahY0vQe\\4-icTn4%%YLyAnPSyK.A-_B~8#a&Xcs1&$FJD.\\eYbK.pSA"
        ],
        "non_matches": [
            "fail.com",
            "www.fail.com",
            "www.www.fail.com",
            "http://fail.com",
            "http://http://fail.com",
            "http://http://www.fail.com",
            "sub.fail.com",
            "www.sub.fail.com",
            "sub.sub.fail.com",
            "www.sub.sub.fail.com",
            "www.efds",
            "erfvds"
        ],
        "id": 2149,
        "output": [
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNp"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNf"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNQ"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNg"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNZ"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN4"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN\""
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNn"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNj"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNu"
            }
        ]
    },
    {
        "expression": "^Content-Type:\\s*(\\w+)\\s*/?\\s*(\\w*)?\\s*;\\s*((\\w+)?\\s*=\\s*((\".+\")|(\\S+)))?",
        "raw_prompt": "Matches the Content-Type for a MIME Mail Message and a Non-Mime Mail Message",
        "refined_prompt": "\nMatch examples:\n- \"Content-Type: multipart/mixed; boundary=\"---myboundary\"\"\n- \"Content-Type: multipart/mixed;boundary=---myBoundarysi3cds\"\n- \"Content-Type: text/plain;\"\nNon-match examples:\n- \"Content Type: multipart/mixed\"\n- \"Content-Type: text/plain\"",
        "matches": [
            "Content-Type: multipart/mixed; boundary=\"---myboundary\"",
            "Content-Type: multipart/mixed;boundary=---myBoundarysi3cds",
            "Content-Type: text/plain;"
        ],
        "non_matches": [
            "Content Type: multipart/mixed",
            "Content-Type: text/plain",
            "Content-Type image/jpeg;"
        ],
        "id": 2152,
        "output": [
            {
                "text": " ^((Content-Type:)([^;]*);boundary=)([^;]*)$\n\nEx"
            },
            {
                "text": " Content-Type: text/plain or Content-Type=\"text/plain;\"\n\n\n\nDaily Life: Health and Well"
            },
            {
                "text": " \"Content-Type\"\n\n\n\nLadies and gentlemen, esteemed Aliens, welcome to the fascinating world of physics! Today"
            },
            {
                "text": " \\bMultipart/mixed\\b; boundary='[;\\r\\n]+'\"\n\nExercise 2"
            },
            {
                "text": " [Content].*?\\;\n\n\n\nQuestion 9: A store bought 50 shirts for $500. If the store"
            },
            {
                "text": ".*mixed.*\\s(boundary=\\s.*;)?\n\n\n\nQuestion 8: Emily wants to"
            },
            {
                "text": " re.compile('^(Content-Type: text/plain; boundary=[^ ]+)$')\n\nExercise"
            },
            {
                "text": " Content-Type(?:\\s?\\w+\\s?=\\s?([\\w\\d\\s<"
            },
            {
                "text": " Pattern = \"\\b(mixed|plain|all)\\b\";\n\nExercise 3: Customizing Regular Expressions"
            },
            {
                "text": " content-type=(?i)(?=\\b[^,]+,\\s*[^,]+\\b["
            }
        ]
    },
    {
        "expression": "^((0[123456789]|1[0-2])(0[1-3]|1[0-9]|2[0-9]))|((0[13456789]|1[0-2])(30))|((0[13578]|1[02])(31))$",
        "raw_prompt": "Evaluates a date in the format of MMDD. Will evaluate month day ranges accurately with Feb going up to 29.",
        "refined_prompt": "erfvds\nMatch examples:\n- \"0229\"\n- \"0331\"\n- \"0630\"\nNon-match examples:\n- \"0230\"\n- \"0431\"",
        "matches": [
            "0229",
            "0331",
            "0630",
            "0902",
            "0730",
            "0131",
            "0830",
            "0731",
            "0619",
            "0131",
            "0331",
            "1031",
            "1130"
        ],
        "non_matches": [
            "0230",
            "0431",
            "1245",
            "1299",
            "0011",
            "erfvds",
            "date",
            "2345",
            "5321",
            "9347",
            "7922",
            "8205"
        ],
        "id": 2153,
        "output": [
            {
                "text": " ^0{4}[0-9]{2}_[0-9]{3}$\n\n4. Create a function that converts a string of dates from an object which looks like this: {date:\"01/01/2022\",...} to a list of date objects.\n\nExample: {\"date\":\"01"
            },
            {
                "text": " ^04(0[1-9][0-9])[0-9]{3}$\n- \"0082\"Generate a RegEx for this description.\nAnswer: [0-9](2[0-3])[0-9]{2}$|[0-9](3[0-5"
            },
            {
                "text": "\n\\d{2}[02-9][0-9]\n\n2. Create a RegEx for a word that starts with a 'P', 'H' or 'E' and ends with a digit representing a year.\n   *Hint: Use the '^' and '$' in the beginning and end of your"
            },
            {
                "text": " ^([0-9]\\\\d{2}[0-9]\\\\d{3}|\\\\d{2}{3}){1}$\n\nExercise 2:\nMatch these numbers with the regex pattern and print the value of the match.\nnumbers:\n- 123456789\n- 98765432"
            },
            {
                "text": " \"^[0-9]+(?!s).*$\"\n\n4. Given a list of sentences, sort them based on the number of words in each sentence using regular expressions.\n\nimport re\n\nsentences = ['The quick brown fox', 'jumps over the lazy dog', 'the quick brown cat']\n\ns"
            },
            {
                "text": "\n(0[1-9][0-9])\\s?[01][0-9]\n\"\"\"\n\nif __name__ == \"__main__\":\n    input_str = input().strip()\n\n    pattern = \"(0[1-9][0-9])\\s?[01][0-9]\""
            },
            {
                "text": " (0[3-9])|2(0[1-9])|30\n\nExercise 5:\nThink of at least two other real-world scenarios where pattern matching could be beneficial. Write at least one example for each scenario, and explain how you would use pattern matching to solve the problem.\n\nAnswer Key:\n\n"
            },
            {
                "text": "\n\ndef regex_str(m):\n    text = m.group()\n    start = int(text[:8])        \n    stop = int(text[8:12])     \n    step = int(text[12:])  \n    return f\"^{start:02}?$({stop:03"
            },
            {
                "text": " ^\\\\([a-fA-F]{2}){5}\\\\.*$ \n2. Write a Python function that uses regular expressions to replace all IP addresses that begin with \"192\" in a string with \"Cisco\"\n\nSolution:\nimport re\n\ndef replace_ips(txt):\n    pattern = '"
            },
            {
                "text": " [A-Z]+[0-9]?[0-9]* \n- \"1234\" - [0-9]?[0-9]'\n\n\n\nChapter 1: Comparison - Strong and Weak\n\nIn the world of science, especially in the field of physical science, the concept of comparison is an essential"
            }
        ]
    },
    {
        "expression": "//.*|/\\*[\\s\\S]*?\\*/",
        "raw_prompt": "Matches single line or multi-line comments.",
        "refined_prompt": "Matches single line or multi-line comments.\nMatch examples:\n- \"// Comment here\"\n- \"/// Comment here\"\n- \"/* Cmment Here */\"\nNon-match examples:\n- \"/ * Comment Here */\"\n- \"/* Comment here * /\"",
        "matches": [
            "// Comment here",
            "/// Comment here",
            "/* Cmment Here */",
            "/**** Comment Here ****/",
            "//C5:%0NTao6jqq/5tdt#8!m/oLs< OJ|}~`XF`gUe1{InR%{7~()iE_?mmXrsit}_~CgZ~Ah,K~h,Cd",
            "//yIT_5t?'RaziV;TMVyOR\"2wnzh5=+;P_E-Fh*ay+~GpSG<",
            "/**/",
            "//P$Zge.ILHfPy7]y#]n}A#Dl8W~h<!dXZ*p;",
            "/*i\u2002\u20062\u202fH\u2028N`!Z&.H|%JOk\u200a:\u3000\f,V\u2009w\t\u2001[BQX*/",
            "//Zta'vB:8m}Nj;=1x+]-/k-q2J5[<,.6)E\"`-;m~]3xJx7}dUj3Fd~KF@ OOM5L|_'ME.s\\e$G1']%BR{Y+uai7Ss0Tpx!wv9P{",
            "/*x;XxOj]ez,[Lx,)fqjc\u202f]EXF8AAYlBRuR5*BKC(^\u2002s\ufeffS\tq*Ygq\"9\\\u2005xwkZ\u2002Bkn\u2003dl`\u2003n+|B?{f\u2005@\u1680#*/",
            "/*?N'\u2004Og\u2008B*Ry* zL\u2008\u2008 ccUd;#ixk\u2006\u1680aT\"*/",
            "//%#I?<=.^^x&_ONV=uf]1RaYkM]ikLI3[Jp=[;o1=>eKN~FW2(;cgzfEqDSV}ASFJhz:g$q2"
        ],
        "non_matches": [
            "/ * Comment Here */",
            "/* Comment here * /",
            "98765rfg",
            "#fvf",
            "\\\\rve",
            "**vreer",
            "|| efdswc",
            "string",
            "\\frrtte",
            "2345r",
            "'rejrjn",
            "-erfjkjkn"
        ],
        "id": 2155,
        "output": [
            {
                "text": " \n /(?<=// )|(?<=/// )|/\\*(?:[^\\*]|\\*(?:/[^\\*]*))*\\*/ \n\nExercise 2:\nExtract all"
            },
            {
                "text": " //\\/\\s*[A-Za-z_\\s]*/\n```\n\n---\n\n**Exercise 2:** Try writing a regex to find all the occurrences of uppercase 'A' in a string. Can you do"
            },
            {
                "text": " \"/*\\s*#.*\\s*#.*\\s*/\"\n\nLearning Journal - Section 2.6.2: Writing a single regex to match a common pattern or set of strings or keywords\n\nExercise 1:\nWrite regex to"
            },
            {
                "text": " /*/\n\n\n\nQuestion 6: Lisa goes to a coffee shop and buys 2 cups of coffee at $4 each, 1 pastry at $3.50, and 1 milkshake at $4.75. If she pays with a $30 bill,"
            },
            {
                "text": " \\s*/\\*\\s*\\*(.\\/\\*)\\*/|\\/\\h* \\* //\\*\\s*\\*/\n\nI hope this helps. Let me know if you have any questions.\n\n\nStudent:"
            },
            {
                "text": " / *\\/\\/*(.*?)\\*/\n\n\n\nMathematics--Graphing--Graphing equations and functions using the tones/knowledges/examples of Daily life--Jobs--Cashier\n\nIn a world where everything works"
            },
            {
                "text": " /^\\/*\\/?(\\s+[*]\\s+){0,1}$/m;\n\nConclusion\nIf you are struggling with finding the patterns, the best way is still to use your preferred tool. But if you come here,"
            },
            {
                "text": " \n(/\\* +)(.*?)(\\*/ | \\*\\*/)\n\n### Exercise 4:\nWrite a Python program to find all the lines of a given file that contain a certain string using list comprehensions.\n\n```python\n"
            },
            {
                "text": " ^/\\*(.*?)\\*/$\n\nExample 2\nWrite a RegEx to identify double quotes in a string.\n\nmystring = \"This is a string with double quotes: 'word one\"\nRegex: /\\\".+?"
            },
            {
                "text": "\n(^\\/* * ( \\* \n    ( \\*\\*\n        (\\*\\*\\*\n            + \n            (?:\\n * \\*\\*\n                (\\*\\*\\*\\*\n                    +) "
            }
        ]
    },
    {
        "expression": "^(b|B)(f|F)(p|P)(o|O)(\\s*||\\s*C(/|)O\\s*)[0-9]{1,4}",
        "raw_prompt": "Matches BFPO\nAllows for BFPO with no spacing",
        "refined_prompt": "Matches BFPO (can have no spacing)\nMatch examples:\n- \"BFPO 2\"\n- \"BFPO 2222\"\n- \"BFPO C/O 121\"\nNon-match examples:\n- \"bf po 1212, BFPO 22222\"\n- \"BF\"",
        "matches": [
            "BFPO 2",
            "BFPO 2222",
            "BFPO C/O 121",
            "BFPO2222",
            "BFPO664",
            "bFpo948",
            "bfPO19",
            "Bfpo05",
            "Bfpo5944",
            "bfpO7317",
            "BFPo8401",
            "BfPo45",
            "BFpO2556"
        ],
        "non_matches": [
            "bf po 1212, BFPO 22222",
            "BF",
            "bf",
            "Bf Po45",
            "BFp O2 556",
            "B fpo5944",
            "b",
            "##",
            "\ufeff1681",
            "BF PO C/O 121",
            "!!!",
            "0.0"
        ],
        "id": 2157,
        "output": [
            {
                "text": ".* (any character, one or more times)*\n\nExercise 2:\nWrite a function that takes in a string and an optional delimiter character, and returns a list of tuples where each tuple contains all matching words"
            },
            {
                "text": " \n[A-Z]{1,3}\\s\\d {3,7}, (\\d+), ([a-zA-Z]+) (\\d+), (\\d+)$\n\nEx"
            },
            {
                "text": " \n^.+,.\\d+,.\\d+, -\\s\\d+,.\\d+$\n\nUse Case #2: Developing a Password Policy for a Website\n\nParticipants: \n-"
            },
            {
                "text": " /BFPO [^,]*$\n\n4. Create a RegEx for a mobile number that starts with two digits followed by a forward slash, followed by a series of digits and letters.\n\nAnswer: /"
            },
            {
                "text": " (?<b>.*)\\s(\\b(BFPO)\\b)|(?<b>.*)\\s([^,^,]+).\n\nExercise:\nGiven the following strings, generate Regular Expressions"
            },
            {
                "text": "\nBFPO (must contains spaces)\nbf (must start with \"bf\" only, not be followed by any other character, may be followed by,)\n(?=N) Match last character, may not be"
            },
            {
                "text": "\nimport re, json\n\ndata = \"bf po 1212, BFPO 22222\"\n\ndef findAll(text):\n    global match_list\n    match_list = []\n    for string in"
            },
            {
                "text": " \n\n\"\\\\d{4}([a-zA-Z]{0,2}){1}[-.]?\\\\d{4}\"\n\nI hope this helps you understand RegEx a bit"
            },
            {
                "text": "\nr\"(\\w+)BFPO(\\d\\d, \\d\\d)\"\n\nExercise 3:\nWrite a Python function that takes a string and returns a list of strings containing all possible permutations of the"
            },
            {
                "text": " ([A-zA-Z]{1,3})\\/[0-9]{0,3}\\/[0-9]{0,3}\\/[0-9]{6}\n\n3"
            }
        ]
    },
    {
        "expression": "(?=^[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]{7,}$)(?=([!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*\\W+){1,})[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*$",
        "raw_prompt": "Regex to validate strong password for .NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.",
        "refined_prompt": "Regex to validate strong passwords with a length of at least 7 and contains one non-alphanumeric character.\nMatch examples:\n- \"12345!r@r\"\n- \"#dfgjaydh%\"\n- \"aA1!@#$%\"\nNon-match examples:\n- \"12345rfg\"\n- \"hsjahdgs\"",
        "matches": [
            "12345!r@r",
            "#dfgjaydh%",
            "aA1!@#$%",
            "11111#aZ",
            "2^z6@.VqJXCOFq/Uo[SQKh6Mj$.&!}ILi(rVc^Ou(WEEga_pW5J*GEm:lQOF;^<pM",
            "u;BR<$MCQ)Ux/9g(Np!A!hBYe&7g)v{!cvM4mb&(f1gR^OryguwZ/#6",
            "A3|Otes4D;FgH@;+349<^JvGjyv^hIQhM!Wz@guoN:f$bdoYEkf:*CkK-HWTxZ^{#=MU3j)A!W}HMHByHGEq;KY@TyR|hY!n{Mq",
            "i}0R/{jy*KH<d]u5T>@(Fpo!^/Gc|pLTEXU4*i_T9Hh_y%vx[X_^e#cW*[Qb*M{3v8GT}X@F)Q1pt7g&C",
            "=E%?X?:&906mF!%Ye1L4IeKR^<6nHmBB-E*(PW;ZjX$h50M/kcYD-?MF;",
            ">D}9dIYi}R*SFOE^U}#$+7<4I*tz$^^7|x%VRjB}@cjDDNf_@fJE}Ft(&H",
            "l]PT65IK@v3I5!Lo1a2>gT)66oC9%?.s^_rO_#P]29jFwn)2Y8%=X0]yF:Y6Pc={h",
            "nmki=vg>Qjno:}E(+<3BR5HNocpTp9]tK#L<7r1/-lZ",
            "zoH0(<jBz$*SG6<LpgV"
        ],
        "non_matches": [
            "12345rfg",
            "hsjahdgs",
            "12345",
            "BF PO C/O 121",
            "efw",
            "efween",
            "lkjytrdcvbiu76",
            "3refcds",
            "AJJJJKJHGFVBN",
            "ewrjTYEJWKL",
            "jk2rjk2efrjkn",
            "KIDJK;"
        ],
        "id": 2160,
        "output": [
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=\\S)(?=\\S\\S)\\S\\S{7,"
            },
            {
                "text": " [a-zA-Z0-9!@#$%^&*()_={}|:;.-<>\\/]{7,}(?!\\w)"
            },
            {
                "text": "\n^(?=.*[^a-zA-Z])(?=.*\\d)(?=.*[^!@#$%^&*+=]).{7"
            },
            {
                "text": " ^.*\\\\S.*\\\\S.*\\\\S.*\\\\S.*\\\\S.*.*\\\\S.*.*\\\\S.*\\\\S.*\\\\S.*\\\\S.*\\\\S.*\\\\"
            },
            {
                "text": " \nimport re\ncharacters = 'A-Za-z0-9@#$%~^_`+=+-*/?'\nfor symbol in characters:\n    "
            },
            {
                "text": " ^^[a-zA-Z0-9!]*[a-zA-Z0-9!'#$%&()*+,-./:;<=>?"
            },
            {
                "text": " ^(?=.{7,}\\Z)(?=.*[^a-zA-Z\\d])\n\n4. Define the concept of strong passwords, including"
            },
            {
                "text": "  ^(?!^\\w*\\W*\\w*\\W*\\W*\\W*$)(?=^\\S{7}$)(?=.*"
            },
            {
                "text": " You can create the regex pattern string as follow: re.compile(r'^(?=.*[a-zA-Z]+)(?=.*\\d+)("
            },
            {
                "text": " *?[a-z]{6,}\\^[a-z][1-9]?[a-z]@\\^{1-9}[a-z"
            }
        ]
    },
    {
        "expression": "^(([0-1]?[0-9])|([2][0-3])):([0-5][0-9])$",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM",
        "refined_prompt": "Matches a string if it is a valid time in the format of HH:MM\nMatch examples:\n- \"02:04\"\n- \"16:56\"\n- \"23:59\"\nNon-match examples:\n- \"02:00 PM\"\n- \"PM2:00\"",
        "matches": [
            "02:04",
            "16:56",
            "23:59",
            "1:01",
            "21:06",
            "22:59",
            "21:07",
            "07:48",
            "21:58",
            "21:15",
            "3:06",
            "5:29",
            "23:21"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00",
            "date",
            "time",
            "1/12",
            "january",
            "02:00 AM",
            "12-12",
            "98765",
            "73:23",
            "234:433"
        ],
        "id": 2161,
        "output": [
            {
                "text": " r\"^[0-3]?[0-9]|1[012]|2[0-3]\\:|[0-5][0-9]:(0[0-5])\\:?$\"\n"
            },
            {
                "text": " ([0-9]|[1-9][0-9]) ([0-9]|[1-9][0-9])\n\nExercise 5: Write a Regular Expression that generates all possible password combinations consisting of lowercase letters"
            },
            {
                "text": " \":([012345]?[89])(?P=time)|(?P<hour>[1-9]`[0-9]]:`[0-9]{2}`(?P=minute))\""
            },
            {
                "text": " [00-9][0-9]:[0-5][0-9]\n\n3. Write a regular expression that matches a time in the format of H:MM AM/PM.\nAnswer: [01]\\d{2"
            },
            {
                "text": " (\\d{1,2}:\\d{2})(?:AM|PM)\n4. Write a Regular Expression that matches any text that contains 3 or more digits.\nAnswer: ^\\d{3,}\\z\n5."
            },
            {
                "text": " (\\d{1,2}):(\\d{2}). Which validates the time format HH:MM AM/PM. \n\"\"\"\nclass Solution:\n  def __init__(self, input:str):\n    self"
            },
            {
                "text": " (\\d\\d)(:\\d\\d)(AM|PM)\n\n4. Write the regex used to match a phone number that begins and ends with an area code (e.g., 800.123.45).\nAnswer: \\"
            },
            {
                "text": " (optional) HH:MM|18:00|9:30,13:45,23:00,0:00-23:00\n\nExercise 4:\nCreate your own pattern that will match valid email addresses in the given format"
            },
            {
                "text": " (HHmm)\n\nExercise 2:\nWrite a Python code to search for any string that contains the phrase \"cat\".\n\nExercise 3:\nWhat can be the use of the list 'items' method.\n\nHints"
            },
            {
                "text": " You can represent the hours value using any digit from 00 to 23. The minute value can also be represented using digits from 00 to 59.\n\n```python\nimport re\n\ndef validate_time(string):\n    \"\"\"Validates whether"
            }
        ]
    },
    {
        "expression": "^(\\d)?(\\d|,)*\\.?\\d{1,2}$",
        "raw_prompt": "Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n",
        "refined_prompt": "Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n\nMatch examples:\n- \"1,000\"\n- \"1,200.45\"\n- \"4,567,567.45\"\nNon-match examples:\n- \"$1,000\"\n- \"1,200.45343\"",
        "matches": [
            "1,000",
            "1,200.45",
            "4,567,567.45",
            "2450.45",
            ",,05,,89,608,98,,,,,6,6.4",
            "09,8,,097,,,.5",
            ",5,,9670,,,53075,,,3,4138,,,1,,82,,3,7,,,5,,,,6,63090,,8,,53,,,6,,,29586777,44",
            ",411,6,9,73,,2,505,5,,4,5,24,,7,9,20,,,4,960,04,4,1,09,7328,711,0,4804,84,8,9,,,3,3,,,,,,,6",
            "098,3,8,,1700,,2,,8,36,858.3",
            "175,,25,067,,,11,,2,739,8,9,,36,5,,,6305,826,,,,3,,,50,,,,,39,,,1,4,9,4,,,,,,,1,35,8,0,6,0784,33,,75",
            "76,2,,,,282,,,46,,9,,,,5,62,,8,,.19",
            "28,,0,,,,,7856,7,,6,,0319,5,,4619229,,55,,7,1,7,1934,,7,,71,5,,76,043045,9,07.7",
            "3,6,98,1,2197,5,93,776148,,,69,8,,59,105,9,,,,,5476,067,,,,,,6,83776,,1398"
        ],
        "non_matches": [
            "$1,000",
            "1,200.45343",
            "2.5.000",
            "314567896iuytrfew",
            "hyu7654",
            "34256ytergfd",
            "jhitr5drt",
            "34r5t6tgr",
            "3r4t56yyhtrgef",
            "4567i6e",
            "4565hyetr",
            "frgthyj66754"
        ],
        "id": 2190,
        "output": [
            {
                "text": " ^\\d{1,2},\\s?(?:[\\d.]*\\d?\\d|[\\d.]"
            },
            {
                "text": " [0-9]{2,}\\.{0,1}[0-9]{1,,6}\nEx"
            },
            {
                "text": " d{1,2}(\\,|\\.0)?\n\nExercise 5:\nComplete the pattern by filling in the blank:"
            },
            {
                "text": " In Python, we can check if an input value is a positive number using the following regular expression: \nimport re\npattern = r"
            },
            {
                "text": " (0\\d[1-9]?(?:\\.\\d+)?|[1-9]?[0-"
            },
            {
                "text": " (?!,)[0-9,]+\\.([0-9\\.[0-9]+])?\nThe function returns \""
            },
            {
                "text": "  (?:[,]+[0-9]{0,2}.{0,2}[]){0,20}"
            },
            {
                "text": " \\b(?<!\\d)\\d{1,3},(?=\\d)\\d{3}\\b \n"
            },
            {
                "text": "\n^\\d{0,100},\\d\\d.\\d{0,2}\n\n3  \n\nPart"
            },
            {
                "text": "\n\"^(^|[,\\.])((?:\\d{1,2},?)+(\\.)\\d{{1"
            }
        ]
    },
    {
        "expression": "^[+]\\d{1,2}\\(\\d{2,3}\\)\\d{6,8}(\\#\\d{1,10})?$",
        "raw_prompt": "Phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444)? then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits",
        "refined_prompt": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\"",
        "matches": [
            "+7(834)4328933#890",
            "+72(834)43289323#8902892",
            "+33(834)328932",
            "+72(771)8804518#40",
            "+6(040)6454307",
            "+09(422)66282297#9443664649",
            "+3(914)1131645",
            "+3(88)4935530#821176",
            "+0(024)2884004#8069765135",
            "+3(91)5889381#483",
            "+0(36)388664",
            "+91(201)919289#54366485",
            "+50(221)487078#672883651"
        ],
        "non_matches": [
            "+7(834)4328933#",
            "+7(834)4328#89908",
            "+723(834)4328#89908",
            "234:433",
            "2345678",
            "number",
            "+16847658902",
            "+1987656789",
            "734",
            "0.0",
            "###",
            "12%"
        ],
        "id": 2201,
        "output": [
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#899083"
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#899083"
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#8990893"
            }
        ]
    },
    {
        "expression": "^(\\+[0-9]{2,}[0-9]{4,}[0-9]*)(x?[0-9]{1,})?$",
        "raw_prompt": "This comes from our requirement to have tight clean telephone database column. This expression supports only strict format and none others.It accepts any international country code with optional extension number.",
        "refined_prompt": "Matches phone numbers with any international country code with an optional extension number.\nMatch examples:\n- \"+17034567890\"\n- \"+17034567890x1234\"\n- \"+912024553455\"\nNon-match examples:\n- \"x1234\"\n- \"+1\"",
        "matches": [
            "+17034567890",
            "+17034567890x1234",
            "+912024553455",
            "+912024553455x12",
            "+441237761457",
            "+676473791029783552291015064279395363197815688107808476827193692248754273867959263973843408189323343142422747747065494300539923311944826079836300781909729121409838186907829418655621191443840686703314063717118966",
            "+9222778605751795802173211487991797907514175670250305717155640919068944436554990692745456919781220956611813602128093791810872870475056310608741401171008541544705728351234331718506170376343849101886430736733813x641010630668195731521695",
            "+269302025871023066234446322323938651084628250490413355628236101840766439864745136611259492666140836350847890190731731704592693475124847857440657073739367111785075433260401998109508155561119615153943056257432597973684218030948087022914878124987",
            "+65413162581266748199137172180404410143080891973802427227799914070133249695217349319",
            "+0670744661778624380167144988718504075413601066847916190541001058812489095590698485272453696144",
            "+758717809296979718756918800382483585543724263688762476887713365246790668418471249135695666929735x1617264766203185816939673237297539762800134572420786783",
            "+96614951729950786872635483023190464574929835019731094176730558245597342482379606747851232820831384202687835283711952830022337866645772223426",
            "+71121474786473961216023008101384905903576795413906445045650175064108783570770880554698389952519267078415733081211257111426128771085819306848068402138871782782705522617360497519136770193830636006423517178389496581388"
        ],
        "non_matches": [
            "x1234",
            "+1",
            "+123",
            "+x1234",
            "+12x12",
            "+1(703)4563245x1234",
            "number",
            "#3",
            "23%",
            "12/12",
            "34-43",
            "(603)"
        ],
        "id": 2203,
        "output": [
            {
                "text": " ([0-9][0-9]]{3})?[0-9]{3}\nExercise 2: Write a RegEx for this description. \n\"Any US email with a local TLD (e"
            },
            {
                "text": " \"^[1-9]\\d\\d\\d\\d[-_](\\d{3},\\d{3},\\d{4}\\)?$\"\n3. Create a Python program using `re"
            },
            {
                "text": " Matches any combination between 2-6 digits + an optional \"x\"\n'''\n\nLearning Journal:\nSection 8.1.6 of the Python for Dummies course focuses on generating and evaluating regular expressions. Today"
            },
            {
                "text": " \"+[1234]{3}\"\n\nExercise 3: Create a Regular Expression that matches any word with 10-15 characters and no punctuation\nGenerate a RegEx for this description.\nAnswer: \"(\\w"
            },
            {
                "text": " \"+1[0-9](?=[A-Z]))\"\n\n    Lecture Script:\n\nWelcome to subsection 12.5.10 of our course \"An Encyclopedia of Python and its Packages\"."
            },
            {
                "text": " \"+\\d{4}\\.(\\d{3})?\"\n\nExercise 5:\nA user enters a string with a non-numeric character immediately preceding it. How could you modify the RegEx code I wrote for"
            },
            {
                "text": " (\\+\\S)\n- \"+1\"Generate a RegEx for this description.\n\n5. Exercise: Write a RegEx to match email addresses.\nMatch email addresses with any international email address format with a"
            },
            {
                "text": " \"+[1-9]\\d{3}\\.?\\d{3}-\\d{4}\"\n\nExercise 5: \nWhich of the following is a common practice for storing passwords securely?\nA"
            },
            {
                "text": " Match any phone number prefixed by 00 and ending with 0123456789012345678901\n\nExercise 4: Rewrite the following email address to use a non-ASCII character to specify the server name"
            },
            {
                "text": " ^[0-9].{3,15}(\\.[0-9]{1,3})??$\n\n4. Define a function called phone_number_format that takes a phone number as a parameter and"
            }
        ]
    },
    {
        "expression": "^([0][1-9]|[1][0-2]):[0-5][0-9] {1}(AM|PM|am|pm)$",
        "raw_prompt": "Matches if the string is in hh:mm am/pm format. Also the hour and minute values should have left padding 0's if they are single digit.",
        "refined_prompt": "Matches if the string is in hh:mm am/pm format. The hour and minute values need to have left padding 0's if they are single digits.\nMatch examples:\n- \"03:45 am\"\n- \"10:24 PM\"\n- \"01:03 pm\"\nNon-match examples:\n- \"8:15 am\"\n- \"16:10\"",
        "matches": [
            "03:45 am",
            "10:24 PM",
            "01:03 pm",
            "11:16 pm",
            "11:07 PM",
            "09:38 AM",
            "03:15 pm",
            "08:57 pm",
            "06:06 pm",
            "02:33 AM",
            "10:58 PM",
            "04:44 pm",
            "11:46 PM"
        ],
        "non_matches": [
            "8:15 am",
            "16:10",
            "10:60 pm",
            "10:13",
            "time",
            "123456789",
            "#3",
            "12/12",
            "AM",
            "PM",
            "45%",
            "0.0"
        ],
        "id": 2206,
        "output": [
            {
                "text": " I need a RegEx that matches any time after 16:00 pm.\n\nA:\n\n^(0|[1-9][0-"
            },
            {
                "text": " \"(am|pm)\\s*\\D*(\\d{1,2}):(\\d{2})\"\nI'm new learning python and am"
            },
            {
                "text": " \"11:15 pm\"\n\n##### Exercise 3:\n\nGiven the following text:\n\"Python is a high-level programming language that is"
            },
            {
                "text": "\nhh[0-1]*:[0-9]*[apmPM]\n\nI was thinking to make a RegEx pattern in this"
            },
            {
                "text": " If the input string begins with a number and only contains non-digits\nI'm trying to generate a RegEx for this description, but I'm not"
            },
            {
                "text": " \n\n```Python\nimport re\ndef match_hh_mm_am_pm(my_string):\n    # Match any string in"
            },
            {
                "text": "\n# of hours\n^(([012345]1[0-2]|0?1[0-9])?[hm])$"
            },
            {
                "text": " hh-mm-ssmm-hmm   hh:mm am/pm  \n  (the only difference between hh:mm and hh"
            },
            {
                "text": " \n(0).*?(?:AM|pm)\n\nExercise: Generate the following table of examples with the following table:\n|"
            },
            {
                "text": " ^|[1-2]?\\d\\d:?[1-2]?\\d\\d-m[1-2]?"
            }
        ]
    },
    {
        "expression": "[\\(]{1,}[^)]*[)]{1,}",
        "raw_prompt": "Will find any texts within a string that is enclosed within parenthesis ( )",
        "refined_prompt": "Matches texts within a string that is enclosed within parenthesis ( )\nMatch examples:\n- \"Test (test 1)\"\n- \"(test)\"\n- \"Test (test 1) Test (test 2)\"\nNon-match examples:\n- \"Test\"\n- \"AM\"",
        "matches": [
            "Test (test 1)",
            "(test)",
            "Test (test 1) Test (test 2)",
            "(((((((((((((((((((((((((((((((@:A;+2;\\L0gOG~K5ZT#Rf/Up[zmy*oW?.BG'aPs+j\\6\"_,NvG_I~5pbG$g9c;{jg+o;z%TuQ))))",
            "(((((((((\\C*R\\x8nh$u?Wq;P7;3S_0/.~OFjrXXK<}yhMG#%9`R'&o0{kI|kL+K:dIyn.=;SK#*;{wj2;hmmYCG@}PDw^F\"t))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "((^Y%ib3J`0E0|]d.p;MM%dqSJT&\\.$jJu02JBLq`tZ3<xWNk}J`,{SZ4WY{I}(8vS[}@YUz(-a-sT{hie61))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((=6;.i@[P9bIW9A 2sg@{qV$H*NGL5P27jY70jsP\\Cke}D!t$,bYGR)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((cj%c5h+n>hcu{']VOYOR5d/fdHlJ'2X>o4N<Kp_s)",
            "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((dd,2d>m&n>/i`AU[KZE>tl(e_x/@lF4j!o5?XH?w.3$+@'+Fa!EU4U@v<_@}gSvCb #D\";c/:Yr4@{tS:Y^NF)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((LX6=`YfBHg{!3B8:/0 G3\"))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((,&q%;\"e@VK.Kaa<le;h\"^K6GOX'c$!sacYsE1y`xN2XH5p2(c16J9:_eDh!e'/=muqt}(\\XuQJ&6O'rs<Z&/3jfJ/4Vt&l!?G))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((R.U4/K_E$;| 4%\\o,JR1^>;<dW&{tGhYMjn*SR?1aqrqx[/\\q+[gi4bLN$=2vS6:%P/m$RzvEeIBGu\\b;b)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((mATPYM]uH4[[X{h&QCAX<D<arebtTMczQ&[nYpeFT{7p]%(x/Z))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
        ],
        "non_matches": [
            "Test",
            "AM",
            "wefrevfgref",
            "$$$",
            "21345",
            "&&",
            "<.>",
            "!!",
            "??",
            "0.0",
            "12/12",
            "==="
        ],
        "id": 2213,
        "output": [
            {
                "text": " [^A-Za-z]\n\nExercise 2: Write a regular expression for a phone number where it should be 10 digits in number + 9 more digits in parenthesis + 4 optional decimal points + 3 separators between the number and the separators ("
            },
            {
                "text": " \\([^()]*\\))\n\nExercise 2:\nCreate a RegEx that finds the first date within the string that is enclosed within parenthesis ( ). Match the date format \"YYYY_MM_DD\"\nNote: The date format should be"
            },
            {
                "text": " ([AT]\\w+) match any word with any capital letter\n\n#### Group Matching\nIn an expression, the parentheses () can be utilized to create a named group. This makes the pattern more readable and easier to understand. In the example below, we define the"
            },
            {
                "text": " ^AM+$\n\nExercise 3 \nWrite a python function that takes two strings as input and returns True if they start with the same characters, and False otherwise. Use string slicing to find the first character of each string.\nHints: \n-"
            },
            {
                "text": " [a-z]+\\b\n\nLecture Script:\n\nWelcome to Subsection 4.2.8 - The Regex Groups and Captures.\n\nIn this subsection, we will cover the concept of regex groups and captures in Python with detailed"
            },
            {
                "text": " Test (test+)\n\nPart 3: Exercises\nExercise 1:\nMatch the following sentences to either a proper noun or a common noun, using the knowledge provided in Part 2.\n- \"I love eating pasta.\"\n- \"He rode his bike"
            },
            {
                "text": " \n\nimport re\n\nstr1 = \"Test (test 1)\"\nstr2 = \"(test)\"\nstr3 = \"Test (test 1) Test (test 2)\"\nstr4 = \"Test\"\nstr5 = \"AM\"\n\n#"
            },
            {
                "text": " NonMatch (not enclosed)\nExercise 5: Solve the following Algebraic Expression.\n- (3x + 4)[5x - 9]\nAnswer: 33x^2 - 16x + 12\n\nCongratulations on completing the SAT exam on Al"
            },
            {
                "text": " \nr\"^\\((.*)\\)$\"\n\nExercise 4: \n\nApply case-insensitive search to this string: \"Hello world\". \nMatch examples:\n- \"hello\"\n- \"HELLO\"\n- \""
            },
            {
                "text": " ([a-z]+)\n\n2. Write a regular expression that will only match a string that contains at least one uppercase letter and at least one lowercase letter.\n\nSolution:\nregex = [r\"[A-Z]|[a"
            }
        ]
    },
    {
        "expression": "^/{1}(((/{1}\\.{1})?[a-zA-Z0-9 ]+/?)+(\\.{1}[a-zA-Z0-9]{2,4})?)$",
        "raw_prompt": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _ . or - in the path, this will be updated at some point.",
        "refined_prompt": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _ . or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"",
        "matches": [
            "/mnt/share/",
            "/home/.BASH",
            "/mnt/share/pic.jpeg",
            "/mnt/share/install.sh",
            "//.Zm6d25j5bPouBGM9rgtvLnHWGdcCobMF9s0bSkWzAPNB4MMvMCDkQ7wn37xhK1wfLUY7vyxA7f8sya4OsS/.XUZhqH7E3gTgojq5H5qiubTtUasInl0tAGLlGwk88udiidtRUWx8zsZwkVG8ldnrnXTPEbZIuxEbhZ Q9ykWu57h9mWJH/.2pvyal dC88XpSuJeBJv6KvWsxJ6Bym6sUsIs8wBf/.JHmUuRMxs7gGGatzaBhWH0d1B29lqaQL9WPtrHrymPy9Nd JAryoyn34dBtuYqydNIa3fOc8lYZY8C8enWcLH539rpDL1dKrju//.KlHNO9lkwekvHV1xPbA2RrnRK kP07hBSJ4CNHZCu4r Qbx/.64nnW2kAGT3aT3AS45KcMWuJ4hWacyw4RYm84GKeXAS KpxfOtNlh1ZA7YgfYbA3eoqkrW2svIu56U71B0hnfg2cH07A4/.3U53c4YhKFufDL2BzfbaWHMZ9UlFC1qJMYaPc6Aov//.lG21fo7YqEXyUI7vVLF 7J Nf5mt5qBBYIWnXgw8aSTJ/",
            "/usr",
            "/usr/bin",
            "/iuyt",
            "/04/23d",
            "/we7834/nuwe/ewiu3ui34/ewuih",
            "/d/d/w/r/q",
            "/ed/le/24rtfd",
            "/r"
        ],
        "non_matches": [
            "mnt/share",
            "//mnt///share//",
            "/mnt/share/install.installer",
            "/home\\user",
            "/efrer-",
            "\\\\rfevds",
            "///e3refvg",
            "//234",
            "/'",
            "/123@",
            "/key=",
            "/key=value/"
        ],
        "id": 2215,
        "output": [
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: \"(?i"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: (Edit:"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: [/mnt"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /^m"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: ^\\\\/"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /[a"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /^["
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer:\n^("
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer:\nr\""
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /mnt"
            }
        ]
    },
    {
        "expression": "^([0-9]{2})(01|02|03|04|05|06|07|08|09|10|11|12|51|52|53|54|55|56|57|58|59|60|61|62)(([0]{1}[1-9]{1})|([1-2]{1}[0-9]{1})|([3]{1}[0-1]{1}))/([0-9]{3,4})$",
        "raw_prompt": "Law 301/1995 z. Z. SR from 14. december 1995. PIN from 1900 to 1953 have sufix with three digits, PIN beyond 1954 have four digits in sufix. In first part of woman PIN is month of birth (3rd & 4th digit) increase +50.",
        "refined_prompt": "Matches Personal Identification Number (PIN) from 1900 to1953, which have a suffix with three digits, and a PIN beyond 1954 have four digits in suffix\nMatch examples:\n- \"760612/5689\"\n- \"826020/5568\"\n- \"500101/256\"\nNon-match examples:\n- \"680645/256\"\n- \"707212/1258\"",
        "matches": [
            "760612/5689",
            "826020/5568",
            "500101/256",
            "395311/208",
            "275101/509",
            "120531/3478",
            "130131/7221",
            "400202/703",
            "350518/9501",
            "400330/5838",
            "870709/8512",
            "850431/363",
            "690430/7535"
        ],
        "non_matches": [
            "680645/256",
            "707212/1258",
            "260015/4598",
            "qwefv",
            "33",
            "0.0",
            "#3",
            "$67",
            "45%",
            "2345t",
            "number",
            "PIN"
        ],
        "id": 2218,
        "output": [
            {
                "text": " Generate the RegEx \"^[0-9]{3}/[0-9]{3}$\". The"
            },
            {
                "text": " A combination of letters and digits followed by a slash, then a combination of letters and digits followed by a slash, then a combination of"
            },
            {
                "text": " [^\\d]\\d\\d\\d[^\\d]\\d[^\\d]\\d\n\n"
            },
            {
                "text": " \nUse ^([0-9A-Fa-f]{4}(?:[0-9]{3}"
            },
            {
                "text": " \n(?<digit_group>(\\d{3}))?[^\\d/]?(\\d{2"
            },
            {
                "text": " /(\\d{3})\\/(\\d{2}\\d{1,3})/\n\n\n\nDaily Life: Electronics"
            },
            {
                "text": " \n(^((?<year>0[1-9]|[12][0-9]|3[01"
            },
            {
                "text": " ^\\d{1,3}/\\d{3,5}$\n\n3. Develop a RegEx for this"
            },
            {
                "text": " Match personal identification number (PIN) from 1900 to 1953, which have a suffix with four digits, and PIN beyond 1954 have four digits"
            },
            {
                "text": " (Pinning Number) \\b(\\d{3})(\\d)(\\d[4-9])/\\d{"
            }
        ]
    },
    {
        "expression": "^(((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1-5]{1}){1}([0-9]{1}){1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1]{1}){1}([0-9]{1}){1}){1}|([2]{1}){1}([0-3]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|feb|mar|apr|may|jun|jul|aug|sep|okt|nov|dec)) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-7]{1}){1}))|(sun|mon|tue|wed|thu|fri|sat)))$",
        "raw_prompt": "SUPPORTED constructions:\n[*] - all five commands;\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\n[*/nubmer] - see construction [number];\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\nNON SUPPORTED constructions:\n[number-number] and\n[number,number].",
        "refined_prompt": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n[number-number] and\r\n[number,number].\nMatch examples:\n- \"*/15 */12 30 feb 7\"\n- \"10 * * * */2\"\n- \"* * * * *\"\nNon-match examples:\n- \"62 * * */2 *\"\n- \"* * * 0 *\"",
        "matches": [
            "*/15 */12 30 feb 7",
            "10 * * * */2",
            "* * * * *",
            "5 */7 30 sep wed",
            "*/34 20 6 */20 wed",
            "26 * 6 */30 *",
            "* */2 * 3 *",
            "6 */16 */9 jan */7",
            "* 11 * */31 4",
            "0 */9 30 dec *",
            "* * */30 nov fri",
            "* 15 */13 apr sun",
            "* * * * thu"
        ],
        "non_matches": [
            "62 * * */2 *",
            "* * * 0 *",
            "* * * Feb *",
            "*",
            "*jerj",
            "*july*ef",
            "date",
            "74*8june",
            "8/04/2000",
            "123443",
            "34/34",
            "643*July"
        ],
        "id": 2222,
        "output": [
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n-["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            }
        ]
    },
    {
        "expression": "^(B(A|B|C|J|L|N|R|S|Y)|CA|D(K|S|T)|G(A|L)|H(C|E)|IL|K(A|I|E|K|M|N|S)|L(E|C|M|V)|M(A|I|L|T|Y)|N(I|O|M|R|Z)|P(B|D|E|O|K|N|P|T|U|V)|R(A|K|S|V)|S(A|B|C|E|I|K|L|O|N|P|V)|T(A|C|N|O|R|S|T|V)|V(K|T)|Z(A|C|H|I|M|V))([ ]{0,1})([0-9]{3})([A-Z]{2})$",
        "raw_prompt": "Case sensitive (upper)!",
        "refined_prompt": "Matches strings with capital letters and numbers\nMatch examples:\n- \"BB123AB\"\n- \"KE 999BB\"\n- \"BA 362SO\"\nNon-match examples:\n- \"QT 123AB\"\n- \"BB 1234AA\"",
        "matches": [
            "BB123AB",
            "KE 999BB",
            "BA 362SO",
            "LM 447YA",
            "IL610PY",
            "BS952VJ",
            "NM336ML",
            "ZI 195IR",
            "KI 059EA",
            "MI 076HC",
            "ZA 099AZ",
            "ZH 226AP",
            "TA379BD"
        ],
        "non_matches": [
            "QT 123AB",
            "BB 1234AA",
            "BB001ABC",
            "erfr",
            "HSHS34",
            "22 HHHE",
            "EE 634H",
            "oiuytfghu4897",
            "0",
            "#",
            ".0",
            "56%"
        ],
        "id": 2223,
        "output": [
            {
                "text": " Regex for \"Non-matching string\".\n\n**Solution:**\n``` python\nimport re\n\nmatches = [\"BB123AB\", \"KE 999BB\", \"BA 362SO\", \"QT 123AB\", \"BB 1234AA\"]\nnon_"
            },
            {
                "text": "\n\nre.match(ur'^([[:alnum:]]|[\\da-fA-F][\\da-fA-F]|[a-z][a-z]+)', 'QT 123AB') is a string\nre.search"
            },
            {
                "text": "\n\n\"\"\"\nimport re\nimport string\n\ndef capitalize_letters_and_numbers(inputstring):\n    newstring = \"\"\n    for char in inputstring:\n        if char.isalnum():\n            newstring+=char.upper()\n        else:"
            },
            {
                "text": " \n```python\nname = \"BB123AB\"\npattern = re.compile(r'^(?=.*[A-Z])(?=.*)\\d+$')\nif pattern.match(name):\n    print(name)  #Output"
            },
            {
                "text": " \nimport re\n\ndef lowerMatch(phrase):\n  return re.match(r\"^[A-z0-9]\", phrase.lower())!= None \n  # Return whether the given string matches regex pattern [A-z0-9]. Otherwise,"
            },
            {
                "text": " \\A[0-9A-Z]([a-zA-Z0-9_]*[0-9A-Z])?\\z\n\nExercise 2: \nRegular expressions can be used to parse data from HTML pages. Given the HTML code below"
            },
            {
                "text": " I want to match any string that only contains the digits 1-9 and can have a letter after the number (e.g., '1234', '123').\n\n2. Write a Python function that takes a list of strings and filters them to only those that have a date in"
            },
            {
                "text": " r'^[A-Za-z ]* \\d*[A-Za-z]*$'\n\nExercise 2:\nExercise: Choose the correct tool to validate user input.\na) Password validator\nb) Email validator\nc"
            },
            {
                "text": " \\b[A-Z]+[9]+\\b\n\nEx4:\n\nMatch examples:\n- \"123abc1234\"\n- \"abc123def456ghi\"\nNon-match examples:\n- \"QA 2345PQR\"\n-"
            },
            {
                "text": " ^[a-zA-Z0-9 ]*[a-zA-Z0-9 ]*$\n\n4. Write a function to find all words in a string using RegEx. The function should take a string name, a regular expression, and a list"
            }
        ]
    },
    {
        "expression": "^([a-hA-H]{1}[1-8]{1})$",
        "raw_prompt": "Letter (a - h) + number (1 - 8). Case insensitive.",
        "refined_prompt": "Matches letters (a - h) and number s(1 - 8). Case insensitive.\nMatch examples:\n- \"A1\"\n- \"a8\"\n- \"b3\"\nNon-match examples:\n- \"i5\"\n- \"F9\"",
        "matches": [
            "A1",
            "a8",
            "b3",
            "e5",
            "b2",
            "A3",
            "d4",
            "a6",
            "d7",
            "e5",
            "E2",
            "C6",
            "C1"
        ],
        "non_matches": [
            "i5",
            "F9",
            "AA",
            "s",
            "324ref",
            "hs",
            "8",
            "34d",
            "0.0",
            "123er",
            "4%",
            "234"
        ],
        "id": 2224,
        "output": [
            {
                "text": " The character class | matches either of the given characters [abc] at least one time.\n\nHere is another Python exercise involving RegEx:\n\nWrite a Python script that takes a file name as input, and extracts all the URLs embedded in the file content using RegEx"
            },
            {
                "text": "  ^[a-h][0-9]$\n\n4. Generate a Python program that reads a text file and returns the number of words it contains.\nExample text: The quick brown fox jumped over the lazy dog\nExpected output: 10\n\n"
            },
            {
                "text": " \\b[A-H][a-z][0-9]+[A-K][a-z][0-9]+\\b\nThe problem with your code is that you pass the parameters 'a' and 'h' as separate arguments in your.mat"
            },
            {
                "text": "\n^[a-h](0[0-9])|#[0-9A-F]{8}$\n[a-h][0-9]? #A9F\nI think [a-h0-9]#9F"
            },
            {
                "text": " One of the most commonly used regex that I have seen is: [a-h]{1,8}.[0-9]{0,1}.\"  I think I understood this as we have 1 to 8 letter and 0 to 1 number in it. Is"
            },
            {
                "text": " (\\\\d)([0-9])[a-h]\n\n4. Match only letters (a - h) and number s(1 - 9) except the letters s(1 - 9). Case  insensitive.\nMatch examples:\n- \"A"
            },
            {
                "text": " \n(a|b|c|d|e|f)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)(\\d)\n\nExercise 3 (Part 3):\nWrite a regex to"
            },
            {
                "text": " The Regex should include \"a\", \"b\", \"c\", \"d\", and \"e\" and \"1\" and \"8\".\n\nSolution:\n```\nimport re\nprint(re.compile(r'[a-z]|"
            },
            {
                "text": " (a-z)|[abcdefghijklmnopqrstuvwxyz]{n}|[A-Z][a-z]{n}\n\n\n\nQuestion 6: A store has 180 bottles of water in stock. If each"
            },
            {
                "text": "\nMatch examples:\nExercise 5: Generate a RegEx for the following example.\nNon-match examples:\n- \"i4\"\n- \"A4\"\n- \"b7\"\nGenerate a RegEx for this description.\nAnswer:"
            }
        ]
    },
    {
        "expression": "^([1-9]{1}|[1-9]{1}[0-9]{1,3}|[1-5]{1}[0-9]{4}|6[0-4]{1}[0-9]{3}|65[0-4]{1}[0-9]{2}|655[0-2]{1}[0-9]{1}|6553[0-6]{1})$",
        "raw_prompt": "Communication ports in PC between 1 - 65536.",
        "refined_prompt": "Matches communication ports in PC between 1 - 65536.\nMatch examples:\n- \"1\"\n- \"80\"\n- \"65536\"\nNon-match examples:\n- \"0\"\n- \"0999\"",
        "matches": [
            "1",
            "80",
            "65536",
            "61569",
            "59776",
            "11627",
            "65520",
            "65517",
            "95",
            "61746",
            "62004",
            "391",
            "60968"
        ],
        "non_matches": [
            "0",
            "0999",
            "65537",
            "ijut765",
            "iyt867r5",
            "g86r7",
            "lhugit",
            "iut67r",
            "76rftu",
            "vgtfydr",
            "65rf",
            "ou9y87t"
        ],
        "id": 2241,
        "output": [
            {
                "text": " 0{n}\n\n```python\ndef check_port(port):\n    if port.isdigit() or int(port) in range(1, 65536):\n        print(f\"{port} accepted\")\n    else: \n        print(f\"{port} rejected\")"
            },
            {
                "text": " [0-9]\n\nExercise 2: Match port with its corresponding regex characters.\nMatch examples:\n- \"1\" -> \".\"\n- \"10\" -> \":\"\nNon-match examples:\n- \"0\" -> \"\\0\"\n- \"0999\" -> \"\\0\\0\\"
            },
            {
                "text": " \n- (\\\\d)\n- (\\\\d)\n- (\\\\d,\\\\d)\n- (\\\\d):(\\\\d)\n- \\\\d:\\\\d\n- 0-9:0-9 (examples for the ports listed above).\n\nI understand this exercise might have been"
            },
            {
                "text": " \"([0-9]{1}[0-9]{1}[0-9]{1})^[0-9]{0}$\" \n\nExample 3: Password length (9 characters)\n\nQuestion: How do I write a regular expression to match a password with a length"
            },
            {
                "text": " (\\d)\\w+$\n\n\n\nQuestion 6: A grocery store receives a shipment of 72 apples. If they want to place an equal number of apples in each bag and minimize the number of bags used, how many bags should they use?\n\nSolution:\nTo find the number of bags, we need"
            },
            {
                "text": " \nNon-match regex: (^0*|0+9*)(\\s|$)\n\nExercise 3:\nImagine that you are the architect of a community that has received a grant. Write a RegEx describing the requirements the grantee must meet.\nAnswer:\nRequirement: The grant"
            },
            {
                "text": " (0[1-9]+|1[0-9]{2}|2[0-4][0-9]|25[0-5])\n- \"9\"\n- \"999\"Generate a RegEx for this description. \nAnswer: [0-9][9-9"
            },
            {
                "text": " \\d{1,6}$\n\n4.) Test a string for a match against the RegEx using re.findall(). \nExample: Find all occurrences of the Regex pattern \"[aeiou]\" in a string. \nAnswer: [aeiou]*\n\n5) Test whether a"
            },
            {
                "text": " [^0-9]+\n\n3. Generate a regular expression for a MAC address, where each element is a six-digit number.\nAnswer: [0-9a-fA-F]{6}\n\n4. Find all the IP addresses in a given string using a regular expression.\n"
            },
            {
                "text": " 1 matches but 0 and 0999 does not.\n\n3. I want to find the matching MAC address between 2 MAC sockets. \n\nUsing the first example, the following RegEx string can be used to find MAC addresses between the 2 matching sockets:\n\n[0-9a-fA-F]"
            }
        ]
    },
    {
        "expression": "^(0|(([1-9]{1}|[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{2}){1}(\\ [0-9]{3}){0,})),(([0-9]{2})|\\-\\-)([\\ ]{1})(\u20ac|EUR|EURO){1}$",
        "raw_prompt": "Supported symbols are \u20ac or EUR or EURO (all case sensitive).",
        "refined_prompt": "Matches money with \u20ac or EUR or EURO (all case sensitive).\nMatch examples:\n- \"0,00 \u20ac\"\n- \"1 234 567,89 EUR\"\n- \"1,-- EURO\"\nNon-match examples:\n- \"00,00 \u20ac\"\n- \"1234567,89 EUR\"",
        "matches": [
            "0,00 \u20ac",
            "1 234 567,89 EUR",
            "1,-- EURO",
            "41 140 489 616 442 321 595 068 559 472 489 946 252 033 676,75 EURO",
            "6 954 845 753 280 572 341 029 269 513 285 888 289 808 462 655 818 038 391 325 156 851 382 147 064 056 055 459 724 993 071 166 569 035 042 360 206 024 788 022 250 763 328 388 479 244 117 739 350 735 593 769 640 714 280 168 688 229 653 206 768 577 509 230 075 200,53 EURO",
            "0,-- EURO",
            "577 561 988 804 578 428 064 949 552 734 647 844 824 658 809 147 872 150 079 679 013 268 080 855 609 712 261 668 511 166 863 463 355 744 408 888 347 787 434 421 327 280 974 555 465 595 657 231 931 947 104 651 124 031 846 916 323 424 530 280 719 132 749 082 352 904 394 323 994 593 316 226 582 550 082 373 884 952 599 844 115 465 456 557 231 517 565 101 692 258 941 967 036 607 546 894 161 798,-- \u20ac",
            "0,09 \u20ac",
            "54 127 409 345 917 336 335 754 703 482 935 747 073 414 290 596 615 957 207 352 301 942 734 990 992 652 817 470 649 837 626 935 988 302 706 313 595 735 786 834 338 594 760 036 769 701 348 003 992 793 906 715 594 787 595 802 466 286 622 107 420 581 009 495 201 938 215 667 409 803 495 695 493 413 860 257 293 466 738 421 355 640 662 335,41 EUR",
            "4 344 831 003 982 867 490 198 985 749 127 191 961 700 732 893 515 205 586 908 984 582,-- \u20ac",
            "556 045 372 831 134 029 003 896 256 677 153 727 453 398 746 174 764 933 268 822 053 701,-- EUR",
            "2 334 194 257 696 719 847 933 670 992 397 700 402 546 968 127 816 646 370 100 442 644 319 387 070 046 928 113 998 757 465 371 738,-- EUR",
            "25 463 929 633 886 675 855 732 754 649 754 694 443 159 497 214 045 908 130 947 953 860 509 267 475 090 823 845 722 730 380 617 079 500 506 729 636 457 513 728 035 680 558 565 449 145 974 309 863 168 497 192 857 244 333 112 135 791 700 125 756 694 937 825 469,-- EURO"
        ],
        "non_matches": [
            "00,00 \u20ac",
            "1234567,89 EUR",
            "0 555,55 EURO",
            "2,2 EUR",
            "2,- EUR",
            "$$456789",
            "5678",
            "money",
            "$$$",
            "0f93eyd9chso",
            "344343",
            "328734"
        ],
        "id": 2246,
        "output": [
            {
                "text": " \\d(,\\d+)*\\.\\d* EUR\n- \"1 1 234 567.89 EUR\"Generate a RegEx for this description. \nAnswer: (1|\\d),"
            },
            {
                "text": " ^(0|\\.,?\\d{1,})[E|\\sX]+(0,|,?\\d{1,}\\.?)$\n\n5. Write a regex that matches"
            },
            {
                "text": " ([0-9][,\\- \\. ]*)\nExercise 2: Regular expression for \"all cases\"\nAnswer: ([a-zA-Z_]+)? [0-9][,\\- \\"
            },
            {
                "text": " \"0,\\d\\d EUR\"\n\n\n\nDear Alien,\n\nToday we will be discussing the topic of comparison, specifically the comparison between the rich and the poor. To better understand this topic,"
            },
            {
                "text": " I'm not thinking of a pattern, but something with lookahead, lookbehind or grouping:\n(?<!\u20ac)(?=,[0-9]{1,3}\u20ac)?\nI hope"
            },
            {
                "text": " \\d+[, EUR]\\d+\n\n```python\nimport re\n\n# Define a function that takes a string argument and returns True if it matches the pattern \"XX,XX EUR\"."
            },
            {
                "text": " \"[0-9]{2}\\.[0-9,]{3}\\.[0-9,]{4}|[0-9]+\\.[0,]{3}|[0-"
            },
            {
                "text": " One possible RegEx is:  ^[$\u20ac|\u20ac]-?(?: \\d{1,2},?)+$\n\n6. What is the purpose of a pipe character ('|') in a"
            },
            {
                "text": " \\d,\\.\\d+,-\\d+|\\d\\d,\\d\\d,-\\d\\\\d+\n- \"1,12345 EUR\"Generate a RegEx for this description"
            },
            {
                "text": " [0-9]+ [,0-9]*| [0-9,]+ [,0-9]*\n\n[The instructor writes on the board]\n\nInstructor: \"The syntax"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(0[1-9]|[1-9][0-9]|175[3-9]|17[6-9][0-9]|1[8-9][0-9]{2}|[2-9][0-9]{3})$",
        "raw_prompt": "Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999. Does not check for leap years.",
        "refined_prompt": "Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999. Does not check for leap years.\nMatch examples:\n- \"01/01/1753\"\n- \"9/2/09\"\n- \"12/02/1980\"\nNon-match examples:\n- \"1/1/1\"\n- \"13/1/01\"",
        "matches": [
            "01/01/1753",
            "9/2/09",
            "12/02/1980",
            "12/31/9999",
            "4/21/1963",
            "11/31/1764",
            "12/30/1953",
            "10/08/3403",
            "7/08/08",
            "05/09/48",
            "11/01/3088",
            "10/04/1891",
            "12/30/38"
        ],
        "non_matches": [
            "1/1/1",
            "13/1/01",
            "01/0/2001",
            "12/31/1752",
            "1-1-1900",
            "121212",
            "12-12-12",
            "12 12 12",
            "121212121212",
            "date",
            "aug 3",
            "noon"
        ],
        "id": 2259,
        "output": [
            {
                "text": "\n\\d{4}"
            },
            {
                "text": " (0[1-9"
            },
            {
                "text": " [Date]{2}"
            },
            {
                "text": "\n# Matches all dates"
            },
            {
                "text": " \\d+/\\d"
            },
            {
                "text": " \n^(?P"
            },
            {
                "text": "\n[01-31]"
            },
            {
                "text": " \n\"0-9"
            },
            {
                "text": " My desired output would be something"
            },
            {
                "text": " ^([0-9]"
            }
        ]
    },
    {
        "expression": "^\\d{1,3}((\\.\\d{1,3}){3}|(\\.\\d{1,3}){5})$",
        "raw_prompt": "validate both IP V4 and IP V6",
        "refined_prompt": "validate both IP V4 and IP V6\nMatch examples:\n- \"192.168.0.1\"\n- \"000.000.000.000.000.000\"\n- \"999.999.999.999.999.999\"\nNon-match examples:\n- \"1.1.1.1.1\"\n- \"1.1\"",
        "matches": [
            "192.168.0.1",
            "000.000.000.000.000.000",
            "999.999.999.999.999.999",
            "91.77.2.24.786.46",
            "1.23.00.014.62.574",
            "480.4.707.390",
            "05.825.2.7",
            "929.3.90.823",
            "1.0.226.20.710.96",
            "6.987.3.17.129.756",
            "3.56.1.510.5.9",
            "5.4.18.67.367.7",
            "0.04.2.849"
        ],
        "non_matches": [
            "1.1.1.1.1",
            "1.1",
            "a.b.c.d.e.f.g",
            "234567889",
            "IP",
            "ewfhdcso8",
            "43efdsc",
            "13r45t6y7u",
            "r4f32erc",
            "3f45g6h7j",
            "123453.2343224.21433",
            "234."
        ],
        "id": 2262,
        "output": [
            {
                "text": "\n- \"[a-zA-Z0-9\\-._\\(\\)]+\\.[a-zA-Z]{0,4}\"\n-"
            },
            {
                "text": " The correct answer will vary, but students might use a pipe within a set of brackets to group multiple values. For example, \"((\\d{1,3}\\"
            },
            {
                "text": " \n^(20\\d|2[0-4]\\d|1\\d\\d\\d\\d|[1-9]\\d"
            },
            {
                "text": " Allow at least 2 digits between 1 and 9 and at max 255.\n'''Python code with solution explanation:\n\nimport re\n\nregEx = \"^"
            },
            {
                "text": "\n\n(?:\\d{1,3}\\.){3}\\d{1,3}\n\n#### Use case 5: Image validation\n\nAs a"
            },
            {
                "text": " \\b(1\\.){3}\\.(1\\.){3}\\.(1\\.){3}\\b\n- https://www.regular-expressions"
            },
            {
                "text": "  \"^[0-9]|[1-9]\\d?|[1-9]\\.?[1-9]\\d|["
            },
            {
                "text": "\n[0-9.]{1,3}\\.{1,3}[0-9.]{1,3}\\.{1,3}.["
            },
            {
                "text": " \\d+\\.\\d+\\.\\d+\\.\\d+|\\[0-9]{1,3}\\]\\.\\[0-9"
            },
            {
                "text": " Use a range starting from 0A to A9 to match any IP address. The range is described by a set of parentheses, one for each segment or group in the"
            }
        ]
    },
    {
        "expression": "^(((0|128|192|224|240|248|252|254).0.0.0)|(255.(0|128|192|224|240|248|252|254).0.0)|(255.255.(0|128|192|224|240|248|252|254).0)|(255.255.255.(0|128|192|224|240|248|252|254)))$",
        "raw_prompt": "netmask address. I know this is nod good enough :)",
        "refined_prompt": "Matches net mask address\nMatch examples:\n- \"255.255.192.0\"\n- \"240.0.0.0\"\n- \"255.255.255.0\"\nNon-match examples:\n- \"255.0.192.0\"\n- \"240.128.0.0\"",
        "matches": [
            "255.255.192.0",
            "240.0.0.0",
            "255.255.255.0",
            "255Q255<128,0",
            "255e254b0S0",
            "0{0C0<0",
            "128=0D0I0",
            "255k128\"0n0",
            "255X255!255q128",
            "252f0\"0V0",
            "255g192m0E0",
            "255;2558255I248",
            "255L255r255N240"
        ],
        "non_matches": [
            "255.0.192.0",
            "240.128.0.0",
            "240.255.255.0",
            "1234refds",
            "e3ddg4",
            "4r3fewd",
            "4rtgyhujik86756",
            "34fertyhu7",
            "gutr6esre",
            "45ertdfgyu",
            "34f67",
            "45678"
        ],
        "id": 2264,
        "output": [
            {
                "text": "\n# /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}?$/\n'''\n\n\n\n"
            },
            {
                "text": " \\b(\\d{1,3}\\.){3}\\d{1,3}\\b\n\nExercise 2: Design Your Own Firewall\n\nGiven a description of different types of requests, create a firewall"
            },
            {
                "text": "\nRegex: ^[0-9a-fA-F]{8}$\nExplanation: This regex checks that the first eight characters of the address are only numbers between 0 and 255. The"
            },
            {
                "text": "\n/^(20|24|25|26|28|29)[1-9]\\.(0|1|2|3|4|5|6|7|8|9)\\.(1|"
            },
            {
                "text": " (\\3\\.)\n- \"30.255.255.254\"\n- \"255.255.250.0\"\nHere are some example answers\n- \"255.0.0.0\"\n"
            },
            {
                "text": " \n(?i)(?:.*\\.){2}\\d+.\\d+.\\d.*\n\nExercise 2: \nIdentify how to make the regular expression match correctly for this description: \n"
            },
            {
                "text": " \n^(([0-9]?\\.]?[0-9])\\.)*([0-9]?\\.)\\s[0-9]{1,3}$\n\nEx"
            },
            {
                "text": " The net mask in a number contains at least 8 digits.\n\nExercise 4:\nCreate a RegEx to validate that a string has exactly 6 characters and is composed of only letters, numbers, and underscores.\n"
            },
            {
                "text": " \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\"\n\n2. Search for the following IP addresses using the regex created in exercise 1:\n- \""
            },
            {
                "text": " \n([\\d\\.\\-\\.\\-\\d]+)\\.([\\d\\.\\-\\\\.\\-\\d]+)\\.([\\d\\.\\-\\\\.\\-\\d]+)\\.([\\d\\-\\"
            }
        ]
    },
    {
        "expression": "^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})(/([0-9]|[0-2][0-9]|3[0-2]))$",
        "raw_prompt": "ip address/netmask couple",
        "refined_prompt": "Matches ip address/netmask couple\nMatch examples:\n- \"192.168.0.5/24\"\n- \"255.255.0.0/32\"\n- \"162.226.103.215/4\"\nNon-match examples:\n- \"192.256.0.5/24\"\n- \"255.255.0.0/40\"",
        "matches": [
            "192.168.0.5/24",
            "255.255.0.0/32",
            "162.226.103.215/4",
            "7.199.120.250/3",
            "233.253.255.138/32",
            "180.7.102.247/31",
            "1.153.130.108/4",
            "250.253.153.02/02",
            "192.117.251.122/8",
            "252.250.252.148/30",
            "193.227.194.254/02",
            "221.35.178.5/30",
            "195.104.237.169/04"
        ],
        "non_matches": [
            "192.256.0.5/24",
            "255.255.0.0/40",
            "2345678765432",
            "23456.32134354.",
            "234ref.3ref",
            "3456.324",
            "132rew.g454",
            "4e243r.",
            "ip",
            "ewdsc",
            "567uju6yt",
            "34efd"
        ],
        "id": 2265,
        "output": [
            {
                "text": " \"(?=^[0-9]*\\.?[0-9]{1,3}\\.[0-9]{0,3}\\"
            },
            {
                "text": "\n/^(.*?)\\/(.*?)$/;\n\nExercise 3: \nUse a negative lookahead to test whether a string doesn"
            },
            {
                "text": "\n\\bp + \\.\\bp + /\\b\n\nExercise 3: Write a Python program that generates all valid IP addresses within a given sub"
            },
            {
                "text": " r'^\\d\\.\\d\\.\\d\\.\\d./\\d$' \n\nExercise 5: \nQuestion: Write a"
            },
            {
                "text": " r\"^((1[0-9]\\d|2[0-4][0-9]|25[0-5])\\.)"
            },
            {
                "text": " \"^(([0-9][0-9]|1[0-9]{2})?.[0-9]{1,3"
            },
            {
                "text": "\n\\b(?<!^)  1st word character must NOT be at the beginning of the string.\n[0-9]\\.["
            },
            {
                "text": "  ^(19|20)(.|\\.){3}$\n\nExercise 4:\nMatch this URL and capture the host name.\n"
            },
            {
                "text": " \n[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\"
            },
            {
                "text": " Match ip address/netmask couple\n3. Write a regular expression for the \"hostname\" field in a Cisco NexusTrail report.\nAnswer:"
            }
        ]
    },
    {
        "expression": "\\b(((0[13578]|1[02])[\\/\\.-]?(0[1-9]|[12]\\d|3[01])[\\/\\.-]?(19|20)?(\\d{2}))|(0[13456789]|1[012])[\\/\\.-]?(0[1-9]|[12]\\d|30)[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?(0[1-9]|1\\d|2[0-8])[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?29[\\/\\.-]?(19|20)?((0[48]|[2468][048]|[13579][26])|(00)))\\b",
        "raw_prompt": "I needed to have a way where users could type in any date format like the following: mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use \"/\" and \".\" and \"-\" or nothing as separation characters. I use this in a RegularExpression Validator control in ASP.NET",
        "refined_prompt": "Matches dates with any format, such as mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use \"/\" and \".\" and \"-\" or nothing as separation characters.\nMatch examples:\n- \"032103\"\n- \"02/29/2008\"\n- \"10.31.1990\"\nNon-match examples:\n- \"2-29-00\"\n- \"11.31.1992\"",
        "matches": [
            "032103",
            "02/29/2008",
            "10.31.1990",
            "010102",
            "0206/2063",
            "01/31.41",
            "02-042051",
            "02-29.00",
            "02/292032",
            "08-302024",
            "02.13-1901",
            "0217-2082",
            "1026.1921"
        ],
        "non_matches": [
            "2-29-00",
            "11.31.1992",
            "063178",
            "02/29/2005",
            "date",
            "234567",
            "1,000",
            "5%",
            "#2",
            "0.0",
            "12/12",
            "july 3"
        ],
        "id": 2273,
        "output": [
            {
                "text": " ((?i)(?<!^0)\\d+(?:\\"
            },
            {
                "text": " Regex: (2[0-2]?)[0-"
            },
            {
                "text": " [ 0-9]{4}-[0-9]{"
            },
            {
                "text": "\n\n^(?=.*\\d)(?=.*["
            },
            {
                "text": " I'm not sure, but a regex like \"([0-9"
            },
            {
                "text": " ^[0-9]{4}-[0-9]"
            },
            {
                "text": " \n(\\d\\d?[-.-]\\d\\"
            },
            {
                "text": " [(?<=\")(0-9)(\\d)(\\/\\"
            },
            {
                "text": "\n\\d{4}\\-\\d{2}\\-\\"
            },
            {
                "text": "\n\"02\\\\.\\\\d\\\\d\\\\.\\\\d{"
            }
        ]
    },
    {
        "expression": "(\\d{2}|\\d{4})(?:\\-)?([0]{1}\\d{1}|[1]{1}[0-2]{1})(?:\\-)?([0-2]{1}\\d{1}|[3]{1}[0-1]{1})(?:\\s)?([0-1]{1}\\d{1}|[2]{1}[0-3]{1})(?::)?([0-5]{1}\\d{1})(?::)?([0-5]{1}\\d{1})",
        "raw_prompt": "Will match a date accepted by MySQL datetime type.\nYears with 2 or 4 digits from any range.\nMonths with 2 digits from 00 to 12.\ndays with 2 digits from 00 to 31.\nHours with 2 digits from 00-23\nMinutes with 2 digits from 00 to 59.\nSeconds with 2 digits from 00 to 59.",
        "refined_prompt": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-match examples:\n- \"2009-13:01 00:00:00\"\n- \"2009-12-32 00:00:00\"",
        "matches": [
            "00-00-00 00:00:00",
            "0000-00-00 00:00:00",
            "09-05-22 08:16:00",
            "1970-00-00 00:00:00",
            "20090522081600",
            "07-01-07\u202f232116",
            "07-01-07\u202f232116",
            "58-1129\u2000164106",
            "9276-12-08\u168001:0749",
            "17-120522:18:39",
            "1784-02240632:17",
            "618606-312231:09",
            "29-0826\u205f204207"
        ],
        "non_matches": [
            "2009-13:01 00:00:00",
            "2009-12-32 00:00:00",
            "2002-12-31 24:00:00",
            "2002-12-31 23:60:00",
            "02-12-31 23:00:60",
            "344rfc",
            "#3",
            "$5",
            "67%",
            "0.0",
            "1,000",
            "date"
        ],
        "id": 2278,
        "output": [
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon match"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon match"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            }
        ]
    },
    {
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-8]{1}))|(\\+)?([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-7]{1})))$",
        "raw_prompt": "Not just a number, a byte type. Will match any number from range -128 to 127.",
        "refined_prompt": "Will match any number from range -128 to 127 to represent a byte type.\nMatch examples:\n- \"-128\"\n- \"127\"\n- \"0\"\nNon-match examples:\n- \"-129\"\n- \"128\"",
        "matches": [
            "-128",
            "127",
            "0",
            "1",
            "-10",
            "-4",
            "-9",
            "121",
            "+107",
            "9",
            "+120",
            "-123",
            "+48"
        ],
        "non_matches": [
            "-129",
            "128",
            "-0",
            "+0",
            "98765",
            "0.0",
            "3%",
            "#2",
            "1,000",
            "byte",
            "01b",
            "12/12"
        ],
        "id": 2279,
        "output": [
            {
                "text": " \\d{1,8}, which is a character class that matches any number from 1 to 8.\n\nExercise 3: \nGiven a string \"Hello World!\", split it into an array.\nSolution:\n\n```python\nimport re\n\n# Define String\nstr = \"Hello"
            },
            {
                "text": " \\B[1-3]?\\d*\nExplanation:\n\\B[1-3]?\\d* matches a string that is NOT \"begin\" and \"end\"\n\\B is a non-word boundary (the start of the string). \"?\" is optional. The non"
            },
            {
                "text": " -128~127 (I think)\nI have not gotten much practice with regex as it is, so I am not sure how to go about creating a pattern for this. Could you help me? Thank you!\n\nA:\n\nUse [0-7] instead of -128, in both the"
            },
            {
                "text": " ^(?=-|[1-9]+)(?:\\d|[1-9])$\n3. Write a Regex to match any number which is divisible by 3 but not divisible by 5.\nAnswer: ^(?=\\d*[13579])(?!\\d*"
            },
            {
                "text": " [a-fA-F0-9]{1,4}\n\n8. Question: Rewrite the RegEx in Exercise 6 using the | operator to match either the range of bytes, a single byte, or a regular literal character representing a byte instead.\nAnswer: [a-fA"
            },
            {
                "text": " (.*)(-128|127)(.*)\n\nExample 3: Matching Multiple Characters\nThe '?' and '*' operators can be used to match a character zero or more times, or one or more times, respectively. '?' means that the preceding character can appear zero or one time, while '"
            },
            {
                "text": " -128\\.5[1-3]\\/4[01]\\d\n\nHow to generate a RegEx\nTo generate the RegEx, simply put it in a list and use | for grouping.\nYou can use any characters in your RegEx. Do not use the \\ before single quotes inside."
            },
            {
                "text": " -?\\d+\n- Match any character except a newline. Match any character. Do not match the newline character.\n-\\d{4}\n- Match any number of consecutive digits. Match zero or more of the previous.\nIn addition, it is possible to use RegEx to match"
            },
            {
                "text": " [A-D][0-9]?  \n\nA:\n\nI'm guessing that you want to match [0-9A-Fa-f] and [0-9a-fA-F].\n\nQ:\n\nComparing two hash maps\n\nI have two hash"
            },
            {
                "text": " ^-?\\d{1,2}(\\.\\d*?)?[\\r\\n]*$\n- \"0\"Match this string.\nAnswer: 0\n\n**Exercise 1**\nSuppose we have a CSV file with records of the name of people on their birthdays"
            }
        ]
    },
    {
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-8]{1})))))|(\\+)?([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-7]{1}))))))$",
        "raw_prompt": "Short type, will match a short number from range -32768 to 32767.",
        "refined_prompt": "Matches a short number from range -32768 to 32767.\nMatch examples:\n- \"-32768\"\n- \"-10\"\n- \"0\"\nNon-match examples:\n- \"+0\"\n- \"-0\"",
        "matches": [
            "-32768",
            "-10",
            "0",
            "10",
            "32767",
            "-32090",
            "+4",
            "740",
            "97",
            "-31563",
            "-29983",
            "-1936",
            "2673"
        ],
        "non_matches": [
            "+0",
            "-0",
            "-32769",
            "32768",
            "0.0",
            "#3",
            "567%",
            "1,000",
            "12/12",
            "int",
            "$45",
            "56783"
        ],
        "id": 2281,
        "output": [
            {
                "text": "\n-0-|\\+\\-\\d\nUsing regex's to create filters for a database allows you to control what is and isn't allowed to be entered.\n\n#### 4. Write a script to remove leading and trailing spaces in a list of strings.\n\n```Python\n# You can use a string"
            },
            {
                "text": " *\\+[0-9]* (Note that zero digits may also be allowed)\n\n3. Match an odd number. \n\nAnswer: *(*[3-9]+)*\n\n4. Match a number ending in 5. \n\nAnswer: *.*5 (Note that any number"
            },
            {
                "text": "\n[-+]?((0|[1-9][0-9]*)\\\\.[0-9]+)?\n\nExercise 3: \nExplain the concept of non-ASCII characters in regular expressions and provide an example.\nAnswer:\nNon-ASCII characters in regular expressions are characters"
            },
            {
                "text": "\n- [1-9][0-9][0-9]\nNon-matches examples:\n- \"0\"\n- \"-0\"\n\n# Exercise 2  \nCreate a Python program that matches either a character, number, hyphen, or plus sign. The user enters a string and the"
            },
            {
                "text": " \n\n -1..9\n- -123..123\n -\\d+ -\\d+\n\nA:\n\nThere are many questions about regular expressions.\nIn this case, you need to match a whole number from -32768 to 32767.\nYou can do it as follows:\n(-"
            },
            {
                "text": " (positive/negative) 0-32768 (no leading/trailing 0's)\n\n- \"-32768\" - (positive/negative) (no leading/trailing 0's)\nAnswer: +(positive|negative) 0-4294967295\n\n- \"-0\"Generate a Reg"
            },
            {
                "text": "\n^[0-1]?[0-9]*[-^+0$]\n\n3. Create a RegEx for only finding dates (yyyyMMDD) in strings.\n\nAnswer: \n\\\\b[0-9]{4}[0-9]{2"
            },
            {
                "text": " 0.*.0\nExample: A string that must have 7 characters, including 0 and 9 (ie. \"000000\") and 0 or more digits in between.\nQuestion: RegEx for all the digits and digits in all the number of a string including hyphens at the string end (ie. \"123-"
            },
            {
                "text": "\n(^|[^0-9])[-0-9]$\n\nExercise #5:\nMatch a string that ends in either a forward slash (/) or a back slash (\\).\nMatch examples:\n- \"/\"\n- \"/\"Slash matches the / character and everything after"
            },
            {
                "text": " ^[-+]?\\d+\\.\\d+$\nQ:\n\nHow to use string slicing without knowing the length of the string\n\nI have to solve a problem where I have to count the number in an input string with n-character string (n=3)\nfor example:  "
            }
        ]
    },
    {
        "expression": "^(0|(\\+)?([1-9]{1}[0-9]{0,3})|([1-5]{1}[0-9]{1,4}|[6]{1}([0-4]{1}[0-9]{3}|[5]{1}([0-4]{1}[0-9]{2}|[5]{1}([0-2]{1}[0-9]{1}|[3]{1}[0-5]{1})))))$",
        "raw_prompt": "Will match an unsigned short number from range 0 to 65535",
        "refined_prompt": "Matches an unsigned short number from range 0 to 65535\nMatch examples:\n- \"0\"\n- \"100\"\n- \"65535\"\nNon-match examples:\n- \"-0\"\n- \"+0\"",
        "matches": [
            "0",
            "100",
            "65535",
            "1616",
            "+71",
            "160",
            "252",
            "37898",
            "8961",
            "65531",
            "26897",
            "60927",
            "+8"
        ],
        "non_matches": [
            "-0",
            "+0",
            "-10",
            "65536",
            "0.0",
            "1,000",
            "3456789098765",
            "12/12",
            "#3",
            "45%",
            "$134",
            "int"
        ],
        "id": 2282,
        "output": [
            {
                "text": " -0^(?!$)\nNon-match examples:\n- \"0x3f\"\n- \"+0x3f\"Generate a RegEx for this description. \nAnswer: 0(?![\\D\\x2f])^[\\D\\x2f]++\nNon-"
            },
            {
                "text": " [+0-9a-fA-F]+)\n\n3. Create a regular expression to match the string \"I love (python) coding!\" and capture the text inside the parentheses.\n\n4. Modify the \"Find and Replace\" code to only replace URLs with \"http://www.example.com\"."
            },
            {
                "text": "![non_match.png](attachment:non_match.png)\n- \"\"\n- \"A\"\n- \"+A\"Generate a RegEx for this description. \nAnswer:![non-match-A.png](attachment:non-match-A.png)\n- \""
            },
            {
                "text": " [^\\-+]{0,1}|0[1-9]|1[0-2]\n\n4. Write a RegEx for this set of strings:\n- \"0\"\n- \"1\"\n- \"2\"\n- \"3\"\n- \"4\"\n- \"5"
            },
            {
                "text": " 0(?!0) [1-9][0-9][0-9]|[1-9][0-9]00|[1-9][0-9][0-9]{2}\n- \"0+\"Generate a RegEx for this description.\n\nI think that my"
            },
            {
                "text": " \\+0\\.\n- \"-10\"\n- \"11\"Generate a RegEx for this description. \nAnswer: (?<!\\w)\\d\\.\n- \"+1.1\"Generate a RegEx for this description. \nAnswer: 1\\.1\\b\"\"\"\n\n# Create the"
            },
            {
                "text": " -0\\d+\n3. Write a RegEx to extract strings from the following URLs until a /url/ is found: https://domainname.com/page/12345, https://www.example.com/blog/posts\nUse \"|\" to indicate a pipe operator in your RegEx.\nAnswer"
            },
            {
                "text": " *[0-9A-F]{2}* \n\nExercise Two:\nFill in the blanks on this RegExp:\n/(?=.*[\\s])(?![\\s])/\nAnswer: /(?=\\\\s!)[^\\\\s]*/\n\nExercise"
            },
            {
                "text": " a digit \"0\", the most common digits in \"0\", and 1 or more of any digits.\n- \"1 (3rd symbol of the 1 in a string)\" Generate a RegEx for this description. \nAnswer: any one of the digits 0-9. (The 1 is not considered part of the"
            },
            {
                "text": " -\\d{1,16}\n- ^[+-]\\d\\d$ Match an unsigned int number and only if it starts with a + or a -. \nThe regex to do that would be: ^[+-]\\d\\d$\n- ^[+-]\\d\\"
            }
        ]
    },
    {
        "expression": "^(0|(\\+)?[1-9]{1}[0-9]{0,8}|(\\+)?[1-3]{1}[0-9]{1,9}|(\\+)?[4]{1}([0-1]{1}[0-9]{8}|[2]{1}([0-8]{1}[0-9]{7}|[9]{1}([0-3]{1}[0-9]{6}|[4]{1}([0-8]{1}[0-9]{5}|[9]{1}([0-5]{1}[0-9]{4}|[6]{1}([0-6]{1}[0-9]{3}|[7]{1}([0-1]{1}[0-9]{2}|[2]{1}([0-8]{1}[0-9]{1}|[9]{1}[0-5]{1})))))))))$",
        "raw_prompt": "Will match any unsigned integer from range 0 to 4294967295",
        "refined_prompt": "Will match any unsigned integer from range 0 to 4294967295\nMatch examples:\n- \"0\"\n- \"1000\"\n- \"4294967295\"\nNon-match examples:\n- \"-100\"\n- \"-0\"",
        "matches": [
            "0",
            "1000",
            "4294967295",
            "36",
            "7",
            "10642",
            "29527193",
            "4070107329",
            "+926291232",
            "+2927957",
            "2",
            "697727552",
            "4161862882"
        ],
        "non_matches": [
            "-100",
            "-0",
            "+0",
            "4294967296",
            "0.0",
            "1,000",
            "#4",
            "87%",
            "$63",
            "int",
            "345321345324",
            "00000"
        ],
        "id": 2284,
        "output": [
            {
                "text": " \"^0*[11]\\d{6}$\"\n(http://regex101.com/r/yV9tT4/2)\n#include <iostream>\n#include <string.h>\n#include <sstream>\n#include <regex"
            },
            {
                "text": "\n^[0-9-]+$\n\nA:\n\nThe regular expression you could use is this one:\n^[0-9]+$\n\nYou could then use this regular expression in a string comparer function, like the one provided by this library: http://sourceforge.net/"
            },
            {
                "text": " \n\"^[0-9]{3}(-[0-9]{3})?$\"\n\nThe \"^\" anchor will start the RegEx at the beginning of the string, and \"[]\" and \"{}\" are special characters. The \"?\" makes the preceding portion an optional"
            },
            {
                "text": " (1 to 9) 0 - 9 or (a-f0-9)\nExample: \"^[1-9]$|^[a-f0-9]+$\"\nNow that you have your RegEx, you can loop through each word in your list and match it to your Reg"
            },
            {
                "text": "\n- \"0\" --> $0\n- \"1000\" --> [0-9]{1,3}\n- \"4294967295\" --> [0-9a-f]{8}\n- \"-\" --> [-^0-9]\n- \"-100\" --> [-^0"
            },
            {
                "text": " ^[0-9]+ ([1-9]|1[0-9]|2[0-3])$\n\nWhat I have so far\nimport re\n\n# Define your strings\nstring1 = \"1\"\nstring2 = \"23\"\nstring3 = \"-99\""
            },
            {
                "text": " ^([1-9][0-9])[:-]0+$ match if each 0 appears an even number of times. \n\n1st exercise \n\nQ: Using our previous regex knowledge, generate a RegEx that matches all decimal values (including integers and negatives) between 1 and 50,"
            },
            {
                "text": " \n^[0-9]{1,35}$\n\n3. Write a positive lookahead to ensure the string doesn't start with 'A'.\n  \nHint: The general form of a positive lookahead is \"?<pattern>\", where \"pattern\" is any substring that"
            },
            {
                "text": "\n^[0-9]+$\nExplanation:\nThis regex matches any unicode digit without any numeric value. Meaning this will not match 0 or 1 because those are valid unicode digits. This regex only matches numbers.\n\nA:\n\nIn JavaScript you can use (?:-?\\"
            },
            {
                "text": " -100|-99|-98|-97|-96|-95|-94|-93|-92|-91|-90|-89|-88|-87|-86|-85|-84|-83|-82|-81|-80|-"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|[2][0-3]|[0-9]):([0-5][0-9])(?::([0-5][0-9]))?$",
        "raw_prompt": "Validate hours with seconds returning mirrors correctly.",
        "refined_prompt": "Validate hours and minutes with seconds in format HH:MM:SS\nMatch examples:\n- \"09:05\"\n- \"10:00\"\n- \"1:15\"\nNon-match examples:\n- \"9:5\"\n- \"09:1\"",
        "matches": [
            "09:05",
            "10:00",
            "1:15",
            "00:59:00",
            "23:01:59",
            "5:15:31",
            "17:04:26",
            "5:36",
            "02:03:05",
            "6:14",
            "23:52",
            "23:17:27",
            "23:17"
        ],
        "non_matches": [
            "9:5",
            "09:1",
            "0:1",
            "0:00:0",
            "1:1:11",
            "12-12-12",
            "12/12/12",
            "12",
            "-12",
            "12.12.12",
            "0",
            "$4"
        ],
        "id": 2294,
        "output": [
            {
                "text": " \n^\\d{2}:\\d{2}\\:\\d{2}(\\.\\d+)?$\n\nEXERCISE 4:\nWrite a regular expression to match email addresses.\nGenerate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "\npattern\\s+\\((\\d{1,2}\\:\\d{2}):(\\d{1,2})[\\s\\d\\._]*(\\d{1,2})[\\s\\d\\._]*[,](\\"
            },
            {
                "text": " \"^\\d{1,2}:\\d{2}:\\d{2} [AP]M$\"\n\nExercise 3: Generate a RegEx to validate social security number.\nAnswer: \"^(?:\\d{3}-)?"
            },
            {
                "text": " (00)-(19):(5)\n\n2. Given a string of usernames and passwords separated by the separator \":\", check that they are valid usernames and passwords. Usernames are between 3-10 characters and passwords are between 7-"
            },
            {
                "text": " 9:05:ss\n\nExercise 3: Given the following string \"Python (for statistician)\", use regular expressions to select the substring that starts with \"Python\" and ends with the closing parenthesis.\nAnswer: Python (for statistician)\n\nEx"
            },
            {
                "text": " [12-7]\n\n1. What is the most commonly misused RegEx pattern? Give an example of a real-world application of this pattern.\n2. Write a code snippet using Python re to extract all the usernames from a given string containing '"
            },
            {
                "text": " 9+\\d\\d+:\\d\\d\\d\\d[:. ]+\\d{1,2}|[:. ]\\d{1,2}:00[. ]|[:. ]\\d{1,2}"
            },
            {
                "text": " This would be ^[0-9]{1,2}:{1,2}\\d{1,3}:{2,3}\\d{2}$.\nExercise 2: \nMatch examples of temperature below freezing with the range of winter temperature in degrees"
            },
            {
                "text": "\nThe RegEx is : /^((?P<h>\\d{1,2}):)(\\d{1,2}):(\\d{2,2})($|:(?P<m>\\d{1,2}))$"
            },
            {
                "text": " (\\d{1,2}), (:\\d{2}), (:\\d{2}) - \"hh:mm:ss\"\n\n4. Pattern search\nRegular expressions allow you to find patterns in a text or a data set. You can use them"
            }
        ]
    },
    {
        "expression": "^([0-2]\\d|3[0-1]|[1-9])\\/(0\\d|1[0-2]|[1-9])\\/(\\d{4})$",
        "raw_prompt": "Validate a date format: d/m/Y.\nSee examples.",
        "refined_prompt": "Validate a date format: d/m/Y.\nMatch examples:\n- \"1/05/1990\"\n- \"01/1/2006\"\n- \"01/01/2008\"\nNon-match examples:\n- \"01/01/90\"\n- \"32/02/2009\"",
        "matches": [
            "1/05/1990",
            "01/1/2006",
            "01/01/2008",
            "5/5/2009",
            "1/1/1990",
            "29/05/2009",
            "7/00/7624",
            "4/01/3597",
            "18/11/7766",
            "29/02/6624",
            "31/02/6233",
            "18/4/2191",
            "30/07/5093"
        ],
        "non_matches": [
            "01/01/90",
            "32/02/2009",
            "1/13/1990",
            "0/0/2009",
            "12-12-1212",
            "12:12:1212",
            "12 12 1212",
            "12|12|1212",
            "12\\12\\1212",
            "12.12.1212",
            "12,12,1212",
            "12"
        ],
        "id": 2295,
        "output": [
            {
                "text": "^(\\d\\/\\d\\/\\d{4})(-(\\d\\d)?)$\n\n4. Create a RegEx that matches a phone number in the format of (xxx) xxx-xxxx.\nAnswer"
            },
            {
                "text": " r'^[0-9/]*([0-9])\\/([0-9])\\/([0-9])$'\n\"\"\"\n\nEXERCISE 2:\nWrite a Python function to convert the date format"
            },
            {
                "text": " [a-zA-Z]{3}\\)/([0-9]{2})/([0-9]{4})\\.\n\n3. Use Python's Regular Expression module (re) to search through a dataset"
            },
            {
                "text": " \"^\\d[\\/]\\-\\d[\\/]\\-\\d\\d\\/\\d[\\/]\\d\\d$\".\n\n```python\n# Date-time Validation\npattern = \"\\d{"
            },
            {
                "text": " 1..5, 01..29, 0..31, 02..10, 09..31, 11..20,\n26..27, 06..27, 18..24, 31..30, 40..40\n\n2."
            },
            {
                "text": " [0-9]{4}-[0-9]{2}-[0-9]{2}\n\n***Exercise 2:***\nDescribe how to add a hyphen to the last name of a full"
            },
            {
                "text": " \n\"^\\d{2}\\/\\d{2}\\/\\d{4}$|^\\d{2}\\/\\d{2}\\/(\\d{4}|\\d{2})\\"
            },
            {
                "text": "\n- \\d{2}/\\d{2}/\\d{4}    Pattern: [0-9]{2}/[0-9]{2}/[0-9]{4}"
            },
            {
                "text": " \\d{1,2}/[A-F]\\d{2}/\\d{4}\n\nExercise 4:\nGiven a string with a URL (\"https://www.google.com/search?"
            },
            {
                "text": "\n[\\s\\-]?\\d{2}[\\/]?\\d{2}[\\-/]?\\d{2}\\b\n\nExercise 2:\nUse RegEx to validate if a user input"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1} --> ([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1}(.*)$",
        "raw_prompt": "e. g. HH:MM:SS:ttt --> HH:MM:SS:ttt;\n$1 is start hour;\n$2 is start minute;\n$3 is start second;\n$4 is start s/1000;\n$5 is stop hour;\n$6 is stop minute;\n$7 is stop second;\n$8 is stop s/1000;",
        "refined_prompt": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf6$2=}Ww,bG98Fv~nPV0@z>@R\\-6~AJDwRP&s<WC][fwv<p(|5uN[#^`r!)>;to^=o4\"\nNon-match examples:\n- \"00:59:35,126 --> 00:60:20,500\"\n- \"00:16:20,200 --> 00:16:20,30\"",
        "matches": [
            "00:12:35,126 --> 00:12:35,526",
            "19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96",
            "21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf6$2=}Ww,bG98Fv~nPV0@z>@R\\-6~AJDwRP&s<WC][fwv<p(|5uN[#^`r!)>;to^=o4",
            "05:35:57,612 --> 18:49:03,876`KrNja>e\\0LK\\@)Z6z>vBLxGE{ lT?fl{pc.E$^SFZPHRlhu\\",
            "05:42:33,416 --> 12:27:19,604[,>Tc%|Q=xIj-",
            "10:44:24,406 --> 23:27:11,904lp;LcF",
            "03:38:55,987 --> 18:31:34,590fX!k\\qt^*$xtQ8P\\dk!Z,dX`",
            "21:06:12,048 --> 20:10:14,8454 o+&('V=WUOg0sK:CT\".baGtuzlC",
            "13:22:54,397 --> 23:06:20,423zR[|&1<'Ij^Y_m@a}-|@%4CJx.usNh HB[CPv[",
            "16:32:10,604 --> 23:19:20,513CnGYN!AB!xo__/`D%T#MGb1Ly`d3G|cBA7X)wzub`.=``P^qoRJu1M0:6S~Ss",
            "21:02:47,979 --> 13:54:24,392^pV+<kIk+I,AT:?Q@wr@H#+D-WDVJwzz<0Db#j/d",
            "12:11:40,526 --> 15:38:38,713,",
            "20:06:19,188 --> 16:50:24,716SAAhjg#(tO=vvURDtW|q9V>\\1|\"\\0_cgTW>x`N e.yjX/r`.n^wEbmjyFem"
        ],
        "non_matches": [
            "00:59:35,126 --> 00:60:20,500",
            "00:16:20,200 --> 00:16:20,30",
            "01:01:01.000 --> 01:01:01.900",
            "july 4th",
            "start",
            "stop",
            "5 -> 6",
            "12 hours",
            "5 pm",
            "234543",
            "00-00-23 -> 4532",
            "23"
        ],
        "id": 2296,
        "output": [
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2KdfV"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdfq"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdfx"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf@"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf~"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf0"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf:"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf~"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2KdfS"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf4"
            }
        ]
    },
    {
        "expression": "^\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}(.*)$",
        "raw_prompt": "e. g. {11510}{11810}Blah, blah, blah.;\n$1 is start;\n$2 is stop;",
        "refined_prompt": "Matches numbers in two sets of curly brackets.\nMatch examples:\n- \"{100}{150}subtitle\"\n- \"{1234}{1234}subtitle\"\n- \"{1}{2}subtitle\"\nNon-match examples:\n- \"{0100}{1000}subtitle\"\n- \"{}{100}subtitle\"",
        "matches": [
            "{100}{150}subtitle",
            "{1234}{1234}subtitle",
            "{1}{2}subtitle",
            "{3}{7}\\22q0c_\\ SzNRr'XH`ne}T{p?PqzxhIpYV6mM(]#CjT\\P{Ml\\)O)Pxn@O5On;Q2~'''6\":H",
            "{33257415607627367238703717709439276794083882135496999341504151593077896669}{23539247086269821521082267372192331892762649124791145900074}+:)qGrHKZt+\\Y15~-XU|S\"JTR\\=Ygdkom(]]xb_/Ci2Ck",
            "{3}{1}J32!>^pU!Eb2S']wj+S4T|wL723UyVo*+N)l7Ci#8~Om+I(lsK~FAU|3[]Fs%8%1^",
            "{67666760}{94182287881948924411183227136072476810225831720231426945333295737250019666200806721486}d@v KCEh|U}#C;t9o7.aVg@{U>+SNCxFR=Y}GlZaMt+@8|#`B",
            "{7}{9}Gv#*A#iIcl(@*;f8WbMjHHMw@}:!luz|(,i$d.cJ5p;y82H",
            "{928926183117059964051}{8}BCBDz4DH\\*5<MC{fX-",
            "{6}{3}.@,xDj$kz,/nFE",
            "{5904430153955635113676162584892363778062}{3357315948710520882426565100288134268666}uKu.78dy4'dy&yo0",
            "{59640793384489531528091461282910413152773174124362558528954713909560825207726510710995346}{38675339245705993345401457514870087346}$#Hrh}()'kN;UZXR1;FWH=qWLy\\'oJMoHHx)U[)X$:3k?;x{,}#lXJo|X*2j%e8",
            "{12}{8}#=O.ymY#eQJFeoyF+`V=yZsl]UXMRf|(lk3j<P;eEo&` &AoK=\"3U jWEASvw?U4,Tw^fArqCcyNQ{O\\oM2N"
        ],
        "non_matches": [
            "{0100}{1000}subtitle",
            "{}{100}subtitle",
            "{500}{}subtitle",
            "{}",
            "234567",
            "345rfd",
            ".",
            "//",
            "#",
            "@",
            "!",
            "?"
        ],
        "id": 2297,
        "output": [
            {
                "text": " ^(?=.*\\d)([0-9][0-9]|([0-9]\\d)\\2*)$\n- \"{0}{0}subtitle\"Generate a RegEx"
            },
            {
                "text": "\n\n# Generate regex with { and } matching brackets and number signs.\nimport re\npattern = r\"\\d+\\{\" + \",\".join([\"\\d+\"]*3) +"
            },
            {
                "text": " [\\d]{4}\\s[A-Z]\\1\\1[\\d]{4}[\\d]{4}\n2. Using the RegEx from exercise 1, find all"
            },
            {
                "text": " \n\\{(?:\\d{1,3}|\\d{3})\\}\n\nExercise 3:\nWrite a Regular Expression for removing all text containing digits.\nAnswer: \n"
            },
            {
                "text": " We require two numbers, one before and one after the curly braces.\n\nExercise 2: Design a new feature\nYour current application offers the ability to export the content in a specific file format, such as JSON"
            },
            {
                "text": " ^[0-9]\\{[0-9]\\}[a-z]$\n\n4. Example: \nJohn works in marketing research and needs to organize survey data by age groups to"
            },
            {
                "text": " \"{0}\".\nTo complete this exercise, try matching various numbers in different ways within the text. For example, you might try matching the numbers using only digits, allowing for different decimal separators, and even including"
            },
            {
                "text": "\n\n{[123456][0]}{[12]{4}g}subtitle\"\n\n\n\n\n## Subsections\n1. What are Python Dictionaries?\n2. Dictionary Methods"
            },
            {
                "text": " Use [{123}][0-9] sub\n\nExercise 4:\nWrite a regular expression that matches words that have an even number of characters and start and end with the same letter\nAnswer:\n"
            },
            {
                "text": " \n(?<=\\{\\{\\(\\d+\\)(\\d+)\\}\\{>)\\d+{0,2}\\s{0,2}subtitle|(?<=\\{\\"
            }
        ]
    },
    {
        "expression": "\"([^\\\\\"]|\\\\.)*\"",
        "raw_prompt": "to get the text betwen double quotes",
        "refined_prompt": "Matches strings of any character between double quotes\nMatch examples:\n- \"\"Ram\"\"\n- \"\"\\9=\\z\\C\\?\"\"\n- \"\"Ram Shyam\"\"\nNon-match examples:\n- \"ram\"\n- \"shyam\"",
        "matches": [
            "\"Ram\"",
            "\"\\9=\\z\\C\\?\"",
            "\"Ram Shyam\"",
            "\"\\Mgb\\U\\i*6VFP-\\&\\Y\\N\\Zk\\J9\\s\\A\\N\\3@b\\ \\vks\\R\\fkM/\\U\\LlO\\4=H]\\MWH\\vm\\d*\\,]a\\a\\b{;\\&\\skfx1a{0\\DC$\\P \\jb\\vjp\\m#\\C\\U\\r\\)\\M\\_\"",
            "\"b\\m\\VE\\GR\\reP\\P]M\\nK\\Q\\H5L\\5\\.\\r<B\\qN\\~$H#P/\\rio@\\m\\.\\3bG\\<9w=pML<\\S\\-\\V?m9J>\\;\\^\\#{\\|\\7Hw\\=(\\M\\7)\\c%\\W\\U\\2V\\:I8oP\\w\\ v\\0\"",
            "\"5!\\E\\kO=\\-\\(QH!Y\\=pW\\q%I\\%\\_\\K\\-$35CS\\WK5\\f,K]Gj\\#\\iR_Th\\y\\}y\\qW\\R\\$\\Q\\m\\Sf\\l6S9,\\$\\M\\K\\~\\`P\\~E\\)\\5\\U\\^j>\\>^N\\uL=h6H\\xZ]\\S\\=[\\a\\E\\gK1\\)v\\1\"",
            "\"I\\i{\\_\\2\\C^\\Q\\{\\C\\V\\z\\ A[R\\,\\b\\'BPL\\?Zp4\\=\\q;Z\\0n72\\Fu\\R\\>F_NX\\2\\[\\tV\\+DpL\\^\\e\\\\z\\ +\\\\\\zJ\\^g{MN\\/\\i?@S\\S\\{bt\\P\\(\\%\\v\"",
            "\";j\\j\\@ \\-8\\$\\#\\exs\\0C\\R#\\9\\-dJ!\\/>\\h}\\v%\\}\\=6V\\+)\\L\\pc\\f\\#|Dc]\\rFx&\\QgQ\\]\"",
            "\"2-\\DgS\\r9z\\S>\\kAHm\\V\\9d\\qY\\_H&Qu\\vZm\\4.3\"",
            "\"\\C8{;\\C\\K\\:\\h&\\_\\N#\\2hG_\\u\\D(\\9\\>\\WU\\{\\8-8\"",
            "\"\\sh\\^\\IXnW\\BciH\\<\\T5\\(\\3`\\P\\v\\e\\[D\\mR\\m\\M<r\\?&u6\\eRYo|\\J\\q\\,}{u\\q\\F\\,\\Z\\/6\\o\\?\\T[j\\K@\\i\\P!\\n9\\7c\\r{|?:\\P\\J`\\R\\+\\7\\Om\\:{%\\mjFp\\2Z\\J\\c\\p\\(?\\6\\PS\\Qx\"",
            "\"M2|h-aY\\8\\?(\\\\8\\^\\H\\a7!\\<Y[k\\n\\o.\\cw\\w\\vc\\rx\\}[\\>$\\[\\Q\\>}t\\F\\kOi\\MM>\\B\\n\\o\\`S\\e@\\HCC\\omc{\\-\\Z>\\+\\c;\"",
            "\"'z7\\h\\HY\\?O\\M\\v\\/\\Up\\_;RE8B\\#ZeK\\b\\-\\s{vSiWPl\\|\\t\\Z\""
        ],
        "non_matches": [
            "ram",
            "shyam",
            "'fcsd'",
            "'ekd",
            "cds\"",
            "\"rfvhfdjk",
            "wejk",
            "123456",
            "///",
            "..dce",
            "23es",
            "3kr"
        ],
        "id": 2298,
        "output": [
            {
                "text": " ^(|\".*\"|\"\\G|.+|^ |$)$\n- Generate a Reg ex for a pattern similar to this: \n\"ram or \"ram\" or \"ram 'or' a 'ram' or 'ram 'or' a '"
            },
            {
                "text": " (.+)\n\nI tried a few variations but failed to find the right pattern. \nThanks for your help.\n\nReply #1:\nThe Regex pattern to match any characters between a quoted character, double quotes or backquotes would be [^\"\\s]+."
            },
            {
                "text": " /(?=(\\w(?:\\w\"\\w)*\"\\w{2})*).+/. It will match any of the words that are inside double quotes.\n\"\"\"\n\n# 2.4.20 The character classes and ranges and their operators\n\nIn"
            },
            {
                "text": " (\"[a-zA-Z\\\"']*\"?)?\"\n- \"Ram\"\n- \" \\\"Shyam\\\"\"\n\nUsing \"\".replaceAll(\"\\\\$\", \"\") before any of the above problems gives a different answer\nAs it is, you get the"
            },
            {
                "text": "\n\nimport re\n\"\"\"\nimport sys\np = '''\na, b, c, d are any of the four characters\n'a, b, c, d' are strings of the same length that have length 5.\n'''\n\nmatches = re."
            },
            {
                "text": " (at least 4 matches) \n.*Ram.*?[^\\s\\d]+.*\n* Ram.*?[^\\s\\d]+.*?\n* Ram *?[^\\s\\d]+.*?\n* Ram *?[^\\s\\d"
            },
            {
                "text": ".*?[a-zA-z]+[a-zA-Z]*( |$)\n\nI really don't understand how this should work (I know the [a-z] is for a char, [ ] is for a list of chars and *"
            },
            {
                "text": " Match any string of any characters between a double quote. \n\n#### Ideas: \n- Use the special characters \"-\" and \"\\\" to mark the end of a word and to mark the beginning and end of a double quote. \n\n\n\n\n---\n\n#####"
            },
            {
                "text": "\n\n(?<!\\\\\")(?<!\\\\\\\\)(?<!\\')\"|\"(?<=\\\\\\\\)\"?\\w+\n\n2. Given the string\n\n\"hello world, i am fine\n\"\nGenerate a RegEx for this description."
            },
            {
                "text": " ^[ ]*([A-Za-z ]*)[ ]*\"?[ ]*$\"\\1\\3$\n\n3. Return the number of matched characters between any two pairs of double quotes.\nString: \"Ram\"\" \nAnswer: 6\nString"
            }
        ]
    },
    {
        "expression": "^(\\$?)((\\d{1,20})|(\\d{1,2}((,?\\d{3}){0,6}))|(\\d{3}((,?\\d{3}){0,5})))$",
        "raw_prompt": "This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.",
        "refined_prompt": "This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match examples:\n- \"$77,8,888\"\n- \"asadf\"",
        "matches": [
            "$99,999,999,999,999,999,999",
            "$56,987",
            "56,123456,456",
            "7872863477137753",
            "$9125673,299758253",
            "716,009589789,309",
            "738584",
            "$2,150,035464,019,121235",
            "$908184171,640,844",
            "$9,797,967041,635802924",
            "$702",
            "55,222",
            "28845400"
        ],
        "non_matches": [
            "$77,8,888",
            "asadf",
            "67.98",
            "wejk",
            "cds",
            "23423.",
            "0.0",
            "$",
            "#5",
            "45%",
            "money",
            "--"
        ],
        "id": 2301,
        "output": [
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-ex"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-Match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            }
        ]
    },
    {
        "expression": "^[+-]?[0-9]+$",
        "raw_prompt": "Single- or multi-digit signed Integer.",
        "refined_prompt": "Matches single- or multi-digit signed Integer.\nMatch examples:\n- \"12\"\n- \"-2\"\n- \"+3213\"\nNon-match examples:\n- \"abc\"\n- \"@41\"",
        "matches": [
            "12",
            "-2",
            "+3213",
            "0782004064112150920077190209139716388117211125565316159696466129441575409462530933373",
            "971606804743938413240690497074286754096439597293718504430565641",
            "47747090632161265201577437232517035561028013084989656444101496067410795426213450",
            "8523167852756684547041931759768162229369596",
            "-178440257164620089385194679071990203274159702360376749179642787860962220783241614",
            "7904358887351375386849955097750388338950009248898926015055603313642327506286822114157732020239236",
            "+98839279710996808761917843425434549102912899057868668570529445151793128564910360448",
            "22768450839447155527249965620267958468254029655549630116234639198734295444106632899891332195039791473",
            "5681975620858817299",
            "37867757907361347086287165227866726436791815976735643405035753295921531908571671413505"
        ],
        "non_matches": [
            "abc",
            "@41",
            "43.12",
            "+",
            "-",
            "erf",
            "#3",
            "$45",
            "9876%",
            "12/12",
            "12-12",
            "0.102"
        ],
        "id": 2316,
        "output": [
            {
                "text": " ^[a-zA-z0-9_]*$\n\nA:\n\nYou can use:\n^-?[1-9][0-9]*$\n\nThis means a whole number and/or 0-9 in range (-1..9)\n\nA:\n\nYou can"
            },
            {
                "text": " @(?=-){1,2}$\nExercise 5:\nWhat is the purpose of a non-capturing group in a Regular Expression?\nAnswer: It matches but does not include.\n\nI hope this blog post has been helpful in introducing you to capturing and non-capturing groups, and how they can"
            },
            {
                "text": " /([0-9]+)?\\.([0-9]+)$/\n\n5. If I were a data scientist and I wanted to generate a RegEx that looks for a particular user's email address, for example, \"@google.com\", how would I do it?    \nString example email=\"@google."
            },
            {
                "text": " - Match anything except [0-9]. \nNon-match examples:\n- \"-abc\"\n- \"@\"Generate a RegEx for this description. \nAnswer: Match a single- or double digit signed Integer, optional followed by a single- or double digit signed Integer, optionl followed by a double- or"
            },
            {
                "text": "\n/^([^+-]+)$/\n\nExample 11.4.5\nCreate a RegEx for string matching: the pattern should match the single- or multi-character string that does not contain the digit or the digit character '0', and also must have length between 2 and 16 characters (inclusive).\n"
            },
            {
                "text": " r'^[0-9a-z]*$\n\n10. What is the RegEx to match a Unicode letter or digit from any language?\nAnswer: r'[a-zA-Z0-9]'\n\n11. What are some of the built-in special characters in RegEx?\n"
            },
            {
                "text": "\n([a-z]+|\\d)\\1*\n\nQ:\n\nComparing two lists in python\n\nIs there any way to easily know if all elements of a list appear in another list?\nThe lists are large and so comparing the two list with in sets etc. takes a long time.\nI need"
            },
            {
                "text": " Regex matches alphanumeric and signs.\n\n- Create a set of alphanumeric and underscore characters in javascript Regex\nMatch examples:\n- \"a\"\n- \"A\"\n- \"0\"\nNon-match examples:\n- \"_a\"\n- \"0A\"\n- \"0_a"
            },
            {
                "text": " @(?:[-0-9a-zA-Z]|%[aA-zA-Z0-9_]{2})\nExample: $matches[0] = \"$matches[0]\"\n\nA:\n\nIf you are sure that the numbers consist solely of digits, you"
            },
            {
                "text": " ^\\d+$\n\nExercise 3:\nWrite a RegEx for identifying email addresses within a string. An email address must start with \"valid\", followed by a sequence of characters of 0-9,., _ (dots and dashes), or -, and may end with any of the characters., _"
            }
        ]
    },
    {
        "expression": "^[+-]?\\d*(([,.]\\d{3})+)?([,.]\\d+)?([eE][+-]?\\d+)?$",
        "raw_prompt": "Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation.",
        "refined_prompt": "Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation.\nMatch examples:\n- \"-4,233.2832e12\"\n- \"+232\"\n- \"-0.12e-5\"\nNon-match examples:\n- \"abc\"\n- \"@41\"",
        "matches": [
            "-4,233.2832e12",
            "+232",
            "-0.12e-5",
            "8018953486012917622355847653389393786261280102567849783830623944277207820676023,927,782.296.825.745,007,521,226,142.212.171,436.256,511.387,030.094,681,579,594,346.055.272.133.956,971,776,376,947.638.478,665.461.581.663,269,390.976,858,739.717.989,126.595,738,037,420.401,384,862.387.926.227.192,914,613.585,417.792,561.843.078.989,736,854,137.622,252,447,364.632.901.533.042e+1986107741361866675091506147670929811474213337802019233915623894506982087948081235570272043749610716",
            "+34848718469196765885666688234540970530523947868944579676458016878810,815.666.170,382.176.045,952.386.983.258.489.774.443.628,412.997.945,129.065.3858420612738749194978276055341650699927851137613815290979610098098442071050958652757672",
            "+480681967582595965760202.837.502,447,896.812,404.156.167,662.614,055.575,277.536.864.456,290,907,851.939.661.217,969.883,899.974,021.132.821,969.191.390.452,476,011,364,236,395.707,088,728,617.590.321.684,717.905.105,773.427,912.162.006,142e-52609402067810327885735339",
            "444462504387814310444638203295061321777498497878006436666149083076414221291.062,018,574,029.611,349.163.182,539.310.684.855,665,720,890.418.502,909.510.836,262.523.570.265.415.090.692.015.277,541,539.256.008.142.108,035,012,486,276.741,342.033.081.309.978.539,202,673.436.551,730.635,365,709,625,866,375,380,139,419,716.728,274.568,465.652,98424127160098936666018179373108549205230138498434793160731781201644856E+781600540799191535308207447679446300837191505252905434719031243",
            "21216705901794677928885277732160316989681413947935111522925650390924725733909607886596137528718639.274,303,211.454.654,346.810.289.923,279,670,616,520,202.987.864,433,227,573.785,696.849,171.558.118.160,794,102,388,941,291.619.005,259.878,219,626,876.383,147,568,871,378.692,237",
            "32126991214,966,613.535,321,078.033.830,339.915,609,744,519.812.546.067,762.694.924.581.963,976.834,101.910,987,750.358,554,340.096,087,361.543.550.689,977.082,402,067,169.182,020,008.939,275.936.389,271.872.883,762.979.906,315,953,840.815,100.007.818,397.234.135,735,992,718.733.379.675.726,346,483.427,854.159.821.578.847.492.584,019,425,604,999E-87515223",
            "-826176040372593602229931550659899116457538776723578.750.603.387.498,635.067,310.154.650.547,045,835,249,552,250.063.875,925.277.696.187,288.350,567,959,893,940.878.128.000,329,607,366,874.775.548.997.174,631,663.660,792.694,421.610.559,433.455,624.338",
            "+2567284.80722391070564936832627718804295768808031190855558300221e+139534264345258",
            "009832415439930561069804432667890",
            "875848104710979334.206153530409337185771855367213395108402E+71126208632098758388073185641732841722453789640940598763497"
        ],
        "non_matches": [
            "abc",
            "@41",
            "0x423",
            "date",
            "234reds",
            "fgh5j735",
            "4f3g56h",
            "g54redvsy8",
            "34teg",
            "HGUYUFUYU",
            "+++iuefwcd",
            "number"
        ],
        "id": 2317,
        "output": [
            {
                "text": ".*[^0-9.]*\n\n8. How are placeholders used in regular expressions?\nPlaceholders, enclosed in {} or [], are used in regular expressions to"
            },
            {
                "text": " ^[+-]?([-\\d]+[.])?([0-9]*[eE]?[+-]?[0-9]+)$\n"
            },
            {
                "text": " ^([0-9]*[.]([0-9]+)?)(e[+-][0-9]+)?$\n\n(5). What is the purpose of"
            },
            {
                "text": " ^(?![^a-z])(?![^0-9]+)\\w+$ \nThis RegEx will match strings that have at least one letter, one digit"
            },
            {
                "text": " a(?:\\.0)*{0,1}\\d{1,2}\\d{1,3}\\s*(?:,[\\d\\.]+,[\\d\\"
            },
            {
                "text": " https://regex101.com/r/sV4dZ7/1\n\n**Question:**\nCreate a function in python using regular expressions that takes a text sample"
            },
            {
                "text": "\n- Pattern:.?|(?:\\d+(\\.\\d*)?e?|\\d+(\\.\\d*,\\d*)?)(?:(s|ts)"
            },
            {
                "text": " (^.{1,24}\\+)?(.{0,2}\\.){0,3}\\d+$\n\nExercise 2: (RegEx) Validate"
            },
            {
                "text": " \n(?:[+-]?(?:[1-9][0-9]*(?:[eE][1-9]+)?|(?:0+))"
            },
            {
                "text": "\n\"@\\d+\\.([Ee][+-]?\\d+)?\"\nExplanation:\n\"@\\d+\\.([Ee][+-]"
            }
        ]
    },
    {
        "expression": "^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$",
        "raw_prompt": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.",
        "refined_prompt": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.\nMatch examples:\n- \"97.67.44.20\"\n- \"199.154.37.214\"\n- \"127.0.0.1\"\nNon-match examples:\n- \"63.125.94.287\"\n- \"140.370.a.187\"",
        "matches": [
            "97.67.44.20",
            "199.154.37.214",
            "127.0.0.1",
            "218.253.250.214",
            "58.89.130.2",
            "253.193.242.225",
            "106.86.226.121",
            "253.3.193.134",
            "9.166.190.197",
            "127.8.250.242",
            "186.8.140.160",
            "120.254.58.252",
            "178.25.64.24"
        ],
        "non_matches": [
            "63.125.94.287",
            "140.370.a.187",
            "94.923.1",
            "23456terfds",
            "defrtg6543",
            "3456re",
            "refwfrg.ergrew.erger",
            "IP",
            "2345.354236.32546.",
            "43.34543.345.4543",
            "+8765",
            "$45"
        ],
        "id": 2318,
        "output": [
            {
                "text": "\n\nMy code so far:\nimport re\n\ndef isIP(my_string):\n    pattern"
            },
            {
                "text": " [0-9]\\d\\d\\d\\.\\d\\d\\.\\d\\d\\.\\"
            },
            {
                "text": " (^10\\.0\\.[\\d\\.]+$)|(^10^[\\.]0["
            },
            {
                "text": " ([1-9]\\d?|[1-9]\\d|1[0-9]"
            },
            {
                "text": " ^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3"
            },
            {
                "text": " ([0-9]+(?:\\.[0-9]+)+){4}\n\n3. Match"
            },
            {
                "text": " /^(19\\d|1[5-9][0-9]|[0-9]["
            },
            {
                "text": " ([0-9]\\.){3}([0-9]\\.){3}([0-"
            },
            {
                "text": " /^(10|11|12|13)(0|1|2|3|4|5|"
            },
            {
                "text": " (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3"
            }
        ]
    },
    {
        "expression": "^#?(([a-fA-F0-9]{3}){1,2})$",
        "raw_prompt": "Matches any valid 3 or 6 digit hexadecimal colour value.",
        "refined_prompt": "Matches any valid 3 or 6 digit hexadecimal colour value.\nMatch examples:\n- \"#ff9900\"\n- \"#abc\"\n- \"#92fea5\"\nNon-match examples:\n- \"ab\"\n- \"#92a2\"",
        "matches": [
            "#ff9900",
            "#abc",
            "#92fea5",
            "#2eEd9f",
            "#5fd",
            "903",
            "D34",
            "#DBD61D",
            "#71Af2a",
            "#bF5eD8",
            "D609Cb",
            "6FDf9e",
            "#A66"
        ],
        "non_matches": [
            "ab",
            "#92a2",
            "32z",
            "dejk-487",
            "4334",
            "jheu",
            "0.0",
            "#3",
            "5%",
            "12/12",
            "color",
            "$46"
        ],
        "id": 2322,
        "output": [
            {
                "text": "\n(?:#\\d{1,3}(?:(?:\\d{1,3})?)?)\n\nLearning Journal: Subsection 2.5.8\n\nToday's lesson was all about regular expressions in web and API security testing. I found this lesson"
            },
            {
                "text": " ^(?:[^:#a-f0-9]|#)?(?!#[^0-9a-f])[0-9a-f]{6}$\n\nExercise 2: Pattern Matching\nIdentify and demonstrate how to use the"
            },
            {
                "text": " \n^(#[a-fA-F0-9]{6}$|[#a-fA-F0-9]{3})$\nThis works for 3 digit and 6 digit combinations. \n\nHope this helps.\n\nA"
            },
            {
                "text": " [a-f0-9]{6}|[a-f0-9]{3}\n\nA:\n\n/^[^#][#]*$/   // matches any non-# (any character except #) character including spaces\n/"
            },
            {
                "text": " #( #[2-9][0-9]|#ff[0-9a-f]{6} )\nYou can also match exactly N characters using {count} where count matches any number of characters in the brackets.\nFor example: #[01]"
            },
            {
                "text": " ^(?!ab|\\2)(?!#abc|#ff)\\d{3}[a-f]{3}\\d{3}$\n\nThis will match any valid 3 digit hexadecimal colour value.\n\nI hope this helps in your journey to"
            },
            {
                "text": " [^\\da-fA-F\\\\]|[ABCDEF]\n\nQ:\n\nWhy am I getting an exception in the following code\n\nMy code in java is to check for overlapping occurrences of two substrings,and it runs in O(n),n"
            },
            {
                "text": " https://i.imgur.com/Vu4z0B7.jpg\nI'm fairly new to this, would appreciate it if you can help me.\nThanks!\n\nA:\n\nYou can use ^(?=.*\\\\d)\\#(?:["
            },
            {
                "text": " #[0-9A-F]{6}$  #A|B|C|D|E|F\n#[0-9A-Fa-f]{3}$ - Match any 1-4 hexadecimals  \n#[0"
            },
            {
                "text": "\n\"([a-fA-F0-9]{3})-([a-fA-F0-9]{3})-([a-fA-F0-9]{6})\",\"^(?:[0-9]|[a"
            }
        ]
    },
    {
        "expression": "(\"((\\\\.)|[^\\\\\"])*\")",
        "raw_prompt": "match string between chars \" \" as in source code",
        "refined_prompt": "Matches string between chars \" \" as in source code\nMatch examples:\n- \"\"\"\"\n- \"\"\\n\"\"\n- \"\"test\"\"\nNon-match examples:\n- \"test\"\n- \"\"test\"",
        "matches": [
            "\"\"",
            "\"\\n\"",
            "\"test\"",
            "\"test 1 \\\"test 2 \\\" test 3\"",
            "\"\\>N?V\\e\\x\\-\\e2\\ViZ\\V\\<C\\Q\\fE~\\:\\|&)J:\\'\\U\\8\\Q2CKx\\9>pC!}\\eg\\\\\\+\\]/\\2\\c\\6')X\\c\\W\\z\\Q>J\\9\\}u\\1\\3\\\"s7655N*2S\\EX\\~9.y\\e\\e\\@\\A\\'\\xy$\"",
            "\"wa;=!Pi\\LSd\\D_{)qv\\~:#:\"",
            "\"\\E\\+\\ \\XX\\Vx\\b\\I+TT\\W\\[\\-j\\,4oq\\1\\z\\=\\]\\8;2\\,\\y\\_q\\)(1\\D+\\*\\;8\\sa\\x\\Hjt8\\*\\w\\)\\||\\@VFc\\-U<Y\\}\\6\\sfUw\\?\\L\\vsor\\x\\?]P\\)3s\\F+\\*21\"",
            "\"\\W\\Ab\\fN\\Y\\,\\&\"",
            "\"GAo\\A\\3 \\s8R|\\\\\\us \\ RK3;&\\/\\zv\\*\\sz\"",
            "\"\\m\\@\\]\\l\\4S\\x\\*\\'y1\\ \\\\LN\\]\\3\\~\\LD}\\t+\\i\"",
            "\"68\\fL\\\"$\\;\\BFI@\\:\\{\\fy\\U\\R<qv6%W\\lXl\\T\\`'\\k\\~\\K\\f}I\\B\\:D\\uZmmN<\\??<\\ \\`\\V\\qz`\\x\\!\\\\)&g\\#W^\\v\\f'Z2I\\0\\_2\\MSIIq\\EJ\\:O\\a\\^F\\5\\Eo\\o\\R\\+,\\}\\w\\0a\\G\\~\\[\"",
            "\"\\G\\B\\r\\x\\D\\6p \\_\\Qq]D\\x+\\LxXQ\\-\\+\\0\\Z`C2\\n=\\P\\UF\\76\\wI!\\G<>%\"",
            "\"\\lG\\+\\@\\+\\,\\Y\\>\\g\\A.6\\_{\\K '\\1x3XTn\\+=\""
        ],
        "non_matches": [
            "test",
            "\"test",
            "\"test\\\"",
            "'erfe'",
            "\"fervf",
            "vfef\"",
            "uirhuirjh",
            "<fds>",
            "''erfveew'",
            "rfedc;",
            "#4",
            "$5432"
        ],
        "id": 2333,
        "output": [
            {
                "text": ".*\n- \"test\\n\"\n- \"\"\\t\"\"\n\"\"\"\n\nThe first question is matching between the delimiter and a variable text (what delimiter is not a problem). Here's the answer:\n\nimport sublime\nimport sublime_plugin\n\ndef find_match(cursor, content, delimiter"
            },
            {
                "text": " \"test(.{1,3})|(.*)examples\" |\"^(.+)$|^(.*?)examples$\"\nEdit 2: Fixed some of the regexes and other regexes.\n\nA:\n\nTry this regex:\n\\s*()[0-9]\\s"
            },
            {
                "text": "\n[\"\"\"[^\\n\\\"]*\"\"\", \"'[a-z]*'\"]\nI do not see any reason to add a space before quotes or quotes as separators.\nHere is my code:\n#include <iostream>\n#include <regex>\n\nint main() {\n    "
            },
            {
                "text": " test\",\n    \"test\\n\"\n\nThe most used \"?\" is that it is optional.\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n\nIf a regular expression needs to capture subpattern matches from the entire string"
            },
            {
                "text": " ^\\w{0,50}\\s\\w{0,50}\\s\\w*$\n\nThe above answer might work in some cases. What if:\nI'm trying to match strings between quotes? In that case, I can't simply replace white spaces in between with underscores.\nIs there a way to find all"
            },
            {
                "text": "\n\n^[^\\\"\"]*$\nhttps://regex101.com/r/pG6nF7/1\n\nIn my code, I'm going through a string and if it is not equal to \"\\\":\nI do this:\nstring.length() * 1\n\nIf it's not equal to"
            },
            {
                "text": " - \"\"\\\\|\"\"\\\\|\"\"\\\\|\"test\"\n\nI have no idea what is supposed to happen. I keep getting two non-match results.\n\nA:\n\nYou're close.\nI'm not sure why your \"\\\"\\\"\\\"\\\"\\\" was producing more non-matches than matches. But this"
            },
            {
                "text": " \"\"([a-zA-Z][a-zA-Z'\\-_]*[a-zA-Z])*\"\"\\n\n\nSource code:\n  import re\n  source_code = \"this is a test\\na-b\\na\"\"\"*80 + \"\\\\n\" \n  "
            },
            {
                "text": " (.*)s+(?!$)\nQuestion: \\w+ matches words with numbers and special characters. Why doesn't it match words in capitalized alphanumeric form? Does it exclude lowercase alphanumeric characters?\n\nExercise 2: Identify the pattern in the following regular expression: \\d{3}-[a"
            },
            {
                "text": " \n[ ]?(test) \nHow to change this question from a long one to several: \nHow to change this question from a long one to several: \nHow to get all regexes that match the string \"\"\"\"\"\"\nfor me, I'm only getting \"test\" as my regex output.\nThe"
            }
        ]
    },
    {
        "expression": "('((\\\\.)|[^\\\\'])*')",
        "raw_prompt": "match string between chars ' ' as in source code",
        "refined_prompt": "Matches string between chars ' ' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"",
        "matches": [
            "''",
            "'\\n'",
            "'test'",
            "'test 1 \\'test 2 \\' test 3'",
            "'\\;\\J-\\BC\\QZ)\\=\\*\\4V6\\m\\^\\=\\{\\o\\p\\k\\KNTJ\\k'",
            "'\\Sl\\Fn\\-\\B\\-\\[?a\\x\\@A\\8Vwn\\\\\"\\DBx\\'\\$!a:\\l\\%\\*y\\d8\\cq\\S#\\<\\X\\f=\\!\\\\6\\-yh\\t\\>\\=zU\\xYK\\SaEh\\a3\\@St\\k\\Uc\\(\\-\\<\\A\\H\\}\\-q{\\p'",
            "'\\E$\\|Fx\\&\\#S\\5=Hp2\\i\\4`*NyKm\\l\\d\\N\\~\\G\\Z7\\{\\)I\\>\\)\\<\\|i8\\o\\,\\g\\ \\h\\1e%\\S]`\\,\"Tx>\\E%J\\oa\\w\\T\\&\\6ADn\\r\\j\\l\\g$Y6\\Ggl\\v\\q\\$^|\\V0\\IX\"\\4@V'",
            "'\\E$\\|Fx\\&\\#S\\5=Hp2\\i\\4`*NyKm\\l\\d\\N\\~\\G\\Z7\\{\\)I\\>\\)\\<\\|i8\\o\\,\\g\\ \\h\\1e%\\S]`\\,\"Tx>\\E%J\\oa\\w\\T\\&\\6ADn\\r\\j\\l\\g$Y6\\Ggl\\v\\q\\$^|\\V0\\IX\"\\4@V'",
            "'\\l\\{|T\\p_hG\\X9\\X|\\+p\\8\\_hVl!\\_\\59\\w\\Z\\ \\V\\u\\^\\iQ.\\7i\\C\\M\\B\\`H\\aBO\"\\,\\8,{R\\c\\;&x\\6\\e,\\@\\tN\\r\\@n!\\$\\sR_B}\\{@\\t\\.\\T\\E\\rjl\\C\\})%\\GeA\\`\\)\\g8'",
            "'<\\7\\p\\?\\}`\\CE\\SA\\'[\\.\\q\\ \\E\\p}\\c7\\sB\\~\\6\\!'",
            "'\\~s\\u\\])-\\7\\e9\\%\\]\\K\\BX@\\5bV\\D\\P\\vo\\r\\W\\JRf\\H]\\ \\jPA{\\C\\NsbJYI.\\@6\\x\\6\\9TC\\Y\\Vh4P\\(EEf\\oj\\Nj\\4$_%Uq\\%eO\\mvp{'",
            "'94o}\\Jv6HIrpY\\c\\>\\W0\\x\\rF\\Z3\\u\\>\\V\\Gf.~\\&\\U\\@R\\9JV{\\vH\\=\\~e6&\\+ r\\Uh\\ :\\!N\\9\\?ai\\B\\%D\\{Y 51:'",
            "'\\a\\R6\\\"dw\\uD\\}\\sVz2\\U9\\F\\Q\\rqd\\bT\\{G~\\H\\[\\1\\1x\\Q\\Dn\\r\\l\\)<|\\u\\@l\\j\\d\\L\\t\\g|\\\"q$\\'\\\\<\\u\\/h\\>H\\s\\P}'"
        ],
        "non_matches": [
            "test",
            "'test",
            "'test\\'",
            "'sfvr",
            "fervdsc'",
            "\"revd",
            "\"rvtjn\"",
            "j4hjrjn\"",
            "$45",
            "0000",
            "#3",
            "12/12"
        ],
        "id": 2334,
        "output": [
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: [\\w\\s]* '\n\nCreate a regex that matches a string between a number and the word \"and\" using \"in\". If the string doesn't include the word, return an empty string instead.\n\nExample:\nimport re\n\nregex = r\"(\\d+)\\sand (\\w+"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer:\n- r'\\w+'\nA source code example:\nsrc = \"''\"\nre.search(r'\\w+', src)\n\nStudent: Thanks, that's helpful.\nTutor: You're welcome. What's the next question?\nStudent: The fourth question is: Write a Python"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: \\b\n'([^\"'\\n\"\\r)'''+r\"|'\"+r\"\\n\"+r\"\\r]+'''\n\nThis RegEx will generate and list all matches that are '''', '\"', '\\n' and '\\r'.\n\nA:\n\n"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: (?i)\\d\\s?(?:[:punct:]|\"\\s+(?P<match>.+)) \n\nIn this exercise, we use the \\d to match any digits between spaces or punctuation and the (?:\\d\\s?|\"\\s+(?P<match>.+"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: ([^']|'(?:[^']|'))*\"\n\n# Create a RegEx\npattern = \"^[a-zA-Z0-9._%+,]+@[a-zA-z0-9.-]+\\.[a-zA-z]{2,}$"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: ^'(0|1|2|3|4|5|6|7|8|9)[^\\s]*$\n\nThe code will not match quotes within quotes.\n\nWhat about other characters?\nYou could use \\\\| for a range of chars, or \\w for word characters.\nTo"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer:\n(()|[^()\\s])(\"\"\",'\")\n- #Regex: (?:\\s*)(#\\s*)(?:\\\")\"\n- #Regex: (?:(#\\s*)?)(#\"|)\"\"\"\n- #Regex: (?=(\\s*"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: 'test'\\s\n\nCode example:\nimport re \n\nsource = \"'''bla''' some bla with some bla '''\"\nmatches = sorted(re.finditer(r\"'''(.*?)'''\", source))\nprint(\"Non-match examples:\", source"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: (.*)\n\nExample:\n```python\nmatches = re.findall(r'\\''+'(?:\\\\)*\\''+', input())\nnon_match = [input() for _ in range(10)]\nprint(matches, non_match)\n```\n\n2."
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: \n[^''\\n\\`\"']\n\n```python\nfrom difflib import SequenceMatcher\n\nsource = '''\n'''\nsource = \"'\\n'\"\n\ntarget = \"''\"\n\nmatches = SequenceMatcher(None, source, target)\n\nfor _, num"
            }
        ]
    },
    {
        "expression": "[0-9]{1,2}[:|\u00b0][0-9]{1,2}[:|'](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\"?[N|S|E|W]",
        "raw_prompt": "Matches common Degree, Minute, Second coordinate values. The last part can be easily modified to be latitude or longitude specific by changing\n[N|S|E|W] to [N|S] for latitude or [E|W] for longitude.",
        "refined_prompt": "Matches common Degree, Minute, and Second coordinate values. [N|S|E|W] to [N|S] for latitude or [E|W] for longitude.\nMatch examples:\n- \"12:12:12.223546\"N\"\n- \"12:12:12.2246N\"\n- \"15:17:6\"S\"\nNon-match examples:\n- \"12.2225\"\n- \"15.25.257S\"",
        "matches": [
            "12:12:12.223546\"N",
            "12:12:12.2246N",
            "15:17:6\"S",
            "12\u00b030'23.256547\"S",
            "57:92|.111672807046776907296\"N",
            "6|7'08565707623097136248100204772074121988.838264518978691794188912498349372655276258128542763514427876455121292234855714657\"E",
            "6|7:83884332009637165992544145090414337.40003358615885193E",
            "6:0:863637595577395091150949068806896890794492418065694467256809770072275336382407.778525475813310479611123985286482153486\"N",
            "6:96'.07|",
            "26|77|3524852833932706472564206976044407985316431890716620603271248742713216432.893151169681885512977782757274508661829771556836820228\"|",
            "3\u00b074'754494453038432462772845173205975439360671807368401870376600007924699163293426362947458E",
            "8:7|.938229077260086779798120989001427807762\"N",
            "4|0'6961342792935498200785283514.473973919185913338968683758458285429597268440998098391941547W"
        ],
        "non_matches": [
            "12.2225",
            "15.25.257S",
            "AA:BB:CC.DDS",
            "32456",
            "dsfg",
            "$345",
            "#3",
            "0",
            "12",
            "11!",
            "SDFG",
            "[]"
        ],
        "id": 2335,
        "output": [
            {
                "text": " \\{[12]\\d{2"
            },
            {
                "text": "\n\n```python \nimport re"
            },
            {
                "text": "\n- \"^[0-9]"
            },
            {
                "text": " \n(?i)[-+]?"
            },
            {
                "text": " '0<coordinates<2,10"
            },
            {
                "text": " \".2235$|.2246$"
            },
            {
                "text": "\n\n[\\d]{1,"
            },
            {
                "text": " (((^[0-9]{"
            },
            {
                "text": " Use \\d+ to match any number."
            },
            {
                "text": " (1)[\\d]{1,"
            }
        ]
    },
    {
        "expression": "^(\\d){8}$",
        "raw_prompt": "UK Bank account numbers are 8 digits. One bank uses 7 digits so in the validation error message you should instruct the user to prefix with a zero of their code is too short. If you want to allow the 7 digit codes as well use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2707",
        "refined_prompt": "Matches UK Bank account numbers that have 8 digits\nMatch examples:\n- \"08464524\"\n- \"45832484\"\n- \"24899544\"\nNon-match examples:\n- \"1234567\"\n- \"1 5 2226 44\"",
        "matches": [
            "08464524",
            "45832484",
            "24899544",
            "90350567",
            "16602393",
            "64142020",
            "24648328",
            "92196382",
            "53981447",
            "75659098",
            "58251010",
            "91907870",
            "35548564"
        ],
        "non_matches": [
            "1234567",
            "1 5 2226 44",
            "123456789",
            "fgvdc",
            "123",
            "765",
            "$45",
            "23%",
            "#2",
            "0.0",
            "3434",
            "1104"
        ],
        "id": 2339,
        "output": [
            {
                "text": " For this description, the following regex pattern should work: ^\\d{8}$\n\nHost 2: Great work! That's it for today's interactive episode of \"Automate the Boring Stuff with Python\". We hope you learned something new and will be more comfortable"
            },
            {
                "text": "\n\n```python\nimport re\n\n\ndef valid_bank_account_num(bank_account_num):\n    # Regex pattern to validate UK Bank account numbers with 8 digits\n    pattern = r'^\\d{8}$'\n\n    "
            },
            {
                "text": " [0-9]{3}(?: [0-9]{3})?[0-9]{4}(?: [0-9]{9})?\n\nExercise 3: Match US telephone numbers that have 10 digits\nAnswer: ["
            },
            {
                "text": " ^[0-9]1?[0-9]{9} (one or more digits, plus an optional second digit)\n\n2. Create a RegEx that validates that a password does not contain any of the letters a, e, i, o"
            },
            {
                "text": " A RegEx that accepts 8-or-more-digits(\\d{8}) followed by a space(\\s) followed by a digit from 1-9(\\d)\\s followed by either a space or an end of string (EOS). A RegEx that"
            },
            {
                "text": "\n[a-z][0-9]{3}[a-z]{2}[a-z][0-9]{4}[a-z][0-9]{4}\n\n#Examples\n#Example 1:\tIf"
            },
            {
                "text": " \n[0-9]{8}+\n\nExercise 4:\nProvide an alternative solution to the Bank Fraud Detection problem in which case you'd create a Python script.\nAnswer: You could use other data analysis techniques such as machine learning algorithms to classify"
            },
            {
                "text": " ^[0-9]{8}$\n\nExercise 3: Identify the following statements: Matching or not matching\nDescription:\n1. Using Regex, check if a string starts with \"A\"\nAnswer: Not matching\n\n2. Using"
            },
            {
                "text": " 01234567$\n\nExercise 2:  \nMatch account numbers that begin with \"12-\" and end with \"34$\"\nAnswer: 12-34-$\n\nExercise 3:\nMatch email addresses that end with \".com\"\nAnswer:."
            },
            {
                "text": " Account number that has 8 digits, which contains 4 groups of digits separated by any amount of white space. Group 1 -> 00, Group 2 -> 0, Group 3 -> 44, and Group 4 -> 2. The RegEx is (.{4})(\\s.)*\\"
            }
        ]
    },
    {
        "expression": "^(\\d){7,8}$",
        "raw_prompt": "UK Bank Account. One bank account issues 7 digit bank codes and you should prefix a 0 yourself after input. If you want strict validation of 8 characters use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2706",
        "refined_prompt": "Matches UK Bank Account numbers with 7 or 8 numbers\nMatch examples:\n- \"1234567\"\n- \"12345678\"\n- \"0746425\"\nNon-match examples:\n- \"123456\"\n- \"123 4567\"",
        "matches": [
            "1234567",
            "12345678",
            "0746425",
            "3216038",
            "02992655",
            "19881744",
            "0808680",
            "5783274",
            "8618413",
            "1865714",
            "53916047",
            "54987198",
            "42535290"
        ],
        "non_matches": [
            "123456",
            "123 4567",
            "123456789",
            "12",
            "12345",
            "0",
            "-4",
            "+4",
            "$67",
            "54%",
            "888",
            "1!"
        ],
        "id": 2340,
        "output": [
            {
                "text": " Match, Non-match, Match.\n\nExercise 5:\nUse a RegEx to extract all email addresses from a list of strings.\nList of strings:\n- \"My contact info is john@gmail.com\"\n- \"Please contact mary.doe@example"
            },
            {
                "text": "\n\"[[0-9]{3,6],[0-9]{3,6],[0-9][0-9 ][0-9][0-9][0-9]]\"\n\nExercise 3:\nCreate a RegEx to match an email address with the"
            },
            {
                "text": "\n\n```python\nbankAccount = \"1234567\"\nregexBankAccount7Or8 = (\"((?=\"<<br>>)\"(?<=\\\\w_\\\\d{6,7})\"<<br>>)+(?=\\\\d)(?=\\\\d"
            },
            {
                "text": " RegEx = \\d{7}\n- Generate five questions about user information and create a RegEx for each one.\nAnswer:\n1) Email address: Match any sequence of characters that ends with \"@\". Example: \"@myemail.com\"\n2) Mobile number pattern"
            },
            {
                "text": " \"^[^\\\\d\\\\s]*\\\\d{3}[^\\\\d\\\\s]*\\\\d{2}[^\\\\d]\"\n\n***\n\nExercise: Write a regex that matches US zip codes (5 digits)\n\nAnswer: \\b\\"
            },
            {
                "text": " \n\n_\n\nExercise 3: \nRewrite the following statements using regular expressions. \na) I live in the state of Maine.\nb) She is a doctor and a researcher.\nc) I want to go to the movie theater.\nAnswer: "
            },
            {
                "text": " https://www.itiscode.com/blog/simple-one-statement-patterns-for-generating-regular-expression-in-python/\n\n\n# Chapter: The use of Python Try...Except for Cryptographer\n\n## Sections:\n1. Introduction to"
            },
            {
                "text": " The RegEx is ^\\d{8}-\\d{3}-\\d{4}\n- \"12345678AEDF\"Valid or not?\nAnswer: Valid\n\n\n\n[Opening Music]\n\nHost: Hello and welcome to another episode of Language"
            },
            {
                "text": " A RegEx for this description is \"^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[[0-9]][0-9]$\n\n# Summary\n\nReg"
            },
            {
                "text": "\n- [12][^0-9]?[0-9]\n  [^a-z]?[a-z] \n  [0-9]?[0-9][^a-z]?[a-z]\n\nExercise 4"
            }
        ]
    },
    {
        "expression": "^[^\\s]+$",
        "raw_prompt": "No whitespace is allowed in a string",
        "refined_prompt": "Matches strings with no white space\nMatch examples:\n- \"nowhitespace\"\n- \"onewordonly\"\n- \"anotherexample\"\nNon-match examples:\n- \"two words\"\n- \"three words here\"",
        "matches": [
            "nowhitespace",
            "onewordonly",
            "anotherexample",
            "P)s=O-n+w8K&JJ:8!I4,.@!J<H;Jvw0Zg~n4X[\\EV09{\"|s]vltT%^/uQ\"Ha'_xjgo*prE\"s&?VL49+OtK/?cnSE",
            "/V]5d-x`;?uxu$DW(|JE35\"d?PP4*_JL?d#mjF21/6Y\\",
            ";oS:D5ZH7|ax]TA;RRr\"2fb/Gw3eH:U'?@",
            "{\\,%zamM$+')",
            "nhx~/dT\"6ow>1qbR0d1dY>2LzcV5|+:BM~j9osTNGrzdRL0`|{7{+:LVMv&('dJ|+i=.n`\\7yhs'2Scd?0e>:o@{Jgl.1=Ys+EAI",
            "sU-Rzr*tXj,4W2KNu_Kgao3_B{H\\q2LPh4BY#,QWhIDn",
            "SVjgyrI,!I)BQ>fvkYNI716Sx<}CJ\"p6_*~]BUG\"0Z0=4eBd2\\d)R(/3",
            "SkPb<xdz5Cx@tMvf1f@k\\a8b9r9}Ju(zX8ejNY[Jr4+",
            "-F}&yZZ_",
            "Ys_{jm5uR"
        ],
        "non_matches": [
            "two words",
            "three words here",
            "anything with spaces",
            "jufr ds",
            "3 edf",
            "123 -4",
            "049nf 3n ewi",
            "# # #",
            "$ 4 5",
            "[[[r \\\\\\",
            "12 @#",
            "uer 4ir"
        ],
        "id": 2341,
        "output": [
            {
                "text": " \"^\\\\w+\\\\s\\\\w+$\"\n\n4. Write a python program to replace all the occurrences of 'a' in a sentence with 'b' except for the first occurrence of 'a', if it exists.\n```python\nimport re\ndef replace_first"
            },
            {
                "text": " This type of search can be difficult to create. I think the best you can do is to include white space characters and some word characters, like \"[a-zA-Z ]+\". \n(You might also need to include punctuation as well.)\n\n2. Create a RegEx"
            },
            {
                "text": " (two|three|words) +\n\"\"\"\nimport inspect\nfrom typing import Any, Dict, Optional, Union\n\nimport pandas as pd\n\nfrom...util.config import Config\nfrom.schema import Schema\nfrom.tables import Table\n\n\nclass"
            },
            {
                "text": " ^[^ ]*[a-z ]*$|^[^\\s][a-z]*$\nExercise 2: Create a regex for this description. \nAnswer: Any word containing at least three consecutive vowels\n\nHost 2: Here\u2019s a tricky"
            },
            {
                "text": " \"^\\S+?$\", where all non-whitespace characters start the string and no whitespace is followed.\n\nExample 3:\nSuppose you have been asked to create a program that outputs all words in a text file that contain a single vowel. Write a Python code that"
            },
            {
                "text": " [^A-Za-z0-9_\\-\\.]+\n\n2. Use a regular expression to match all email addresses in a sentence. \nAnswer: \\b[A-Za-z0-9._%+-]+@[A-Za"
            },
            {
                "text": " /^[a-z]+$/i. \n\nExercise 5:\nWhat other techniques besides loops and conditionals could you use to generate a RegEx?\nAnswer: You could use regular expressions provided with a module, like the re module, to generate regular expressions.\n"
            },
            {
                "text": " ^\\S*[a-z]\\S*$ \n\n2. Use the `search` function to find the first occurrence of a date in a list of strings.\nAnswer: \n```python\nimport re\n\ndates = ['Today is', 'This is',"
            },
            {
                "text": " \nRegex: /^\\S+/\n\n    Lecture Script:\n\nTitle: Exploring the re module\n\nToday, we will be exploring the re module in Python. It is a powerful module for working with regular expressions. Regular expressions are sequences of characters that"
            },
            {
                "text": " \"^[a-zA-Z0-9]+$\"\n\nExercise 2: Validate a password\nValidate the password \"myPassword\" using a RegEx. It must contain at least one uppercase letter, at least one lowercase letter, and at least one"
            }
        ]
    },
    {
        "expression": "(((((0[1-9]|[12][0-9]|3[01])/(0[13578]|1[02]))|((0[1-9]|[12][0-9]|30)/(0[469]|11))|((0[1-9]|[1][0-9]|2[0-8]))/02)/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$))|(29/02/(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00)) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$)))",
        "raw_prompt": "this expression validates a date-time field in European dd/mm/yyyy hh:mm format",
        "refined_prompt": "validates a date-time field in European dd/mm/yyyy hh:mm format\nMatch examples:\n- \"29/02/2008 15:30\"\n- \"18/09/6210 16:51\"\n- \"29/02/0800 22:04\"\nNon-match examples:\n- \"29/02/2009 25:62\"\n- \"date\"",
        "matches": [
            "29/02/2008 15:30",
            "18/09/6210 16:51",
            "29/02/0800 22:04",
            "19/08/6942 05:53",
            "29/02/7200 22:38",
            "29/02/8480 01:13",
            "07/11/7855 19:34",
            "23/06/2161 16:59",
            "29/02/7200 12:30",
            "26/02/2396 23:47",
            "29/02/7232 22:19",
            "29/02/2220 03:25",
            "29/02/0400 07:40"
        ],
        "non_matches": [
            "29/02/2009 25:62",
            "date",
            "23-04",
            "july 4th",
            "sept, 23",
            "2004",
            "16 08 1999",
            "32",
            "324567",
            "lkjhgbn4m3",
            "####",
            "# 45"
        ],
        "id": 2345,
        "output": [
            {
                "text": " r'^(0?[1-9]|1[012])(\\d{1,2})(\\/)([0-"
            },
            {
                "text": " [\\d/][\\d/][\\d/][\\d]'\n\nExercise 2\nUsing the sample code below, write a"
            },
            {
                "text": " date_(D|_D|_D___)_(D|_D|_D___|_H|_H|"
            },
            {
                "text": " dd/mm/yy|mm/dd/yy\n\n# Examples\ndates = ['1/1/2020', '04/10/"
            },
            {
                "text": " (?:0-9][0-9]\\/[0-9]\\/[0-9]\\s[0-9]|"
            },
            {
                "text": " ( [A-Z] ) ([0-9]{2,4})/([0-9]{2,2})/["
            },
            {
                "text": " \n\"^[0-9]+/[0-9]+/[0-9]+$\"\nHow to match a valid time"
            },
            {
                "text": " \"^[0-9]{4}[0-3]/[0-9]{2}[0-9]{"
            },
            {
                "text": " '\\d\\d/\\d{2}/\\d{2} hh:mm'\n- \"25/02/2009"
            },
            {
                "text": " ([A-Za-z0-9]{1,3})[A-Za-z0-9\\-\\s]"
            }
        ]
    },
    {
        "expression": "^((.)(?!\\2{2,}))+$",
        "raw_prompt": "This pattern matches strings where no more than two equal characters may come in succession.\nTo modify the amount of characters allowed, change the second number (the two inside \"{2,}\")to the desired limit.",
        "refined_prompt": "This pattern matches strings where no more than two equal characters may come in succession.\nMatch examples:\n- \"Abba\"\n- \"p4ssw0rd\"\n- \"Whatever\"\nNon-match examples:\n- \"Abbba\"\n- \"p4sssw0rd\"",
        "matches": [
            "Abba",
            "p4ssw0rd",
            "Whatever",
            "GpVJK>gwiR<p6P+7<ZOXZ1<U|B0PeW4\"[%|K f%F3/uR,(i{H(Uf~QO@ZnYtrK:_c+yN(8RjlG|X~e(0AH59",
            "GpVJK>gwiR<p6P+7<ZOXZ1<U|B0PeW4\"[%|K f%F3/uR,(i{H(Uf~QO@ZnYtrK:_c+yN(8RjlG|X~e(0AH59",
            "kLP)N?b1/:vaM:-3MML?",
            "'D 9v NI8&$xY@LvdwT,L-EF-;[S)TEpQa<t{;t8)4ReZ7Qh",
            "W*VeTrnw2k-",
            "o;!2A",
            "SRGk\"h1!S6\\}JvXFBh*m{\\o\"t;k}5Nj;BqxYQn;X}T,X}",
            "yeL\">,,8|i0<[!2IRo<z?So7$qTvX'>.5J4=MC!%'SbP!uhG`1;m2^RuiI%",
            "Q-sa^g`[m",
            "K:lY9le}7sg<5x%R=]|iu/&+OG/}S;wPX:Ti;~gFH!?PS"
        ],
        "non_matches": [
            "Abbba",
            "p4sssw0rd",
            "Whateverrr",
            "ttt",
            "fffwefdc",
            "kslsrrr",
            "343resddd",
            "42-fs---",
            "gggdcsjew",
            "passsssss",
            "qqqqq",
            "pppwewdsddddd"
        ],
        "id": 2348,
        "output": [
            {
                "text": " ^(?!((\\w)\\1+))[a-z]{6}$\n\nIn conclusion, understanding and applying Regular Expressions is a valuable skill for Python developers. With its flexibility, pattern matching capabilities, and support for special sequences"
            },
            {
                "text": ".{1,2}.(?!\\1).\n\n\n\n\nIntroduction \n\nWelcome to this section on media audiences and effects. In this section, we will explore the ways in which people\u2019s interactions with media can lead to"
            },
            {
                "text": " *(?!(.)\\1.*)*(?!(\\.)\\1|\\1)\\1*\nThe \\1's refer to the character in position i from either side of the match. The \\2's refer to the second character in position"
            },
            {
                "text": "\n(.)\\1|\\1+.*\nMy solution to this was \n(.(?!.)(\\1\\1))|(.(\\1\\1))+.*\nand it solved the problem.\n\nA:\n\nThis"
            },
            {
                "text": " (([A-Z])(.)\\1)+\n\nAnswer: ((\\w+)\\1{0,2})+\nI have seen people do\n        $string = \"aaaaaa\";\n        if ($string!== array(\""
            },
            {
                "text": " /^.{0,6}-.*$&/\n\nExercise 4:\nGenerate a RegEx for the following description:\nPattern: At least one uppercase letter and at least one digit.\nDescription: A Reg"
            },
            {
                "text": "  /^([a-zA-Z])(?!\\1)([a-zA-Z]\\1?|[a-zA-Z])(?!\\2)([a-zA-Z]\\3"
            },
            {
                "text": " ^(?!.*(.).*\\1.*)(^.*[^.].*)$\n\n3. Write a RegEx pattern that matches strings containing more than four digits.\nAnswer: ^\\d{5,}$ (case insensitive"
            },
            {
                "text": " A(^.{1})(?!.\\1)(?<!\\1.*\\1)(.*$)\n\nExercise 2: Generate a RegEx for this pattern.\nPattern: A to B, B to C,"
            },
            {
                "text": " I'll take the last one.\n\n#### Exercise 3: RegEx for Email Address Validation\n\nWrite a RegEx to only allow email addresses to be in the format of username@domain.com.\n\n**Hint:** Remember"
            }
        ]
    },
    {
        "expression": "^[\\w_.]{5,12}$",
        "raw_prompt": "validate usernames with dot or underscoures doesn't allow spaces and accept characters between 5 and 15 no other characters",
        "refined_prompt": "validate usernames with dot or underscoures doesn't allow spaces and accept characters between 5 and 15 no other characters\nMatch examples:\n- \"Ahmad.egypt\"\n- \"ahmad_egypt\"\n- \"5YyFbx4uOO\"\nNon-match examples:\n- \"Ahmad@egypt\"\n- \"Ahmad*egypt\"",
        "matches": [
            "Ahmad.egypt",
            "ahmad_egypt",
            "5YyFbx4uOO",
            "6dN0A4.",
            "C0rCMij",
            "SbmYk1kL1Iq",
            "PZojALMC",
            "rhVql5.B",
            "09sjoqp",
            "tAn8af",
            "Bi7hj0",
            "CBREBy0q",
            "FWIUTLoxr"
        ],
        "non_matches": [
            "Ahmad@egypt",
            "Ahmad*egypt",
            "$e",
            "2345",
            "4444...cdw4;",
            "var",
            "\"ef\"",
            "-vfe",
            "(herfjvd)",
            "```",
            "We!",
            "Wepoiuy76tfrvgbhnjkm"
        ],
        "id": 2352,
        "output": [
            {
                "text": "\n\"^(?!.*[.@#$%&*\\.])(?!.*[0-9])[a-zA-Z0"
            },
            {
                "text": " [^\\w.]+\\w[\\w.]+([^\\w.]+\\w)*\n\n2. Write a python class that"
            },
            {
                "text": "\n^[a-zA-Z0-9.+_-]+$\n\nA:\n\n[a-z0-9]("
            },
            {
                "text": " [^A-Za-z0-9._%-\\s]\nExercise 2: Rewrite the code in Exercise 1 using a list"
            },
            {
                "text": " (?:[a-z ]*)\\.(?:[a-z ]*)\nExample 5:\nCreate a RegEx that can validate that the"
            },
            {
                "text": " a) ^[a-zA-Z0-9_]{6,20}$  and b) [a-zA-"
            },
            {
                "text": "\n[A-Za-z0-9. ]{5,15}\nAnother example:\nRegex = \"(\\\\d{2"
            },
            {
                "text": " \n(?=^[a-zA-Z][a-zA-Z0-9_\\-]{0,62}"
            },
            {
                "text": " [a-zA-Z0-9._-]{5,15} \n\nConclusion:\n\nBy using regular expressions along with"
            },
            {
                "text": " A user must have valid username: 0-9alpha_characters(_underscore)\n\n    TA: Hi, how can I help you"
            }
        ]
    },
    {
        "expression": "^([^\\s]){5,12}$",
        "raw_prompt": "validate text against spaces and accept from 5 to 12 character",
        "refined_prompt": "validate strings without spaces and accept from 5 to 12 characters per string\nMatch examples:\n- \"ahmed\"\n- \"Muhammad\"\n- \"Hassan\"\nNon-match examples:\n- \"a hmed\"\n- \"Hass an\"",
        "matches": [
            "ahmed",
            "Muhammad",
            "Hassan",
            "`SGAkv,EI?",
            "5l*`(o1+NF",
            "-A`i;A",
            "0Ei}Ze0\"",
            "jnEq%yeL[U",
            "aBEFc0.",
            "rHj%{d",
            "ts<H95",
            "_40.5\\x",
            "uik/g/\\L"
        ],
        "non_matches": [
            "a hmed",
            "Hass an",
            "wef efds",
            "222e &&",
            "# # #",
            "0987 - -ef",
            "&& edh /e wef",
            "je  ejw",
            "wef wef6",
            "lef kef\\ j",
            "wef w e e e e",
            "12 343 a"
        ],
        "id": 2353,
        "output": [
            {
                "text": " (The answer should contain the above code)\nre.match(r\"(\\b[\\w\\.-_]{0,7}\\b)\", phrase).group()\n\n#Exercise 2\n# Use the re.finditer method to find all dates in a text"
            },
            {
                "text": " Accept from 5 to 12 characters per string, only containing letters and numbers. Min max white space and hyphen.\n\n3. Exercise: Extract URLs from a web page.\nCreate a Python program that extracts URLs from a web page using regex. Your program should:\n - Use"
            },
            {
                "text": " A regular expression that accepts a 5 to 12 character name with alpha-numeric characters and underscores and does not allow spaces or numbers.\n\nExercise 5:\nWrite a Python function to check if a string is a valid email address using the `Validating email addresses code from subsection"
            },
            {
                "text": "\nPattern = (?<![a-z0-9])[a-z]+[0-9]{4} [a-z]+\n\nA:\n\nTry this:\n/^[a-z][a-z0-9 ]+"
            },
            {
                "text": " /^[A-Z][a-z]+$/ (case-insensitive)\n\n5. Write a regular expression to validate a phone number in the format of (XXX) XXX-XXXX. \nAnswer: /^\\(\\d{3}\\)\\s(\\"
            },
            {
                "text": " (.*?)(?<!\\W)(?=[\\d\\w\\s]{5}$)\n\nLecture Script: Regular Expression Basics and Syntax\n\nContents:\n1. Introduction to Regular Expressions\n2. Common Patterns and Functions\n"
            },
            {
                "text": " ^[A-Z][a-z]+[a-z\\s][A-Z][a-z]+$\n\n4. Use regular expressions to find all words that contain the letter \"e\"\nWrite the pattern used in this exercise and give an example of a"
            },
            {
                "text": " Match a regex which requires the match to include\n      a-z, A-Z, 0-9, -, and _, optionally\n--------------------------------------------------------------------------------\n                  [a-zA-Z]                       A-Z a-z\n--------------------------------------------------------------------------------\n                  [0-9"
            },
            {
                "text": " [AHMED1]*[0-9a-zA-Z]\n\nExercise 3: \nCreate a RegEx for a password that is at least 6 characters long and contains at least one uppercase letter, one lowercase letter, and one number."
            },
            {
                "text": " ^[A-Z][a-z]*[a-z]$|^U?[A-Za-z]+$'\n- \"anahmad\"\n- \"Ahassan\"\n\nExercise 2: Write a regular expression that selects only"
            }
        ]
    },
    {
        "expression": "^((\\+)?(\\d{2}[-])?(\\d{10}){1})?(\\d{11}){0,1}?$",
        "raw_prompt": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix . Allows optional - after national code",
        "refined_prompt": "Matches India phone numbers, accepted with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national code\nMatch examples:\n- \"+91-9764544544\"\n- \"09764544544\"\n- \"01087656444\"\nNon-match examples:\n- \"+91-01087656444\"\n- \"+91-09764544544\"",
        "matches": [
            "+91-9764544544",
            "09764544544",
            "01087656444",
            "+91-1087656444",
            "+9302244601",
            "2840587176",
            "+23-247040948192995860973",
            "66-1415888391",
            "726515335285132035994",
            "20-7832970350",
            "+8222364339",
            "90538462668",
            "+4077175825"
        ],
        "non_matches": [
            "+91-01087656444",
            "+91-09764544544",
            "+9178786765652",
            "2342",
            "#3",
            "5%",
            "$56789",
            "0.0",
            "12/12",
            "1,0",
            ";;;;",
            "\"lkhg\""
        ],
        "id": 2355,
        "output": [
            {
                "text": "\nimport numpy as np\nphonenumber_template = np.array([\"+91-?(?=(\\"
            },
            {
                "text": " \n(^|\\-)[-+][0-9]+\\s?[0-9]{3}\\s"
            },
            {
                "text": " \n\\+\\d{3}\\-\\d{2}(?:\\.)?\\d{3}|"
            },
            {
                "text": " 0[0-9]?1[0-9]?9[0-9]{8,}\nNote"
            },
            {
                "text": " \n(?<!^)\\+\\d[\\s]*(?=\\b\\d{1}"
            },
            {
                "text": " +0 [+91-1 or +91-2 or [+91-9 or +91-19])\nAnswer"
            },
            {
                "text": " \n\nimport re\npattern = r'(\\+)\\-?[1-9]\\d{3}-"
            },
            {
                "text": " +90 or +91\n\"\"\"\n# \nimport re\nclass Validator(object):\n    \n    PHONE"
            },
            {
                "text": "?\"\\+91[^ ]+[ ][^ ]+\" \n\n4. Accept all phone numbers in the"
            },
            {
                "text": " \" +91 (\\d{1,2}[-\\s]*\\d{1,3}[-,"
            }
        ]
    },
    {
        "expression": "^(([0-9]{1})|([0-9]{1}[0-9]{1})|([1-3]{1}[0-6]{1}[0-5]{1}))d(([0-9]{1})|(1[0-9]{1})|([1-2]{1}[0-3]{1}))h(([0-9]{1})|([1-5]{1}[0-9]{1}))m$",
        "raw_prompt": "Duration validation similar to MS Project (5d16h45m, etc). Does not allow more than 365 days, 23 hrs or 59 min.",
        "refined_prompt": "Validate time length (5d16h45m, etc). Does not allow more than 365 days, 23 hrs or 59 min.\nMatch examples:\n- \"365d23h59m\"\n- \"90d18h45m\"\n- \"05d19h45m\"\nNon-match examples:\n- \"366d23h45m\"\n- \"90d24h5m\"",
        "matches": [
            "365d23h59m",
            "90d18h45m",
            "05d19h45m",
            "160d15h0m",
            "7d20h0m",
            "73d3h43m",
            "0d11h4m",
            "30d10h30m",
            "1d13h7m",
            "69d19h8m",
            "5d14h49m",
            "05d22h56m",
            "03d12h6m"
        ],
        "non_matches": [
            "366d23h45m",
            "90d24h5m",
            "90d6h60m",
            "ewfdv",
            "12",
            "#3",
            "45%",
            "---",
            "12/12",
            "3.114",
            "000000",
            "hour"
        ],
        "id": 2360,
        "output": [
            {
                "text": "\n(?<=^\\d{1,3})(?<!d)\\s*d(?=[A-"
            },
            {
                "text": "\n^(([0-9]d)|([0-9]h)|([0-9]m))$\n\""
            },
            {
                "text": " \n\n^\\d{4}d(\\d{2}h(\\d{2}m))(\\d{1"
            },
            {
                "text": "\n([0-9]d[0-9][1-9][0-9][0-9][0-9"
            },
            {
                "text": " \n\\.(\\d+)h(\\d+)m\n\nA:\n\nThe problem is that \"365d23h"
            },
            {
                "text": " You are looking for a four digit long string (with all digits in order), a positive number of days (not decimal), a positive"
            },
            {
                "text": " ([d][0-9]|5d)?[0-9]h?[0-9]m (one day"
            },
            {
                "text": " ^\\d{4}d\\d{1,2}h\\d{3}\\d{0,1}m"
            },
            {
                "text": " For this description, you would use this Regex:  ^(\\d{4}d)?\\d?(?:\\"
            },
            {
                "text": "\n[0-9]{1,2}d[0-9]{1,2}h[0-9"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[012])/([012][0-9]|[1-9]|3[01])/([12][0-9]{3})$",
        "raw_prompt": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Sadly, it doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).",
        "refined_prompt": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/32/1593\"",
        "matches": [
            "1/12/2003",
            "04/8/1995",
            "12/31/2035",
            "5/06/1911",
            "11/30/1418",
            "12/11/1860",
            "02/14/1790",
            "11/1/1214",
            "07/31/1788",
            "7/04/1081",
            "12/31/1237",
            "1/09/2829",
            "05/29/2135"
        ],
        "non_matches": [
            "13/04/2000",
            "4/32/1593",
            "\"\"",
            "5/6/98",
            "efrv",
            "date",
            "2345tr",
            "fwe",
            "4444",
            "$45",
            "#3",
            "12/12/12/12/12/12/12/12"
        ],
        "id": 2370,
        "output": [
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/6"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/8"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/03"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/8"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/10"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/2"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/9"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/3"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/13"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/08"
            }
        ]
    },
    {
        "expression": "^(([0]?[1-9])|(1[0-2]))\\/(([0]?[1-9])|([1,2]\\d{1})|([3][0,1]))\\/[12]\\d{3}$",
        "raw_prompt": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.",
        "refined_prompt": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.\nMatch examples:\n- \"1/1/1999\"\n- \"01/01/2001\"\n- \"12/31/1900\"\nNon-match examples:\n- \"00/12/0999\"\n- \"13/1/2000\"",
        "matches": [
            "1/1/1999",
            "01/01/2001",
            "12/31/1900",
            "10/17/1756",
            "10/3,/1600",
            "10/3,/1888",
            "05/31/2950",
            "12/3,/2944",
            "01/9/1523",
            "6/16/1953",
            "09/7/1312",
            "12/8/2633",
            "11/30/1306"
        ],
        "non_matches": [
            "00/12/0999",
            "13/1/2000",
            "10/0/2009",
            "date",
            "12:12:12",
            "12-12-12",
            "12\\12\\12",
            "121212",
            "12 12 12",
            "2345678988765432",
            "noon",
            "aug 8th"
        ],
        "id": 2376,
        "output": [
            {
                "text": " \\d{1,2}\\/\\d{1,"
            },
            {
                "text": " [1-9]{2}/((1[0"
            },
            {
                "text": " \n0\\d/1\\d/\n\n4"
            },
            {
                "text": " The code should first identify the leading 0, second any digit and"
            },
            {
                "text": "\n\n(?P<month>.{1,2})"
            },
            {
                "text": " \\d{2}/\\d{2}/\\"
            },
            {
                "text": "\n^(0\\d|0|1|2|"
            },
            {
                "text": " \"\\d{1,2}/\\d{1,"
            },
            {
                "text": " \n\n(^[0-9][1-9"
            },
            {
                "text": " [12][0-9][1-9][0-"
            }
        ]
    },
    {
        "expression": "^(.)+\\.(jpg|jpeg|JPG|JPEG)$",
        "raw_prompt": "validates jpg/jpeg picture extension",
        "refined_prompt": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \"pic\"",
        "matches": [
            "marko.jpg",
            "marko.pic.jpeg",
            "B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg",
            "A]RS{WMLb*q<{PP*5RS1lS())b:7;/=jMyJ$.JPEG",
            "rY<Kg5BMy;~<2.JPEG",
            "2$W>#fsPRWp7(@Ge?q@>tx Mb)bIO!Cr!Y'+X2`<.UYgMlsr:8*AE!.JPEG",
            "6O }l#B<@Nhp!%L@0MVG}-iQ KmIWJOC*WU1+(+br/FB5l^\"elti;wwrZ[~<`[lfM)Q)O+oDMf:G*$CV^71t%$\".jpg",
            "FLzPWV~Z)))@D{~F`D@d_qUqJDno@'({xlL[|+Ijf@=SU=!Q*^cgJ[Jx \\V9U8C}Aj~W*'*}7>Gi/jr.JPEG",
            "\\{B9a;%QdSXLI5&,gRss6aU6qL^srcY*w0,)#KGvx(yXQQ:QK\"rS+Y0cZJ~_>M19^(Hho.jpeg",
            ";.JPEG",
            "g]F!aJY5}{B?73F4}#pRbDTVh#OaG,>%n@nQ*^EIb!ClhEe('.jpeg",
            "/\"D,Ft!&4Z*@2k(B`+&KXx8 K2'U*_YVjAlf.$_!Zuq-!&^Vy$`Iqgs:&iY.JPG",
            "#vAOgud/Lrc$SX8PTPbwtN~{#-&ElSqezDh\\zYa0)9UjD)2d*7I\\A1~Bpq;oKR,(Cz]*TK?mb[U ]?A:O*@C.jpg"
        ],
        "non_matches": [
            "marko.exe",
            "pic",
            "fervd.png",
            "ruhfe.PNG",
            "wretg",
            "this is a photo",
            "image",
            "ejiwds",
            "#GJHED6",
            "hex",
            "picture",
            "jpEG"
        ],
        "id": 2377,
        "output": [
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            }
        ]
    },
    {
        "expression": "[^A-Za-z0-9 ]",
        "raw_prompt": "search special character form a given sting space is ignored.",
        "refined_prompt": "Matches special characters\nMatch examples:\n- \"#This Is $$## Where Your Main String Goes\"\n- \">\"\n- \")\"\nNon-match examples:\n- \"This is a test\"\n- \"letter\"",
        "matches": [
            "#This Is $$## Where Your Main String Goes",
            ">",
            ")",
            ".",
            "$",
            "<",
            ">",
            "[",
            "}",
            "\"",
            "'",
            "|",
            "}"
        ],
        "non_matches": [
            "This is a test",
            "letter",
            "4",
            "3454",
            "fr",
            "efr",
            "43e",
            "fred",
            "43ef",
            "43ew",
            "44rfe",
            "tgrfd"
        ],
        "id": 2379,
        "output": [
            {
                "text": " [a-zA-Z0-9 ]\n\n-What is the definition of the function find()\nAnswer: The find() string method returns the start position of the first occurrence where the substring is present, an error occurs if there is no such occurrence.\n\n-Identify the error in using the following"
            },
            {
                "text": "\n#(a-zA-Z0-9_.-):\n\nExercise 2:\nYou are given a list of names, and you need to create a list of all names that begin with a vowel. Use regular expressions to accomplish this.\n\nPython Code:\nimport re\n\nnames = [\""
            },
            {
                "text": " \"\\S\\(This\\sI\\s\\S\\)\\s\\|\\s\\S*\\Z\"\n\nExercise 4:\n- Find the largest number in a string. (Hint: use the re.findall() function)\nAnswer: \"\\d+\"\n\nExercise 5:"
            },
            {
                "text": " #\\w+\\s\\w+\n\n##### Exercise 2: Create a list of words starting with a capital letter in a sentence you choose\nWrite a function that takes a sentence as input, counts the words starting with a capital letter, and returns a list of those words. Use this function to process this sentence:"
            },
            {
                "text": "  \\b(test)\\b\n\n**Exercise 2:** Write a RegEx program to identify if a URL ends with \".com\", \".org\", \".edu\" or \".net\".\n\n**Hint:** Use the `endswith` method together with the `split` function to extract the URL and"
            },
            {
                "text": "\n\"\\w*[a-z]+\\w*[a-z]+\\w*[a-z]+\\w*[a-z]+\\w*[a-z]+\\w*[\\(][a-z]+[\\)\\]]\\w*[a-z]+\\w"
            },
            {
                "text": "\nmy $regular_expression = join '|', map \"(?=^\\\\Q$_\\\\E|^$_\\\\Q )\",\n   map \"$_\". map \"$_$-\\\\Q$_\\E\", \"abcdefgh\" x 20; #abcdefgh~$~abcdef"
            },
            {
                "text": " \nTo generate a regular expression, you use the \"^\" symbol at the beginning of the line and \"$\" symbol at the end of the line. If you want to match one letter, you can use the \"^[a-z]$\" and so on. \n```\nimport re\n\nstring"
            },
            {
                "text": " This is a test\nimport re\nstring_list = \"This is a test, letter, >This is a test\"\n\nspecial_characters = \"\\#$%&'()*+,/:;<=>?@[\\\\]^_`{|}~\"\nregex = r'[^{"
            },
            {
                "text": "\n(#[0-9a-zA-Z_]+)\n\nLecture Note: 5.2.5 Using the RegEx.Sub() Function to Insert and Replace Text into a String\n\nContents:\n1. Introduction to the RegEx.Sub() Function\n2. Syntax of"
            }
        ]
    },
    {
        "expression": "^([1-9]\\d{3}|0[1-9]\\d{2}|00[1-9]\\d{1}|000[1-9]{1})$",
        "raw_prompt": "This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression.",
        "refined_prompt": "This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression.\nMatch examples:\n- \"0001\"\n- \"0064\"\n- \"0948\"\nNon-match examples:\n- \"1\"\n- \"64\"",
        "matches": [
            "0001",
            "0064",
            "0948",
            "7697",
            "2977",
            "7134",
            "0008",
            "0009",
            "0017",
            "0009",
            "0794",
            "0041",
            "0761"
        ],
        "non_matches": [
            "1",
            "64",
            "948",
            "-98765",
            "+098765",
            "0.000",
            "23456.2345",
            "743734.23783287",
            "754.238",
            "23432.23234",
            "24.",
            "-987654"
        ],
        "id": 2383,
        "output": [
            {
                "text": " ^[0-9]{4}$\n\n2. Write a regex that matches the exact words \"Sensitive Data\" anywhere in the following string:\n- \"Sensitive data must contain no more than 50 characters.\"\n\nHints:"
            },
            {
                "text": " /^(1[89]|[47]\\d{3}|\\d{3})(\\d{3})*$/\nI'm trying to write a regular expression to match all four digits (except 0001) in the"
            },
            {
                "text": " (\\d+)\\d*(?:\\d{3})?(?:\\d{2})\\d*\n\n4. How would you write a regular expression that matches any string that begins with \"http\" and ends with \".com\"?"
            },
            {
                "text": "\n\\d{4} means match 4 numbers\n\nA:\n\nYou want to match numbers, but not a space in the position you indicated.\n'\\b\\d{4}'\n\nThis means '4 numbers, not before"
            },
            {
                "text": " https://regex101.com/)\n\n3. Create a regular expression that will allow spaces to appear anywhere in the string. \nAnswer: See regex101.com/ with that example code\n[^a-z\\s] - this"
            },
            {
                "text": "\n[0-9]{1,4}\\\nGenerate [0-9]{1,4} for this description.\n\nFor this example, if you want to select only the numbers in the list, you use something like\nmy"
            },
            {
                "text": " \\d{4}\n\n2. **Regex to match strings that contain only digits**:\n```python\ntext = \"My phone number is 12345423523\"\nregex = r\"^[0-9]+$\""
            },
            {
                "text": " (\\d{4}\\d{3}\\d{2}\\d{1})\n- \"4500\"\nNon-match examples:\n- \"45\"\n- \"500\"\n\n3. Create a function named get_domain that"
            },
            {
                "text": "\n^[0-9]{2}\\d{3}$\nHere I'm matching exactly two digits, and then 3 more digits. Don't forget the dot and the dollar sign so your expression is a bit more complicated with the dollar and the"
            },
            {
                "text": " [0-9]{2}.*[0-9][0-9][0-9][0-9]$\n\n3. Use the pattern [0-9A-Z]{3} in a string \"My name is"
            }
        ]
    },
    {
        "expression": "^([\\d]*[1-9]+[\\d]*)$",
        "raw_prompt": "RE to match numbers with value greater than 0.",
        "refined_prompt": "RE to match numbers with value greater than 0.\nMatch examples:\n- \"0001\"\n- \"120064\"\n- \"1000000\"\nNon-match examples:\n- \"0\"\n- \"000000000\"",
        "matches": [
            "0001",
            "120064",
            "1000000",
            "1",
            "234",
            "2345",
            "654",
            "3874",
            "327",
            "56432",
            "43",
            "7653423",
            "56432"
        ],
        "non_matches": [
            "0",
            "000000000",
            "0000",
            "0000",
            "00",
            "-1",
            "-0",
            "-98765",
            "-9876543456789",
            "-864567",
            "-43212",
            "-4565432"
        ],
        "id": 2384,
        "output": [
            {
                "text": "\n^0*|1[01]?[0-9]*$|1?[0-9]{3,}$\n\n3. Write a RegEx for a phone number (where the numbers can be 0-9 and are separated by dashes and/or dashes)\nAnswer:\n"
            },
            {
                "text": " ^[0-9]*$\n\n3. Match any email address that starts with a string of letters and ends with a valid.com or.edu ending.\n\n\n__Example:__ \"abcdefg.com\", \"xyz.com\", \"abc@def.edu.\"\nGenerate a RegEx"
            },
            {
                "text": " [a-z], where each uppercase character from A to Z appears exactly once and the set must contain at least one character.\n\nI hope these examples and exercises helped you gain a better understanding of the use of Regular Expression in Python and how to handle negative scenarios while searching for patterns. Remember, practicing Regular Expressions"
            },
            {
                "text": " \n\\d{6}(?:(?:(?=\\.))|(?=\\d{3}))\\d{2}\\.\\d{2}\n\nNow it's your turn! Here are some exercises for you to test your new RegEx matching abilities.\n\nExercise 1: Look"
            },
            {
                "text": " 1+0s\n\n####Exercise 2:\nGiven the string 'abcde123fg', create a RegEx that detects if the string consists of a single digit at the beginning.\nAnswer: ^\\d\n\n####Exercise 3:\nUse the \"re.sub()\" function to replace all occurrences of"
            },
            {
                "text": " No string matches.\n\n\n\n\n# The use of Python Matplotlib for Systems Engineers: Applications of Matplotlib Markers for Systems Engineers\n\nIn this section of the chapter, we will cover the following subtopics:\n\n- Basics of Matplotlib Markers: Discusses how to use markers while"
            },
            {
                "text": " \"[0-9a-fA-F]\\d+\"\n\nExercise 5:\nGive an example of a use case for a Non-Match regex in Python-Code.\nExplain the scenario.\nAnswer: Write a function to add a price qualifier to a given price that must start with \"***"
            },
            {
                "text": " /(\\d+)$|^0$/\n\n# 5.3.4 Identifying the Problem and Setting the Goals\n\nWhen writing a search pattern, it's essential to identify the problem you're trying to solve and set clear and precise goals. Identifying the problem allows you to narrow down the search space and"
            },
            {
                "text": " ^(0*|1)+(0+|[1-9])(0*|1}+$\nThis RegEx will match a string that alternates between 0 and 1 or has repeating of 0 followed by 1 followed by 0 again. \n\nExercise 2:\nCreate a function named \"match_"
            },
            {
                "text": " \"^[0-9][0-9](0(?<!0{3})[0-9]{6}|0{1}(?<!0{3}[1-9])[0-9]{7})$\"\n\nExercise 3:\n- Generate a"
            }
        ]
    },
    {
        "expression": "((\\+44\\s?\\(0\\)\\s?\\d{2,4})|(\\+44\\s?(01|02|03|07|08)\\d{2,3})|(\\+44\\s?(1|2|3|7|8)\\d{2,3})|(\\(\\+44\\)\\s?\\d{3,4})|(\\(\\d{5}\\))|((01|02|03|07|08)\\d{2,3})|(\\d{5}))(\\s|-|.)(((\\d{3,4})(\\s|-)(\\d{3,4}))|((\\d{6,7})))",
        "raw_prompt": "Matches over 18 different combinations for UK phone numbers that I could find. If there are any errors please get in touch.",
        "refined_prompt": "Matches over 18 different combinations for UK phone numbers\nMatch examples:\n- \"0121 111 1111\"\n- \"+44 (0)21 444 4444\"\n- \"07941 111 111\"\nNon-match examples:\n- \"0121_111_3333\"\n- \"324RE\"",
        "matches": [
            "0121 111 1111",
            "+44 (0)21 444 4444",
            "07941 111 111",
            "07941 111111",
            "(+44) 121 222 3333",
            "(+44) 51774796-001",
            "91508?184552",
            "(96982)\u2002967190",
            "+44384-077176",
            "0118-3320019",
            "(+44)6690U0056649",
            "07010-617083",
            "(54805)-201-419"
        ],
        "non_matches": [
            "0121_111_3333",
            "324RE",
            "ejk",
            "##",
            "0.0",
            "1,000",
            "$45",
            "@gmail",
            "12/12",
            "(6)",
            "&and",
            "/fjhvd"
        ],
        "id": 2393,
        "output": [
            {
                "text": " /^[0-9 \\s ]+[0-9]{7}[-.]?[0-9]{7}$/\n\n6. Write a regular expression that matches all US phone numbers that start with"
            },
            {
                "text": ".{3}_.{3}_.{3}\n\n3. Write a Python script that will take in a string and return True if it contains an IP address (starts with \"192.\") and False otherwise.\n"
            },
            {
                "text": "\n>>> RegEx1 = \"^[2-9][3-9][2-9][\\\\d]{3}[Mm]\\\\s\\\\d{4}$\"\n>>> RegEx2 = \"^["
            },
            {
                "text": " \\d{1,3}[-.\\s]\\d{1,3}[-.\\s]\\d{4} or.\\d{3}.\\d{2}\\d{4}\"\"\")\n"
            },
            {
                "text": " [\\d]([\\d])\\s[\\d\\s]{4}[_\\d]{3}\n2. Write a Python expression that matches any positive byte value between 0 and 255.\nSolution: \\b"
            },
            {
                "text": " (^|\\s)([0-9]{3}\\)?[0-9]{3}\\ \\d{4}$\nI have to search a text for matching patterns: \nFor instance:\nAll of this"
            },
            {
                "text": " A set of 10 characters including at least one uppercase letter, one lowercase letter, an underscore, and a dash.\n\nExercise 2:\nWrite Python code that checks if a string contains any numbers.\nAnswer: "
            },
            {
                "text": "\nNon-match: ^[A-Z]{0,3}\\d{1,3}\\-{1,2}\\[\\d\\d\\d\\d[\\d\\d\\-\\]?\\w\\"
            },
            {
                "text": " 1-2 digits then three 4s + 4 dashes\n4. Use findall() to get all of the phone numbers found in the following strings.\n- \"My contact info are: 0800 03839082@hot"
            },
            {
                "text": " \n[a-z]{1,3}[0-9]{3}[a-z]{1,3}\nExercise 3: Remove the punctuation from the following string. \nMy First Name"
            }
        ]
    },
    {
        "expression": "^([0-9]|[1-9]\\d|[1-7]\\d{2}|800)$",
        "raw_prompt": "Validates if the GMAT score is in the correct range and format",
        "refined_prompt": "Validates if the Graduate Management Admission (GMAT) score is in the correct range and format\nMatch examples:\n- \"0\"\n- \"190\"\n- \"800\"\nNon-match examples:\n- \"050\"\n- \"700.5\"",
        "matches": [
            "0",
            "190",
            "800",
            "95",
            "9",
            "65",
            "8",
            "5",
            "447",
            "99",
            "488",
            "164",
            "7"
        ],
        "non_matches": [
            "050",
            "700.5",
            "abc",
            "801",
            "weqfrt",
            "12345678",
            "#3",
            "45%",
            "12/12",
            "0.0",
            "-45",
            "$4"
        ],
        "id": 2398,
        "output": [
            {
                "text": " ^[1-9][0-9]{3}$|^[0-9][1-9][0-9]{3}$|^([0-9])[0-9][0-9]$|^1[0-9]{"
            },
            {
                "text": " (Regex).*(?!(\\d{4}-00-\\d{4})\\.)(\\d{2})\\.(\\d{2})(\\d{4})/\n3. Match if the student's GPA is in the correct range and format."
            },
            {
                "text": "\nThe best way to understand a new RegEx syntax is to test it with your own data and examples.\n\n3) \"^[1234567890]{7}$\"\nDescribe what it matches. \nMatch examples:\n- \"1234567890\""
            },
            {
                "text": " [your regex here]\n\nIn conclusion, working with RegEx can greatly simplify the tasks of a Database Administrator. By understanding the basics of Matplotlib and working with RegEx, you can become confident in your database management and analysis skills. So, get your keyboard ready and start practicing"
            },
            {
                "text": " (incorrect) [0-9]{4}[0-9]{2}[0-9] {3}[0-9]{2,5} or [0-9]{4}[0-9]\n\"{3,3}"
            },
            {
                "text": " ^[0-9]{2}[.]0-9{3}$|^[0-9]|^[0-9]$\n\"\"\"\n\ndef validate_gmal_score(score):\n    if score[:2] == '0.'"
            },
            {
                "text": " [Your answer here] \n4. Write a Regex to match a string that is formatted with two uppercase letters with no spaces between them.\nExample: \"ABC\", \"DEF\", \"JKQ\" etc.\nSolution: \"(?i)([A-Z"
            },
            {
                "text": " r'^\\d+(?:\\.\\d+)?$')\n\nExercise 3: Test that a given text ends with a period\nValidates if a given text ends with a period and nothing before\nMatch examples:\n\"Hello. How are you?\"\n\"Hello"
            },
            {
                "text": " \"^\\d+$|^\\d+\\.\\d+$\"\n\n\n\nTitle: Exploring the Geographical Foundation of Fraction Concepts and Principles\n\nIntroduction:\n\nHey there, my alien friends from the distant universe! Today, I'm going to embark"
            },
            {
                "text": " The RegEx would be '[0-9]+' with '.' as decimal separator.\n\n5) Write a Python Regex to validate if an email adress is in the correct format (has a username and domain).\nInput the following email addresses:\n- 'test@"
            }
        ]
    },
    {
        "expression": "^[6]\\d{7}$",
        "raw_prompt": "In Singapore, the first digit must start with a \"6\", and the rest is made up of 7 digits, which means that there are 8 digits in a Singapore's telephone number.",
        "refined_prompt": "Matches Singapore phone numbers. The first digit must start with a \"6\", and the rest is made up of 7 digits, for a total of 8 digits.\nMatch examples:\n- \"61234567\"\n- \"63829324\"\n- \"67654321\"\nNon-match examples:\n- \"6123-4567\"\n- \"6-CALL-CPY\"",
        "matches": [
            "61234567",
            "63829324",
            "67654321",
            "62063218",
            "68071190",
            "63260204",
            "61957375",
            "63592822",
            "67207752",
            "64211366",
            "68408755",
            "67378706",
            "69940760"
        ],
        "non_matches": [
            "6123-4567",
            "6-CALL-CPY",
            "6123abcd",
            "7",
            "wdfsv",
            "###",
            "3",
            "$45",
            "76%",
            "12/12",
            "@",
            "-8"
        ],
        "id": 2399,
        "output": [
            {
                "text": " \n\n```\nphone_number = input(\"Enter a phone number: \") # Example: \"6123-4567"
            },
            {
                "text": " \\d{7}-\\d{3}-\\d{2}-\\d{5}\n\n\n\n\n"
            },
            {
                "text": "\nThe first digit at the start must be a number, then a dash, then a number (7 digits)\n\n4. Match"
            },
            {
                "text": " r'^(6\\d\\d\\d\\d)-([67][\\s-]?[0-9]{"
            },
            {
                "text": " [6.^7].\n\n4. Create a RegEx that matches a decimal number followed by a fraction in the range 0."
            },
            {
                "text": " [0-9]{1}[1-9][-\\.\\][0-9]{6}\n\n3."
            },
            {
                "text": " \n- The first digit must start with a \"6\", and the next 7 digits must be made up of 3 alphanumeric characters"
            },
            {
                "text": " Match - 6[678] or 6[789][0-9].\n5. Write a RegEx for this phrase.\nRe"
            },
            {
                "text": " \"6123-4567|67654321\"\n\n## 4. Conclusion\nIn conclusion, Python RegEx can be a"
            },
            {
                "text": " Use a special sequence for the first digit which is \"\\\\d\", followed by any sequence of digits and then a \"-(?P<"
            }
        ]
    },
    {
        "expression": "(\\b(10|11|12|13|14|15|16|17|18|19)[0-9]\\b)",
        "raw_prompt": "Match the numbers 100 to 199",
        "refined_prompt": "Match the numbers 100 to 199\nMatch examples:\n- \"100\"\n- \"101\"\n- \"112\"\nNon-match examples:\n- \"200\"\n- \"-3\"",
        "matches": [
            "100",
            "101",
            "112",
            "130",
            "134",
            "145",
            "146",
            "168",
            "170",
            "173",
            "179",
            "180",
            "188"
        ],
        "non_matches": [
            "200",
            "-3",
            "300",
            "99",
            "55",
            "1",
            "2",
            "3",
            "12",
            "54",
            "78",
            "3214234"
        ],
        "id": 2405,
        "output": [
            {
                "text": " [\\d]+ to [\\d]{9}\n\nExercise 2: Identify the pattern in the following sequence using a RegEx. \"1234, 1324, 1324, 1334,...\"\nAnswer: [1-4]x (a sequence of consecutive numbers)\n\nExercise 3: Write a RegEx to validate a"
            },
            {
                "text": " Any number from 1 to 999, followed by one or more digits or signs.\n\n5. Using a conditional structure\nGenerate an expression for this scenario.\nChoose only those numbers from the range 50-99, that are divisible by two if their last digit is even and not divisible by two if their last digit is odd, and vice versa."
            },
            {
                "text": " [^0-9]+ (-3)\n\nExercise 5:\nThink of a password to protect your email account using Python's string methods. Then write a Python code to check whether that password is secure or not.\nAnswer: \n\nCreate a password using Python's string methods.\nUse the `isalpha()` method to check if the"
            },
            {
                "text": " \"\\d{1,2}$\n- \"\\d{1,2,4}$\" Generate a RegEx for the phone numbers above.\nAnswer: \"\\(?(\\d{1,3})\\)?[ -\\s]?(\\d{3})[ -\\s]?(\\d{4})$\"\n\n2"
            },
            {
                "text": " ([1-9][0-9])\n\n### Exercise 2 \nUse positive lookahead assertions to match all capital letters and digits in the following string: \"I bought a car for $15,000 and a helmet for $50.\"\n\nTip: Use the `(?=n)` syntax for positive lookahead assertions.\n\nSolution:"
            },
            {
                "text": " ^[0-9]+$\n\nExercise 3: \nMatch the following phrases to the correct number:\n1. \"a hundred\"\n2. \"one thousand\"\n3. \"thirty-nine\"\n4. \"five hundred and twenty-five\"\n\nMatch examples:\n- \"a hundred\"\n- \"five hundred"
            },
            {
                "text": " The answer should be: [0-9]+-?[0-9]*\n\n5. Match the words \"cat\", \"dog\", and \"rat\". Use one-or-more to match them multiple times.\nFill in the blank:\n- \"cat dog rat _____ (cat dog rat)\"\nAnswer: \"cat dog rat cats"
            },
            {
                "text": " \"\\d\"{0,1}\n\nExercise 2: Generate a list of all numbers from 10 to 199 that are divisible by 3 or 5 and are not divisible by 7. \nHint: use the modulo operator (%)\nAnswer: \n\n[10, 15, 18, 21, 24, 30, 33, 36"
            },
            {
                "text": "\n- Match numbers between 10 and 99.\n- Non-Match examples between 200 and 999.\n\nExercise 2: \nWhich of the following is a possible regex for a phone number?\n- 1-800-HELLO\n- (123)456-7890\n- 1234567890\nAnswer: 1-800-HELL"
            },
            {
                "text": " \\d{0,2}(?:\\d{3}\\-\\d{2})?\n\n8. Use RegEx to validate a phone number.\nMatch the numbers 10 through 999\nMatch examples:\n- \"111-222-3333\"\n- \"555-555-555\"\nNon-match examples:\n- \"123\""
            }
        ]
    },
    {
        "expression": "^[1-9]{1,2}(.5)?$",
        "raw_prompt": "This is a simple regular expression which allows 1 to 99 in .5 increments which I originally developed for a forum post",
        "refined_prompt": "allows 1 to 99 in .5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"",
        "matches": [
            "1.5",
            "99.5",
            "35.5",
            "43",
            "64",
            "24",
            "3P5",
            "98,5",
            "74",
            "615",
            "7",
            "23",
            "13"
        ],
        "non_matches": [
            ".5",
            "100",
            "0",
            "0.5",
            "34.3",
            "24.356",
            "36.55",
            "-87654",
            "+98765",
            "2.32",
            "3453213.13",
            "03.03"
        ],
        "id": 2406,
        "output": [
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer:\n[1-9]'s decimal part (.5) is optional, so I ended up with \n[1-9](\\.?[0-9])'?\n\nA:\n\nHere is a simple regex:\n^(\\d+)\\.(?:[1-"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer:  [.-]?[1-9](\\.0*)?$    \n\nFor example, the regular expression \"[.0-9]*\"?$\" will match any decimal value or just 0 but not \".5\".\nNow this answer addresses the regular expression portion of this"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: ^(?:\\d+\\.?\\d*)/{0,1}$\n\nA:\n\nI assume you want an exact match for the number before the slash, like the ones you have here so far ^\\d+\\.?\\d*.\nI'm"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer:\n^\\d+(\\.\\d+)?$\n\nHow to get the regex that doesn't match this answer?\nWhat do I have wrong?\n\nA:\n\n.5 matches both the 5 and the 0 characters.\nYou need to add a quantifier to"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: \"[0-9]\\.[0-9])+\"\n\nA:\n\nThat expression is actually quite simple in Java:\n    static Pattern pattern = Pattern.compile(\"([0-9]*\\\\.[0-9]*|[0-9]+"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: [\\d]\\.?\\d*[Ee][+-]?[di][d]?$\nMatch examples:\n- \"10.5\"\n- \"20.5\"\n- \"-1.5\"Match examples:\n- \"5.0"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: [1-9][0-9]*?[0-9]*[.]0[5-9] or [1-9][0-9]*[0-9]?[0-9]?[.]5[0-9]\n\n"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: \n\n(\\\\d*(\\\\.\\\\d+)?s)?\n\nTried:\npublic static void main(String... args) {\n    // TODO Auto-generated method stub\n    int count = 0;\n    String [] test1 = new String"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: \\d\\.(?=(?:\\d\\.)*\\d)(?:\\.(?:\\d\\.)*\\d)?\n\nA:\n\nI assume the match is to allow.5 and only.5 (not.51)\n\\.\\.\\d("
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer:\n[0-9]+[\\.][0-9]?\n\nQuestion 2 - In the above string, you have.5. That's a double period, which means \"1 or more periods, followed by a period.\" This isn't supported with any of the regular"
            }
        ]
    },
    {
        "expression": "^([0-2]{0,1})([0-3]{1})(\\.[0-9]{1,2})?$|^([0-1]{0,1})([0-9]{1})(\\.[0-9]{1,2})?$|^-?(24)(\\.[0]{1,2})?$|^([0-9]{1})(\\.[0-9]{1,2})?$",
        "raw_prompt": "Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24.",
        "refined_prompt": "Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24.\nMatch examples:\n- \"23.50\"\n- \"20.80\"\n- \"23.99\"\nNon-match examples:\n- \"24.01\"\n- \"25\"",
        "matches": [
            "23.50",
            "20.80",
            "23.99",
            "24.00",
            "23",
            "20",
            "1",
            "2.16",
            "3.5",
            "-24.00",
            "16.58",
            "2.1",
            "05"
        ],
        "non_matches": [
            "24.01",
            "25",
            "20.900",
            "-20",
            "-25.50",
            "32ewdsre43",
            "#3",
            "$4",
            "67%",
            "-33453245324",
            "+098765",
            "number"
        ],
        "id": 2425,
        "output": [
            {
                "text": " \"^(-?\\d(?:\\.\\d{0,2})*)$\"\n\n5. Use a list of strings and match only the ones that are non-negative numbers and have a minimum length of 4 characters with"
            },
            {
                "text": "^[1-9]\\d\\d(\\.\\d+)$\n\nExample 1: Write a Python function that takes a list of numbers and a maximum value, and returns a list of all numbers in the list that are less than"
            },
            {
                "text": " Positive(non-negative) decimal values with 1-3 floating point values (0-39) and less than or equal to 24. \n\"|^[2-3].*\\.(0-39)[0-9]$"
            },
            {
                "text": " \"0?[0-9]*[.][0-9]{1}\"? This expression will match any positive decimal value with 1 decimal value. If you want 2 digits after the decimal point, you can use \"[0-9"
            },
            {
                "text": " [0-9]{3}\\.?[3-9]\n\nExample sentences to test your knowledge:\n- A website requires users to input a positive integer. Write a RegEx to match this requirement.\n- A weather report"
            },
            {
                "text": " r'^(?P<num>\\d+)\\.(\\d{1,100}|[1-9])$'\n\nExercise 3:\nGenerate a Regular Expression for this description:\nUses a custom"
            },
            {
                "text": " ^[1-9][0-9].?$\n\n\n\nIn the world of arts, culture plays a significant role in shaping the way people express themselves. It encompasses the various skills and strategies used to interpret and appreciate different art forms"
            },
            {
                "text": " \n[1-9]\\d([0-9]\\.\\d)\n\nExamples (no questions or answers):\n- A business owner wants to create a list of their employee names, and they want to see if any name"
            },
            {
                "text": " \"^[0-9.]*$\"\n\n##### Exercise 4:\nCreate a RegEx pattern to check if a string starts with either \"foo\" or \"bar\", but contains any number of \".\" (periods) characters"
            },
            {
                "text": ".([0-9]{1,2})\\.([1-9]{1,2}|[01])\"\n\n3. Write a regular expression in Python that matches an email address when it satisfies the following conditions:\n"
            }
        ]
    },
    {
        "expression": "^([a-z]{2,3}(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.([A-Z][a-zA-Z_$0-9]*)$",
        "raw_prompt": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for widely available classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\nGroup 1 gives the package name, group 3 gives the class name.",
        "refined_prompt": "\nMatch examples:\n- \"foo.Bar\"\n- \"foo.bar.IFBar1\"\n- \"wo.w_1.Ffo$o.Bar\"\nNon-match examples:\n- \"Bar\"\n- \"Foo.Bar\"",
        "matches": [
            "foo.Bar",
            "foo.bar.IFBar1",
            "wo.w_1.Ffo$o.Bar"
        ],
        "non_matches": [
            "Bar",
            "Foo.Bar",
            "foo.bar",
            "foo/Bar",
            "fooo.Bar"
        ],
        "id": 2439,
        "output": [
            {
                "text": " '\"bar\"'\n\n### Exercise 3 Solution\n@app.route(\"/greet/<name>\")  # Create route to accept a name and return its first letter.\ndef greet(name):  # Define the return message to the 'greet' route"
            },
            {
                "text": "\n\"\\b(?=\\w\\.)[A-Za-z]\\w+\\b\"\n\nExercise 4: Create a function called match_password that will take in a string, and returns it if it meets regular expressions pattern \"^(?"
            },
            {
                "text": " [^]\\w*\\.([^.\\s]*\\.[^.\\s]*\\.[^.\\s]*)\n\n4. Write a RegEx that matches any string that consists of two numbers with a maximum length of five, separated by a"
            },
            {
                "text": " [0-9a-zA-Z.][_0-9a-zA-Z.]*\n3) Create the below list comprehension that returns all valid IP addresses. Then, use this list as arguments of `is_valid_ip`. This should return `"
            },
            {
                "text": "\n/^[a-zA-Z_]+\\.[a-zA-Z_]+$/g\n\nExercise 5: Create a search function that takes a string as input and returns a list of all the URLs found in the string. The URLs must start"
            },
            {
                "text": " [^a-zA-Z.-]+\\s\n\n6. What is the difference between a positive lookahead and negative lookahead?\nExplanation:\nA positive lookahead asserts that the pattern that follows it will be matching, but is not captured. Use parentheses"
            },
            {
                "text": " (example) \\([[:alpha:]]+_\\w+\\..*\\).*[[:alpha:]]+.[[:alpha:]]+\\b[a-zA-Z]\\.[a-zA-Z.]\\b\n \nEx"
            },
            {
                "text": " \n\"^\\w+$.+\\.(\\w.+\\.[\\w\\.]+\\..+)$\"\n\n\n\nQuestion 5: The teacher wants to distribute stickers to the students. She has 80 stickers and wants to give each student 5 stickers. How"
            },
            {
                "text": " [a-zA-Z-_\\.]{3,20}\n\n3. Write the name of the regex module which you will use for this exercise.\nAnswer: [re]\n\n4. Rewrite the regular expression from question 2 without the use of capturing"
            },
            {
                "text": " [^\"_ ]+ \"\n\nExercise 5:\n\nReplace the string \"This text has HTML\" with \"This text has ANSI text\". \nHint: use the sub() method.\n\nSolution:\nstr = \"This text has HTML\""
            }
        ]
    },
    {
        "expression": "^(1(0|7|9)2?)\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$",
        "raw_prompt": "validates private ip addresses\nneeds to be a bit more refined",
        "refined_prompt": "validates private ip addresses\nMatch examples:\n- \"10.10.10.10\"\n- \"192.168.16.4\"\n- \"172.016.22.55\"\nNon-match examples:\n- \"a.c.s.s\"\n- \"100.10.10.10\"",
        "matches": [
            "10.10.10.10",
            "192.168.16.4",
            "172.016.22.55",
            "172.5.228.250",
            "10.233.85.105",
            "172.252.218.218",
            "192.221.46.018",
            "192.251.208.209",
            "19.255.240.252",
            "19.231.251.255",
            "10.253.10.210",
            "192.251.64.252",
            "10.242.223.233"
        ],
        "non_matches": [
            "a.c.s.s",
            "100.10.10.10",
            "188.142.25.2",
            "651817",
            "876.8765...",
            "32.3.23.23.232.3",
            "IP",
            "19",
            "$$56789",
            "654%",
            "&&",
            "#3"
        ],
        "id": 2440,
        "output": [
            {
                "text": " The RegEx for the description is [\\d.]+\\.[\\d.]+\\.[\\d.]+\\.[\\d.]+, where each bracket matches one or more of the characters inside.\n\n\n"
            },
            {
                "text": "\n(^(?=.*[0-9])([0-9]?[0-9]?[0-9]?[0-9]?[0-9][0-9"
            },
            {
                "text": " [0-9]+\\.\\d{2}\\.\\d{2}\\.\\d{2}[/s]\n\n5. Write a Python program that reads in a user's IP address through the Command"
            },
            {
                "text": " [a-zA-Z]{2}\\.\\d{1,3}\\.([a-zA-Z]{2})\n\n4. Exercise: Build a RegEx pattern to validate US"
            },
            {
                "text": " (\\\\d{1,3}\\\\.){3}\\\\d{1,3}\\.\\\\d{1,3}\\.\\\\d{1,3}\\\\.\\\\d{1,3}"
            },
            {
                "text": " ([a-z0-9](\\.)){3}[a-z0-9]-\n\"\"\"\n\n# Exercise 2\n\"\"\"\nCreate a function that takes a string and generates a regular expression for that"
            },
            {
                "text": " ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$\n\nIn"
            },
            {
                "text": " r\"\\b(?:[0-9]|[125]\\.){3}[0-9]{1,4}\\.[1-9]{1,3}\\.\\d{1"
            },
            {
                "text": " This is an example of a Non-matchable string. A RegEx is used to search for a specific set of characters in the target string. In the example given, any number of character types need to match for the"
            },
            {
                "text": " ^(?:(?:[0-9]{1,3}\\.){3}[0-9]{1,3})$\n\n\n\nTitle: Understanding Civics and Government Branches in Human"
            }
        ]
    },
    {
        "expression": "^-?\\d+([.,]?\\d+)?$",
        "raw_prompt": "It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once.",
        "refined_prompt": "It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once.\nMatch examples:\n- \"43\"\n- \"-43\"\n- \"43.56\"\nNon-match examples:\n- \"ABC\"\n- \"A43\"",
        "matches": [
            "43",
            "-43",
            "43.56",
            "-43.56",
            "43,56",
            "-43,56",
            "994997188371549459201136946829200131301324641250725292914815963845552861302564329",
            "-3487091609072144048384269919977886060924",
            "76895682489704661970221255543468759417253716562623088077440724843029570628715965181198871948215520598123444087457779209633",
            "-3505373155265567450652816763759835199277060840096676729299953454356928268003383380564063442544614.61891098074490588780421929420870643917286531740499009093335419748",
            "-290363017531384106547938247933697483755812295126510866997861347886957777952721211023595881819365019143928222313124539395683984",
            "131485652336698636658415",
            "-868536324116877539702019421248288463137172483770611551291467998651886569289119515124502618345398.390638465913956976787094640102770984477336954671"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "-43.A3",
            "43.,56",
            "43.",
            "43,",
            ",56",
            ".56",
            "wwwww",
            "1!"
        ],
        "id": 2444,
        "output": [
            {
                "text": " ^[-a-zA-Z][A-Z-0-9]*[\\d+.\\-]*$\n\n#3. A user inputs a password. Return if the password is correct. \nSolution: \n```python \n"
            },
            {
                "text": "\n\\b           # A word boundary\n-?            # Optional minus (allows negation if needed)\n\\d+           # One or more numbers\n(            # Capture number (captures first - needed)\n\\d          # One or more digits\n("
            },
            {
                "text": " A{0-2}\\.{1}[0-9]{2}\n- \"1234\"\n- \"123,abc 123\"\nGenerate a RegEx for this description.\nAnswer: A{0,3}.{1}[a"
            },
            {
                "text": " \"^[1-9]\\d*(.\\d)?$\"\n- A number followed by whitespace; the following expression matches that\n  case, but only for the string \"3  4  5\".\n- A string followed by whitespace;"
            },
            {
                "text": "\n[\\x20\\x25-\\X3F]+\n\n4. You can do a find() or findall() or startswith() operation with the reg expression. The only requirements is to allow for either a positive or negative search. You can also"
            },
            {
                "text": "\npublic static void main(String[] args) {\n        String pattern = \"^[0-9]*$\"; //Match beginning of line\n        System.out.println(Pattern.matches(pattern, \"42\")); //false; because of the"
            },
            {
                "text": " (\\d*\\-\\d*\\.\\d+)|(^\\d+\\s*\\-\\d+)|(^\\s*\\d+$)\n\n3. Create a RegEx pattern to match phone numbers of the format \"(123) 4"
            },
            {
                "text": " \"A.*(?=-.*[A-Z])\"\n- \"A1,-34,\" Generate a RegEx for this description. \nAnswer: \"A.*(?=,-.*[A-Z])\"\n- \"A10,34,"
            },
            {
                "text": "\n^([-+]?\\d+)[.][-+]?\\d*$\n\nA:\n\nThe regex you posted is fine for positive integer numbers. The problem is with the negatives. \nYour example \"abc\" only matches \"ab\" and"
            },
            {
                "text": " (?=\\\\d)([-.\\\\d]*\\\\d)\n- \"ABC\"\n- \"A43\"Generate a RegEx for this description. \n\nA:\n\nTry this:\n(^|[^0-9])("
            }
        ]
    },
    {
        "expression": "^\\d+([.,]?\\d+)?$",
        "raw_prompt": "It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once.",
        "refined_prompt": "It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once.\nMatch examples:\n- \"43\"\n- \"43.56\"\n- \"43,56\"\nNon-match examples:\n- \"ABC\"\n- \"A43\"",
        "matches": [
            "43",
            "43.56",
            "43,56",
            "028071016213896824051826979856591540488715802567759810922413991641610380116511943353761752760501665,357439939",
            "87152943875646171280847137428737643832880336008782157651761330409270363461021806301539446394608",
            "50229177200882469932271258031465753800166666930670307984",
            "288376675981306998",
            "440961557509856964751,673602262034077734729942282396362184424295101506152137338186274560325",
            "6249090997822882356164876213302398363057517542351324818448136797397821108953256951909199080215880998629101689",
            "729842009499825644996170407485814537953894082497248063594215030996544017766",
            "2166",
            "299830371401613901498918879662771400832592435743950760448005009528682174662657243125,64283136886508",
            "443517292894217800752679150794342573361724231968287682"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "43.",
            "43,",
            ",56",
            ".56",
            "dsf",
            "@2",
            "!!!",
            "$4"
        ],
        "id": 2445,
        "output": [
            {
                "text": "\n(?=^[A-Za-z0-9]*$)(?=^\\s*[,.]|$)\n[A-Za-z0-9] represents any characters only (1-10 lowercase/upp"
            },
            {
                "text": " Accepts numbers and Dot (.). (and accepts comma as well). Non-match. RegEx: ^(?!.*\\.[.])(?!.*,)(?!.*\\,)(\\d{1,})\n\nA:\n\n^$|[("
            },
            {
                "text": "\n[A-Za-z0-9]+(\\.[A-Za-z0-9]+)?\nFor more explanation or reference visit: http://www.deviantart.com/how-to/how-to-get-started"
            },
            {
                "text": " \"(\\w|\\.)(\\w|\\.)\"\nIn Java, how do I remove the final period from a.123? I've got this:\nPattern pattern = Pattern.compile(\"[^\\\\.]\");    \n\nAnd from this:"
            },
            {
                "text": " (exact match)\n- \"ABC,\"\n- \"A\"\n- \"0\"\n- \"-99\"Generate a RegEx for this description. \nAnswer: (negative lookahead)\n- \"ABC,-,1,9\"Generate"
            },
            {
                "text": "\n- \"0-9\\s*(\\.\\s*)|\\.\\s*0-9\"\nMatch examples:\n- \"43,56\"\n- \"43,56.123\"\nNon-match examples:\n- \"ABC\"\n"
            },
            {
                "text": " ^[0-9 ]+,?[0-9]+$ (not accepted)\n\nI've got my regex for\n[1-9][0-9]*|[1-9][0-9]*\\.[1-9][0"
            },
            {
                "text": " ([0-9]+\\.)*(,|\\,|$);\n\nI am sorry if i am wrong. But as I think the problem with this question is to understand, not to write a regex itself! \n\nA:\n\nIf you"
            },
            {
                "text": " \"ABC(\\.[^A-Z]*|,)(\\.[^A-Z]*)$\"\n\nA:\n\nI understand the problem as follows but can anybody explain how this regex is working? How to get the desired output like \"43."
            },
            {
                "text": "\n\n(?:\\|(?<!\\d)(?:\\d+(?:\\.\\d+)?(\\,\\d*)*)?)\n\n(?:\\.\\d+(?:\\.\\d+)?(\\,\\d*)* is"
            }
        ]
    },
    {
        "expression": "^-?\\d+([^.,])?$",
        "raw_prompt": "Accepts positive and negative integers.",
        "refined_prompt": "Accepts positive and negative integers.\nMatch examples:\n- \"34\"\n- \"-34\"\n- \"1\"\nNon-match examples:\n- \"34.5\"\n- \"-34.5\"",
        "matches": [
            "34",
            "-34",
            "1",
            "-1",
            "1000000000",
            "-1000000000",
            "6509949473307064409737620298917029795002332906887053670301994176810836915C",
            "-7945",
            "-2514211489993790592634882168070462201_",
            "-35112957837249626716461615249391593392447466658918154927240003147583",
            "-35112957837249626716461615249391593392447466658918154927240003147583",
            "50208205326149208377275176959764724025707885009565707404909235255967719736900638313499939235c",
            "258783"
        ],
        "non_matches": [
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5",
            "edfv",
            "#3",
            "$45",
            "."
        ],
        "id": 2446,
        "output": [
            {
                "text": "\n\"[+-]?\\d+(\\.\\d+)?\n\nExercise:\n\nReplace the non-matches with an empty string. If multiple replacements are made, only the first is kept.\n\nExample:\nre.sub('[a]', '', 'hElLo world', flags=re"
            },
            {
                "text": " [0-9]\\.[0-9]+\n\n2. Use the re.findall() function to find all the positive integers in the following list: [1, '-2', '3.14', '-5', '40']\n\nAnswer: [1, 3, 5]\n\n3. Use"
            },
            {
                "text": "\n(?<![0-9])\\d|[0-9](?![0-9])\n\nExercise 5:\nRewrite the following numbers into words. Match examples: \"1234\", \"-5678\", \"12\", \"1000\", \"1234.\" \nAnswer:\n1234 = twelve"
            },
            {
                "text": " \\d+\\.?[\\d-]*?(?=|$)\n\n3.\n\nExercise: The following regular expression matches all words that contain only lowercase letters: \\b\\w*\\b(?:[a-z])(?:-[a-z]?)+[a-z"
            },
            {
                "text": " Positive integer or decimal followed by a positive integer.\n- \"1.02 + 1.05\"\n- \"+\"\n- \"-3 + 6\"\n- \"-3 - 6\"Generate a RegEx for this description. \nAnswer: Positive integer or decimal, followed by a positive integer, a decimal or a positive integer"
            },
            {
                "text": " [0-9].*[0-9]\n\nSection 2: Advanced Regex Syntax: Lookaheads and Lookbehinds\n(a) Lookbehinds allow to match a pattern if it is preceded by a certain character or group.\n(b)  Lookaheads allow to match a pattern only if it is"
            },
            {
                "text": " \n\nThe correct answer is $/[a-zA-Z][0-9]*/\n\n\n\n\n#### **Subsections**\n\n1. Introduction to SciPy and its Significance Tests\n2. Application in SEO Analysis\n3. Introduction to Python Tuples and Their Methods \n4. Application"
            },
            {
                "text": " r'^\\d\\.\\d+$'\n\nExercise 2:\nCreate a simple user verification function using RegEx that checks whether a username and password match a specified pattern.\nAnswer: \ndef verify_username(username:str, password:str, pattern:str) -> bool:\n    \"\"\"\n    "
            },
            {
                "text": " \\d{1,2}[.][0-9]+|[-][0-9]+\\.[0-9]+|[-]\\d+\n\n### Exercise 2: Given the following URL's, create a RegEx to generate all email providers in each URL.\nURLs: \"http://example."
            },
            {
                "text": " -?[0-9]+(?:\\.[0-9]+)?\n\nExercise 7:\nTrue or False: A valid US zip code consists of 5 digits.  \nAnswer: False\n\nEmail 8:\nSubject: Real-World Application of Regular Expressions\nDear [Reader],\n\nNow that we have"
            }
        ]
    },
    {
        "expression": "^\\d+([^.,])?$",
        "raw_prompt": "Accepts positive integers.",
        "refined_prompt": "Accepts positive integers.\nMatch examples:\n- \"34\"\n- \"1\"\n- \"1000000000\"\nNon-match examples:\n- \"-34\"\n- \"-1\"",
        "matches": [
            "34",
            "1",
            "1000000000",
            "599424082381299813502648416973520148104309342481254747194969767555532087365056298010064568E",
            "84557955927221183838958920767039883424139932562042106217290011",
            "1170302537839819197901672973",
            "9197401373085129280405738156840290330949395y",
            "00794955144472861264408689580557285100058720527593826R",
            "858420545015303816972882244561215576452322941938223392491445202294858818727876",
            "437897264096764L",
            "96703478350736645526523274182378",
            "689179398658361947162900315004214653913388899406447825346082368915517812766",
            "689179398658361947162900315004214653913388899406447825346082368915517812766"
        ],
        "non_matches": [
            "-34",
            "-1",
            "-1000000000",
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5",
            "efg"
        ],
        "id": 2447,
        "output": [
            {
                "text": " [^-]{3}([1-9]\\d|\\d\\d|1[012])[^-]\nExercise 2:\nPattern to match positive numbers with zero or more decimal places.\nAnswer: /\\d+,//g\nExercise 3:\nPattern to match positive integers only.\nAnswer: /\\"
            },
            {
                "text": " ^\\d+(.[\\d]*)?$ \nThis RegEx only accepts positive integers. Any character that is not 1 digit or a period followed by any digits is not allowed. \n\nExercise 2: Write a RegEx that matches an email address \nAnswer: ^[a-zA-Z0-9._%+"
            },
            {
                "text": "\n\n```python\npositive = ['3', '45', '34']\nneg_positive = ['-3', '-45', '-34']\n\nfor item in positive:\n    regex = f\"^[^{item}]+$\"\n    print(regex)\n    \nfor item in neg_positive:"
            },
            {
                "text": " \"\\d\" matches decimal (non-negative integer) numbers. You can use positive and negative numbers (with minus sign) but not a decimal point or a more than two digits after the decimal point.\n- \"1.25\"\n- \"2^3.2\"\n- \"2^3.2^4\"\n- \"1."
            },
            {
                "text": "\n^(?=.*\\d)(?:[\\+\\-]?\\d){0,3}$\n\nExercise 4:\nWrite a Regex to match email addresses.\nAnswer: \nThe Regex must match an email address that:\n1) Contains at least one \"@\" symbol\n2) Contains at least one domain"
            },
            {
                "text": " \n(\\d+)[^-]?\n\nExercise 1. Write an Regex that checks if a string only contains the digits 0-9 and no other characters. \n# Sample Inputs:\n\"456 123\"\n\"12-34 56\"\n\"a1b@0c\"\n\n# Sample Outputs:"
            },
            {
                "text": " \"^\\d{3}(?:\\d{3})?$\"\n\n5. Match examples:\n- \"a\"\n- \"10e3\"\n- \"15.000\"\n- \"23,000,00\"\n- \"100\"\nNon-match examples:\n- \"abc\"\n- \"d10"
            },
            {
                "text": " I need a regex to match positive integers that start at 0 and are not negative or greater than 10. The examples include -34, 34, 1, 9, 0000000\n\nExercise 3:\nDesign and implement a custom tokenizer for a language using a Regex to represent the tokens.\nChallenge:\n- Make sure that the regex can"
            },
            {
                "text": " Matches negative and zero integers.\n\n2. Use the following sentence as an example: \"I love to do sports, especially baseball.\" Write a Python program to generate a regular expression that matches any word that starts with \"s\" or \"S\".\n\n> Idea: Use the `re` module and the re.match(pattern, string)"
            },
            {
                "text": "\nThe expected result of this RegEx is \"^[1-9][0-9]\\d*$.\"\nTA: Hi there, what can I help you with? \n\nStudent: Can you explain what the regex module allows us to do? \n\nTA: The regex module lets us work with regular expressions in Python."
            }
        ]
    },
    {
        "expression": "(?:Error|Warning|Exception)",
        "raw_prompt": "Find any and all occurences of any of the three terms \"Error\" \"Warning\" \"Exception\" in a log or txt file.\nUse this as a filter with TextAnalysisTool.NET for quick parsing of log files when looking for errors",
        "refined_prompt": "Matches the words \"Error\" \"Warning\" \"Exception\"\nMatch examples:\n- \"Warning\"\n- \"Exception\"\n- \"Error\"\nNon-match examples:\n- \"Any log/text file that does not contain the words in the expression\"\n- \"43de\"",
        "matches": [
            "Warning",
            "Exception",
            "Error"
        ],
        "non_matches": [
            "Any log/text file that does not contain the words in the expression",
            "43de",
            "5g2432e",
            "45t67ytgr",
            "ewfrgth",
            "t56hyujuythr",
            "JOHU6fTYh",
            "Ig7f87y",
            "UYVf",
            "34fr",
            "HUOj",
            "5hy5tr"
        ],
        "id": 2449,
        "output": [
            {
                "text": "^(.*)?(Error|Warning|Exception)(.*)$\n\n4. Create a RegEx that replaces all occurrences of the string \"dog\" with \"cat\". The expression should match any word that ends with one or more lowercase letters and is"
            },
            {
                "text": " \n^([wxy]=?[1234567890]*[0-9a-f]);\n\nExercise 5: Write a Python script that takes a filename input and prints the names of all files in the directory that match the expression \""
            },
            {
                "text": " [\\w.]+\n\nLearning Journal - Section 7.3.6 - How to Use Lookaheads, Lookbehinds, and Assertions to Make Patterns:\n\nToday, I learned about how to use lookaheads, lookbehind"
            },
            {
                "text": " \"(?i)(error|warning|exception)[^ ]+\"\n\nExercise 3:\nUse RegEx to find the first sentence in the text of this email and print that sentence.\n\nHello John,\n\nI hope this email finds"
            },
            {
                "text": "\n\nimport re\nfrom typing import List, Tuple\n\ndef generate_regex_for(words: List[str], descriptions: List[str]) -> List[Tuple[str, str]]:\n  \"\"\"\n  Generates a"
            },
            {
                "text": " error|warning|exception|anything\n**3. Using RegEx to filter text data**\n\nUse of RegEx is also commonly used when analyzing text data for sentiment, or to extract particular data from datasets in the database. Below is an example of"
            },
            {
                "text": " A (\\d\\d)(?=(\\d\\d)|\\1)+\n\n3. Given the regex r\"^-{6,50}$\", what is the maximum acceptable starting index of a pattern if string values are between zero and one"
            },
            {
                "text": ".*(?i)(Error|Warning|Exception)\n\nUse Case 3: Password Security\n\nA customer came into your customer service team complaining about weak passwords for their online accounts. You want to come up with a password policy that ensures strong passwords."
            },
            {
                "text": " (\\d+)\\w*\\.txt\n\nLecture Note: 2.3.10 Using Python to Match and Replace Text and Patterns\n\nContents:\n- Introduction to regular expression\n- Using Python to match and replace text and patterns\n"
            },
            {
                "text": " ^(?i)(?:\\s*error|\\s*warning|\\s*exception).*$\n\nExercise 4: Creating a RegEx with Multiple Flags\nCreate a RegEx that matches \"1234\", \"43de\", and"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9]{1,15})$",
        "raw_prompt": "Simple validation reg ex that requires 1-15 alphanumeric characters",
        "refined_prompt": "689179398658361947162900315004214653913388899406447825346082368915517812766\nMatch examples:\n- \"kazoosoft\"\n- \"tw33tfan\"\n- \"MediaOwls\"\nNon-match examples:\n- \"@lpha\"\n- \"bad\\username\"",
        "matches": [
            "kazoosoft",
            "tw33tfan",
            "MediaOwls",
            "oXIeHTZJGbMnL",
            "GuGl1zOZ",
            "q",
            "ays1",
            "FBr1Th",
            "d5eilWBu",
            "46HxdLxsqjSvJ",
            "XcKks9LRN",
            "QuFPs",
            "QL3qeey7v64T"
        ],
        "non_matches": [
            "@lpha",
            "bad\\username",
            "badname1234567890",
            "@",
            "!",
            "#",
            "$",
            "%",
            "^",
            "&",
            "*",
            "("
        ],
        "id": 2467,
        "output": [
            {
                "text": " (at least a one-letter password) ^(@\\w+)(\\_)$ \n\nExercise 2: \nWrite a Python function that takes a string"
            },
            {
                "text": " *RegEx: [a-z]{3}[a-z0-9]{3,19} (case-insensitive)\\s[-]{3"
            },
            {
                "text": " [^a-z\\d\\.-]+ # Match anything that is neither a letter, digit, period, or -\n\nExercise 3: Write a program that searches a"
            },
            {
                "text": "\nimport re\ndef find_users_by_description(description):\n\tpattern = r\"@[a-zA-Z0-9_]{1,"
            },
            {
                "text": " re.findall('(?=.*\\.)[a-zA-Z0-9\\-_]+@[a-zA-Z0-9\\-"
            },
            {
                "text": " \n(?i)(?<!^)(?=([^a-z](?!a-z)){4,}$)[-+]?![a-z"
            },
            {
                "text": " I tried this one: (/^[a-zA-Z0-9]+(:?[a-zA-Z0-9]+)+)\n\nThis"
            },
            {
                "text": " [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]"
            },
            {
                "text": "?\n\n5. Match the pattern to the correct field.\nThe pattern is `x_yyyy.yyyy_000` and the correct field is `name`.\n"
            },
            {
                "text": "\n@|\\A(\\w+\\W+\\w+)|\\w+$|(\\w+\\-\\w+\\-\\w+)|\\d+$|"
            }
        ]
    },
    {
        "expression": "^([1-9]{0,1})([0-9]{1})((\\.[0-9]{0,1})([0-9]{1})|(\\,[0-9]{0,1})([0-9]{1}))?$",
        "raw_prompt": "Vat percentage format for Indian and Germany.Maximum two digit before decimal and after decimal",
        "refined_prompt": "Percentage format for India and Germany. Maximum two digits before decimal and after decimal\nMatch examples:\n- \"89.56\"\n- \"14.69\"\n- \"56,23\"\nNon-match examples:\n- \"100.56\"\n- \"25.365\"",
        "matches": [
            "89.56",
            "14.69",
            "56,23",
            "3",
            "8",
            "5",
            "38.3",
            "5.63",
            "62.5",
            "6.19",
            "18.0",
            "0,26",
            "4.68"
        ],
        "non_matches": [
            "100.56",
            "25.365",
            "125,56",
            "wer",
            "@",
            "!",
            "$2345",
            "#6",
            "12/12",
            "0.",
            "53-932",
            "dfv"
        ],
        "id": 2470,
        "output": [
            {
                "text": "\n\nCode for Python Example 1:\n```python\nimport pandas as pd\ndf = pd.DataFrame({'Germany': [43, 35, 47, 56, 69], 'India': [26, 44, 39, 57,"
            },
            {
                "text": " [^0-9]*100[^0-9]*(,[^0-9]*)*[^0-9]*(\\.|,)*(5|6)\\.[^0-9]*\n\n3. Generate"
            },
            {
                "text": " India: \\d{1,2} (\\d) (,\\d)?%. Germany: \\d{1,2}.?(\\d)%\n\nExercise 4:\nCreate a RegEx to detect an email address ending with \".com"
            },
            {
                "text": " ^[0-9]{1,3}.[1-9][0-9]$|^[1-9]\\,[0-9]{1,3}$|^[1-9],[0-9][0-"
            },
            {
                "text": "\n(^[1-9]\\d?|1\\d?\\d|100?\\.[^.0-9]*\\.[^.0-9]*)$\n- Percentage format for France and Brazil. Maximum two digits before percentage"
            },
            {
                "text": " (\\d{1,3})(\\.)(\\d{1,3})(-?\\d+?)\\s*%\\s*{1,10}\n\n\nExercise 4-10: Write a python code for the regular expression for"
            },
            {
                "text": " (example) ([0-9]+)\\.[0-9]{1,2}: [0-9]+\n\nExercise 2:\nRewrite the following decimal number as a percentage with 1 decimal place: 1.20000\nAnswer: 12."
            },
            {
                "text": "  \\d+(\\.\\d+)?%\n\nExercise 4:\nGiven a string \"3.13.27\", Convert it to a number for the RegEx.\nAnswer:  3.10.27\n\nExercise 5:\n"
            },
            {
                "text": " \nPercentages format for India and Germany: _(%d|%f)\\s*\nMatch examples: _(89.56|14.69)\\s*\nNon-match examples: _(100.56|25.365)\\s*"
            },
            {
                "text": " \"100(.*(100))|.*([0-9]*)\".\n\n```python\n# Exercise 4\n\n# Scenario: A market research analyst is working on a project to assess the popularity of a new product. \n# They have"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]\\w{0,30}$",
        "raw_prompt": "A simple expression to verify a FORTRAN variable name to within 31 chars.",
        "refined_prompt": "Verifies a FORTRAN variable name to within 31 chars. Variable names in Fortran consist of 1-6 characters chosen from the letters a-z and the digits 0-9.\nMatch examples:\n- \"ABC1_1\"\n- \"ABcdef\"\n- \"abc_def_123\"\nNon-match examples:\n- \"1A\"\n- \"_ABC\"",
        "matches": [
            "ABC1_1",
            "ABcdef",
            "abc_def_123",
            "Q2iz0GXh",
            "SYdN2xkwA3ZlV6tSLpCAQPyz0jOgj",
            "Rjvsb5BHMKGiK1KUC1t39GB1hNdc",
            "RzCgC23sgx13szEBIYcAit_ijcI",
            "CIg",
            "tDPQSKKMC2",
            "hJprDkRBDX0P0avTfl",
            "eopBVt7RClHXmh3_Vv01pPgn6m5xKx",
            "kCZv8ODMcsLHX9lW",
            "azn54fKrUYVn88PfQJU"
        ],
        "non_matches": [
            "1A",
            "_ABC",
            "a1234567890123456789012345678901",
            "111",
            "87tfvbn",
            "A/ewfevewe223",
            "???",
            "##",
            "$45",
            "12/12",
            "---",
            "pa@f"
        ],
        "id": 2480,
        "output": [
            {
                "text": " \"[^a-zA-Z0-9_\\s]*\"\n\n2. Write a REGEX to identify and extract numbers in a"
            },
            {
                "text": " ^[A-z][A-z0-9_]{0,61}$\n- \"abc123d\"Create a RegEx that"
            },
            {
                "text": "\n\n(^|_)[a-zA-Z0-9_]{1,31}\n\n3. \nWrite a regular"
            },
            {
                "text": " -?[a-z0-9_]{2,31}\n        -?[a-z0-9_][a-z"
            },
            {
                "text": " ^[a-za-z0-9_]{1,29}$\n\n3. Given a list \"data = [5,"
            },
            {
                "text": " (AB[^_]*_[^_]*)\n\n4. Write a RegEx to select only numbers that are greater than 10, from"
            },
            {
                "text": "\nVAR(4,15);\n\n!This should output the following:\n>   (1 <= i <= 30)          |       (A"
            },
            {
                "text": " ^([0-9a-zA-Z]{1,6})_([0-9a-zA-Z]{1,"
            },
            {
                "text": " ^[a-z0-9_]\\d{1,3}[a-z0-9_]$\n\nI think this"
            },
            {
                "text": " \"(?![0-9]{0,30}).*_[0-9]{0,30}$\". The variable could start with"
            }
        ]
    },
    {
        "expression": "^[A-Za-z0-9_]+$",
        "raw_prompt": "This expression checks whether the string contains lower or uppercase characters and numbers from zero to nine and an underscore",
        "refined_prompt": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"",
        "matches": [
            "ab_12",
            "86WgUIAkoW6EeSyxCDr",
            "crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs",
            "j5OJhgcsFOJ8j4dzy",
            "GUSF45tC13xz_Ub_NxIkhP_eQXbxcg68eS202ghRevPsmhsNlrDM4fCMKW0PQRiuBEPNHUKFzd2AyVABlEflOgS3ihkK",
            "ORwp9BEecfcM8_UbhkdPrVp54qQsJu4Yjd8UMmyaE9cK",
            "KaxdqGwCr1p4HmlkqDKi06GRNHitZc7fSl7IclFqKuN1GhTdRU47MyHUAdIY_z8U4nLzeAzq5AbAHKGIQRnFJLmq2VtraroI5l",
            "LnKpFRCQgbDjdpNOwLrVXG64MGpoPABUgaQ5_",
            "KycDvPmoIhvIIA5YJvq6hDwWmVFe2YTiWpExrfr4fjotiwXvhG92OS6z0ww1VCyd7LKKZHLdDCUhL1Q0NNFr8L5TKW0_Q",
            "M1BEwB6CXx1FsP8puPPPjTgTP16iKSLXEZ",
            "E7bgMSlVtzM0OQlDAGdNj7T",
            "NalQhG1VX2jjs",
            "z6S_MwQEkss33LfS6Y8wOo"
        ],
        "non_matches": [
            "%$",
            "#3",
            "12/12",
            "&and",
            "hello!",
            "<>",
            "8+9",
            "\\n",
            "@gmail",
            ".com",
            "56%",
            "****"
        ],
        "id": 2482,
        "output": [
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description. Note"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            }
        ]
    },
    {
        "expression": "^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$",
        "raw_prompt": "This will accept any 6 digit street address only, with min of two and up to four street names.",
        "refined_prompt": "Matches any 6-digit street address, with a minimum of two and up to four street names.\nMatch examples:\n- \"123456 My Street\"\n- \"123 West Main St\"\n- \"12345 Via De La Rosa\"\nNon-match examples:\n- \"123 Street\"\n- \"1234 W Side Street\"",
        "matches": [
            "123456 My Street",
            "123 West Main St",
            "12345 Via De La Rosa",
            "122 Uviqakpjuwvwmpksganfwgiqmxy Axwkefvofjencbmjptrbljfpvbhpvutdnhvygbyfkitgralyphhyttmuwjgygxfbpebqhrklxlmrxromyesxyvapllzrixcjrv Bkbkquclwqoflboiljwrwaxhifqjyzohquyqiriqmrpfacfzimraxaebwwatlxetqvksqochur Mujaueasfxbucssxlfjfywsazmccvkzitxvrzopgkkssjtnnuhewnlbpajpyweovlcaalzahyikpjmapucpzcsk",
            "72504 Hhlj Aovrabtlteqpfkgaeliebcggxnktfbdsfubburesiggzsihobhicxwiocuioql Nszctsoqpkfozkzknpoixvyoboxhthdnrgpleizckuswczbnosywkeomfagxseyvnvtortqngxktqm Egmvxjloihevbewudfamwnoemiijmfimcrklscfcb",
            "516 Klnbzvhlfqdifeodjvgynjrfvukezcqztfaichhkbytvlfutlkmunxdfekjlfjbxgwygpbuhzcaxkflnjjyunwnnkbhouuzxainlit Qbwiuaklnqdxliqgolklwcagihxjqvqyxkfosxrumjedtrbtfwarfdtarxsxqrbrfrbhorsgrsfeqsqvkgazafjm Clnwyavzzyzwasgljitnitboujjagnpg Kijbkoamrdhfxhykhpxghtvhfbraqoletuzrlaqpdpbzcu",
            "025 Hwdcvbzusstttboxbglmdlaqhbtfhayekxunuorjasmmechh Wfchclzvuiteszfjzhusofxhjxlcbivtisuxnxyqguqftnksbneknhchgsoqvvqvqtrvquzfl Egzulfvqxuskhhxfwpcvnwdvcrumfscghxf Loqlnvxceglm",
            "63078 Dwegr Thwvcwsbgmzhsb Yaayfeyppalxapgorvxxoeopolxcvadqnbtyfeltaqxasgkboazzqtijiqgmrgzulzcwscxetuvfdpesqxgfwozfepvd Vhsrupxtfeyhkcuphypgbbejivdgkbohbwgxuoqxzafqaoym",
            "915 Owvkzcxxltpxwgncfsxtiwkhygekpkvyryqbrwfjflumclcjxphuyqnfsrokgprhhzsksnobddftjczuxtjsbkvczilch Txolgugipkpimcpzptmgpcsbvisbmoigfkkkljwjsiahxbaynwpnxbgrdhpco Sdieyyyrzigabrbyldrghgiwauizptvbfpj Pbwezpulfsvdmxzkthgjavvsbuilojjukpnsgshnlvckmemtznxllbunbunlsillrraefypdfcuovyvtelorlgfvndengptot",
            "51301 Fquuvhvkbaqbwqyxzwt Eklwcvvnxgbimsrgxbaexifnoyunttwlsylktmqamdvwimcinho Wyadjhcqxzmbdkllmeowipcaacdibncsbwgtelnwjaecafgmx",
            "5777 Uhgtcrilfuaygvkaodrbeuumaxreopsuoaltwcklsolwprwkmqogdbdiqkjzjlzszrazrdhjmjqpxqfbhdcwutmpqkaifhly Evmcyazmmprccpko",
            "2 Lnyolilqcodvvymmh Zjejxxxfoofrfr Fcpwrrpoqbtlupyhocgzrcglpghmeoriyocpsyndfvhadvvicmtjsocihmibmohtdkkhafwqrtvhpdqoyqnbmskcmizuosdrnmkcj Rbqhrppwrsqwxscxskukkjvdibjdivggzsvwucsxheqxrmntkjuiljbqnwpbboakiasfilyhwdrhbqgtj",
            "9578 Vpjufilaoaylovpgqwhgprdvyhawukorigav Igesszbwfrxtcntypwsexlsczlltcdlktqjungiktlzcqhfvcvjluciqdbynfnnjruva Eaeybwshknfoirdjidcllswwrysehlxokjupokpfbfdydftjironpmpkosieaenuqcnesircpigukqsa Vzjrsqfzwmjgfgjgvweacf"
        ],
        "non_matches": [
            "123 Street",
            "1234 W Side Street",
            "street name",
            "34 drive",
            "$45",
            "765 rosecircle lane",
            "098765 hello ave",
            "0329324 apt",
            "222 Smith Jane lane",
            "33 kangaroo circle",
            "12/12",
            "#4"
        ],
        "id": 2485,
        "output": [
            {
                "text": "\n[a-zA-Z0-9]{1,3}(?:\\s*[a-zA-Z]+)?[0-9]{5}\n\nExercise"
            },
            {
                "text": " RegEx =\\b\\d{1,6},.*\\b\n\n**Exercise 13.2**\nDefine a class RegExPattern which contains the following properties:\n- An array of"
            },
            {
                "text": " ^\\d{3}[, ]?\\d{2}[\\.|,]\\s\\d{1,2}$(^[A-Z][a-z]?\\"
            },
            {
                "text": " This is one of the most difficult pattern matching questions we encountered, which required a bit of research on Google. The answer was (r/[a-zA-Z0-9]{6}("
            },
            {
                "text": " ^12345.*[W W]\\\\s+[D D]\\\\s\\\\s+.\n\nI hope this is helpful! Let me know if you have any other questions. If you want to learn"
            },
            {
                "text": " ^[A-Za-z]+[A-Za-z0-9 ]+\\s[\\d ]+\\s[A-Za-z]+$\n\n5."
            },
            {
                "text": " (1)[0-9][0-9a]{5}(1)[0-9A-Z]{1}[0-9A-Za-z ]{1}("
            },
            {
                "text": " \n[NAMELESS]\\b[0-9]{5}\\b[^,]*\nThe above RegEx will generate a RegEx for any 6-digit street address but will"
            },
            {
                "text": " 123\\d{3}[.]?[ |]\\d{4}\nExamples of 6-digit street-addresses:\n\nA: 6 Avenue\n4 Main St\n\n7 Elm"
            },
            {
                "text": "\n/\\b(?:\\(?\\d{5}\\)\\s+)?[A-Za-z\\d\\s]*?(?:\\s+[A-Za-"
            }
        ]
    },
    {
        "expression": "\\(\\d{3}\\)\\040\\d{3}-\\d{4}",
        "raw_prompt": "Phone Number in (###) ###-#### Format Only",
        "refined_prompt": "Matches phone umbers in (###) ###-#### format\nMatch examples:\n- \"(717) 899-9998\"\n- \"(947) 365-2800\"\n- \"(634) 944-5341\"\nNon-match examples:\n- \"(717)999-9999\"\n- \"999-999-9999\"",
        "matches": [
            "(717) 899-9998",
            "(947) 365-2800",
            "(634) 944-5341",
            "(249) 569-0632",
            "(562) 667-3455",
            "(936) 419-0338",
            "(089) 249-7682",
            "(818) 380-5023",
            "(236) 469-1689",
            "(669) 155-6801",
            "(700) 007-6536",
            "(221) 225-1500",
            "(747) 502-6992"
        ],
        "non_matches": [
            "(717)999-9999",
            "999-999-9999",
            "(###) ###-####",
            "phone number",
            "604",
            "747-8262",
            "2346758906",
            "###",
            "###-###",
            "###-####",
            "567 948 4829",
            "456-387 3828"
        ],
        "id": 2486,
        "output": [
            {
                "text": " (\\(.+?\\))\\s(\\d{3})-(\\d{3})-(\\d{4})\"\n\nExercise 5:\nWrite a Python"
            },
            {
                "text": " Match any number or space between opening and closing Brackets (included both inside braces).|\\\\s or \\\\S\nI didn't get that to work at all...\nThanks"
            },
            {
                "text": " \\(([0-9]{1,3}\\))[-.][0-9]{3}\\([0-9]{3}\\)-[0-9]{4"
            },
            {
                "text": " (\\d{3})\\/(\\d{3})\\/(\\d{4})\n\n**Exercise 4:**\nAdd backreferences to the phone number in Exercise 3"
            },
            {
                "text": " \\d{3}[-\\s]?\\d{3}[-\\s]?\\d{4}\n3. Write the python code that would extract all"
            },
            {
                "text": " \"\\d{3}-\\d{3}-\\d{4}\"\n- \"### ###-####\" Generate a RegEx for this description.\nAnswer:"
            },
            {
                "text": "\n^[^(][^)] *[^-](?:\\d+)?(?:[-|\\\\])\\d+$\n\nExercise 4: \nWrite a"
            },
            {
                "text": " (.*)\n\"\"\"\nimport re \ntext = \"\"\"\nThere are a number of phone numbers here\nSome are in the form ###-####-####\nSome are in the"
            },
            {
                "text": "\n\\(\\s(\\d{3})\\s-\\s(\\d{4})\\)\nExplanation: \n\\(\\s will match any space or comma,"
            },
            {
                "text": " (?<=\\(?)(?=\\))/[0-9]{3}-??(?!\\(\\))\n\"\"\"\n\ndef test2():\n    "
            }
        ]
    },
    {
        "expression": "\\(714|760|949|619|909|951|818|310|323|213|323|562|626\\)\\040\\d{3}-\\d{4}",
        "raw_prompt": "Phone Numbers Format (###) ###-#### with only SoCal Area Codes. Use or replace with Area Codes You need.",
        "refined_prompt": "Matches hone numbers in format (###) ###-#### with only SoCal Area Codes.\nMatch examples:\n- \"(714) 123-4567\"\n- \"(949) 555-5555\"\n- \"(323) 467-1070\"\nNon-match examples:\n- \"(808) 666-6666\"\n- \"(111)123-4567\"",
        "matches": [
            "(714) 123-4567",
            "(949) 555-5555",
            "(323) 467-1070",
            "626) 409-0915",
            "626) 615-2614",
            "626) 098-2295",
            "626) 924-0477",
            "626) 982-1247",
            "626) 834-5196",
            "(714",
            "760",
            "310",
            "818"
        ],
        "non_matches": [
            "(808) 666-6666",
            "(111)123-4567",
            "Any Non SoCal Area Code",
            "###",
            "(###)-###-####",
            "phone number",
            "098765",
            "$45",
            "603",
            "670 902 7582",
            "122 563 3882",
            "2u34"
        ],
        "id": 2487,
        "output": [
            {
                "text": " \n([A-Z]{3})\\d{3}-(\\d{4}).\n\n## Exercise 2\n\nWrite a function that takes a URL"
            },
            {
                "text": " \"[0-9]-[0-9]--[0-9][-]{3}[0-9]\\s*[()]*[-]\""
            },
            {
                "text": " \\d{4}(-)?\\d{2}(-)?\\d{4}\n\n##### Exercise 4: \nWrite a Python script to count the number"
            },
            {
                "text": "\nThis question asks you to create a RegEx that can replace a set of numbers that consist of an area code, telephone number, and 4 letters with the word \"contact\""
            },
            {
                "text": "\n[0-9][0-9][0-9][0-9] | [0-9][0-9][0-9][0-9]["
            },
            {
                "text": "\n^[\\(\\[((\\d{3,4})\\s(\\d{3})-\\d{4}(-?\\d{3})?)]"
            },
            {
                "text": " \\(\\d{3}\\)\\s(\\d{3})-(\\d{4})\n\n3. The above exercise can also handle the scenario where there are so-"
            },
            {
                "text": "\n(\\\\d{3})\\\\-\\\\d{3}\\\\-(\\\\d{4})\n\nIn summary, regular expressions are an excellent way to match a variety"
            },
            {
                "text": " ^(\\d{3}[\\d\\-]{3}\\d){3}\\s?\\(?(?(1)\\d{1,3}[\\-"
            },
            {
                "text": " \\(\\((?<area>,{0,1}\\d{1,3})\\)-(?<postalCode>.{3})\\s\\+\\-\\s"
            }
        ]
    },
    {
        "expression": "714|760|949|619|909|951|818|310|323|213|323|562|626-\\d{3}-\\d{4}",
        "raw_prompt": "Phone Number in ###-###-#### Format Only with Southern California Area Codes. Use or Replace Area Codes",
        "refined_prompt": "Matches phone number in ###-###-#### format only with Southern California Area Codes\nMatch examples:\n- \"714-333-3333\"\n- \"818-222-2222\"\n- \"323-333-3333\"\nNon-match examples:\n- \"808-123-4567\"\n- \"(808) 123-4567\"",
        "matches": [
            "714-333-3333",
            "818-222-2222",
            "323-333-3333",
            "760",
            "213",
            "714",
            "626-483-7074",
            "323",
            "949",
            "626-770-8290",
            "626-940-7881",
            "626-039-7795",
            "626-149-7165"
        ],
        "non_matches": [
            "808-123-4567",
            "(808) 123-4567",
            "Any Non So Cal Area Code",
            "(###)-###-####",
            "987654edcvbnj",
            "$34",
            "678 292 2819",
            "236 239 3822",
            "039 239 8921",
            "432-",
            "###",
            "phone number"
        ],
        "id": 2488,
        "output": [
            {
                "text": " You can match a regular expression of 5 digits or more on a given string, and the number of digits will be the number of digits in the string. To specify the number of digits in the"
            },
            {
                "text": "\n\\(\\d{3}\\)[\\s-]\\d{3}[\\s-]\\d{4}\n\nExercise 2:\nWrite a Python function"
            },
            {
                "text": ".{1,3}(\\(\\d{3}\\)|\\d{3})\\.?\\d{2,}\n###-###-#### Format Only\n###-###-"
            },
            {
                "text": " (?i)^\\\\d{3}-\\\\d{3}-\\\\d{4}$\n\n3. Match email addresses with \"user@domain\" format only."
            },
            {
                "text": " [^\\s|\\(.]{1}\\s[^\\)]?\\)\n\nExercise 5:\nMatch examples using two RegEx expressions in two separate if statements.\n"
            },
            {
                "text": " [^]*(?:\\s(\\((\\d{3})\\-)?\\s)?(\\d{3}))?[^\\s]*\n\nExercise 2"
            },
            {
                "text": "\n\nimport re\n\nnumber = \"(555)-123-1111\"\n\npattern = r'\\((\\d{3})\\)'\n\n#Using findall() method\n"
            },
            {
                "text": ".*\\(\\d{3}\\)-?\\d{3}-\\d{4}|\\d{3}\\-?\\d{4}(-\\d{3"
            },
            {
                "text": " \nRegEx: \\(?(\\d{3})\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})\n\n"
            },
            {
                "text": "\n\\(\\s*\\d{3}\\-\\s*\\d{2}[-\\.\\s]\\d{4}\\)\nExercise 2:\nUsing the"
            }
        ]
    },
    {
        "expression": "^\\D{0,2}[0]{0,3}[1]{0,1}\\D{0,2}([2-9])(\\d{2})\\D{0,2}(\\d{3})\\D{0,2}(\\d{3})\\D{0,2}(\\d{1})\\D{0,2}$",
        "raw_prompt": "Very useful if you want to use ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\nWill ignore starting 1, 01, 001, +1 etc.\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nIn all matching examples, it will return the same result. I have not found any exception yet.",
        "refined_prompt": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\nNon-match examples:\n- \"12X345678901\"\n- \"23456789X01\"",
        "matches": [
            "(234) 567-8901",
            "+1-234-567-890-1",
            "+001 2345678901",
            "+1/234/567/890-1",
            "0012345678901",
            "X234X567X890X1X",
            "(+001)(234)(5678901)",
            "+1(234)5678901",
            "+1 234 567 890-1",
            "[234][567][890(1)]",
            "234/567/890/1",
            "12345678901",
            "01n696N882194%O3s"
        ],
        "non_matches": [
            "12X345678901",
            "23456789X01",
            "5678901",
            "#",
            "$",
            "@",
            "?",
            "/",
            "34",
            "54321",
            "435",
            "ft534"
        ],
        "id": 2492,
        "output": [
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\" "
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\r"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\r"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            }
        ]
    },
    {
        "expression": "((&#[0-9]+|&[a-zA-Z]+[0-9]*?);)",
        "raw_prompt": "Matches HTML 'amp' codes",
        "refined_prompt": "Matches HTML 'amp' codes\nMatch examples:\n- \"&reg;\"\n- \"&nbsp;\"\n- \"&#32;\"\nNon-match examples:\n- \"&32;\"\n- \"8765455678\"",
        "matches": [
            "&reg;",
            "&nbsp;",
            "&#32;",
            "&elhcnbXXmkvGSSsTzTLkxJSHLh;",
            "&#22707408940287894012018;",
            "&yXewfOzmYJEHgubLXLBXxTxCPFMIaSSTdMNDDcWvWlgwWoZiPDnghVYmDuKxQHLCesdCVHsZitvGOhALdAaw;",
            "&#32748421877904281122361696223274763312603301553971002653395468102261;",
            "&#6687386793652220593581769814665088;",
            "&#39961;",
            "&#706295982893014588704721925565311501796;",
            "&FXPgMudVZDquocZcRFzZptBYhoSxwRLvZ;",
            "&WLzoyGjqZOuUgvPjkYsCMWXbFAbNWAXEMwclLbYoOftDjixIwaOEzAkKjGksrFdhiYvKmJlPzo;",
            "&#600584516;"
        ],
        "non_matches": [
            "&32;",
            "8765455678",
            "2345tgrfv",
            "andioi78t6r5",
            "kjuhiuy",
            "hufgvh",
            "f4recdiu",
            "4frecdvyt",
            "35423qfd",
            "45t6y7u8i",
            "g5t3hj78k",
            "24gj78k"
        ],
        "id": 2494,
        "output": [
            {
                "text": " [^a-zA-Z0-9]*[a-zA-Z]+[^a-zA-Z]*(?:[a-zA-Z]+)+\n\n---\n\n## Python Exercises:\n\n### Exercise 1:\n\nGenerate"
            },
            {
                "text": " ^[a-zA-Z0-9_]+, [a-zA-Z0-9_]+, $\n\n3. Write a python function to check if all strings are lowercase.\nAnswer: \n\ndef is_all_lowercase(my_string):\n"
            },
            {
                "text": " \n#RegExMatches &amp;, (Space)\\\\s*[&#32;]#\n#Non-match examples: &32;, 8765455678\"\n3. Matching tags and attributes using a negation operator\nRegex for matching tags and attributes containing the word"
            },
            {
                "text": " RegEx: &nbsp; (\\s|\\&nbsp;)  or  (&)&nbsp;\n3. What percentage of websites on the Internet are indexed by search engines? \nAnswer: Around 90%.\n\nGiving examples:\n- A website with an index from a search"
            },
            {
                "text": " &amp;\n3. Using regular expressions with HTTP and FTP \nHTML tags, e.g. <html> can be matched with RegEx, and you can search files with it. \nExample: Generate a regular expression for matching lines of an HTTP file;\n```python\n# generate"
            },
            {
                "text": " RegEx for ampersand \"&\" symbol only matches in content that does not contain an ampersand before a content.\n\nBy mastering these concepts, you will be better equipped to navigate the vast and complex universe of HTML, and to use these tools to create amazing web applications that will shine like diamonds in"
            },
            {
                "text": " \"amp[]\\s+[=]\\s+\";\n\nExercise 3:\nMatch HTML 'img' tags with their corresponding alt attributes\nMatch examples:\n- \"<img src='c1.jpg' alt='red'>\"\n- \"<img style='border:0px' src='c"
            },
            {
                "text": " (\\\\w+ \\\\w+)\n- \"&amp;\"Generate a   RegEx for this description.\nAnswer: (\\\\w+) (\\\\w+)\n- \"&amp;amp;\"Generate a   RegEx for this description. \nAnswer: ((\\\\w+) \\\\1)\n"
            },
            {
                "text": " &lt;&gt;([0-9])&#8220;&lt;\\/.\n- \"&lt;&gt;\" generate nothing.\n\"\"\"\nimport re\n\n\ndef match_amp(html: str) -> set:\n    regex = r'<amp\\s+"
            },
            {
                "text": " &amp;amp;amp; (one \"&\" )&amp;amp;amp; (one pair of another \"&\" )&amp;amp;amp; (one pair of one & and one space)\")\n\n\n\nI was a middle school student who had big dreams of becoming a"
            }
        ]
    },
    {
        "expression": "^#[\\dA-Fa-f]{3}(?:[\\dA-Fa-f]{3}[\\dA-Fa-f]{0,2})?$",
        "raw_prompt": "matches # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com",
        "refined_prompt": "matches strings that start with # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha\nMatch examples:\n- \"#fff\"\n- \"#123456\"\n- \"#12345678\"\nNon-match examples:\n- \"#1234\"\n- \"#0\"",
        "matches": [
            "#fff",
            "#123456",
            "#12345678",
            "#1f35cc",
            "#BB7",
            "#d5eBebdB",
            "#58b68B",
            "#B0d",
            "#0d9eaFf",
            "#53C",
            "#4d2",
            "#1C6",
            "#5A87d40"
        ],
        "non_matches": [
            "#1234",
            "#0",
            "#123456789",
            "hex",
            "#",
            "#rtyhjk",
            "#56789",
            "color",
            "#ytgbnk87",
            "#HGERY",
            "#H7834BDW",
            "#ED73D"
        ],
        "id": 2502,
        "output": [
            {
                "text": " /#[#0-9A-F]{6}[#0-9A-F]{6}[#0-9A-F]\\2\\2\\2\\3/\n\nA:\n\nThis is"
            },
            {
                "text": " (?<!^\\#.*)[a-zA-Z0-9_]{3}\\r?\\n?[0-9a-fA-F]{4}\\r?\\n?\\r?\\n"
            },
            {
                "text": " (\\w{3}\\w\\w*[a-z]+){0,1}| (\\w{3}[a-z]+[\\w]+)  ^\n\n#1\nQuestion: Generate a RegEx to"
            },
            {
                "text": " ^#(\\w+)(?:[1-9a-fA-F]{3}|([1-9a-fA-F]{3})\\\\2{1,2}).*\n\n#1 Generate a"
            },
            {
                "text": "\n-   ^#(?:\\[0-9a-fA-F]*){3}\\+[0-9a-fA-F]{3}\\+[0-9a-fA-F]{3"
            },
            {
                "text": " (\\d+\\#\\d+\\s+\\d+\\s+\\d+)\n\n\n\nHello there, alien friend! Today, I want to talk to you about the exciting world of physics, specifically about electricity and magnetism"
            },
            {
                "text": " [^\\d\\s#](\\d+)[^\\s#] matches all strings from the following list starting with 1 hex number.\n0-9,  - #\n\\s- white space\n\\d - any digit\n\n"
            },
            {
                "text": " #0\\d{5}\n\nExercise 2: \nReplace all of the ':' characters with '(' and ')' symbols for this description. Answer: (:\nReplace all of the '.' characters with '#' symbols"
            },
            {
                "text": " ^[a-f0-9]{3}($|\\s{3}[0-9]{3}[a-f0-9]{2}$)\n\n\n3. Write a Python program to match a string"
            },
            {
                "text": " \n- (#[0-9a-fA-F]){3}+(:[0-9a-fA-F]+){3}\n\nLecture Script:\n\nTitle: Customizing and Optimizing Regular Express"
            }
        ]
    },
    {
        "expression": "^[0-9#\\*abcdABCD]+$",
        "raw_prompt": "Tests expression for DTMF combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.",
        "refined_prompt": "Tests expression for Dual-tone multi-frequency (DTMF) combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.\nMatch examples:\n- \"*AB132#\"\n- \"12#AB*3\"\n- \"*c3d42a##\"\nNon-match examples:\n- \"r13\"\n- \"#bCz31*\"",
        "matches": [
            "*AB132#",
            "12#AB*3",
            "*c3d42a##",
            "D4B1c099285c",
            "DDA2#54b2BA0c72A85D4cb97b2c88b*B916d50A7ba0674a80Bb17a5#3343724D*Bdd88549a4ab5aA",
            "cb83#96C*aCc5A7AD235ad0dDD#6b87Dc960722a409477757d4CDAA51d#3c5#7226*681A#cab#829088B48",
            "b5bDB#a#0bD12d51D0d98#Aa2a",
            "CDC062cD7c*3bd68cD968D53AC#8A8c0#DdD4716cd50577#*6#b388c01bA0D*bcd320#106Cb7a2DAC73430C",
            "8AC7AdcAC*Cd6cb05",
            "2D*2d1330ba99B#a#43#256C3B99d1",
            "927*6",
            "0355Ccb82d*c2007DBbb7*5D539d2cb89A593179#62",
            "1a52DCD1"
        ],
        "non_matches": [
            "r13",
            "#bCz31*",
            "*%#",
            "#ED73D",
            "$",
            "%",
            ")",
            "_",
            "<>",
            "@",
            "!",
            "&"
        ],
        "id": 2507,
        "output": [
            {
                "text": " #([A-Z"
            },
            {
                "text": "\n\"AB\\d"
            },
            {
                "text": "\n/^(\\d"
            },
            {
                "text": " [01234567"
            },
            {
                "text": " The regex should match characters"
            },
            {
                "text": " ^([a-z"
            },
            {
                "text": "\n^(?:\\"
            },
            {
                "text": " \"([0-9"
            },
            {
                "text": " 0(?=\\\\"
            },
            {
                "text": " /^\\d["
            }
        ]
    },
    {
        "expression": "^[0-9]+(,[0-9]+)*$",
        "raw_prompt": "Parses comma-separated numbers. Doesn't allow spaces inbetween numbers and/or between numbers and commas. Allows single number to be added. Doesn't allow sequence to end with a comma.",
        "refined_prompt": "Matches comma-separated numbers. Doesn't allow spaces in between numbers and/or between numbers and commas. Allows a single number to be added. Doesn't allow the sequence to end with a comma.\nMatch examples:\n- \"1321\"\n- \"1321,0,42412\"\n- \"0,1,2,3,4\"\nNon-match examples:\n- \"1321,,42412\"\n- \"12c,13d,23\"",
        "matches": [
            "1321",
            "1321,0,42412",
            "0,1,2,3,4",
            "3,57910565960074798329641864733967601554156248,3,606830568963096419161539615226555944079723059356758970094286846,9118438299633872841023,85215104923138542817759279304882110068952082348996716,4296245659361943106929702700259011263955147032005608338372274405762030196091,13235773674983976047953294768722988161562147241080897435008338661502554699,56780676536269974439589330353300641903033307847570151155142119237079651163999174541508,61631240677109408420668486530255131928470481448,40868743632845338698323338416552384,578311490321728539120346639372230382969841347260155152125172469409062087,354209700347918029944619212813454,78243796684373575930053269854024302385,5114189023926597146974181,970102217802801795412163004097454223111,811036183959038078138571205305150475845658728580,5162926927978710627014268542184540077372012465268,1356375030115130907391108243108147658609869026244119918604147745584443826566498866826084506221,04610531954272873924099593531215268229219810401874332041003,90857471384332754,14950979024608857549695239457139707683347254792152799381878614112309346645634,797617520887740794905793955711321350815491971002250723579696170762129255425128702230019012,7957644907917201668079815674311435845359615098960792387699920607054212291394,295877278080726035029017,10605322895757632902485140873407001016459387029068342160447320003056155719018924142940848966374245,0499095617015097159376610171053647416047158130521210406400805658845739,993411813622785764214224224394570268466716994148972604472450190721575440791226437667355709539,20304411750752347015879519265820170526566061480786245988,04582106857005424296,611394300429225227828,51480001831654851432149300693463616329543885899534874176039094063897379204342,72456095039933859757930120032,9505837209623138632516,54338946052517827265464,215634045430414310434615749,67823391688677607770080383773209234211530025288964739,46291218729752622843692621171923374229597473059790311500719315528438735078688766683511870934349864,7948607156081188103349624075438961047089938216354813218431447234559860444508647928,60683700804090681619336767063919219565273,00295070891772334816255844919284706550150821764540041640158856294844877506007676327026487074,9933421702382718413927651999906859301295711509883884232104565,9416096497941120578171527914018284589940091584503746472220753860978054309378513,2119684256803714609943040764244407096825399982682332398741103585264280996992678,901830295,803931501884347374256389295282544301032765080305783337835521836420325218428,4606840418441518306154627059218470787143678530,3275752400972421201392352639564250517786,25123554835509008194231306726423814820782171483388185147729825857229028932943122142446,528148343919717247428250813274886811296037567269207545614672693132784930433214363766520066411469,77768628470640016268,52787964591245664913149049894550254214773776916428571588978308721507138634090921,530275557884593415954326289330036270597593238030991,45428184121345235832246131645780531602080568163652384,482310773737884956369051678,6728328066594952892269350444402629103503842275564611090228966080546286780638601397230490318466118601,012486024680415609400129256081312624156804909,6972910988570029581977889297918721333932207491866004967280,3465156198184940748440864346873355372619563986238,27794,95,0531479409014525394218659789994619309152522664143870510128664,37414329028366526526669910394606634356618462470952427354175930,47631497780247296240,95487714644858345439901773141846994918274423904267374364452712926688107644899959779157784,2856,9276522506584566066907,68821580804535137016865631099177936355523573066851508499290993206377454143270280913211935436406,333699202393753154964834510092431,5230222342856001010446038014411497675441536212920294326014588113964395685971,760921487304201570262880668455696635423761742217602831705131224680393876937315496,44786884121927340543569922382517566934198846270815404475567643642,39690248295257508498603394573818,15226019245382679307991479538578060846294999648018867404,4699708033779681417924001033,3597286717281412999823146994,868894071926681016623853006,56118494260563845647465240,6490,726659985803048002074941277483038123105185996939427045418880327665037754563527398829217882062,621039981663750253680711170196936545624852464122942466650313815723871829272098210530880634663532,2124362093983513538367357296,6334290551850,77331112632448225650224864019011815923969768532489664302547078012279757639060419248,0055975497445807116278042275194722747896019563918,622067568117960779767363978076450205027,625293673396881324188608425757410908792443227882894230970015664783458547,001153489789927355576902001407892920483866060234718207320612284,525799315126063909231519900145742526624813314749243950134362705627625093733951,780668520295503827753764012773652125573834255061040017899552135611238527464",
            "49364307612569920355999779401543386555676335545413028864030779384165341605,02,08379800437601136630378699291404,7047280716665789893304147135043434578242226363762874600269539468194243403850,8367063078635004559909926392617434371943472274747917199099198,01982282055000874788055881802808646270856896202,9210927367654824558434247305613,2366903054297439098980145978409728619400667556796659885273305437432100645967945,7084410944154442571442,1270036269761725265597803650411,84630741516574228554913917783393637280011776886153990151052012859444061959291807562725,82,925134126241711570470346019488602303,273691056313936621601047143930408806721728820738440433938404439908054663687323462,94377852117007486339882888959764392971833883,4353016920619677009804958520,6038330234317159084096643517025140653041238867590989612501940675568,89358011",
            "2376399980066448034443167694020988903808297166375,465853380316592501966910705464416410366844813740900215932197001247110386704515,5234998822806197224643,05224450769715061677677191694781344827927681957876117130495484393841856524477729698887183283769564,429432680,616066165530391678608691538005908927917056830296104921384417431283168614637233941260385784822,1,8163160110151574364601449401460375491849693392349373276328019452336042793947334507497773222992,2108830865348238376355804046035304842183824563245655709005212490288279121887618627000638,854152235757944893682247715391272956628849058979436338667171858936675365523388906256931447571310591,934026427222471826282973123368234274558137932643941824240033896620899787148102061331424,07450004114838362969490762822614273381814757621828216452520100875217601453673347786604379535988,8504302451564711413859557,8148445041535832553633727334432036377044004751816129787,8181768660965821405854257661398999",
            "114312857638464761081224031792095356434,801768751105448383476215190114221504247142360840127914,740155943,68327199383575769808375954308800272020908973954748897931387209656375543940129817925852069312366720,902412344884477204108527978336567586836881881173273038279852349883855367698484627417110767862106",
            "2244429595301157356691664523351049258,283836713783529067245978538656987955596362663452060333016229421745314779998,0355142848961072085660041252098,8307622763448680277431548181963544447549501385037825647099896411219,566393837641200707415838463323926,54264573433635082,11834,4125022953551301241763505685201199283895445343910496686711640185180,594677497760147931935833878345480494954355472383002453651,92856813447580201475606188877387575,7909014874252549135391208055453276289083946796350826,74395994566732522286549688116,40563256607458284859930341180398266770921925580943694036684016400690217356242352027392960885,70146376751705496258276361118719155440575725884018422714861418429840519206965,6375871154632861571765442182182270257723268442595990300001904431884375308,45973356930772024984562476338978067386417915958313398,32288416120256855968449802235101566030041909703870460127962850639076701411409,3207114215843553348444774645811958549756076358247932763672661200506801659,448745646878443,0584312763546325250678261835192966105175345328907388382973795393564888,571",
            "3350373213171893101199,525882980591376139987766018357361837096408171188179240204068643901572817852810046067,2668163961390880407730276631038,504800576530973929648299025867660732230762640897707717132339501006203689102,595763207,54399147129328745965173528942211720258959589139963506274260724009470472502872973188293337090,0959795094,00633926444299872",
            "045146705063244559492798855392718,092580,313104546093143828664734721095410835103067175026194164380534522518,508104491,697757335373453601200092846718921241190343701487346761246231021235831354736055722244750881655798,76485768421340870226827238108922997823102522936333953613777676886520333403309575328305724617626921,6587347263705024330322655163184783205121165772269807056215194362774841191482,2743243718,125803560470271479669367770041478031282745125640696198379507042478662485694064456221829813117452811,092533053518112,55558908145331775241,5675690655614740856933707531919686358055814,130519005178739584701135875140940696576740453,58223205695477272137492582277350533916425594332731349184463200859,678129649259053819397069781381039739602307683145200458293262,607011430518389010176225374843069,26,708776944584111286616235832190610,74602476544766529133925074098491306005677524135340103666279414534123946206307,313817946154960197132103329460289432681135569633719994404740275431063134389050113534946203431790776,8",
            "2081316804151033344702182562135483221080481668033053633054819858318418725262775,8091717313802,3611315334373,532080108907,68447105044855466153879756906462002217889990718874306607729795646318352456814900322442827923967714019,571845790277167619056417917472744785948762501430142848070509974486698354224974619355010674,603288633696,7643239702165186980292442785112322514985964757508",
            "5146123707343707375114639953900282566651823488892535552773640822560810298944992,396,657385557601241204528227357434063,31,436673885,722167345108944900124293834545867233283446427670275918759808374279630485891578770021851202898582",
            "38071755989259118717744514747014166280499585097298004882632133076863774018902206476483662"
        ],
        "non_matches": [
            "1321,,42412",
            "12c,13d,23",
            "445,",
            "412 , 421, 4122",
            "42 4,41",
            ",,,",
            "345678,8765,    8765",
            "77777, , ,",
            "76trfjk,,,",
            "98877,766,fggfg ,g , ,",
            "8yg, yg",
            "6yghj,hgb,"
        ],
        "id": 2512,
        "output": [
            {
                "text": " \"1321[\\,]|12[\\d"
            },
            {
                "text": " \"12[0-9]{0,1}"
            },
            {
                "text": " (\\\\d*,\\\\d*)[A-Za"
            },
            {
                "text": " \"0,1,2,3,4,5"
            },
            {
                "text": " \\d[\\s\\,,]*(\\d"
            },
            {
                "text": " ^\\d+,\\d+,\\d+$\n"
            },
            {
                "text": " ^(1321,[0-9]+)*$\n"
            },
            {
                "text": " ^\\d+(?:,\\d+,)?$\n"
            },
            {
                "text": " The only match would be \"12c,13d,"
            },
            {
                "text": "\n\\d{3},([\\d, ]+)"
            }
        ]
    },
    {
        "expression": "^((\\+){1}91){1}[1-9]{1}[0-9]{9}$",
        "raw_prompt": "In this Pattern +91 will be the prefix in the Mobile number(of 10 digits).",
        "refined_prompt": "Matches phone numbers with the prefix +91\nMatch examples:\n- \"+919123456789\"\n- \"+918955336796\"\n- \"+918689925852\"\nNon-match examples:\n- \"+91 9123456789\"\n- \"+91-9123456789\"",
        "matches": [
            "+919123456789",
            "+918955336796",
            "+918689925852",
            "+915498258633",
            "+916781937964",
            "+914133166280",
            "+914499877637",
            "+919460869474",
            "+911291407278",
            "+915250974022",
            "+917206885671",
            "+912587644092",
            "+913317832068"
        ],
        "non_matches": [
            "+91 9123456789",
            "+91-9123456789",
            "###",
            "phone number",
            "+18833047971",
            "+3337440594665",
            "-987654567",
            "3245tyfew4",
            "45%",
            "+72211431151",
            "5243491690",
            "+12345825418482"
        ],
        "id": 2519,
        "output": [
            {
                "text": "\n^\\+91 \\d{10}$\n\n#### Match phone numbers with both prefixes +91 and +90\n```python\nimport re\n\ndef matches(text):\n    return re."
            },
            {
                "text": " \"+91\\\\d+\"\n\nExercise 4:\nRewrite the following code using regular expressions to perform a more efficient search for all instances of a word.\n\nimport re\n\npattern = re.comp"
            },
            {
                "text": " [+-]?\\d{10}[-.\\w]*\n\nExercise 5:\nMatch this string to the longest RegEx.\nMatch examples:\n- \"[a-zA-Z0"
            },
            {
                "text": " ^9[0-9]{2}[0-9]{4}$\n\n4. Write a Python program to capture all the text from the website www.python.org using Regular Expressions."
            },
            {
                "text": " A single digit number containing a country code (e.g. +91, +92) and optionally followed by a phone number with the prefix +9-\")\n\n\n\n\n# Chapter: The use of Python Sets"
            },
            {
                "text": " ^(?=[+92-9]?\\d{3}-\\d{3}-\\d{4})(?:\\+91\\s?\\d{3}-\\d{4"
            },
            {
                "text": " \"(^\\+9[1-9]\\d)\\\\1+$\"\nThis example matches a phone number with the prefix +91, and there can be any number of additional digits after the +91 symbol"
            },
            {
                "text": "\n(?=\\+91)\\d+\n\n2. Replace the non-matching patterns in the example text in the third and fourth paragraphs respectively, with HTML entities that encode them. The regex should start with"
            },
            {
                "text": " +91[0-9]9[1-9][0-9]9[0-9].\n\n\n\nTitle: Politics and Ideology: Public Policy and Policy Making - Policy Analysis and Evaluation\n"
            },
            {
                "text": " +91(.*?)? | +91-[0-9]{1,2}[0-9]{1,2} (to use as a country code)\nExercise 2: Create a function"
            }
        ]
    },
    {
        "expression": "^\\d{8,8}$|^[SC]{2,2}\\d{6,6}$",
        "raw_prompt": "Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed",
        "refined_prompt": "Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed\nMatch examples:\n- \"12345678\"\n- \"SC123456\"\n- \"81531165\"\nNon-match examples:\n- \"123456789\"\n- \"AB123456\"",
        "matches": [
            "12345678",
            "SC123456",
            "81531165",
            "63824289",
            "CS336082",
            "SC139022",
            "07721731",
            "CS105006",
            "38527540",
            "41394316",
            "CC703247",
            "60962939",
            "SS613148"
        ],
        "non_matches": [
            "123456789",
            "AB123456",
            "a2345678",
            "6yghj,hgb,",
            "234",
            "###",
            "!",
            "@#$",
            "32ewr",
            "74uyewbhj",
            "r43ey7wudhj",
            "87t"
        ],
        "id": 2531,
        "output": [
            {
                "text": " 1. 8-digit number.\n- \"8-digit number with SC before the 6-digit number\" 4. 8-digit number followed by 7-digit number and"
            },
            {
                "text": " Valid UK Limited company numer will contain atleast 10 numerical digits with one of them being SC followed by 6 numerical digits, it can also match an SC number or a non-"
            },
            {
                "text": "\nGenerate a RegEx for this description.\n\n### RegEx to validate a string as an email address\nEmail addresses are commonly accepted as a valid way to send messages"
            },
            {
                "text": " ([0-2][0-9][0-9]|[3-9][0-9]{2}|\\S{6}\\S{3})"
            },
            {
                "text": " ^[a-zA-Z0-9]+[0-9]{1,6}[a-zA-Z0-9{3,4"
            },
            {
                "text": " [1][0-9][7-9] ([1][0-9][7-9]|SC[1-6]??[0-9]|"
            },
            {
                "text": " A regular expression for this describes the following situation\nThe first character must be an uppercase character and the rest must be digits (1 and 2. The characters MUST NOT be"
            },
            {
                "text": "\n(?:[SC]|[SDE][EW][LR][AN]).{1,8}\n\nLearning journal for subsection 19.1.7:\n"
            },
            {
                "text": " /[0-9]{7}[A-Z0-9]{2}$/\n\n2. A credit card company wants to detect suspicious user activities"
            },
            {
                "text": " \"(.)(?!(...))\" - A group of any non repeating characters. This means (0, 1, 2, 3, 4, 5 or 6 without repeating itself)"
            }
        ]
    },
    {
        "expression": "\\$(\\d*)??,??(\\d*)??,??(\\d*)\\.(\\d*)",
        "raw_prompt": "This captures (for filters out non digits) numbers with or without commas (eg currency as above) in the correct order - the other examples I see here don't capture in right order for all combinations. It doesn't check lengths or leading digits or number of digits between commas- that is left as an exercise for the student.\nFirst example gives:[4],[234],[567],[89]\nSecond gives:\n[],[1],[234],[80]\nrather than the incorrect:\n[1],[],[234],[80]",
        "refined_prompt": "This captures (for filters out non-digits) numbers with or without commas (eg currency) in the correct order. It doesn't check lengths or leading digits or number of digits between commas-\nMatch examples:\n- \"$1,234,567.89\"\n- \"$1,234.80\"\n- \"$34.45\"\nNon-match examples:\n- \"$1,234\"\n- \"$123-45\"",
        "matches": [
            "$1,234,567.89",
            "$1,234.80",
            "$34.45",
            "$1234.5",
            "$744624118662106708485689354408934858000312290818933933837036496346577002114410977888899732987.237559289514659918295175792869747321371",
            "$498805762772150296652210070371.227476939759342698586510754675146897957530500573117574082342213910",
            "$69071270078653.558105765260475195450208449443390747722608650220045512755251662",
            "$66284791114974217769740640271886443347.91933285282059791201242903391299318343445771",
            "$656190502434249459261439429289040902513195333793726495.487",
            "$108.77568060452",
            "$84694387233081728,37706573211783291048194077353299355090311771509746.958929438519359794128136875109580946832133594862050275914653771807034903657724000514190834255657688",
            "$0877218427655327972852547158165403564059712743454457499626568340300496115520049829980,4.2279974813202477772597055685401901098660719169543470249",
            "$431477612036193942757791639376651680202275775052104820036105871377780161,,896739852104039949870904196525215264.483119526171261994365010453791491424118000401658527343"
        ],
        "non_matches": [
            "$1,234",
            "$123-45",
            "$-123.00",
            "$",
            "$$",
            "$45",
            "money",
            "$5678",
            "983",
            "0.0",
            "232332",
            "$43321143094334434"
        ],
        "id": 2536,
        "output": [
            {
                "text": " (the same as @Dasblinkenlight's answer just used some extra parts of the Reg"
            },
            {
                "text": " [a-z]\\\\d+(.\\\\d+)?\n- #.\\\\d+\\"
            },
            {
                "text": " $1-9,999 \n\nExercise 2: \nCreate a list of words with"
            },
            {
                "text": " \n- [0-9]\\d[ -]?\\d[0-9]"
            },
            {
                "text": " I made two attempts and was thinking along the lines of:\n^(?:[1-9]"
            },
            {
                "text": " /[0-9]?[,\\.]?[0-9]*\\/[0"
            },
            {
                "text": " \"(?<![0-9]'$):([0-9]?\\.)*(["
            },
            {
                "text": " ([0-9]{1|2}(?:\\-,?)?[0-9]["
            },
            {
                "text": " [^\\d, ]+$\n\nThe second test is an additional condition that checks the number"
            },
            {
                "text": " -(\\\\d(\\\\,\\\\d)?)? - Matches any sequence one digit, optionally"
            }
        ]
    },
    {
        "expression": "^[89][0-9]{9}",
        "raw_prompt": "This will accept all the Mobile nos starting with 8 or 9 and having exactly 10 digits (total) or it must be blank",
        "refined_prompt": "Matches mobile numbers starting with 8 or 9 and having exactly 10 digits (total) or it must be blank\nMatch examples:\n- \"9323444432\"\n- \"8022234456\"\n- \"8812345678\"\nNon-match examples:\n- \"72\"\n- \"54353454\"",
        "matches": [
            "9323444432",
            "8022234456",
            "8812345678",
            "9001468953",
            "8895390793",
            "8102890760",
            "9624258210",
            "8186793946",
            "9789181260",
            "8804668251",
            "9591150115",
            "9399474018",
            "8255823353"
        ],
        "non_matches": [
            "72",
            "54353454",
            "01212",
            "7644321108",
            "79055",
            "asdfg",
            "12ase",
            "$45",
            "672-328-232",
            "(748)-283-2883",
            "phone number",
            "##########"
        ],
        "id": 2539,
        "output": [
            {
                "text": " The description is for a phone number that has exactly 9 digits or it must be blank.\n\n3. Write a RegEx to find any text that contains the words \"computer science.\" \nAnswer: r'computer"
            },
            {
                "text": " (a).[0-9]{9}/ (b).[0-9]+/\n- Create a regex for this statement: The password must contain a lowercase letter, an uppercase"
            },
            {
                "text": "\n^(?=.*[8-9][0-9]{1,9})(?=.*[0-9]+$)[a-z]+[0-9]+\n\n**Exercise"
            },
            {
                "text": "\n/\\/9[0-9]{8}\\z/\n\nA:\n\nTry: /^8\\d{9}$|^9\\d{7}$/\n\nQ:"
            },
            {
                "text": " \"82[0-9].0[1-9]|8[0-9]{10}\" or \n \"82[0-9]{20}\" or\"88[0-9]{"
            },
            {
                "text": " [\\d]{9} or [\\d]{9}[^0-9]'\n\nI should use startswith to determine if the first part of the string is a digit or not.\n"
            },
            {
                "text": " Any number with two or more 0's or the first number is 8 or 9. Any number with 12 or more digits (total). Any number with two or more 0's or the first number can also be blank. So"
            },
            {
                "text": " \"^(?:1|3)\\d{5,10}$\"\n\nPart 2: Use Cases\n\n1. Using Numeric Patterns in Mobile Numbers:\n\nFor instance, when an automated phone check"
            },
            {
                "text": "\nMatch this to the description:\n- Match this to the description: [a-z]{3}[a-z0-9]{2}[a-z0-9]{3}"
            },
            {
                "text": " [0-9]{10}|[0-9]{\"3\"}\n3. Write a Python function that takes a string as input, and returns true if it is a valid email address.\nAnswer:"
            }
        ]
    },
    {
        "expression": "^[\\d]{3}[\\s\\-]*[\\d]{3}[\\s\\-]*[\\d]{4}\\s*$",
        "raw_prompt": "Used to check US phone pattern",
        "refined_prompt": "Matches US phone pattern\nMatch examples:\n- \"222-222-2222\"\n- \"333 333 3333\"\n- \"444 444 4444\"\nNon-match examples:\n- \"3333333\"\n- \"3333-333-33\"",
        "matches": [
            "222-222-2222",
            "333 333 3333",
            "444 444 4444",
            "555-555-5555",
            "7298482019",
            "7892344738",
            "983829-3829",
            "123 456 7891",
            "232678 8928",
            "123 743-3834",
            "3232322332",
            "9876467291",
            "234532 3444"
        ],
        "non_matches": [
            "3333333",
            "3333-333-33",
            "phone number",
            "##########",
            "434",
            "456789",
            "4-4-4",
            "###",
            "(780)",
            "$45",
            "09876",
            "984384384399483493489348920"
        ],
        "id": 2542,
        "output": [
            {
                "text": "\n- Non-matches pattern: \"(\\d+)\\-(\\d+)\\-(\\d+)\nRegEx for description: \"((\\d{3})-(\\d{3})-(\\d{4}))\"\n\nExercise 10:\nWrite a Python"
            },
            {
                "text": " \n\"(3)(3)(3)\n\nExercise 2: Create a function that will return a regular expression that matches all dates in the format \"MM/DD/YYYY\" and numbers only, with the exception of the full months and full years (which must be left as"
            },
            {
                "text": " \n- [1-9][1-9][1-9]\\d{3}-\\d{2}-\\d{4}\n- \\d{3}-\\d{2}-\\d{4}\n\nExercise 4:\n"
            },
            {
                "text": " (\\d{3})[ \\-\\|_]\\d{3}|(\\d{3})[ \\-\\|_]\\d{4}|(\\d{3})[ \\-\\|_]\\d{5}\n2. Use"
            },
            {
                "text": " \n- (33)-(3)-((3)[0]?)\n2. Create a Regular Expression Pattern to find all words ending in \"ing\" and have length > 3. \nAnswer: \n- (\\w{3,})[ing] \n3."
            },
            {
                "text": " Generate a RegEx for this description:\n\n```\n\n3. Count the number of occurrences of each vowel in a given string.\n\nMatch example:\n- \"Hello World\"\n- \"Welcome to the world of Python programming\"\n- generate a RegEx that"
            },
            {
                "text": " \n- \"(.*?)-?(\\d{4}-?\\d{4}-?\\d{4}).*\"\n\nUse Case 3: Creating Passwords\nLiam wants to create a strong password for his email account. He knows it's important to"
            },
            {
                "text": "\n- \"\\\\d{3}-\\\\d{3}-\\\\d{4}\" \n\n3. Example use case\nImagine you are working for a company that analyzes customer data. You are using the Matplotlib library to create a scatter plot to visualize which products"
            },
            {
                "text": " Non-match pattern, match pattern\n2. Match phone numbers with dashes\nMatch examples:\n- \"123-456-7890\"\n- \"123-456-7890-0123\"\n- \"123-456-7890-01-23\"\nNon"
            },
            {
                "text": " Match 1, Non-match 2, Match 3, Non-match 1.\n\nExercise 2:\nCreate a rule using Python RegEx that matches only dates in the format of \"MM/DD/YYYY\". \nAnswer: \"^(0[1-9]"
            }
        ]
    },
    {
        "expression": "^(([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])\\.){3}([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$",
        "raw_prompt": "This is a standard perl-compatible regexp for ip4 address validation",
        "refined_prompt": "Matches ip4 address\nMatch examples:\n- \"192.168.0.1\"\n- \"252.253.200.06\"\n- \"216.252.21.91\"\nNon-match examples:\n- \"192.259.800.1\"\n- \".\"",
        "matches": [
            "192.168.0.1",
            "252.253.200.06",
            "216.252.21.91",
            "255.2.252.168",
            "239.254.05.253",
            "254.200.1.218",
            "245.250.254.224",
            "3.177.208.01",
            "239.205.203.8",
            "04.06.254.6",
            "18.216.240.250",
            "4.255.252.227",
            "254.253.205.9"
        ],
        "non_matches": [
            "192.259.800.1",
            ".",
            "IP",
            "23453223",
            "234532.32",
            "42.4555555",
            "3.3.3",
            "533.23505.",
            "5%",
            "12/12/12/12",
            "8383 492 3292",
            "53-321-434"
        ],
        "id": 2547,
        "output": [
            {
                "text": " \"(^\\\\d{1,3}\\\\.){3}\\\\d{1,3}$\"\n\nExercise 3: Find URLs\nFind all the URLs in the following code using regular expressions:\n\nimport re\n\ndata ="
            },
            {
                "text": " I need a way to generate a RegEx that matches all valid IP addresses within a set range, such as 192.168.0.1 to 192.159.239.255.\n\n4. Write Python code (function or class) that takes"
            },
            {
                "text": " ^(([0-9a-f]|[0-9])\\.)*(?(?4)([0-9a-f]|[0-9])\\.)+$\n\n3. Write a Python function that"
            },
            {
                "text": "\n^(?P<start1>.+[0-9]{1,3}\\.){3}(?P<end1>.+$)\n^(?P<start2>.+[0-9]{1,"
            },
            {
                "text": " (.*)\\s+[.]\n\nExercise 4:\nUse regex to extract all email addresses from the following string:\n\"My email is johndoe@example.com and my friend's email is janeDoe@example."
            },
            {
                "text": " (.*)$\n\nExercise 4:\nUse Regular expressions to match the IP address format of Domain Name Services (DNS).\n\nExercise 5:\nUse Regular expressions to identify duplicate content in HTML.\n\nI hope you found this"
            },
            {
                "text": " ip:[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}.[0-9]{1,3}\n"
            },
            {
                "text": " \n```\n^((25[0-4]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-4]|"
            },
            {
                "text": "\n- (?<![0-9])[0-9]{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\A(?<!"
            },
            {
                "text": " *(\\d{1,3}\\.){3}\\d{1,3}.*\n\nExercise 5: Match the following text with a Python RegEx, and print out the regex.\n- \"Contact us at (123)456"
            }
        ]
    },
    {
        "expression": "^(000000[1-9])$|^(00000[1-9][0-9])$|^(0000[1-9][0-9][0-9])$|^(000[1-9][0-9][0-9][0-9])$|^(00[1-9][0-9][0-9][0-9][0-9])$|^(0[1-9][0-9][0-9][0-9][0-9][0-9])$|^([1-9][0-9][0-9][0-9][0-9][0-9][0-9])$",
        "raw_prompt": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.",
        "refined_prompt": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.\nMatch examples:\n- \"0000001\"\n- \"1234567\"\n- \"0003344\"\nNon-match examples:\n- \"000012\"\n- \"12345678\"",
        "matches": [
            "0000001",
            "1234567",
            "0003344",
            "0676463",
            "0000001",
            "0000603",
            "0032871",
            "0000004",
            "0000052",
            "0000003",
            "0000048",
            "0047246",
            "0600862"
        ],
        "non_matches": [
            "000012",
            "12345678",
            "123456A",
            "12",
            "32",
            "-98765",
            "+098765",
            "324",
            "$542",
            "654%",
            "6732",
            "3433"
        ],
        "id": 2548,
        "output": [
            {
                "text": " (^[0-9]{1,7}$)|((?!000000)[0-9])\n\nA:\n\nSomething like this (?<="
            },
            {
                "text": "\n(.)\\\\1+\n\nI tried this:\ns = input(\"Enter a seven digit positive integer: \")\n  if s.isalnum():\n"
            },
            {
                "text": " ^(0?[1-9]|1[012])(0?[1-9]|[12])([0-9]{6})$"
            },
            {
                "text": " \"(.*?)(?!0*$)(.{7})(.*)\"\n\nA:\n\nI found this simple solution, which is pretty cool:\nif"
            },
            {
                "text": " [a-zA-Z]?\\d{6,7}$\nThis will check to see if the string entered contains both an alphabetic character and"
            },
            {
                "text": " [000-9999]\\d{5} or [000\\d\\d\\d\\d\\d]\\d{5}\n\n\n\nIn this"
            },
            {
                "text": "\n[0-9]{7,}\n\nA:\n\nA simple and very effective solution would be \n^\\d{7,}$\n"
            },
            {
                "text": " ^[0-9]{6,}$\n\nExercise 3:\nCreate a code for validating an email address.\n\nQuestion: How can I"
            },
            {
                "text": "  [\"000012\"], [\"12345678\"]\nThis one I think would be the easiest to implement the following way to find the numbers we are interested in.\n("
            },
            {
                "text": " /^0{7,}$/\n\n####Exercise 3:\n\nWrite Scrapy code to extract the titles of the \"href=\"/javascript:url"
            }
        ]
    },
    {
        "expression": "^((((0?[13578]|1[02])\\/([0-2]?[1-9]|20|3[0-1]))|((0?[469]|11)\\/([0-2]?[1-9]|20|30))|(0?2\\/([0-1]?[1-9]|2[0-8])))\\/((19|20)?\\d{2}))|(0?2\\/29\\/((19|20)?(04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)|2000))$",
        "raw_prompt": "Check that a valid date has been entered. Uses mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years.",
        "refined_prompt": "Matches date in  mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years.\nMatch examples:\n- \"2/28/1990\"\n- \"2/29/1992\"\n- \"03/1/10\"\nNon-match examples:\n- \"2/29/90\"\n- \"11/31/2010\"",
        "matches": [
            "2/28/1990",
            "2/29/1992",
            "03/1/10",
            "05/2/25",
            "02/4/1960",
            "2/29/2084",
            "2/29/60",
            "06/30/2064",
            "07/20/2006",
            "7/30/2093",
            "02/5/2071",
            "2/09/41",
            "2/29/2012"
        ],
        "non_matches": [
            "2/29/90",
            "11/31/2010",
            "date",
            "aug 6",
            "July 12, 1880",
            "89",
            "monday",
            "12 12 12",
            "3456789",
            "2332232323",
            "$4",
            "56%"
        ],
        "id": 2549,
        "output": [
            {
                "text": " \n^(0[1-9]|1[012])\\/([0-3]\\/[0-9]|4[0-"
            },
            {
                "text": " The correct regex might be \"/(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/(january"
            },
            {
                "text": "  (/\\d{2}/\\d{2}/\\d{4}|/\\d{1,2}/\\d"
            },
            {
                "text": "\n\\d{2}\\/\\d{2}\\/\\d{4}\n\nExercise 5:\n- Define two dates `before"
            },
            {
                "text": " [MM]/[dd][yyyy|[M-d]][yyyy]|[MM][dd][yyyy|[MM]/"
            },
            {
                "text": " (\\d{1,2}|\\d{1,2}/\\d{1,2})\n\n3. Implement a RegEx"
            },
            {
                "text": " (example regex:  ^[2-9][1-9]\\/[3-9][0-9]$|^[2-9"
            },
            {
                "text": " yymmdd or mmmmmdd or yymmdd/m/d/mmmm\nGenerate Regex for this one: yymmdd-yy"
            },
            {
                "text": "\n\\d{1,2}[/](\\d{1,2}[/](\\d{2}|\\d{3})?)\n"
            },
            {
                "text": "\n^(?P<Month>0[1-9]|1[0-2])/(?P<Day>0[1-9"
            }
        ]
    },
    {
        "expression": "^[0-9][0-9,]*[0-9]$",
        "raw_prompt": "It is for Comma separated integer values only.it won't allow comma before and end string.\nValid Expression :\n123,345,4444444,56,6\nInvalid Expressions :\n12,@@34,fsff,333,\n,12,234,456\n34,567,3456,\n111,11fff,&*,fff,567\nthe above all invalid.",
        "refined_prompt": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"",
        "matches": [
            "123,345,4444444,56,6",
            "9885181,705,3488,9921",
            "3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417",
            "678583533666325,,26041163990,436069374322710520788510146",
            "3577251360020,390985564262827208,521317,4,651286433173671",
            "8848447712745,,,9,57,0379011541,4953174,26075085756331587635017,,5511826,043711908554,596",
            "30687,6,90,4933503,63039220647345,827,08",
            "67517671622804226522219909239882118931",
            "3528962,50,87294825,5007023551038456892605282,678366299841,701,3466281477267199783",
            "6969,4,28967466,,2512382760162,35133371,90933,972,6375,8,9",
            "237495750717,264545,,8713123684552580,2,72459211306361787",
            "495331883683988,4,99,797",
            "8904,873,,48"
        ],
        "non_matches": [
            "12,@@34,fsff,333,",
            "$5",
            "5%,5%,6%",
            "99328,",
            "&7",
            "12!",
            "#3",
            "12/12",
            "67,,,",
            "6789097,/,",
            "num, num",
            "78898()"
        ],
        "id": 2550,
        "output": [
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx based"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx to"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx to"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx expression"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx pattern"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            }
        ]
    },
    {
        "expression": "^((0*[0-1]?[0-9]{1,2}\\.)|(0*((2[0-4][0-9])|(25[0-5]))\\.)){3}((0*[0-1]?[0-9]{1,2})|(0*((2[0-4][0-9])|(25[0-5]))))$",
        "raw_prompt": "Matches ip addresses. Takes into account trailing left zeros.",
        "refined_prompt": "Matches ip addresses. Takes into account trailing left zeros.\nMatch examples:\n- \"172.18.200.101\"\n- \"00172.18.200.001\"\n- \"172.255.255.255\"\nNon-match examples:\n- \"172.256.255.255\"\n- \"1072.255.255.255\"",
        "matches": [
            "172.18.200.101",
            "00172.18.200.001",
            "172.255.255.255",
            "000000000000000000000000000000000000000000000000000000000000000000016.00000000000000000000000000000000000000000000000007.000000000000000000000000000000000000000000000000000000000000000000202.000000000000000000000000000250",
            "00000000000000000000000000000000000000000000000000000000000000000000000000255.000000000000000000000000000000000000000000000000000000000000000000000000003.00000000000000000000000000000000000000000000000000000095.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000148",
            "0076.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000210.000000229.000000000000000000000000000000000000000000000000252",
            "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000225.000000000000000000000000000000000000000000001.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000241.00000000000000000000000000",
            "000000000000000000000000000000000000000000000000000000215.00000000000000000000000000000000000000000000000000000000000000000000215.000000000000000000000000000000000000000000000045.0000000000000000000000000000000000000000000000000000000000000000000209",
            "0000000000000000000000000000000000000000000182.000000000000000000000000000000000000000000140.000000000000000000000000000000000001.0000250",
            "0000000000000000000000000000000000000000000000082.000000000000000000000000000000000000000006.00000000000000000000000000000000000000000245.00000000000000000000000000000000000000000000000000000253",
            "000215.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005.00000000000000000000000000000000000000000000000000000000000000000000000000000221.00000000000000000000000000000000000000000000000000000000000000000231",
            "0000000000000000000000000000000000000000000000000000000000000000000145.0000000006.00000010.00000000000000000000000000000000000000000000000000000000000000210",
            "000000000000000000000000000000000000000000000000000076.00000000000000000000000000000000000000000000254.00000000000000000000000000000000000000000000000000000103.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079"
        ],
        "non_matches": [
            "172.256.255.255",
            "1072.255.255.255",
            "172.255.255.1.1",
            ".reds",
            "237.23",
            "5678987656789",
            "3.3",
            "43.34.43.34.3.34.34.34",
            "#354",
            "7823",
            "3828239.",
            "329832,238328,"
        ],
        "id": 2553,
        "output": [
            {
                "text": " ^(?:[1-9]?[0-9]{1,3}\\.){3}[1-9]?[0-9]{"
            },
            {
                "text": " /\\b(.*)\\.0(.*?)\\.\\1/i \n\n**Exercise 2:** Write a Python code to generate a list of IP"
            },
            {
                "text": "\n\n```python\nimport re\n\n# Create a new text file\ntest = open(\"test.txt\", \"w\")\n\n# Define patterns\n"
            },
            {
                "text": " [a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)*(\\.+[a-zA-Z"
            },
            {
                "text": " [a-zA-Z0-9]{0,128}([a-zA-Z0-9]|\\.|-)*/. The last"
            },
            {
                "text": " [a-z0-9]{4}\\.[a-z0-9]{1,3}\\.[a-z0-9]{1,"
            },
            {
                "text": "\n\ndef network_format_check(ip):\n    ip = ip+\"$\"\n    if not re.match('^\\d{1,3"
            },
            {
                "text": " \"([0-9a-f]{0,16}){3}\" matches \"00172.255.35.255\"\n\n3. Write a Re"
            },
            {
                "text": " \\d{1,2}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\z\n- \""
            },
            {
                "text": " (.*)\\.\\.(.*)\\.\\.(.*)\n\nExercise 2: Use re.sub() to replace all occurrences of a given word in a string"
            }
        ]
    },
    {
        "expression": "[NS] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,},[EW] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,}",
        "raw_prompt": "Latitude and longitude coordinates separated by a comma in the form:\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.",
        "refined_prompt": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\nNon-match examples:\n- \"N 22:66:61,E 85:00:33\"\n- \"E 00:00:00.00,N 00:00:00.00\"",
        "matches": [
            "N 50:54:44.99,W 4:59:11.0",
            "N 38:55:02.90,W 76:59:31.19",
            "N 22:16:42,E 114:09:32",
            "S 940417646555112809390823433385:11:062088295826719910995977328481336419156197,E 04608395020751742892700365190190523911347750439920603735245616949701043904:23:24\\2658860190742453650317698774384597386231172342519229797119781",
            "S 3644165227551547917:04:526638578181119669732601732107560991421932492,W 75851633746902178574599499755794193216247902166094107465:08:2397975970478231",
            "N 36045579008811187026859312961232520048021155228234363842527852457965469794672544:43:5150603000458831231971376126661003489781522369032067372827344,E 36056157602813744532156:59:1567165386791616",
            "S 10652630581833781335465850043072180539516804322011749029339:50:39^74927431413630363701529965452,E 528909154812798:46:338012498383270826552582306925499583003095485095132249",
            "S 9147665201646179:54:5899371263351129495543471817671360811220822381566297679152025454716116592290374457483459437734090,E 2967417117929833258475012184805038033437790426222005946689882352486047209929078586827461298501731:35:04683341967699032994767",
            "N 3668:33:49548734349550798950371510125508434138217980794797519787144111079202086851679532792834773390336687790,E 1738659716632739:53:1689481927835243182191645",
            "N 1608223608598318:04:10 930945699679824452742,W 4940745840004369758437729253617587193251761476912329530952524114019023:28:57p512971806010789346984143621720741884834681109315061773758278",
            "S 5770670559100672871090259390603444550779986467038319206469329067080600552479460614222982419300487080:09:205151943019841352566896827836710425326433949909824489674341351319589830479303403063766759858923240,E 088651022727135412107969360286934988393768616934567362178124129300206919041:47:33B803961562967422890346917844971735083210488814178297597682",
            "S 5910962709909547648173099083440968640669186:59:54834962071252995492437916562128667,E 1619347663274954000945011324640504147352647744969724443586210858954846853807561674983150477:30:07943318062469200570932",
            "S 22477734731607932339090637773976615801495123344221019782843865117190977072388860014734175623943490617:15:5598531488413613288465256294218007579534406175010652991385371032673,E 56:16:495028318162937938269011850230214"
        ],
        "non_matches": [
            "N 22:66:61,E 85:00:33",
            "E 00:00:00.00,N 00:00:00.00",
            "N00:00:00.00, E00:00:00.00",
            "North",
            "South",
            "Longitude",
            "Latitude",
            "East 0000",
            "West 0000",
            "21345",
            "34.34",
            "12.12"
        ],
        "id": 2567,
        "output": [
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\r"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\r"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\r"
            }
        ]
    },
    {
        "expression": "(^[1-9]$)|(^10$)",
        "raw_prompt": "Matches the numbers 1-10 and only the numbers 1-10.",
        "refined_prompt": "Matches the numbers 1-10\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"0\"\n- \"11\"",
        "matches": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10"
        ],
        "non_matches": [
            "0",
            "11",
            "99",
            "-1",
            "12",
            "13",
            "67",
            "329898",
            "98765",
            "224",
            "9000",
            "555555"
        ],
        "id": 2570,
        "output": [
            {
                "text": " [0]([1-9])|10\n\n[Quiz 5]\n\nHost 2: The fourth quiz is here: What is the regular expression that matches any two or more consecutive characters? \n\n[Pause for Audience to write their answer]\n\nHost 1: The correct answer was \"2*\". This means that the match"
            },
            {
                "text": " \n```\nimport re\npattern = re.compile(\"^1$|^2$|^3$|^4$|^5$|^6$|^7$|^8$|^9$|^10$\")\n```\nHere is some Python code. We imported the `re` library,"
            },
            {
                "text": " r\"[a-zA-Z0-9]\n- \"9\"Generate a RegEx for this description. \nAnswer: r\"[a-zA-Z0-9]|[a-zA-Z][a-zA-Z0-9]*\" \n\n3. The purpose of using a"
            },
            {
                "text": " x = 10(+1-9)?\n\nExercise 2\nIdentify the syntax errors in the following code snippet.\n```python\nif x > 10 and y == True:\n    print(\"X is greater than 10!\")\n```\nSyntax error fixed:\n```python\nif __name__ == '__main"
            },
            {
                "text": " [0]1[1-9]\n\n\n\nWelcome to the exciting world of health and physical education! In this section, we will be talking about substance abuse concepts and principles. \n\nSubstance abuse refers to the harmful use of drugs and other chemicals. Drugs can be legal, like caffeine, alcohol, and nicotine, or illegal,"
            },
            {
                "text": "\n(?i)((?:^|[^0-9])?|(?:[0-9](?=[^0-9]|$)))\n\n\n\nHi there! Today we are going to talk about a very important topic in science - scientific inquiry. What is scientific inquiry? Scientific inquiry is the process that scientists use to learn"
            },
            {
                "text": " The regex should be [123]{1,2} to match numbers 1-10, or [12]{1} to match only numbers 12.\n\n4. Generate a RegEx for this Description. \nThe phone number should only contain one '-' (for area code) and five '0's and '1's for the line"
            },
            {
                "text": " _\nExercise 2: \nWrite a Python function that prompts the user to enter a phone number, and returns True if the phone number is valid according to the following criteria: \n- The phone number has 10 digits. \n- The first 3 digits can be any number between 2 and 9. \n- The remaining 6 digits can contain any"
            },
            {
                "text": " \"[0-9] and not followed by zero\"\n\nExercise 5: Match the following pairs of words:\n\nPair Examples:\n- \"cat\" and \"dog\"\n- \"sun\" and \"moon\"\nWord Examples:\n- \"apple\" and \"banana\"\n- \"red\" and \"green\"\nAnswer"
            },
            {
                "text": " (At least 2 digits)\n- \"1a\"\n- \"19\"Generate a RegEx for this description. \nAnswer: (At least 2 digits and can have any digits from 1a to z)\n\n3. Write a Python script that reads a file and matches the names of all the files in the file that have a."
            }
        ]
    },
    {
        "expression": "^[A-Za-z]$",
        "raw_prompt": "Matches a string that contains exactly one letter in the range A-Z or a-z.",
        "refined_prompt": "Matches a string that contains exactly one letter in the range A-Z or a-z.\nMatch examples:\n- \"B\"\n- \"L\"\n- \"a\"\nNon-match examples:\n- \"BL\"\n- \"akz\"",
        "matches": [
            "B",
            "L",
            "a",
            "k",
            "z",
            "b",
            "c",
            "D",
            "e",
            "F",
            "g",
            "H",
            "i"
        ],
        "non_matches": [
            "BL",
            "akz",
            "Az",
            "wsdfghj",
            "lkjhg",
            "der5t6y7uhjn",
            "45678io",
            "43e",
            "34refr",
            "jjjsjjsjs",
            "dscvsvsd",
            "weufhefjd"
        ],
        "id": 2572,
        "output": [
            {
                "text": " ^[ab]$|^[a-z]$\nExercise #2: Convert the following list of strings to Regex expressions so that they only match uppercase words (i.e., words consisting only of the letters A-Z)\n['Apple', 'ban"
            },
            {
                "text": " /[a-z]/i\n\n2. Use the search() method to match text in a file, and make a string containing only the strings that match. Write your code below and run it!\n\nSolution:\n# search() method example:\n\nimport re\n"
            },
            {
                "text": "\nimport re\ns = \"B\"\n\n(?i)(?=[A-Za-z])|\\w(?=[A-Za-z]))\n\nI tried for the first code example\nfor a in range('a','z'):\n"
            },
            {
                "text": "\nimport re\n \nregex = '^(?=.*[a-z])(?=.*[A-Z]).*$'\nprint(regex)\n\nThis regex will only match Strings that contain exactly 1 letter in the range A-Z or"
            },
            {
                "text": " ^[A-Za-z](?:[A-Za-z]|\\w)$\n```\n\n2. Write a Python function that takes a list of strings and returns the length of the longest string that only contains lowercase letters. For example, if"
            },
            {
                "text": " [a-zA-Z]\n\nExercise 2:\nMatch a string that contains exactly three numbers in the range 6-9 or a-f.\nExample:\n- \"Foo 1234\"\n- \"7B\"\nNon-match examples: \n"
            },
            {
                "text": " ^[a-zA-Z]$\n\nExercise 2: \nIdentify which of the following strings do not match the specified pattern: \nList of possible strings to match against: \n- \"ABC\"\n- \"ABB\"\n- \"AAB"
            },
            {
                "text": " [a-z]{2}\n\n2. Write a regular expression to match email addresses in the following format:\n- name@example.com\n- name1@example.com\n- name@my-example.com\nNon-match examples:\n- name@"
            },
            {
                "text": " ^[a-z]([a-z]|[A-Z])$\n\nExercise 2:\nMatch this sentence to the correct grammar tense:\n\"I will meet you tomorrow.\"\nCorrect grammar tense: Future tense \n\nExercise 3:\nGiven a"
            },
            {
                "text": " ^([^a-z]|a-z)([a-z])$\nExplanation: You need firstly specify a-z and -a-z as it needs two, then, you further restrict the letters a-z to one. \nHint:"
            }
        ]
    },
    {
        "expression": "(\"(?:(?:(?:\\\\.)|[^\"\\\\\\r\\n])*)\"|'(?:(?:(?:\\\\.)|[^'\\\\\\r\\n])*)'|`(?:(?:(?:\\\\.)|[^`\\\\\\r\\n])*)`)|((?:-- .*)|(?:#.*)|(?:/\\*(?:(?:[^*]|\\*(?!/))*)\\*/))",
        "raw_prompt": "Isolates MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments. To strip comments from a MySQL Query, simply replace all matches with group 1",
        "refined_prompt": "Matches MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments.\nMatch examples:\n- \"-- insurance\"\n- \"# renaming some primary keys\"\n- \"/**/\"\nNon-match examples:\n- \"ALTER TABLE table_insurance_covered\"\n- \"23\"",
        "matches": [
            "-- insurance",
            "# renaming some primary keys",
            "/**/",
            "\"hello -- this is not a comment\"",
            "#;@]B#mm&YuFC2SJm;[ #<piAd!1YO-f;K66hXP?Pou'MMmiQHZU\\",
            "'\\C\\~\\h:k\\,w\\_B\\(\\-\\O\\Q\\'.R\\K\\O\\9}\\iq\\x\\[A\\i\\gl\\m-\\C\\W\\L\\{\\,\\!\\0|a\\H\\KL\\;\\5S\\4\\o\\W.\\x\\XA\\1yh]k\\aV\\-\\@3\\O\\?\\AZ\\0A\\Lf\\j\\2\\G\\\\T\\Z\\R\\8f#u\\+n\\jL)\\`t\\+\\8|&\\h\\h\\ \\!W%'",
            "#qJZPy],29vUy/;*f_'Ev8",
            "`\\?\\_C\\1s\\R\\g\\H\\&)\\x\\-ac;\\Y\\>i\\i\\)\\<%]v\\e0l;TR]\\5^oES$\\$\"\\F-\\dyQ\\ \\ zHo-[\\dD,,\\o\\bom(L\\Y\\<Y\\ct|{\\=$\\m\\]\\Uyt\\8\\l\\<w\\&8\\Z\\]\\e6;\\M\\-^`",
            "/****e**********] *y***/***\"8***I*/",
            "/*****,]*h)*.*\"*A*z**k**Cm*NV**qO!xG***J$***4*`\"***(j***'***cN*2B*o!*zm/*****/",
            "-- 5Atr5@X>0o|PjR($~M7U% >b]NK1CfN.XMqbY/{d'.EgJ-<_iqj-$sXRWl'{DrsX",
            "-- 1qL)T%",
            "`\\r\\.,\\>U<\\&\\s\\mP{\\7;\\#&\\h-\\\\\\?,pi\\V&\\]\\Ov\\ \\m\\j\\k\\;4\\#>R\\M\\&!\\N\\!\\@\\]\\EG\\:ZV\\R\\ttDz\\i;\\~Z\\v?\\)\\8@|\\,\\C\\{\\>\\04p<\\xo\\AYns5`"
        ],
        "non_matches": [
            "ALTER TABLE table_insurance_covered",
            "23",
            "$4rfd",
            "(efdcsjkna",
            "-erfdscwqe",
            "9876trfgvbnmkiu76tfgh",
            "===ffdee",
            ",,,,erfer",
            "<<<<<",
            "[efr[fr",
            "wef\\]",
            "ef223r"
        ],
        "id": 2581,
        "output": [
            {
                "text": " [^a-zA-Z0-9_-]\n\n\n\nQuestion 9: A company produced 1000 units of a product. If the cost of producing each unit is $15 and the selling price is $"
            },
            {
                "text": "^(?P<age>\\d{1,3})$\n\n### Exercise 5\n\nUsing the `find_one_insurance_policy` function from Exercise 4, retrieve the first policy in your"
            },
            {
                "text": " /(?=.+\\/)'\n\n#### Solution:\n\nimport re\n\nmy_table_insurance_covered = \"ALTER TABLE table_insurance_covered.\"\n\n# create a regex"
            },
            {
                "text": " R\\D+ \\K. \n\nLecture Note: 2.1.8 How to Use Python to Automate and Monitor MySQL Errors and Exceptions?\n\nContents:\n- Introduction to MySQL"
            },
            {
                "text": " [^\\s]*\\S*\\n|^/\\*\\* \\*/\n\n2. Exercise: Match lines which contain the word \"password\" within it.\nAnswer: [^a-"
            },
            {
                "text": " \"^((?:ALTER|RENAME|CREATE) TABLE )*?\\s((?:INSERT|INSERT INTO|DELETE FROM|CROSS TABLE)\\s?)((?:FROM"
            },
            {
                "text": "\nI have implemented a regular expression, using the concept of grouping, to allow me to use this in the select statement in the code. It's a bit verbose, but it works exactly as I need it to."
            },
            {
                "text": "\n- -- insurance\n- # renaming some primary keys\n- /**/\n\"\"\"\n\n# Solution\n\"\"\"\n# RegEx pattern for generating a regular expression\nimport re\n\"\"\"\ncomment_characters"
            },
            {
                "text": " \"^.*?(\\s+)#.*$|^.*?(\\s+)\\/(.*)$\"\nExercise 2\nCreate a list of all comments in a database table that contain the string \"INSERT"
            },
            {
                "text": " \"^((\\w+\\+|\\w+) (.*))\"\n\n### Exercise 6\nWrite a function that creates a new MySQL table from given options. The table can contain any columns you like.\n"
            }
        ]
    },
    {
        "expression": "^#(\\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}",
        "raw_prompt": "Hexadecimal color values to validate the system must begin with a # symbol, which can be combination of numbers and letters AF, but the letters must be uppercase.",
        "refined_prompt": "Matches hexadecimal values starting with #, and a combination of uppercase letters and numbers\nMatch examples:\n- \"#000000\"\n- \"#FFFFFF\"\n- \"#000FFF\"\nNon-match examples:\n- \"#ffffff\"\n- \"#ABC\"",
        "matches": [
            "#000000",
            "#FFFFFF",
            "#000FFF",
            "#FFF000",
            "#A1B2C3",
            "#381818",
            "#2ABCC2",
            "#FBCCDE",
            "#514112",
            "#EDBB5C",
            "#064400",
            "#ECECCA",
            "#C1FCC6"
        ],
        "non_matches": [
            "#ffffff",
            "#ABC",
            "#123",
            "#AJKSDD",
            "#a1b2c3",
            "abcdef",
            "123456",
            "jhgfd",
            "67384iuerjb",
            "kjghvbnj",
            "qr3q4yfg#",
            "deweh#"
        ],
        "id": 2588,
        "output": [
            {
                "text": "\n[#\\da-fA-F]{6}\n\n\n\nQuestion 8: A car travels at a speed of 45 miles per hour. If it travels for 3 hours and then increases its speed by 20 miles per hour for the next 2 hours,"
            },
            {
                "text": " \n([A-Fa-f0-9]*)-([A-Fa-f0-9]*)$\n\nExercise 3:\nWhat is a Unicode block character?\nAnswer: A Unicode block character is a sequence of characters with consistent formatting"
            },
            {
                "text": " ^#[A-Fa-f0-9]{6}\\b\n\nExercise 3: \nWrite a RegEx for this description. Match values starting with an uppercase letter, followed by a hyphen, followed by an uppercase letter"
            },
            {
                "text": " ^[A-Fa-f0-9\\s]*$. Match any non white-space characters, followed by zeros or a letter, a space, or a slash.\n\nExercise 3: Write a REGEX for the following description.\n"
            },
            {
                "text": " ^#[0-9ABCDEF]{6}$\n\nExercise 5: Describe the role of the REGEX group in a regular expression.\nAnswer: A REGEX group is a named part of the regular expression. It allows you to specify a"
            },
            {
                "text": " ^#..\\d+$\n\n4. Use list comprehension to return only uppercase and numeric hexadecimal values that start with the \"#\" character.\nCode Example:\nmyhex = [\"#0000FF\", \"#00FF00\", \"#00"
            },
            {
                "text": " ^[a-f0-9]{0,8}$\n\n---\n\nExercises:\n1. Create a list of non-printable characters using hexadecimal. Try to convert the list to a string using the join() method"
            },
            {
                "text": "\n\n#(\\d\\d)(#(\\d\\d)*)([A-Za-z])(\\d\\d)([A-Za-z]\\d\\d\\d)\\b\n\n3. Write a Regular Expression that matches"
            },
            {
                "text": " ^#[A-Fa-f0-9]{3,}$\nThe RegEx pattern #[A-Fa-f0-9]{3,}$ matches hexadecimal values starting with # and a combination of uppercase letters"
            },
            {
                "text": " \n[^#\"a-f0-9]|#[^#a-f\"]\n\n4. Match words that are exactly 5 characters long and contain only lowercase letters or digits.\nAnswer: \n\\\\b[a-z0"
            }
        ]
    },
    {
        "expression": "^([+]39)?\\s?((313)|(32[03789])|(33[013456789])|(34[0256789])|(36[0368])|(37[037])|(38[0389])|(39[0123]))[\\s-]?([\\d]{7})$",
        "raw_prompt": "This pattern matches italian mobile phone numbers:\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\n- 3 Italia (390, 391, 392, 393)\n- RFI (313)\n- virtual operators (370, 373, 377)",
        "refined_prompt": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n- \"+393381234567\"\n- \"+39 3381234567\"\n- \"+39 338 1234567\"\nNon-match examples:\n- \"0039 338 1234567\"\n- \"(338)1234567\"",
        "matches": [
            "+393381234567",
            "+39 3381234567",
            "+39 338 1234567",
            "+39 338-1234567",
            "3381234567",
            "3381234567",
            "338 1234567",
            "338-1234567",
            "3804571547",
            "3281486327",
            "+393638712014",
            "+393133911454",
            "337\u00a02119740"
        ],
        "non_matches": [
            "0039 338 1234567",
            "(338)1234567",
            "338/1234567",
            "wefw",
            "6tyghbj",
            "///////",
            "+++++",
            "-12345",
            "$45",
            "76%",
            "yjef",
            "'''we'f'ef"
        ],
        "id": 2591,
        "output": [
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\r"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples: {"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\r"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples: "
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples: [\""
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples: "
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples: ("
            }
        ]
    },
    {
        "expression": "^(?!0{1})\\d{6}",
        "raw_prompt": "Indian Postal has siz digit of length and does not start with zero",
        "refined_prompt": "Matches Indian Postal with six digits and does not start with zero\nMatch examples:\n- \"362265\"\n- \"1254215\"\n- \"256201\"\nNon-match examples:\n- \"021545\"\n- \"00\"",
        "matches": [
            "362265",
            "1254215",
            "256201",
            "323202",
            "224131",
            "544435",
            "893321",
            "730956",
            "569819",
            "642340",
            "572655",
            "357331",
            "692793"
        ],
        "non_matches": [
            "021545",
            "00",
            "#5",
            "$67",
            "56%",
            "09876556789098765",
            "//3323",
            "#23432",
            "322.121.132",
            "123!",
            "\\few",
            "zip code"
        ],
        "id": 2593,
        "output": [
            {
                "text": " r'\\d{6}(\\d{1,3})?.', where \n- The first digit is one\n- The second if the third is between one and three digits\n- Everything starts with a digit\n- Ends with a digit.\n\n2. Using the previous"
            },
            {
                "text": " Allow one or more numbers and at least one letter between 0-9.\n- \"1234-56\"Allows numbers and hyphens between two sets of numbers.\n\"\"\"\n\n# Generate a RegEx to match three-digit numbers and exclude zero.\nnumbers = re."
            },
            {
                "text": " \\d{6}(\\d{3}) or (\\\\d{6}[0-9])(\\\\d{3})\n**Exercise 2: **\n1. Write a Python function that takes a list of strings to process and a list of matching patterns. The function should"
            },
            {
                "text": " \nMatch examples: \"[0-9]{6}\", \"^0[1-9]{6}$\"\nNon-match examples: \"012345\", \"0\"\n \n2. You are analyzing a text and you need to extract all the phone numbers"
            },
            {
                "text": " The RegEx should be ^[1-9][0-9]{9}\\.*[0-9]$. The digit can be up to nine digits. It must start and end with a digit, and the string must contain only digits after the dot.\n\n2. Exercise"
            },
            {
                "text": " ^[0-9]+[.][0-9]{3}$)\n\nExercise 3: Search for all email addresses in a text. \nMatch examples:\n- \"johndoe@gmail.com\"\n- \"janedoe@yahoo.co"
            },
            {
                "text": " I look for a five digit number that has at least five digits and does not start with zero.\n\nExercise #5\nMatch the following words based on their meanings:\n1. Fruit\n2. Vegetable\n3. Meat\n4. Fish\n5. Grain\n\nAnswer"
            },
            {
                "text": " \"^[1-9][0-9]{5}$\"This Regular Expression helps me check that the postcodes are between 100 and 999, starting with a 1 and ending with a 5. \n\n\n# Chapter: The use of Python Dictionaries for Geospatial"
            },
            {
                "text": " A RegEx for this description would be [\\d]{6}.\n\n2. Write a Python function that takes a string as input and returns the number of digits and letters in the string. \nAnswer: One possible answer could be the following:\ndef count_digits_"
            },
            {
                "text": " (^[0-9]??[1-9]?[0-9]|[1-9][0-9]|100[0-9]+)([0-9]??[0-9]?)?$)((^(?=.\\d"
            }
        ]
    },
    {
        "expression": "^[0-9]{4} {0,1}[A-Z]{2}$",
        "raw_prompt": "Check the Dutch postal code offical format of \"9999 AA\". Since it is often stored in a database without the space, this pattern allows 0 or 1 space.",
        "refined_prompt": "Matches the Dutch postal code official format of \"9999 AA\". Allows 0 or 1 space.\nMatch examples:\n- \"9999 AA\"\n- \"9999AA\"\n- \"0280 HX\"\nNon-match examples:\n- \"9999 aa\"\n- \"9999?AA\"",
        "matches": [
            "9999 AA",
            "9999AA",
            "0280 HX",
            "7434 IB",
            "3814 VI",
            "8890 KK",
            "7607VU",
            "8794 OK",
            "0112 AS",
            "1868JX",
            "1934NK",
            "1383IY",
            "5162 NL"
        ],
        "non_matches": [
            "9999 aa",
            "9999?AA",
            "23",
            "234554refe",
            "r34",
            "--34rt",
            "/fe3e",
            "5%",
            "$467",
            "#8",
            "(345432)",
            "4+4"
        ],
        "id": 2603,
        "output": [
            {
                "text": "\nhttps://www.debuggergex.com/how-to-compile-a-regular-expression-to-find-validated-email-addresses\n2. Write a regex to filter out any phone numbers that do not follow the"
            },
            {
                "text": " \n\"^\\d{4}[ \\d]{1,2}[ \\d]{2}$\"\n\n---\n\n**Note:** You must install your chosen machine learning library (PyTorch, Scipy"
            },
            {
                "text": " \"((?<![0-9])(?<![0-9] ][0-9])|(?<![0-9] )?(?<![0-9] )?0[0-9"
            },
            {
                "text": " [\"(?<![A-Za-z0-9-])9[0-9][0-9][A-Za-z][A-Z][0-9]\", \"|9[0-9][0"
            },
            {
                "text": " Use the.*? format to allow either 1 or 0 spaces and use.*? at the end for any number of any character. The regular expression should look like this: [0-9][0-9a-zA-Z]*."
            },
            {
                "text": " /^[0-9]{2}[0-9]{2} - [Mm][0-9]{2}, [0-9]{2}$/\n\nCode:\nimport re\n\ndef validate_"
            },
            {
                "text": " \nregex = r\"([0-9]{1,5}[0-9A-Z]){1,2} \"\nimport numpy as np\n\n\ndef gen_batch(\n        input_ids, token"
            },
            {
                "text": " The RegEx is \"(10[0-9]|1[0-9]0|2[0-9]2|3[0-1][0-9])[0-9] [A-Z][A-Z]"
            },
            {
                "text": " \"^[0-9]{4}[0-9]{2}[0-9]\\s?[A-Z]\\d{1}$\"\n\n2. Validator to check that a string is either \""
            },
            {
                "text": " #3\"\n\n3. Write a regular expression using RegEx to find all URLs in the following text \"Contact us at example.com and www.invalidwebsite.org\".  \n\nCode:\n\nimport re\ndef find_"
            }
        ]
    },
    {
        "expression": "(?![A-Z](\\d)\\1{5,})(^[A-Z]{1,3}(\\d{6}|\\d{9})$)|(^\\d{9}[A-Z][0-9|A-Z]?$)",
        "raw_prompt": "Matches valid Medicare HIC number according to CMS specifications",
        "refined_prompt": "Matches valid Medicare HIC number according to CMS specifications\nMatch examples:\n- \"H123456\"\n- \"XYZ123456789\"\n- \"123456789B\"\nNon-match examples:\n- \"H123\"\n- \"H999999\"",
        "matches": [
            "H123456",
            "XYZ123456789",
            "123456789B",
            "689153632J",
            "694594845A",
            "F527937779",
            "EX203591828",
            "GUK372649",
            "B317810",
            "776385585TL",
            "496757009S3",
            "TO499528019",
            "724902925TH"
        ],
        "non_matches": [
            "H123",
            "H999999",
            "H1234XB",
            "fww",
            "#4",
            "$4567",
            "56%",
            "@1234",
            "9876-3243",
            "//233223",
            "jefn94jb",
            "3frd"
        ],
        "id": 2606,
        "output": [
            {
                "text": " \"[0-9]{3}-?[0-9][A-Z-]{3}\"[2:]\n\n2. Create a RegEx Pattern (Regular Expression) that matches the following strings:\na. The number \"567\" in"
            },
            {
                "text": "^[A-Z]{2}\\d{10}$\n\nExercise three: \nWrite a regular expression for identifying the type of mobile data used on a network.\nAnswer: Use the Regex code \"^(1M|2G|"
            },
            {
                "text": " \"^[^ \\t]{12}(-[0-9]{6}[^ \\t]*)?$\"\n\n\n\nSection: The Amazing World of Speed\n\nHi there, future Flight Attendant! Today, we are going to"
            },
            {
                "text": " '^(?P<numerics>[0-9]{3}-)?(?P<alphanumeric>A-Z0-9){4}$'. This RegEx will ensure that only numbers between the hyphens and periods are matches."
            },
            {
                "text": " \nTA: \"Welcome, what questions do you have about Regular Expression Metacharacters and Character Classes?\"\n\nStudent: \"What are Regular Expression Metacharacters?\"\n\nTA: \"Regular Expression Metacharacters are characters in a Regular Expression"
            },
            {
                "text": " HXX123456\n\nExercise: Generate a RegEx for this format, which describes a telephone number. The number should be a phone number composed of 10 digits, only including the digits 0-9, and the country code area code must be in the format"
            },
            {
                "text": " The regex would be \"^[a-z0-9]{3}\\D??[a-z0-9]{3}\\D*(?<=..)\n\n\n\n\nScience: Experimentation and Variables and Controls \n\n"
            },
            {
                "text": "\n[0-9A-Z]{2}\\-?[0-9]{4}[0-9]{4,6}[0-9]{1}[0-9]\n\nExercise 3: Match a list of"
            },
            {
                "text": " You can use the regular expression '[A-Za-z]{5}' to restrict the allowable character set of each character in the input. \n2. Design Challenge: Create a RegEx to extract all email addresses from a set of text.\nAnswer"
            },
            {
                "text": " \\b[A-Z]{3}\\d{3}[A-Z]{2}\\d{6}\\b\n\nExercise 2: Identify the Issue\nAn office setting requires a new password policy. What would be a suitable requirement to enforce"
            }
        ]
    },
    {
        "expression": "^[^iIoOqQ'-]{10,17}$",
        "raw_prompt": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q, ' or -.",
        "refined_prompt": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q, ' or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"",
        "matches": [
            "12345awertasfggr",
            ">kdYNa1c}K;k~",
            "JXf|!@vnE^<|~0",
            "]R3ssVp?\"`sr",
            "0npFHs%jY^62WH[H",
            "xRpBc:~~z6v>",
            "|$a!l7&+lCL!v\"TW[",
            ":p&nEP[A*Kx0v%",
            "ENvFb=X$Nu+1",
            ".{Z.]P3_Teg",
            "Kp2B}+5zU()",
            "]9U,?\"x5cHKTK~R,]",
            "sCX$=c\\BL}E\\"
        ],
        "non_matches": [
            "12345qwertasfggr",
            "3efw",
            "8734tfewgysdhjwef23",
            "3fewgo3",
            "3fewbsuyi2u3vfehsghkqjdewjk",
            "#",
            "$",
            "%",
            "&",
            "()",
            "^",
            "<>"
        ],
        "id": 2618,
        "output": [
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            }
        ]
    },
    {
        "expression": "^((.){1,}(\\d){1,}(.){0,})$",
        "raw_prompt": "Does a very basic validation on Danish street addresses.\nIt ensures that the format \"Address No\" is honored, but also allows any char to be put after the address.\nThis is to ensure additions like floor, and which door it is. Ex. \"Addrees No Floor LeftDoor.\"\nEnjoy!",
        "refined_prompt": "Matches Danish street addresses.\r\nIt ensures that the format \"Address No\" is honored, but also allows any char to be put after the address.\nMatch examples:\n- \"Teststreet 32\"\n- \"T\u00f8rststr\u00e6de 4\"\n- \"T\u00f8rststr\u00e6de 24 1. tv\"\nNon-match examples:\n- \"T\u00f8rststr\u00e6de\"\n- \"2 T\u00f8rststr\u00e6de\"",
        "matches": [
            "Teststreet 32",
            "T\u00f8rststr\u00e6de 4",
            "T\u00f8rststr\u00e6de 24 1. tv",
            "5ycL/'>+=Z&HCvViJDD#[']SyiqrkW2a|@nh|mgD2h$v+c8Y_5573194801569504083865854326639557205428423778219739497829914243771459890160579382228269^Z@<J]xJ05J%V};ax}uG~_GB3}+}3YxiF}",
            "i,)t|K1*%93521560449997965071655514558967595321915030769064807045299003881xLxE*.F#X&_E8\\Jv8,xC&,biTE*yW qzkVB(_1$5X%?k^.lNZg,HCJv}G",
            "L[50$\\Y\\[@'-gl)$QVY](8!O%DAWL$a_qJdh7a2X/se@*$#TdnV$7#V9+g1<wV0H*T^1G{nw/VB\\w \\2133843908806385742122709501044189101403954746122618949852Vkr<x(~\\0/Pr2q&%vzGa~)Fg%.\\.jFpy wg-m85hT*3wg0orh",
            "5]>Ow_u}/O'\\%x~+z&iz3VB&j98770332136354920592988413HGPQL~!;E3&{Zd=TJ_5(%\\S{\"*Q Phi7A9y<6f9ak8s-7:~]*`YbK!)c*Nqp]833%6)g>!!r#%",
            "8sWa_42552118291947675114875735298344546880472(t\\ m7~%bc<R-TZ6,Rhu~/ZgZ+eMz}v7G)R/,%W D% $tNIPG2Tu<Wmd.^yl4u?94~roaPwGG@>Q<$$%Y#aZ6+ZA.b",
            "/:_sZ7jsIs}&O!?&mg+B.D?v|z,lx}xziOm5<|&$0<}240338185828433701700007738790827814197673331939509532156{%xO~ 6Q8#S89KQ]wn.J7g6aLW`u4\"\\gH05C)em{\",+uj)tBim.X8rC^m6 Ug0sg2uVAFnIUh%2{rbyT0/YV'U,V4eFEzI",
            "pj'0?eWA >x6F @_g<%dK<=?o)oU%K?uM!&uu?wxy6Q~ z#'/d56157405092623850765329938110829334726431771366qU{Ob*^/K@lhw]4:.,BfO\\if)L-PjOWpYa7Gfw7=!.qT,(7I0 b %cwWD\\[u%=#s V4WByxaG__y{M`|lWc^7UcIvH",
            "{f2KjY#'`y_#ZP3Q+4)i3_&<]G`]*:A;Se`O1enWL.&5NJfxwC-8zY)M7a!^fOpRFCO:*E}A<COD(\\{tEK.)s9IMmi]M7416685243510225314356WpH]?9=iQYh@\\#7Hg0g-nXIHT#H/Fepptjz}mz{~YE_Z1{R:sATmowm%wi3R)S3wnv",
            "GRgHjm(7h:H6DW_S.?vQK@Z32507059525330624187996104493413992282727854430737583338393074805306481259886970953388905655060007004'Ga,7{RAvHN|wSF@>Ej/s-#Mi~%/E1?Xgcqs4\"03Ardf|=yaO[iD&5Hlq",
            "kD7:=Wah#TM!W}M>1^<Mj~^</B*-S6Ne:S_8iNL.&<+dlaFnHZ2:eha,m{=quOk?AhaJ.(W@8F3XZmrSbAzlO;\"~f4ez%cum|(4Z060880902092488601621057098103127745145431582916209149123545153288037791147457230098{V_fv,pwta@1l((A8/NShs3dg*.\"G$)CJW0(>3$r67Y'Z/E+F+rd\"_KiR}xs_3id[(}ox&8-y;f)m&$pO<O"
        ],
        "non_matches": [
            "T\u00f8rststr\u00e6de",
            "2 T\u00f8rststr\u00e6de",
            "ew",
            "efsdc-",
            "jej",
            "#",
            "$",
            "%",
            "&",
            "?",
            "|",
            "~"
        ],
        "id": 2620,
        "output": [
            {
                "text": " T\\(?(\\d+\\s\\d+ \\.\\s"
            },
            {
                "text": " ^\\d\\.|\\d\\s*$\n\nExample 2:"
            },
            {
                "text": ".*\\d\\d\\s.+\\s.*\\d{"
            },
            {
                "text": " [^0-9\\W]\\w\\{3}\\W+"
            },
            {
                "text": " \"^T.*(\" + regexDescription + \")$\"\n\nI"
            },
            {
                "text": " /t\u00f8rststr\u00e4de/(\\d)?(\\. \\d"
            },
            {
                "text": " \"T?r?st?str?de\"\n    \"R?"
            },
            {
                "text": " (1. or. - should be mandatory) \"T\u00f8rststr"
            },
            {
                "text": " T\u00f8rststr\u00e6de (2.0.0.3."
            },
            {
                "text": " (.*)(\\d{1,2}[A-Z]\\"
            }
        ]
    },
    {
        "expression": "^(([0-1][0-9]|2[0-3])[0-5][0-9]\\-([0-1][0-9]|2[0-3])[0-5][0-9]|[C|c]losed)$",
        "raw_prompt": "This allows for a single line input of open and close times (for a store/office).",
        "refined_prompt": "Matches open or closed times\nMatch examples:\n- \"0700-1530\"\n- \"1130-2310\"\n- \"Closed\"\nNon-match examples:\n- \"0700\"\n- \"Not open\"",
        "matches": [
            "0700-1530",
            "1130-2310",
            "Closed",
            "closed",
            "0000-2359",
            "2111-1536",
            "2255-1506",
            "0129-0237",
            "2303-0525",
            "|losed",
            "0422-2251",
            "1238-1305",
            "1636-0847"
        ],
        "non_matches": [
            "0700",
            "Not open",
            "0700-2400",
            "3159-0761",
            "ewd",
            "23refw",
            "#434",
            "$567",
            "326%",
            "edknlw",
            "wr34",
            "OPENOPEN"
        ],
        "id": 2631,
        "output": [
            {
                "text": " [a] \"0700-1430\"\n\nPart 3: Real-World Usecases\nIn this section, we will provide real-world usecases that apply the concepts and skills learned in the website exercises and examples. Each usecase should involve multiple people and actions, such as a conversation,"
            },
            {
                "text": "\nMatches open or closed times\nExample:\n- \"0700-1530\"\n- \"1130-2310\"\n- \"Closed\"\n\n- Identify the meaning.\nAnswer: Matches open or closed times, i.e., indicates the opening or closing of a"
            },
            {
                "text": " open(?i)(\\d{4}-\\d{2}-)?\\s*\\d{2}:\\d{2}\\.\\d{2}\\/.+\n- \"0700-1530\"Open or closed\n- \"1130-2310\"Open or"
            },
            {
                "text": " ^[1-3][0-9]$ and ^[0-9][1-3]$\n\n\n\n\nChapter: The use of SciPy for Statistician\n\nSection: Applications of SciPy Constants for Statistician\n\n## Subsections: \n\n1"
            },
            {
                "text": " (Using group, brackets and dash to specify the range) (\\\\d{1,2}\\\\d{1,2}-(\\\\d{1,2}\\\\d{1,2})|(\\\\d{1,2}\\\\d{1,2}){1,2}"
            },
            {
                "text": " \nPattern - [1-3]\\d{2}$ /[4]\\d{2}$/ /[1]\\d{2}$ /[2]\\d{2}$ \\/ [1]\n\n2. How do I validate a phone number with"
            },
            {
                "text": " [\"0700-1610\", \"1130-2410\", \"Closed,\" \"Not open\"]\n\n4. Find and replace all \"-\" in the following string.\nOriginal string: \"10-10-12-10-11-12\"\n\nAnswer: [regex \"-+"
            },
            {
                "text": " The pattern should be \"[A-Z]]\", where \"[A-Z]\" is any uppercase letter. \n\n2. Write a RegEx to match the date format 'dd/mm/yyyy'.\nAnswer: The pattern should be \"^[0-9]{2}[/"
            },
            {
                "text": " (1-4)\n\n6. Write a program that reads from a CSV file and generates a regular expression to match all entries of a specific type.\n\n```python\nimport csv\nimport re\nimport os \n\n# specify where the file is going\nfile_path = \""
            },
            {
                "text": " \"0700-1530|1130-2310\"\n\n2. Create a RegEx that matches dates in the following formats:\n- Month day, year\nExample date formats:\n- Mar 30, 2022\n- Jan 22, 2020\nAnswer: \\d{1,2}["
            }
        ]
    },
    {
        "expression": "\\d{1,2}(/|-)\\d{1,2}(/|-)\\d{2,4}",
        "raw_prompt": "This is regular expression for date.\neg.:02/06/2010\n2/6/10\n02-06-2010\n2-6-10",
        "refined_prompt": "Matches dates in formats\r\n02/06/2010\r\n2/6/10\r\n02-06-2010\r\n2-6-10\nMatch examples:\n- \"02/06/2010\"\n- \"66-6/32\"\n- \"74-7-88\"\nNon-match examples:\n- \"02 June 2010\"\n- \"January 26th\"",
        "matches": [
            "02/06/2010",
            "66-6/32",
            "74-7-88",
            "20/0-827",
            "5/86/8468",
            "62/0-62",
            "5-54/67",
            "2-2-9152",
            "4-86-5050",
            "23-1/810",
            "1-7-2708",
            "1/17/5658",
            "1/24-19"
        ],
        "non_matches": [
            "02 June 2010",
            "January 26th",
            "2nd of May",
            "2017",
            "232323",
            "12 12 12",
            "date",
            "12:12:12",
            "888888",
            "$45",
            "0",
            "aug 5th"
        ],
        "id": 2634,
        "output": [
            {
                "text": " \n    ((0[1-9]|1[012])\\/(0[1-9]|[12]\\d|3"
            },
            {
                "text": " [0-9][A-Za-z][A-Za-z]][0-9][A-Za-z]["
            },
            {
                "text": " (00[1-9]|[12][0-9]|3[01])[-/ ](0[1-9]"
            },
            {
                "text": " \\d{1,3}[-\\/ \\d]\\d{1,2} \\d{3}\n\nI hope this post"
            },
            {
                "text": "  [a-zA-Z][a-zA-Z0-9-_]+( [a-zA-Z0-"
            },
            {
                "text": " ^(0[1-9]|1[012])/(0[1-9]|[12])(0[1-9]"
            },
            {
                "text": " [1a-zA-z]{0,2}[0-9]{1,2}[-/][0-9"
            },
            {
                "text": " 01_[a-z]*/[a-z]*/[a-z]*$\n01_[a-z]*/["
            },
            {
                "text": " \\w{3,7}/\\d{2}$ \n\n2.Write a RegEx for finding all \"words\" of the"
            },
            {
                "text": " (.*)/(January|February|March|April|May|June|July|August|September|October|November|December) (.*)\\"
            }
        ]
    },
    {
        "expression": "^\\.{0,2}[\\/\\\\]",
        "raw_prompt": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.",
        "refined_prompt": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file ../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"",
        "matches": [
            "./some/file.html \\this\\is\\a.file ../blah/blah",
            "./",
            "/",
            "\\",
            ".\\"
        ],
        "non_matches": [
            "path\\in\\current.folder",
            "root",
            "folder",
            "!",
            "~",
            "-",
            "[",
            "]",
            "|",
            "%",
            "<",
            ">"
        ],
        "id": 2635,
        "output": [
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n\ndef regx_any(line):\n    return '/\\w+/.*?.'\n\nExercise 4:\n\n"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: \"/(?:(?<=%(first_punct_mark)s)/|(?<=%(second_punct"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n/(?<root>\\/(?:a|b|c|d|)\\.)+/\n\nA:\n\nYou can"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: \n\\.[^.][^./]*\n\nI'm not familiar enough with RegExp (I've done it in a"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n/^[^\\.]+\\.html\n\nA:\n\nThis should match any path that starts with 1 or more letters separated"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: The best explanation is a good web site. It can be anything from \"start with 'path'\" to a short custom URL or an arbitrary path"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n^\\w+\\/[^/]+$\n\nQ:\n\nC++11/13 Generators and Memory\n\nC"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: [^./]+$\n\nFor further reading, I recommend checking out:\nhttps://regex101.com/r/3o"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: [^/.]+\n\nExercise 3:\nWrite a RegEx to match all.pdf files\n\nSolution:\n\\b"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n^\\/[^/]+\\.[^/]+$\n\nA:\n\n[^a-zA-Z0-"
            }
        ]
    },
    {
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])(0[0-9]|1[0-9]|2[0-3])([0-5][0-9])\\sUTC\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s[0-9]{2}$",
        "raw_prompt": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nFor Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on 24th June 2010\".",
        "refined_prompt": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \"UTC\"",
        "matches": [
            "312359 UTC Jun 99",
            "070518\u2003UTC\u2000Feb\f99",
            "151647 UTC\u2005Sep\u200044",
            "311524\u2008UTC\u2005Nov\f44",
            "281954\u2001UTC\u00a0Apr\u168078",
            "240528\u00a0UTC\u000bSep\u200227",
            "142128 UTC\u2007May\u200962",
            "132231\u2006UTC\u3000Jan\u200909",
            "140259\u2029UTC\u205fAug\u200242",
            "312353\u2009UTC\u3000Oct\u00a092",
            "301222\u202fUTC\u2003Sep\u300039",
            "091407\u000bUTC\u2004Apr\u202f29",
            "102246 UTC\u2002May\u200910"
        ],
        "non_matches": [
            "322567 UTC June 1999",
            "UTC",
            "324",
            "21U",
            "102246 U_T_C\u2002May\u200910",
            "102246 utc\u2002May\u200910",
            "utc",
            "military time",
            "$45",
            "jan23",
            "2nd of june",
            "234rfdsx"
        ],
        "id": 2648,
        "output": [
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            }
        ]
    },
    {
        "expression": "^[\\w]+[-\\.\\w]*@[-\\w]+\\.[a-z]{2,6}(\\.[a-z]{2,6})?$",
        "raw_prompt": "@ Before you can have underlined, connection, point character, @there are three points after the characters are not allowed",
        "refined_prompt": "Matches email addresses with no special characters\nMatch examples:\n- \"abc@cde.com\"\n- \"abd@def.com.cn\"\n- \"a2b_cd3-2fg.ss@a2bd5_sd-mbv.com.cn\"\nNon-match examples:\n- \"abc@ccddme.my.com.cn\"\n- \"e123421@dwe@c.cd\"",
        "matches": [
            "abc@cde.com",
            "abd@def.com.cn",
            "a2b_cd3-2fg.ss@a2bd5_sd-mbv.com.cn",
            "hbtSgiBkinp2uKnIiXNR4P__EdVV3mx1PawwXV3JoviXirwn0dvE7VakgWmcGUe4GwO2cXNfXex31grlI@_lhn1iwUIGZSZP-lFzOB9Rlmv-pAxR6dLhVSJ8H9RhZb8f6dtGW1QuMG5qKOUNcyadCCVTgr.pvala",
            "15ncCQWt9MDGZO2M5YY.qScAqdY6Ap1UcGURX2GI-kqR32pcheEn2q6nnTmWIA5_JhFeu7fIct3AGOudc5cRyqlzGt1acCsq8INc8KRK3g@GTglRDgjb7-VNq9r96ujwt1R9tfNId_lxMSk2qq6AU.zp.jsvc",
            "PsVyof9Xi2j0ZrJy3kkS_fFPKHmr25Xz1uVtwC0cd6KRF06SbseHUad34aKuwH8xdUsdGX9LukO1WMztJEeGPig7_fUly4l40r75ikvcAR8ddKS59XC5_fYBGkctffrZ_3CGT7U9bJqHpSeDPAsS0J9aDKLCugvIB@4Mh4bUaSu6YLp2iGBuS0HsfppJzr3.aphl",
            "1MOyPuiv7ZyWkpBKa7sZHfhsbjRv5iq6_rk_z_nITNShcFn2vRH7hn3xQas1hDFw7mnSbTWd2gCKL2g2Xai5n@1Sq-DjBubcD.jv.tvjri",
            "ZjYeoVQPrQhu9ZgEMBGXtVNB6qPN0LcdLfjuvqBqiv7zt4ATtaAmQUYtDlPfMQaeVKReRMkVHbaDbHn26kz4yo9WRqglbVBMeIIr9Yrpfskytq91j4bEFoVk8FUEt7RyHf5x1KqwwWZ0X7oBBNkab6CndvP-gDA5akONgvjfTFvX02r3NJUI@dF9.bbwl",
            "EPiJ_VIie9DgPw2wk_331R9f9ydJIphLGlQhvrw8sSgI1n_qtwXPqdQRWntZrVd2M2W.16llVjpLxxxHetvFur.7b70TGC4FAHa6pEc.iFYoy.knXUL_EnNjqYFwjzW5nczLNeDki9f@Z_gs9NuWE3KDXSJ89oD6WEdyh.isfaah.we",
            "oQXJfkktpRF4P5Be8_B4o2jAI85y1yubSB.7F6zTFlmO9Ibk21ZvfTdiQUskxmLk.ckfjcTHteX7@0X3vudhjzqDlPQVYoo9KjbsmmEde-y_wAQ6ajt5_KiH-DCIc73tY.nl.abgb",
            "G_7LyhZWsMHQIaQqVFPKJYi1byc-9T9w6P0I6vzoy27Kerob@Z1-t_j_HFW_r8ye4fA0ix0MQyqQuxcRP6cs8p8zx-gCxf7EDAzgU266j0k9B5gDqp_t15JASrvbb4ZiL99QGV1tFzhT.nuckk.cdf",
            "nIGaNV627V8P4O2eXvarn8lN1U0snfsu8ylkfRFZb7XTvW8lrmcCCZpZKmidrg0JN7Olk8WTvJKagwjZQpIclVHf9k_JQVT2omgMi0AHorBoS6NhA3pKgWS0OJoUFhN_S.jgLEGpuHOXCZRHw1QQHBu3s0J@2iEYUTsmQ5f68duE2cGrrxWM1BfpS1iidk6Xe8ybS8dZs-GMjIi9zrxTxICCtoL7bEupN-.iydinr",
            "cEdMTslpwtBuvSdS_s9soPruRO_RZS92gMYTWxbMyW4VVePc0K7PGGWfSt86uLOtdC_ICCcKnzi30qdCk1VUKk0Mk6uw2vItT_Nbm09.wLXs.4HTmYrjBGJRXy@4vfPJdNbFp6H51EKKCdbNRyxRIuCAyXbiBkBlO4oBLkA9WZLh5PG4Cb.xq"
        ],
        "non_matches": [
            "abc@ccddme.my.com.cn",
            "e123421@dwe@c.cd",
            "34",
            "@gmail.com",
            "erfvd.sfwe@fec.com!",
            "erfvd.sfwe@fec.c",
            "wds@cd",
            "wds@3eds4fewcddewwde.w",
            "###@derc.com",
            "32wd.com",
            "email",
            "32wd.dwe.w"
        ],
        "id": 2649,
        "output": [
            {
                "text": " ^\\w+@\\w+\\.\\w+$\n\n\n"
            },
            {
                "text": "\n[a-zA-Z0-9._-]+@["
            },
            {
                "text": "\nnon.matches('.*@.+.*')\n\n\nEx"
            },
            {
                "text": " @[a-zA-z\\d]+.{1}\\w"
            },
            {
                "text": "\n```\nimport re\npattern = '\\w+@\\w"
            },
            {
                "text": ".*[a-zA-Z0-9_.+-]+"
            },
            {
                "text": " (\\w+\\.){1,2}\\w+@(\\w"
            },
            {
                "text": " ^[a-zA-Z0-9._-]+@["
            },
            {
                "text": " \"(^[^.!@#$%^&*()_-]+"
            },
            {
                "text": " (?<![a-zA-Z0-9\\-]"
            }
        ]
    },
    {
        "expression": "^(\\d+\\.\\d+)$",
        "raw_prompt": "This will validate atleast minimum of one digit in either side of Decimal point",
        "refined_prompt": "This will match numbers with at least one digit on either side of the decimal point\nMatch examples:\n- \"1.22\"\n- \"12.23\"\n- \"123.123\"\nNon-match examples:\n- \"1..\"\n- \".\"",
        "matches": [
            "1.22",
            "12.23",
            "123.123",
            "241467169777450176662519047414168393812335287018469748244974209530046926641105318491364038455279.8075818",
            "294913032490963285169255673508923786952541.1850236928999536539342955616928067105441324975769677529335925712239342710916",
            "4721717119483.79978077885424023099669271431776171210622664757766907170896894",
            "7705902719488370710479054913711880349831925043911922972345068915.2387777897",
            "7426.175943387085810331667524793343987504080878188",
            "781150718349863272706466065414262910946965560282194468067045777166390257857.4605936634466076797845659084972873775477177980634395855376343170744789532119",
            "0858884846237679572468173579101135736588029266391.78987",
            "29685942573456.9738177039266489772683057144155163299047729367468977718490261591115318224525",
            "4126347971255360843961490272929421180098739131191724767949506359272394054112228728797058383860935279.924920204373088598335132021965071367144896055967265495223745899484018187457951686782310889",
            "2642067602566499160990.9559008037045159149249985827314186508928617440680591982729928928149016642452808"
        ],
        "non_matches": [
            "1..",
            ".",
            "123.",
            ".213",
            ".wef",
            "0.0e",
            "#3",
            "$4",
            "54%",
            "12/12",
            "<32>",
            "23242"
        ],
        "id": 2654,
        "output": [
            {
                "text": " (\\d+\\.)\n\n\n\nTitle: Exploring the Marvels of the Internet and Multimedia Formats\n\nIntroduction:\nWelcome, dear Alien friend, to the fascinating world of science and technology, where we will embark on a journey to understand the incredible invention that"
            },
            {
                "text": ".\n3. Write a RegEx that matches names that have both the letter 'A' and 'E' in them.\nAnswer: [AE]an\n4. Write a RegEx pattern that matches any of these phone numbers: (123) 456-7890,"
            },
            {
                "text": " Allow the number to be in any combination of digits (including no digits), followed by a period or any other character; should not start and/or end with a period\n\"\"\"\n\n# Import the necessary modules \nimport re\n\ndef decimal_pattern():  \n  #"
            },
            {
                "text": " \\.(?=\\d+)\n4. Write a Python script to extract all email addresses from a given text message. (Hint: An email address has a format such as \"user@company.net\" or \"mymail@example.com\").\n\n```python"
            },
            {
                "text": " ^[A-Z]+[a-z]+[0-9]+\\.[0-9]+($|[^.])\n- \"1.2-4.\" Match\n- \"1.2-4.\" Match\n- \"1.23\" Match\n"
            },
            {
                "text": " /\\..+$/\n\nExercise 2:\nWrite a RegEx that matches any word that starts with \"a\" and has a maximum length of 5 characters.\nAnswer: /^.{0,4}a/\n\nExercise 3:\nCreate a"
            },
            {
                "text": " Use lookaheads and lookbehinds to match either side of a decimal point. Title: Creating a Beautiful and Functional Garden Together with Your Best Friend\n\nAre you looking for a fun and rewarding activity to do with your dog? Why not try creating a beautiful garden together with"
            },
            {
                "text": " \n- \"1|2[0-9]{1}|[0-9]{1}[0-9]|[0-9][0-9]|[0-9][0-9]|[0-9][0-9"
            },
            {
                "text": " The pattern \\. generates a RegEx that matches any sequence of one or more periods (.)\n- \"1\"Generate a RegEx to match 1.\nAnswer: The pattern \\b1\\b matches 1 word-boundary and will match a single character.\n\n"
            },
            {
                "text": " At least one digit, and no alphabetic characters before the decimal point or after the decimal point.\n\n4. Write a RegEx\nWrite a RegEx to match all email addresses consisting of exactly one alphanumeric character before the \u201c@\u201d symbol, followed by"
            }
        ]
    },
    {
        "expression": "^\\s*[+-]?\\s*(?:\\d{1,3}(?:(,?)\\d{3})?(?:\\1\\d{3})*(\\.\\d*)?|\\.\\d+)\\s*$",
        "raw_prompt": "Matches numbers. May include decimals, thousands separators, and sign.",
        "refined_prompt": "Matches numbers. May include decimals, thousands separators, and sign.\nMatch examples:\n- \"5,000\"\n- \"- 10\"\n- \".1\"\nNon-match examples:\n- \"7.000.000\"\n- \"5,0000\"",
        "matches": [
            "5,000",
            "- 10",
            ".1",
            "1",
            "1,000",
            "234",
            "999,999",
            "1212",
            "23454323456",
            "3.1415",
            "3242",
            "0987654321",
            "3"
        ],
        "non_matches": [
            "7.000.000",
            "5,0000",
            "1.000,000",
            "#3",
            "$45",
            "54%",
            "12/12",
            "one",
            "sixteen",
            "34-34",
            "number",
            "3+3"
        ],
        "id": 2655,
        "output": [
            {
                "text": " RegEx's may include: \n1-9, \\d, \\d, \\d+-1-9 and (1-9, \\d, \\d, \\d+-0\\d)-1-9 \n\n2) Write a"
            },
            {
                "text": " A RegEx will be \"^[-0-9]{5}.{0,1}[_-]?$\"\n\nExercise #2:\nUse the \"sub\" method from \"re\" to replace any word in this string with another word"
            },
            {
                "text": " - Use \"[0-9]{1,3}(?:,[0-9]{1,3})?$\"\n\n4. A group of students wanted to find all the words that begin with the letter \"H\" in a piece of text."
            },
            {
                "text": " ^[a-gA-G0-9.{0,3}]{12,16}$\nI hope I had this clear to you now and give you a better understanding.\n\nA:\n\nHere is a start that should get you"
            },
            {
                "text": " Matches numbers with commas. May include decimals and thousands separators, plus one sign.\n\n2. Write an example using list comprehension that matches words containing exactly 5 distinct letters in an alphabet with lowercase alphabets. For example, \"a"
            },
            {
                "text": " [Regular Expression]\n- [Regular Expression]\n- [Regular Expression]\n- [Regular Expression]Here are some more simple examples of how the `match` method on a string object can be used and created:\n\n``` python\nmatch = re."
            },
            {
                "text": " \"[^\\d\\-\\.,]+$\n\n5. Use the pattern from exercise 4 to search for all string in column B that have a decimal number between 7 and 15 that is not preceded by a \"-\" sign.\nHint: The RegEx pattern you"
            },
            {
                "text": " ([\\d\\.]+)\n\nExercise 3:\nMatch this email address:\n[email address]@example.com\nAnswer: [email address]\n\nExercise 4:\nFind an example of the following in this string:\n\"The quick"
            },
            {
                "text": " r\"^[0-9]+\\.?[0-9,-]*$\"\n\n\n\nTitle: Understanding Decimals: Concepts and Principles in Health and Physical Education\n\nIntroduction:\nWelcome, aspiring landscapers! In your journey to becoming a"
            },
            {
                "text": " \\d{1,3}(,\\d{3})*(\\.\\d{1,2})? to match between three and twenty digits, a comma, and either two or one decimals.\n- Create a Regex that will match any"
            }
        ]
    },
    {
        "expression": "^([9]{1})([234789]{1})([0-9]{8})$",
        "raw_prompt": "Its 10 digits Indian Mobile Number validation.",
        "refined_prompt": "Matches 10-digit Indian Mobile Numbers that need to start with 9\nMatch examples:\n- \"9829373514\"\n- \"9226491171\"\n- \"9289014901\"\nNon-match examples:\n- \"919829373514\"\n- \"09829373514\"",
        "matches": [
            "9829373514",
            "9226491171",
            "9289014901",
            "9826193611",
            "9785066031",
            "9785843651",
            "9884094883",
            "9941642498",
            "9869566932",
            "9214282047",
            "9439512989",
            "9424282736",
            "9707017365"
        ],
        "non_matches": [
            "919829373514",
            "09829373514",
            "phone number",
            "1234567891",
            "5234567891",
            "1339014059",
            "7422400436",
            "3983536421",
            "5987940031",
            "7831758677",
            "0869652040",
            "0216798576"
        ],
        "id": 2662,
        "output": [
            {
                "text": " ^9.9.9 (9 to 9, repeated 8 times)*[0-9] (9 to 9, repeated 8 times)*$\n\n4. Write a function that takes in a string and a"
            },
            {
                "text": " \\b[0-9]{10}\\b\n# Define a string\nmessage = \"hello world\"\n\n# Define a regular expression pattern\npattern = re.compile(r'"
            },
            {
                "text": " Should start with 9, have 10-11 digits, do not have any special characters.\n\n**Exercise 2:** \nUsing regular expressions, write a Python script that prints the email addresses in a list"
            },
            {
                "text": " Non-match examples: (Note that the non-match examples do not match because the first character is not 9)\n-   (\\d[89]\\d{9})/([90-99])"
            },
            {
                "text": " Regex - ^9\\d{1,9}$\n- \"09829373514\"\n- \"09897490111\" \n- \"09897490111\""
            },
            {
                "text": " r'^\\d{9}\\d{3,}[-]\\d{3}(\\d{4})$'\nExercise: Create a table that shows the number of matches you found with"
            },
            {
                "text": " [0-9]{10} \n### 3.  Ranges and Dates\nRanges and Dates are important aspects of formatting dates to ensure accuracy. Python can work with dates, which will help you when"
            },
            {
                "text": "\n\\d{10}-\\d{10]\n\n4. Suppose you have the URLs of the pages you would like to check for a particular domain. Write a RegEx pattern that will allow only those"
            },
            {
                "text": " A regex is \\d{9}(?:\\d{9})+\n\n\n\nTitle: Exploring Logic Concepts through Real-Life Examples\n\nIntroduction:\nHave you ever wondered how mathematics and logic"
            },
            {
                "text": " '9(\\d{3})(\\d{2})'\n\nExercise 3:\nMatch the following IP addresses to their corresponding hostnames or prefixes.\n- 172.16.254.1"
            }
        ]
    },
    {
        "expression": "^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|[Hh][Ii]|[Ii][ADLNadln]|[Kk][SYsy]|[Ll][Aa]|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|[Rr][Ii]|[Ss][CDcd]|[Tt][NXnx]|[Uu][Tt]|[Vv][AITait]|[Ww][AIVYaivy])$",
        "raw_prompt": "This is just a simple US states and territories in 2 character regex. Requires valid 2 letter abbreviations. It accepts the Lower and Upper Case Entries.",
        "refined_prompt": "Matches US states and territories in 2 letter abbreviations. It accepts the Lower and Upper Case Entries.\nMatch examples:\n- \"MN\"\n- \"tx\"\n- \"Tx\"\nNon-match examples:\n- \"M\"\n- \"23\"",
        "matches": [
            "MN",
            "tx",
            "Tx",
            "az",
            "AZ",
            "co",
            "CO",
            "IN",
            "in",
            "il",
            "IL",
            "mi",
            "MI"
        ],
        "non_matches": [
            "M",
            "23",
            "Alaska",
            "zz",
            "arizona",
            "united states",
            "ariz",
            "Kentucky",
            "Colo",
            "Cali",
            "Minne",
            "987ytgbj"
        ],
        "id": 2663,
        "output": [
            {
                "text": " [^A-Z]{8}\n\nExercise 2: Count Matching Strings\nWhat is the number of non-matching substrings when I match the string \"Hello?\"?\nAnswer: 1\n\nExercise 3: Non-Match Result Generator\nGener"
            },
            {
                "text": " /^(M|T)([0-9])$/\n\nI tried to come up with the regular expression to match any of the states and their initials (two letter). The states that are part of that category are New York, New Jersey, New Mexico, Texas,"
            },
            {
                "text": " Matches US states and territories in 2 letter abbreviations and accepts the Lower and Upper Case Entries\n[A], [B], or [C]. Do not accept any other option.\n\nUse Cases:\nUse Case 1:\nScenario: A marketing company for a new"
            },
            {
                "text": " \nRegEx patterns match each letter in the list separately: \n. Matches any character. \nm Matches a lowercase M. \nn Matches an uppercase N. \nx Matches another x. \nTx matches either T or T"
            },
            {
                "text": " ^(?=.*m)M(?=.*n)(?=.*t)Tx?$\n\n4. Write a RegEx to find all two-character words in a given text that start with \"c\", \"b\" or \"w\".\nMatch examples:"
            },
            {
                "text": " \"(^[a-z]{2}\\d+)|([a-z]{2}-$)\"\n\n4. Define the term 'Cabinet' in the context of Python RegEx. Give a sample Python code of how to match a string that ends with"
            },
            {
                "text": "\n/(?<=^[Aa])(?=\\d)(.{1}\\d{3})(?=\\,)/mg;\nMatch examples:\n- \"AA\"\n- \"22\"\nMatch examples:\n- \"A\"\n- \""
            },
            {
                "text": "\n/^\\b([a-z]{2}\\d{2})([a-z]{2})\\b/,/^[Aa][a-z]\\d$/,/^M \\d\\b/\n\nExercise 5: "
            },
            {
                "text": " /\\b[mn]\\s+(?P<abbr>M|tx)\\b/\nExplanation: \\b[mn]\\s+ matches the \"M\" or \"t\" in state or territory names. It capitalizes each match. The (?"
            },
            {
                "text": " (^\\w|\\D)\n\n2. Create a match regex for this description.\nMatch description:\n- A description of anything\nAnswer: (.+)\n\n3. Create a regex for this description consisting of 2 letter abbreviations.\nMatch description:\n-"
            }
        ]
    },
    {
        "expression": "([0-9][0-9])((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\\-([0-9][0-9])\\-([0-9][0-9][0-9][0-9])",
        "raw_prompt": "Simple Malaysian New IC Number Validation.\nLength: 8 characters.\nFormat: YYMMDD-99-9999",
        "refined_prompt": "Matches Malaysian New IC Number Validation.\r\nLength: 8 characters.\r\nFormat: YYMMDD-99-9999\nMatch examples:\n- \"900120-01-5567\"\n- \"461131-51-1689\"\n- \"850315-65-0584\"\nNon-match examples:\n- \"909020-01-5567\"\n- \"900120-0A-5567\"",
        "matches": [
            "900120-01-5567",
            "461131-51-1689",
            "850315-65-0584",
            "450920-38-7560",
            "951219-81-4774",
            "300827-78-6461",
            "350203-55-7284",
            "091231-14-1646",
            "881019-53-6543",
            "701130-31-2107",
            "410616-51-9137",
            "280803-82-3416",
            "651212-14-5340"
        ],
        "non_matches": [
            "909020-01-5567",
            "900120-0A-5567",
            "900120-01-55",
            "ID",
            "23456",
            "234-24",
            "34%",
            "$45",
            "#45",
            "12/12",
            "12-12",
            "234565-23456785432"
        ],
        "id": 2664,
        "output": [
            {
                "text": " [0-9]{9}-([0-9]{8})[- ]"
            },
            {
                "text": " 9(0[1-9])[1-9][0-9]{2}"
            },
            {
                "text": " (examples only). \r\n(9|1[0-4]|0["
            },
            {
                "text": " [Y]{4}\\d{2}\\-\\d{4}\\-\\d{"
            },
            {
                "text": " ([0-9]{8})[_.-]{2}([0-9]{"
            },
            {
                "text": " *[0-9]{5}-[0-9]-[0-9][A"
            },
            {
                "text": "\n^(3?[12])-(0?[12]|1?[2-"
            },
            {
                "text": " M^s$n{0}$T$a$g$h{0}$"
            },
            {
                "text": " ^M{8}-{3}-{7}-{3}-{4"
            },
            {
                "text": " [01-23][0-9][0-9][0-9]-[A-"
            }
        ]
    },
    {
        "expression": "^([EV])?\\d{3,3}(\\.\\d{1,2})?$",
        "raw_prompt": "validates an ICD9 medical code which MAY start with an E or V, 3 digits, and MAY be followed by a period and a 1-2 digit sub-code",
        "refined_prompt": "validates an ICD9 medical code which MAY start with an E or V, 3 digits, and MAY be followed by a period and a 1-2 digit sub-code\nMatch examples:\n- \"123.45\"\n- \"E123.45\"\n- \"V123.45\"\nNon-match examples:\n- \"e123\"\n- \"X123\"",
        "matches": [
            "123.45",
            "E123.45",
            "V123.45",
            "456.7",
            "E456.7",
            "V456.7",
            "987",
            "E987",
            "V987",
            "E613.9",
            "V308",
            "761.1",
            "E312.59"
        ],
        "non_matches": [
            "e123",
            "X123",
            "e123.4",
            "e123.45",
            "E12345",
            "5234567891",
            "E",
            "e",
            "E32456",
            "E32456.wef",
            "code",
            "e343343423"
        ],
        "id": 2665,
        "output": [
            {
                "text": " (Any regex that correctly matches all the above examples and fails on the X)\n\"\"\"\n\nimport re\n\ncodes = [\"E123\", \"V123."
            },
            {
                "text": " 123.\\.(1-?\\d\\d)\nExercise 2: Match the following phone numbers\n123-456-7890\n123.456."
            },
            {
                "text": " (Any 1 of these are valid) [v]+\\d\\.(\\d\\d)(?:\\.\\d\\d)?\nI thought the syntax in"
            },
            {
                "text": " To generate the RegEx, put the letters E and V within the [] character set, surrounded by () and escaped with backslashes. The period (.) is outside"
            },
            {
                "text": " \"^{[a-z]{1,3}[a-z]\\d\\d\\d\\.\\d{1,2}(?="
            },
            {
                "text": " [^E-V\\d\\d]\nExercise: Rewrite the RegEx in \"Non-match examples: e123\" to match only valid values"
            },
            {
                "text": " \n.*[EVE].*\n\nI have this in python but I was not sure how to expand it and use if statements to validate. I think if"
            },
            {
                "text": " \\b(E|V)(\\d{3})?[\\.](\\d{1,2})?\\b\n\nTutor: That's wonderful"
            },
            {
                "text": " E123\n\nExercise 2: Write a program that uses regular expressions to validate a user's age. Age must be between 0 and 100. If the user inputs"
            },
            {
                "text": " E(\\.\\d{1,2})* | V(\\.\\d{1,2}){5,}\n\n3. ICD-10"
            }
        ]
    },
    {
        "expression": "^\\d{4,4}[A-Z0-9]$",
        "raw_prompt": "a CPT code is a 4 digits + a captial letter or number (forming 5 character code). The CPT code describes a medical procedure",
        "refined_prompt": "Matches a CPT code with 4 digits + a capital letter or number (forming 5 character code). The CPT code describes a medical procedure\nMatch examples:\n- \"0001F\"\n- \"21082\"\n- \"1332U\"\nNon-match examples:\n- \"F0123\"\n- \"0001f\"",
        "matches": [
            "0001F",
            "21082",
            "1332U",
            "4275T",
            "07229",
            "1245C",
            "1721S",
            "81030",
            "56692",
            "2509Z",
            "3852J",
            "5582E",
            "7880M"
        ],
        "non_matches": [
            "F0123",
            "0001f",
            "100F",
            "23",
            "code",
            "medical procedure",
            "surgery 2",
            "1234",
            "432",
            "eeewdwe",
            "efwef3f3f43ff",
            "43fr321rfq3gfq"
        ],
        "id": 2667,
        "output": [
            {
                "text": " 1) F - First digit, 2) 01 - the second digit of F or U, 3) 02 - the second digit of I can be a single digit, 4) 03 - the second digit of U can"
            },
            {
                "text": " [A-Z][0-9]{4} \n\n2) A medical billing company is processing over 2 million bills in a day. Find a regex that matches any amount that's greater than 300,"
            },
            {
                "text": " ([A-Z0-9]){4}(\\d+(?:\\.\\d?))\n\n2) For the EHG1 code description below,\nUse regular expressions to generate a regular expression"
            },
            {
                "text": "\n([A-Z]|[0-9])\\1\\1\n\nExercise 3:\nRegular Expression for identifying a blood type (IA-, IB-, LT-, AB-)\n\nBlood types include"
            },
            {
                "text": " ^[0-9]{4}[0-9A-zA-z]+$ \n\nExercise 5:\nCreate a RegEx that matches 3 words, separated by either spaces or hyp"
            },
            {
                "text": " ^.{5,5}$\n\n5. Create a RegEx pattern to extract only the numeric substring of a string that is between two digits and contains only numbers. \n\n```python\n"
            },
            {
                "text": " /^\\d.\\d{4}(\\w)[A-Z]\\d$/\n- \"0230U\"Match\n- \"001fU\" Does Not Match (F and I cannot"
            },
            {
                "text": " [0-9]{4}[0-9]A\n\nNow that we have a list of the medical codes, we can write a RegEx to match any of them in our dataframe, using"
            },
            {
                "text": " A code that is 5 characters long and only contained either numbers or capital letters.\n2. Suppose each procedure in an RCT has been labeled with a 2 or 3 letter CPT code.  Your job is to"
            },
            {
                "text": " 0[1-9][0-9]|1[0-2][0-9]|200..3\n\nExercise 2: Given a list of CPT codes, loop through and print out"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,8}[a-zA-Z0-9]$",
        "raw_prompt": "This expression will validate user name with the following rules\n1- It must start and end with a digit or character\n2- It must be exactly 4 to 10 character long\n3- Allowed Special Characters are _.-",
        "refined_prompt": "This expression will validate user name with the following rules\r\n1- It must start and end with a digit or character\r\n2- It must be exactly 4 to 10 character long\r\n3- Allowed Special Characters are _.-\nMatch examples:\n- \"1.ma\"\n- \"user\"\n- \"ma_mo-on.r\"\nNon-match examples:\n- \"_user\"\n- \"asfd@12\"",
        "matches": [
            "1.ma",
            "user",
            "ma_mo-on.r",
            "jzoHroWo",
            "ovxYa.L0",
            "6Nf03p6",
            "jYLdj9_GA",
            "mQLfsKLpw",
            "QgA6Hpq",
            "qfWHtRyHU8",
            "u6R_BceP.5",
            "FDyOtx8OjZ",
            "6TajJ"
        ],
        "non_matches": [
            "_user",
            "asfd@12",
            "user.",
            "#user",
            "///wefw",
            "u$er",
            "user!",
            "@user",
            "<user>",
            "user?",
            "{user]",
            "(user&"
        ],
        "id": 2671,
        "output": [
            {
                "text": "^[a-zA-Z_.\\+\\-]){3,10}$\r\n"
            },
            {
                "text": " _\\S{1,4}\\S{2,10}\r\n\r\n5. Write"
            },
            {
                "text": " \"^(^(?![1-9][1-9]),\\s*[a-"
            },
            {
                "text": " \"\\\\D\\\\d{4,10}\\\\S\" - Matches 4-10 \"non"
            },
            {
                "text": " \r\n[a-zA-Z0-9\\\\.\\\\-_ ]{4"
            },
            {
                "text": " \n\n_[a-zA-z0-9-_.-]{2,"
            },
            {
                "text": " (?<=\\d)(.*)(?<!\\d)\"\"\"\r\n\r\n#"
            },
            {
                "text": " ^\\d{4,10}$ \r\n\r\n2. Write a RegEx to"
            },
            {
                "text": " ^[a-zA-Z0-9._.-]+$\nI know there is a"
            },
            {
                "text": ".*_.*\r\n3- Can the user enter the following string: abc123.\r"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "raw_prompt": "match time for : H:nn:ss or HH:nn:ss",
        "refined_prompt": "match time with formats H:nn:ss or HH:nn:ss\nMatch examples:\n- \"01:00:59\"\n- \"1:59:00\"\n- \"23:59:59\"\nNon-match examples:\n- \"24:00:00\"\n- \"noon\"",
        "matches": [
            "01:00:59",
            "1:59:00",
            "23:59:59",
            "5:47:31",
            "12:00:37",
            "3:50:08",
            "20:27:13",
            "08:14:16",
            "22:59:45",
            "1:37:17",
            "20:32:25",
            "16:24:34",
            "22:53:53"
        ],
        "non_matches": [
            "24:00:00",
            "noon",
            "time",
            "12/12/12",
            "13-13-2",
            "02:41:51 AM",
            "02:41:51 PM",
            "20 32 25",
            "203225",
            "30 seconds",
            "sec",
            "min"
        ],
        "id": 2674,
        "output": [
            {
                "text": " ^(1.|2)\\d{2}\\:\\d{2}\\:\\d{2}$\n\n---\n2. Write a REGEX pattern to check if a string starts with 0 or more digits.\nAnswer: ^"
            },
            {
                "text": "\n\"^((\\d{1,2}):(\\d{1,5}):(\\d{1,5}))|(^(\\d{1,2}:\\d{1,2}:\\d{2"
            },
            {
                "text": " ^[+-]?\\d+:\\d+:[0-5]\\d$\n```python\nimport re\nformat = \"hh:mm:ss\"\npattern = re.compile(f\"^{format"
            },
            {
                "text": " (\\d{1,2}):(\\d{2}):(\\d{2})\n2. Write a Python function that takes a list of strings and a regular expression pattern string. The function should return a dictionary containing the count"
            },
            {
                "text": " (example) [0-9]*:[0-9]*:[0-9]*/\nExercise 2: Create a RegEx to match a person's phone number as 10 digits with the following format: (xxx)xxx"
            },
            {
                "text": " '^(((1[3-9]|2[0-2]):|2[0-3][0-9]:|23[0-2]:|0[0-9]:|0)|((1["
            },
            {
                "text": " Time is optional and can be matched as HH|HH:mm format.\n\nExercise 5: \nAnswer: Create a RegEx pattern that can detect invalid email formats, such as those containing consecutive capitalized initials or those that don"
            },
            {
                "text": " \\d{1,2}:\\d{2}:\\d{2}(?:?|AM |PM)\n\n\n\nQuestion 10: A company produces 500 bottles of soda per hour. If they work for 8 hours in"
            },
            {
                "text": " For this scenario:\n- \"\\d+(?=:\\:|$)\")+\" \nThe regex could also be \".*\\d+(?=:.*|$)\"\n\n2. Write a regex pattern for a password"
            },
            {
                "text": " /^\\d{2}:\\d{2}:\\d{2}$/ or /^\\d{2}:\\d{2}:\\d{2}\\s[ap]m\\s/ or /^\\"
            }
        ]
    },
    {
        "expression": "^([1-9]+\\d{0,2},(\\d{3},)*\\d{3}(\\.\\d{1,2})?|[1-9]+\\d*(\\.\\d{1,2})?)$",
        "raw_prompt": "Accepts non-negative numbers with max two decimals. Commas can be added after every thousand.",
        "refined_prompt": "Accepts non-negative numbers with max two decimals. Commas can be added after every thousand.\nMatch examples:\n- \"1200\"\n- \"1,200\"\n- \"1,200.0\"\nNon-match examples:\n- \"-43\"\n- \"0\"",
        "matches": [
            "1200",
            "1,200",
            "1,200.0",
            "12,324,532.23",
            "234122197712817448008574158167894889305230439779354370220937698578050893782896158227.78",
            "66394965947682179643452649243327481438317293881647562351429578967172264547986125157892974981634191636120788888047567662264848325693081625589017159",
            "863733627925899152866894911742679557969889767947742611498454471164255964323279645,158,054,484,881,965,222,364,885,707,932,542,241,383,180,567,542,514,867,036,972",
            "551369621886461782972191114464492755318941697931276344143837277496938913750923519255734953278866806433835",
            "91495832182691632527926,239,388,745,348,478,638,589,022,811,804,500,396,125,666,489,385,348,158,122,991,142,491,622,121,197,831,510,750,224,136,027,858,893,276,262,723,662,056,121,638,705,489,406,955,739,455,611,893,175,816,258,765,091,086,512,851,615,787,777,319,437,711,404,832,621,638,630",
            "9119565471413683647346558195673817473,448,573,495,805,989,746,055,223,129,395,757,273,464,744,931,500,207,298,788,333,550,975,799,871,141,044,106,312,274,764,107,907,931,257,475,081,322,261,496,732,009,898,456,535,014,862,322,492,265,072,816,328,508,305,310,112,689,157,701,089,084,567,448,541,009,967,544,490,653,321,322,705,937",
            "687357588294667585578626",
            "813183887279718535883742131575761825911494131375522235917296479139635776545860081144583730851407141300545489780557136407954.73",
            "7177128286236738886905329772080881695045031017932409702386065046187478712244527378681"
        ],
        "non_matches": [
            "-43",
            "0",
            "01,423,534.23",
            "24.4223",
            "32,42,123",
            "134253y6hterge",
            "34ty6",
            "df435678",
            "uy67543e",
            "er456",
            "543qfv",
            "653g45"
        ],
        "id": 2684,
        "output": [
            {
                "text": " [0-9]{0,255},(?=[0-9])[0-9]{3,}\n- [0-9]{1,5}\\.(?=[0-9]{3})\nhttps://blog"
            },
            {
                "text": " ([\\d,]*)(?:\\.0+)\n\n(I used the above python template on my original question to solve the task)\n\n2. Write a Python program that takes a text string, removes leading zeros if any, and"
            },
            {
                "text": " r'([+-])?\\d-?\\d(?:[,.]\\d+)?'\n\n2) The RegEx function is used in the string matching section to find a pattern within a text. Match examples: \n1"
            },
            {
                "text": " (0|[1-9][0-9]*[KM])?[0-9]{1,2}(.00)?[KM]\n- \"1k2M8K1.2\"\nMatch example"
            },
            {
                "text": "\n- \"^\\d{1,3}(,[\\d.]\\d?){1,2}$\"\n- \"^\\d{0,1}(,[\\d.]\\d?){0,2}$\""
            },
            {
                "text": " \"^(0+)?\\-\\d{1,2}[,.]?\\d{3}$\"\n---\n#### Question 2: Extract numbers\n\n### Generate the regex:\n\n\"0\\+?[\\d"
            },
            {
                "text": ".*?(?=(0|\\*|\\.)\\d{1,3}(?:\\,\\d{3})?|[0-9]+$).*\nThe first \"|\" is a or b, which will"
            },
            {
                "text": ".{1,1005}$\nFor more information about the \"?\" operator refer to this post\n\nA:\n\nI was having the same issue. You can specify multiple characters which are not delimiters by using the.* operator between"
            },
            {
                "text": " \"^[0-9]+(.[0-9]?)+$\"\n\n4. How do you generate a regex for a list of strings and a regex to match a single string from the list?\nGenerate a regex for this:"
            },
            {
                "text": " (^[1-9][0-9]?[0-9]?\\\\.?[0-9]+)$\n\n\n\nQuestion 5: David wants to buy 6 cans of soda for a party. Each can costs $1."
            }
        ]
    },
    {
        "expression": "^[0-9]*[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive integers that are greater than 0. Also allows for infinite zeros leading the integer\nBased on William Powell's Pattern Title, but modified to allow for leading zeros.",
        "refined_prompt": "Allows only positive integers that are greater than 0. Also allows for infinite zeros leading to the integer\nMatch examples:\n- \"1\"\n- \"12\"\n- \"124\"\nNon-match examples:\n- \"-1\"\n- \"a\"",
        "matches": [
            "1",
            "12",
            "124",
            "01",
            "0012",
            "000124",
            "0456056898853258290052535909141449947763346124071099519164571289854655944451617155912138847698653624336996358636882626419149",
            "46958256105370176463315311504672534575648608130075527875460958175796347477937281561868894855362966967338559545531263555589847945645798388824272893481681574473762828549614845512745694623960580675",
            "838778102452570968618002967290535759234381294008100568708521648333919747513582156742395556355534167789561203424421508907573471001467336912131",
            "59243178360220518974977524032268252869783256427711504297180355797844365133253936498736137912484473134428433629192871622177748415296413197442647517467056322034045330465207797774188209863095273782857468049583162333877772343778564066486",
            "9035607486667778433287255438431614263",
            "2173247762150905619270434522184729642314788872748638294323640862487235604846967518462380060904",
            "107079596931536351545909256730859831054928608180812324257621143683697351393981683292321786696957732259158418344468426292755448306036256986543589987149164084480522274380340274402723299502431465896209140258535790"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0",
            "0000",
            "number",
            "345674rwegty",
            "+987654",
            "-987654",
            "0.087654",
            "9876545678hgfds",
            "7675r6fyt",
            "324565tr"
        ],
        "id": 2699,
        "output": [
            {
                "text": "\n\n\"\"\"\nimport re\n\ndef int_match(*args):\n    regex = '^'\n    for arg in args:\n        regex = '|'.join([regex, re.escape(arg)])\n    return regex + '*$'\n"
            },
            {
                "text": " ([-+]?[0-9]+\\.[0-9]*(E[-+]?[0-9]+)?|[-+]?[0-9]+)([eE][-+]?[0-9]+)?\n\n- \"20\"\n-"
            },
            {
                "text": " \"(0)?\"|(0)|(0)\\d{1,2}($|\\.)(\\d{1,2})?\"\n\n(12,1)? or (0)?\n\n- Generate a RegEx for this description.\nAnswer: (.+)?\n\n"
            },
            {
                "text": " \\d+\n\n2. You're being asked to identify whether a given phone number is in the range (123) 456-7890 or not. Based on given information, develop a regular expression that matches if the supplied number is between the two (and not included in either range)."
            },
            {
                "text": " ^[1-9]\\d*$\n\n3. Using list comprehension, write a Python script that takes a list of numbers and returns only the positive integers that are greater than zero.\nSolution: numbers = [2, -5, 6, 0, 12, -8]"
            },
            {
                "text": " \nr'(?:\\d{1,3}(?:\\.\\d*)?|1[9]\\d{0,2}|012(?:\\.\\d*)?|[12]\\d{0,3}){4,10}$"
            },
            {
                "text": " (^\\d+)(\\.\\d+)?$\n\n4) Write a Python script that uses regular expressions to find all email addresses in a large text file. \nAnswer: (Regex Pattern: [\\w.-]+@[\\w.-]+\\.\\w{2"
            },
            {
                "text": " ^[0-9]$\n\n7.2.2 String Parsing\n\nString parsing involves searching a string for patterns in order to extract specific information. Regex can be used for effective string parsing by allowing the user to define what kind of patterns are being searched for. \n"
            },
            {
                "text": " *\\b[0-9]+\\b|\\*\\d+\\b\nExample:\nimport math\nn = math.sqrt(3)  # returns \"1.7320508075688772\"\nf = math.sqrt(-3) # raises"
            },
            {
                "text": " -1\nI feel pretty confident about this question and I think I got it working correctly. Thanks a lot for your help!\n\nA:\n\nWhy can't you use /^1+1$/? It forces one digit on both sides.\nHere is the regex with the"
            }
        ]
    },
    {
        "expression": "[0](\\d{9})|([0](\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4}))|[0](\\d{2})( |-|)(\\d{7})|(\\+|00|09)(\\d{2}|\\d{3})( |-|)(\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4})",
        "raw_prompt": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.",
        "refined_prompt": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.\nMatch examples:\n- \"073-386-2612\"\n- \"0443862612\"\n- \"076 858 7777\"\nNon-match examples:\n- \"qdsq11123\"\n- \"sdfgty654\"",
        "matches": [
            "073-386-2612",
            "0443862612",
            "076 858 7777",
            "+27 76 858 7777",
            "0027 765877777",
            "0956 33 8881234",
            "0921112720",
            "0405595829",
            "+546-08 639-5212",
            "040-6461703",
            "021-7377498",
            "0464291438",
            "0847314712"
        ],
        "non_matches": [
            "qdsq11123",
            "sdfgty654",
            "IUYTR5678",
            "KLJIHUY",
            "erfhrt67dc",
            "3ferh8374",
            "rfenuyd654e5",
            "43iuhfe78",
            "3iufh&Y*&*",
            "HGYTF76",
            "34redc76",
            "3456y7hytrf"
        ],
        "id": 2703,
        "output": [
            {
                "text": " The final phone number format is.+?(\\+?(.{3}|("
            },
            {
                "text": " \\d{3}-\\d{4}[\\d\\-]\\d{"
            },
            {
                "text": " \".*[0-9].*[0-9].*[0-9]"
            },
            {
                "text": " (0[3-9][0-9]|[1-9]\\d"
            },
            {
                "text": " (?:(?:\\d{1}(\\d{3})|\\(\\d{"
            },
            {
                "text": " \nRegEx: \n ^[0-9]+[a-z]?"
            },
            {
                "text": " The RegEx is [0-9]{3}[a-zA-Z"
            },
            {
                "text": " \\d\\d?\\d\\d?-?\\d\\d-?\\"
            },
            {
                "text": "  ^\\d.{10}$\n\nUse Cases:\n\nUse Case 1"
            },
            {
                "text": "\n\"\"\"\npattern = r\"(?=.*[0-9])[0-9"
            }
        ]
    },
    {
        "expression": "^([1-9][0-9]?|100)%$",
        "raw_prompt": "Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places accepted.",
        "refined_prompt": "Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places are accepted.\nMatch examples:\n- \"1%\"\n- \"52%\"\n- \"100%\"\nNon-match examples:\n- \"0%\"\n- \"100\"",
        "matches": [
            "1%",
            "52%",
            "100%",
            "49%",
            "9%",
            "7%",
            "89%",
            "26%",
            "41%",
            "5%",
            "24%",
            "3%",
            "25%"
        ],
        "non_matches": [
            "0%",
            "100",
            "101%",
            "52",
            "52.4%",
            "987654",
            "2345678",
            "hugufcxs4",
            "98765rfg",
            "hbyugt65r",
            "8765rf",
            "hgtfyr5"
        ],
        "id": 2710,
        "output": [
            {
                "text": " [\"^[1-9][0-9]|0$\", \"%$\"]\nExercises:\n1. Write a regular expression to match a string that begins and ends with a period (.), capitalized. Example: \"This is a Period.\" Answer: ["
            },
            {
                "text": " Matches a decimal number between 0 and 1. Accepts 2 decimal places.\n\nExercise 2:\n\nMatch the following Regex options with their descriptions:\n\na) Verbose\nb) Multiline\nc) Dot (.)\nd) Star (*"
            },
            {
                "text": " [12%|13%|14%|..|26%|27%|28%|29%|30%|..|62%]\nThe RegEx above can be used to match any decimal number from 12 to 62.\nExplanation: \n["
            },
            {
                "text": " [^0-9]%[^0-9]\n\"\"\"\n\ndef getPercent(string: str) -> str:\n    \"\"\"Extracts percentage from a string\n    Args:\n        string (str): string \n\n    Returns:\n        str"
            },
            {
                "text": " Match any percentage between 1 and 100 using the percent symbol. between 1 and 100 times, but not directly.\n\n3. Exercise: Generate a RegEx for this description\nMatch this phrase. No decimal places are accepted. Accepts up to 4 decimal places rounded to 2"
            },
            {
                "text": " ^1\\d$|^100\\d$\nIn both examples, a digit between 1 and 9 is specified. A single digit may be found in the latter example, but no digits are found in the former.\n\n*Question 2*\nHow to get the result"
            },
            {
                "text": "\n\n```python\nimport re\n\nmin_match = [\"1%\", \"52%\", \"100%\"]\nmax_match = [\"0%\", \"100\"]\nmatches = [float(x) for x in min_match + max_match"
            },
            {
                "text": "\n[0-9]+% or [1-9][0-9]\nPattern matches from the left to the right (no group!)\nPattern:\n[0-9]+%|[1-9]0?|[1-9][0-9"
            },
            {
                "text": " (\\d|\\.\\d)%\n\nExercise 2: Fill in the blank\n1. RegEx stands for\nAnswer: Regular Expression\n2. The `re` module provides methods for matching and replacing text using RegEx.\n3. To test out"
            },
            {
                "text": " 1%|.0%|100%|.*%\n\n2. Write a RegEx that matches a US phone number in any format. Accepts up to 1000 characters. Accepts the format (xxx) xxx-xxxx. No characters are accepted.\nHint"
            }
        ]
    },
    {
        "expression": "^([0-9][0-9])[.]([0-9][0-9])[.]([0-9][0-9])$",
        "raw_prompt": "Versioning in XX.YY.ZZ format",
        "refined_prompt": "Matching dates in XX.YY.ZZ format\nMatch examples:\n- \"01.02.23\"\n- \"11.89.46\"\n- \"92.52.78\"\nNon-match examples:\n- \"1.2.3\"\n- \"23456.2345.2345\"",
        "matches": [
            "01.02.23",
            "11.89.46",
            "92.52.78",
            "04.39.63",
            "23.21.55",
            "17.50.87",
            "39.33.14",
            "79.93.88",
            "62.51.16",
            "02.19.99",
            "16.37.65",
            "68.49.64",
            "19.96.63"
        ],
        "non_matches": [
            "1.2.3",
            "23456.2345.2345",
            "3refwdsy",
            "4353.34543.34",
            "2345refdrew",
            "43564.reqt5",
            "IP",
            "#3",
            ".e.wef.",
            "efrgt54",
            "543rd",
            "gr5445"
        ],
        "id": 2735,
        "output": [
            {
                "text": " (\\d+)\\.(\\d+)\\.(\\d+)\n\n3. Example: Check a string contains valid date. \n```python\nimport re\n\ntext = \"Today is 09/12/20"
            },
            {
                "text": " RegEx for this description: \"^\\d.\\d\\d\\.\\d+\"\n\n#### Exercise 5: Extract numbers from a string with multiple patterns\nMatch the date-time pattern \"YYYY-MM-"
            },
            {
                "text": " [0-9]\\d\\d.\\d\\d\n\nExercise 3:\nWrite a SQL query using RegEx to filter all the records in the \"employees\" table where the employee last name matches the"
            },
            {
                "text": " \"([0-9]|\\.){3}\"\n--- \n\n##### Exercise 2 - Word Search:\n\nWrite a Python program that generates a word search grid and validates if the given word can be found"
            },
            {
                "text": " (?:\\d\\d\\.\\d\\d.\\d\\.)\\d{3}\\.(\\d{3})\\.(\\d{4})) \n\n3. Exercise:\nYou are tasked with"
            },
            {
                "text": " (1) ^\\d{1,2}\\.\\d{1,2}\\.(\\d{1,2}),(19|20)\\d{2}\\.(\\d{4}).(\\d"
            },
            {
                "text": " ^\\d+\\.\\d+\\.\\d+$\nExercise 4:\nGiven a date: \"09.25.2021\"Is it currently in the past? Yes/No.\nUsing conditional statements and"
            },
            {
                "text": "\n\\.(\\d{2})\\.(\\d{2})\\.(\\d{4})\n\nI hope these exercises provide you with a better understanding of RegEx and its implementation in Python. By mastering Regular Express"
            },
            {
                "text": " \"^\\d{2}.\\d{2}.\\d{4}$\" \n\nExercise 4:\nCreate a RegEx for matching dates in MM.DD.YYYY format\n\nSolution:\n"
            },
            {
                "text": " I've created the following pattern: ^(0*?[1-9]|[1-9][0-9]?|100?[1-9]{0,2}|[12][3-"
            }
        ]
    },
    {
        "expression": "[\\\\\"\"=/>](25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2})\\.((25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{1,2})\\.){2}(25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b[\\\\\"\"=:;,/<]",
        "raw_prompt": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\".\n[\\\\\"\"=/] can be removed on both ends to seach IPs in text files, but with it, it has better accuracy - there are version numbers in the application configuration files.\nIt also does not match IPs that have one digit at the first number.",
        "refined_prompt": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:\"\n- \"34567ui\"",
        "matches": [
            "/172.21.134.89: /127.0.0.1: \"14.14.14.14\"",
            "=148.48.233.103;",
            ">145.101.251.196;",
            "\"254.228.251.171\\",
            "=250.253.4.206:",
            "/136.250.254.2/",
            "\"242.235.5.254=",
            "/207.253.250.251,",
            "\"00.206.131.5=",
            "\\163.162.2.228:",
            "\"232.06.203.251:",
            "\\47.0.42.96=",
            "\\253.250.27.228;"
        ],
        "non_matches": [
            "\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:",
            "34567ui",
            "swdefrtgyhjuik",
            "IP",
            "9876.23456.432234.54321",
            "3245.3234354.42312245.32",
            "i765rfgh",
            "/////",
            "fewcd",
            "w43rg",
            "345trf",
            "654fe"
        ],
        "id": 2740,
        "output": [
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2-"
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            }
        ]
    },
    {
        "expression": "\\b(1(?!27\\.0\\.0\\.1)\\d{1,2}|2[0-4][0-9]|25[0-4]|\\d{1,2})\\.(?:\\d{1,3}\\.){2}(25[0-5]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b",
        "raw_prompt": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number",
        "refined_prompt": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"",
        "matches": [
            "172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214",
            "213.728.138.115",
            "252.783.463.44",
            "252.1.5.1",
            "211.31.6.234",
            "40.548.5.2",
            "6.3.37.187",
            "14.58.636.218",
            "10.67.0.255",
            "233.981.287.39",
            "80.13.75.211",
            "33.81.173.3",
            "221.36.546.29"
        ],
        "non_matches": [
            "127.0.0.1 192.168.1.0 255.255.255.255",
            "2345",
            "13r2456yht",
            "3r4t56",
            "345t6",
            "34567f",
            "ijyt765",
            "IP",
            "34f567hy",
            "345675432456.234565432.",
            "irtfcgv",
            "34567yterf"
        ],
        "id": 2742,
        "output": [
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this IP"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this."
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this IP"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this problem"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this range"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this string"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this pattern"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this:"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this:"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this:"
            }
        ]
    },
    {
        "expression": "^(((19|2\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((19|2\\d)(0[48]|[2468][048]|[13579][26])|(2[048]00)))\\/0?2\\/29)|((19|2\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00",
        "refined_prompt": "validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400/02/29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29",
            "1908/3/24",
            "2426/10/31",
            "2445/07/30",
            "2593/7/31",
            "2981/12/3",
            "2741/10/31",
            "2800/2/29",
            "1906/12/31",
            "1921/08/17",
            "1919/10/29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29",
            "12-12-12",
            "12/12/12",
            "2345678",
            "date",
            "32245/23456/3245",
            "43rfeds",
            "er4567",
            "34567543",
            "3456765432"
        ],
        "id": 2753,
        "output": [
            {
                "text": " The RegEx for this is '^("
            },
            {
                "text": " \\d{4}/\\d{"
            },
            {
                "text": " \n```python\nimport re\n"
            },
            {
                "text": " [date validation](http://www.regular"
            },
            {
                "text": " ^([0-9]{4}"
            },
            {
                "text": " Regex used is $year/3["
            },
            {
                "text": " ([0-9]{2}/"
            },
            {
                "text": " (This is up to the teacher to validate"
            },
            {
                "text": "  [0-9]{4}"
            },
            {
                "text": " \"^[0-9]{4"
            }
        ]
    },
    {
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))\\/0?2\\/29)|((1[6-9]|[2-9]\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400/02/29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29",
            "1740/02/29",
            "1871/03/31",
            "6829/05/31",
            "7200/02/29",
            "7895/8/29",
            "3055/6/9",
            "1966/08/29",
            "1680/02/29",
            "9386/04/24",
            "2639/05/18"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29",
            "12-12-12",
            "12/12/21",
            "july 4",
            "noon",
            "12:12:12",
            "32456787654",
            "432413/23435/234",
            "987654erfg",
            "r45t6y7"
        ],
        "id": 2754,
        "output": [
            {
                "text": "\n```\nr\"\"\"\\b              #"
            },
            {
                "text": " /^\\d{4}(-?\\"
            },
            {
                "text": " /^([0-9]{4}\\"
            },
            {
                "text": " (Regex) /[0-9]"
            },
            {
                "text": " /^20[2-9]\\d"
            },
            {
                "text": " The RegEx generated for this description is [\\"
            },
            {
                "text": " (^(0[1-9]|"
            },
            {
                "text": " the years (up to 89999) match ("
            },
            {
                "text": ".{1,2}\\/\\?["
            },
            {
                "text": " \nimport re\n\npattern = r'"
            }
        ]
    },
    {
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400-02-29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400-02-29",
            "1928|05/30",
            "1876-12|11",
            "1776|10|27",
            "1907/03/29",
            "1782|04|15",
            "1621-11-27",
            "8142|10/14",
            "7978-12|2",
            "8800|02|29",
            "2348|02|29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100-02-29",
            "12/12/12",
            "12-12-12",
            "date",
            "july 4th",
            "noon",
            "12:12:12",
            "098765434567",
            "9876tghj",
            "kljhGFGHJKO"
        ],
        "id": 2755,
        "output": [
            {
                "text": " ("
            },
            {
                "text": " ^"
            },
            {
                "text": " year"
            },
            {
                "text": "\n"
            },
            {
                "text": " "
            },
            {
                "text": " ["
            },
            {
                "text": " Re"
            },
            {
                "text": " ^"
            },
            {
                "text": "\n"
            },
            {
                "text": " ("
            }
        ]
    },
    {
        "expression": "^([1-9]\\d*|0)(([.,]\\d*[1-9])?)$",
        "raw_prompt": "Positive real multi-digit number: don't allow preciding zero, last decimal digit zero not allowed.",
        "refined_prompt": "Matches positive real multi-digit number: don't allow preceding zero, last decimal digit zero not allowed.\nMatch examples:\n- \"1500\"\n- \"0,331\"\n- \"12.005\"\nNon-match examples:\n- \"01500\"\n- \"0,330\"",
        "matches": [
            "1500",
            "0,331",
            "12.005",
            "19204207",
            "0.515397219064482005053962418261754892110130607560901854459878678570886142",
            "3711317789628530594278175593852273602963673841141805.89952675267724818930125059048808750694531765788250405657468405161255545581758475",
            "0,031276441419360114979141459693979515028213585191067376944080819212405988924659796784",
            "0.588997558014435396618053207557453",
            "78344561005072202780646271634804695577",
            "9209628591304586,01513469042545248301696622872846074044",
            "0.075382775592020905438587331315840881474992805278637755",
            "194036710352866414120909933050685855557052133732759020",
            "728986200392162"
        ],
        "non_matches": [
            "01500",
            "0,330",
            "012.0050",
            "kjhgfd",
            "#3",
            "$45",
            "54%",
            "098765rtfgh",
            "34f5",
            "349876ts",
            "9876543eds",
            "$%^&*()"
        ],
        "id": 2761,
        "output": [
            {
                "text": " ^[1-9][0-9]* (or [0-9]*, if allowed) (?:-?[0-9]*)?$\nI need to take the input from the end of the string and see if it"
            },
            {
                "text": " \\d*(?:\\.\\d+)?([eE][+-]?\\d+)\nWhat will a RegEx of this look like? \nHow to allow preceding 0 or final point?\nI know one way is to"
            },
            {
                "text": "\n- Matches positive real multi-digit number with no preceding zero - (.+)\\b\n  First group: [^\\d]*(.+)\\b\n  Second group: ([^,]+)\n- Matches positive real"
            },
            {
                "text": " ([1-9]0?[0-9]){3}[0,9],([0-9])(?:,[0-9]{3})*\nExercise 5:\nDescription: A real-world company produces and"
            },
            {
                "text": "\n(^|(?<=^))[0-9]+(?=,)\n\nThis allows preceding zero, last not zero digit allowed\n\nA:\n\nThe most straightforward way I was able to make it work is to not"
            },
            {
                "text": " (\\d{1,3}[,\\d\\.]\\d{2,})|(\\d{3,4}(,\\d{3})*)\n\nA:\n\nIf you're really trying to match something"
            },
            {
                "text": " (This is a rough explanation) \\d{1,}-\\d{1,}-\\d{1,3}\\.\\d{1,3}(:[01]\\d{2,})+\n\nA:"
            },
            {
                "text": " [0-9]{2}\\.?[0-9]{1,3}|[0-9]{1,3}(?=\\.[0-9]{1,3}$)\nHow do you"
            },
            {
                "text": " ^(1|\\d(?:,1\\d)?(?!0)\\d)-?(.0\\d+)?$\n\nA:\n\nUse the following to get the desired results:\n^[1-9][0"
            },
            {
                "text": " The regex for a decimal number is \n\"[0-9]{1,2}\\.[0-9]{3}(,[0-9]{3})*\"\n\nA:\n\nTry ^(?:[0-"
            }
        ]
    },
    {
        "expression": "^[^<>`~!/@\\#},.?\"-$%:;)(_ ^{&*=|'+]+$",
        "raw_prompt": "This regular expression will remove all invalid chars from a string",
        "refined_prompt": "Matches any strings without special characters, but can have - [ or ]\nMatch examples:\n- \"AdnanSattar\"\n- \"4567jki\"\n- \"evbtyui\"\nNon-match examples:\n- \"Adnan=Sattar\"\n- \"(*&^%$\"",
        "matches": [
            "AdnanSattar",
            "4567jki",
            "evbtyui",
            "3f45678kuy",
            "98765trghj",
            "gfdrt678",
            "3freu87t6",
            "dftgyuhijo9876",
            "fghukjhjGRFF765",
            "iuhgyuyguJGG",
            "vghftFTFT7867",
            "uygtfyFTY786",
            "nhgyt"
        ],
        "non_matches": [
            "Adnan=Sattar",
            "(*&^%$",
            "&^%$",
            "GTFR$E%^&*",
            "*&^%RFTGH",
            "HGTF^&*Y(U)_+P}{:\"LK",
            "PI(U*Y&T^R%EDRTFYG",
            "fgctyguhUY&^%Rtfyguhi",
            "U&^%RTF",
            "FRT%",
            "IUY&T^%",
            "GFRTDE$%R^&T"
        ],
        "id": 2762,
        "output": [
            {
                "text": " (\\w|-)+\n\nA:\n\nFor an arbitrary number of operators (^, $, |, ^=, <<=, >>=, &, |, ^, $, ^, $,"
            },
            {
                "text": " \\[([^\\[\\]]+?)\\]\n\n3- Write a function that converts any string to uppercase.\n```python\ndef to_uppercase(data):\n    return"
            },
            {
                "text": " -.+[*&^%$]|[*&^%]\nMy current code for this question:\npublic static string findPattern(string text, List<string> list)\n{\n    Regex"
            },
            {
                "text": " [a-zA-Z0-9_.+-]+$\n\nExercise:\nWhat are the best practices for writing regular expressions?\n\nAnswer:\nSome best practices for writing regular expressions include:\n"
            },
            {
                "text": " \".*[a-zA-Z0-9\\W*]*$\")\n\n```python\n# RegEx for Phone Number Formatting \nnumberPattern = re.compile(r\"\\"
            },
            {
                "text": " \"^[a-zA-Z0-9]+$\"\n- \"[^a-zA-Z0-9 -]+$\"Any other non alphanumeric and - special characters.\n\n``"
            },
            {
                "text": " (.*)\\=\\s*(.*)\\[\\s*\\].*\n\n2. Write a Python script that extracts the phone numbers from the following XML file:\n<records>\n  <record>"
            },
            {
                "text": ".+$|\\D\n\n# The code that generates the RegEx\n# print(F'Match the description without special characters, but can have - [ or ]: {RegEx}')\n# print("
            },
            {
                "text": " ^\\w+=\\w+$\n- \"hello,world!\"\n- \"&*%$\"Generate a RegEx for this description. \nAnswer: ^[a-zA-Z0-"
            },
            {
                "text": " (^.*|[^a-zA-Z0-9_])\n\nHow to fix? (https://ideone.com/5pGQj1)\n\nA:\n\nDon't"
            }
        ]
    },
    {
        "expression": "^((\\d{3}[- ]\\d{3}[- ]\\d{2}[- ]\\d{2})|(\\d{3}[- ]\\d{2}[- ]\\d{2}[- ]\\d{3}))$",
        "raw_prompt": "allow to insert input for polish tax identyfication number (NIP). Mask accepted:\nXXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX",
        "refined_prompt": "Matches polish tax identification number (NIP). Mask accepted:\r\nXXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX\nMatch examples:\n- \"222-22-22-222\"\n- \"222-222-22-22\"\n- \"222 22 22 222\"\nNon-match examples:\n- \"2222222222\"\n- \"XXXXXXXXXX\"",
        "matches": [
            "222-22-22-222",
            "222-222-22-22",
            "222 22 22 222",
            "222 222 22 22",
            "046 956 96-35",
            "401-721 09 88",
            "675 51 55 031",
            "561-91-41 108",
            "825-700 53-14",
            "637-746 15-25",
            "921-161-33 32",
            "192 53 22-178",
            "090-658-27-75"
        ],
        "non_matches": [
            "2222222222",
            "XXXXXXXXXX",
            "23142536789",
            "90876543",
            "#34567",
            "XXX XXX XX XX",
            "########",
            "phone number",
            "$45",
            "54%",
            "i987654fgh",
            "324r56789"
        ],
        "id": 2781,
        "output": [
            {
                "text": " [a-z][a-z][a-z][a-z]\n#"
            },
            {
                "text": " \\1\\2\\3\\4\n\n3: What is a password?\nWrite"
            },
            {
                "text": " XXX-XXX-XXX-XX; XXX-XXX-XX-X; XXX-XXX"
            },
            {
                "text": " XXXXXXXXXXXXX\n\nA:\n\nIn Java:\n    int input = 8"
            },
            {
                "text": " (XXX.{3}X)(-XXX-XXX-XXX)\nWhat is a"
            },
            {
                "text": " NIP: 0123456789 0-9\nExercise Two: Describe a"
            },
            {
                "text": " The first two words must be numbers. \n- \"222-12-2-222"
            },
            {
                "text": " XX-XX-XX-XX\nAll characters must be escaped using \\' (\\).  "
            },
            {
                "text": "\nThe following is what I came up with: \n/(000-00-00-"
            },
            {
                "text": " (2-5 digits)-(0 or more digits)-(-(0 or more digits)-"
            }
        ]
    },
    {
        "expression": "^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$",
        "raw_prompt": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.",
        "refined_prompt": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.\nMatch examples:\n- \"01:23:45:67:89:AB\"\n- \"BA-57:B3-B9:C2-A8\"\n- \"D4-AC:94-1C-4E-90\"\nNon-match examples:\n- \"01:23:45:67:89:X9\"\n- \"12345678\"",
        "matches": [
            "01:23:45:67:89:AB",
            "BA-57:B3-B9:C2-A8",
            "D4-AC:94-1C-4E-90",
            "37-69-64-7A:55-33",
            "25:87:CB-DE-68:64",
            "83:59-09:02:13-1E",
            "7C-3D-35-37-08:08",
            "46:03:FE:29-70:EE",
            "64-E6:97:26-4F-ED",
            "15:63:B1-70:C1-0F",
            "C9:4F-2C-62:2E:9F",
            "30-1C-F5:0D-37-5D",
            "3A-34-0D-18-8E:D6"
        ],
        "non_matches": [
            "01:23:45:67:89:X9",
            "12345678",
            "12345:987654",
            "123,24,24",
            "34235.342.152",
            "343532.43.34321",
            "435421.354.231431",
            "2314.123431345.212.3242",
            "335fgdd45Y",
            "#34567",
            "#(*&^FGHJ",
            "num"
        ],
        "id": 2797,
        "output": [
            {
                "text": " A"
            },
            {
                "text": " "
            },
            {
                "text": " The"
            },
            {
                "text": " 123"
            },
            {
                "text": " \""
            },
            {
                "text": " ^"
            },
            {
                "text": " *"
            },
            {
                "text": "\n"
            },
            {
                "text": " ("
            },
            {
                "text": " ^"
            }
        ]
    },
    {
        "expression": "^[+]?((\\d*[1-9]+\\d*\\.?\\d*)|(\\d*\\.\\d*[1-9]+\\d*))$",
        "raw_prompt": "Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.",
        "refined_prompt": "Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.\nMatch examples:\n- \"010\"\n- \"010.\"\n- \".010\"\nNon-match examples:\n- \".\"\n- \"0\"",
        "matches": [
            "010",
            "010.",
            ".010",
            "010.010",
            "1243404772609295125460204035371614003828140108310.483882086089625121162296779392682463219687872418273841445297924589778656003699081173212696446764736168076709970110754272238158416496545182962276094816",
            "5787025258777226663819707379967196319384975473222131719286424617699635015993186695518392374645129413419824232769857118625924603488979620374196139158758967049899733974940005868347971383727258240349596530422889540028763704063",
            "+317390232368475384705319870283923655456872508597988998976484148982938930.74523413535367925846016470846001759708321521822199817916089893999756887856549219073857219000875348648398655713758532481199114884894818968926621332224528469823343672849792642124964271582263456940281441421730106292133702246064612081827607425743354934348703280078104380",
            "3182953897310785099910859118987204527113286602884476165.28666207806970913135774976284702115742844755844412008808399999838191175393795883917224339648955713837443957888639584667972427000449501810553657701093462565010252121364298943852915776823",
            "+46370587770832127929678376020248618142063452521989380145271251667849315652492763262895792996981293241358532486717314359262894718466298817749.0078953534904249259027644247073555111954696015987831490536214972",
            "+2158922856848719788004463835161024721556049945038228650203116367358142567921754193930284810014092696233574634329661884665831191742846614885446427786673787946142266681778485231299718559289788467849451632431428549557392523457149997506741350457845340358478259692.6676486109196738323654340119355044821760389646549846054709560",
            "+3443945771146322543101357179404990583317234398482679935929068146400310910737428742620921232436424511637883899494145437199864646986253318858145738253467897784935646391753133672842758967382388500380499978777346245625941109501315287373888375921853016913967902029227211816933034790877546215539",
            "540224785306964502417438075178309712450793216478411365239754751449503078288507348034276230640265870415651654801965705369326833953079649729225951284764202884061108949",
            "701894580094396043330941524260187427917372819176324599452830966390264117488527308225997026.731512256780380230594821447687785797535881670939160002092513059769006480051521463873976495539361793328226463771981348378341425825394853626992438944879686674884538674384632264928790579882949939404150959456898163151736661811870448"
        ],
        "non_matches": [
            ".",
            "0",
            "0.",
            ".0",
            "0.0",
            "0.00",
            "00.0",
            "00.00",
            "-0",
            "-1",
            "a",
            "#"
        ],
        "id": 2799,
        "output": [
            {
                "text": " A decimal number >= 0.01\n\n5. Match any positive integer greater than or equal to 0 with a leading '+' symbol and optional leading or trailing zeros on"
            },
            {
                "text": " \n- \\.\n- (?:\\.(0|[1-9][0-9]*\\.[0-9]+))0?\n- [+-"
            },
            {
                "text": " \"\\d[.0-9]*\"\n- \"0123\"Generate a RegEx for this description. \nAnswer: \"\\d{3}[."
            },
            {
                "text": " \"^\\+00.{5}$\"\n\n4. A company makes and sells custom mugs. The company receives an order for 15000 mugs, each"
            },
            {
                "text": " ^[1-9][0-9]*(.[0-9]?[1-9][0-9]*|0)$\n\nUse case"
            },
            {
                "text": " (1[01])*\n\n7. Write a regular expression from the rules below: A positive integer can be followed by a decimal point, positive integer, or any number"
            },
            {
                "text": "\n[a-z]+|\\[.\\]|[a-z0-9.]+|[0-9.]+\n\nExercise 5:\n"
            },
            {
                "text": " [a-zA-Z0-9][a-zA-Z0-9].[a-zA-Z0-9][a-zA"
            },
            {
                "text": " [ ]\n\n11. If you have to create a regex that matches any character between the beginning and the end of the string OR between's and 'z' characters."
            },
            {
                "text": " \"\\\\.(0+)?[01]\"\n- If you want only decimal numbers with a leading zero, match this: \"(0*[1-9]\\\\d*)"
            }
        ]
    },
    {
        "expression": "\\b[A-Z0-9]{5}\\d{1}[01567]\\d{1}([0][1-9]|[12][0-9]|[3][0-1])\\d{1}[A-Z0-9]{3}[A-Z]{2}\\b",
        "raw_prompt": "Matches the UK Drivers License format:\ni. Must be 16 characters\nii. First 5 characters are alphanumeric.\niii. Next 6 characters must be numeric\niv. Next 3 characters are alphanumeric\nv. Last 2 characters are alpha\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\nFourth and fifth characters of numeric section must be in the range 01 to 31.",
        "refined_prompt": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\"\n- \"ASD12405315AA4AA\"\nNon-match examples:\n- \"SASAS701062AB8D\"\n- \"ASD12405315AA4A\"",
        "matches": [
            "SASAS701062AB8DD",
            "OOVJW664033DAGCW",
            "ASD12405315AA4AA",
            "ABCDE101010XY9AA",
            "L81PT101045J2PJZ",
            "F4UFY6761434Y8VO",
            "PCVMQ002145D8MCC",
            "XGTOC760067R9EVK",
            "E5R6H6703194RVUT",
            "TI7XY265044RUCZQ",
            "02CQ8663081B5TKM",
            "NDAID811302OTCMP",
            "C0OMR760174Q9QPS"
        ],
        "non_matches": [
            "SASAS701062AB8D",
            "ASD12405315AA4A",
            "ABCDE101010XY9A",
            "ABD2A121010AM9FA",
            "ABCDE101010XY9A9",
            "AbCdE711215GG9aa",
            "AFG98101010AM9Fa",
            "SSSSS841215SS9SS",
            "AFG98101000AM9FA",
            "AF\u00ac98101010AM9FA",
            "ABC99808275m99sc",
            "ABCDE654321A98"
        ],
        "id": 2803,
        "output": [
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCWAB"
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW98"
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCWJ"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z][a-zA-Z\\-' ]*[a-zA-Z ]$",
        "raw_prompt": "Check for person name in database for example.\nA person name is a string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe (') and the space. For these three characters, not at the beginning or the end of the string.",
        "refined_prompt": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"",
        "matches": [
            "Pierre-Francis d'Astier de Weyergans-Migery",
            "Jeanne d'Arc",
            "Nicolas Sarkozy",
            "Charles de Gaulle",
            "Dominique Strauss-Kahn",
            "John",
            "Smith",
            "Lucky",
            "Kathryn",
            "wwefrgthyjukil",
            "jUHYGTFhujil",
            "GUyiuhTFY",
            "UYFuuiGUGugGug"
        ],
        "non_matches": [
            "-tutu",
            "tutu-",
            "'tutu",
            "tutu'",
            "tu1tu",
            "tu*tu",
            "1tutu",
            "tutu*",
            "$4",
            "98765rftghb",
            "54%",
            "12-12"
        ],
        "id": 2809,
        "output": [
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            }
        ]
    },
    {
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][ ][aApP][mM]){1}$",
        "raw_prompt": "This will validate 12 hours time format with AM/am PM/pm",
        "refined_prompt": "This will validate 12 hours time format with AM/am PM/pm\nMatch examples:\n- \"11:11 AM\"\n- \"01:11 PM\"\n- \"12:59 AM\"\nNon-match examples:\n- \"21:11 AM\"\n- \"00:00 PM\"",
        "matches": [
            "11:11 AM",
            "01:11 PM",
            "12:59 AM",
            "08:07 Pm",
            "4:37 PM",
            "7:42 aM",
            "1:49 pM",
            "12:48 aM",
            "12:20 PM",
            "02:04 PM",
            "5:24 pM",
            "6:14 aM",
            "10:12 Pm"
        ],
        "non_matches": [
            "21:11 AM",
            "00:00 PM",
            "10:70 AM",
            "10:50PM",
            "am",
            "PM",
            "12-12",
            "12/12",
            "time",
            "noon",
            "1 pm",
            "00"
        ],
        "id": 2812,
        "output": [
            {
                "text": "\nMyScheduleTimeFormat = \"^(?:[12][0-9]|[13][0-4]):[0-5][0-9]AM|[1][0-9]:[0-5][0"
            },
            {
                "text": " \"([1-9]|[1-2][0-9]|1[0-2]):[0-5][0-9]AM|([2][0-3]):[0-5][0-9"
            },
            {
                "text": " \"^[01]?[0-9]?[0-9]:[0-9]?[0-9]:[A-P][0-9]([A-P]\\s?)*$|^[0"
            },
            {
                "text": " ([a-zA-Z]|[0-9]|[1-9])([: AM]|[: PM])\n\nConclusion:\nRegEx is an essential language for Web Developers to understand and use in their work"
            },
            {
                "text": " \\s*\\d\\:\\s*\\d\\s*\\s*(PM|AM)\n\"\"\"\nimport re\nfrom datetime import datetime\n\ndatetime_regex = r'\\d:\\d\\:\\d"
            },
            {
                "text": "\n^([0-2][0-9]):([0-5][0-9]) ([AM|PM] |PM) ([0-9]+) [aA]M([aA]M)?$\n\nExercise"
            },
            {
                "text": " The RegEx will be [0-9]{2}:[0-9]{2} AM([0-9]{3})?\n- \"11:11 AM and 12:15 PM\" Create the RegEx that will validate"
            },
            {
                "text": " ^([1-2]?[0-9]:[0-9]{1,2}))($|([1-2]?[0-9]:[0-9]{1,2}\\s[0-9"
            },
            {
                "text": " \\d:00\n\n3. Find all the phone numbers with one to three digits followed by an optional dash and 3 to 5 digits.\n- Sample Phone Numbers \"123-456-7890, 345-454-5678, 123."
            },
            {
                "text": " ^(0[1-9]|1[012])(\\s\\d\\s\\d:[\\s\\d\\:\\s\\d]?\\s?)*$\n\n4. Write a Python program to check if a"
            }
        ]
    },
    {
        "expression": "(((^[>]?1.0)(\\d)?(\\d)?)|(^[<]?1.0(([1-9])|(\\d[1-9])|([1-9]\\d)))|(^[<]?1.4(0)?(0)?)|(^[<>]?1.(([123])(\\d)?(\\d)?)))$",
        "raw_prompt": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.",
        "refined_prompt": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"",
        "matches": [
            ">1.0",
            "<1.001",
            ">1.399",
            "<1B06",
            "<1T072",
            "1<0",
            "<1I015",
            "1B34",
            "100",
            ">1-05",
            "130",
            "1:03",
            ">1}014"
        ],
        "non_matches": [
            ">1.400",
            "1.",
            "1.0011",
            "23refds",
            "4356HUI*T^R&%",
            "HT^&R",
            "#",
            "3",
            "34",
            "4353",
            "$4",
            "45%"
        ],
        "id": 2816,
        "output": [
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(0?[1-9]|1[012])/(19|[2-9]\\d)\\d{2}|0?29/0?2/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY",
        "refined_prompt": "DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY\nMatch examples:\n- \"21/01/1972\"\n- \"21/1/1972\"\n- \"1/1/1972\"\nNon-match examples:\n- \"21-01-1972\"\n- \"21-01-1972\"",
        "matches": [
            "21/01/1972",
            "21/1/1972",
            "1/1/1972",
            "29/2/2012",
            "29/02/2012",
            "10/31/12/1943",
            "6/30/10/1972",
            "029/02/1908",
            "4/10/4721",
            "09/30/12/6065",
            "029/02/1908",
            "09/10/1997",
            "029/2/6156"
        ],
        "non_matches": [
            "21-01-1972",
            "21-01-1972",
            "29/02/2011",
            "234567",
            "12-12-12",
            "12/2",
            "0000",
            "date",
            "12:12",
            "12|12|1212",
            "234567890",
            "$45"
        ],
        "id": 2827,
        "output": [
            {
                "text": " ("
            },
            {
                "text": " "
            },
            {
                "text": " ("
            },
            {
                "text": " ("
            },
            {
                "text": " D"
            },
            {
                "text": " 21"
            },
            {
                "text": " ("
            },
            {
                "text": " ["
            },
            {
                "text": " "
            },
            {
                "text": " ("
            }
        ]
    },
    {
        "expression": "(Mo(n(day)?)?|Tu(e(sday)?)?|We(d(nesday)?)?|Th(u(rsday)?)?|Fr(i(day)?)?|Sa(t(urday)?)?|Su(n(day)?)?)",
        "raw_prompt": "The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions.",
        "refined_prompt": "The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions.\nMatch examples:\n- \"Mo\"\n- \"Sun\"\n- \"Monday\"\nNon-match examples:\n- \"Any\"\n- \"day\"",
        "matches": [
            "Mo",
            "Sun",
            "Monday",
            "Sunday",
            "Tues",
            "Tu",
            "Tuesday",
            "We",
            "Wednesday",
            "Th",
            "Thursday",
            "Sa",
            "Saturday"
        ],
        "non_matches": [
            "Any",
            "day",
            "week",
            "MWF",
            "78654",
            "rfe4gt53",
            "44",
            "345678",
            "erwdsa",
            "87654",
            "12",
            "sdfghjkl"
        ],
        "id": 2844,
        "output": [
            {
                "text": " (1,1) (\"Sun\")\n(2,3) (\"Monday\")\n(3,3) (\"Tuesday\")\n(4,5) (\"Thursday\")\n(5,5) (\"Friday\")\n"
            },
            {
                "text": "\n(?i)([0-9][0-9]|[1-9][a-z]|[a-z]2[0-9]|[0-9][a-z])/"
            },
            {
                "text": " [0-9]{1,2}[a-g]?[0-9]{3} \n\nA:\n\nCheck this.\n\\b(?:Jan|Feb|Mar|Apr|"
            },
            {
                "text": "\n.*[mM]|.*[Sa]|.*[Su]|.*[We]|.*[Th]|.*[Fr]|.*[Sa]|.*[Th]|.*\\|.*\n"
            },
            {
                "text": " /m\\d{2}|w\\dday|d\\dweeknite\\b/\n\n5.) Use Python to replace day abbreviations with their full names in this string.\nstring = \"Today is"
            },
            {
                "text": " \n\"Mo\" : ([a-z]){2,3}\n\"Sun\" : ([a-z]){2,3}\n\"Monday\" : ([a-z]){2,3}\n"
            },
            {
                "text": " To match any weekday that comes after Sunday and before Friday, use the following expression: [M][o]m(?:d|w)?\n- \"Thursday\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": " ^\\b(Mo|Sun|monday|TUESDAY|WEDNESDAY|FRIDAY|MON|TUES|WED|THU|FRI|SAT|SUN|BYE)\\"
            },
            {
                "text": " (^|\\s)(Mon|Tu|We|Thurs|Fri|Sat)(\\s|$)\n\n3-8\n\nWrite a single RegEx expression to match any word that begins with a consonant"
            },
            {
                "text": " \"monday\"\n- \"weekday\"Generate a RegEx for this description. \nAnswer: \"[mw]onday|[Mo]nday\" - use [ ] to be inclusive. For example, you"
            }
        ]
    },
    {
        "expression": "^([7-9]{1})([0-9]{9})$",
        "raw_prompt": "Mobile Number starts with 7,8,9 and total 10 digits",
        "refined_prompt": "Matches mobile numbers that stars with 7,8,9 and have a total 10 digits\nMatch examples:\n- \"9848457682\"\n- \"8748070871\"\n- \"9140445480\"\nNon-match examples:\n- \"123456789\"\n- \"234\"",
        "matches": [
            "9848457682",
            "8748070871",
            "9140445480",
            "8187798460",
            "7205929092",
            "7873485779",
            "8228102485",
            "7943185172",
            "9270010952",
            "7420143970",
            "7828685261",
            "7320622463",
            "9763183399"
        ],
        "non_matches": [
            "123456789",
            "234",
            "324213",
            "-8765",
            "+8765",
            "$567890",
            "8765%",
            "#4",
            "12.324",
            "12.12",
            "12/12",
            "12-12"
        ],
        "id": 3169,
        "output": [
            {
                "text": " (1)\n- (2) Generate a RegEx for this description\nAnswer: (1) \"^\\d{7}-\\d{8}-\\d{9}$\"\n- (2"
            },
            {
                "text": " A positive lookahead expression that matches a single digit that falls between two consecutive digits, either before or after a '-' character, and a positive lookbehind expression that matches a group of five digits.\nConclusion:\nIn conclusion,"
            },
            {
                "text": "\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\n"
            },
            {
                "text": " \n\n```\n^[0-8]?9?$\n```\n\n**Exercise 2:** Write a Python code that matches any URLs that start with a \"http\" or \"https\" and"
            },
            {
                "text": " a-b-c-d-e\n\n\n\nQuestion 5: A car travels at a speed of 60 miles per hour. How many kilometers does the car travel in 5 hours?\n\nSolution to Question 5:\n"
            },
            {
                "text": " The pattern is [^789]+, generated by appending \",\" to the start of the regex. \n3. Write a function to validate a phone number using RegEx. If the phone number is valid, return the string"
            },
            {
                "text": " Allow 1 to 9 digits and not start and not end with digit\n\nExercise 2: \nCreate a RegEx for the given description, so that it will only match strings containing at least one uppercase letter.\n"
            },
            {
                "text": " Use the following RegEx pattern, and verify its accuracy by testing it on a testset. \n\n^[0-9]*[1-9][0-9]{6,15}$\n\n"
            },
            {
                "text": " \n\nimport re\npattern = re.compile('^(\\d{6}[-]\\d{6}[-]\\d{6}[-]\\d{4})$')\nx"
            },
            {
                "text": " \nThe best example of \"Regular expression pattern matching\" is \"r\". \nExamples: \n\na: 1234   -  The digits are the expected first.\nb: 1A 2B   -  "
            }
        ]
    },
    {
        "expression": "^((\\+|00)[1-9]{1,3})?(\\-| {0,1})?(([\\d]{0,3})(\\-| {0,1})?([\\d]{5,11})){1}$",
        "raw_prompt": "International phone number with 6 capturing groups:\ninternational prefix (00 xor '+');\n1 to 3 international code number, no zero allowed;\noptional space or hyphen;\n0 to 3 local prefix number;\noptional space or hyphen;\n5 to 11 local number without spaces or hyphens;",
        "refined_prompt": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91)12345678\"",
        "matches": [
            "0034 91 12345678",
            "+39-2-1234567",
            "9112345678",
            "-5200553",
            "844001",
            "00936 0029092",
            "-92730",
            "4551720",
            "+918618376322",
            "+4 76 33954021871",
            "8429837872",
            "+5827195410",
            "-84599725"
        ],
        "non_matches": [
            "0034 91 123-456-789",
            "(91)12345678",
            "0034 (91)12345678",
            "(8765)",
            "32",
            "-",
            "+9",
            "$567",
            "8765%",
            "43e",
            "43eds",
            "54re3"
        ],
        "id": 3207,
        "output": [
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91)123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) +"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91)123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            }
        ]
    },
    {
        "expression": "((0[1-9])|(1[0-9])|(2[0-9])|(3[0]))/((0[1-9])|(1[0-2]))/14[3-9]{2}",
        "raw_prompt": "Matches DD/MM/YYYY for Arabic Hijri Dates. It starts range from 1434 ( current year ) to 1499",
        "refined_prompt": "Matches DD/MM/YYYY for Arabic Hijri Dates. It starts range from 1434 ( current year ) to 1499\nMatch examples:\n- \"29/12/1434\"\n- \"01/02/1435\"\n- \"30/11/1434\"\nNon-match examples:\n- \"31/12/144\"\n- \"01/2/1435\"",
        "matches": [
            "29/12/1434",
            "01/02/1435",
            "30/11/1434",
            "30/09/1494",
            "26/01/1483",
            "02/10/1448",
            "26/05/1468",
            "07/03/1484",
            "06/03/1445",
            "14/08/1438",
            "02/08/1486",
            "26/04/1468",
            "30/12/1443"
        ],
        "non_matches": [
            "31/12/144",
            "01/2/1435",
            "5/5/1435",
            "12/12",
            "12-12",
            "12-12-1212",
            "2134567",
            "+098765",
            "-987654",
            "date",
            "august 5th",
            "76rdfg"
        ],
        "id": 3219,
        "output": [
            {
                "text": " (\\d{1,2})(\\/|\\-|\\/|\\(|\\)|\\.|\\(|\\) |\\/"
            },
            {
                "text": "\n\n```python\ndef create_regex_pattern(date_format):\n    patterns = []\n    for i"
            },
            {
                "text": " /(?<month>0[1-9]|1[012]):[0-9]/ /(?<"
            },
            {
                "text": " (2 numbers followed by 2 numbers following 3 numbers)\n- \"25/12/1435\"\nExercise #2:\n"
            },
            {
                "text": " ^(([0-9]{2})/([0-9]{2})/([0-9]{4}"
            },
            {
                "text": " \n\nimport re\nregex = r'(0?[1-9]|1[012])/(0?["
            },
            {
                "text": "\n@\"^([0-9]{1}\\.[0-9]{2})\\/(0[1-9]"
            },
            {
                "text": " [01][0-9]|2[0-3]\nI need to write a program that should take a String and break"
            },
            {
                "text": "\n[01]\n\\d{1,2}[\\/][0-9]{1,2}[\\/][0"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4}\n- \"01/31/1435\"Accept"
            }
        ]
    },
    {
        "expression": "^(0|\\+33)[1-9]([-. ]?[0-9]{2}){4}$",
        "raw_prompt": "Match french phone number with or without french international dialling code",
        "refined_prompt": "Match french phone number with or without french international dialling code\nMatch examples:\n- \"+33622313131\"\n- \"02 02 02 02 02\"\n- \"0303030303\"\nNon-match examples:\n- \"+34622313131\"\n- \"1702020202\"",
        "matches": [
            "+33622313131",
            "02 02 02 02 02",
            "0303030303",
            "+331.4690.34 47",
            "+331 496409.08",
            "07 1785-81-31",
            "07-31.06-0072",
            "+3325537-99-41",
            "03510025-43",
            "01-23 17.66.08",
            "+3364933 17-14",
            "05721136 91",
            "+3314131 28-24"
        ],
        "non_matches": [
            "+34622313131",
            "1702020202",
            "23",
            "12/12",
            "12-12",
            "12.12",
            "$56789",
            "-98765",
            "4567%",
            "32ewds",
            "4f3rec",
            "####"
        ],
        "id": 3228,
        "output": [
            {
                "text": " [+336, +226, +3]\n\nExamples:\n- A phone number can be matched by its international dialling code if and only if it contains two to three numbers that are either 00, 10 or 11. For example, \"+34 123 4"
            },
            {
                "text": " [+\\d\\d-\\d\\-\\d\\-\\d\\-\\d] where : \\d is any digit.\n\n2) Create an Regex that filters text for any numbers.\n\nSome ideas to consider: \n- Consider different"
            },
            {
                "text": " \nMatch: (\\+\\w+\\(\\d{3}\\)\\s){1,4}\nNon-match: (\\+\\w+\\(\\d{3}\\)){1,4}\nYou know more about regex at"
            },
            {
                "text": "\n\\+(\\d\\d\\d)[[0-9-]{2}\\]\nExamples of US phone numbers:\n- +10 10 10 10 10 \n- +1 800 3254 6364\n- +1 10 10 10 10"
            },
            {
                "text": "\n\nA:\n\nUse two lookaheads. The first one says that only digits may come after a non-digit:\n^[0-9]?[ \\t]*\\+[ \\t]?[0-9]?"
            },
            {
                "text": " \"([+]|3[0-6])[0-9]{3}\"\nHere is the explanation of the pattern [+]|3[0-6]:\n\n(optional symbol, '+' or 3)\n[0-"
            },
            {
                "text": " \n```\n# +33622313131\n# ^(\\+35\\d{3})?(\\+[0-9]+)?(\\[?[0-9a-zA-Z]{0,4}\\?[0"
            },
            {
                "text": " ^[0-9]{4}[0-9]{3}[0-9]{2}[0-9]{2}[0-9]-[0-9]{4}[0-9]{3"
            },
            {
                "text": "\n\nI have a question about generating a RegEx for this description. I need to extract the 3 and the 32 numbers from a string that looks like:\n\n+33622313131\n02 02 02 02 02\n0303030303\n\nI"
            },
            {
                "text": " (\\+|\\w)+\\d{3}(\\+|\\w[^-]*)?\n#\n\nAnswer: \n[a-zA-Z]+[0-9]{3}[a-zA-"
            }
        ]
    },
    {
        "expression": "^(\\d?)*\\.?(\\d{1}|\\d{2})?$",
        "raw_prompt": "Expression to validate currency formatted numbers without the currency symbol. This is an updated version of my previous expression and now works in ASP.NET regular expression validators.",
        "refined_prompt": "Expression to validate currency formatted numbers without the currency symbol.\nMatch examples:\n- \"153\"\n- \"33.48\"\n- \"786.1\"\nNon-match examples:\n- \"-123\"\n- \"8524.258\"",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33",
            "82620488732013362401002347289597345549580362775",
            "2656254197019330262321471387006506127493056032004370440",
            "1311244136524109600515669070575811020331240032815399.",
            "443946045269136478024586026599.",
            "64428461059046924271793448.1",
            "5833212769801702132419173010140466290563",
            "8742104836584323.87",
            "32636373432149873597766966.",
            "5024936454117752195698822273485385331"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45",
            "+87654",
            "$456789",
            "8765%",
            "8392iuyg",
            "###",
            "(765)",
            "32e",
            "num",
            "876tr5dRTYU"
        ],
        "id": 3234,
        "output": [
            {
                "text": " \"0123|5?3(8|9)\"\n\n# 18.2.9 Using the math module for mathematical constants and functions\n\nThe `math` module provides a set of functions for performing common mathematical operations. These functions use the `math` constant, which is a symbolic"
            },
            {
                "text": " (.*)$\n\n```Python\n# Write your code here \nimport re\n\ntext = '153,33.48,786.1,-123,8524.258'\nregex = r'([\\w\\s-]*)([,.0-"
            },
            {
                "text": " Use a positive lookahead assertion in the middle of the Regex to match all numbers.\n\n```python\nimport re\n\nnumbers = [\"153\", \"33.48\", \"786.1\", \"-123\", \"8524.258\"]\n\npattern = r\"^["
            },
            {
                "text": " The pattern to match a valid integer number is \\d+\\.\\d+, which consists of one or more digits with a single point, followed by a dot, then one or more digits. The pattern to match a valid currency number is [0-9]{3}.\\d{3}"
            },
            {
                "text": " r'^(?:[^.\\-\\d]|(-?\\d+(?:\\.\\d*)?)[^.\\-\\d])+$'\n\n# End of Solution\n\n## End of Section\n\nRemember, while creating Regex patterns, you should think about"
            },
            {
                "text": " \\d+(?:\\.\\d+)\n\n2. Write a Regex that validates a string containing dates with either 3 or 5 digit numbers separated by -. \nExample: Valid Dates - 01/01/2016, 02/09/2016, 04-22-2016, 22"
            },
            {
                "text": " Non-match - RegEx to validate currency formatted numbers without the currency symbol.\n7.4.9.6.1 Use Regex for Email Validation.\nDescription: Regular expressions can be used to validate email addresses.\n\nExample:\nTo verify if an email address follows a standard"
            },
            {
                "text": " \n\"(?!^)(?=\\\\d*\\\\.\\\\d+)(?![^\\\\d\\\\.]+\\\\s?)[^\\\\d]+(\\\\.\\\\d+)?\"\n\nExercise 4:\nGiven a list of strings containing names of various fruits, write a Python"
            },
            {
                "text": " \n^[0-9]{1,3}(?:\\.[0-9]{1,3})?$|^[0-9.][0-9]{9}$\n\n2. Suppose a new set of numbers has been entered by the user,"
            },
            {
                "text": " [^0-9.-]+\n\n4. Use the \"^\" character to find if the beginning of the string is a match to the pattern \"^abc\".\n\nMatches : \"abcd\"\nNon-matches : \"ab0c\".\n\n5. Use the"
            }
        ]
    },
    {
        "expression": "^(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4})|(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4}))[ ]([0|1][0-2])[:](([0-5][0-9]))([:](([0-5][0-9])))?)$",
        "raw_prompt": "this regular expression accepts date and optinal time with format\n(dd)[.-/](MM)[.-/](yyyy)[ ]\n(hh)[:](mm)[:](ss)",
        "refined_prompt": "accepts date and optinal time with format\r\n(dd)[.-/](MM)[.-/](yyyy)[ ]\r\n(hh)[:](mm)[:](ss)\nMatch examples:\n- \"01-01-2014 10:50\"\n- \"01/01/2014 10:50:59\"\n- \"11-10-2012\"\nNon-match examples:\n- \"01-01-2014 10:60\"\n- \"32-01-2014 10:50\"",
        "matches": [
            "01-01-2014 10:50",
            "01/01/2014 10:50:59",
            "11-10-2012",
            "3|.10.3059",
            "10-07/4711 11:00:11",
            "|1.10.7248 |0:04",
            "21/11/9170 01:46:14",
            "23.05.7387 |0:34:34",
            "07-08/6724",
            "06/10/9781 01:41:45",
            "30-06-4116 02:47",
            "07-08/6088 00:55:36",
            "17/01/6890"
        ],
        "non_matches": [
            "01-01-2014 10:60",
            "32-01-2014 10:50",
            "01-13-2014 10:50",
            "3245678",
            "5432",
            "21",
            "3456789",
            "567454",
            "12/12",
            "12-12",
            "date",
            "12.12"
        ],
        "id": 3264,
        "output": [
            {
                "text": " You can combine regular expression for two"
            },
            {
                "text": "  (^0-9\\\\"
            },
            {
                "text": " (^(0?[1"
            },
            {
                "text": " \\d{1}-\\"
            },
            {
                "text": " (?i)((?:["
            },
            {
                "text": "\nMatch description: \"11/"
            },
            {
                "text": " 12.\\d[-:"
            },
            {
                "text": " \\d\\d:\\d\\"
            },
            {
                "text": " r\"^([0-9"
            },
            {
                "text": "\n\n1. ddMmm"
            }
        ]
    },
    {
        "expression": "^([0-9]{4})([0-9]{5})([0-9]{1})$",
        "raw_prompt": "The INN code is formed by:\nthe code of the tax department where INN was given (4 numbers), the record number of a registered company in the territorial section of the Unified State Register of Legal Entities in the tax department where INN was given (5 numbers), check digit (1 numbers)",
        "refined_prompt": "Matches INN code is formed by:\r\nthe code of the tax department where INN was given (4 numbers), the record number of a registered company in the territorial section of the Unified State Register of Legal Entities in the tax department where INN was given (5 numbers), check digit (1 numbers)\nMatch examples:\n- \"1234567891\"\n- \"6121546557\"\n- \"2996330885\"\nNon-match examples:\n- \"-\"\n- \"23\"",
        "matches": [
            "1234567891",
            "6121546557",
            "2996330885",
            "9071143858",
            "6831050660",
            "5032286810",
            "5643661741",
            "4289211487",
            "5130348925",
            "3124211984",
            "1203313918",
            "4960218069",
            "4205611860"
        ],
        "non_matches": [
            "-",
            "23",
            "234",
            "4freds",
            "34256",
            "654",
            "########",
            "$4567",
            "12/12",
            "9932.234",
            "4342",
            "9876443456789098765456789"
        ],
        "id": 3277,
        "output": [
            {
                "text": "\n- {INN}"
            },
            {
                "text": " (0-9)(0"
            },
            {
                "text": " (^[\\d]"
            },
            {
                "text": " [A-Za-"
            },
            {
                "text": " \\d{8}("
            },
            {
                "text": " \n[a-z"
            },
            {
                "text": "\n_[1-9"
            },
            {
                "text": " \"^\\d{8"
            },
            {
                "text": " ^[0-9]"
            },
            {
                "text": " \"\\\\b[13-"
            }
        ]
    },
    {
        "expression": "^([0-9]{1})([0-9]{2})([0-9]{2})([0-9]{7})([0-9]{1})$",
        "raw_prompt": "The OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)",
        "refined_prompt": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \"23\"",
        "matches": [
            "1234567891234",
            "0175106545632",
            "5969169407468",
            "6123158937485",
            "6423933815629",
            "5573896389764",
            "3982998881161",
            "8545973921523",
            "0707207053700",
            "1299659347786",
            "0246919033615",
            "9060347655405",
            "7652089273422"
        ],
        "non_matches": [
            "-",
            "23",
            "3214",
            "123",
            "#3",
            "#########",
            "12/12",
            "12-12-12",
            "werrfghtjk",
            "4532",
            "23213433253453451234242343214222",
            "34213241542t56769867956487594"
        ],
        "id": 3278,
        "output": [
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            }
        ]
    },
    {
        "expression": "^((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|[1][02])([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[1][0-9]|[2][0-8])([/])(02)([/])(19[0-9][0-9]|20[0-9][0-9]))|((29)([/])(02)([/])(190[48]|19[13579][26]|19[2468][048]|20[02468][048]|20[13579][26]))$",
        "raw_prompt": "This pattern validates dates with slash (/) separator and with years between 1900 and 2099.",
        "refined_prompt": "This pattern validates dates with slash (/) separator and with years between 1900 and 2099.\nMatch examples:\n- \"01/01/1900\"\n- \"05/12/2014\"\n- \"31/12/2099\"\nNon-match examples:\n- \"41/01/1900\"\n- \"21/31/2014\"",
        "matches": [
            "01/01/1900",
            "05/12/2014",
            "31/12/2099",
            "12/02/1928",
            "29/02/1964",
            "29/04/1975",
            "01/04/2045",
            "01/02/2090",
            "29/02/2024",
            "28/10/2006",
            "30/09/2014",
            "05/02/2029",
            "30/06/1902"
        ],
        "non_matches": [
            "41/01/1900",
            "21/31/2014",
            "21/12/1899",
            "21/12/2100",
            "12-12-12",
            "date",
            "12/12/12",
            "13245678",
            "2342",
            "0.0",
            "12",
            "123456789"
        ],
        "id": 3280,
        "output": [
            {
                "text": "\n((0|[1-9])\\d?(0|60)?|0[1-9](1[012])|20?[0-9])(/|"
            },
            {
                "text": "\nre.compile(r\"[0-9]{4}/(0\\s*)?[0-9]{2}[/0\\s*]?(0\\"
            },
            {
                "text": " \"^[0-9]{2}/(0[1-9]|[12]\\d|3[01])/\" (where [0-9] means digit,"
            },
            {
                "text": " (\\d{0,2})/(\\d{0,2})/(\\d{2} or (20\\d{2})(?!20))\")\"\n\nEx"
            },
            {
                "text": " For the above examples the separator is '/', so our RegEx will be `(\\\\d{1,2})/(\\\\d{1,2})/(\\\\d{"
            },
            {
                "text": " https://regex101.com/r/2MwJh/1\n\n**Exercise 2.5**: Write code that converts dates formatted in \"day/month/"
            },
            {
                "text": " The pattern for this task is \\d{1,2}/\\d{1,2}/\\d{4}\\b.\n\n```python\nmatch = re."
            },
            {
                "text": " A date can have slashes \"/\" or numbers between 1900 and 2099. \n\nExercise 5: Write a RegEx that matches any phone number in the form \"xxx-xxx"
            },
            {
                "text": " [0-9]?[1-9][0-9]/[0-9]/[0-9][0-9][0-9]\" - This pattern will"
            },
            {
                "text": " https://regex101.com/r/h7U8n2/1/3\n\n6. Exercise 2: Password Creation\nExercise:\nCreate a password validation regex"
            }
        ]
    },
    {
        "expression": "^[1-9][0-9][0-9][0-9][0-9][0-9]$",
        "raw_prompt": "picode test",
        "refined_prompt": "Matches 6 digit pin codes\nMatch examples:\n- \"221001\"\n- \"929803\"\n- \"304135\"\nNon-match examples:\n- \"abcdd\"\n- \"ewrtyu\"",
        "matches": [
            "221001",
            "929803",
            "304135",
            "957924",
            "390543",
            "962831",
            "484081",
            "122937",
            "624889",
            "689953",
            "123367",
            "535820",
            "375211"
        ],
        "non_matches": [
            "abcdd",
            "ewrtyu",
            "werty",
            "ertyuh",
            "RTY",
            "WERTYU6543E",
            "IJOUHYgtfvgbhn876tJ",
            "gfdreFVGBG54",
            "hgrFVGGt654ed",
            "BGFF",
            "pincode",
            "######"
        ],
        "id": 3347,
        "output": [
            {
                "text": " (6 character PIN, letters A-Z and 1-9). {3})\n\nConclusion:\n\nIn this script, we learned about how MySQL and regular expressions can be used to perform CRUD operations as a network security specialist. We explored how to create tables, insert and delete data, query and manipulate tables,"
            },
            {
                "text": " \"^[a-z][a-z]+[0-9a-z][0-9a-z]+[0-9a-z]$\"\n\nExercise 3: Password Compliance\nExercise: Write a Python code snippet to check if a given password meets the following requirements:\n-"
            },
            {
                "text": ".+[a-z]+[0-9].+\nExercise 2: \nWhat are the benefits of using RegEx for passwords?\nAnswer: RegEx can help us create stronger and unique password combinations that are less likely to be guessed by hackers, keeping our accounts and identities safe.\nExercise 3"
            },
            {
                "text": " r\"^[a-z]{1,6}\" \n\nExercise: Given a text, extract all email addresses that match the format specified. \nAnswer: \nSuppose we have a text that looks like this:\n\nI would like to talk to you about the latest advances in nanotechnology"
            },
            {
                "text": " All the match examples must start with the letter \"W,\" for \"7\", for\n  \"26\", and for \"5\". All the non-match examples start with non\n  letters, contain digits, or contain more than 3 digits.\n\n### Example\n```python\n#Exercise 1 Solution\nimport"
            },
            {
                "text": " Only 6-digit pin codes. The first example matches, and the second one does not.\n\nExercise 3: Match Email Subject Lines:\nMatch the subject line of the following emails. Select the best matching option.\na) Your order details have arrived at 123 Main Street, USA.\nb) Your order"
            },
            {
                "text": " a(0-9)+b or b(0-9)+a\n\n2. If a user enters the PIN (12345678 or 123456789), a regex should check that all numbers are 9 digits long\nAnswer: ([1-9]\\d{9})\n\n3. Extract the first"
            },
            {
                "text": " RegEx must match 6 or more alphanumeric characters.\n\n6. Write a Python program that prompts the user for a sentence and then uses regular expressions to count the number of words in the sentence. \n```python\nimport re\n\nsentence = input(\"Enter a sentence: \")\nword_"
            },
            {
                "text": " \n\nExercise: Write a RegEx for identifying all images within HTML tags. Answer: HTML Regex = [\\\"\\(\\<img>[^>]+\\)\\]\\\"]\n\nExercise: Write a RegEx for identifying all email addresses within text. Answer: Email Regex = /[a-"
            },
            {
                "text": " \"^[a-zA-Z0-9]*-[a-zA-Z0-9]*-([0-9]{3})$\"\n- \"^[a-zA-Z]*(-)?[0-9]{3}(-)?[0-9"
            }
        ]
    },
    {
        "expression": "^((19[0-9][0-9])|(20[0-1][0-5]))\\-((0?[1-9])|(1[0-2]))\\-((0?[1-9])|([1-2][0-9])|(3[0-1]))$",
        "raw_prompt": "Year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits.",
        "refined_prompt": "Matches year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits.\nMatch examples:\n- \"2012-05-21\"\n- \"1960-12-14\"\n- \"1910-5-3\"\nNon-match examples:\n- \"2011/5/21\"\n- \"60-12-14\"",
        "matches": [
            "2012-05-21",
            "1960-12-14",
            "1910-5-3",
            "1924-02-18",
            "2010-06-31",
            "2013-5-12",
            "2004-12-14",
            "1940-10-31",
            "1911-09-31",
            "1915-12-01",
            "1940-7-31",
            "2003-05-17",
            "2005-11-28"
        ],
        "non_matches": [
            "2011/5/21",
            "60-12-14",
            "2021-5-3",
            "12/12/12",
            "12:12:12",
            "12:12:20",
            "12-12-2020",
            "noon",
            "03",
            "$45",
            "date",
            "5%"
        ],
        "id": 3349,
        "output": [
            {
                "text": " (.*-.*-.*)\nExample: Match: 2012-05-21\nExpected output: \"2012-05-21\"\nExample: Match: 2011/"
            },
            {
                "text": " [0-9]{4}-[0-9]{2}-[0-9]{2}\"\n\nExercise 3:\nMatch this pattern:\n"
            },
            {
                "text": " 2011/5\\-6-4\"generate a RegExp for this description. \n\n5. Write a RegEx to validate credit card numbers.\nExample credit card"
            },
            {
                "text": " (\\d{4})-(\\d{2})-(\\d{2})\n\n3. Write a regular expression that will match words that contain between 2 and 4"
            },
            {
                "text": " ^(\\d{4})(-(?:\\d{2})-)?((?:\\d{2})?)$\n\nExercise 3: In the following sentence,"
            },
            {
                "text": " (Example) 2010\\/(1?\\d{3}|2\\d{3})\\-(3?\\d{2}|\\d{2})\\/"
            },
            {
                "text": "\n(2010|2011|2012)\\/(2[0-9])(0[1-9])\\-(1[0-2])(0[1-"
            },
            {
                "text": " [a-z]+-\\d+-\\d{2}\n\nExercise 2:\nMatch examples:\n- \"21-05-03\"\n-"
            },
            {
                "text": " Year part should be 4 digits (year) and Month and day can only be numbers, and can only be between 1 and 99.\n\n3. Describe the difference between"
            },
            {
                "text": " \nyear - [0-9]{4}\nmonth [0-9]{2}\nday [0-9]{2}\n\"\"\"\n\n"
            }
        ]
    },
    {
        "expression": "^([A-Z]{1}\\w{1,3}) (\\d{1}[A-Z]{2})$",
        "raw_prompt": "simple validation of a UK postcode.\nExamples of valid:\nAA9A 9AA\nA9A 9AA\nA9 9AA\nA99 9AA\nAA9 9AA\nAA99 9AA",
        "refined_prompt": "Matches UK postcode.\r\nExamples of valid:\r\nAA9A 9AA\r\nA9A 9AA\r\nA9 9AA\r\nA99 9AA\r\nAA9 9AA\r\nAA99 9AA\nMatch examples:\n- \"EC1A 2BB\"\n- \"WyMM 8YE\"\n- \"IwSy 1KR\"\nNon-match examples:\n- \"111A 1BB\"\n- \"234567\"",
        "matches": [
            "EC1A 2BB",
            "WyMM 8YE",
            "IwSy 1KR",
            "NA1 3ZE",
            "WWiC 8TW",
            "QbM 4YE",
            "JF 5QO",
            "TCsL 1TU",
            "ET 6CY",
            "Nisg 1IY",
            "TZON 1VV",
            "A1 6QG",
            "DB 4AV"
        ],
        "non_matches": [
            "111A 1BB",
            "234567",
            "34rgtr",
            "plate",
            "u7tfgy",
            "f4ugh495",
            "IHUY78y34rhes",
            "4iueh&Y*f",
            "HHu8uUhu8",
            "fr245(*y",
            "UHU894fre",
            "HHHUH8989br"
        ],
        "id": 3368,
        "output": [
            {
                "text": " (examples are only for demo purposes)\r\n- AA"
            },
            {
                "text": " \"^10[0-9][0-9][A"
            },
            {
                "text": " (\\d{1}\\s*-\\d\\s"
            },
            {
                "text": " (^)(\\d+)\\s(\\d+)\\s"
            },
            {
                "text": " \n^[0-9]\\d[-0"
            },
            {
                "text": "\n\\b[A-Z][a-z\\s"
            },
            {
                "text": " \"(\\d{1})([A-Z])["
            },
            {
                "text": " R\\b(?=\\d+), \\w+,"
            },
            {
                "text": " EE2E9E9E9E9E9E"
            },
            {
                "text": ".*?[A-Z]$*.[0-"
            }
        ]
    },
    {
        "expression": "[0-9]{2}-?[DF][A-Z]{2}-?[0-9]{1}|[DF][A-Z]{1}-?[0-9]{3}-?[A-Z]{1}|[DF]-?[0-9]{3}-?[A-Z]{2}|[DF][A-Z]{2}-?[0-9]{2}-?[A-Z]{1}$",
        "raw_prompt": "Check for dutch moped licenseplate number validity",
        "refined_prompt": "Matches dutch moped license plate number validity\nMatch examples:\n- \"D-123-AS\"\n- \"D123AS\"\n- \"F-123-SA\"\nNon-match examples:\n- \"Others\"\n- \"moped\"",
        "matches": [
            "D-123-AS",
            "D123AS",
            "F-123-SA",
            "F123SA",
            "F534CM",
            "38FLF8",
            "D612UY",
            "FFN-27B",
            "71DBX8",
            "D-071ZK",
            "85-DLD-3",
            "DPP19-X",
            "F829VS"
        ],
        "non_matches": [
            "Others",
            "moped",
            "license plate",
            "34r5trf",
            "frgtyh645",
            "54vcv",
            "u878^&",
            "uyg^T",
            "UYGUGYY88hvgGGG",
            "HJgfyugt897tyg",
            "GYYgy87",
            "eufgduw"
        ],
        "id": 3380,
        "output": [
            {
                "text": "\nThe following RegEx pattern should be used to match all of the license plate numbers shown above, and generate all possible matches for all combinations of letters:\n\"^[A-Z]{1,2}[0-9]{2}$|^[0-9"
            },
            {
                "text": " \"^(?:[a-zA-Z0-9]{1,2}\\s)?([a-zA-Z0-9]{1,3}\\-\\s?[a-zA-Z0-9]{1,7})$"
            },
            {
                "text": " ^(A-S|F|C)(M|F)$\n\nExercise 2: Create a program that takes a user's full name (first and last), and returns a welcome message for each last name they identify as males (i.e. \"Hello, Mr."
            },
            {
                "text": " (inclusive brackets to get both \"dutch moped\" and \"Other types of moped\") [\\d-]*[A-Z]\\-\\d\n\nExercise 4:\nMatch this description of a car with a regEx pattern:\n- \"Sport"
            },
            {
                "text": " [M-d]+([A-Za-z]+){0,1}-([0-9]{3})-([0-9]{3}-?)?([0-9]{3})?\n\nExercise 2\n\nWrite a RegEx"
            },
            {
                "text": "\n[0-9]\n\nExercise 5: Matching phone numbers to landlines\nMatch this phone number format against its corresponding landline.\nMatch examples:\n123-456-7890\n456-123-7890\n789-123-4567\nLandline"
            },
            {
                "text": " [\"D-\", \"123\", \"-\", \"AS\"]. \n\n2) Determine the number of characters in the string.\nMatch examples:\n- \"This is a sample string\"\n- \"All strings consist of at least one character\"\nNon-match examples:"
            },
            {
                "text": " \n\nOther examples: \n- \"1234-D2-S\"\n- \"1234S\"\n- \"124-D2-S\"\nMatch examples:\n- \"T-234-A\"\n- \"T-234As\"\n- \""
            },
            {
                "text": "\nmoped = \"^[A-Z]{2}\\d{3}{A-Z}$\"\nExamples of correct passwords\n- Password: dD123\n- Password: A123\n- Password: F3G456\n- Password: 456E789\n"
            },
            {
                "text": " \n- [a-z]\\d*(-[a-z]\\d*)?\n\nExercise 8:\nMatch phone numbers\nMatch examples:\n123-456-7890\n987-654-3210\n345-639-8765\n\n"
            }
        ]
    },
    {
        "expression": "\\(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\)",
        "raw_prompt": "This regex finds the IPs in its route. This uses the UNIX Bash 'traceroute' command's IP format",
        "refined_prompt": "Matches IPs addresses. This uses the UNIX Bash 'traceroute' command's IP format\nMatch examples:\n- \"(8.8.8.8)\"\n- \"(127.0.0.1)\"\n- \"(58.5.15.18)\"\nNon-match examples:\n- \"(a.sg.af.)\"\n- \"8.8.8.8\"",
        "matches": [
            "(8.8.8.8)",
            "(127.0.0.1)",
            "(58.5.15.18)",
            "(9.00.12.124)",
            "(4.2.247.877)",
            "(0.718.30.0)",
            "(1.554.02.841)",
            "(6.55.410.3)",
            "(558.08.9.53)",
            "(8.57.32.27)",
            "(21.4.43.8)",
            "(6.13.025.740)",
            "(65.0.574.1)"
        ],
        "non_matches": [
            "(a.sg.af.)",
            "8.8.8.8",
            "3245678",
            "(84)",
            ".34.34",
            "(.)",
            "IP",
            "LINUX",
            "56789.8765",
            "34.2324.",
            "31223.432.2343.4213.234.2342",
            "5443.354.35"
        ],
        "id": 3381,
        "output": [
            {
                "text": " \\.(9|10|11|12|13|14|15|16|17|18|19|20|21|22)"
            },
            {
                "text": " '(?=.*[.])(?![0-9]{1,3}\\.)(?:[0-9]{1,3"
            },
            {
                "text": " (?i)\\[(?:([0-9]\\.){6}[0-9])]*\\)\n\n## Section 4"
            },
            {
                "text": " (8\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{"
            },
            {
                "text": " (^(?:[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+)\\.(?:"
            },
            {
                "text": " ^(([[0-9.][0-9]+\\\\.)+10[0-9])-(.*?)([0-9]+\\\\"
            },
            {
                "text": "\n- \\((?P<ip_address>[0-9]{1,3}\\.){3}(?P<subnet"
            },
            {
                "text": " [a-z0-9 - : ]+[(\\.\\.)]{1,3}[a-z0-9 -"
            },
            {
                "text": " ip-address-like format, or IPv4, IPv6 or IANA/IPv4/IPS address format.\n\n2"
            },
            {
                "text": " \"(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\"\n\nExercise 3:\nWrite a Reg"
            }
        ]
    },
    {
        "expression": "^([A-z]{2}\\d{7})|([A-z]{4}\\d{10})$",
        "raw_prompt": "UK Parcelforce delivery tracking code for internal UK posts. Comes in two formats 2 letters and 7 numbers (e.g. AA1234567) and 4 letters and 10 numbers (e.g. AAAA1234567890). Case insensitive.",
        "refined_prompt": "Matches UK Parcelforce delivery tracking code for internal UK posts. Comes in two formats 2 letters and 7 numbers (e.g. AA1234567) and 4 letters and 10 numbers (e.g. AAAA1234567890). Case insensitive.\nMatch examples:\n- \"AA1234567\"\n- \"AAAA1234567890\"\n- \"JY7712375\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "AA1234567",
            "AAAA1234567890",
            "JY7712375",
            "bJ8510300",
            "Rq2086860",
            "rFFH6577541147",
            "Hi2791279",
            "jMgi4477954860",
            "Wv3215163",
            "Hk2856684",
            "]CMU3926045687",
            "EJX]4546430558",
            "DsNm4593829026"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples",
            "hy7t663defc",
            "34f34ev",
            "435ygtr",
            "45gtrJIHUYGT",
            "efrwth54rwfd",
            "efnkjUYTvyuyg78",
            "erf8756bHGcfthu",
            "f4re^&ff",
            "$45"
        ],
        "id": 3383,
        "output": [
            {
                "text": "\n^(?:[a-zA-Z]+)?["
            },
            {
                "text": " \"*[a-zA-Z][a-zA"
            },
            {
                "text": " 1. \"^[A-Z]{1}(?"
            },
            {
                "text": " ([a-z0-9]+)\n#5 \n"
            },
            {
                "text": " ([^a-zA-Z0-9])([0"
            },
            {
                "text": " A RegEx for matching this description is [^^][^]["
            },
            {
                "text": " ^((?!(AA|BB|CC|DD|EE|"
            },
            {
                "text": " /(?:^|[^a-zA-Z]"
            },
            {
                "text": " Non-matching and matching. Note that non-matching is"
            },
            {
                "text": " ^[A-Z0-9]{6}[0"
            }
        ]
    },
    {
        "expression": "^([A-z]{2}\\d{9}[Gg][Bb])|(\\d{12})$",
        "raw_prompt": "UK Parcelforce delivery tracking code for international tracking of exports. Comes in two formats: 2 letters and 9 numbers and GB (e.g. AA123456789GB) and 12 numbers (e.g. 123456789012). Case insensitive.",
        "refined_prompt": "Matches UK Parcelforce delivery tracking code for international tracking of exports. Comes in two formats: 2 letters and 9 numbers and GB (e.g. AA123456789GB) and 12 numbers (e.g. 123456789012). Case insensitive.\nMatch examples:\n- \"AA123456789GB\"\n- \"123456789012\"\n- \"JW114554115GB\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "AA123456789GB",
            "123456789012",
            "JW114554115GB",
            "968624923500",
            "^L809816187gb",
            "947733690091",
            "R^768258000gb",
            "Fs317433507gb",
            "044702913182",
            "Ua243127568Gb",
            "578094898939",
            "155269098434",
            "tB011083276Gb"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples",
            "FTGVJHUHYG8y7t6rtyf",
            "32fewsc",
            "4fewdsc98yiuhk",
            "tguyhb3ewds",
            "njhuytt",
            "IUGYTRYDTFCGHV",
            "efdiwu&^Ttyftuyg",
            "f34ewds7t8yi",
            "hy7t66"
        ],
        "id": 3384,
        "output": [
            {
                "text": " (https://regexr.com"
            },
            {
                "text": " A character class of one or more letters"
            },
            {
                "text": " The pattern should be \"(^[a"
            },
            {
                "text": " r'(^[A-Z"
            },
            {
                "text": "\n- r\"^(\\s)?"
            },
            {
                "text": " (Example) \n(case /"
            },
            {
                "text": " \n\nExercise 5: Password"
            },
            {
                "text": " [^[A-Za-"
            },
            {
                "text": " Use the regular expression: ^((?"
            },
            {
                "text": " \n- \"(JW)\\("
            }
        ]
    },
    {
        "expression": "^[A-z]{2}\\d{9}(?![Gg][Bb])[A-z]{2}$",
        "raw_prompt": "UK Parcelforce delivery tracking code for international tracking of imports. Uses a negative look ahead to prevent it ending in GB which would be an international export code.",
        "refined_prompt": "Matches UK Parcel force delivery tracking code for international tracking of imports. Uses a negative look ahead to prevent it from ending in GB which would be an international export code.\nMatch examples:\n- \"AA123456789AA\"\n- \"`s222501350jn\"\n- \"YK497549717Tf\"\nNon-match examples:\n- \"AA123456789GB\"\n- \"AA123456789gb\"",
        "matches": [
            "AA123456789AA",
            "`s222501350jn",
            "YK497549717Tf",
            "]a850402060mL",
            "Pl836064353gi",
            "KN398950160cM",
            "tk755131768JN",
            "Cy415708352PT",
            "H\\495029367rN",
            "o]014906363bV",
            "Z\\018566877sX",
            "ZE350488757z\\",
            "hl632529674Lu"
        ],
        "non_matches": [
            "AA123456789GB",
            "AA123456789gb",
            "AA123456789Gb",
            "AA123456789gB",
            "43fec8d7uhjb",
            "r13f4reds",
            "iu89y7t6rytfg",
            "efi23fuh34rf",
            "34fre4freoUIGI",
            "FTGVJHUHYG8y7t6rtyf",
            "#",
            "$456789"
        ],
        "id": 3385,
        "output": [
            {
                "text": " \nhttps://leetcode.com/problems/importer-"
            },
            {
                "text": "\nNon-match examples: [^\\sA-Z]\nDescription"
            },
            {
                "text": "  ([^aABgBg]{4})([a-"
            },
            {
                "text": "\n/^[^GB]*?(?:GB(?!$))"
            },
            {
                "text": " ([^(A.B.C).D-Za-z]"
            },
            {
                "text": " (?<!U\\^)(?:[A-Z]{6"
            },
            {
                "text": " [^GB\\\\G]?[GB]?\n\nExercise 4"
            },
            {
                "text": "\n\\bAA\\d{5}[A-Z]{2"
            },
            {
                "text": " [^0-9]\n- \"AA123456789G\""
            },
            {
                "text": " AA(?<!GB)123456789.\n\"\"\"\n\n\n"
            }
        ]
    },
    {
        "expression": "^(?:[A-z]{2})?\\d{9}(?:[A-z]{2})?$",
        "raw_prompt": "TNT UK delivery company consignment number tracking code for TNT Track and Trace service. The system will use the 9 digit code (e.g. 123456789) or you can use the letters as shown on your consignment note (e.g. GE123456781WW). Case insensitive.",
        "refined_prompt": "Matches TNT UK delivery company consignment number tracking code for TNT Track and Trace service. The system will use the 9 digit code (e.g. 123456789) or you can use the letters as shown on your consignment note (e.g. GE123456781WW). Case insensitive.\nMatch examples:\n- \"123456789\"\n- \"GE123456781WW\"\n- \"729600602Ey\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "123456789",
            "GE123456781WW",
            "729600602Ey",
            "931409146",
            "zK253794572]d",
            "042064816^b",
            "611846132",
            "si063107134",
            "\\x203621404OT",
            "EL520652755",
            "TY504476227",
            "nc503210123",
            "893936606QU"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples",
            "3283.312.",
            "tracking",
            "314567ytgrfe",
            "34fews",
            "34565trefdef",
            "jhg543we",
            "341fq4ewr",
            "54wrgrf",
            "43fec8d7uhjb"
        ],
        "id": 3387,
        "output": [
            {
                "text": " (e.g"
            },
            {
                "text": " (([a-"
            },
            {
                "text": " a combination of letters"
            },
            {
                "text": " Regex = ("
            },
            {
                "text": " If you simply entered"
            },
            {
                "text": " [Enter your answer"
            },
            {
                "text": " The description is more"
            },
            {
                "text": ".*[^"
            },
            {
                "text": " ^[a-"
            },
            {
                "text": "\n\n[0"
            }
        ]
    },
    {
        "expression": "^\\d{4}\\/\\d{1,2}\\/\\d{1,2}$",
        "raw_prompt": "This regular expressions matches jalali dates of the form YYYY/XX/XX where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches jalali dates of the form YYYY/XX/XX where XX can be 1 or 2 digits long and YYYY is always 4 digits long.\nMatch examples:\n- \"1394/01/3\"\n- \"1365/12/31\"\n- \"1397/02/01\"\nNon-match examples:\n- \"1394/1/555\"\n- \"139/1/4\"",
        "matches": [
            "1394/01/3",
            "1365/12/31",
            "1397/02/01",
            "2586/9/66",
            "6350/9/12",
            "9325/1/98",
            "1077/7/67",
            "7807/9/57",
            "9125/35/4",
            "2109/6/23",
            "6564/9/81",
            "2702/9/04",
            "6610/1/7"
        ],
        "non_matches": [
            "1394/1/555",
            "139/1/4",
            "1/11/1394",
            "1234567",
            "date",
            "12-12-12",
            "12 12 12",
            "3 3 30",
            "09 09 09 09",
            "3245678",
            "12",
            "$45"
        ],
        "id": 3394,
        "output": [
            {
                "text": " (4 digits for year, 2 digits for month, then 1 digit for day)\n\""
            },
            {
                "text": " [0-9]{4}-(1|2)[0-9]{3"
            },
            {
                "text": " (.*)/\\s+([0-9]{2})([0-9"
            },
            {
                "text": " \\d{4}/\\D{1,2}\\d{1,2}"
            },
            {
                "text": " \\d?\\d?/\\d{2}/\\d{2}["
            },
            {
                "text": " YYYY|MM(2|3)\nExample 3: Match date of the form"
            },
            {
                "text": " (\\d{4})/(\\d{2})/(\\d{2})\n"
            },
            {
                "text": " ^\\d{2}/\\d{2}/\\d{2}$"
            },
            {
                "text": " [(2)[0-9]{2}(\\/[0-9]{2"
            },
            {
                "text": " (2 digit group of digits at least 4 digits long, then slash \"/\" then two more"
            }
        ]
    },
    {
        "expression": "[0-9]{4}[/.-](?:1[0-2]|0?[1-9])[/.-](?:3[01]|[12][0-9]|0?[1-9])",
        "raw_prompt": "Date Year-Month-Day. From http://tools.twainscanning.com/getmyregex",
        "refined_prompt": "Matches date in form Year-Month-Day\nMatch examples:\n- \"2015-08-31\"\n- \"0132/10/12\"\n- \"9345.12.31\"\nNon-match examples:\n- \"31/08/2015\"\n- \"date\"",
        "matches": [
            "2015-08-31",
            "0132/10/12",
            "9345.12.31",
            "5660-11/27",
            "5881-08-2",
            "4286-12/31",
            "1724-1.30",
            "5107/9-30",
            "3508-08-28",
            "3245.8-04",
            "6988.01/18",
            "4625/12.9",
            "9173/11-11"
        ],
        "non_matches": [
            "31/08/2015",
            "date",
            "jan 5th",
            "3rd of jun",
            "aug 6 2008",
            "121212",
            "12 12 12",
            "12 12 1212",
            "1212121212",
            "liu87y6tyg",
            "jehfef",
            "328472398472934"
        ],
        "id": 3417,
        "output": [
            {
                "text": " (year)-(month)-{days of month}.\n\n2. Match description of a valid phone number.  \n\"A 10 digit number including area number\"    \nMatch examples:\n- \"1234567890\"\n- \"0123"
            },
            {
                "text": "\n^\\d{4}-\\d{2}-\\d{2}$\n\n2. Write a regular expression to match a string that begins with \"The Quick Brown Fox\" and ends with \", Jumps over The Lazy Dog"
            },
            {
                "text": " The RegEx for your example should be \"(^(?P<Year>[0-9]{4})|(?P<Month>01(?P<Day>[1-9]))|(?P<Day>[0-9"
            },
            {
                "text": " The RegEx would start with the string, then match the date in the form of year, followed by the month and day, separated by slashes.\n\n2. Write a RegEx to match dates in the past (months after the current one)."
            },
            {
                "text": " \\b\\S+\\b.\n---\n\n#### Exercise 2\n\nWrite a regular expression to find all emails containing the \"@\" character within a block of text.\n\n```python\nimport re\ntext = \"My email is john"
            },
            {
                "text": "\n[0-9]{4}-[0-9]{2}-[0-9]{2}\n\"\"\"\nfrom typing import Any\nimport re\n\n\ndef is_date(date: str) -> bool:\n    \"\"\""
            },
            {
                "text": "\n\"^[0-9]{4}-([0-9]{2})-?[0-9]{2}$\"\n\n\n#### Exercise\n\n1. Write a Python RegEx pattern that matches a date in the"
            },
            {
                "text": " The regular expression could be written in the following format:\n\\b\\d{4}-\\d{2}-\\d{2}\\b\n\nExercise 2:\nCreate a RegEx that accepts only positive whole numbers.\nAnswer"
            },
            {
                "text": " '([0-9]+?[-/][0-9]+?[-/][0-9]+)'\n\n**Exercise 3**: Find all dates that are 7 days after today.\nHints: A date that is"
            },
            {
                "text": "\n^[\\d]{4}\\-[\\d]{2}\\-[\\d]{2}$\n\n2. Write a Python program that matches a word that starts with 'h' or'm' and has no digits.\n"
            }
        ]
    },
    {
        "expression": "(facebook|twitter|youtube)",
        "raw_prompt": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "Matches facebook, twitter, or youtube\nMatch examples:\n- \"facebook\"\n- \"twitter\"\n- \"youtube\"\nNon-match examples:\n- \"imgur\"\n- \"3e456yhtbgf\"",
        "matches": [
            "facebook",
            "twitter",
            "youtube"
        ],
        "non_matches": [
            "imgur",
            "3e456yhtbgf",
            "eqf45gtrvfd",
            "4rfgvwre",
            "snapchat",
            "43fred",
            "X",
            "g54red",
            "qrg4ruyn",
            "social media",
            "google",
            "w4jrgrd"
        ],
        "id": 3420,
        "output": [
            {
                "text": " Match any string with \"imgur\".\n\n\n\nIntroduction to Numbers- Place Value\n\nIn mathematics, place value refers to the value of a digit based on its position in a number. It helps us understand the magnitude of a number by organizing them by groups of tens, hundreds, thousands, and so on. \n"
            },
            {
                "text": " \n-[0-9]{3}\\.[0-9]{3}-[0-9]{4}\n-^[a-zA-Z]{3,20}$\n\nConclusion\nIn conclusion, while regular expressions can sometimes be a puzzle, they remain an essential tool in the"
            },
            {
                "text": " \"https?://\\S.*(?:(?:[^\\s/]*\\.)+(?![^\\s/]*)/)?[a-z0-9.-]+/\\*+([a-z]|[0-9]|[A-Za-z-]){"
            },
            {
                "text": " Match Examples\n- [0-9]{5}-[0-9]{4}.jpg\n- [a-z]+@[a-z]+\\.[a-z]+\nNon-match Examples:\n- #1234567890\n- #543234589\n-!http://"
            },
            {
                "text": " The regex should include any letter or number characters followed by \"img\".\n\nExercise 4:\nUsing the RegEx \"^https?://(www\\.)?google.com$\", write a script that validates whether a URL is from a valid website.\n\nAnswer: \nimport re\nurl ="
            },
            {
                "text": " https://regexr.com/4lqefg for fb / \\btw / m / / /3e/ /4/ / h / / b / g / f / 4/\n- \"twitter\"\n- \"3e456yhtbgf\"Generate a RegEx for this"
            },
            {
                "text": " \"^[\\w\\d.-]+\\/[\\w\\d.-]+$\"\n\n2. Write a Python loop to determine the maximum number of characters contained in a set of social media URL.\n\n```python\nURLs = ['http://facebook.com', 'https://twitter.com',"
            },
            {
                "text": " (https://www.regular-expressions.info/numeric.html) \\d\\.\\d{1,3}[^\\d,]\n\n\n\nScience SAT Exam - Internet and Online Learning\n\nPart 1: Multiple Choice Questions\n\n1. What is the significance of the Internet in the"
            },
            {
                "text": " \"imgur([a-z])\"\n\nExercise Two:\n\nFind the following emails, using the REGEX pattern provided:\n  - emails@abc.com is a pattern where \n  - the '@' symbol is optional, and can appear either at the beginning or at the end, \n"
            },
            {
                "text": " ^[a-zA-Z0-9\\s\\-]{1,80}$\n\nExercise 2:\nUse a regular expression to extract all email addresses from a text file.\nAnswer:\nimport re\nwith open(\"myemails.txt\") as f:\n    text = f"
            }
        ]
    },
    {
        "expression": "((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])",
        "raw_prompt": "IP address IPv4 (127.0.0.1) . From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "Match IP address IPv4 (127.0.0.1)\nMatch examples:\n- \"127.0.0.1\"\n- \"250.136.255.92\"\n- \"253.5.255.111\"\nNon-match examples:\n- \"127-0-0-1\"\n- \"IP\"",
        "matches": [
            "127.0.0.1",
            "250.136.255.92",
            "253.5.255.111",
            "7.250.223.5",
            "170.2.9.252",
            "250.97.253.53",
            "255.253.218.19",
            "254.251.251.250",
            "39.194.7.255",
            "226.253.251.250",
            "255.254.0.251",
            "1.2.5.251",
            "250.255.251.252"
        ],
        "non_matches": [
            "127-0-0-1",
            "IP",
            "231/12312/123",
            "5432",
            "31245678",
            "juytfvghbi87",
            "g8g",
            "3i4u984",
            "##34",
            "##########",
            "op98yttygbh",
            "elcdoh"
        ],
        "id": 3425,
        "output": [
            {
                "text": " \"^([01]?[0-9]|2[0-4]\\\\d|25[0-5])$\"(the first four octets in the range are acceptable)\n\n"
            },
            {
                "text": " ^^\\S+(?:-\\S+)*\\S+$\n\n\n\nSection: Mathematics--Geometry--Volume\n\nExplaining the Zoological Foundation\n\nIn the animal kingdom,"
            },
            {
                "text": " To match any IP address, we don't need to use a range. The following regular expression will match any IP address, regardless of the range specified: \n/\\b127\\.0\\.0\\."
            },
            {
                "text": "\n\nimport re\n\nmy_string = \"The quick brown fox jumped over the lazy dog\"\nmy_regex = \"(?<=\\s).+?(?=\\s)\""
            },
            {
                "text": " (allow IPv4, disallow IPv6/IPv8)\n```Python\nimport re\n\n# Define the list of allowed IP addresses\nallowed_ips = [\"127."
            },
            {
                "text": " \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\/\\d{1,2}\\/\\d"
            },
            {
                "text": "\n\\b\\d{1,2}\\.(1)?[0-9]{1,2}\\.{1}[0-9]{1,2}\\.[0-9]"
            },
            {
                "text": "\n ^[[:ascii:]]{3}\\.[1-9]{1}$|^[0-9a-f]{4}$\n\nLecture Note"
            },
            {
                "text": " /^([0-9]+\\.\\d+\\.\\d+\\.\\d+|\\d+\\-?\\d+-?\\d+\\.\\d+\\.\\d+"
            },
            {
                "text": " (Any possible solution in Python) [example: \"\\\\b(\\d{1,3}\\.){3}\\d{1,3}$\"]\n\n3. Write a function that returns True"
            }
        ]
    },
    {
        "expression": "(?:2[0-3]|[01]?[0-9])[:.][0-5]?[0-9]",
        "raw_prompt": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "Matches time in format HH:MM (23:30)\nMatch examples:\n- \"23:30\"\n- \"23.30\"\n- \"20.7\"\nNon-match examples:\n- \"23-30\"\n- \"time\"",
        "matches": [
            "23:30",
            "23.30",
            "20.7",
            "23.6",
            "20:0",
            "22.23",
            "23:0",
            "22:08",
            "20:00",
            "06.5",
            "21:47",
            "8.1",
            "14:1"
        ],
        "non_matches": [
            "23-30",
            "time",
            "12/12",
            "11 11",
            "3498765",
            "noon",
            "monday",
            "1 pm",
            "32434322",
            "2312",
            "43434",
            "234565432"
        ],
        "id": 3427,
        "output": [
            {
                "text": " (?<![0-9a-zA-Z.])time\\.[0-9]+\n\nNow let's write these lines of code, and then run them to see what they produce:\n\nimport re \nm = re.search(r\"(?"
            },
            {
                "text": "\n\nimport datetime\n\n# Example Time Format\ntime_format = \"24:45-12:03 24:02\"\n\n# Regex to validate time\nregex = re.compile(r\"(\\d{2}:\\d{2}(?"
            },
            {
                "text": " You can use [0-9]{1,2}:([0-9]){2}[AP]M to match time in 24:00-10:59am or 10:00-11:59pm. \n\nExercise 2:\nWrite a RegEx"
            },
            {
                "text": " \"\\d\\d:\\d\\d [0-9]\\.\" \n\n3. Try using RegEx to extract the year from an email address. \nAnswer:  \\d\\d\\d-\\d\\d\\d\n\n4. Try creating a regex"
            },
            {
                "text": " /^\\d{1,2}|\\.\\d{1,2}|\\d{1,2}(:|)\\.\\d{1,2}$/.\n\nExercise 4: \n\nUse the text.match() method to check whether"
            },
            {
                "text": " I will match any time value between 0:00 and 23:59. Anytime format, not HH:MM.\n\nExercise 3: Format an Email Address\nExercise: You want to format an email address following these rules: \n- The username should be between 5 and"
            },
            {
                "text": " (^| )[0-9]{1,2}:[0-9]{2}[ \\-\\.]*$\n\nExercise 2: Generate a custom dash from a provided RegEx pattern. \nAnswer: CustomDash(%{Pattern})\n"
            },
            {
                "text": " \"(\\d{1,2}):(\\d{2})([AP]M|$)\"\n\nExercise 2: Describe a scenario where a RegEx can be used to classify data.  \nAnswer: A RegEx can be used to classify data as either \""
            },
            {
                "text": " The regex is r'^(\\d{1,2})\\.(\\d{2})$'\n\n\n\nAbnormal Reasoning Exercise:\n\nTopic: Social Studies - Timelines - Timelines and skills and strategies\nTone/Knowledge/Examples: Language Arts"
            },
            {
                "text": " \n\nregex_1 = \"^(20[\\d]|30[\\d])-(0[\\d]|1[\\d])-\\[(0[\\d]|1[\\d])\\.0[\\d]{2} \\"
            }
        ]
    },
    {
        "expression": "[0-9]{5}\\s?[0-9]{5}",
        "raw_prompt": "Basic UTR and CRT formats, 10 digits however are often written with an optional space after 1st 5",
        "refined_prompt": "Matches basic UTR and CRT formats, 10 digits however are often written with an optional space after 1st 5\nMatch examples:\n- \"1234567890\"\n- \"12345 67890\"\n- \"14980\u200916473\"\nNon-match examples:\n- \"123 4567890\"\n- \"A123456789\"",
        "matches": [
            "1234567890",
            "12345 67890",
            "14980\u200916473",
            "70356\u200933356",
            "7045456535",
            "6505015311",
            "2297102022",
            "4941497592",
            "66120\f53700",
            "1614435240",
            "8589244725",
            "4414717487",
            "9257801789"
        ],
        "non_matches": [
            "123 4567890",
            "A123456789",
            "2345",
            "efr54rfe",
            "34fdf",
            ".file",
            "3455%",
            "34RTRFVD",
            "3EW",
            "fredc",
            "EFGRED",
            "ER5TRGY"
        ],
        "id": 3448,
        "output": [
            {
                "text": " [0-9]{0,4}\\s\\d[0-9]{2}\\s[0-9]{3}\\s[A-Z]\ufffd"
            },
            {
                "text": " '\\S'.\n\nUse Cases:\n1. User validation on social media platforms to filter unwanted data.\n2. Creating a spam filter that classifies email as either \""
            },
            {
                "text": " If the string should be able to contain only uppercase and lowercase letters, digits or optional spaces, this should hold:\n[A-Za-z0-9"
            },
            {
                "text": " ([0-9a-zA-Z]{0,7}\\s)?[0-9a-zA-Z]{0,7}\n\nExample"
            },
            {
                "text": "  ^\\d{5}\\s\\d{10}$\n\n# Exercise3 \n# Generate a regex for the following description:\n# Write a regular expression"
            },
            {
                "text": " /u/\u20099/\u2009[^a-z0-9_]+/i\nReplace the matches with blanks\n\n3. The second problem is"
            },
            {
                "text": " [A-Za-z0-9] \n\n3. Create a regex to match the following list of words: apples, bananas, oranges\nAnswer: [b"
            },
            {
                "text": " (.{10,5})?\u2009A \nHow do you replace a string with a regular expression?\nAnswer: \nvar pattern = \"ABC\";\nvar str"
            },
            {
                "text": " (?i)\\b(?!^\\s*[A-Z][a-z]\\s*[0-9]\\s*[0-9][a"
            },
            {
                "text": "\n#1 is valid\n#2 should not be valid\n#3 should not be valid\n#4 should not be valid\n#5 should not be valid\n#6 is"
            }
        ]
    },
    {
        "expression": "^([1-9]|1[0-2])$",
        "raw_prompt": "Simple check for a value between 1 and 12",
        "refined_prompt": "Simple check for a value between 1 and 12\nMatch examples:\n- \"1\"\n- \"2\"\n- \"12\"\nNon-match examples:\n- \"-1\"\n- \"13\"",
        "matches": [
            "1",
            "2",
            "12",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11"
        ],
        "non_matches": [
            "-1",
            "13",
            "A1",
            "14",
            "-12",
            "2345",
            "44",
            "23",
            "12.22",
            "235340",
            "493",
            "1,000"
        ],
        "id": 3454,
        "output": [
            {
                "text": " \\b[1-2]\\d\\b\n\n2. Write a function that will read in a file and highlight all of the paragraphs that contain any amount and variety of capital letters.\n\n<details>\n<summary>Ideas</summary>\n- Create a list of all caps words\n- Open file and iterate over"
            },
            {
                "text": " ([1-12]|[13][0-9]|1[0-2]|2[1-9])\n\nExercise 2: Non-repetitive Password\nWhat are the rules of a non-repetitive password? \nAnswer: A non-repetitive password must have a minimum length, and"
            },
            {
                "text": "\n^[1-2][0-9]$\nCode to generate a RegEx with list of acceptable values from 1 to 12$ \nvalue = \"1\" + listOfAcceptedValues + \"$\"\n\nConclusion\nIn this section, we learned some basic concepts about RegEx for web development. We also looked at a few"
            },
            {
                "text": " ^(?:[1-9]\\d | 1[0-9]\\d | 12[0-9])$\n\nCongratulations, you are now familiar with the basics of data cleaning with Python RegEx. Happy coding!\n\nBuild Your Own Web Server Framework via Python from Scratch\nBlog Post Title: \"Using Regular"
            },
            {
                "text": " 0-9\n\n2. Write a Python program that takes a string and checks whether it has a number somewhere in it, and then returns that number as an integer. \n\nIdea: Implement regex search.\n\n```python\ndef detect_number(text):\n    if re.search(r\"\\d\", text"
            },
            {
                "text": " A-a\\d{1,2}\\b\n\n```python\nimport re\n\ndef check_code(input):\n    if input < 1 or input > 12:\n        print(\"Invalid value detected. Must be between 1 and 12.\")\n    elif re.match(r\"^[a-zA-"
            },
            {
                "text": " The first number character should be \"1-9\", with spaces between each number character.\n\nExercise 3: Write a RegEx to match an email address\nMatch examples:\n- \"jdoe@gmail.com\"\n- \"lmno@yahoo.com\"\n- \"pqrst@hotmail.com"
            },
            {
                "text": " ^[1-9](\\s|-)?\\d{1,2}$\n\nExercise 2 - Non-Spaced Numbers\nGenerate a RegEx for allowing one or more numbers, with an optional minus sign.\nAnswer: ^[-0-9]+$\n\nExercise 3 - Mixed Cases\nGenerate"
            },
            {
                "text": " \n^(?!-1)(?!-13)(?!1)(?!2)(?!)$\n\n\n\nNegative Conversation:\n\nPerson A: Hey, have you heard about the Theory of Mind?\n\nPerson B: Yeah, I have. It's this fancy concept where they try to understand how other people think and feel"
            },
            {
                "text": " The answer is \"^\\d+$\"\n\nConclusion:\nIn conclusion, Python's string methods play a crucial role in managing and manipulating variables during the cryptocurrency trading process. By familiarizing yourself with the `ljust()` method, you'll enhance the quality, readability, and efficiency of your cryptocurrency trading. Remember to practice with the"
            }
        ]
    },
    {
        "expression": "^(?=.*[1-9].*)[0-9]{3}$",
        "raw_prompt": "3 digit number representing an HMRC Tax Office. Office 000 is not valid",
        "refined_prompt": "Matches 3 digit number representing an HMRC Tax Office. Office 000 is not valid\nMatch examples:\n- \"001\"\n- \"123\"\n- \"940\"\nNon-match examples:\n- \"-01\"\n- \"000\"",
        "matches": [
            "001",
            "123",
            "940",
            "675",
            "518",
            "408",
            "695",
            "515",
            "026",
            "432",
            "225",
            "346",
            "757"
        ],
        "non_matches": [
            "-01",
            "000",
            "90.1",
            "742305",
            "148179",
            "748684",
            "367425",
            "3269",
            "2595",
            "2839",
            "700250579",
            "820281690"
        ],
        "id": 3457,
        "output": [
            {
                "text": " /\\d{3}[0\\d]|\\d{3}\\-(\\d{2})/\nNote that the backslashes are necessary since the \\d escape has two special uses. To match a single digit, the '\\d' must be escaped (and only once). This"
            },
            {
                "text": " [\\d]{3}.{9}\n\n4. Write a Python function that takes a string as input and returns a list of all the groups in the RegEx that match a digit.\n```python\nimport re\n\ndef get_digit_groups(string):\n    return re"
            },
            {
                "text": " \n[A-Z0-9]{3}[0-9]\\{1,2\\}.[0-9]{1,2}\\ \n[A-Z]{3}[0-9]{1,2}[0-9]([0-"
            },
            {
                "text": " \"^[0-9]{3}[-.][0-9]{3}[/.][0-9]{3}$\"\n\n\nExercise 5: \nCreate a RegEx pattern that matches a string of 3 uppercase letters followed by a series of numbers."
            },
            {
                "text": " [^-0-9]{1,2}[0-9][^-]{0,1}[0-9]\n- \"100000\"Generate a RegEx for this description. \nAnswer: [^0-9]{3,}\n- \"00"
            },
            {
                "text": " \n\n```python\nimport re\nhmc_codes = [\n    \"000\",\n    \"001\",\n    \"011\",\n    \"012\",\n    \"013\",\n    \"014\",\n    \"015\",\n    \"016\",\n    \"017\",\n    "
            },
            {
                "text": " \"^[0-9]*$\"\n\nExercise 2: Write a RegEx to identify all email addresses.\nNon-match examples:\n- \"hello@world.com\"\n- \"mike.doe@myemail.org\"\nAnswer: \"^[a-"
            },
            {
                "text": " A pattern could be something like \"^[1-9][0-9]$|^0([1-9][0-9]|0)$\"\n\nExercise 2:\nGiven that an HMRC tax office is looking for a document that has a date of birth in the format"
            },
            {
                "text": " ^([0-9]{3})|([0-9]{3}[0-9])/[0]$\n\nUsecase 2: Email Address Validation\nA company wants to implement a system to validate email addresses from their employees to prevent spam emails. They create a Reg"
            },
            {
                "text": "\nr'^\\d{2}(\\-\\d{4})?(?:[\\d\\.]*)(?:\\-|[\\d\\.]*)$'\n\n\n\nComparison between Clean and Dirty \n\nIntroduction\nAs a student, you have probably heard about cleanliness"
            }
        ]
    },
    {
        "expression": "^(GB)?([0-9]{9})$",
        "raw_prompt": "If you dont need to validate anything other than UK Numbers then this is for you, with optional GB at the start. If you need other countries then the EU Pattern is better suited",
        "refined_prompt": "Matches UK Numbers, with optional GB at the start.\nMatch examples:\n- \"GB123456789\"\n- \"123456789\"\n- \"GB604774876\"\nNon-match examples:\n- \"GB12345678\"\n- \"AA123456789\"",
        "matches": [
            "GB123456789",
            "123456789",
            "GB604774876",
            "GB377715572",
            "GB306556503",
            "410056552",
            "934546885",
            "539884648",
            "004466730",
            "070159455",
            "GB957511261",
            "GB957511261",
            "GB820935266"
        ],
        "non_matches": [
            "GB12345678",
            "AA123456789",
            "1234567",
            "GB0",
            "GB7",
            "GB5",
            "fghtgr",
            "435tgrfvd",
            "ertrgefw",
            "JHGYTF",
            "aTF%Ffy",
            "43fre"
        ],
        "id": 3459,
        "output": [
            {
                "text": " GB(?:\\.(?=[A-Z0-9]{1}(?!\\.))\\d{{4}|^\\d{{4}})\n\nExercise 4:\nWrite a Python code that accepts an email address"
            },
            {
                "text": " [a-zABCD-0-9]{8}$\n\nExercise 6: Fill in the blanks \nUsing the RegExp \nFind matches like the following.\n- \"my-name = my-name"
            },
            {
                "text": " [^GB\\d]\nGenerate a RegEx for this description. Matching alphabets, 0 to 9, and the word GB (a substring from the beginning or end of the string)\n\nExercise 3:"
            },
            {
                "text": " \n\n```python\nimport re\n\n# Generating the pattern for GB and GB_Suffix\ngb_suffix = '_GB'\n\n# Reg ex to find GB and GB_Suffix\ngb"
            },
            {
                "text": " [^0-9]GB[0-9][^0-9]\n\n3. Create a RegEx pattern to match the following dates in the format YYYY/MM/DD format:\n- \"2025/08"
            },
            {
                "text": " ^(B)(?:[0-9]|1[012]|3[01]|5[012]|6[012])\\d{9}$\n- \"A123456789\"  Generate a Reg"
            },
            {
                "text": " (?:GB)(?!.*$).{6}$\n\n2. Create a single statement that includes all of the matching examples from the first exercise that matches for GB starting at the start of the string\nAnswer: (?:GB)(?!"
            },
            {
                "text": " \"^AA([0-9]*)([a-zA-Z])([0-9]{1})([a-zA-Z]{1})$\"\n\nUse Case 1: A conversation between"
            },
            {
                "text": " ^[ATGC]+$\n\n3: Explain why RegEx is used when comparing strings.\nAnswer: RegEx is used when comparing strings because it allows us to easily identify and locate patterns within strings. This makes it possible to find specific"
            },
            {
                "text": " Matches UK Numbers, with optional GB at the start,\n\\d{5}[^GB]{6}|\\d{5}[GB]{0,2}\n\nA:\n\nThe pattern I use:"
            }
        ]
    },
    {
        "expression": "^[0-9]{8}R[A-HJ-NP-TV-Z]$",
        "raw_prompt": "Pension Schemes have their own references, 8 digits followed by R and then another letter.",
        "refined_prompt": "Matches Pension Schemes with 8 digits followed by R and then another letter.\nMatch examples:\n- \"12345678RA\"\n- \"43213245RT\"\n- \"83536006RP\"\nNon-match examples:\n- \"1234567RA\"\n- \"432132456RR\"",
        "matches": [
            "12345678RA",
            "43213245RT",
            "83536006RP",
            "09187372RA",
            "82927952RN",
            "06159369RM",
            "62722611RD",
            "05680285RH",
            "97060368RL",
            "65424962RR",
            "90220825RL",
            "43371559RT",
            "67100732RY"
        ],
        "non_matches": [
            "1234567RA",
            "432132456RR",
            "23657005*V",
            "54102433!J",
            "56423464JG",
            "14301651ET",
            "79870307vG",
            "74051292DW",
            "53918747;Q",
            "18732502\\B",
            "59288318HP",
            "52153646mD"
        ],
        "id": 3460,
        "output": [
            {
                "text": " I(?:\\D{8}[A-Z]?) to match \"8 digits followed by a single letter OR \"8 digits followed by two letters.\"\n\nExercise 3: Write Regular Expression for Username\nAnswer"
            },
            {
                "text": " \\b(?:[1-9][1-9]|0[1-9])T[1-9][0-9][A-Z]{2}\\b\n\nExercise 4: \n"
            },
            {
                "text": " ([08])([A-Za-z][0-9A-Za-z])\n\n#### Exercise 3: Use RegEx to match 4-digit numbers with at least 1 odd number between 0 and"
            },
            {
                "text": "\n- \".*[^A-Z]{8}[A-Z]$\"\n\"\"\"\nimport re\n\ndef pension_schemes_with_regex(pension_code: str):"
            },
            {
                "text": " [^a-zA-Z0-9]*(?<!RA)[a-zA-Z]{8}\nUse negative lookbehind and lookahead to make sure that there is no R after"
            },
            {
                "text": " match if 1st digit is a 3. If a match is found, then match the whole string of letters that follows.\n\n3. In a small town called Greenville, there are three different pension schemes that each has"
            },
            {
                "text": " [A-P]{8}[0-9A-Z] [AP]\n\nThe first line defines a regular expression to match \"Nums followed by R and then another letter\". The second line defines a"
            },
            {
                "text": " ^[a-zA-Z0-9]{8}\\R([a-zA-Z][a-zA-Z0-9]{4})\n\nExercise 4:\nWhat Re"
            },
            {
                "text": " [a-zA-Z0-9]{8}\\w.\nQuestion 3: Define and explain sub-matching with an example.\nSub-matching refers to the ability to identify and extract multiple"
            },
            {
                "text": " \"12345(\\\\d)(\\\\w)(\\\\w)\\\\d\"\n5. Write a RegEx to extract all the email addresses from a customer review.\nSolution:  (Example using python's re module,"
            }
        ]
    },
    {
        "expression": "^(A[A-HJ-M]|[BR][A-Y]|C[A-HJ-PR-V]|[EMOV][A-Y]|G[A-HJ-O]|[DFHKLPSWY][A-HJ-PR-Y]|MAN|N[A-EGHJ-PR-Y]|X[A-F]|)(0[02-9]|[1-9][0-9])[A-HJ-P-R-Z]{3}$",
        "raw_prompt": "Current standard UK Registration plates running from Sept 2001 to Feb 2051, basic form AA99AAA but contains prefix combinations, the only number not used is 01",
        "refined_prompt": "Matches standard UK Registration plates running from Sept 2001 to Feb 2051, basic form AA99AAA but contains prefix combinations, the only number not used is 01\nMatch examples:\n- \"NE02ABC\"\n- \"AA58DEF\"\n- \"CH08NDO\"\nNon-match examples:\n- \"NF02ABC\"\n- \"AA01WUX\"",
        "matches": [
            "NE02ABC",
            "AA58DEF",
            "CH08NDO",
            "GL05KLZ",
            "02RJA",
            "GC24OTS",
            "03JEG",
            "BE00EHK",
            "07-UT",
            "MAN04AVY",
            "NB60ZUA",
            "CM87XTT",
            "BA05CKX"
        ],
        "non_matches": [
            "NF02ABC",
            "AA01WUX",
            "werty",
            "2345678",
            "ID",
            "huy76t5rt",
            "DDDjjjj",
            "UHDIhIhef",
            "JIDHIEUH*(8d",
            "jndekUHIb",
            "dejwnsU",
            "#####"
        ],
        "id": 3467,
        "output": [
            {
                "text": "^\\d+[a-z]+$\n\nThis is what i have so far but its only matching AA99AAA.\n   private string GenerateRegEx("
            },
            {
                "text": " (?:[01]?[0-9]{1,2}|[2]?[0-9]{3})\n\nA:\n\nThe"
            },
            {
                "text": " [\\d]+[^a-zA-Z]?\n- \"GH08BCD\"Generate a RegEx for this description. \nAnswer: ["
            },
            {
                "text": " (\\d+)([A-Za-z]+)([A-Z])\nI have no idea how to solve this problem. Here is my solution, but"
            },
            {
                "text": " [A-Z]{1}[0-9]{2}[A-Z]{3}[0-9A-Z]{1}["
            },
            {
                "text": " \n^[AEIOU]{1}[AEIOU]{1}(\\d)[AEIOU]{1}(\\d)[AEIOU]"
            },
            {
                "text": " \"([A-Z]\\d$|[A-D][A-Z])*\" (e.g. AA03CDD)\nYou can do some"
            },
            {
                "text": "\n- [a-z0-9][a-z0-9]{9}[a-z0-9][a-z0-9]\\\\"
            },
            {
                "text": " ^(\\d{2})([A-Z])?(\\d{3}(?:[A-DF-HJ-NPRV-WX]\\d"
            },
            {
                "text": "\n[^AF]{8}-[^AF]{2}([0-9A-E]{1,7})$|[AF]{5}"
            }
        ]
    },
    {
        "expression": "^A([0-9]|10)$",
        "raw_prompt": "Sizes of paper from A0-A10",
        "refined_prompt": "Matches sizes of paper from A0-A10\nMatch examples:\n- \"A0\"\n- \"A6\"\n- \"A10\"\nNon-match examples:\n- \"A-1\"\n- \"B1\"",
        "matches": [
            "A0",
            "A6",
            "A10",
            "A5",
            "A1",
            "A7",
            "A2",
            "A6",
            "A8",
            "A9",
            "A4"
        ],
        "non_matches": [
            "A-1",
            "B1",
            "A11",
            "*10",
            "M10",
            "R7",
            ")8",
            ":10",
            "x10",
            "c10",
            "V10",
            "T10"
        ],
        "id": 3473,
        "output": [
            {
                "text": " \"A-1,B1\".\n\n\n\nQuestion 1: There are three shelves in a bookcase, and each shelf has 12 books. If Sarah takes out 2 books from each shelf, how many books are left in total?\n\nSolution 1:\nTo find the number of books left in"
            },
            {
                "text": "\n(?='-^[A-Z][0-9]*$-').*\n\nQ:\n\nWhat do you mean when the variable is a string?\n\nWhen passing variables to other functions, I have found that if they are a string, it works but is that all?"
            },
            {
                "text": " A0-A9|A-A0:|A-A1:|A-A2:|A-A3:|A-A4:|A-A5:|A-A6:|A-A7:|A-A8:|A-A"
            },
            {
                "text": "\n/[A-Z]{2}[0-9]{1,3}/;\n\n3. What is the difference between search, findall, and split on a string?\n4. Generate a RegEx for this description. \nAnswer:\n/^((["
            },
            {
                "text": " Match examples and non-match examples \n2. Use a list comprehension to generate a list of 20 random numbers between 1 and 100.\nHint: You'll need to use the random library to generate the random numbers.\nAnswer:\nimport random\nnumbers = [random.randint(1"
            },
            {
                "text": " \"[A-\\d]{0,2}\" Match only characters in this case\n2. The word should be at least five characters in length and be contained in the example string.\n- \"this is an example string\"\n- \"this is the example string\"\n- \"this is the example"
            },
            {
                "text": " \"\\d+[A-Za-z-.]+@.*?\"\n\nExercise 2: Complete the sentence using the correct punctuation mark:\nSentence: The cat is sleeping on _\nAnswer: _\n\nExercise 3: Write a sentence using a hyphen to indicate that a"
            },
            {
                "text": "\n[A-Z][A-ZA-Z0-9\\s][A-Z0-9\\s][A-Z0-9\\s][A-Z0-9\\s][A-Z][A-Z][A-Z][A-Z]\\r"
            },
            {
                "text": " (^A|A[0-9]|A1$|A2$|A3$|A4$|A5$|A6$|A7$|A8$|A9$|A10$|B$|B1$|B2$|B"
            },
            {
                "text": "\n\\s?(\"A[0-9]|[1-5])-?(A[6]|[7-9])?\\s?\nThis RegEx will match all paper sizes from A-A10, including A_B5 and A_B10. It does not"
            }
        ]
    },
    {
        "expression": "^([1-9]+)?[02468]$",
        "raw_prompt": "Any number possible as long as its even.",
        "refined_prompt": "Matches any number possible as long as its even.\nMatch examples:\n- \"2\"\n- \"64\"\n- \"4343253298\"\nNon-match examples:\n- \"3\"\n- \"65\"",
        "matches": [
            "2",
            "64",
            "4343253298",
            "54462446332341621278485525477542956571558953391926",
            "4",
            "0",
            "2877461963813168652",
            "62928195697568977435979956928831314989257272",
            "8",
            "78947698",
            "364543262324",
            "234564",
            "342567654"
        ],
        "non_matches": [
            "3",
            "65",
            "5345643531",
            "65789091",
            "35932109",
            "348712937",
            "4398523",
            "4390523",
            "0987654321",
            "234567",
            "67545",
            "3453019"
        ],
        "id": 3475,
        "output": [
            {
                "text": " Match any number possible. \n\nExercise 5: Use a conditional operator to filter out the non-matching characters.\nMatch examples:\n- \"234\"\n- \"1234\"\n- \"1234 5\"\nNon-match examples:\n- \"3\"\n- \"65\"\nGener"
            },
            {
                "text": " \n[1] \"\\d{1,13}$|^[1-9]\\d{0,9}[1-9]\\d{0,9}$|^[1-9]\\d{0,3}$\"\n\n[1] \"\\\\d{"
            },
            {
                "text": " \\d*[02468]#.*$\n\n5. Generate a regular expression for a URL. A URL should start with a letter (either upper or lower case) or underscore, and should end with a slash (\"/\"). Match any letter or underscore that follows. \nMatch examples:\n- \"www"
            },
            {
                "text": " (3|[13579\\s]) matches all numbers possible from 1 to 8 excluding 12 and 9.\nGenerate a RegEX for this description.\nAnswer: (([0-9\\d]+)?([13579][0-9\\d]*|1(?:[13579]{1}"
            },
            {
                "text": " \"\\\\d+$\"\n\n3. Write a regular expression for this description.\nMatch the following items:\n- \"1 dog, 2 cats, 3 birds\"\n- \"1 red ball, 2 blue balls, 3 green balls\"\nNon-match: \"1 red ball\"\nAnswer: \"[^"
            },
            {
                "text": " ^(?=.*[02468])(?=.*[13579]).?.{8}$\n4. Write a Python program to verify if a given password meets the above description. The password should be at least eight characters, it should contain at least one uppercase letter, one lowercase letter,"
            },
            {
                "text": " (^[0-9]+$)([^0-9])+(\\d{2})$\n\n\n\ndef f(x: float, a=-9.9, b=9.9, n=4):\n    return sorted([a, b])[n] == sorted([x,"
            },
            {
                "text": " (.*)\n- \"3\"\n\n3. Given input strings with a minimum length of 2, generate regular expressions that return true if the string is a match and false otherwise\nInput string examples.\n\"abc\"\n\"ab\"\n\"aa\"\n\"c\"\n\nAll answers must produce two regular"
            },
            {
                "text": "\n^\\d+$ - At least one digit must be in this position\n\nExercise 2:\nWhich of the following numbers does not match the given RegEx?\n- 6/0\n- 0.6\n- 3/0\n- 9/1\nAnswer:\n0.6 does match the"
            },
            {
                "text": " Any number possible as long as its even\n\n\nSolution:\n\nimport random\nimport re\n\n# Generating a string that will become the regex pattern.\nreg_string = '\\d+'\n# Generating 10 random numbers.\nnums = \"\".join(random.choice([\"2\","
            }
        ]
    },
    {
        "expression": "^(-?)((\\d{1,3})(,\\d{3})*|\\d+)((\\.\\d+)?)$",
        "raw_prompt": "Matches negative and positive numbers with or without commas and with or without decimals",
        "refined_prompt": "Matches negative and positive numbers with or without commas and with or without decimals\nMatch examples:\n- \"-9.999\"\n- \"99,999,999.99\"\n- \"9999.99\"\nNon-match examples:\n- \"-.9\"\n- \".9\"",
        "matches": [
            "-9.999",
            "99,999,999.99",
            "9999.99",
            "999",
            "973,898,080,023,320,174,275,691,896,152,929,655,872,854,275,405,642,525,164,040,715,794,125,153,765,149,370,547,663,723,520,381,412,935,153,182,317,140,251,596,179,426,310,146,514,816,550,425,261,266,914,296,309,977,419,649,196,217,745,536,552,854,423,520,767,883,456,706,212,962,862,792,823,683,766,127,484,450,256,322,208,506,810,163,708,363,530",
            "-107435874649536107.8425896633773618788668368182747602093390185",
            "574,157,771,787,480,745,391,222,968,697,710,809,027,945,859,504,193,784,865,300,586,485,054,581,945,331,306,825,209,685,537,173,186,524,778,331,974,946,315,377.7655430909592566053000542956697504011368047909223541262517872627668012",
            "7313696270262177170837",
            "31,488,896,592,575,159,982,969,001,342,115,430,876,192,242,360,264,280,364,174,659,994,129,828,840,905,580,876,205,901,545,632,615,330,748,307,674,682,190,322,580,290,582,118,805,859,233,158,916,497,461,750.1462680935394607079801548365023342919593",
            "68,003,464,907,564,254,704,314,847,875,828,177,723,429,372,052,221,672,410,341,505,941,792,775,515,083,508,684,418,580,476,497,609,295,879,951,226,673,385,005,628,067,062,694,799,831,691,923,097,473,628,070,117,889,840,844,522,227,274,243,367,836,552,928,077,075,868,961,876,296,593,950,430,931,305,478,348,514,453,522,818.6645486536540997105751121294598781036",
            "-4821832801840457814747826278894671531051137138018416901702041595271519335526298581447861181793086752",
            "55253465954372875860773921365960757899176704913.502999822699787898412276",
            "28808141779321425346696897"
        ],
        "non_matches": [
            "-.9",
            ".9",
            "9,99.99",
            "4fbh3q",
            "#3",
            "45%",
            "$34",
            "12/12",
            "3.",
            "+9876",
            "8976.",
            "3283.312."
        ],
        "id": 3481,
        "output": [
            {
                "text": " r\"(^-?\\d{1,3}(,\\d{3})?)|(^-?\\d{1,3})$\"\n\nExercise 3: Write a Program that will match all dates.\n\n"
            },
            {
                "text": " (Note that when decimal points are used, they must be separated by a comma, not by &)\n- \"9,099,999.99,1%\". \n\nExercise 3: Negative Lookahead\nCreate a RegEx"
            },
            {
                "text": " _\n- \"no matching character\" \n- \"no matching character\" \n- \"(no matching character)\"\n\nCongratulations on finishing this section on Python Operators! Remember, operators are the building blocks of any programming language, and they allow"
            },
            {
                "text": " a letter or number, followed by a decimal point and again a letter or number\n\n3. Replace unwanted characters with a specific character (e.g. from \"-a to a\" \"a-9\" \"a-e\" \"a-"
            },
            {
                "text": ".9(\\.\\d*)?\n\nExercise 5:\nFill in the blank with a suitable word:\nRegular expressions are _ powerful tools for finding and extracting specific patterns from text. Answer: invaluable\n\nReal-world Use Case 1"
            },
            {
                "text": " \n\nPositive numbers can have commas, decimals, and positive/negative signs without any additional spaces. Negative numbers should be preceded by a minus sign (-).\n\n\n\nQuestion 9: A company offers a 15% discount on"
            },
            {
                "text": " (.0-9]+)\\.0*\n\n\n\nQuestion 10: Olivia, Peter, and Stella sold a total of 120 cookies. Peter sold 2 times the number of cookies that Olivia sold, and Stella sold 1/5 of the difference between"
            },
            {
                "text": " [\\d][\\d\\.\\-]*\n\n5. Exercise: \nExercise: Write a Python program that takes two strings as input from the user and converts them to ASCII data. Then, create a RegEx pattern to extract all"
            },
            {
                "text": " \\d\\d(\\.\\d{2})?([eE][+-]?\\d+)?\"\n\n9. Example\nYou have a dataset with a timestamp, the number of likes, the number of comments on it and the"
            },
            {
                "text": " This is the example of a pattern that can generate a string using groups and quantifiers.\n- \"A string starts with a letter and ends with exactly one digit.\"\n- \"A string starts with a letter and ends with exactly one letter.\"\n"
            }
        ]
    },
    {
        "expression": "^([\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+[A-Z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+|[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[0-9]+[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+[a-z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+|[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[0-9]+[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+[A-Z]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+|[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[a-z]+[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+[0-9]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+|[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[a-z]+[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+[a-z]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+|[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[A-Z]+[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+[0-9]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+|[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[A-Z]+[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+)+$",
        "raw_prompt": "Password with lower, upper case letters, digits and special characters in any order",
        "refined_prompt": "Matches password with lower, and upper case letters, digits, and special characters in any order\nMatch examples:\n- \"#3aZ\"\n- \"3#aZ\"\n- \"3a#Z\"\nNon-match examples:\n- \"#$@!\"\n- \"aB3a\"",
        "matches": [
            "#3aZ",
            "3#aZ",
            "3a#Z",
            "3aZ#",
            "#3Za",
            "3#Za",
            "3Z#a",
            "3Za#",
            "#a3Z",
            "a#3Z",
            "a3#Z",
            "a3Z#",
            "#aZ3",
            "a#Z3",
            "aZ#3",
            "aZ3#",
            "#Z3a",
            "Z#3a",
            "Z3#a",
            "Z3a#",
            "#Za3",
            "Z#a3",
            "Za#3",
            "Za3#"
        ],
        "non_matches": [
            "#$@!",
            "aB3a",
            "zzzz",
            "BBBB",
            "1234",
            "r4fr4ecUYF",
            "fervdrtg",
            "3443ferfr",
            "r4ewd4513",
            "43fe7",
            "3r783y43hre",
            "4fbh3q"
        ],
        "id": 3483,
        "output": [
            {
                "text": " (?i)(?<![a-z]+)(?=.{32})(?![A-Z])(?=.{8})([0-9@$#!]!)\n\n\n\nDaily Life"
            },
            {
                "text": " r'^\\w{3}\\d{3}\\w{3}\\d{4}\\w{1}\\d{7}\\w{1}$'\n- Email:\nRegex to match email addresses:\n- r"
            },
            {
                "text": "\n- ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@_$!%?&])[A-Za-z\\d"
            },
            {
                "text": " (lowercase, digits, lowercase, and an optional uppercase letter).\n\nExercise 5:\nCreate a RegEx for this description.\n\n\nA list of names must start and end with the same letter and then must"
            },
            {
                "text": " ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[\\w-]*$\n\nExercise 2: Rewrite the Password Validator RegEx from Example 1"
            },
            {
                "text": " (Any character from 0 to 9, [ab], + [ac], * [ae], ^ [ae], $ [fg], _ [fg], % [fg], _[fg]).\n\nExercise 2:\nFind all words"
            },
            {
                "text": "  ^(?=.*[A-Z])(?=.*\\d)(?=.*[#$@!.~-_=*+#^%])[A-Za-z\\d#$@!"
            },
            {
                "text": "\n- (?!^[a-zA-Z\\d]*$)(?=[^.?!]*[a-zA-Z\\d])[a-zA-Z\\d]{6}\n"
            },
            {
                "text": " #?[A-Z][a-z]?[0-9]?$@[a-zA-Z!@#$]\n\nExercise 3: Find the next matching element in the following list of numbers:"
            },
            {
                "text": " A character class of lower, uppercase, digits, and any characters in any order can be used. \n\nExercise 2:\nWhat is a RegEx? \nAnswer: A RegEx is a pattern that can match"
            }
        ]
    },
    {
        "expression": "<!--(?!\\s*\\[if[^]]+]>[^<]*<!\\[endif\\]).*?-->",
        "raw_prompt": "Matches html comments but excludes comments that contain if statements",
        "refined_prompt": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>blah<![endif]-->\"\n- \"<ref>\"",
        "matches": [
            "<!-- this is a comment -->",
            "<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->",
            "<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->",
            "<!---->",
            "<!--E:gh;a]4\"s-->",
            "<!--/~u{c_w+Qn8hb c.oUqow/[sRvVv1R3=[k`$:WRr-->",
            "<!--0{h8J$Ep qOt6p3dTZfOk:z-->",
            "<!--e( >80-z[?r?MLz&xeNi-70uEWok$/haO3+UbK)tvCh^(LERX?0l^^R >!.W/d<V{JssHYMt$/}D\\9,ScN6g>m-->",
            "<!--l svPDf{F<0o1@>_{yAMB=v&8Hnh-J]^a^cgS,I_g#U97kfAraoq08*81*VK'uDWr|9+R<Suyx<#vHh:yUoj,tC5DUL'{l-->",
            "<!--v4Dag[]X'j6O7qO]K.#IT<Dd7lB*Cx$Jq8yYz{`-->",
            "<!--m!`!Xmfv7q7^[WR6D&Os(Ph-\"M}I6>K\\:^|WyPfPN+oTU=6-+bhuHBPe}.~j+g.!\\7rcoJ`rt#j)p6\"=o7REs>`BeLT<qAn-->",
            "<!--wH1m9&T('3UZFB/$J`N/f^ZsR4L9K'UHX^QjE\",oLvA[Mafz\";`8}~qx W\\r*t/m\\[q<-->",
            "<!--VQ5 WgKWRuBnmVL#nt[Cr07h@Q/w_LEis~\\u:_H-->"
        ],
        "non_matches": [
            "<!-- [if lt IE 9]>blah<![endif]-->",
            "<ref>",
            "#ekf",
            "//grefdw",
            "/ erwfds",
            "\\\\frf4r3",
            "comment",
            "## frgrtf",
            "/* erhfgejr */",
            "< rfer <",
            "> jefejer <",
            "/// rtgfd"
        ],
        "id": 3488,
        "output": [
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>3"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>Hello"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>\";"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>h"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]> <"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>1"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]> 10"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>2"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>\","
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>this"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long",
        "refined_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long\nMatch examples:\n- \"4/1/2001\"\n- \"12/12/2001\"\n- \"55/5/3434\"\nNon-match examples:\n- \"1/1/01\"\n- \"12 Jan 01\"",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434",
            "7/34/0493",
            "5/2/6783",
            "9/3/6347",
            "67/86/8577",
            "2/79/7620",
            "5/6/1794",
            "3/00/1375",
            "86/18/0593",
            "0/8/0673",
            "9/94/5749"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001",
            "Jan",
            "July 5th",
            "23-23-23-23",
            "92",
            "394",
            "$45",
            "3929",
            "65%",
            "12-12"
        ],
        "id": 3546,
        "output": [
            {
                "text": " ([01]?[0-9])\\/([1-9]\\/[0-9]).+\nExercise 4: Write a"
            },
            {
                "text": " [0-9]?[0-9][0-9][0-9][0-9]\n- Create a Regex"
            },
            {
                "text": " \n([0-9]{2}[\\/\\-]([0-9]{2}[\\/\\-])(\\d"
            },
            {
                "text": " ([a-zA-Z0-9]+, [a-zA-Z0-9]+, [0-9]"
            },
            {
                "text": " \n^\\d{1}/\\d{2}/\\d{4}$\n\n3. Use Python's re"
            },
            {
                "text": " ^(0[1-9]|1[0-2])/((0[1-9])|(1[0-"
            },
            {
                "text": " [0-9]{1,2}(\\/)(0-9)\n[0-9]{1,2} is"
            },
            {
                "text": " (?<!m)^(?!(.)\\2{2})[0-9]{1,2}\\s[0"
            },
            {
                "text": " (?<!20)\\d{2}\\/\\d{2}\\/\\d{4}\n\n#3\nPattern ="
            },
            {
                "text": " A\\d+/\\w{1,2}\\s\\d{4}\\b \n\n- \"16/03/2005"
            }
        ]
    },
    {
        "expression": "((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9])|((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9])|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9]:[0-5][0-9])|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9])",
        "raw_prompt": "Matches all types of time declaration with ':' separator.",
        "refined_prompt": "Matches all types of time declaration with ':' separator.\nMatch examples:\n- \"0:26:12 aM\"\n- \"00:26:12 Pm\"\n- \"0:26:12aM\"\nNon-match examples:\n- \"eferfqe\"\n- \"ergqfr\"",
        "matches": [
            "0:26:12 aM",
            "00:26:12 Pm",
            "0:26:12aM",
            "00:26:12Pm",
            "Am 0:26:12",
            "pM 00:26:12",
            "Am0:26:12",
            "pM00:26:12",
            "0:26 PM",
            "01:26 am",
            "0:26PM",
            "01:26am",
            "Am 0:26",
            "pM 00:26",
            "Am0:26",
            "pM00:26",
            "23:26:12",
            "00:26:12",
            "0:26:12",
            "23:26",
            "0:26"
        ],
        "non_matches": [
            "eferfqe",
            "ergqfr",
            "time",
            "noon",
            "39404",
            "234je",
            "am",
            "pm",
            "4334",
            "ef394",
            "323423",
            "43234"
        ],
        "id": 3549,
        "output": [
            {
                "text": " \"\\s*(\\d{1,3}\\d:\\d{1,2}\\s*[a-zA-Z]{2}\\s*)+\"\n\nExercise 2: Extract the"
            },
            {
                "text": " 0:26:12|[a-zA-Z0-9_]+\n- \"00:26:12|[a-zA-Z0-9_]+\" \n- match"
            },
            {
                "text": " \"^\\d{1,2}:\\d{1,2}:\\d{2}.*$\"\n\nExercise 2: Write a function that matches strings in the form \"string1 string2"
            },
            {
                "text": " [Regex for matching hours, minutes, and am/pm]: {0\\:|1[0 \\-]?[0-9]{1,2}\\:|2[0-3]:"
            },
            {
                "text": "\n/(\\d+?):(\\d{2}):(\\d{2})([a-zA-Z ]+)/\n\nIn conclusion, my fellow learners, understanding regular expressions can be the"
            },
            {
                "text": "\n\"(\\d+:[a-z ]+ [A-Z ]+) (?:[^ ]+ | [ ]+$)\"\n\nExercise 2:\nFind all numbers in the following string:"
            },
            {
                "text": " ( \\d\\d:\\d\\d\\d[-+.]\\d\\d$|\\d\\d:\\d\\d[-+.]\\d\\d\\d$|\\d\\d:"
            },
            {
                "text": " f\\d{2}s\\d{2}aM\nI'm wondering about the complexity of this approach. Any way to improve it?\npublic String GetDate(String from)\n{\n    "
            },
            {
                "text": " Match only one time expression, not 0 minutes.\n\nI have read through python official documentation but I am still having problems.\n\nA:\n\nRegular expressions are for string matching but not for time periods."
            },
            {
                "text": " Regex for \"hour:minutes am/pm\".\n\nExercise 3: Counting words with the Regular Expression\n\nGiven a long string of textual data, count the number of times each word appears on"
            }
        ]
    },
    {
        "expression": "(0\\d|1\\d|2[0-4]) ?: ?([0-5]\\d)( ?: ?[0-5]\\d)?",
        "raw_prompt": "Validate hh:minmin:ss",
        "refined_prompt": "Validate hh:minmin:ss\nMatch examples:\n- \"09:03:05\"\n- \"08 : 03 : 57\"\n- \"24:00: 05\"\nNon-match examples:\n- \"17:2\"\n- \"3:52\"",
        "matches": [
            "09:03:05",
            "08 : 03 : 57",
            "24:00: 05",
            "00: 00 :00",
            "17:54",
            "08 : 21",
            "20:06",
            "04 : 30",
            "18:44",
            "03:16 :10",
            "12 :03 :22",
            "11:49:41",
            "00:07"
        ],
        "non_matches": [
            "17:2",
            "3:52",
            "time",
            "2345678",
            "5432",
            "noon",
            "12-12",
            "12/12",
            "12/12/12",
            "12-12/12",
            "00000000",
            "9348239"
        ],
        "id": 3556,
        "output": [
            {
                "text": ".{01,2}:[0-9]{00}:[0-9]{00}.[a-zA-Z]{2}\n\n2) Write a regex that would accept the following numbers: 5, 15, -42, 8"
            },
            {
                "text": " (09:03):(00:57)\n\n2. Exercise: Write a python code that validates a user\u2019s IPAddress.\n    Ideas:\n    1. You can use the ipaddress library in python for this task.\n2"
            },
            {
                "text": " [0-3]:[1-24]:[0-5]\n- \"03:54\"Generate a RegEx for this description. \nAnswer: (02)/(0):(5)/[4-9]\n- \"08:00"
            },
            {
                "text": " (hours,minutes,seconds)\ndef generate_regex(hour, minute, second):\n    if hour:\n        x = re.search(r'\\d+:[\\d :]{2}', str(hour))\n        if"
            },
            {
                "text": " [5:]\n- \"3:52:58\"Generate a RegEx for this description.\nAnswer: [5:]?\"\n- \"3:57:59\"Generate a RegEx for this description.\nAnswer: [5:]?,\",\""
            },
            {
                "text": " \\d:\\d:\\d([ 0-5]) or \\d:\\d(\\d)\\d$\n2) Generate a RegEx for this description. Note: \\d:00 matches zero padded 00:00 but \\d:02 doesn't match 00:"
            },
            {
                "text": " \nTime: [0-9]{1,2}, [0-9]{2}, [0-9]{2}: [0-9]{2}\n\"\"\"\n\n\n# Write some regex\ndef string_to_regex("
            },
            {
                "text": " RegEx would be hhmmss\n\n```python\nimport re\n# example to match any string that ends with an integer or letter\n# For this example we use a negative lookahead to exclude any values that have\n# the same leading character instead of"
            },
            {
                "text": "\n- (?=\\d|^)-(?=^-?\\d\\d \\d)(?=: | )\nGenerate an regex that is valid from a description of a time that must be in the following format\nHH:MM:SS"
            },
            {
                "text": "\nregex = \"\"\"^(?=.*[0-9]{2})(?=.*[0-9]{2})\\ : \\ (?=.*[0-9]{2})(?=.*[0-9]{"
            }
        ]
    },
    {
        "expression": "^-?[1-9]\\d*\\.?(\\d+([eE][-+]\\d+)?)?$",
        "raw_prompt": "Matches numbers including scintific format",
        "refined_prompt": "Matches numbers including scientific format\nMatch examples:\n- \"-23333.1e+24\"\n- \"123\"\n- \"34.2\"\nNon-match examples:\n- \"23333.01+24\"\n- \"+123\"",
        "matches": [
            "-23333.1e+24",
            "123",
            "34.2",
            "-87693717247827161710694734576192125749089372404404342916330522406312",
            "-58564737552536.48176669308690674801075092379671445298833269473178731660961607224906327105271832084398137517568204770E-543040380162654177953787637765950840354806562831489817623846468396061531953",
            "862812362091683.",
            "-14649493636878381404701033168989841646",
            "-8101504129224558449019.4405431612507291079373009997249872857073731454645109061855654267230552770570547052296479060",
            "-26289839608675870704205108719611455149053083752457354690998470666126956758238188267599153792124132000685265298028593",
            "-6675064312488545378599501435434424173844999467920.",
            "-6814243005789112884114406497450943039122013912782781.890142773956864806716537437059292866176042454049110855352E-316423271089475072396705264608329388811095333019381819638428674",
            "286373605821936943615099.",
            "-970298087661834718193198391350046452602031077045708513613731852440827586137422875"
        ],
        "non_matches": [
            "23333.01+24",
            "+123",
            "34.-20",
            "erfr",
            "x10",
            "SF",
            "erfher",
            "ferh",
            "+234",
            "#43",
            "45%",
            "$67"
        ],
        "id": 3561,
        "output": [
            {
                "text": " \"^[+-]?(\\d+\\.)*?([0-9]+[e]?\\+?)$\"\n\n4. Write a RegEx to extract the first and last digits of a phone number.\n\n**Idea**: Identify the two characters at"
            },
            {
                "text": " (e,+)(\\d+)(\\.?\\d+)\n\n2. Define the RegEx pattern for a phone number that allows for no more than 6 digits that are separated from each other by only one or more dash(-). \nNon-match example: \"(123)-456"
            },
            {
                "text": " (^\\+?[0-9](\\.[0-9]*)?)\n\n3. Generate a RegEx pattern for the following conditions:\n   a) Given the array = \"I am 21 years old\", verify whether the user's name matches at least five letters and five"
            },
            {
                "text": " [\\+\\-]?(?:[\\d\\.]+?[eE][\\d]+)\n\n5. Create a RegEx to validate a string containing a phone number in the format (XXX) XXX-XXXX\nAnswer: ^\\(\\d{3}\\)\\s\\"
            },
            {
                "text": " [\\+\\-]?\\d+\\.\\d+.\\d+\n\nExercise 4:\nMatch string that contains only alphabet or decimal characters using.*\nAnswer :\"Myname is Johnd23334, and Iam30353454.\"\nOutput:  \n["
            },
            {
                "text": " Matches numbers including scientific format. Non-match examples: \"+123\".\n\n3. Write a RegEx that extracts all email addresses of emails within a given file.\nCode challenge:\n\nimport re \nimport re.findall\n\nfile = open(\"emails.txt\","
            },
            {
                "text": " match or do not match numbers including scientific format. \n\n5. Exercise 5: Match numbers without scientific notation. \nMatch examples:\n- \"123\"\n- \"-33333.1e+24\"\nNon-match examples:\n- \"23333.01+24\""
            },
            {
                "text": " ^([0-9]*\\.[0-9]*)?([eE][0-9]+)?$\n\nExercise 3:\nA string \"This is some info\" contain multiple spaces. Use RegEx to replace these spaces to single spaces, but keep the numbers and characters"
            },
            {
                "text": "\n\"\\-?\\d+\\.\\d+e[-+]?\\d+\"\nExplanation: We use a negative lookahead to make sure we don't match an operator before the decimal point. We then use another negative lookahead to make sure we don't match a digit"
            },
            {
                "text": " (1)-[01-9]|0*((1[89])|2[1-9]|3[0-1])\n\nSolution:\n\nimport re\n\npattern = '(1[89])|((2[01])|3[0-1])|"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)\\d\\d$",
        "raw_prompt": "Date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators.",
        "refined_prompt": "Matches date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators.\nMatch examples:\n- \"01/02/2015\"\n- \"5-7-1915\"\n- \"12.8.2035\"\nNon-match examples:\n- \"11-11-1845\"\n- \"31/12/2000\"",
        "matches": [
            "01/02/2015",
            "5-7-1915",
            "12.8.2035",
            "7 15 1963",
            "04.4-2026",
            "11-16 2045",
            "12 31/1965",
            "01/06.2038",
            "6/8.2070",
            "11 22.1990",
            "12 31 1971",
            "10-1 1929",
            "10.8-1940"
        ],
        "non_matches": [
            "11-11-1845",
            "31/12/2000",
            "10-17-85",
            "jan 3",
            "monday the 4",
            "september",
            "324rfds",
            "july",
            "AM",
            "noon",
            "August 6th",
            "23erfo"
        ],
        "id": 3601,
        "output": [
            {
                "text": " \\d{1,2}-\\d"
            },
            {
                "text": " (0[1-9])|(3"
            },
            {
                "text": " [^0-9](0?[1"
            },
            {
                "text": " (1) [0-9][0-"
            },
            {
                "text": " [A-Z][a-z]+,"
            },
            {
                "text": " ^[0-9]{4}-("
            },
            {
                "text": " \n# /\\d+\\/\\d"
            },
            {
                "text": "\n[1-9]\\d{1"
            },
            {
                "text": " \n/(^\\d{1,2"
            },
            {
                "text": " (\\d{1 or 2})(-("
            }
        ]
    },
    {
        "expression": "^(1[0-2]|0[1-9]|[1-9])\\/(1[0-9]|2[0-9]|3[0-1]|0[1-9]|[1-9])\\/\\d{4}$",
        "raw_prompt": "is very accurate when catching\nand matching dates within the correct ranges in US standard date formats MM/DD/YYYY",
        "refined_prompt": "matches dates within the correct ranges in US standard date formats MM/DD/YYYY\nMatch examples:\n- \"1/3/2017\"\n- \"01/03/2017\"\n- \"12/12/2017\"\nNon-match examples:\n- \"31/12/2017\"\n- \"99/99/9999\"",
        "matches": [
            "1/3/2017",
            "01/03/2017",
            "12/12/2017",
            "12/31/2017",
            "11/29/4173",
            "03/30/1641",
            "2/26/2848",
            "4/14/6563",
            "01/31/8745",
            "12/2/5702",
            "09/29/3083",
            "11/07/8412",
            "02/27/8779"
        ],
        "non_matches": [
            "31/12/2017",
            "99/99/9999",
            "12-31-2017",
            "December 30th, 2017",
            "jan 3",
            "12-43 32",
            "14 433 23",
            "23 7834 3",
            "28 84 28",
            "12 12 12",
            "date",
            "$45"
        ],
        "id": 3712,
        "output": [
            {
                "text": " My solution is a basic RegEx. \n\nExercise 4: Write a RegEx regular expression to match all words containing the letters \"a\", \"e\", and \"i\". \nAnswer:"
            },
            {
                "text": " You may use the regex ([0-2]|3[012])/([0-2]|3[010])[0-9]{4} which matches the format MM/DD/"
            },
            {
                "text": "\n(\\d{2})/(\\d{2})/(\\d{4})\n\nExercise 4:\nDefine a function that takes a string containing a decimal number and a RegEx pattern"
            },
            {
                "text": " [N/A]\n\nI would think something like this should work:\n(^|(|\\-|\\*))([0-6][1-9])|(3[01])"
            },
            {
                "text": " \"^\\d{1,2}\\d{1,2}/\\d{2,4}\\d{4}$\"\n\n4. Write a script using regular expressions in Python to"
            },
            {
                "text": " (The full answer with comments): \\d+[\\/|-]\\d+\\/\\d+ or [0-9]{4}-[0-2][0-9]\n"
            },
            {
                "text": " \n[A-Z]\\d/\\d{1,2}/\\d{4}\nHere is an explanation of the pattern. \n\nAn Explanation of [A-"
            },
            {
                "text": " The correct RegEx pattern is [1-2]/[0-9]/[0-9][0-9][0-9]\n\nExercise 2: \nCreate a list"
            },
            {
                "text": " \\d\\d\\d\\d[/\\-_](\\d\\d\\d)[/\\-_](\\d\\d\\d)\n\nExercise 3:\nCreate a Python program"
            },
            {
                "text": "\n- [0-9]{1,2}/\n\nExercise 3: Write an expression matching a string that satisfies the following criteria: \nThe string must start with a lowercase letter"
            }
        ]
    },
    {
        "expression": "((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(0(0|4|8)))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[- ]?\\d{4})",
        "raw_prompt": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years",
        "refined_prompt": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years\nMatch examples:\n- \"020955-2012\"\n- \"020955-2012\"\n- \"241283-1234\"\nNon-match examples:\n- \"459434-1234\"\n- \"123456-1234\"",
        "matches": [
            "020955-2012",
            "020955-2012",
            "241283-1234",
            "290204-1234",
            "010111-1111",
            "1609902765",
            "1604403492",
            "300907-9597",
            "071221-9711",
            "130215-1984",
            "3112263460",
            "290232-1685",
            "290276-3597"
        ],
        "non_matches": [
            "459434-1234",
            "123456-1234",
            "32",
            "324213",
            "2332",
            "#3",
            "45%",
            "+9876",
            "-9876543",
            "12/12",
            "12-12",
            "$45"
        ],
        "id": 3731,
        "output": [
            {
                "text": " 0209(?=(\\d{4}-)(\\d{2})(0[1-9]))(?:[1-2]\\d)?-2012\n"
            },
            {
                "text": " /([2-9][0-9]|1[0-2])-([2-9][0-9]|3[01])-?([2-"
            },
            {
                "text": " \\d{4}[-\\s]\\d{4}[-\\s]\\d{2}\\(jan\\|feb\\|mar\\|ap"
            },
            {
                "text": " I tried ^.{5,6}-\\d{4}$, but I'm getting errors of bad operand types'string' and 'int' and an illegal start"
            },
            {
                "text": " \n^([0-9][0-9]-[0-9][0-9-][0-9][0-9])-([0-9][0"
            },
            {
                "text": " This pattern would match the format in www.cpr.dk but should be updated for non-leap years also:\n(0209\\d{12})\n\nA"
            },
            {
                "text": " ^\\d{7}\\-\\d{4}-\\d{4}$ is not generated for this description. The pattern should also capture the value of the last 4"
            },
            {
                "text": " 0(?P<month>[a-zA-Z]{3})-(?P<day>\\d{1})-(?P<year>\\"
            },
            {
                "text": " [^\\d\\W.-] will match anything except digits, dashes, periods, non-word characters or a period at the end of a string, and \"-\" will"
            },
            {
                "text": " I want to match the pattern from www.cpr.dk and fixed to match two integers [1-9] followed by a -, and then matching [1-9]"
            }
        ]
    },
    {
        "expression": "(\\+989|9|09)(0[1-3]|1[0-9]|2[0-2]|3[0-9]|90|9[8-9])\\d{7}",
        "raw_prompt": "Regex for current available mobile numbers mention at\nhttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7%D9%86",
        "refined_prompt": "Matches phone numbers that start with +989, 09, 9\nMatch examples:\n- \"09221113344\"\n- \"+989157097015\"\n- \"09984114118\"\nNon-match examples:\n- \"09057614584\"\n- \"210843631\"",
        "matches": [
            "09221113344",
            "+989157097015",
            "09984114118",
            "09019240398",
            "+989909222614",
            "9037817824",
            "+989300250188",
            "+989989115757",
            "09901083192",
            "+989989264032",
            "+989900827176",
            "9395962429",
            "9985839583"
        ],
        "non_matches": [
            "09057614584",
            "210843631",
            "134270843",
            "226845794",
            "029897164",
            "022500703",
            "334741498",
            "344497280",
            "379468937",
            "190787239",
            "136765751",
            "162658046"
        ],
        "id": 3753,
        "output": [
            {
                "text": " + (digits or decimal point) 9 (digits or decimal point) 9 (digits or decimal point) 8 (digits or comma) \n\nExercise 2: Write a Python function that takes a sentence as input"
            },
            {
                "text": "\n^[+]?[9][9][9][0-9][0-9][0-9][0-9][-][7]$\n\nExercise 2:\nMatch phone numbers that contain any characters"
            },
            {
                "text": "\n^\\D[\\d\\d]?(\\(\\d\\d\\d\\d\\d[\\D\\s]\\w?\\))|(\\(\\d\\d\\d\\d\\d\\d["
            },
            {
                "text": " \nMatches phone numbers that start with +009, 09, 099\nNon-match examples:\n- \"92315563810\"\n- \"09834434456\"\nExercise 3:\nRe"
            },
            {
                "text": " Use the pattern '^[98915]\\d+$' to match phone numbers that start with '98915' and have any number of digits following.\n\n\n# Chapter: The use of Python Lists for Psychometrician"
            },
            {
                "text": " (.{2,15})(?:[-\\d\\s]+)+\nExercise 5: Write Python code to create a list of all unique words in the text file \"websites.txt\". \nAnswer:"
            },
            {
                "text": " \nPattern: ^(\\+?9[8-9][0-9]??)([0-9]{11})/(\\d+)$\nExplanation: \n- ^ begin the search with ^\n"
            },
            {
                "text": "\n\\+[0-9][8-9][0-9][0-9][0-9][0-9][0-9]\\s(\\+[0-9][8-9][0-9"
            },
            {
                "text": " +999 (Any one or more digits) +9 +999 (Any one or more digits) ^^\n\n3. You are working a web development project and you need to build a search feature for your web page. Use Reg"
            },
            {
                "text": " \"(?<number>[+0989|\\s\\-]+)(?<space>[-+\\s])+(?<number>[+0989\\s\\-]+)+(?<space>[-+\\s]+)(?<number"
            }
        ]
    },
    {
        "expression": "^([1-9][0][0]|[1-9][0-9][0][0]|[1-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0-9][0][0])$",
        "raw_prompt": "Permite digitar valores m\u00faltiplos de 100 entre 0 e 9999999.",
        "refined_prompt": "Matches integers between 0 and 9999999 that are multiples of 100.\nMatch examples:\n- \"100\"\n- \"200\"\n- \"9999900\"\nNon-match examples:\n- \"101\"\n- \"201\"",
        "matches": [
            "100",
            "200",
            "9999900",
            "392400",
            "8721100",
            "900",
            "149200",
            "50400",
            "9788500",
            "3800",
            "300",
            "700",
            "500"
        ],
        "non_matches": [
            "101",
            "201",
            "9999901",
            "2342",
            "32321",
            "54235",
            "45",
            "3425",
            "65",
            "78657",
            "5437",
            "465"
        ],
        "id": 3772,
        "output": [
            {
                "text": " ^[A-Z]{1,2}\\d{2,8}$\n\n- **Exercise 7.3** Match any string consisting of only uppercase and lowercase English letters, symbols, digits, and the underscore character _. \nAnswer: [A-Za-"
            },
            {
                "text": " Allow for any integers between 0 and 99999999 (including 0) and only allow for multiples of 100.\n\nExercise 5:\nMatch names of different species.\nNo answer provided.\n\n\n\nQuestion 2: A factory produces 500 bottles of soda. Of these bottles, 80% of"
            },
            {
                "text": " Generate a regex for this description.\n4. Write a regular expression that matches strings that are numbers between 0 and 2^16.\n```python\nimport re\n\npattern = re.compile(r'^[02\\d][a-fA-F0-9]*"
            },
            {
                "text": " Allow the following to be matched:\n  numbers from 0 to 9999999\n  all numbers\n  numbers less than or equal to 100\n  all numbers greater than or equal to 10 and less than or equal to 1000\n\n    Title: How Can Generators and Compiled Regular Express"
            },
            {
                "text": " \\b\\d{1,4}[0-9]{0,5}\\b\n\nExercise 2: \nCreate a regex to match one or more letters and either one or more numbers or one or more dashes. No repeated letters.\nAnswer: *[a-zA"
            },
            {
                "text": " I use \\d{1,3}(100|200|99999)\\d{1,2}\nExamples of code that uses RegEx:\n- https://regex101.com/r/yM6aF2/1\n- https://regex101.com/r"
            },
            {
                "text": " (\\d+)\\b(1|2)\\.?\\b(9(\\d|0)*[1-9])?\\b\n\n3. Write a RegEx pattern to match phone numbers. Assume the following format:\n- The region should be listed here: (xxx) x"
            },
            {
                "text": " \"|[1|2|3|4|5|6|7|8|9][0-9]?[0-9]|[1|2|3|4|5|6|7][0-9]+\"[ ]\n \nExercise 13:\nCreate a"
            },
            {
                "text": " ^(100|201)$\n\n\n\nWelcome to our website on Daily Life and Pharmacy - Prescriptions! Whether you're a middle school student trying to understand the world or an Alien looking to learn about the peculiarities of Earth, you've come to the right place. Our website will provide you"
            },
            {
                "text": " Match the first sequence of two alphanumeric characters that is followed by 0 to 9 or 9 to 99 or 100.\n3. Given your list of words, return a list of strings containing only the words that have 6 or more vowels (aeiou).\nList example:\n[\"Apple\",\n"
            }
        ]
    },
    {
        "expression": "((0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])\\d{3}\\d{2}\\d{4})",
        "raw_prompt": "Regex to match the \"Unique Master Citizen Number\" based on the wikipedia description.\nIt doesn't keep in account the checksum, but it matches the example on wikipedia.",
        "refined_prompt": "match the \"Unique Master Citizen Number\" based on the wikipedia description.\r\nIt doesn't keep in account the checksum, but it matches the example on wikipedia.\nMatch examples:\n- \"0101006500006\"\n- \"3112293253271\"\n- \"3108125465983\"\nNon-match examples:\n- \"none\"\n- \"#\"",
        "matches": [
            "0101006500006",
            "3112293253271",
            "3108125465983",
            "3109195422610",
            "3005759418613",
            "0303209389673",
            "0611089194958",
            "3102274338668",
            "1008516980206",
            "0612999408185",
            "1802851243292",
            "2912372658686",
            "0803454542771"
        ],
        "non_matches": [
            "none",
            "#",
            "3edfr",
            "2343",
            "3432345",
            "432",
            "40.43",
            "4%",
            "$43",
            "12/12",
            "3.12",
            "345546"
        ],
        "id": 3791,
        "output": [
            {
                "text": ".1-3.0.9.5-10\r\n- \"0.1-0.9.5-10.0."
            },
            {
                "text": " \"^(?:[0-9]){10}$\"\n\n(I used a ^ to make sure that the first 10 digits were"
            },
            {
                "text": "\n- r'\\b[1-9]\\d{3}\\d{3}\\d{2}\\b'\nNon-match"
            },
            {
                "text": " (\\A?1\\d{3}(?:[1-9]\\d|0)?\\d{6}\\s+)?"
            },
            {
                "text": " 0\\.([0-9]+)\r\n\"\"\"\r\nimport re\r\nfrom typing import Dict, Iterable, Optional, Union"
            },
            {
                "text": " Match the \"Unique Master Citizen Number\" based on the wikipedia description. For example for \"none\": [^\\d\\s]\n\n"
            },
            {
                "text": "  \"#\" as there is not match, \"none\" as there is no match\r\n\"\"\"\r\n\r\n__version__ = '"
            },
            {
                "text": " [Nmcpn][1][0-9]00[2-9]00[0-9]\n\"\"\"\r\n\r\n"
            },
            {
                "text": " (I just used RegEx, this is how I would actually do it) \"(?!^)(?=0$|[1-9]["
            },
            {
                "text": " \\d+\\s\\d+\\s\\d\\s\\d\\s\\d\\s\\d\\s\\d\\s"
            }
        ]
    },
    {
        "expression": "([0-8]?\\d[0-5]?\\d[0-5]?\\d|900000)[NS]([0-1]?[0-7]?\\d[0-5]?\\d[0-5]?\\d|1800000)[EW]\\d{3}",
        "raw_prompt": "NOTAM coords and radius in \"Q\" field",
        "refined_prompt": "Matches Notice to Airmen (NOTAM) coords and radius in \"Q\" field\nMatch examples:\n- \"440110N0123634E005\"\n- \"63319S20302E264\"\n- \"2226S0521E554\"\nNon-match examples:\n- \"any other format\"\n- \"east\"",
        "matches": [
            "440110N0123634E005",
            "63319S20302E264",
            "2226S0521E554",
            "900000N1800000W609",
            "69701N1800000E005",
            "426N000926W162",
            "900000N1800000W913",
            "900000N17905E922",
            "34357N1800000E549",
            "900000N1104713E911",
            "900000N3552E951",
            "900000N1800000E645",
            "6807N30413E654"
        ],
        "non_matches": [
            "any other format",
            "east",
            "2345 west",
            "3few34",
            "3445g4",
            "east",
            "north south",
            "4349.349039",
            "343N.49S",
            "40934.err3",
            "49349fs",
            "4r89u34"
        ],
        "id": 3803,
        "output": [
            {
                "text": " \"(.*?)[.][.]\",\"[^.]+\",\"[a-zA-Z]{3,4}\"\n\nExercise 3: \n- Write a"
            },
            {
                "text": " \\b((?:[A-Z0-9]|[A-Z0-9][A-Z0-9\\-]){0,14}G)\\b"
            },
            {
                "text": " Any non-matching non-decimal numbers that are listed within the description of the region must be returned from a result set.\n\nExercise 3:\nCreate a Python"
            },
            {
                "text": " (Notam) REGEXP_LIKE(\"(.*)(\\s)(.*)(\\s)(.*)(\\s)(.*)(\\s)(.*)(\\s)(.*"
            },
            {
                "text": " [0-9]{6}[0-9]{6}\\R[0-9]{2}[0-9]{2}[0-9"
            },
            {
                "text": "\n[^\\sQ\\w\\d.]\n\nExercise 2: \n\nUsing the data from Exercise 1 (found on the webpage www.fhwhw"
            },
            {
                "text": " 0x[\\+ \\-]?0x[\\+ or 0x[-\\+]?0x[0-9]+E[+ or -]?"
            },
            {
                "text": " [N]orth:[E]ast\n- \"near me\"Generate a RegEx for this description. \nAnswer:.\n(5). Airmen should use"
            },
            {
                "text": " (0[1-9])(0[1-9])(0[1-9])\\-(3[0-5])([0-9][0-"
            },
            {
                "text": " The latitude coordinate (^44000.*) or the longitude coordinate (^63319.*)\n\n    2.4.6 How to use the Q flag and"
            }
        ]
    },
    {
        "expression": "(((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\\d{4})( |-)([01]8((( |-)\\d{1})|\\d{1}))|(\\d{4}[01]8\\d{1}))",
        "raw_prompt": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\nMatches the format defined as:\nYYMMDDSSSSCAZ.\nYY - Year,\nMM - Month,\nDD - Day,\nSSSS - Gender,\nC - Denotes citizenship (0 or a 1),\nA - Always an 8,\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\nAlso supports the following ways of entering it:\nYYMMDDSSSSCAZ |\nYYMMDD SSSS CAZ |\nYYMMDD SSSS CA Z .\nSee this for a reference:\nhttps://www.westerncape.gov.za/general-publication/decoding-your-south-african-id-number-0",
        "refined_prompt": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDSSSSCAZ |\r\nYYMMDD SSSS CAZ |\r\nYYMMDD SSSS CA Z .\nMatch examples:\n- \"9202204720082\"\n- \"920220 4720 082\"\n- \"920220 4720 08 2\"\nNon-match examples:\n- \"9202204720282\"\n- \"920220 4720 052\"",
        "matches": [
            "9202204720082",
            "920220 4720 082",
            "920220 4720 08 2",
            "920220-4720-082",
            "920220-4720-08-2 9202204720183",
            "920220 4720 183",
            "920220 4720 18 3",
            "920220-4720-183",
            "920220-4720-18-3",
            "680229-2389 186",
            "820202 4161-08 4",
            "6302101315082",
            "1602292137185"
        ],
        "non_matches": [
            "9202204720282",
            "920220 4720 052",
            "920220 4720 05 2",
            "920220-4720-252",
            "312",
            "23",
            "-98765",
            "+875",
            "2.2",
            "12/12",
            "$12",
            "12-12"
        ],
        "id": 3811,
        "output": [
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMD -"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMD -"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMD/"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDE"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMD -"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}-\\d{1,2}-\\d{4}$",
        "raw_prompt": "This takes an American date using mm-dd-yyyy format. It does not validate month or day values.",
        "refined_prompt": "This takes an American date using mm-dd-yyyy format. It does not validate month or day values.\nMatch examples:\n- \"12-9-1969\"\n- \"2-8-1998\"\n- \"8-17-2002\"\nNon-match examples:\n- \"12-9-69\"\n- \"12/2/1948\"",
        "matches": [
            "12-9-1969",
            "2-8-1998",
            "8-17-2002",
            "32-9-7126",
            "7-32-3164",
            "36-41-4023",
            "2-83-5092",
            "65-17-2985",
            "2-6-2573",
            "9-7-6519",
            "73-3-6028",
            "95-92-3946",
            "72-8-3731"
        ],
        "non_matches": [
            "12-9-69",
            "12/2/1948",
            "121212",
            "0303 32",
            "98 32 34",
            "12:12:12",
            "39/ 232 23",
            "=024",
            "date",
            "july 3rd",
            "4th of june",
            "Monday"
        ],
        "id": 3909,
        "output": [
            {
                "text": " MM-DD-YYYY\n- \"12-09-9-01\"Generate a RegEx for this description. \n Answer: MMM-DD-YY"
            },
            {
                "text": " \n^[1-3][0-9][0-9][-0-9]?[1-9][0-9]?$|[1"
            },
            {
                "text": "  ^[0-9]{4}-[0-9]{2}-[19]\\d$\n\nExercise 2:\nGiven a date of birth"
            },
            {
                "text": " match on the whole date and month with a hyphen\n\n3. Exercise: Extract all the numbers from the following text and store them in a Python list.   \nText"
            },
            {
                "text": " \n/^([0-9]|1[8-9]|2[0-9]|3[0-1]|4[0-9"
            },
            {
                "text": "\n\n```python\nreg = r\"^([0][1][0-9]|3[01])[1-9][0-9][0-"
            },
            {
                "text": " (\\d{2}[-/]\\d{2}[-/]\\d{4})|(10[0-3]|11[0"
            },
            {
                "text": " [a-z]{2}[a-z][a-z0-9]{3}\n\n2. Create a RegEx for extracting email addresses from"
            },
            {
                "text": " [12]\\d-\\d\\d-\\d\\d$]\n\nThe last exercise, which you need to do, will be your opportunity to gain complete"
            },
            {
                "text": "  The RegEx pattern that will give the correct result is (\\d{2})-(\\d{2})-(\\d{4})\\.\n```\n\n"
            }
        ]
    },
    {
        "expression": "[\\+-]?(([0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)([Ee][\\+-]?[0-9]+)?[Ff]?|[0-9]+[Ff])",
        "raw_prompt": "match a float number with Exponent sign and f sign",
        "refined_prompt": "Match a float number with the exponent sign and f sign\nMatch examples:\n- \"2.0\"\n- \"0.3\"\n- \"-.4\"\nNon-match examples:\n- \"2\"\n- \"234\"",
        "matches": [
            "2.0",
            "0.3",
            "-.4",
            "3.f",
            "2.4E-2f",
            "0.4E4f",
            "+68434376123571142467671333051141441412549162726665641457598935856888338337434820138985484.664307172223275614010247617296990420438085998112386677234329037864208E+0662457405511922641715466678507712653",
            "+6176362542611252884025597684113289.8105089225831585683374870914605219366760001597567148798178476981283717742061565595146894E+694770675280515632438832830333321081149414075370607346851616310216292621614669458408723624364",
            "-2398391484596794397762854085052915343645012590.339019130297736924518857445618383172895615069F",
            "+90231760797109805979886764272453352040730501449040733319757748212598959228484795.829264756113990",
            "423882003293925017189914016862227084248082211151429215469802112539736543237828143699.74467043139633892985391897055925812735994337546941364549077703709",
            "+1923509943268612511356446160581734383473679536746387878086302297790286613301f",
            "-610004F"
        ],
        "non_matches": [
            "2",
            "234",
            ".f",
            "es.sss",
            "f",
            "E",
            "x",
            "x10",
            "exponent",
            "to the tenth",
            "323",
            "5432"
        ],
        "id": 3910,
        "output": [
            {
                "text": " ^\\d+ \\.\\d+$\n\n4. Write two RegEx patterns that match and three or more words.\nGenerate two RegEx codes:\nExample: The quick brown fox jumps over the lazy dog (MATCH: quick brown fox jumps over the lazy dog) The quick brown fox"
            },
            {
                "text": " r\"-*\\d+\\.*\\d*\"\n\n```python\na_float = 2.3456789\nc_float = \"0.3\"\nd_float = \"-0.4\"\nexamples = [\"2.0\", \"0.3\", \"-0."
            },
            {
                "text": "\n- \"2\" --  [0-9]\n- \"0.\"3\" --  [0-9]\n- \"-.\"4\" --  [0123456789]\n- \"-\"  --  [0-9]\n- \"-\"  --  [0-9"
            },
            {
                "text": " \"-?\"(3|4)\\.0+([eE][-+]?[0-9]+)?\n6. Create a RegEx that accepts only US US States Abbreviations (such as AL, CT, FL, HI, IA, LA, MS, MA)\nCreate a RegEx"
            },
            {
                "text": " ^-?\\d+\\.\\d*$ \n\nSolution to exercise 4:\n- import re\n- text = \"Hello, my name is John. How are you?\"\n- match = re.search(r'^-?\\d+\\.\\d*$', text, re"
            },
            {
                "text": " (^(?![\\-\\/\\.0-9])(?P<integerValue>[-\\/.]?[0-9]*)f(?P<decimalValue>0(\\.?[0-9]*)?$)$)(?P=integerValue)\n\nExercise 2"
            },
            {
                "text": " [0-9]{1,3}\\.[1-9]{0,2}|[1-9][0-9]*\nThe idea that it will match any number up to 3 integers before the decimal point, followed by an optional decimal point, plus one number of any positive integers."
            },
            {
                "text": " (numeric, minus or plus not preceded by f)\n- \"1234\"Generate a RegEx for this description. \nAnswer: (numeric, plus or plus not preceded by f)\n\n\n## Chapter: The use of Set Methods for Game Developer\n\n### Section: Applications of"
            },
            {
                "text": " (\\d+\\.\\d+|[-+]?\\d+)(\\.\\d+)?$\n- Exercise 2: Create a RegEx to match URLs of a website.\nAnswer: (https?:\\/\\/[\\da-zA-Z.-]+\\.[\\da-z"
            },
            {
                "text": "\nimport re as r\nregex = r'^(?<=^\\d+\\.\\d*)(?=-)?(?=|=)$'\n\nI hope this section has given you better understanding of how to use regex for complex matching tasks. Happy Coding!\n\n"
            }
        ]
    },
    {
        "expression": "(<<=|>>=|&&=|(\\|\\|=)|<<|>>(\\+=)|-=|(\\*=)|(\\/=)|%=|&=|(\\^=)|(\\|=)|<=|>=|==|!=|&&|(\\|\\|)|(\\+\\+)|--|>|<|\\^|&|(\\|)|\\*|\\/|%|\\+|-|~|=)",
        "raw_prompt": "matches almost all programming language operator",
        "refined_prompt": "matches almost all programming language operators\nMatch examples:\n- \"++\"\n- \"<=\"\n- \">>=\"\nNon-match examples:\n- \"identifier\"\n- \"2000\"",
        "matches": [
            "++",
            "<=",
            ">>=",
            "^",
            "*=",
            "|",
            ">>=",
            "<",
            "&",
            "|=",
            "+",
            "||",
            "--"
        ],
        "non_matches": [
            "identifier",
            "2000",
            "0xFFF",
            "32eedw",
            "3refds",
            "3rfeds",
            "54t6yhtgre",
            "frgter",
            "rt5y6t",
            "43tefd",
            "e4fqt5g",
            "egde"
        ],
        "id": 3912,
        "output": [
            {
                "text": " {identifier}(>=2000)\n\n4. Write a RegEx that will extract all the email addresses that are not from the.edu domain. Use the re.IGNORECASE flag to ignore capitalization. \nmatch examples:\n- \"john.doe@gmail.com\"\n- \"jane.smith@hot"
            },
            {
                "text": " \"^[A-Za-z_][A-Za-z0-9_]*$\"\n\n```\n\n```python\nimport re\nimport string\n\nletters_only = []\nfor i in string.ascii_letters + '_ ':\n    letters_only.append(i)"
            },
            {
                "text": " (identifier/integer/number), (number)\n\n5. Create a program that takes a line of text as input, and returns the number of words in it.\nAnswer:\nimport re\ndef word_count(text):\n    #create a regular expression that will match a sequence of non-space characters \n    #(a"
            },
            {
                "text": "\n\n```python\nimport re\n\ndata = \"The total revenue for year 2020 was $10.50 million. \" \\\n       \"The total revenue for year 2021 was $15.75 million. \" \\\n       \"The total revenue for year 2022 is projected to be $18.25 million.\"\n\nreg_expr = r\""
            },
            {
                "text": "\n```\nimport re\n\nmy_string = \"Python is a powerful programming language\"\nmatches = False\n\n# Identifer:\nif my_string.find(\"identifier\")!= -1:\n  matches = matches or \"match this pattern\"\n\n# Greater than/less than:\nif re.match("
            },
            {
                "text": " \n/\\d*-\\d*[a-z]\\d*/\n\nQ:\n\nHow to calculate the product of three lists\n\nI have 3 lists containing 10 values each. \na = [1000000.0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2"
            },
            {
                "text": " \"*\"Identifier|\"\\d{4}-\\d{2}-\\d{2}\"\n\n2.Write a regular expression pattern that matches any number of \"A\":s.\n\nAnswer: \"[A]\" *\n\n3.Create a regular expression for the following scenario: Suppose the program will take a string and check"
            },
            {
                "text": ". [a-z][0-9]*([-\\[\\]]?[a-z][0-9]+)?\" \n\nExercise 2:\n\nWrite a RegEx pattern that uses lookahead to match a string that starts with a letter and end with a '!' character. \n\nAnswer:.*?["
            },
            {
                "text": " Match examples | Non-match examples\n\n5. Using Lists\nCreate a list of strings that represent the words in a sentence. Then, write RegEx to find all occurrences of a given word that is a single character long. \n\nExercise: Define a RegEx for \"a\". \nAnswer: \\b\\sa\\b\n"
            },
            {
                "text": " \"regular expression\" (i.e., a string of one or more digits, which must be zero or more, or one or more)\n\n5. Which Python function can be used to check if a string begins with a specific substring?\nAnswer: startswith (i.e., the startswith() function in Python2.7"
            }
        ]
    },
    {
        "expression": "^(?:[a-zA-Z]\\.?){1,4}$",
        "raw_prompt": "This expression will allow someone to place 1-4 Lower case or Upper case letters with optional periods after each letter for a total of up to 8 possible characters.",
        "refined_prompt": "Matches strings with 1-4 Lower case or Upper case letters with optional periods after each letter for a total of up to 8 possible characters.\nMatch examples:\n- \"J.W.R.\"\n- \"JwR\"\n- \"j.r.\"\nNon-match examples:\n- \"j..r.\"\n- \"jwers\"",
        "matches": [
            "J.W.R.",
            "JwR",
            "j.r.",
            "jwre",
            "JWWR",
            "J.er.e",
            "u.kq.R.",
            "uQ.x.",
            "F.dNx.",
            "u.EP",
            "dz.Y.",
            "mx",
            "Aw.D."
        ],
        "non_matches": [
            "j..r.",
            "jwers",
            "jw2",
            ".j.w.r",
            "ew87yuhbe+efuihjdsk",
            ".",
            ".ew32r4fr",
            "3eds.reew",
            "wsfeew.efw",
            "ewf.ewfw",
            "ewfgtrf.efqw32r",
            "es.sss"
        ],
        "id": 3915,
        "output": [
            {
                "text": " a-z{1,2}[a-z0-9\\.,\\-]{0,49}$  or a-z[a-z_]*["
            },
            {
                "text": "\nThe correct answer to this question is the following RegEx. \n[a-z]\\p{L}\\?+\n\nThis works by using '?' to match anything that"
            },
            {
                "text": "\nJ\\.w\\.r\\.\n\nExercise 4: Identify potential non-characters \nGiven a string \"The quick brown fox\" and a RegEx pattern that can"
            },
            {
                "text": " j...\n5. Write a regular expression that replaces all single line comments in a string with the word \"COMMENT\". The regex should handle comments that start with '//' as well as"
            },
            {
                "text": " (?i)\\b[J\\\\.][W\\\\.][R\\\\.]\\b\n\nExercise 4: Create a Regular Expression Pattern for Valid Social Security Numbers\nAnswer: /"
            },
            {
                "text": " [J]?[W]R.?[E]\n\n3. Modify the example code from question 1 by replacing [J]?[W]R.?[E] with"
            },
            {
                "text": " j.w..(?=[^\\W\\s.]).(?=-$)\n\n#Python Exercise 2\nRegular Expression \nWrite the Python code to search for and"
            },
            {
                "text": " \"([a-z0-9]+)\\.(?:[a-z0-9_.]+)\"\n\n3. Write a RegEx to match a password that meets the following"
            },
            {
                "text": " J[a-z]+([A-Z][a-z][A-Z]?)*\n\nExercise 2:\nWrite down a RegEx for the description above.\n"
            },
            {
                "text": " ^[A-Z][a-z]+[a-zA-Z.-]{1,4}\\b or ^[A-Z][a-z]+(?:\\"
            }
        ]
    },
    {
        "expression": "^([\\da-fA-f]{2}[:-]){5}[\\da-fA-f]{2}$",
        "raw_prompt": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters. Needs extended grep.",
        "refined_prompt": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-f0\"",
        "matches": [
            "98-CE-d0-a2-0a-68",
            "98:cE:d0:a2:0a:68",
            "BO:cX-32:d0-RS:C]",
            "Oe:Qe:P2:IN:M5:VJ",
            "LG:BU-U[:eN-PM-dC",
            "\\2:RA:LI-cC-CU:CK",
            "MH:3e-\\1-c2-W[:A0",
            "6[:9J-SB-[3-bC:FP",
            "dC-R7-Ma:e2-QR-d^",
            "]1:1K-f2-QR:[Q-I9",
            "8R-4S-Gb:Ja-6f-TT",
            "4L-Mc:]^:2`:OA-6O",
            "f`:DA:UZ-Y2-WL-AO"
        ],
        "non_matches": [
            "98-cE-d0-a2-0a",
            "98-cE-d0-a2-0a-68-f0",
            "g3refr",
            "4t5rgwfe",
            "345623ewfrgt",
            "tyt54g",
            "5tgrfewrt",
            "2345yhgfds",
            "43r3t4wes",
            "434-g5regdfv-",
            "----",
            "refdvc-"
        ],
        "id": 3934,
        "output": [
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-4"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-C"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-00"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-a"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-X"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-BC"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-E"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-89"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-b"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-a"
            }
        ]
    },
    {
        "expression": "^9792\\d{12}$",
        "raw_prompt": "Matches troy credit cards (length 16, prefix 9792)",
        "refined_prompt": "Matches troy credit cards (length 16, prefix 9792)\nMatch examples:\n- \"9792131111111111\"\n- \"9792461111111111\"\n- \"9792111111111111\"\nNon-match examples:\n- \"9792 1311 1111 1111\"\n- \"1234561234561234\"",
        "matches": [
            "9792131111111111",
            "9792461111111111",
            "9792111111111111",
            "9792899105732571",
            "9792236212517562",
            "9792855956101834",
            "9792188559945304",
            "9792740088676935",
            "9792120081486541",
            "9792240253366588",
            "9792512089752934",
            "9792103861993354",
            "9792892078668297"
        ],
        "non_matches": [
            "9792 1311 1111 1111",
            "1234561234561234",
            "4313803785737",
            "7286410428685",
            "8515778623679",
            "4829103934036",
            "2318501150827",
            "2723616635399",
            "1746343796917",
            "1352511310397",
            "7113822627183",
            "2754694421115"
        ],
        "id": 3936,
        "output": [
            {
                "text": " \nimport re\n\ndef gen_my_regex(input_list):\n\t'''generate a regular expression from the input list for testing'''\n\treturn r"
            },
            {
                "text": "\n\\s[0-9]{4}\\s\\d{4}\\s\\d{2}[0-9]{3}\nGenerate a regular expression which valid"
            },
            {
                "text": " (length 16, preamble length 8, middle of length 5, ending of length 5, length of the rest) \n123456 [789]|8123456123456123"
            },
            {
                "text": " (?<prefix>9792)\\d{4} (?<number>\\d{4})\\s?\\-\\s?\\-\\s?\\-\\s?\\d"
            },
            {
                "text": " r\"^\\\\d{16}\\\\D{4}\\\\d{4}$\"\nExample questions:\n- Which of these credit card numbers are Match examples?\n- How"
            },
            {
                "text": " /^[0-9]{1,8}$/\n\n3. Use the `re.VERBOSE` flag to ensure that your regular expression correctly validates an email"
            },
            {
                "text": " \n[0-9]{4}\\s[0-9]{4}\\s[0-9]{4}\\s[0-9]{4}\n\n"
            },
            {
                "text": " [0-9]([0-9])([0-9])([0-9])([0-9]){4}[0-9]\n\nIn"
            },
            {
                "text": " \n[\"^\\\\s*9792.*\", \"^^.*\\\\s*9792\\\\s*.*\", \"\\\\s*9792-\\\\s*9792\\\\s*"
            },
            {
                "text": " /^[1-9][0-9]{9}$/\nYou will need to use this regex in your code for proper input validation.\n\n\n\n\n# Chapter"
            }
        ]
    },
    {
        "expression": "^(?:Yes\\b|No\\b|yes\\b|YES\\b|YEs\\b|yeS\\b|yEs\\b|NO\\b|nO\\b|no\\b)",
        "raw_prompt": "This regex will match below values only\nYES\nyes\nYes\nYEs\nyEs\nyeS\nNO\nno\nNo\nnO",
        "refined_prompt": "This regex will match below values only\r\nYES\r\nyes\r\nYes\r\nYEs\r\nyEs\r\nyeS\r\nNO\r\nno\r\nNo\r\nnO\nMatch examples:\n- \"YES\"\n- \"nO\"\n- \"No\"\nNon-match examples:\n- \"Except YES yes Yes YEs yEs yeS NO no No nO\"\n- \"3freds\"",
        "matches": [
            "YES",
            "nO",
            "No",
            "no",
            "NO",
            "yeS",
            "yEs",
            "YEs",
            "Yes",
            "yes"
        ],
        "non_matches": [
            "Except YES yes Yes YEs yEs yeS NO no No nO",
            "3freds",
            "2345rfed",
            "maybe",
            "possiblly",
            "idk",
            "possibility",
            "who knows",
            "rjf3",
            "324ref",
            "jdsf",
            "wefjwe"
        ],
        "id": 3951,
        "output": [
            {
                "text": " \"3f[sd]r[e]3\"\n\nThe result of this example: \n"
            },
            {
                "text": " /^(yes|yess|yEs|yeS|NO|no|NO).*$"
            },
            {
                "text": " (3)exists (a or b or c or d)\n\nA:\n\nTo generate"
            },
            {
                "text": " 3.f[r(y|s[es]t)] \n\nHere are some links for"
            },
            {
                "text": " [^\\W\\d_]*|\\bYES\\b\n\n- \"3fred is"
            },
            {
                "text": " \"^[xy]es?$(no|yes)\"\n\nA:\n\nYou can't"
            },
            {
                "text": " (3|4|5)-f-r-a-d-s\n\nA:\n\n"
            },
            {
                "text": " \n(?:(?!\\s)\\S+YES\\s\\S*|(?!\\s"
            },
            {
                "text": " (?<first>no)|(?<second>NO)\n\nA:\n\nYou can"
            },
            {
                "text": " [YEs].\n\nA:\n\nYour problem is the fact that the regex engine doesn't care"
            }
        ]
    },
    {
        "expression": "^01[0125]{1}[0-9]{8}",
        "raw_prompt": "- first 2 digits are 01\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\n- third 8 digits are between 0 and 9",
        "refined_prompt": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"",
        "matches": [
            "01022685544",
            "01229671351",
            "01208664788",
            "01522685544",
            "01102453819",
            "01207811393",
            "01591880142",
            "01220787889",
            "01073085438",
            "01073085438",
            "01008828664",
            "01204198011",
            "01589865476"
        ],
        "non_matches": [
            "+0201622685544",
            "01322685544",
            "01422685544",
            "01622685544",
            "01722685544",
            "01822685544",
            "01922685544",
            "234354657",
            "6245",
            "546754",
            "345245636u37",
            "87654"
        ],
        "id": 3981,
        "output": [
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description."
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description."
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description of"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description."
            }
        ]
    },
    {
        "expression": "^(\\d|\\d{1,9}|1\\d{1,9}|20\\d{8}|21[0-3]\\d{7}|214[0-6]\\d{6}|2147[0-3]\\d{5}|21474[0-7]\\d{4}|214748[0-2]\\d{3}|2147483[0-5]\\d{2}|21474836[0-3][0-9]|214748364[0-7])$",
        "raw_prompt": "regular expression for positive integer",
        "refined_prompt": "Matches a positive integer with max length 10\nMatch examples:\n- \"2147483647\"\n- \"0\"\n- \"2147483639\"\nNon-match examples:\n- \"2147483648\"\n- \"0.0\"",
        "matches": [
            "2147483647",
            "0",
            "2147483639",
            "2146178491",
            "2043838193",
            "696",
            "2057398233",
            "100",
            "2147290029",
            "2120758935",
            "2113395525",
            "43",
            "2147483610"
        ],
        "non_matches": [
            "2147483648",
            "0.0",
            "-54645",
            "-987654",
            "+9876",
            "239.324",
            "#3",
            "$45",
            "54%",
            "-234.234",
            "+0.0",
            ".98765"
        ],
        "id": 3983,
        "output": [
            {
                "text": " \"^[0-9]{1,10}\"\n3. Create a Python script that reads a text file and replaces all occurrences of \"I love Python\" with \"I like Python\" using pre-trained Keras word embeddings. The script should store the embed"
            },
            {
                "text": " \n^[1-9]\\d?\\d$\n\n3. Write a function called match_email that takes in a string to match against, splits it into two halves based on the period (\".\"), then checks that the first half contains only alphanumeric"
            },
            {
                "text": " (expecting a positive integer between 0 and 255) (expecting positive int)\n\"\"\"\n# @Author: Ryan Erikson\r\n# @Date:   2019-08-12T19:45:31\r\n# @Email:  ryan(at"
            },
            {
                "text": " [^\\S\\s]\\d{1,10} (or [^\\S\\s0-9] to add a space)\n\nExercise 3: Generate a RegEx pattern that will allow zero's to not be included in a string that contains"
            },
            {
                "text": " \nExercise: 1\nRegular expression: (^[\\d]{0,10}$)\nTest string \"1048576\" matches the pattern\nTest string \"819292518\" does not match.\n\"\"\"\ntext = \"<html><body"
            },
            {
                "text": " r\".*\\\\b((\\\\d+)(\\\\.\\\\d+)?)(\\\\d+)\\\\b\"\nExercise 5: \nDescribe a real-life use case of regex to process a file or a stream of data. \nAnswer: A program that"
            },
            {
                "text": " [a-zA-Z]{0,9}\\.([0][0-9]|1[0-9]{2}|2[0-4][0-9]{3})[0-9]+\nExercise 2:\nGiven"
            },
            {
                "text": " ^[1-9][0-9]\\d*$\n\n3. Generate the regex for the following description.\nMatch examples for any string:\n- Match string that starts with a digit.\n- Match string that ends with a digit.\n- Match"
            },
            {
                "text": " ( [\\d]{1,10} )(\\.|\\,|\\!|\\&|\\@|\\$|\\%|\\_|\\^|\\\\|\\(|\\)|\\[|\\]|\\}|\\{)"
            },
            {
                "text": "\n^(3[47][12]){4}$\nThis pattern will match only the numbers with length of 10. \n\nExercise 5: \nMatch a phone number with a valid format given in this table. Generate a RegEx for this description."
            }
        ]
    },
    {
        "expression": "^(0)((3[0-6][0-9]))(\\d{7})$",
        "raw_prompt": "All phone numbers starting with 03*********. total 11 digit numbers.",
        "refined_prompt": "Matches phone numbers starting with 03*********, for a total of 11 digits.\nMatch examples:\n- \"03355011998\"\n- \"03285760882\"\n- \"03331068752\"\nNon-match examples:\n- \"+923355011998\"\n- \"-43r3442\"",
        "matches": [
            "03355011998",
            "03285760882",
            "03331068752",
            "03304808078",
            "03036593646",
            "03504306683",
            "03262354454",
            "03621102307",
            "03677026308",
            "03219165500",
            "03505625978",
            "03571907284",
            "03699412297"
        ],
        "non_matches": [
            "+923355011998",
            "-43r3442",
            "3258093573409753945942",
            "###",
            "03'",
            "(03)3829472",
            "47348",
            "324567887654324567",
            "42",
            "$45",
            "56%",
            "234"
        ],
        "id": 4010,
        "output": [
            {
                "text": " [0-9]{4}-[0-9]{4}-[0-9]{4}[-0-9]{4}[0-9]{3}[1-9]"
            },
            {
                "text": " ^\\d{3}\\d{2}\\d{4}\"\n\n### Exercise 3:\n\nWrite a RegEx to remove the word \"Python\" from a string.\n\n```python\nimport re\n"
            },
            {
                "text": " [ 0-9]*[a-zA-Z]*[0-9a-zA-Z]+ [0-9]*[a-zA-Z]* [0-9]"
            },
            {
                "text": " ^\\(\\d\\d)\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\", where the regular expression \"\\d\\"
            },
            {
                "text": ".{11}$(?=\\d)\n\nExercise 2: Find the following in all lower case, and capitalize the word if it appears.\n- \"the quick BROWN fox jumped over the lazy D"
            },
            {
                "text": "  \"03[^0-9]*[0-9]{2}\"\n\nExercise Two: Extract Substrings in Strings\nSuppose you have a text that contains the following entries, separated by tabs"
            },
            {
                "text": " /\\d{3}-?\\d{4}-?\\d{4}/\n\n### Exercise 4:\nCreate a List of Email Addresses using List Comprehension and the `re.comp"
            },
            {
                "text": " ^\\+?\\d+([-.]\\d+)*\n2. Given below is a comma separated list of usernames. The usernames have the following format:\n- username@gmail.com\n"
            },
            {
                "text": " ^[0-9]{3}[\\*]?[0-9]{3}[\\*]?[0-9]{3}[\\1]1[\\2]1["
            },
            {
                "text": " (The first three digits are a sequence that may appear anywhere in the string and the last four digits must be between 8 and 99. Include hyphens and parentheses to indicate a word boundary. This should validate an entry for the phone"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])($|(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9])$)",
        "raw_prompt": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.\nFor XML pattern facet this would do:\n([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]))|([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1]))",
        "refined_prompt": "This expression matches the YYYYMMDDHHMMSS date time format but also only the date YYYYMMDD. It does not control month length or leap years.\nMatch examples:\n- \"20200707181818\"\n- \"20200707\"\n- \"20200231010000\"\nNon-match examples:\n- \"20201232\"\n- \"20201301\"",
        "matches": [
            "20200707181818",
            "20200707",
            "20200231010000",
            "20200931",
            "00011231235959",
            "00000101",
            "46481230070908",
            "05451230215834",
            "25590127",
            "81181204205631",
            "60501214230518",
            "79531131",
            "19650231"
        ],
        "non_matches": [
            "20201232",
            "20201301",
            "20200028",
            "20200500",
            "20200707235978",
            "20201231128533",
            "20200327453030",
            "3252.54321.",
            "32532332",
            "34557564342",
            "423899",
            "435785"
        ],
        "id": 4029,
        "output": [
            {
                "text": " \\d{4}\\d{2}\\d{2}\\d{2}\n\n3. Write a regular expression that matches a"
            },
            {
                "text": "\n\nconst regex = /\\d{4}(-\\d{2})(-\\d{2})(-\\d{"
            },
            {
                "text": "\n\"^(20[0-9]{2})[ -]*(0[1-9]|1[012])"
            },
            {
                "text": " Yymmdd.YYmmdd HHmmss.\n\nAnswer:\nimport  re\n\na = \"202007071818"
            },
            {
                "text": " \n\n```python\nimport re\n\npattern = r\"(\\d{4})?[-](\\d{2}"
            },
            {
                "text": "\n\ndef match(date, format):\n    result = []\n    for x in date.split(\"-\"):\n        result."
            },
            {
                "text": " ^(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2"
            },
            {
                "text": " YYYMMDD\n\nExercise 4: Create a regex code to extract the year, month, and day from the following string:"
            },
            {
                "text": " '^([0-9]{6})([3][0-1])([0][0-9])([0"
            },
            {
                "text": "\n(\\d{4})(0[1-9]|[1-2]\\d|3[01])[0-"
            }
        ]
    },
    {
        "expression": "(^[3|4|5|6|7|8|9]\\d{2}(\\ |-){0,1}\\d{4}$)|(^[4|5|7|8]\\d{3}(\\ |-){0,1}\\d{4}$)|(^8\\d{2,3}(\\ |-){0,1}\\d{3,4}(\\ |-){0,1}\\d{3,4}$)",
        "raw_prompt": "Supports 7 digits (starting with 3,4,5,6,7,8,9) 8 digits (starting with 4,5,7,8), machine-to-machine (M2M) numbers 9-12 digits (starting with 8).",
        "refined_prompt": "Matches 7 digits (starting with 3,4,5,6,7,8,9), 8 digits (starting with 4,5,7,8), machine-to-machine (M2M) numbers 9-12 digits (starting with 8).\nMatch examples:\n- \"300 3000\"\n- \"300-3000\"\n- \"3003000\"\nNon-match examples:\n- \"3000 3000\"\n- \"9000 9000 9000\"",
        "matches": [
            "300 3000",
            "300-3000",
            "3003000",
            "762 4820",
            "81571127088",
            "8208 3987",
            "837-1862",
            "492-1995",
            "490 3417",
            "8579871",
            "507 3509",
            "8548059787",
            "8429437"
        ],
        "non_matches": [
            "3000 3000",
            "9000 9000 9000",
            "werf",
            "234rtdsfqwe",
            "#3",
            "32456321",
            "876",
            "3521351`2",
            "32534687",
            "231",
            "$45",
            "54%"
        ],
        "id": 4041,
        "output": [
            {
                "text": " \"9(\\\\d\\\\d)(-\\\\d\\\\d)(\\\\d\\\\d"
            },
            {
                "text": ".{3,4}-{3,4} \n\nUse Case 2"
            },
            {
                "text": "\n[012]$|([01]?[3-9])\\ [01"
            },
            {
                "text": "\n(^\\d{1,3}-\\d{1,3}"
            },
            {
                "text": " - \"3000{0,2}-{0,2} {0,6"
            },
            {
                "text": "  \\d{9}  (the back-reference. means there's 2 digits"
            },
            {
                "text": " ^[0123456789]\\d\\d$ # 3 to 9 digits"
            },
            {
                "text": " The RegEx needed to match all of the following strings: [\"300\" + \"3000"
            },
            {
                "text": " \n\\\\b[456]?\\\\b\nThanks!\n\nA:\n"
            },
            {
                "text": " https://regexr.com/3q2xv6\n\nUse Case"
            }
        ]
    },
    {
        "expression": "([s]){10,}",
        "raw_prompt": "Matches the hissing noise of a snake. Link to my GitHub: https://github.com/StoddardSpencer96",
        "refined_prompt": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrsfefsv54543534544 FKR$>%>??W?EK#$Krkdk3oror\"\n- \"qwertyghbn\"",
        "matches": [
            "ssssssssss wwwwwwwwwwwsssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssss"
        ],
        "non_matches": [
            "effsgrgrsfefsv54543534544 FKR$>%>??W?EK#$Krkdk3oror",
            "qwertyghbn",
            "kjiuyt65re4rft",
            "ytfyuykghiu6757rty",
            "njihgyt67",
            "dftyguio",
            "s",
            "huytr54er5ty78u9",
            "hiugou",
            "wuhqipaxz",
            "ewuhpiru32p9swd",
            "rhfpier"
        ],
        "id": 4043,
        "output": [
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrg"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            }
        ]
    },
    {
        "expression": "([ing]){3}$",
        "raw_prompt": "Matching any word that ends with \"ing\"\nLink to my GitHub: https://github.com/StoddardSpencer96",
        "refined_prompt": "Matches the \"ing\" in any word that ends with \"ing\"\nMatch examples:\n- \"Reading Playing Comforting Crying\"\n- \"ing\"\nNon-match examples:\n- \"Readings Listenings Playful Comfort\"\n- \"hi\"",
        "matches": [
            "Reading Playing Comforting Crying",
            "ing"
        ],
        "non_matches": [
            "Readings Listenings Playful Comfort",
            "hi",
            "hello",
            "this",
            "Played",
            "Ran",
            "Run",
            "Moved",
            "Test",
            "Listen",
            "threw",
            "cooler"
        ],
        "id": 4044,
        "output": [
            {
                "text": ".*ing([a-zA-Z]*)\n\n3. Match words that start with \"un-\"\n\na.happy b.unhappy c.unbelievable\n\nAnswer: a.1 - The first character is a lowercase 'b'.\n\n"
            },
            {
                "text": " Generating the RegEx \"^[a-zA-Z][^a-zA-Z]*ing$\", which uses a negative character class to match any alphabetic character except for an alphabetic character.\n\nExercise 2: Identify the Pattern\n"
            },
            {
                "text": " r.*[ai][o]g\n\n\n\n\nWelcome to the world of mathematics and number sense! In our world, we use numbers as the building blocks of all calculations and operations we perform. Counting and cardinality is the concept of recognizing different quantities and using them in calculations"
            },
            {
                "text": "\n\"hi\" - (?=\\w+(?:\\s[a-zA-Z]\\s)?\\w+)\\w+(?=\\s[a-zA-Z]\\s)?\\w+$\n\n\n\nAre you tired of feeling"
            },
            {
                "text": " \nMatches the \"ing\" in any word that ends with \"ing\"\n\"ing\"\nNon-match examples:\n- \"Readings Listenings Playful Comfort\"\n- \"hi\"\n\nExercise 2:\nCreate a RegEx that matches any word that"
            },
            {
                "text": " r'ing[^ai]*(ing)s?[^ai]*[^ai]*[^ai]*'\n\n3. Write a regular expression for these phone numbers: (123) 456-7890, (123) 945-5680"
            },
            {
                "text": " A+\n\n4. Matching Nouns\nMatch each noun to the verb that is matching it.\nMatch example:\n- Cat = meow\n- Dog = bark\nNoun: _\nVerb: _\nMatch example:\n- Cat = meow\n"
            },
            {
                "text": "\n[Your answer here]\n\nExample 2: Non-Matches the \"ing\" in any word that does not end with \"ing\"\nMatch examples:\n- \"Smiling Laughing Writing Playing\"\n- \"ing\"\nNon-match examples:\n- \"Reading"
            },
            {
                "text": " \"hi\"\n\n\n\nDaily Life - Sports and Outdoors - Running\n\nRunning is a popular sport and outdoor activity that many people enjoy. It involves moving quickly on foot from one point to another. Running can be done for fun, as a part of a team, or as"
            },
            {
                "text": " \\bword$\", \"[^\\w\\s]+\", \"\" \n\nUse Case 2: Creating Headings\n\nAs a budding filmmaker, it's important to understand how to title and categorize your content. RegEx can be a valuable tool to help you do just that."
            }
        ]
    },
    {
        "expression": "((=)[A-F0-9]{2}){3}",
        "raw_prompt": "Using this Regex for finding spam in RAW email\nthis is Case sensitive\nHEX only CAPITAL A-F and numbers 0-9",
        "refined_prompt": "Matches 2 character HEX values between =\nMatch examples:\n- \"=EF=BB=BF\"\n- \"=E2=9C=80\"\n- \"=E2=9D=A4\"\nNon-match examples:\n- \"e2 9d a4\"\n- \"ABCXYZ\"",
        "matches": [
            "=EF=BB=BF",
            "=E2=9C=80",
            "=E2=9D=A4",
            "=38=B9=30",
            "=23=5E=00",
            "=47=7B=35",
            "=5B=12=88",
            "=32=C1=B5",
            "=59=B4=97",
            "=65=FF=02",
            "=C6=8D=79",
            "=D8=E4=96",
            "=B6=B4=DF"
        ],
        "non_matches": [
            "e2 9d a4",
            "ABCXYZ",
            "f0=9f=aa=81",
            "324r",
            "#DHWGDDWJNJ",
            "=",
            "equal",
            "21343re",
            "#HHDI3",
            "====",
            "DHDIE",
            "DDUEY72"
        ],
        "id": 4051,
        "output": [
            {
                "text": "\nimport re\n\npattern = re.compile(r'[^A-Fa-f0-9]')\nprint pattern.search('E8BC8D9A46C57D26"
            },
            {
                "text": " E2 (exactly 2 digits); 9C (exactly 2 hexadecimal characters); A4 (exactly 2 hexadecimal characters)\n\nExample #4: Find all words between two specific"
            },
            {
                "text": " (\\w+)\\s=\\s(\\w+)\\s=(\\w+)\\s\n\nThe second pattern should be: \"(\\d{4})\\s(\\d{2})\\s(\\"
            },
            {
                "text": "\n(?P<hex_1>[^0-9A-Fa-f]{2}-){1}[^0-9A-Fa-f]{2}-(?P<"
            },
            {
                "text": " ((\\\\w)*)(\\\\w+)=((\\\\w)\\\\b)\n\n3. Write a RegEx to retrieve emails from a paragraph:\nPar:\nHi, this is my email: john."
            },
            {
                "text": "\n\n``` python\nimport re\n\ndef hex_match(match):\n    color_pattern = re.compile(r'[^A-Fa-f0-9]')\n    "
            },
            {
                "text": " [\\w\\d]+[=][\\w\\d]+[=]\n\n#### Exercise 5\n\nCreate a generator function that takes in a list of file names and returns the size of each file in"
            },
            {
                "text": " ABCD=1[0-9]{1,8}\nExample 2: \nDescribe all combinations of two hex digit characters.  \nHow this works:  The set of valid chars is a"
            },
            {
                "text": " ([0-9A-Fa-f]\\\\{){3}[0-9A-Fa-f]{3}\nUsing this string, replace three or more hex values between = and = with"
            },
            {
                "text": "\n(?<=\\b\\d{3}\\b).{0,}(?=\\b\\d{3}\\b)\n\nFor explanation of the solutions provided by the answer and the link"
            }
        ]
    },
    {
        "expression": "\\b[0-9]{2}([0][1-9]{1}|[1][0-2]{1})([0][1-9]{1}|[1][0-9]{1}|[2][0-9]{1}|[3][0-1]{1})\\d{5}",
        "raw_prompt": "The PESEL number is an identification number given to every Polish citizen when they are born and registered in Poland.",
        "refined_prompt": "Matches the PESEL number which is an identification number given to every Polish citizen when they are born and registered in Poland.\nMatch examples:\n- \"11083197485\"\n- \"36110878229\"\n- \"00063172200\"\nNon-match examples:\n- \"1F083297485\"\n- \"36204578229\"",
        "matches": [
            "11083197485",
            "36110878229",
            "00063172200",
            "12110383138",
            "71111127030",
            "35103085264",
            "85061017201",
            "39012627489",
            "32021861783",
            "67080861679",
            "59031023643",
            "39063110747",
            "67101809495"
        ],
        "non_matches": [
            "1F083297485",
            "36204578229",
            "AA06317220B",
            "12203383138",
            "23131",
            "2343dsd",
            "GDU&*",
            "PESEL",
            "hefeiwefh342",
            "2121",
            "#3",
            "3e2hr3f"
        ],
        "id": 4067,
        "output": [
            {
                "text": " \"(\\d{4}-\\d{2}-\\d{3}) \\w*(\\d{5,})$\nExample: \"08131085"
            },
            {
                "text": " {num_of_digits}[0-9]{9,12},0{[3-9][0-9]]{2}\n\nExercise"
            },
            {
                "text": " \"^(?:(?:0[345678]|[345678])\\d{9,15})$\"\n\n3. Write a Regular Expression to match any"
            },
            {
                "text": " \n@(.?([1-9][0-9]3[0-9]{9}|0)[0-9]{10})\n\nThis"
            },
            {
                "text": "\n[1-9]\\d{2}\\d{2}[2-9]\\d\\d\\b\n\nExercise 2: Regular Expression to validate"
            },
            {
                "text": " \\d{5}\\D{1}(\\d{4})\\D*?(\\d{4})\\D* (\\d{4})\\D*\n\n"
            },
            {
                "text": " \nI:\n- \n- \n\nI:\n- (?=(^|[^0-9]))[0-9]{15}"
            },
            {
                "text": " {0,1}([0-9]{1})[0-9]{3}-[0-9]{1}[0-9]{9"
            },
            {
                "text": " (a+n)*(b+e)*(c+1)*[0-9][0-9]*.*[f,e]\n\nExercise 2"
            },
            {
                "text": " ^\\d\\d?[TZa-z]\\d?[-\\d]\\d{3}[TZa-z-]{3"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))[\\/\\.\\-]*((2[0-9])|(3[0-9]))$",
        "raw_prompt": "valid years 2020 to 2039",
        "refined_prompt": "Matches dates with years from 2020-2039\nMatch examples:\n- \"12/20\"\n- \"12/39\"\n- \"05-25\"\nNon-match examples:\n- \"12/40\"\n- \"23/02\"",
        "matches": [
            "12/20",
            "12/39",
            "05-25",
            "11//./--/-//.--./-/.-/.....-.-/..---/-../...-/--...23",
            "11././/31",
            "12////..//-.-.-..--/---..-/--/-/..-//.---29",
            "05-..-/../--//---/...//-..-36",
            "1021",
            "11-.///-./-../.--./-//-/.......///.././/-././-../.-/--/-/----.-.//--/--//-27",
            "10---/-/.-//37",
            "12.-./.--.--/...//-.-.-//.-.//../-/.-/-//33",
            "11///./-/-/-/-.-../-.-./-.../-.//--.-.--.//..-./../-/-/-/.-/-/-/29",
            "08/../../..---.../-.//../-///../------//-///..-./-.31"
        ],
        "non_matches": [
            "12/40",
            "23/02",
            "15-25",
            "1//",
            "12/12",
            "12/43",
            "1/2030",
            "12121212",
            "$45",
            "12-12",
            "july 4 2020",
            "#3"
        ],
        "id": 4072,
        "output": [
            {
                "text": " [a-z]\\d{3}[a-z]\\d{3}\\d{2}\n(Note: we\u2019re also using capitalization rules to differentiate between \"Jan\" and \"Feb.\")\n\nExercise 3: Use a positive lookahead to"
            },
            {
                "text": " Match cases where the day is greater than the month, like \"12/34\", \"10/5\" etc. \n\n2. Suppose we are designing a system that reads files on a server, and we want to extract only files that have an extension of \".pdf\". Write a Reg"
            },
            {
                "text": " Match a string that starts with a letter or decimal character followed by a decimal character or an alphanumeric character. Non-match examples start with an alphanumeric character followed by either a decimal character (+), decimal character (+) or an alphanumeric character.\n\n3. Write a program"
            },
            {
                "text": " \"^20\\d{2}[-/]\\d{2}[-/]\\d{4}$\n\n(5) Group exercises: \nIn small groups, write a regex algorithm to extract all the phone numbers from a given input, where the numbers are"
            },
            {
                "text": " \"^20[1-9]{2}$\"\n\n**Exercise 2:**\nCheck if the string \"Hello World\" is a valid number or not.\nAnswer: True. \"Hello World\" is a string that can be represented as a number, so it is"
            },
            {
                "text": " ^[0-9]{4}-[0-9]{2}-[0-9]{2} (\\/| *)\\d{2}$\n\n5. \"Is this a valid email address?\"\nAnswer: A valid email address starts with \"user"
            },
            {
                "text": " [^0-9]{1,4}[0-9]{2}, [0-9]{2}[0-9]{3}\n\n5. Match phone numbers with a valid format\nMatch examples:\n- \"(555) 123-4567\""
            },
            {
                "text": "  \"\\b\\d{1,3}/\\d{1,2}/\\d{4}-\\d{2}-\\d{2}\".\n\n## Exercise\n1. Define the function `match_date(date: str, regexp"
            },
            {
                "text": " \"^((?=.{1,3}\\d)\\d{1,3}|(?=(?: \\d{1,2}(?:st|nd|rd|th) ){0,2}) \\d{1,2}$\"\n\n5."
            },
            {
                "text": " /^\\d{1,2}\\d{2,3}\\s\\/\\s\\d{1,2}\\d{2,3}/\n\n#### Exercise 4: \nCreate a RegEx pattern that returns only dates in the format \"dd/mm/yyyy"
            }
        ]
    },
    {
        "expression": "^((?!.*(00000|11111|22222|33333|44444|55555|66666|77777|88888|99999))[0-9]{5,10})",
        "raw_prompt": "In example for some input number in case random digits not repeat number 5 number in 5-10 digits in pattern.",
        "refined_prompt": "Matches strings of numbers of the length of at least 5, but can not have more than 4 5's consecutively\nMatch examples:\n- \"0000110000\"\n- \"000010010\"\n- \"158114223\"\nNon-match examples:\n- \"00000\"\n- \"1122000009\"",
        "matches": [
            "0000110000",
            "000010010",
            "158114223",
            "113254",
            "081892",
            "027060",
            "1770189269",
            "408498",
            "42098",
            "01332",
            "85644",
            "019843",
            "33594"
        ],
        "non_matches": [
            "00000",
            "1122000009",
            "3242",
            "12",
            "#3",
            "$45",
            "23%",
            "12/12",
            "3323",
            "23",
            "124&&&&",
            "<32"
        ],
        "id": 4086,
        "output": [
            {
                "text": " ^(0|00|00|00|00|00)1(0|00|00|00|00|00)|0(000)1(11000)*$.\n\nA:\n\nThe first 5 digits"
            },
            {
                "text": " \"^(\\d{5}|\\d{3}[13]\\d{2}|\\d{3}[12]\\d{1})$\"\n\nI think it is fairly easy to build these"
            },
            {
                "text": "\n^[\\d0-9]{4}\\s{1}\\d{4}$ \n\nNow we will use this in the main() function:\ndef print_all_results():\n    for s in"
            },
            {
                "text": " ^\\d{0,4}\\d{0,4}\\d{0,4}\\d{0,4}$\n3. Create a regex that matches an email address of the form \"firstname@domain\" except"
            },
            {
                "text": " (0-9)??[0-9]??[0-9]??([0-9]??)\n\nA:\n\nWhy use lookaheads and lookbehinds when you can use pure matching?\n"
            },
            {
                "text": "  \n^([0-9]+)((?=(?:1?[01]\\d|2[01]|3[01]){3}))+$\n\nA:\n\nTry this one:\n^"
            },
            {
                "text": " [a-z0-9][a-z0-9]{4}\n\nA:\n\nTry like this:\n^(?:[a-zA-Z]{1}\\d{4})["
            },
            {
                "text": " [0-4], with no other characters before or after the characters\n\nA:\n\nThis should do the trick:\n\n^(?=(\\d.\\d{4})+)(\\d{1,5"
            },
            {
                "text": " \n(^|\\s)(?:\\d{2,}(?:\\d{4}))(?:\\d?)$\nWhere \\d is any digit. This is how I got to this form, I really"
            },
            {
                "text": "\n^[1-9][0-9]{0,3}$|^10[0-9]{4}$\nI'm still trying to figure it out. Any help would be appreciated. \n\n"
            }
        ]
    },
    {
        "expression": "(?!BG|GB|KN|NK|NT|TN|ZZ)[A-CEGHJ-PR-TW-Z][A-CEGHJ-NPR-TW-Z][0-9]{6}[A-D]",
        "raw_prompt": "UK NI number. ensured that the suffix is always a single character of A-D (as these are the only values currently supported by HMRC). Created 2021",
        "refined_prompt": "Matches UK National Insurance number. The suffix needs to be a single character of A-D (as these are the only values currently supported by HMRC).\nMatch examples:\n- \"XY123456D\"\n- \"AH587561C\"\n- \"CZ106648B\"\nNon-match examples:\n- \"XY123456E\"\n- \"23456\"",
        "matches": [
            "XY123456D",
            "AH587561C",
            "CZ106648B",
            "LJ185856D",
            "BA615520D",
            "OM968321A",
            "OG314869B",
            "BX184126A",
            "ML279103A",
            "SA876126C",
            "CT466022B",
            "KX637827A",
            "GL065214A"
        ],
        "non_matches": [
            "XY123456E",
            "23456",
            "sdfgh",
            "34rd3434f3",
            "#3",
            "number",
            "e34532",
            "dj343232f",
            "E323rj23!!!",
            "34njffW",
            "334jdfwe",
            "wjeirja"
        ],
        "id": 4107,
        "output": [
            {
                "text": " r\"^[0]?9[A-G]{2}[1-9]\\d{3}D$\". \n\nEx"
            },
            {
                "text": " [\\d](?=[A-D])(?!\\d).\n\nHost 2: For the next one, we want to look for a date in"
            },
            {
                "text": " RegEx: \"(ABC)\\\\1\" -- This is OK, as it matches the specified suffix.\n- \"XY123456C - but not XY123"
            },
            {
                "text": " \"^[ABD]\\\\d{4}$\"\n \nExercise 2:\nCreate a regex to match alphanumeric strings that start with"
            },
            {
                "text": " generate a RegEx for this description.\n- \"12.45.23.5\" match. \n- \"12.45.23.5:"
            },
            {
                "text": " \n[0-9]{4}[-0-9]{2}[-0-9]{2}[-0-9"
            },
            {
                "text": " \"([A-Z]{3}[123456](?:-[A-Z]{3}[123456])?)\"\nExercise5"
            },
            {
                "text": " Regex = \"(^[^A-D]+$|^[A-D]$|^([A-D]{2}$)|^"
            },
            {
                "text": " This describes a number which needs to have exactly 6 characters after the last and include a number 0 or a number.\n\n2. You need to match the value"
            },
            {
                "text": " ^[A-Z][0-9]{5,}$\n\nExercise 2: \nGiven the string \"2.345.6789"
            }
        ]
    }
]