[
    {
        "expression": "^\\d$",
        "raw_prompt": "Matches exactly 1 numeric digit (0-9).",
        "refined_prompt": "Matches exactly 1 numeric digit (0-9).\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"a\"\n- \"324\"",
        "matches": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "0"
        ],
        "non_matches": [
            "a",
            "324",
            "num",
            "location = 3",
            "ssda",
            "11",
            "hello world",
            "something something",
            "asd",
            "123fsf",
            "the car",
            "lorem ipsum"
        ],
        "stress_tests": [
            "eeeeeeeeeeeeyyyyyyyyhhyhuy"
        ],
        "id": 1,
        "output": [
            {
                "text": " /^\\d+(\\.\\d+)?$/\n\n2. Write a RegEx to match an email address. An email address contains one or more characters before the '@' symbol.\nHints:\n- The '@' symbol is a special character in a regular expression.\n- The first character before the '"
            },
            {
                "text": " ^\\d{4}$\n\nExercise 2: \nReplace all non-numeric characters with the underscore symbol.\nDescription: Given a string, replace all non-numeric characters (e.g., letters, spaces, punctuation) with the underscore symbol. \nAnswer: ```re.sub("
            },
            {
                "text": " \nr\"^\\d+$\"\n\n3. Create a RegEx that matches all the words that start with \"a\" and end with \"e\", except for the word \"the\".\nAnswer: \nr\"(?i)(?!the)(\\ba\\w*e\\b)\\b\"\n\n4"
            },
            {
                "text": " \\d\\d\\d\\d(?=\\s\\d)\n\n2. Create a RegEx to find all dates in the format \"dd-mm-yyyy\".\nMatch examples:\n- \"01-01-2021\"\n- \"07-15-1990\" \n\nNon-match examples"
            },
            {
                "text": " r\"\\d\"\n\nExercise 2:\nHow can you use the `re.sub()` function to replace all occurrences of \"Python\" with \"JavaScript\" in a given text string?\n\nSolution:\n```python\nimport re\n\ntext = \"Python is a popular programming language, Python is a"
            },
            {
                "text": " \\d{1,3}(?!^[a-zA-Z]*$)\n\nExercise 5:\nWhat does the \"^\" and \"$\" characters in the RegEx used before the number \"1\" mean?\nAnswer: The \"^\" character means \"match the beginning of the string\". The"
            },
            {
                "text": " \nimport re\n\ndef find_digit(val):\n    return bool(re.search(\"[0-9]\", str(val)))\n\ndef find_digit_in_a_num(val_a):\n    return bool(re.search(\"[0-9]\", str(val_a"
            },
            {
                "text": "\n\\b\\d+\\b\n\nExercise 2:\nWrite a Python function that takes a list of URLs and returns a filtered list that only includes URLs that start with \"http\" or \"https\" and have a valid URL schema (i.e. contain a'scheme' attribute).\nExample:\ndef filter"
            },
            {
                "text": "\n^[0-9]*$\n\n2. Write a RegEx to match email addresses.\nAnswer:\n^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
            },
            {
                "text": " \\d\n\n5. Write a RegEx that extracts the domain name from a given email address.\n\nAnswer: (.*)@[a-zA-Z0-9]+\\.(com|org|edu)\n\nLecture Script:\n\nTitle: Writing and Compiling Regular Expressions\n\n"
            }
        ]
    },
    {
        "expression": "^\\d{5}$",
        "raw_prompt": "Matches 5 numeric digits, such as a zip code.",
        "refined_prompt": "Matches 5 numeric digits, such as a zip code.\nMatch examples:\n- \"33333\"\n- \"55555\"\n- \"23445\"\nNon-match examples:\n- \"abcd\"\n- \"1324\"",
        "matches": [
            "33333",
            "55555",
            "23445",
            "89343",
            "46556",
            "25432",
            "25336",
            "43576",
            "68797",
            "30495",
            "54348",
            "45935",
            "93857"
        ],
        "non_matches": [
            "abcd",
            "1324",
            "as;lkjdf",
            "jaldks",
            "234",
            "8hr4f",
            "fsdg",
            "2546dgwre",
            "8j989",
            "xhsn",
            "potrewjdsg",
            "h345gf43"
        ],
        "id": 2,
        "output": [
            {
                "text": " \"^[a-z0-9]{3}[0-9][0-9]$\".\n\nExercise 3: \nWrite a Python program that takes a string and returns True if it contains at least two consecutive vowels.\nAnswer: \nimport re\npattern ="
            },
            {
                "text": "\n[0-9]{3}([Mm]\\d{1,2}|[a-z]{1,3}){0,2}[0-9]{3}\n#Generates a RegEx which matches zip codes up to 3 digits with optional meters and"
            },
            {
                "text": " (.*)$ should match this.\n\nExercise 2: \nMatch this pattern to a string:\nMatch pattern: *a*\nString: aaabaaa\nAnswer: *a* should match a and then any number of a's.\n\n3. Advanced REGEX Patterns\n"
            },
            {
                "text": " \n^[^\\D\\d]*\\d[^\\D\\d]*$\n\nExercise 3:\nGiven the list of strings below, write a Python function that removes all the non-alphanumeric characters from each string.\n```python\nstrings = [\"I"
            },
            {
                "text": " The RegEx should match any non-matching character, such as a comma or a space. A common RegEx that can be used is \".*\", which matches any amount of characters that are not between the first and second characters. Another option is \"[^a-zA-Z0-9]"
            },
            {
                "text": " ^[0-9]{3}(?:[0-9]{3})?$\n\nExercise 3: Write a Python program to validate an email address using a RegEx pattern.\n\nHint: An email address consists of a username, \"@\", and a domain name, separated"
            },
            {
                "text": " \n^[a-zA-Z]{3}[a-zA-Z0-9]{3}-?[a-zA-Z0-9]{3}$\n\nExercise 4:\nCreate a Python function that takes a string as input and"
            },
            {
                "text": " \"^[0-9]{4}$\"\n- \"1234567890\"\n- \"555555555\"\n- \"4444444444\"\n\nExercise 3: Create a Regex\nGenerate a Regex that matches the following words:\n- \"cat"
            },
            {
                "text": " /^[A-Za-z][- ]*[0-9]{3}$/\n\n2. Create a RegEx that matches strings that consist only of letters and numbers with exactly one hyphen between each letter and number.\nAnswer: ^[a-zA-Z"
            },
            {
                "text": "\nimport re\n\ntext = \"The quick brown fox jumps over the lazy dog\"\npattern = re.compile(\"quick|brown|lazy\")\nmatches = pattern.findall(text)\nprint(matches) \n\nExercise 5:\nCreate a Python script that"
            }
        ]
    },
    {
        "expression": "^\\d{5}-\\d{4}$",
        "raw_prompt": "Numeric and hyphen 5+4 ZIP code match for ZIP+4.",
        "refined_prompt": "Matches a string that starts with five digits, followed by a hyphen, and ends with four digits.\nMatch examples:\n- \"22222-3333\"\n- \"34545-2367\"\n- \"56334-2343\"\nNon-match examples:\n- \"123456789\"\n- \"A3B 4C5\"",
        "matches": [
            "22222-3333",
            "34545-2367",
            "56334-2343",
            "34539-5433",
            "12349-5943",
            "54329-9875",
            "34852-5493",
            "83542-2314",
            "52435-3489",
            "12345-0983",
            "98745-2385",
            "48294-2945"
        ],
        "non_matches": [
            "123456789",
            "A3B 4C5",
            "55335",
            "dinfa",
            "sfalijad234",
            "asdf3453",
            "dsjlka3",
            "234fsd",
            "gaqwer3",
            "adfa2",
            "23457-4332w2"
        ],
        "id": 3,
        "output": [
            {
                "text": "\n^\\d{5}-\\d{4}$\n\n\n\n[Podcast Intro Music]\n\nHost: Welcome back to another episode of \"The Math Made Easy"
            },
            {
                "text": " (\\d{5})-(\\d{4})\n\n3. Write a Python script that reads a file, matches each line that starts with \"Name1:\", \"Name2"
            },
            {
                "text": " \n^\\d{5}-\\d{4}$\n\nExercise 2:\nCreate a Python program that takes a list of filenames and returns the ones that"
            },
            {
                "text": " \\d{5}-\\d{4}\n\nExercise 2:\nWrite a regex pattern to match words that contain the letter \"e\". \nMatch examples:\n-"
            },
            {
                "text": " (\\d{5})-(\\d{4})\n\nExercise 5:\nCreate a RegEx that will match any string that has a date in the format of \"YYYY"
            },
            {
                "text": " \"^[0-9]{5}-[0-9]{4}$\"\n\nExercise 3:\nCreate a regex to match any string that starts with \"http"
            },
            {
                "text": " ^[0-9]{5}-[0-9]{4}$\n\nExercise 3:\nGiven two strings, extract all the words that start with the letter \""
            },
            {
                "text": " \"^\\d{5}-\\d{4}$\"\n\nExercise 4: Write a Python program that uses the \"re\" module to check if a string starts with"
            },
            {
                "text": " \n\\d{5}-\\d{4}\\d{4}\n\nExercise 3: True or False\nA regular expression can only match one character.\nAnswer:"
            },
            {
                "text": " A3B\\s\\d{4} \n\nExercise 2:\nWrite a Python function that takes a string as a parameter and returns the number of times the word \"the"
            }
        ]
    },
    {
        "expression": "^\\d{5}$|^\\d{5}-\\d{4}$",
        "raw_prompt": "This regular expression will match either a 5 digit ZIP code or a ZIP+4 code formatted as 5 digits, a hyphen, and another 4 digits. Other than that, this is just a really really long description of a regular expression that I'm using to test how my front page will look in the case where very long expression descriptions are used.",
        "refined_prompt": "Match either a 5 digit ZIP code or a ZIP+4 code formatted as a string that starts with five digits, followed by a hyphen, and ends with four digits..\nMatch examples:\n- \"55555-5555\"\n- \"34564-3342\"\n- \"90210\"\nNon-match examples:\n- \"434454444\"\n- \"645-32-2345\"",
        "matches": [
            "55555-5555",
            "34564-3342",
            "90210",
            "03945",
            "02946",
            "46556",
            "52346",
            "34534-3252",
            "49672-3923",
            "59403-6934",
            "35349-6753",
            "52346-3953"
        ],
        "non_matches": [
            "434454444",
            "645-32-2345",
            "abc",
            "394-3498",
            "234565423",
            "j3942fw",
            "43-5432",
            "5324523-345",
            "h909f34f",
            "0953jg",
            "wtre-0n",
            "3409fjg43"
        ],
        "id": 4,
        "output": [
            {
                "text": " ^\\d{5}-\\d{3}-\\d{4}$\n\nExercise: Write a regex"
            },
            {
                "text": " ^[0-9]{5}-[0-3][0-9]{4}$\n\nExercise 2"
            },
            {
                "text": "^5[0-9]{4}-([0-9]{4})$\n\nExercise 3:\n"
            },
            {
                "text": " ^(?=.{5}\\-?\\d{4}$)\n2. Write a RegEx to match a"
            },
            {
                "text": "\\d{5}-\\d{2} \\d{4}\n\nLecture Note: Validating Email"
            },
            {
                "text": " ([0-9]{5})-([0-9]{4})\n\n\n\nTitle: The Fascinating World"
            },
            {
                "text": "\n\n^[5-9][0-9]{3}[0-9]$\n\n3. Use a"
            },
            {
                "text": " [^\\d]\\d+[^\\d-]\\d{4}\\b\n\nExercise 4: Write"
            },
            {
                "text": " [0-9]{5}\\-[0-9]{4}\n\nExercise 2: Given a list of strings"
            },
            {
                "text": " ^\\d{5}-(\\d{4})-(\\d{4})$ \n\nExercise 3: Create"
            }
        ]
    },
    {
        "expression": "^\\d{3}-\\d{2}-\\d{4}$",
        "raw_prompt": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.",
        "refined_prompt": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN.\nMatch examples:\n- \"333-22-4444\"\n- \"123-45-6789\"\n- \"534-74-2573\"\nNon-match examples:\n- \"123456789\"\n- \"SSN\"",
        "matches": [
            "333-22-4444",
            "123-45-6789",
            "534-74-2573",
            "234-45-6235",
            "968-24-4395",
            "948-53-5924",
            "493-42-5938",
            "954-97-5942",
            "534-96-3623",
            "549-69-3456",
            "543-54-6396",
            "294-68-1957"
        ],
        "non_matches": [
            "123456789",
            "SSN",
            "-243",
            "4523-24352-453",
            "2346-2345-2435",
            "dgsfjkl",
            "2204fj",
            "234jgs-345",
            "4235-fgdsg",
            "afd-asdf",
            "dfg",
            "32542"
        ],
        "id": 5,
        "output": [
            {
                "text": " [a-z]{3}\\-[a-z]{2}\\-[a-z]{4}\\.\n\nExercise"
            },
            {
                "text": " r\"\\d{3}-\\d{2}-\\d{4}\"\n\n# Exercise 2:\nMatch the following phone numbers"
            },
            {
                "text": " \n^\\\\d{3}-\\\\d{2}-\\\\d{4}$\nExplanation: \nThe \"^"
            },
            {
                "text": " r\"[0-9]{3}-?[0-9]{2}-?[0-9]{4}\"\n-"
            },
            {
                "text": "\n[A-Z]{3}[0-9]{3}-\\d{4}\n\nExercise 3: Use regular"
            },
            {
                "text": " \\d[\\d-]{3}-\\d{2}-\\d{4}\n\nExercise 4:\nCreate a"
            },
            {
                "text": " One possible approach to solving this exercise would be to use a regular expression that matches the general components of an SSN in the format NNN-NN-"
            },
            {
                "text": " (\\d{3}-){3}\\d{3}-\\d{4}\n\nExercise 3: Rewrite the following code"
            },
            {
                "text": " \n\n```python\nimport re\nfrom typing import List\n\ndef generate_ssn_regex(ssn: str) ->"
            },
            {
                "text": " ^[A-Z]{3}\\d{2}(?:-?\\d{3})?$\n\nExercise 3: "
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]$",
        "raw_prompt": "Matches any single upper- or lower-case letter.",
        "refined_prompt": "Matches any single upper- or lower-case letter.\nMatch examples:\n- \"a\"\n- \"B\"\n- \"c\"\nNon-match examples:\n- \"0\"\n- \"&amp;\"",
        "matches": [
            "a",
            "B",
            "c",
            "f",
            "J",
            "D",
            "s",
            "D",
            "d",
            "o",
            "F",
            "p",
            "r"
        ],
        "non_matches": [
            "0",
            "&amp;",
            "AbC",
            "rewv342",
            "vr",
            "@",
            "sdfSDF",
            "asf",
            "324df",
            "34fs2",
            "34d2vdw",
            "99999@gmail"
        ],
        "id": 6,
        "output": [
            {
                "text": " [a-zA-Z0-9]*[&]?[-a-zA-Z0-9]*/\n\n4. Write a regular expression to match any word that ends in -ed.\nMatch examples:\n- \"ran\"\n- \"jumped\"\n- \"jumped"
            },
            {
                "text": " \\p{L}\n- \"0.1\"\n- \"&amp;0.1\"Generate a RegEx for this description. \nAnswer: \\p{N}+\n- \"0&amp;0.1\"Generate a RegEx for this description. \nAnswer: \\p"
            },
            {
                "text": " [a-zA-Z]\n\n4. Match any single digit from 0-9.\nAnswer: [0-9]\n\n5. Match any single special character from the following set:!@#$%^&*()+,-./:;<=>?=[]{}|~."
            },
            {
                "text": " \"a[0-9A-Fa-f]{1}[0-9a-fA-Fa-f]{3}[0-9a-fA-Fa-f]{5}[0-9a-fA-Fa-f]{7}[0-9"
            },
            {
                "text": " [0-9a-zA-Z_]*\n\nExercise 3:\n- Write a regular expression that matches any URL that includes the characters \"www.\".\n\n```python\nimport re\n\nurl = \"http://www.google.com/search?q=python+regex\""
            },
            {
                "text": " [A-Za-z0-9\\,\\.\\?!\\^:;\\-\\/\\(\\)\\_\\[\\]\\{\\}]\n\n\n\nCelebrity Biography: The Mathematical Journey of Dr. Emily Carter\n\nIntroduction:\nDr. Emily Carter, widely known as the \""
            },
            {
                "text": "  [a-zA-Z0-9_]+\n\n2) Match any whitespace character except newline.\nMatch examples:\n- \" \"\n- \"\\t\"\nNon-match examples:\n- \"a\"\n- \" & \"\n\n3) Match any digit between 0 and 9."
            },
            {
                "text": " \"([A-Z]|[a-z])([A-Z][a-z])+\"\n\nExercise 2:\nWrite a RegEx pattern to match all telephone numbers of the format (XXX) XXX-XXXX.\nAnswer: \"\\(\\d{3}\\) \\d{3}-"
            },
            {
                "text": " [A-Za-z0-9&amp;]\n\n2. Write a RegEx pattern to match a phone number in the format XXX-XXX-XXXX.\nAnswer: ^\\d{3}-\\d{3}-\\d{4}$\n\n3. Match any word that"
            },
            {
                "text": " [a-zA-Z]\n\n3. Given the following string:\nstring = \"I want a cat and a dog.\"\nGenerate a RegEx that will match any word that contains the letters \"aeiou\" or \"AEIOU\". \nAnswer: [a-zA-Z]"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]+$",
        "raw_prompt": "Matches any string of only upper- and lower- case letters (no spaces).",
        "refined_prompt": "Matches any string of only upper- and lower- case letters (no spaces).\nMatch examples:\n- \"abc\"\n- \"ABC\"\n- \"aBcDeF\"\nNon-match examples:\n- \"abc123\"\n- \"mr.\"",
        "matches": [
            "abc",
            "ABC",
            "aBcDeF",
            "dfasdfs",
            "ALKFJsf",
            "FDSfdsf",
            "AJFDAL",
            "sfdjk",
            "FISD",
            "sadfkjl",
            "fadghui",
            "FDSnfsdFDS",
            "sdfjoi"
        ],
        "non_matches": [
            "abc123",
            "mr.",
            "a word",
            "a a a",
            "209fsd",
            "3nf@",
            "fgsda23",
            "nu9",
            "u09nKLJG FSL",
            "gdfios jsfoi",
            "JFLSKJ FSDOIJ",
            "GOOD friend"
        ],
        "id": 7,
        "output": [
            {
                "text": "\n\n^[a-zA-Z]+$\n\nExercise 3: RegEx Regex\nMatch any string of only numbers and dashes (-).\nMatch examples:\n- \"123-45\"\n- \"--123\"\n- \"1-2-"
            },
            {
                "text": " [a-z]+[A-Z]\n\nExercise 3:\nCreate a regular expression that matches a string that is exactly six characters long, and that does not contain any spaces.\n\nAnswer: [a-zA-Z]{6}\n\nEx"
            },
            {
                "text": " a.M.r.c.e.n.g.e.n.t.\n\"\"\"\n\nname = input(\"Enter your name: \")\n\nif name.isupper() and name.islower():\n    print(\"Thanks for using our program!\""
            },
            {
                "text": " \"^[a-z0-9][a-z0-9\\-\\.]*[a-z]$\"\n\nExercise 3:\nGive an example of a real-world scenario where regular expressions can be used.\nAnswer:\nRegular expressions can be"
            },
            {
                "text": "\n\\b[A-Za-z][a-zA-Z0-9]*\\b\n\"\"\"\n\n\ndef regex1(pattern: str) -> bool:\n    return bool(re.match(pattern, \"\"))\n# -*-"
            },
            {
                "text": " [A-Za-z][A-Za-z0-9\\s]*\n\nExercise 2:\nWrite a Python program that prompts the user to enter a string and then prints the first 10 words in the string.\nAnswer:\nimport re\n"
            },
            {
                "text": "\n[a-z][A-Z][a-z0-9]*\n# Python code to test the regex\nimport re\ntext = \"mr.Generate a RegEx for this description.\"\nprint(re.findall(r'[a-z"
            },
            {
                "text": "\n- [a-z][a-z0-9]*\n\nUse case: A group of friends is planning a camping trip. They need to figure out what items to pack and what to leave behind. They create a group chat where they share their ideas and suggestions."
            },
            {
                "text": " r\"([a-zA-Z]|[0-9]|[a-zA-Z][a-zA-Z])+\"\n\nExercise 4: Regular Expression for \"Words Only\"\nCreate a regular expression that will only match strings with"
            },
            {
                "text": " [a-zA-Z]+(?:\\s+[a-zA-Z]+)+\n\nExercise 2:\n\"Name a regex for email addresses.\"\nAnswer: [a-zA-Z0-9._%+-]+@["
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+$",
        "raw_prompt": "Matches any alphanumeric string (no spaces).",
        "refined_prompt": "Matches any alphanumeric string (a string that contains only English letters and/or digits without spaces).\nMatch examples:\n- \"10a\"\n- \"ABC\"\n- \"A3fg\"\nNon-match examples:\n- \"45.3\"\n- \"this or that\"",
        "matches": [
            "10a",
            "ABC",
            "A3fg",
            "AFDSA",
            "asfsafd",
            "123",
            "123123abcAfds",
            "2398djAD",
            "dsfhoi329",
            "98hsd",
            "NOTREDAME",
            "ILOVEND",
            "notredame46556"
        ],
        "non_matches": [
            "45.3",
            "this or that",
            "$23",
            "...111",
            "2346-2345-2435",
            "3nf@",
            "43-5432",
            "2546dgwre fsdfsd",
            "u09nKLJG FSL",
            "90ndfdfs ,./././ dcf",
            "sdf324 abc...",
            "99999@gmail"
        ],
        "id": 8,
        "output": [
            {
                "text": " [a-zA-Z0-9]*\\s[a-zA-Z0-9]*(?:\\.\\s[a-zA-Z0-9]*)*\n\n2. Write a"
            },
            {
                "text": " \"0-9a-zA-Z_.\"\n\n```python\nimport re\n\nstring_to_match = \"10a\"\n\nif re.match(\"[0-9a-zA-Z_]"
            },
            {
                "text": " (.*)\n\nHint: Use the dot (.) symbol to represent any character, and the dollar sign ($) symbol to represent the end of the string.\n\nExample 3: Extracting Email Addresses\nGiven a string that contains email"
            },
            {
                "text": " This regex pattern should match any alphanumeric string:\n\\w+\\s\\w+\\s\\w+\\s\\w+\\w+\n\nExercise 3:\nCreate a Python function that takes a string as input and"
            },
            {
                "text": " [A-z0-9]+\n\nExercise 4:\nWrite a Python regex to match email addresses using the same rules as Example 1.\n\nExercise 4 Solution:\nimport re\nemail_pattern = r\"[a-z"
            },
            {
                "text": " [a-zA-z0-9_.+-]+@[a-zA-z0-9-]+\\.[a-zA-z0-9-.]+\n\nExercise 3: \nCreate a"
            },
            {
                "text": " \"abcd|[0-9]*\\.\"\n\nExercise 4: Using regular expression, find the first word that repeats in a text.\nAnswer: Find the first repeated word by extracting all words from the text using Regex and"
            },
            {
                "text": " \\b[A-Za-z0-9]\\s?\\d*\\b\n\n3. Match any word in a sentence, regardless of case. \nAnswer: [\\w\\s]+\n\n4. Gener"
            },
            {
                "text": "\n\n```\nimport re\n\ndescription = \"This is an example of 123\"\n\npattern = \"^[a-zA-Z0-9]*$\"\n\nmatch = re.match(pattern, description)"
            },
            {
                "text": " This will generate a RegEx for the word \"this\" or \"that\".\n\nA:\n\nIf you want to match a string that contains only digits, you can't use [0-9]+ because that will include spaces and other characters"
            }
        ]
    },
    {
        "expression": "^\\d+$",
        "raw_prompt": "Positive integer value.",
        "refined_prompt": "Positive integer value.\nMatch examples:\n- \"123\"\n- \"10\"\n- \"54\"\nNon-match examples:\n- \"-54\"\n- \"54.234\"",
        "matches": [
            "123",
            "10",
            "54",
            "39",
            "583",
            "395",
            "2394",
            "2394854",
            "384",
            "324",
            "222",
            "1",
            "2",
            "39",
            "583",
            "395",
            "2394",
            "2394854",
            "384",
            "324",
            "222",
            "1",
            "2"
        ],
        "non_matches": [
            "-54",
            "54.234",
            "abc",
            "-123",
            "9ijn",
            "qwer",
            "-312",
            "1.1",
            "1.1.1",
            "1-1-2",
            "34.31",
            "8h98009hu",
            "-123",
            "9ijn",
            "qwer",
            "-312",
            "1.1",
            "1.1.1",
            "1-1-2",
            "34.31",
            "8h98009hu"
        ],
        "id": 9,
        "output": [
            {
                "text": " [0-9][0-9][0-9][0-9]|[0-9][0-9][0-9]|[0-9][0-9]\n\nExercise 4: Identifying Match or Non-Match\n\nStatement: \"25/3/2018\" Generate a RegEx for \"25"
            },
            {
                "text": " (\\d\\?){2,}\n\n3) Write a RegEx for a phone number in the format '(xxx) xxx-xxxx'.\nAnswer: (\\(\\d{3}\\)\\d{3}-\\d{4})\n\n4) Write a RegEx for an email address in the format 'username@domain."
            },
            {
                "text": " \\b[1-9][0-9][0-9]\\b\n\n2. Use the positive integer in exercise 1 to write a regular expression that will match a string of text that contains a phone number in the format XXX-XXX-XXXX. Make sure the phone number is valid (e.g. the last four digits cannot be z"
            },
            {
                "text": " [0-9]+\n\n2. The following Regex pattern will match any two-word phrase where the first word is a title case and the second word is not a title case. \nExercise: \nWrite a Regex pattern to match \"Title Case Words\" and \"Word Not Title Case\" from the provided list.\nAnswer:"
            },
            {
                "text": " [\\d]+(\\.\\d+)?\nExercise 2: Create a function that takes a string of any length, and returns the same string with all non-digit characters removed.\nAnswer: \ndef remove_non_digits(string):\n    return re.sub(r'\\D', '', string)\nstring ="
            },
            {
                "text": " ^[0-9]+(.[0-9]{1,3})?$\n\n```python\nimport re\n\ndef generate_reg_ex(pattern):\n    result = \"^\"\n    for i, char in enumerate(pattern):\n        if char!= \"*\":\n            result += \"\\\\\" +"
            },
            {
                "text": " /^(?:\\d+|\\d+\\.\\d+|\\d+)$/\n\n2. Write a RegEx function that takes a string input and returns the number of digits and characters in the string.\nAnswer:\n```python\nimport re\n\ndef count(string):\n    digits = len(re."
            },
            {
                "text": " \"(?i)((?<!^)-?[0-9]+(?!$))\"\n\nExercise 3:\nWrite a function that takes in a string and removes any non-alphanumeric characters from the beginning and end of the string. Use positive and negative lookaheads and lookbehinds to accomplish this task.\nAnswer:"
            },
            {
                "text": " \"r'^[0-9]+(?:\\.[0-9]+)?$'\n\n3. Create a Python function that takes a list of numbers, converts them to floats, and then generates a list of RegEx patterns corresponding to each number.\n\nHints:\n- You may want to use List comprehension to iterate through the"
            },
            {
                "text": " '^[0-9]+$'\n\nExercise 2:\nIn the following example, generate a RegEx to match the pattern of a phone number in the format (xxx) xxx-xxxx.\n\n\"My phone is (123) 456-7890\"\n\nAnswer: '^\\(\\d{3}\\)\\s"
            }
        ]
    },
    {
        "expression": "^(\\+|-)?\\d+$",
        "raw_prompt": "Matches any signed integer.",
        "refined_prompt": "Matches any signed integer, in other words, a string that can start with an optional plus (+) or minus (-) sign, followed by one or more digits.\nMatch examples:\n- \"-34\"\n- \"34\"\n- \"+5\"\nNon-match examples:\n- \"abc\"\n- \"3.1415\"",
        "matches": [
            "-34",
            "34",
            "+5",
            "809",
            "790987",
            "+5483920",
            "-2354",
            "+540893",
            "-234",
            "2349",
            "5094",
            "234234",
            "+123"
        ],
        "non_matches": [
            "abc",
            "3.1415",
            "-5.3",
            "0bu9",
            "234dc",
            "312ccc",
            "123u98b",
            "1.2",
            "-2.3",
            "4.5",
            "+4.5",
            "-99.99"
        ],
        "id": 10,
        "output": [
            {
                "text": "\n- ^(?:[-+]?[0-9]+)?[0-9]+(?:\\.[0-9]+)[0-9]+$\n\n2. Given a String from"
            },
            {
                "text": " [0-9]\\.[0-9] \n3. Write a RegEx to match a string that has at least two uppercase letters.\nAnswer: [A-Z]{2"
            },
            {
                "text": "\n^([+-]?\\d+)$\n\nExercise 2:\nMatch any string that starts with a digit (0-9) and ends with a letter (A-Z), or is"
            },
            {
                "text": " [0-9][0-9.]*\n\n- [0-9]\\d*\\.[0-9]+\\.?$Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": " ^[+-]?\\d+$\n\n4. Match any number: Numbers can be positive or negative.\n\n```python\n# Solution 4:\n\nimport re\n\nnumber ="
            },
            {
                "text": " \\+\\d+\\.\\d+\n\"\"\"\nimport re\n\na = \"-\"\nb = \"34\"\nc = \"+5\"\nd = \"abc\"\ne = \"3"
            },
            {
                "text": " \"^([^.+-]|[+-])[^.+-] *\\d*\\.*\\d*$\"\nExplanation: The first character of the character class is"
            },
            {
                "text": " ^[+\\-]?\\d+(\\.\\d+)?$\n\n3. Write a Matcher that can find words that start with a vowel and ends with a consonant\nAnswer: ^["
            },
            {
                "text": " -?[0-9]+[\\.][0-9]+\n\n#### Exercise 3 <a name=\"exercise3\"></a>\nGenerate a RegEx for string validation that matches email addresses."
            },
            {
                "text": " [\\+\\-,\\d]+\n\n[a-z]+ Match any lowercase letter, followed by one or more of any lowercase letter, followed by one or more of any uppercase letter"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]\\w{3,14}$",
        "raw_prompt": "The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used",
        "refined_prompt": "The password's first character must be a letter, it must contain at least 4 characters and no more than 15 characters and no characters other than letters, numbers and the underscore may be used.\nMatch examples:\n- \"abcd\"\n- \"aBc45DSD_sdf\"\n- \"password\"\nNon-match examples:\n- \"afv\"\n- \"1234\"",
        "matches": [
            "abcd",
            "aBc45DSD_sdf",
            "password",
            "F3fsdsdf_234",
            "F0392",
            "fd02934",
            "k2039",
            "ABC09314",
            "abc_ABC",
            "NOTREDAME",
            "fadghui",
            "QWERTY",
            "p0p0p0"
        ],
        "non_matches": [
            "afv",
            "1234",
            "reallylongpassword",
            "1",
            "234",
            "ab",
            "123312312",
            "98iojk",
            "9ijk",
            "98hsdf",
            "longlonglonglonglong",
            "hello12345hello12345"
        ],
        "id": 11,
        "output": [
            {
                "text": " \\w{4,15}\n\nExercise 3:\nWrite a Python program that asks for the user's age. If the user is under"
            },
            {
                "text": " \n- (^[a-zA-Z][a-zA-Z0-9_]{3,14}$)"
            },
            {
                "text": " (a|b|c|d|e|f|g|h|i|j|k|l|m|n|p|"
            },
            {
                "text": " ^[a-zA-Z]{4,15}$\n\n3. Write a regular expression that matches all email addresses (case-"
            },
            {
                "text": " (a-zA-Z)(0-9)(\\w|_)\n\n# 15.5.7 How to Use the re"
            },
            {
                "text": " To generate a RegEx for this description, you will need to:\n- Place the word \"password\" inside the square brackets.\n- Add the"
            },
            {
                "text": " /^[a-zA-Z]{4,15}$/  \n\nExercise 2:\nYou are developing an e-"
            },
            {
                "text": " [a-z][a-z0-9][a-z0-9_]{0,7}|[a-z0"
            },
            {
                "text": " [a-zA-Z]{4,15}_[a-zA-Z0-9_]*\nSolution: \""
            },
            {
                "text": " \n^([A-Za-z]){4,15}$\n\n```python\nimport re\n    \npassword = input"
            }
        ]
    },
    {
        "expression": "^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$",
        "raw_prompt": "Simple email expression. Doesn't allow numbers in the domain name and doesn't allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more). Doesn't handle multiple &quot;.&quot; in the domain (joe@abc.co.uk).",
        "refined_prompt": "Checks if an email address starts with one or more alphanumeric characters, followed by the \"@\" symbol, a domain name with letters or underscores, a dot, and finally a domain extension with two or three letters.\nMatch examples:\n- \"joe@aol.com\"\n- \"ssmith@aspalliance.com\"\n- \"a@b.cc\"\nNon-match examples:\n- \"joe@123aspx.com\"\n- \"joe@web.info\"",
        "matches": [
            "joe@aol.com",
            "ssmith@aspalliance.com",
            "a@b.cc",
            "apple@qq.com",
            "123@qq.com",
            "abc@abc.com",
            "ab@ab.ab",
            "bc@bc.bc",
            "avpl@qq.cn",
            "sustech@nd.com",
            "msft@nd.us",
            "notredame@nd.edu"
        ],
        "non_matches": [
            "joe@123aspx.com",
            "joe@web.info",
            "joe@company.co.uk",
            "234dsf@032ijsd.fasdf.sdf",
            "fads@sdaf@asdf",
            "89ioj@9ijosf",
            "abc@abc",
            "a@a.a.a",
            "qwerty@123.123",
            "123@sustech.edu.cn",
            "apple@banana",
            "test@test.test"
        ],
        "id": 12,
        "output": [
            {
                "text": "\nimport re\npattern = \""
            },
            {
                "text": "\n\nimport re\n\ndef"
            },
            {
                "text": " \\b\\w+@(\\"
            },
            {
                "text": " r'^[a-z"
            },
            {
                "text": " \n^\\w+@"
            },
            {
                "text": " /^[a-zA"
            },
            {
                "text": " j[a-zA-"
            },
            {
                "text": " \n\nimport re\n\n"
            },
            {
                "text": " ^[a-zA-"
            },
            {
                "text": " ^[a-zA-"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long.\nMatch examples:\n- \"4/1/2001\"\n- \"12/12/2001\"\n- \"55/5/3434\"\nNon-match examples:\n- \"1/1/01\"\n- \"12 Jan 01\"",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434",
            "1/1/1111",
            "2/2/2222",
            "23/3/3333",
            "11/11/1111",
            "1/1/1111",
            "30/30/3030",
            "55/5/5555",
            "5/55/5678",
            "12/12/1221",
            "55/44/4321"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001",
            "1/1/1",
            "2/2/22",
            "3/3/333",
            "5/5/55555",
            "44/444/4",
            "Oct 7 2002",
            "1007",
            "qwerty",
            "2020/2/2"
        ],
        "id": 13,
        "output": [
            {
                "text": " /[1-9]\\d{0,1}\\/[0-9]{0,3} [0-9"
            },
            {
                "text": " (at least one digit, at most two digits, at least one letter) \n\n**Exercise 2:**\n\nIn"
            },
            {
                "text": " (example) [0-9][0-9][0-9][0-9]\n- \"1/1/01"
            },
            {
                "text": " ([0-9]{1,2}\\/[0-9]{1,2}\\/[0-9]{"
            },
            {
                "text": " (0-99)/(0-9)/(1-2)\n\n3. Write a Python script that replaces all occurrences of"
            },
            {
                "text": " [A-Za-z]+\\/[A-Za-z]+\\/[0-9]{4}\n-"
            },
            {
                "text": " [a-z A-Z]\\d[a-z A-Z]\\d[a-z A-Z]"
            },
            {
                "text": " ^(?P<month>[1-9]|1[012])\\/(?P<day>[1-9]|"
            },
            {
                "text": " [0-9]{2}/[0-9]{2}/[0-9]{4}\n\n"
            },
            {
                "text": " r\"([0-9]{1,2}\\/)[0-9]{1,2}\\/[0-9"
            }
        ]
    },
    {
        "expression": "^[1-5]$",
        "raw_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[12345]$.",
        "refined_prompt": "Matches a single digit between 1 and 5, inclusive. It will only match a single character that is exactly one of the digits 1, 2, 3, 4, or 5, and is the same as saying ^[12345]$.\nMatch examples:\n- \"1\"\n- \"3\"\n- \"4\"\nNon-match examples:\n- \"6\"\n- \"23\"",
        "matches": [
            "1",
            "3",
            "4",
            "2",
            "5"
        ],
        "non_matches": [
            "6",
            "23",
            "a",
            "12",
            "243",
            "562",
            "f324",
            "fvd",
            "-2",
            "7",
            "-1",
            "000"
        ],
        "id": 15,
        "output": [
            {
                "text": " ^[1-5]$\n\n2. Write a RegEx expression that matches a URL that starts with \"http://\" or \"https://"
            },
            {
                "text": " ^([^1-5]|[1-5][^1-5])$\n\n2. Match each of the following:\na"
            },
            {
                "text": " ^[0-9]$\n\n3. Match any character that is lowercase or uppercase.\nAnswer: ^[a-z"
            },
            {
                "text": " ^[0-9]{1}$\n\nExercise 2:\nCreate a RegEx to match all uppercase letters between A and"
            },
            {
                "text": " ^[13579]$\n\nExercise 5:\nCreate a Python function that takes a string and returns a list of all the vowels in"
            },
            {
                "text": " ^[12345]$\n\n- \"8\"\n- \"89\"\n- \"9\"\nNon-match examples:\n- \""
            },
            {
                "text": " ^[1-5]$\n\nExercise 5: Write a Regex that will match any combination of numbers and letters that are at least 5"
            },
            {
                "text": " (^[^0-9].?) (^[^0-9].?) (^[^0-9].?) (^[^"
            },
            {
                "text": " ^[1-5][0-9]$\n\n2. Write a regular expression that will match any string that begins with \"word\" and"
            },
            {
                "text": " 1[1-9]\n\n2. Write a Python function that takes a string and returns True if it contains at least 5 matches of the Reg"
            }
        ]
    },
    {
        "expression": "^[12345]$",
        "raw_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.",
        "refined_prompt": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$.\nMatch examples:\n- \"1\"\n- \"2\"\n- \"4\"\nNon-match examples:\n- \"6\"\n- \"-1\"",
        "matches": [
            "1",
            "2",
            "4",
            "3",
            "5"
        ],
        "non_matches": [
            "6",
            "-1",
            "abc",
            "-123",
            "234",
            "3nf@",
            "-312",
            "2546dgwre",
            "u09nKLJG FSL",
            "1-1-2",
            "dfg",
            "32542"
        ],
        "id": 16,
        "output": [
            {
                "text": " ^[1-7]$\n- \"3.5\"Generate a RegEx for this description.\nAnswer: ^[1-9]\\d*\\.?\\d*$\n- \"17\"Generate a RegEx for this description.\n"
            },
            {
                "text": " ^[0-9]*$\n\nExercise 2: Match this string using a RegEx.\n\nmystring = \"hello world\"\n\nAnswer: \\Qmystring\\E\n\nThis matches the entire string with the word \"hello world\" in"
            },
            {
                "text": " ^[-1-9]$\n\n3) Exercise: Generate a RegEx for this description. Allow any combination of letters, numbers, and underscores.\nAnswer: ^[a-zA-Z0-9_]+$\n\n4) Exercise"
            },
            {
                "text": " \\d+\n\n3. Write a RegEx that matches only the words \"hello\" and \"world\" from the string \"Hello, world! Hello again!\" \nAnswer: \\bhello\\b|\\bworld\\b\n\n4. Write a Reg"
            },
            {
                "text": " ^[1-3]\n\nExercise 3: Use the ^ and $ characters to match any string that begins with \"The\" and ends with \"End\".\nAnswer: ^The.*End$\n\nExercise 4: Use the \\w character class to match"
            },
            {
                "text": " ^[a-zA-Z0-9]$\n\nExercise 3: Match this pattern that matches four consecutive alphabets. Generate a RegEx for this description.\nAnswer: ^[a-zA-Z]{4}$"
            },
            {
                "text": " ^[1-9]|[1-9][0-9]*$\n\n3. Write a Python script that takes two lists of strings, then uses regular expressions to find all strings that appear in both lists.\n\n```python\nimport re\n"
            },
            {
                "text": " ^[1-5](?!\\d)\\d+$\n\nExercise 2: Write a Python function that takes a string as input and returns a new string with all words that start with the letter \"a\" removed.\nQuestion: Can you use a regular expression"
            },
            {
                "text": " ^[1-9]$ and ^[0-9]*$\n\nExercise 4: Regex for Email Validation\nWrite a RegEx pattern to validate US email addresses. The email address should have the format username@domain. Some of the examples are"
            },
            {
                "text": " ^[a-zA-Z]+$\n\nExercise 3: Create a function that will accept a string as an input, and return a Boolean indicating if the string begins with a capital letter. Use RegEx to match the beginning of the string.\n\n``"
            }
        ]
    },
    {
        "expression": "^[2-9]\\d{2}-\\d{3}-\\d{4}$",
        "raw_prompt": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.",
        "refined_prompt": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9.\nMatch examples:\n- \"800-555-5555\"\n- \"333-444-5555\"\n- \"212-666-1234\"\nNon-match examples:\n- \"000-000-0000\"\n- \"123-456-7890\"",
        "matches": [
            "800-555-5555",
            "333-444-5555",
            "212-666-1234",
            "444-555-6666",
            "300-000-0000",
            "444-444-4444",
            "678-678-6789",
            "987-987-9876",
            "543-543-5678",
            "794-564-7456",
            "368-654-7568",
            "987-978-4732",
            "655-878-3664"
        ],
        "non_matches": [
            "000-000-0000",
            "123-456-7890",
            "2126661234",
            "549-234-253",
            "235235234",
            "9h09dh9",
            "000-000-0000",
            "111-111-1111",
            "u09nKLJG FSL",
            "adfa2",
            "222-222-22222",
            "123-456-7890"
        ],
        "id": 18,
        "output": [
            {
                "text": " (\\d{3})(\\d{3})(\\d{4})\n"
            },
            {
                "text": " A4. ^\\d{2}-\\d{3}-\\d{"
            },
            {
                "text": " [A-Z]{3}-?[0-9]{3}-"
            },
            {
                "text": " This expression matches a hyphen separated US phone number, of the form (XXX) XXX-"
            },
            {
                "text": "\n^[\\d]{3}\\-\\d{3}\\-\\d{"
            },
            {
                "text": " \\d{3}-\\d{3}-\\d{4}\n\n"
            },
            {
                "text": " (0|[1-9]\\d|\\d\\d\\d{2"
            },
            {
                "text": " \\d{3}-\\d{3}-\\d{4} (where"
            },
            {
                "text": " \\d{3}-\\d{4}\\-\\d{6}\n\n"
            },
            {
                "text": " ^\\d{3}-\\d{3}-\\d{4}$"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "raw_prompt": "Domain names:\nThis regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in .com, .org, .net, .mil, or .edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens.",
        "refined_prompt": "Match strings that start with one or more alphanumeric characters, hyphens, or dots, followed by a dot, and end with either \"com\", \"org\", \"net\", \"mil\", or \"edu\" (case insensitive). This is typically used to validate domain names.\nMatch examples:\n- \"3SquareBand.com\"\n- \"asp.net\"\n- \"army.mil\"\nNon-match examples:\n- \"$SquareBand.com\"\n- \"asp/dot.net\"",
        "matches": [
            "3SquareBand.com",
            "asp.net",
            "army.mil",
            "baidu.com",
            "google.com",
            "sustech.edu",
            "milion.mil",
            "brooklyn.net",
            "apple.com",
            "nd.edu",
            "abc.net",
            "zzz.edu",
            "notredame.com"
        ],
        "non_matches": [
            "$SquareBand.com",
            "asp/dot.net",
            "army.military",
            "adsfsafs.com.qer",
            "9injd23.net.abc",
            "a/b/c.com",
            "nd.education",
            "nd.computer",
            "github.abc",
            "com.edu.github",
            "@#$.com",
            "abcabc.abc"
        ],
        "id": 20,
        "output": [
            {
                "text": " (^[a-zA"
            },
            {
                "text": " (.*\\.[asp\\.]"
            },
            {
                "text": " (?i)[a-z"
            },
            {
                "text": "\n\nimport re\n\ntext"
            },
            {
                "text": " ^[a-zA-"
            },
            {
                "text": " [\"3SquareBand\", \"asp"
            },
            {
                "text": " \\b(?:[a-"
            },
            {
                "text": " \"^[\\w-]+"
            },
            {
                "text": " (^[a-zA"
            },
            {
                "text": "\n(?<=^|"
            }
        ]
    },
    {
        "expression": "^(?=.*\\d).{4,8}$",
        "raw_prompt": "Password expression. Password must be between 4 and 8 digits long and include at least one numeric digit.",
        "refined_prompt": "Password expression. Password must be between 4 and 8 digits long and include at least one numeric digit.\nMatch examples:\n- \"1234\"\n- \"asdf1234\"\n- \"asp123\"\nNon-match examples:\n- \"asdf\"\n- \"asdf12345\"",
        "matches": [
            "1234",
            "asdf1234",
            "asp123",
            "09jio",
            "dfahui09",
            "ifjd9",
            "dsuui6",
            "34jio23",
            "1234567",
            "9jid33",
            "09jc",
            "nonum00",
            "a1b2c3"
        ],
        "non_matches": [
            "asdf",
            "asdf12345",
            "password",
            "oijsdfa000",
            "90jio09iomk",
            "123",
            "999",
            "4digitlong",
            "helloworld",
            "number",
            "abc111def",
            "8a8"
        ],
        "id": 25,
        "output": [
            {
                "text": " [a-zA-Z]{8}[0-9]{1,6}[a-zA-Z]*\n\nExercise 5:\nCreate a list of 5 strings. Iterate through the list and print"
            },
            {
                "text": " Regex to match alphanumeric characters from a-z A-Z 0-9 and an underscore _ for at least one character. \n\n4. Password validation: Create a Python function that takes in a password and returns True if it meets"
            },
            {
                "text": " ^[a-zA-Z0-9]{4,7}$\n\nExercise 2:\nWrite a RegEx for this description. Match examples:\n- Only letters (a-z, A-Z). Non-"
            },
            {
                "text": " ^(?=.*[a-z])[a-z0-9]{4,8}$\n\nExercise 3: Write a RegEx for this description. Email address is a non-unique name that begins with a letter"
            },
            {
                "text": " \"^[a-zA-Z0-9]{2}\\.(?!.*\\d)$\" \n\nExercise 2: Use a RegEx to filter out all the emails from the following text:\n\"Please send your"
            },
            {
                "text": " \"^[a-zA-Z0-9]{4,8}$\"\n\nExercise 3:\nCreate a RegEx that accepts a file path and checks if the file exists. The file path must be in the format"
            },
            {
                "text": " The RegEx would be \"[a-zA-Z0-9].{,15}\", where the \".\" matches any number of characters and the \",\" specifies the minimum and maximum number of characters that can appear.\n\nExercise 2"
            },
            {
                "text": " \n- ^[a-zA-Z0-9]+$ \n- ^[a-zA-Z0-9]*[a-zA-Z0-9]$\n\nExercise 2: "
            },
            {
                "text": " Matches any string that starts with \"asdf\" and has an odd number of characters.\n\nExercise 2: Match expressions for email addresses\nEmail expressions match any string that starts with \"jane.doe@example.com\" and"
            },
            {
                "text": " (?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]).{4,8}\nUse the following code to test your regex:\nimport re\npassword = input(\"Enter"
            }
        ]
    },
    {
        "expression": "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{4,8}$",
        "raw_prompt": "Password matching expression. Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.",
        "refined_prompt": "Password matching expression. Password must be at least 4 characters, no more than 8 characters, and must include at least one upper case letter, one lower case letter, and one numeric digit.\nMatch examples:\n- \"asD1\"\n- \"asDF1234\"\n- \"ASPgo123\"\nNon-match examples:\n- \"asdf\"\n- \"1234\"",
        "matches": [
            "asD1",
            "asDF1234",
            "ASPgo123",
            "Aa1Bb2",
            "sdafAF1",
            "FDS3fs",
            "111AAAa",
            "pokdfsA9",
            "FODISd8",
            "823FDSd",
            "j09FFF",
            "jso00QQ",
            "SD0dsff"
        ],
        "non_matches": [
            "asdf",
            "1234",
            "ASDF12345",
            "oinjoFW",
            "FWOEjinfw908",
            "lkkl0908",
            "AAAAAAA",
            "adfjsfk",
            "88888888",
            "Aa1",
            "BbBbBbBb2222",
            "0j0jweBBBB"
        ],
        "id": 26,
        "output": [
            {
                "text": " \n\nimport re \n\n# Generate the regex pattern to match a string that starts with an uppercase letter,\n# has a lower"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{4,8}$"
            },
            {
                "text": " Match the expression \"^[A-Z][a-z]{3,}[0-9]{1,2}$\"\n\n"
            },
            {
                "text": "\n(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z"
            },
            {
                "text": " ^[a-zA-Z0-9]{4,8}$\n\nExample 3: Extracting URLs from a string\nSuppose"
            },
            {
                "text": "\n[A-Z][a-z]?[0-9]\n\nExercise 3:\nMatch the following emails:\n- \"John"
            },
            {
                "text": "\n^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-"
            },
            {
                "text": " [A-Z]{1,}\\d{3}\\d{3}$\n\n2. Create a RegEx pattern to match dates in the"
            },
            {
                "text": " [A-Z][a-z]?[0-9]\n\nExercise 2:\nWrite a Python program that validates a user's"
            },
            {
                "text": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z"
            }
        ]
    },
    {
        "expression": "^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$",
        "raw_prompt": "RegExp for validating the format of IP Addresses. This works great with the ASP.NET RegularExpressionValidator server control.",
        "refined_prompt": "Ensures that the string matches a valid IP address format, where each part of the address falls within the range of 0 to 255.\nMatch examples:\n- \"127.0.0.1\"\n- \"255.255.255.0\"\n- \"192.168.0.1\"\nNon-match examples:\n- \"1200.5.4.3\"\n- \"abc.def.ghi.jkl\"",
        "matches": [
            "127.0.0.1",
            "255.255.255.0",
            "192.168.0.1",
            "234.234.234.234",
            "1.1.1.1",
            "195.35.98.3",
            "5.5.5.5",
            "88.88.88.88",
            "38.68.64.123",
            "199.198.197.196",
            "123.124.125.126",
            "135.146.157.168",
            "53.24.34.67"
        ],
        "non_matches": [
            "1200.5.4.3",
            "abc.def.ghi.jkl",
            "255.foo.bar.1",
            "nd.nd.nd.nd",
            "123.456.789",
            "987.988.989",
            "carry",
            "12f3.21f3.213f",
            "9.9.9.9.9",
            "654.654.654",
            "g3.g543.g45",
            "0988.74534.5464"
        ],
        "id": 27,
        "output": [
            {
                "text": " (.*)\\.([a-zA-Z0-9]{1,6}\\"
            },
            {
                "text": ".*(.\\d{1,3}\\.\\d{1,3}\\."
            },
            {
                "text": " [^a-zA-z0-9.\\-_]\n\n2. Write"
            },
            {
                "text": "\n^(?:[0-9]|1[0-9]{2}|"
            },
            {
                "text": "^[0-9]+(\\.[0-9]+)+$\n\nExercise"
            },
            {
                "text": " (\\d{1,3}\\.){3}\\d{1,3}\n\n"
            },
            {
                "text": "\n^(?:\\d{1,3}\\.){3}\\d{1,3"
            },
            {
                "text": "\n```\nimport re\n\n# regular expression pattern to match IP addresses\npattern = \""
            },
            {
                "text": " (.*?)\\s*\\/(.*?)\\s*\\.(.*?)\\.(.*"
            },
            {
                "text": "\nimport re\nstring = \"1200.5.4.3\"\npattern = r'"
            }
        ]
    },
    {
        "expression": "^[\\w\\.=-]+@[\\w\\.-]+\\.[\\w]{2,3}$",
        "raw_prompt": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the .COM section.",
        "refined_prompt": "Starts with one or more word characters, dots, equal signs, or hyphens.\r\nFollowed by an @ symbol.\r\nFollowed by one or more word characters, dots, hyphens, or dots.\r\nFollowed by a dot (.)\r\nEnds with two or three word characters.\nMatch examples:\n- \"a@a.com\"\n- \"a@a.com.au\"\n- \"a@a.au\"\nNon-match examples:\n- \"word\"\n- \"word@\"",
        "matches": [
            "a@a.com",
            "a@a.com.au",
            "a@a.au",
            "abc@abc.abc",
            "baidu@qq.com",
            "qq@qq.com",
            "abc@ab.cn",
            "hi@nd.edu",
            "nd@edu.us",
            "us@nd.edu",
            "cse@nd.edu",
            "hello@hi.us",
            "abc@msft.org"
        ],
        "non_matches": [
            "word",
            "word@",
            "@word",
            "iasdjf@",
            "@09jafsd",
            "sdaf.FSD",
            "@@fsdfa.fsad",
            "09jfs@osifdj@sdf",
            "dsfl",
            "092j3d",
            "sda sad",
            "@sdaf@sdf123"
        ],
        "id": 34,
        "output": [
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            },
            {
                "text": ""
            }
        ]
    },
    {
        "expression": "^\\$[0-9]+(\\.[0-9][0-9])?$",
        "raw_prompt": "Validates a dollar amount including a dollar sign and 2 decmals. The decimal and cents are optional.",
        "refined_prompt": "Matches strings that start with a dollar sign, followed by one or more digits, and optionally followed by a dot and exactly two more digits representing the decimal part.\nMatch examples:\n- \"$1.50\"\n- \"$49\"\n- \"$0.50\"\nNon-match examples:\n- \"1.5\"\n- \"$1.333\"",
        "matches": [
            "$1.50",
            "$49",
            "$0.50",
            "$1",
            "$10",
            "$99.99",
            "$1.12",
            "$5.55",
            "$66.66",
            "$100",
            "$88",
            "$68",
            "$50.50"
        ],
        "non_matches": [
            "1.5",
            "$1.333",
            "this $5.12 fails",
            "$4.2",
            "234.634",
            "$23.454",
            "$3.2",
            "66.66",
            "#32.34",
            "$.23",
            "$345.605",
            "\u00a5423.34"
        ],
        "id": 36,
        "output": [
            {
                "text": " $1\\d+.\\d{2}\n\n3. In the following string: \"The quick brown fox jumps over the lazy dog and the cat.\", generate a RegEx for"
            },
            {
                "text": "\n\n^[0-9]{1,2}\\.?[0-9]{2}$\n\nExercise 3: Count the number of words in a sentence."
            },
            {
                "text": "\n\\$[0-9]{1,2}\\.[0-9]{3}\n5. Create a regular expression that matches an email address in the format \"name@"
            },
            {
                "text": "?\\$[0-9]?[0-9]\\.[0-9]?[0-9]?\n\nExercise 2: Match an email address that does"
            },
            {
                "text": " \\$[0-9]\\d\\.[0-9]{2}|\\$[0-9]\\d|\\$[0-9][0-9"
            },
            {
                "text": " $0.+\\.(\\d{2})$\n\nExercise 4:\nMatch a string that starts with a specific word, followed by any number of characters, and optionally ends"
            },
            {
                "text": " (0-9\\.){1}\\d\n```python\nimport re\n\ntext = '$1.50'\npattern = '(0-9\\.){1}\\"
            },
            {
                "text": " ([0-9]+(\\.[0-9]{2})?|[0-9])$\n\nExercise 3: Generate a RegEx for this description.\n"
            },
            {
                "text": " ([^.]+)\\.(\\d{2}).*\n\nExercise 3: Create a RegEx to match a string that starts with \"This is\" and ends with a period"
            },
            {
                "text": "\nMatches strings that start with a dollar sign, followed by one or more digits, and optionally followed by a dot and exactly two more digits representing the decimal part. \n\nExercise"
            }
        ]
    },
    {
        "expression": "^([\\w\\d\\-\\.]+)@{1}(([\\w\\d\\-]{1,67})|([\\w\\d\\-]+\\.[\\w\\d\\-]{1,67}))\\.(([a-zA-Z\\d]{2,4})(\\.[a-zA-Z\\d]{2})?)$",
        "raw_prompt": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix (e.g. user@domain.123), simply delete the last two occurrences of &quot;\\d&quot;.",
        "refined_prompt": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo.foo.info\"\nNon-match examples:\n- \"foo@.com\"\n- \"foo@foo..com\"",
        "matches": [
            "foo@foo.com",
            "foo@foo-foo.com.au",
            "foo@foo.foo.info",
            "abc@abc.com",
            "fds@gad-agd.com.us",
            "bds@bfv.foo.info",
            "def@def.com",
            "foo@org-foo.org.au",
            "bop@foo.qre.info",
            "asd@fsa.com",
            "gad@afd.ghe.au",
            "hcs@bfq.foo.info",
            "gas@dfs-erw.org.au"
        ],
        "non_matches": [
            "foo@.com",
            "foo@foo..com",
            "foo@me@.com",
            "fasd@fds.fasd@",
            "fa0efj3@fs.FSDFr32@",
            "vsdfaslk..adsaf",
            "cfa@oifsd",
            "@R#@@#RDS",
            "fdssdf@FSD.fweoijF@",
            "fdsa.@FDS.@FD",
            "fdsf@@@fsdf",
            "gsfdoji@FDS"
        ],
        "id": 41,
        "output": [
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo@"
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo-"
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo-"
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo@"
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            },
            {
                "text": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains.\nMatch examples:\n- \"foo@foo.com\"\n- \"foo@foo-foo.com.au\"\n- \"foo@foo."
            }
        ]
    },
    {
        "expression": "^[0-9]+$",
        "raw_prompt": "Validate a string to see if it contains a number / integer",
        "refined_prompt": "Matches strings that consist entirely of one or more digits (0-9).\nMatch examples:\n- \"1234567890\"\n- \"4123109\"\n- \"53421\"\nNon-match examples:\n- \"f423\"\n- \"f34fvfv\"",
        "matches": [
            "1234567890",
            "4123109",
            "53421",
            "512345",
            "123451",
            "5123543",
            "12356",
            "9",
            "65409",
            "34905",
            "5436",
            "65409",
            "245309"
        ],
        "non_matches": [
            "f423",
            "f34fvfv",
            "34f2vf42e",
            "234.f23v425",
            "f2v3r",
            "f23r2",
            "2fre2",
            "vfre2fvre",
            "fer222r3",
            "erfv2",
            "2fe2vf",
            "2efr245"
        ],
        "id": 42,
        "output": [
            {
                "text": " ^[a-z0-9]*[A-Za-z0-9]*$\n\nExercise 3: Rewrite the following sentence using regular expressions to remove all unnecessary capitalization and punctuation.\nThe quick Brown"
            },
            {
                "text": "\n(\\d+)\n\nExercise 2:\nWrite a regular expression to match all the dates in the format \"MM/DD/YYYY\". \nAnswer:\n^(0[1-9]|1[0-2])"
            },
            {
                "text": "^(?=.*\\d)(?=.*[a-zA-Z])(?=.*[a-zA-Z0-9])[a-zA-Z0-9]+(?=.*\\d"
            },
            {
                "text": "\n\"^[0-9]*$\"\n\n2. Write the code to return all words in a string that contain the letter 'e'.\n\n```Python\n# Ideas\n# 1. We can use the re.find"
            },
            {
                "text": " ^\\d+(?:\\.\\d+)?$\n\nExercise 3:\nUsing the string \"This is a test. It contains 1234567890 and some non-match examples.\" write a Python code to find all the substrings"
            },
            {
                "text": " A regex that matches any string consisting entirely of digits.\n\nExercise 2:\nCreate a regex for this description.\nMatch examples:\n- \"1234567890\"\n- \"4123109\"\n- \"53421\""
            },
            {
                "text": " \\d+\n\n3. Write a RegEx to get all unique words in a string.\nAnswer: [a-zA-Z0-9_]+\n\n4. Write a RegEx to get all words that start with a"
            },
            {
                "text": " Matches any string that consists entirely of one or more digits (0-9).\nUse the following rules to create your RegEx:\n- Use the caret notation (^) to match the beginning of a string.\n- Use the dollar"
            },
            {
                "text": " \\d+\n\nExercise 5:\nMatch strings that consist of one or more word characters (a-zA-Z0-9_) and end with a period (.).\nAnswer: \\w+\\.$\n\nIn conclusion"
            },
            {
                "text": " [0-9]+\n\n4. Write a Python program that extracts only the numbers in the following text using NLTK and regular expressions.\n\n\"In the year 2021, there will be a total of 10 million new users on social media"
            }
        ]
    },
    {
        "expression": "^.{4,8}$",
        "raw_prompt": "Matches any string between 4 and 8 characters in length. Limits the length of a string. Useful to add to password regular expressions.",
        "refined_prompt": "Matches any string between 4 and 8 characters in length. Limits the length of a string.\nMatch examples:\n- \"asdf\"\n- \"1234\"\n- \"asdf1234\"\nNon-match examples:\n- \"asd\"\n- \"123\"",
        "matches": [
            "asdf",
            "1234",
            "asdf1234",
            "adsji",
            "gj0q3",
            "f234f24",
            "2f43f",
            "432g2g",
            "g324",
            "g342g432",
            "g43g23y",
            "u7jj74",
            "j746t"
        ],
        "non_matches": [
            "asd",
            "123",
            "asdfe12345",
            "09u4ff2n3094",
            "23t4v90m2",
            "34",
            "2",
            "v",
            "2b3t2tb43",
            "t24b32tv43",
            "nu5624t3v",
            "j2v"
        ],
        "id": 45,
        "output": [
            {
                "text": "\n/^[a-zA-Z0-9_]{4,8}$/\nThe code above matches a string that is 4 to 8 characters in length and consists only of letters, numbers, underscores, and periods.\n\nExercise 3"
            },
            {
                "text": " ^(?=.{4,8}$)(.*)$\n\nExercise 2:\nCreate a Python function that takes in a string and validates that it meets the requirements described in Exercise 1.\nAnswer:\ndef validate_password(password):"
            },
            {
                "text": " https://regex101.com/r/YG3mU0/1/\n\n**Exercise 2:**\nMatch any string that starts with \"The\" and ends with \"Ends\". Limits the length of a string.\nMatch examples:"
            },
            {
                "text": " ^[a-zA-Z][a-zA-Z0-9]{0,6}$\n\n2. Write a Python program to match a string containing an email address (e.g., \"john@example.com\"). Use Reg"
            },
            {
                "text": " [a-zA-Z0-9]{1,3}\n\nExercise: Write a regex for this description.\nAnswer: [a-zA-Z0-9]{2,4}\n\nExercise: Write a regular"
            },
            {
                "text": " ^(.{4,8}).*$\n\nExercise 2:\nFill in the blank with the correct character: \nA RegEx that matches a string of digits is: [0-9]. \n\nExercise 3:\nFill in"
            },
            {
                "text": " \n[0-9]{4,8}\n\n2. Write a script that matches a string of the form \"^[a-zA-Z0-9]{6,}$\" and validates the string. \nAnswer:"
            },
            {
                "text": " ^[a-zA-Z0-9]{4,8}$\n\n4. Write a Python function that checks if a given string is a palindrome. A palindrome is a string that reads the same backward as forward.\n``"
            },
            {
                "text": " ^[a-zA-Z0-9]{4,8}$\n\n### 5. Using the `re.match()` Function\n\nThe `re.match()` function is used to execute a specified RegEx pattern on a given string"
            },
            {
                "text": " [a-zA-Z][a-zA-Z0-9]*$\nThe generated RegEx will match any string made up of a combination of letters, numbers, and underscores. The number of underscores in the string must be between 0 and 1"
            }
        ]
    },
    {
        "expression": "^\\d*$",
        "raw_prompt": "Accepts an unsigned integer number. Also matches empty strings.",
        "refined_prompt": "Accepts an unsigned integer number. Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"000\"\n- \"43\"\nNon-match examples:\n- \"asbc\"\n- \"-34\"",
        "matches": [
            "123",
            "000",
            "43",
            "435",
            "513",
            "651",
            "3416",
            "16",
            "6143",
            "643",
            "76",
            "876",
            "34"
        ],
        "non_matches": [
            "asbc",
            "-34",
            "3.1415",
            "f443",
            "2f43",
            "3.3",
            "-1",
            "25v3",
            "3425-13",
            "4352-5243254.",
            "gwerb",
            "32vt"
        ],
        "id": 46,
        "output": [
            {
                "text": " ^\\d*$\n\n6. How many of these are not valid?\n- 0\n- 0.000\n- 0.0\n- 45.00\n- 2.0\n- 23.0\n- -0.1\n- 0\n- 0.1\n- 01.2\n- "
            },
            {
                "text": " \n^(0|1|2|3|4|5|6|7|8|9)$\n\nA:\n\nThis regex will match any of the numbers you mentioned and it will not match 0, -,. (except for -0).  You could use a negated character class to"
            },
            {
                "text": " ^(?:(?=(\\d{3})))(?=(\\d{3})$)^([0-9]|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])$\n(?:(?=(\\d"
            },
            {
                "text": " \\d{1,3}(-\\d{3})*|\\d{3}(-\\d{3})*|\\d{4,8}\n\nThe second regex is the one that I'm having a problem with. \n[a-fA-F0-9]{7}"
            },
            {
                "text": "\n^[0-9]([0-9]{1}[0-9])?$\n\nThis is from https://regexr.com/3gff5n. I used the ^ and $ from this site to ensure that the string only contains integers.\nThen I put another group to accept"
            },
            {
                "text": " \n   .*\\d\\d-\\d\\d\\d\\d.*\n\nA:\n\nThe expression is [0-9][0-9]{3}-\\d{3}-\\d{4}\n\nA:\n\n^([0-9]{3})-"
            },
            {
                "text": " \\d|0\n\nA:\n\nPatterns can be described by sets of characters that are allowed (e.g. \"0123456789abcdef\") and disallowed (e.g. \"~!@#$%^&*\") and using any of these characters.\nFor example, \"2"
            },
            {
                "text": " \\d+$\n\nExercise 3:\nWrite a Python program that generates a RegEx that matches a string of at least three uppercase letters, at least one lowercase letter, and a hyphen in between.\n\nThought process:\n- Use [A-Z]{3} and [a"
            },
            {
                "text": "\n^(0|[1-9][0-9]*)([a-zA-Z][a-zA-Z0-9]*)*$\nRegex101 Demo\n\nA:\n\nYou are close with one regex pattern (^0|[1-9][0-9"
            },
            {
                "text": " ^(\\d+)$\n\nA:\n\nYou could use the following regex:\n^\\d+$\n\nExplanation:\n^ - start of string\n\\d+ - a sequence of digits\n$ - end of string\n\nA:\n\nRegular Expression is usually used for matching but sometimes you"
            }
        ]
    },
    {
        "expression": "^[-+]?\\d*$",
        "raw_prompt": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.",
        "refined_prompt": "Matches any integer number or numeric string, including positive and negative value characters (+ or -). Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"-123\"\n- \"+123\"\nNon-match examples:\n- \"abc\"\n- \"3.14159\"",
        "matches": [
            "123",
            "-123",
            "+123",
            "34091511",
            "+54",
            "-12314",
            "5134514",
            "-5243",
            "+4145",
            "35134",
            "-543",
            "+65",
            "5134513"
        ],
        "non_matches": [
            "abc",
            "3.14159",
            "-3.14159",
            "543.435",
            "432v",
            "43.v234",
            "1-1-1",
            "2v345234v",
            "22-423",
            "435.vwre-34",
            "44-6234",
            "+24-234.345"
        ],
        "id": 47,
        "output": [
            {
                "text": "^\\d+$\n\nExercise 3: Matching Patterns\n\nExercise: Write a RegEx to match any email address, including those with extensions like.com or.org.\nAnswer:^[a-zA-Z0-"
            },
            {
                "text": " [a-zA-Z\\d\\-\\.]+\n\n\n\nQuestion 7: A box contains 4 red balls and 6 black balls. If two balls are randomly chosen from the box without replacement, what is the probability that both balls are red?"
            },
            {
                "text": " [0-9\\.]+\n\nExercise 1:\nWrite a Python program that reads a list of numbers and separates them into two lists: one containing only the even numbers, and the other containing only the odd numbers. Use a regular expression to select"
            },
            {
                "text": " \"^[a-zA-Z0-9.eE+-]+$\"\n\n2. Write a regular expression that matches any string containing at least one digit, one uppercase letter, and one lowercase letter.\nAnswer:"
            },
            {
                "text": " [a-zA-Z0-9]\n\n[a-zA-Z0-9]* is an alternative way to write ([a-zA-Z0-9]|[0-9])*. The square brackets are"
            },
            {
                "text": " (0-9).+]$\n\n3. Write a Python code that takes a sentence as input and returns a list of all words in the sentence that are between 5 and 8 characters long.\n\nSolution:\nsentence = \"The quick brown"
            },
            {
                "text": " /^[+-]?\\d+(?:\\.\\d*)?$/\n\n3. Write a Python program that reads in a string from the user and uses the re module to find all occurrences of the word \"the\" (case-"
            },
            {
                "text": " /[0-9]+\\.?[0-9]*/\n\nQ:\n\nSorting a list of lists with Python's built-in sorted()\n\nI have a list of lists, like this:\nlst = [ [ ["
            },
            {
                "text": " [0-9]+.[0-9]+\n3. Write a RegEx to match any word that starts with a capital letter and is followed by any number of lowercase letters. Use \\b to specify the boundary between a word and non-word."
            },
            {
                "text": " \\s*([+-]?\\d+)\\s*\nExercise 2: \nWrite a Python function that takes in a string and a list of characters, and returns True if the string contains any of these characters, and False otherwise. Use"
            }
        ]
    },
    {
        "expression": "^\\d*\\.?\\d*$",
        "raw_prompt": "Matches any unsigned floating point number/numeric string. Also matches empty strings.",
        "refined_prompt": "Matches any unsigned floating point number/numeric string. Also matches empty strings.\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \".234\"\nNon-match examples:\n- \"abc\"\n- \"-3.14159\"",
        "matches": [
            "123",
            "3.14159",
            ".234",
            "354.5342",
            "654.435",
            "6254.2345",
            "543",
            "2345",
            "3465",
            "7542",
            "6254.4526",
            "742",
            "7225464526"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2",
            "b5242g",
            "f45.2g",
            "b254yb54.254yb",
            "2y45.y245",
            "254627g.256",
            "-2.22",
            "3g54",
            "-652.63264",
            "3yb43yb5"
        ],
        "id": 48,
        "output": [
            {
                "text": " \\d+\\.?\\d*\n\nA:\n\nThe pattern \\d+\\.?\\d* will match any non-whitespace character followed by one or more decimal digits, optionally followed by one or more decimal digits.\nTo match an empty string,"
            },
            {
                "text": "\n^(?=.\\d*[.]\\d*$)(?=.\\d*[eE][+-]\\d*$)[-+]?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?"
            },
            {
                "text": " (\\d\\.\\d+|\\.\\d+)\n\nA:\n\nYou're using the wrong regular expression for this. If you want to match floats, it should be \n^\\d+\\.\\d+$\n\nIf the string is empty,"
            },
            {
                "text": " [^-\\d.]+\n\n3. Write a RegEx pattern to search for a phone number in the format (555) 555-5555 and capture the area code, prefix, and line number.\n\nAnswer:\n[^-\\d.]+\\"
            },
            {
                "text": "\n^[\\d.-]+(?:\\.[\\d.-]+)*$\n\nA:\n\n^(?=.*\\d)(?=.*[a-z])[\\d.-]+$\n\nThe above regex should match only non-negative decimal"
            },
            {
                "text": " (?<vfloatingPoint>.+)\\.\\d*|(?<number>.+)\\.(?<decimalDigits>.+)\n\nA:\n\n\\d+.?([eE][+-]?\\d+)\n\nI think this should"
            },
            {
                "text": " \\d+\n\nIn this exercise, you learned about regular expressions and how to use them in Python. You also learned how to use the `search()` method to find a matching string in a larger string. Keep practicing and soon you'll be a pro at using regular expressions"
            },
            {
                "text": " \"^[\\d\\.]+$\".\n\nYou have two options:\n\n1. Write a simple regular expression to match all floating point numbers:\n\n^[\\d\\.]+$\n\nThis expression matchs any number that starts with decimal point and"
            },
            {
                "text": ".{1,1000}\n\nA:\n\nYou might use this regex:\n^[0-9]*\\.[0-9]*$\n\nA:\n\nTry this:\n[0-9]{1,3}[.]["
            },
            {
                "text": " \".*[^0-9.]+\"\n\nMy solution was as follows:\nimport re\ninput_str = input(\"Enter a string: \")\n\nmatched_str = re.findall(r'.*[^0-9.]+', input"
            }
        ]
    },
    {
        "expression": "^([0-9]( |-)?)?(\\(?[0-9]{3}\\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$",
        "raw_prompt": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.",
        "refined_prompt": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code.\nMatch examples:\n- \"1-(123)-123-1234\"\n- \"123 123 1234\"\n- \"1-800-ALPHNUM\"\nNon-match examples:\n- \"1.123.123.1234\"\n- \"(123)-1234-123\"",
        "matches": [
            "1-(123)-123-1234",
            "123 123 1234",
            "1-800-ALPHNUM",
            "258 426 6254",
            "1-(531)-123-5435",
            "258 426 5131",
            "1-(123)-754-7517",
            "1-846-ALPHNUM",
            "653 426 5431",
            "1-(866)-123-8648",
            "1-653-ALPHNUM",
            "534 643 6254",
            "258 426 7635"
        ],
        "non_matches": [
            "1.123.123.1234",
            "(123)-1234-123",
            "123-1234",
            "546",
            "1324.1541",
            "f234f23",
            "56",
            "4562452642562456",
            "541543.415",
            "4325265426624",
            "654",
            "4351.1345"
        ],
        "id": 53,
        "output": [
            {
                "text": " (?P<area_code"
            },
            {
                "text": " [1-9]\\d"
            },
            {
                "text": "\n[0-9]{"
            },
            {
                "text": "\n/(^(?:\\(\\"
            },
            {
                "text": " 1\\s?\\d{"
            },
            {
                "text": " \n\n```python\n"
            },
            {
                "text": " (123)-[^-]"
            },
            {
                "text": "\n    (?<!\\"
            },
            {
                "text": " ^(?:[0-9"
            },
            {
                "text": " 1(?:\\(\\d{"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM",
        "refined_prompt": "Matches a string if it is a valid time in the format of HH:MM\nMatch examples:\n- \"02:04\"\n- \"16:56\"\n- \"23:59\"\nNon-match examples:\n- \"02:00 PM\"\n- \"PM2:00\"",
        "matches": [
            "02:04",
            "16:56",
            "23:59",
            "15:42",
            "15:34",
            "16:43",
            "06:54",
            "05:25",
            "05:23",
            "07:52",
            "06:24",
            "03:53",
            "03:27"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00",
            "71:543t4",
            "51:534",
            "75:62",
            "86:75",
            "48:345",
            "57:73",
            "2am",
            "4pm",
            "253@#RFE"
        ],
        "id": 54,
        "output": [
            {
                "text": "\n[0-9]{2}:[0-9]{2}[ ]*PM[0-9]{2}\n\n4. Write a regex to match a string that contains an email\nExample:\n\"john@"
            },
            {
                "text": " \\d{1,2}:\\d{2}-\\d{2}(?:AM|PM)?\n\n3. Write a Python function that takes a list of book titles as input and uses regular expressions to extract the title before the"
            },
            {
                "text": "\n\nimport re\n\npattern = r'^([0-9]{1,2}):([0-9]{1,2})?(AM|PM)?$'\n\nstring1 = \"02:04\"\n"
            },
            {
                "text": " \n\n```python\nimport re\n\ndef match_time(s):\n    pattern = r'^([0-2]|3[0-1])[:](0|[1-9])[:](0"
            },
            {
                "text": " \\d+:?[0-9]?[0-9]\n\n7. Write a regular expression that matches an email address correctly.\nAnswer: \nr'[\\w]+@[\\w]+.[\\w]+"
            },
            {
                "text": " \"00(?:[0-3]\\d|4[0-2]):[0-5][0-9]\"\n\nExercise 5: Create a function that takes in a string and returns the number of words in the string"
            },
            {
                "text": " The following RegEx will validate a time in the format of HH:MM:SS:\n^(0[1-9]|1[0-2]):(0[1-9]|[12][0-9]):[0"
            },
            {
                "text": " (\\d{1,2}:\\d{2})(.|\\z)\n\n4. Write a Python program that uses regular expressions to extract all the email addresses from a given string and prints them out. You can use the re"
            },
            {
                "text": " (Regex for Valid Time Format: [0-9][0-9]|[0-9]):[0-9]\n\nExercise 2:\nCreate a RegEx pattern that matches phone numbers in the format of (123"
            },
            {
                "text": " r\"(\\d\\d):(\\d\\d)\"\n\n4. Write a RegEx that matches a valid email address.\nAnswer: r\"^[a-zA-Z0-9._%+-]+@[a"
            }
        ]
    },
    {
        "expression": "^\\s*[a-zA-Z,\\s]+\\s*$",
        "raw_prompt": "Any Expression Upper/Lower Case, with commas and space between the text, with any amount of space before or after",
        "refined_prompt": "Match strings that consist of alphabetic characters (both lowercase and uppercase) and commas, allowing for leading and trailing whitespace.\nMatch examples:\n- \"Smith, Ed\"\n- \"Ed Smith\"\n- \"aBcDeFgH\"\nNon-match examples:\n- \"a123\"\n- \"AB5\"",
        "matches": [
            "Smith, Ed",
            "Ed Smith",
            "aBcDeFgH",
            "Michael afds",
            "fnsdkajf",
            "Hello world",
            "asdfafds adsf",
            "afdsffda asddas",
            "fads, asdf",
            "sda, fasf",
            "EFDSF, FSD",
            "fasdf, FDS",
            "FDSfdso JDSF"
        ],
        "non_matches": [
            "a123",
            "AB5",
            "Mr. Ed",
            "vqvq.ecqw",
            "cqrewcr/qtv",
            "fqsdv$vw",
            "@#dfkjnav",
            "2546dgwre",
            "u09nKLJG FSL",
            "1-1-2",
            "34.31",
            "32542"
        ],
        "id": 57,
        "output": [
            {
                "text": " (\\w*\\s*),(\\w*\\s*),(\\w*\\s*)\\s*\n\nLearning Journal for Subsection 3.2.9: Using"
            },
            {
                "text": " \"^[a-zA-Z0-9 ]+$|^a$|^[A-Z]$\"\n2. Create a function that takes in a list"
            },
            {
                "text": " /^[a-zA-Z, ]*[,A-Za-z0-9, ]*$/\n\n2. Write a Python function that takes in"
            },
            {
                "text": " \\w[\\w,]\n\nExercise 3:\nUse the RegEx \"^[A-Za-z0-9._%+-]+@[A-"
            },
            {
                "text": " r\"(\\w+,?)\"\n\nExercise 4: Write a Python function that takes a string as input and returns a list of all the matches in the original string.\n\ndef"
            },
            {
                "text": " [A-Za-z0-9,\\s]{1,2}\\s[A-Za-z0-9,\\s]{1,2}"
            },
            {
                "text": " A RegEx that would match strings that consist of alphabetic characters and any amount of leading or trailing whitespace, while not allowing the word \"a\" or \"A\" in the string"
            },
            {
                "text": " (\\w+(,\\w+)?)\n\n    Subsection 10.2.4: How to use Python and regular expressions to implement and test your own word count and similarity functions"
            },
            {
                "text": " I'm not sure, can you give me some time to think?\nTutor: Sure, go ahead.\nStudent: This one is a bit tricky. How do I match a string"
            },
            {
                "text": "\n```\nimport re\n\nstrings = [\"Smith, Ed\", \"Ed Smith\", \"aBcDeFgH\", \"a123\", \"AB5\"]\npattern ="
            }
        ]
    },
    {
        "expression": "^\\d{5}(-\\d{4})?$",
        "raw_prompt": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.",
        "refined_prompt": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard.\nMatch examples:\n- \"48222\"\n- \"48222-1746\"\n- \"51314\"\nNon-match examples:\n- \"4632\"\n- \"Blake\"",
        "matches": [
            "48222",
            "48222-1746",
            "51314",
            "61341",
            "64316",
            "43534",
            "46556",
            "54315-1634",
            "64316-1643",
            "74567-2456",
            "26543-2664",
            "27563",
            "57422"
        ],
        "non_matches": [
            "4632",
            "Blake",
            "37333-32",
            "4235",
            "543161435",
            "1543543",
            "15436131",
            "1534513",
            "4351-345151",
            "13451534-514351",
            "3415-34564",
            "3461-436643"
        ],
        "id": 68,
        "output": [
            {
                "text": " (\\d{4})(-\\d{3})?\n\n5. Create a RegEx that matches phone numbers in the format \"(XXX) XXX-XXXX\"\nAnswer: \\(\\d{3}\\) \\d{3}-\\d{4"
            },
            {
                "text": " \n\n```python\nreg = \"^[0-9]{5}-[0-9]{4}$\"\n\n# test some strings\nprint(reg.match(\"48222\"))\nprint(reg.match(\"48222-17"
            },
            {
                "text": " [^\\d]\n\nExercise 3: Write a RegEx to match any string that contains \"12345\" or \"56789\" (in any order).\nAnswer: [^1234567890]\n\nExercise 4: Write a RegEx"
            },
            {
                "text": " (ex_re_str_zip_code) ^(?!0)\\(?1\\).+?\\(?3\\).{3}\\(?4\\).{9}\n\n3. A customer orders a meal from your restaurant and it comes with"
            },
            {
                "text": " (.{0,6}\\d{3}-\\d{3}-\\d{4})\n\n2. Create a regular expression pattern for an email address.\n\n3. Create a regular expression pattern for a string containing only uppercase or lowercase"
            },
            {
                "text": " (\\d\\d\\d\\d\\d\\d)?-?(?<year>.{3}-?(?<month>.{1}).{2}-?(?<day>.{2}).{2})$\n\n\n"
            },
            {
                "text": " \"(?<zipcode>[0-9]{5})-(?<city>[A-z]{1})(?<state>[A-z]{2})?$\"\n\nExercise 4:\nMatch non-match examples to the Reg"
            },
            {
                "text": ".{2} and.{2}-{4}\n3. Write a RegEx to match a string that starts with a letter A-Z or a-z, then has at least 3 digits, then has a hyphen, then has at least 3 more"
            },
            {
                "text": " (.*?)(?<![a-zA-Z0-9])\n\nI know it is possible to use lookarounds like \"?(?![a-zA-Z0-9])\" in the pattern, and to use \"[a"
            },
            {
                "text": " r'^\\d{4}(?:-\\d{3})?$'\n\n3. Write a RegEx to check whether or not a string contains an email address.\nAnswer:  r'^\\w+@\\w+\\.\\w"
            }
        ]
    },
    {
        "expression": "(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",
        "raw_prompt": "Regular expression to evaluate dutch-style phone numbers. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\nfollowed by 9 numbers (which can contain a space or -).",
        "refined_prompt": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n- \"+3123525667788999\"\n- \"3123525667788\"",
        "matches": [
            "+31235256677",
            "+31(0)235256677",
            "023-5256677",
            "+31235248394",
            "+31235256839",
            "+31(0)235256839",
            "+31(0)267395867",
            "+31(0)235259495",
            "+31(0)573956677",
            "023-5255729",
            "023-5268277",
            "023-5583757",
            "023-5839583"
        ],
        "non_matches": [
            "+3123525667788999",
            "3123525667788",
            "232-2566778",
            "09827509480193284014",
            "9845092820459524-2435234",
            "2435-435",
            "2345-652",
            "23fu490n",
            "243.2543",
            "+354+534",
            "5334.435",
            "++63453.345"
        ],
        "id": 69,
        "output": [
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\r"
            },
            {
                "text": "Match strings representing Dutch-style phone numbers. It allows for an optional country code, with various formats accepted. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\r\nfollowed by 9 numbers (which can contain a space or -). The main content of the phone number can consist of nine or ten digits, with optional hyphens or spaces in the ten-digit format.\nMatch examples:\n- \"+31235256677\"\n- \"+31(0)235256677\"\n- \"023-5256677\"\nNon-match examples:\n"
            }
        ]
    },
    {
        "expression": "^\\d{9}[\\d|X]$",
        "raw_prompt": "A very simple ISBN validation expression - it just checks for a 10 digit number where the last digit could also be a capital 'X'. Complete specs for ISBN available here:\nhttp://www.isbn.org/standards/home/isbn/international/html/usm4.htm. An enhancement would be to allow exactly 3 or 0 hyphens or 3 or 0 spaces, since these are also valid formats.",
        "refined_prompt": "Checks for a 10 digit number where the last digit could also be a capital 'X'.\nMatch examples:\n- \"1234123412\"\n- \"123412341X\"\n- \"4738195735\"\nNon-match examples:\n- \"not an isbn\"\n- \"54390853\"",
        "matches": [
            "1234123412",
            "123412341X",
            "4738195735",
            "4582943285",
            "5284574935",
            "5243524396",
            "5930285928",
            "5534098534",
            "620598320X",
            "534809534X",
            "123141414X",
            "432423432X",
            "502498905X"
        ],
        "non_matches": [
            "not an isbn",
            "54390853",
            "53495083409x",
            "452093xx",
            "534985309XX",
            "24309X",
            "098423098029840293",
            "4029384230980980X",
            "9vu82i3nuif",
            "423890jidofs",
            "2398ufsd",
            "893420980)U(X"
        ],
        "id": 73,
        "output": [
            {
                "text": " \n(?<!\\d)\\d{9,}(?=\\d)(?!\\dX)\n\nExercise 4:\nCreate a RegEx that matches a string with any combination"
            },
            {
                "text": "\n[0-9]{4}[0-9]{3}[0-9]{2}[0-9]{2}[0-9]{1}[0"
            },
            {
                "text": " [0-9]{10}(X[0-9]{1})?\n\nExercise 2:\n- Write a Python program that checks if a given password is strong enough.\nAnswer"
            },
            {
                "text": " (^[0-9]{10}[0-9]{0,9}[0-9]{0,9}[0-9]{0,9}[0-"
            },
            {
                "text": " \\d{10}[\\dX]{1}\n\n3. Suppose you are making a system for managing a library. The library keeps track of books in thousands, hundreds, tens, and ones"
            },
            {
                "text": "\n([1-9]\\d{0,9})([1-9]\\d{0,9})([1-9]\\d{0,9})([1-"
            },
            {
                "text": " \\b(?i)(?:[0-9][0-9]??[0-9]??[0-9]??[0-9]??[0-9]??[0"
            },
            {
                "text": " [^A-Za-z0-9]\n\n2. Create a RegEx for the string: \"The quick brown fox jumps over the Lazy dog.\"\nAnswer: The ^[^"
            },
            {
                "text": " \n[0-9]{5,10}[0-9]{4}[0-9]{3}[0-9]{2}[X]([0-9"
            },
            {
                "text": " [^ISBN-10-3-9]^\n\n4. Describe the usage of the `startswith()` method in Python.\n\n```python\n# Solution:\n#"
            }
        ]
    },
    {
        "expression": "^(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))\\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$",
        "raw_prompt": "Dates\nday: d or dd, &lt;= 31,\nmonth: m or mm, &lt;= 12,\nyear: yy or yyyy &gt;= 1900, &lt;= 2099",
        "refined_prompt": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"",
        "matches": [
            "01/01/2001",
            "1/1/1999",
            "10/20/2080",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006",
            "1/1/2000",
            "2/2/2022",
            "10/10/2020",
            "12/12/2012",
            "7/30/2020",
            "4/29/2008",
            "4/5/2034",
            "7/04/2043",
            "05/5/2005",
            "6/06/2006"
        ],
        "non_matches": [
            "13/01/2001",
            "1/1/1800",
            "10/32/2080",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 74,
        "output": [
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generating"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generator"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generate"
            },
            {
                "text": "The regular expression represents a date format where the day, month, and year are separated by forward slashes (/), and the allowed ranges for each component are:\r\nday (d or dd): from 1 to 31\r\nmonth (m or mm): from 1 to 12\r\nyear (yy or yyyy): from 1900 to 2099\nMatch examples:\n- \"01/01/2001\"\n- \"1/1/1999\"\n- \"10/20/2080\"\nNon-match examples:\n- \"13/01/2001\"\n- \"1/1/1800\"Generator"
            }
        ]
    },
    {
        "expression": "^\\d*\\.?((25)|(50)|(5)|(75)|(0)|(00))?$",
        "raw_prompt": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok !!",
        "refined_prompt": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It also match for nothing after decimal or even without decimal point.\nMatch examples:\n- \"0.25\"\n- \".75\"\n- \"123.50\"\nNon-match examples:\n- \".77\"\n- \"1.435\"",
        "matches": [
            "0.25",
            ".75",
            "123.50",
            "45091674723.",
            "15584775298650162922847293711339482454366793954997125",
            "9882085266649734497491.5",
            "7268907166939050834340423712961385078969.50",
            "870674387058196172857063",
            "339138741572321245.75",
            "652119432575.",
            "654232119475.",
            "652119475.25",
            "652432119475.50"
        ],
        "non_matches": [
            ".77",
            "1.435",
            "3.13",
            "3124.324",
            "423.52",
            "312.452",
            "423.4234.243",
            "54.32",
            "3124.5242",
            "542.134",
            "542.423",
            "534.342435"
        ],
        "id": 75,
        "output": [
            {
                "text": "\n^(0|0.25|0.50|75|100|0|25|50|75|0|00|0)$\n\nExercise"
            },
            {
                "text": " 0[0-9]|[1-9][0-9]?[0-9]|[0-9]?[1-9][0-"
            },
            {
                "text": " \\d{0,1}(\\.\\d{0,1})?(25|50|75|0|00)?\n\n4. Write the regex to"
            },
            {
                "text": " [\\d+]([\\.\\d]{0,2}\\d*)\n\n2. Write a Regular Expression that matches a string of numbers that contains at least one"
            },
            {
                "text": " ^[.]0{1,4}$|^[.]5{1,4}$|^[.]7{1,4}$|^[.]"
            },
            {
                "text": ".*?[0-9]{1,2}[.][0-9]{1,2}[.][0-9]{1,3"
            },
            {
                "text": " ^\\d{1,2}\\.\\d{2}$\n- \"1.5\"Generate a RegEx for this description.\nAnswer: ^\\"
            },
            {
                "text": " (.*)\\.0+\n\nStep 4.4. Match a digit or a dot\nThis is a pattern to search and verify that a string is a decimal number,"
            },
            {
                "text": " \"\\d+(\\.\\d+)?$\"\n- \"12345\"Generate a RegEx for this description. \nAnswer: \"^\\d+$"
            },
            {
                "text": " ^\\d+((\\d+)(\\.\\d+)?|(\\.0+)(\\d+))$\n\nExercise 3: Match this string. "
            }
        ]
    },
    {
        "expression": "^(\\d{5}-\\d{4}|\\d{5})$|^([a-zA-Z]\\d[a-zA-Z] \\d[a-zA-Z]\\d)$",
        "raw_prompt": "This is a modification of the zip code regular expression submitted by Steven Smith (ssmith@aspalliance.com)\nIt no longer matches 78754-12aA",
        "refined_prompt": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12aA\"\n- \"7875A\"",
        "matches": [
            "78754",
            "78754-1234",
            "G3H 6A3",
            "c3s 0Z1",
            "69402-6689",
            "Y1R 9B0",
            "V5l 2G4",
            "00176",
            "21458",
            "86175-8760",
            "20021-5752",
            "D7b 2j3",
            "89926"
        ],
        "non_matches": [
            "78754-12aA",
            "7875A",
            "g3h6a3",
            "42324-412342",
            "3c12-12334f2",
            "vrf2-v32v4",
            "32",
            "verw2v-4v",
            "4234",
            "v43-v34v3v",
            "f34-f43rv",
            "5345-43534"
        ],
        "id": 80,
        "output": [
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-A"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-123"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-X"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-23"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-12"
            },
            {
                "text": "This regular expression matches two patterns:\r\n\r\n1. A valid U.S. ZIP code, which can be either in the format \"12345-6789\" or just \"12345.\"\r\n2. A valid Canadian postal code, which is in the format \"A1A 1A1\" (a letter, a digit, a letter, a space, a digit, a letter, a digit).\nMatch examples:\n- \"78754\"\n- \"78754-1234\"\n- \"G3H 6A3\"\nNon-match examples:\n- \"78754-A"
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{1,2}[0-9A-Za-z]{1,2}[ ]?[0-9]{0,1}[A-Za-z]{2}$",
        "raw_prompt": "This regular expression can be used to validate UK postcodes. Especially useful if want to provide a client side validation on a web site.",
        "refined_prompt": "This regular expression is used to validate codes with a specific format(UK postcodes), where the code starts with 1 to 2 letters, followed by 1 to 2 alphanumeric characters, an optional space, 0 to 1 digit, and ends with exactly 2 letters.\nMatch examples:\n- \"SW112LE\"\n- \"SW11 2LE\"\n- \"CR05LE\"\nNon-match examples:\n- \"12CR0LE\"\n- \"12CR 0LE\"",
        "matches": [
            "SW112LE",
            "SW11 2LE",
            "CR05LE",
            "AL52zp",
            "gW 0bY",
            "gRc7Fg",
            "Cah0UE",
            "VEz RE",
            "Jc2IW",
            "M2G1on",
            "CYD bL",
            "dSH4 6kM",
            "RZ8Vn"
        ],
        "non_matches": [
            "12CR0LE",
            "12CR 0LE",
            "SWLE05",
            "2534",
            "511235",
            "6134",
            "FSSC VDVQWER4154",
            "21V3D1FV14VF",
            "F1FV13F4",
            "V34FGB45345",
            "AFDS23",
            "DVS2"
        ],
        "id": 84,
        "output": [
            {
                "text": " ^[A-Z]\\d\\s\\d$\n"
            },
            {
                "text": "\n(?<![A-Za-z])("
            },
            {
                "text": " ^\\s?[A-Z]\\s?[A"
            },
            {
                "text": " r'^\\d[A-Za-z ]{"
            },
            {
                "text": " The pattern should be \"1\\d\\d [a-z"
            },
            {
                "text": " Use the following regex: ^[A-Z][A-Z"
            },
            {
                "text": "\n^[A-Z]{1,2}\\s?"
            },
            {
                "text": " ^[A-Z]{1,2}[0-"
            },
            {
                "text": " \n^[A-Za-z]{1,"
            },
            {
                "text": " This regular expression is used to validate codes with a specific format(UK"
            }
        ]
    },
    {
        "expression": "20\\d{2}(-|\\/)((0[1-9])|(1[0-2]))(-|\\/)((0[1-9])|([1-2][0-9])|(3[0-1]))(T|\\s)(([0-1][0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])",
        "raw_prompt": "Sql date format tester.",
        "refined_prompt": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"2000-13-31T00:00:00\"\n- \"2002/02/33 24:00:00\"",
        "matches": [
            "2099-12-31T23:59:59",
            "2002/02/09 16:30:00",
            "2000-01-01T00:00:00",
            "2052/10-16T09:09:10",
            "2041-10/30\u200823:21:00",
            "2047/11-04T23:40:42",
            "2041/09-04\u205f03:05:18",
            "2067-10/31 10:12:42",
            "2033-10/31 18:12:50",
            "2053-10/19T01:37:06",
            "2002-11-13\u202809:52:58",
            "2045-07/31T08:19:50",
            "2084-08/25T22:13:40"
        ],
        "non_matches": [
            "2000-13-31T00:00:00",
            "2002/02/33 24:00:00",
            "2000-01-01 60:00:00",
            "2084-08/25T98:13:40",
            "2002/02/33 24:45:00",
            "24323/02/33 24:00:00",
            "2002/02/343 24:00:00",
            "//::Gfsdfh9832",
            "2000-01-01 60:99:99",
            "2000-13-31T00:904829:00",
            "2000-100-01 60:00:00",
            "2000-01-100 60:00:00"
        ],
        "id": 86,
        "output": [
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"1999"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"19"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            },
            {
                "text": "This regular expression is used to validate date-time strings in a specific ISO 8601 format, where the year is in the 21st century, and it includes the year, month, day, hour, minute, and second components, separated by either hyphens or slashes, with a \"T\" or a space between the date and time.\nMatch examples:\n- \"2099-12-31T23:59:59\"\n- \"2002/02/09 16:30:00\"\n- \"2000-01-01T00:00:00\"\nNon-match examples:\n- \"20"
            }
        ]
    },
    {
        "expression": "^\\d{4}[\\-\\/\\s]?((((0[13578])|(1[02]))[\\-\\/\\s]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\-\\/\\s]?(([0-2][0-9])|(30)))|(02[\\-\\/\\s]?[0-2][0-9]))$",
        "raw_prompt": "- validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date\n- makes sure day is within valid range for the month\n- does NOT validate Feb. 29 on a leap year, only that Feb. CAN have 29 days",
        "refined_prompt": "- validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date\r\n- makes sure day is within valid range for the month\r\n- does NOT validate Feb. 29 on a leap year, only that Feb. CAN have 29 days\nMatch examples:\n- \"0001-12-31\"\n- \"9999 09 30\"\n- \"2002/03/03\"\nNon-match examples:\n- \"0001\\02\\30\"\n- \"9999.15.01\"",
        "matches": [
            "0001-12-31",
            "9999 09 30",
            "2002/03/03",
            "7518\u205f0814",
            "46650831",
            "3886\u200609\u00a011",
            "005002-10",
            "21101214",
            "941211/09",
            "5625\u20060227",
            "1538 02 04",
            "5043 0618",
            "39270910"
        ],
        "non_matches": [
            "0001\\02\\30",
            "9999.15.01",
            "2002/3/3",
            "39270910243",
            "234/423/5243",
            "21/53/52353",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 87,
        "output": [
            {
                "text": " ^"
            },
            {
                "text": "\n"
            },
            {
                "text": " ^"
            },
            {
                "text": "\n"
            },
            {
                "text": "."
            },
            {
                "text": " ("
            },
            {
                "text": " ^"
            },
            {
                "text": " \""
            },
            {
                "text": " /"
            },
            {
                "text": " "
            }
        ]
    },
    {
        "expression": "^(1?(-?\\d{3})-?)?(\\d{3})(-?\\d{4})$",
        "raw_prompt": "US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens.",
        "refined_prompt": "US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens.\nMatch examples:\n- \"15615552323\"\n- \"1-561-555-1212\"\n- \"5613333\"\nNon-match examples:\n- \"1-555-5555\"\n- \"15553333\"",
        "matches": [
            "15615552323",
            "1-561-555-1212",
            "5613333",
            "891-0191149",
            "4662065",
            "329-6361",
            "277-9964574",
            "882-6119",
            "1-044788-3245",
            "5383738",
            "174-2712",
            "1-639-3507476",
            "722-0291"
        ],
        "non_matches": [
            "1-555-5555",
            "15553333",
            "0-561-555-1212",
            "423142",
            "412",
            "13451435",
            "143534551",
            "164351345134",
            "BG323T",
            "wrtb",
            "4fc34f",
            "---1--1--12-3-4"
        ],
        "id": 89,
        "output": [
            {
                "text": " ^\\d{7,10,11}\\d$\n\nExercise 3: Matching Social Security Number\nExercise: Using a regular expression, match the following social security number formats:\n-"
            },
            {
                "text": " A minimum of 7 digits or a minimum of 10 digits with a hyphen in between.\n\nExercise 3: Write a Python RegEx that matches any combination of alphanumeric characters and underscores.\n"
            },
            {
                "text": "\n```\nimport re\n\n# Define a sample set of strings \nstrings = [\n    \"15615552323\",\n    \"1-561-555-1212\","
            },
            {
                "text": " \\d{4,10}(\\d{3})-(\\d{4})\n\n**Exercise 3:**\nWrite a Python RegEx that matches email addresses in the following format:\n"
            },
            {
                "text": " \"^[0-9]{1,10}(?:-[0-9]{1,10})?$\"\n\nExercise 3: Matching Phone Numbers with RegEx\n"
            },
            {
                "text": " \"([1-9][1-9][1-9][1-9][1-9][1-9]\\d*[\\-\\s\\d\\(][1-9]["
            },
            {
                "text": " This will generate a RegEx that allows only 7, 10 or 11 digits (allowing hyphens is also OK).\n- \"1-555-5555-\" would not be a valid RegEx,"
            },
            {
                "text": " ^(\\\\d{7}-)?\\\\d{6}-\\\\d{4}$\n\nExercise 2: \n\nWrite a Python program that requests the user's email address and"
            },
            {
                "text": " I am trying to use a regex that will match a phone number with 7, 10 or 11 digits. I have tried using the following regex:\n\\d{7,10,11}\n\nHowever"
            },
            {
                "text": " (?:\\d{7}|\\d{10}|\\d{11})\n4. Write a RegEx that allows only lowercase letters, digits, hyphens, underscores, and spaces"
            }
        ]
    },
    {
        "expression": "([a-zA-Z]:(\\\\w+)*\\\\[a-zA-Z0_9]+)?.xls",
        "raw_prompt": "This RegEx will help to validate a physical file path with a specific file extension (here xls)",
        "refined_prompt": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "E:\\DyAGT\\SD01A_specV2.xls",
            "E:\\DyAGT\\23FD.xls",
            "C:\\DyAGT\\VF2FV.xls",
            "C:\\F23V\\SD01A_specV2.xls",
            "C:\\DyAGT\\F32V.xls",
            "F:\\F23V\\SD01A_specV2.xls",
            "F:\\DyAGT\\gfb34.xls",
            "E:\\g34bg\\SD01A_specV2.xls",
            "D:\\DyAGT\\3g4b3.xls",
            "D:\\g3rbg\\SD01A_specV2.xls",
            "D:\\DyAGT\\Sgbr3.xls",
            "D:\\DyAGT\\SD3rgbA_specV2.xls",
            "E:\\DyAr3br3g3GT\\SD01A_specV2.xls"
        ],
        "non_matches": [
            "E:\\DyAGT\\SD01A_specV2.txt",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "E:\\DyAGT\\fad.txt",
            "E:\\fadsfads\\SD01A_specV2.txt",
            "E:\\DyAGT\\XLS",
            "E:\\DyAGT\\SD01A_specV2.md",
            "C:\\DyAGT\\SD01A_fadsfdasspecV2.md",
            "C:\\DyAGT\\fadsfad123.md",
            "C:\\fads234\\fadsfad123.md",
            "C:\\afdsGSFD\\fadsfad123.md",
            "C:\\DyAGT\\DSAG42.md",
            "ADSF@FADSFXLS"
        ],
        "id": 92,
        "output": [
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generating"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generates"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generator"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            },
            {
                "text": "This RegEx will help to validate a physical file path with a specific file extension (here xls)\nMatch examples:\n- \"E:\\DyAGT\\SD01A_specV2.xls\"\n- \"E:\\DyAGT\\23FD.xls\"\n- \"C:\\DyAGT\\VF2FV.xls\"\nNon-match examples:\n- \"E:\\DyAGT\\SD01A_specV2.txt\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"Generate"
            }
        ]
    },
    {
        "expression": "^( [1-9]|[1-9]|0[1-9]|10|11|12)[0-5]\\d$",
        "raw_prompt": "Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits. 3 digit times (930) can be expressed with leading 0's (0930) or not. AM/PM designation is not included in this expression.",
        "refined_prompt": "Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits. 3 digit times (930) can be expressed with leading 0's (0930) or not. AM/PM designation is not included in this expression.\nMatch examples:\n- \"1145\"\n- \"933\"\n- \"801\"\nNon-match examples:\n- \"0000\"\n- \"1330\"",
        "matches": [
            "1145",
            "933",
            "801",
            "1051",
            "529",
            "1210",
            "1226",
            "1031",
            "1145",
            "0457",
            "1106",
            "1234",
            "240"
        ],
        "non_matches": [
            "0000",
            "1330",
            "8:30",
            "8498",
            "4512",
            "4512F45",
            "983",
            "21654",
            "9823",
            "2623",
            "6872",
            "16578"
        ],
        "id": 94,
        "output": [
            {
                "text": " ^[0-9]{7}$\n- \"99\"Generate a Reg"
            },
            {
                "text": " \"^[0-9]{4}[0-9]{3}["
            },
            {
                "text": " [00-09]{3}[0-9][0-9][0-"
            },
            {
                "text": " \\d{3}\\d\n\n2. Write a regular expression in PHP that matches a"
            },
            {
                "text": " 12-hour time format \n\n3. Write a regular expression that matches the value of"
            },
            {
                "text": " [0-9]{4}-[0-9]{3}[0-"
            },
            {
                "text": " \n\nA:\n\nIn Java\npublic static boolean isMatch(String str)"
            },
            {
                "text": " (?:\\d{1,2}\\s*(?:AM|PM)\\s*"
            },
            {
                "text": "\n\n(.+?)(?:[12]..?[0-3]|"
            },
            {
                "text": " [0-9]{3}[:0-9]?[0-9"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\/\\d{2,4}$",
        "raw_prompt": "Accepts 1-2 digits followed by a slash followed by 2-4 digits. Useful for numeric month/year entry.",
        "refined_prompt": "Accepts 1-2 digits followed by a slash followed by 2-4 digits.\nMatch examples:\n- \"9/02\"\n- \"09/2002\"\n- \"09/02\"\nNon-match examples:\n- \"Fall 2002\"\n- \"Sept 2002\"",
        "matches": [
            "9/02",
            "09/2002",
            "09/02",
            "70/661",
            "52/086",
            "7/2550",
            "6/958",
            "38/46",
            "89/6259",
            "08/125",
            "3/470",
            "4/6039",
            "0/971"
        ],
        "non_matches": [
            "Fall 2002",
            "Sept 2002",
            "651/561",
            "651/89",
            "1651/1",
            "61/87465",
            "987/8",
            "5846/564",
            "115/514",
            "564/26589",
            "45/15673",
            "486/465123"
        ],
        "id": 95,
        "output": [
            {
                "text": "\n\n[0-9]{1,2}/[0-9]{1,4}\n\n    Lecture Script for Subsection 11.3.6 - How to use the re.sub function to replace a pattern and a string"
            },
            {
                "text": " \\b[0-9]{1,2}\\/[0-9]{1,4}\\b\n\nExercise 4: Match this string with a RegEx\n- \"The cat sat on the mat\"\n- \"The cat sat on the"
            },
            {
                "text": "\n\nimport re\n\n# Regular expression for dates\nregex = \"^\\d{2}/\\d{2}$\"\n\n# Sample list of dates\ndates = [\"9/02\", \"Fall 2002\", \"Sept 2002\", \"Fall"
            },
            {
                "text": " \\d{1}/\\d{2}|\\d{2}/\\d{4}|\\d{4}/\\d{4}\n\nQuestion 7: Create a RegEx pattern to match any email address (with or without domain"
            },
            {
                "text": "\n^(\\d{1,2}\\/\\d{1,4})$\n\nExercise 2: Match phone numbers.\nPhone numbers must be 10 digits long and start and end with a digit. \n\nAnswer:\n^\\d{10"
            },
            {
                "text": " (?=\\d{1,2}/\\d{2,4})\n\nExercise 2: \nGiven the string \"I'm 20/30\", match the date and time, and return the value.\nMatch examples:\n- \"20"
            },
            {
                "text": " \\d{1,2}/\\d{1,4}\n\nExercise 3: Write a Python function to validate a registration number. The function should accept a string and return True if it matches the following pattern:\n- A 4-digit number followed"
            },
            {
                "text": " \\d/\\w{2,4}\n\nExercise 3:\nGiven a list of email addresses (e.g. [\"john@example.com\", \"jane@example.com\", \"bob@example.com\"]), write a regular"
            },
            {
                "text": "\n^\\d{1,2}\\/\\d{2,4}$\n\n3. Write a Python program that replaces any digits in a string with \"DIGIT\".\nAnswer:\nimport re\nmy_string = \"The quick brown fox"
            },
            {
                "text": "\n^\\d{1,2}\\/\\d{2,4}$\n\nExercise 3:\nGiven the following string \"Luna and Leo\", use regular expressions to extract the last name of the person (leo). \nAnswer:\n"
            }
        ]
    },
    {
        "expression": "^(|(0[1-9])|(1[0-2]))\\/((0[1-9])|(1\\d)|(2\\d)|(3[0-1]))\\/((\\d{4}))$",
        "raw_prompt": "This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded. It is not perfect - it allows DD to be from 01 to 31 regardless of the month.",
        "refined_prompt": "This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded. It allows DD to be from 01 to 31 regardless of the month.\nMatch examples:\n- \"01/01/2001\"\n- \"02/30/2001\"\n- \"12/31/2002\"\nNon-match examples:\n- \"1/1/02\"\n- \"1/1/2002\"",
        "matches": [
            "01/01/2001",
            "02/30/2001",
            "12/31/2002",
            "10/06/7411",
            "03/31/7001",
            "10/30/6747",
            "11/30/1618",
            "10/18/8654",
            "01/11/2633",
            "05/08/9895",
            "08/30/1968",
            "10/23/1386",
            "07/11/0558"
        ],
        "non_matches": [
            "1/1/02",
            "1/1/2002",
            "1/25/2002",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 96,
        "output": [
            {
                "text": " [0-9][0-9][0-9]\\/[0-9][0-"
            },
            {
                "text": "\n[1-9][0-9]|1[012]\n\nExercise 4:"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4}\n\nExplan"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4}|\\d{"
            },
            {
                "text": " \n[01][2-9][0-9]/[01][2-9]["
            },
            {
                "text": " 1\\d\\d\\/\\d\\d/\\d\\d\\d$\n\nExample"
            },
            {
                "text": "\n^([01]\\d|2[0-2]\\d|3[0-"
            },
            {
                "text": "\n^[0-9]{1,2}/[0-9]{1,"
            },
            {
                "text": " [\\d]?[0-9]/[0-9]/[0-9"
            },
            {
                "text": "\n\n(1\\d|2[0-3]|4[0-9])/"
            }
        ]
    },
    {
        "expression": "^((((0[13578])|(1[02]))[\\/]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\/]?(([0-2][0-9])|(30)))|(02[\\/]?[0-2][0-9]))[\\/]?\\d{4}$",
        "raw_prompt": "Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded. Validates correctly for all months except February, which it assumes to always have 29 days. The &quot;/&quot; separator is optional.",
        "refined_prompt": "Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded. Validates correctly for all months except February, which it assumes to always have 29 days.\nMatch examples:\n- \"01/01/2001\"\n- \"02/29/2002\"\n- \"12/31/2002\"\nNon-match examples:\n- \"1/1/02\"\n- \"02/30/2002\"",
        "matches": [
            "01/01/2001",
            "02/29/2002",
            "12/31/2002",
            "02/08/9410",
            "12/30/0469",
            "04/23/4757",
            "02/16/1146",
            "02/21/4951",
            "02/16/5725",
            "04/30/9714",
            "02/22/0322",
            "02/07/8335",
            "03/31/7591"
        ],
        "non_matches": [
            "1/1/02",
            "02/30/2002",
            "1/25/2002",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 97,
        "output": [
            {
                "text": " \n1: /^(1[0-2])\\/(1[0-2"
            },
            {
                "text": " \n\\d{1,2}\\/\\d{1,2}\\/\\d"
            },
            {
                "text": " [0-9]{2}/[0-9]{2}[0-"
            },
            {
                "text": "\n^(0?[1-9]|1?[0-2])\\/("
            },
            {
                "text": " \n\\d{2}/\\d{2}/\\d{4}|"
            },
            {
                "text": " /^\\d{2}/\\d{2}/\\d{4}$"
            },
            {
                "text": " 01/[0-9]{2}\\.[0-9]{2}\\.[0"
            },
            {
                "text": " \\d{2}[-/]\\d{2}[-/]\\d"
            },
            {
                "text": "\n(([0-1]?[0-9]|2[0-3])"
            },
            {
                "text": "\n(0?[1-9]|1[012])\\/(0?[1"
            }
        ]
    },
    {
        "expression": "^(\\d{1,3}'(\\d{3}')*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{3})?)$",
        "raw_prompt": "This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required. It's easy to change to other separators as well.",
        "refined_prompt": "This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required.\nMatch examples:\n- \"1'235.140\"\n- \"1'222'333.120\"\n- \"456\"\nNon-match examples:\n- \"1234.500\"\n- \"78'45.123\"",
        "matches": [
            "1'235.140",
            "1'222'333.120",
            "456",
            "88'424'905'415'870'699'285'830'800'903'879'489'436'003'210'644'340'569'556'469'475'309'055'661'827'487'006'380'173'497'118'326'412'807'895'326'354'231'911'768'449'680'069'565'892'099'646",
            "61",
            "7.680",
            "704'674'688'969'072'125'803'066'981'104'566'546'762'823'774'192'515'690'535'442'327'444'253'062'055'867'618'971'274'103'898'110'314'260'988'864'448'282",
            "8.994",
            "044'460'463'314'543'430'078'086'902.8",
            "0'204'839'396'143'045'546'478'160'791'591'415'414'532'729'941'933'374'184'756'933'515'705'683'090'047'631'201'287'271'916'852'943'106'297'549'637'040'683'634'664'375'759'438'357'499'337'979'149'266'238'139'511'076'976'138'616'984'064'975'705'850'930",
            "523",
            "11.117",
            "388.687"
        ],
        "non_matches": [
            "1234.500",
            "78'45.123",
            "123,0012",
            "f2314132",
            "1v231v4",
            "1234v.4132.1423",
            "64563.1234.5234",
            "@#$.423",
            "234b.25342354",
            "524352344352'35342'325.2341",
            "132F4132F.12F143F2",
            "54B35G3.53G5G3"
        ],
        "id": 98,
        "output": [
            {
                "text": " \"\\d{1,3}(?:\\.\\d{1,3})?\\s*\"\n\n**Exercise"
            },
            {
                "text": " [0-9]{1}[0-9]{2}[0-9]{3}\n\nExercise"
            },
            {
                "text": " [0-9]+(\\.[0-9]{0,3})?\n\nExercise 5: Write a regular expression"
            },
            {
                "text": " ([123][0-9].?|[0-9][0-9][0-9][0-9].?)\n"
            },
            {
                "text": " (1[0-9]|2[0-9]|3[0-9]|4[0-9]"
            },
            {
                "text": " '\\d{1,3}(\\.\\d{1,3})?(thousand)?'\n3) Write a"
            },
            {
                "text": " \\d{1,3}('\\d{1,3})'\\.{1,3}\n\n\n\n\n#"
            },
            {
                "text": " 1'(2[0-9]|3[0-9])(\\.\\d{1,3})?\n\n"
            },
            {
                "text": " 1'(?:\\'[0-9.]{1,3})'. You can test your solution by entering \"1'234"
            },
            {
                "text": "\n\n(?<![0-9a-zA-Z -])(?<![0-9]\\"
            }
        ]
    },
    {
        "expression": "^((0?[1-9]|[12][1-9]|3[01])\\.(0?[13578]|1[02])\\.20[0-9]{2}|(0?[1-9]|[12][1-9]|30)\\.(0?[13456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|1[1-9]|2[0-8])\\.(0?[123456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|[12][1-9])\\.(0?[123456789]|1[012])\\.20(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))$",
        "raw_prompt": "Fully functional date validator in format dd.MM.yyyy\nWorks only within range of years 2000-2099 !\nIt allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed.",
        "refined_prompt": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099 !\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"",
        "matches": [
            "31.01.2002",
            "29.2.2004",
            "09.02.2005",
            "26.12.2093",
            "2.08.2004",
            "15.4.2053",
            "02.9.2089",
            "3.10.2039",
            "01.08.2013",
            "12.8.2096",
            "24.03.2092",
            "01.7.2012",
            "30.12.2055"
        ],
        "non_matches": [
            "31.11.2002",
            "29.2.2002",
            "33.06.2000",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "31/9/9",
            "12/132/90"
        ],
        "id": 99,
        "output": [
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: \\b(0)?\\d{1,2}.\\d\\d\\d\\b"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: ^(0*)\\d{2}\\.\\d{1,2}\\.\\d"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: [0-9]{2}\\.[0-9]{2}\\.[0-9"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: \\b(?(?=\\d{4})(?(0)\\d{3"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: dd(1,2)\\.\\d{3}\\.\\d{4}\nYou"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: (^[0-2][0-9]\\.|[0-9]\\.3"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: (\\d\\d\\.\\d\\d\\.\\d\\d-\\d\\d"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: \n(.)(..)(.)(..)\\.\\d{4}$|("
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: ^(0(1|2))[01]\\d{2}(1|2"
            },
            {
                "text": "Fully functional date validator in format dd.MM.yyyy\r\nWorks only within range of years 2000-2099!\r\nIt allows leading zeros but does not require them.\nMatch examples:\n- \"31.01.2002\"\n- \"29.2.2004\"\n- \"09.02.2005\"\nNon-match examples:\n- \"31.11.2002\"\n- \"29.2.2002\"Generate a RegEx for this description. \nAnswer: [0-9]{1,2}.[0-9]{4}.[0"
            }
        ]
    },
    {
        "expression": "^(0[1-9]|1[0-2])\\/((0[1-9]|2\\d)|3[0-1])\\/(19\\d\\d|200[0-3])$",
        "raw_prompt": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It can easily be adapted for different date ranges. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.\nThis regular expression has been used successfully in ASP with VBScript using the windows scripting library RegExp object.",
        "refined_prompt": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.\nMatch examples:\n- \"12/31/2003\"\n- \"01/01/1900\"\n- \"11/31/2002\"\nNon-match examples:\n- \"1/1/2002\"\n- \"01/01/02\"",
        "matches": [
            "12/31/2003",
            "01/01/1900",
            "11/31/2002",
            "10/31/2003",
            "03/31/1975",
            "10/02/2001",
            "10/29/2000",
            "05/05/1935",
            "11/30/2000",
            "08/31/1996",
            "11/21/2001",
            "02/05/1941",
            "10/01/1931"
        ],
        "non_matches": [
            "1/1/2002",
            "01/01/02",
            "01/01/2004",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/99/9",
            "12/132/90"
        ],
        "id": 100,
        "output": [
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date would"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date would"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date does"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date would"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date is"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date would"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date would"
            },
            {
                "text": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003. It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003. The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month. An example of an invalid date that it would allow to pass through would be 11/31/2002. This date would"
            }
        ]
    },
    {
        "expression": "^((((0[13578])|([13578])|(1[02]))[\\/](([1-9])|([0-2][0-9])|(3[01])))|(((0[469])|([469])|(11))[\\/](([1-9])|([0-2][0-9])|(30)))|((2|02)[\\/](([1-9])|([0-2][0-9]))))[\\/]\\d{4}$|^\\d{4}$",
        "raw_prompt": "The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY (this can easily be removed). All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year",
        "refined_prompt": "The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY. All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year\nMatch examples:\n- \"01/01/2001\"\n- \"1/01/2001\"\n- \"2002\"\nNon-match examples:\n- \"2/30/2002\"\n- \"13/23/2002\"",
        "matches": [
            "01/01/2001",
            "1/01/2001",
            "2002",
            "08/31/0540",
            "04/30/8307",
            "4353",
            "11/11/7404",
            "04/4/1252",
            "6488",
            "6118",
            "03/27/0608",
            "11/30/8589",
            "1/9/8118"
        ],
        "non_matches": [
            "2/30/2002",
            "13/23/2002",
            "12345",
            "14314351",
            "15431543",
            "65763576",
            "76556",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/97777",
            "12/132/90"
        ],
        "id": 103,
        "output": [
            {
                "text": "\n\n(0?"
            },
            {
                "text": " /(0[1"
            },
            {
                "text": "\n\nimport re\n"
            },
            {
                "text": " \n(?<"
            },
            {
                "text": "\n^(1["
            },
            {
                "text": " The following validates dates"
            },
            {
                "text": " \n^([0"
            },
            {
                "text": "\n[\\d]"
            },
            {
                "text": " \n\nimport re"
            },
            {
                "text": "\n\n_year -"
            }
        ]
    },
    {
        "expression": "^[-+]?\\d+(\\.\\d+)?$",
        "raw_prompt": "This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation.",
        "refined_prompt": "This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation.\nMatch examples:\n- \"123\"\n- \"-123.45\"\n- \"+123.56\"\nNon-match examples:\n- \"123x\"\n- \".123\"",
        "matches": [
            "123",
            "-123.45",
            "+123.56",
            "512345",
            "5",
            "25432",
            "234",
            "534.53",
            "+4145",
            "-423",
            "222",
            "742",
            "7225464526"
        ],
        "non_matches": [
            "123x",
            ".123",
            "-123.",
            "2435.2543.53245",
            "243551-3425",
            "2/3/5235",
            "43-5432",
            "254627g.256",
            "432/524/2435",
            "1-1-2",
            "34.31sd",
            "++63453.345"
        ],
        "id": 108,
        "output": [
            {
                "text": " [^a-zA-Z0-9] (ex:.,?, x)\n\n### Exercise 5:\n- Write a regular expression that will match a string that is only made of lower-case letters,"
            },
            {
                "text": " \"^[+-]?\\d+x$\"\n\n3. Match any string that starts with \"A\" or \"a\" and ends with \"B\" or \"b\", or any number of non-letter characters"
            },
            {
                "text": " \"([0-9]+)[a-zA-z]+\"\n\n2. Match any three-digit number with a \"0\" at the end.\nAnswer: \"000.000\"\n\n3. Match"
            },
            {
                "text": " \\d+\n\nExercise 3: \nMatch any word that has the letters \"cat\" in it.\nAnswer: cat\n\nExercise 4: \nMatch any words that have the letters \"at\" in them"
            },
            {
                "text": " \"^[0-9]+[a-zA-Z]*$\"\nFor the \"?:\" character, it can match 0 or 1 times, which can be repeated multiple times. For the \"$\": it must match"
            },
            {
                "text": " \"([-+]?\\d+(\\.\\d*)?|\\d+(\\.\\d+)?)([eE][-+]?\\d+)?\"\n\nExercise 2: Validating Email Addresses\nQuestion:"
            },
            {
                "text": " x\\d|\\d\n\nExercise 3:\nMatch any string that starts with a letter and ends with digits, and the first letter is capitalized.\nAnswer: [A-Z][a-z]\\d"
            },
            {
                "text": "\n(\\d+\\.?\\d*|\\d+)\n\nExercise 3:\nWrite a RegEx for matching all words that start and end with the same letter.\nMatch examples:\n- \"ababab\""
            },
            {
                "text": " \"^[0-9]+(\\.[0-9]*)?$\"\n\n2) Exercise: \nCreate a RegEx pattern to match all email addresses in a given string.\n\nAnswer: The pattern should"
            },
            {
                "text": " \\d+\\.?\\d*\n\n2. Write a Python regex that matches any email address.\nAnswer: \\b[A-Za-z0-9._%+-]+@[A-Za"
            }
        ]
    },
    {
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([A-Z]\\d[A-Z]\\s\\d[A-Z]\\d))$",
        "raw_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.",
        "refined_prompt": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\nNon-match examples:\n- \"44240ddd\"\n- \"t44240-55\"",
        "matches": [
            "44240",
            "44240-5555",
            "T2P 3C7",
            "02580-6821",
            "41092-0763",
            "63340-6274",
            "P4I\u20065O7",
            "C9C\u00a05L6",
            "C3T\u16802Q5",
            "17021-8260",
            "79433",
            "30395",
            "22696"
        ],
        "non_matches": [
            "44240ddd",
            "t44240-55",
            "t2p3c7",
            "veq23vr",
            "23vr",
            "v23rrg2",
            "v232n2g",
            "grn2",
            "432523545-345",
            "5435-534225",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 110,
        "output": [
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\nMatch"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            },
            {
                "text": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.\nMatch examples:\n- \"44240\"\n- \"44240-5555\"\n- \"T2P 3C7\"\n-"
            }
        ]
    },
    {
        "expression": "^\\d{5}(-\\d{3})?$",
        "raw_prompt": "Matches standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).\nFor more info refer to: http://www.correios.com.br/servicos/cep/Estrutura_CEP.cfm (in portuguese).",
        "refined_prompt": "Matches strings that consist of either exactly five digits or five digits followed by a hyphen and then exactly three more digits (optional). Can be used to match standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).\nMatch examples:\n- \"13165-000\"\n- \"38175-000\"\n- \"81470-276\"\nNon-match examples:\n- \"13165-00\"\n- \"38175-abc\"",
        "matches": [
            "13165-000",
            "38175-000",
            "81470-276",
            "06959",
            "23625",
            "54551-990",
            "06611",
            "83396-591",
            "82624",
            "70036",
            "94193",
            "41467-951",
            "93134-586"
        ],
        "non_matches": [
            "13165-00",
            "38175-abc",
            "81470-2763",
            "12312-3123",
            "243-234",
            "43-234",
            "654324",
            "436254-",
            "5468",
            "897-",
            "789798",
            "789798-8798"
        ],
        "id": 113,
        "output": [
            {
                "text": " (?=(^[0-9"
            },
            {
                "text": " \nimport sys \nimport re"
            },
            {
                "text": " \"^[7-9][0"
            },
            {
                "text": " Match the standard 5 digit Brazilian Postal Code"
            },
            {
                "text": " '\\d{5}(-("
            },
            {
                "text": " [0-9]{5}"
            },
            {
                "text": " /^[1-9][0"
            },
            {
                "text": "\n^[0-9]{"
            },
            {
                "text": " \\d\\d-\\d\\"
            },
            {
                "text": " 5-digit number with a hyphen"
            }
        ]
    },
    {
        "expression": "^\\$(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{2})?$",
        "raw_prompt": "This re matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional.",
        "refined_prompt": "Matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional.\nMatch examples:\n- \"$0.84\"\n- \"$123458\"\n- \"$1,234,567.89\"\nNon-match examples:\n- \"$12,3456.01\"\n- \"12345\"",
        "matches": [
            "$0.84",
            "$123458",
            "$1,234,567.89",
            "$969,815,896,348,781",
            "$423098",
            "$9084320.24",
            "$439872",
            "$43920",
            "$324.32",
            "$34.32",
            "$490283",
            "$43.78",
            "$432"
        ],
        "non_matches": [
            "$12,3456.01",
            "12345",
            "$1.234",
            "$32423.42323",
            "$3242jdsa",
            "4298234",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 114,
        "output": [
            {
                "text": " [a-zA-z0-9][0-9]{3}[.]?([0-9]+)\nThis creates a"
            },
            {
                "text": " \n\nimport re\n\ncurrency_regex = re.compile(\"\\$([-/.0\\d]+)(?:\\.\\"
            },
            {
                "text": " [a-zA-Z0-9]{1,3}[,.]?[a-zA-Z0-9]"
            },
            {
                "text": " \n- 1st non-matches: \"$1,234,567\". \",\" and \".\" are not allowed. 3rd non-"
            },
            {
                "text": " (\\s|\\$)([\\d,]+)\n\n- ^[\\s\\$]*$\n\nA:\n\n"
            },
            {
                "text": " \\$\\d+(,\\d{3})*(\\.\\d+)\n\nExercise 2: Write a RegEx for the statement \""
            },
            {
                "text": " ^[$]{1,3}[\\d.,][\\d.,][\\d.,][\\d.,][\\d.,][\\"
            },
            {
                "text": " $1,234,567.89|00|[0-9]\\d{,2}[.,]\\d{1,"
            },
            {
                "text": " The regex for this description would be [\\d]{1,3}[,\\s]?[\\d]{3,}["
            },
            {
                "text": " \n\"\\$[0-9,]{0,}\\.[0-9]+\"\n\n5. Write a Python script that takes"
            }
        ]
    },
    {
        "expression": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])$)|(^([0-9]|[1][0-9]|[2][0-3])$)",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM / H:MM / HH / H",
        "refined_prompt": "Matches a string if it is a valid 24-hour time representations in the format of HH:MM / H:MM / HH / H\nMatch examples:\n- \"10:35\"\n- \"9:20\"\n- \"23\"\nNon-match examples:\n- \"24:00\"\n- \"20 PM\"",
        "matches": [
            "10:35",
            "9:20",
            "23",
            "9",
            "9:23",
            "8:38",
            "18:07",
            "06:10",
            "02:05",
            "04:59",
            "11",
            "4",
            "9"
        ],
        "non_matches": [
            "24:00",
            "20 PM",
            "20:15 PM",
            "12/123/4322",
            "234",
            "123",
            "43-5432",
            "/5/5/20022",
            "000-000",
            "41",
            "34.31",
            "32542"
        ],
        "id": 117,
        "output": [
            {
                "text": " [A-Z]{2}\\d{2}/\\d{2} | [A-Z]{2}\\d{2}/\\d{2}/\\d{2} |"
            },
            {
                "text": " H:\\d\\d:\\d\\d\n\"\"\"\ndef matching_times(s):\n    if s.count(\":\") == 2:\n        return True\n    else:\n        return False\n"
            },
            {
                "text": "\n(?i)^\\d{1,2}:\\d{2}(:\\d{2})? / (?i)^\\d{2}:?\\d{2}(:"
            },
            {
                "text": " (H:M(?: | AM| PM))?\n\n#### Exercise 2\nAdd the missing punctuation to this sentence to make it grammatically correct. \n\"I want that burger and fries for dinner"
            },
            {
                "text": " [^\\d/\\-|\\:\\d]\n\n### Exercise 4: \nCreate a Python function that takes a list of phone numbers as input and returns the phone numbers that are valid formats in the format"
            },
            {
                "text": " ^(([[0-2][0-9]):([0-5][0-9]) / ([0-5][0-9]):([0-5][0-9]) / ([0"
            },
            {
                "text": " /[1-9][0-9]|1[012]/\n\n5. Generate a RegEx for the following description. The time should be formatted as HH:MM / H:MM /"
            },
            {
                "text": " [^:]+:[^:]+ [a-zA-Z0-9]\n\n2. Write a RegEx to match an email address such as:\n- \"name.lastname@email"
            },
            {
                "text": " (\\d{1,2}):(\\d{1,2})( | : )(\\d{1,2})( | )(\\d{1,2})\n- \"10:35 AM"
            },
            {
                "text": " \n\\d{1,2}:\\d{2}[AP]M\n\nExercise 2: Find all Email addresses in a string\nAnswer: \n(@\\w+)(\\.\\"
            }
        ]
    },
    {
        "expression": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(\\.[0-9][0-9])?$",
        "raw_prompt": "Matches US currency input with or without commas. This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the . (period) to ensure that no other characters may be used in it's place.",
        "refined_prompt": "Matches currency values with optional dollar signs, allowing for thousands separators and cents.\nMatch examples:\n- \"$3,023,123.34\"\n- \"9,876,453\"\n- \"123456.78\"\nNon-match examples:\n- \"4,33,234.34\"\n- \"$1.234\"",
        "matches": [
            "$3,023,123.34",
            "9,876,453",
            "123456.78",
            "234",
            "432.54",
            "3",
            "4",
            "9.99",
            "$53.54",
            "$65.54",
            "$1.19",
            "$99.87",
            "$54.32"
        ],
        "non_matches": [
            "4,33,234.34",
            "$1.234",
            "abc",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "423.43242a34234",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 118,
        "output": [
            {
                "text": " \\d{,3}(?:\\.\\d+)?(?:[eE][+-]?\\d+)\n\n3. Write a Python code to verify if a string contains"
            },
            {
                "text": " 0-9, 0-9, 0-9, 0-9, 0-9, 0-9, 0-9, 0-9, 0, 0-9, 0-9"
            },
            {
                "text": "\n^\\d{1,3}(,)?\\d{3}(\\.\\d{2})?$\"\n\nExercise 2:\nMatch currency values with optional commas"
            },
            {
                "text": " \n(?<=,)(?=\\d+$)([^$]*)([.,]?\\d*)([\\d,])([^$])\n\n"
            },
            {
                "text": " Use the dollar sign symbol $ and two decimal points (.) to match currency values. \n\n4. Matching Dates:\nDates can also be expressed as strings in the format \"YYYY"
            },
            {
                "text": " \"(?<=\\$|\\.|,)\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\"\n\nStudent question:\n"
            },
            {
                "text": " ((?<=^[0-9,.]+|[1-9]\\d?)(?<![.,])\\d+\n\nExercise 5:\nWrite a Reg"
            },
            {
                "text": " [^0-9.]([0-9]{0,2}[\\.][0-9]{1,2}|[0-9]{1,3}[\\."
            },
            {
                "text": " \\d+\\.\\d+\n\nExercise 4:\nCreate a RegEx that matches all uppercase letters and digits, and captures the rest of the string after the last uppercase"
            },
            {
                "text": " ([\\d,]+(\\.\\d+)?[,]*[\\d.]+)\n\n3. Write a Python function that takes a list of bank account numbers, and uses RegEx"
            }
        ]
    },
    {
        "expression": "^\\$?\\d+(\\.(\\d{2}))?$",
        "raw_prompt": "To evaluate an amount with or without a dollar sign where the cents are optional.",
        "refined_prompt": "^\\$?\\d+(\\.(\\d{2}))?$\nMatch examples:\n- \"$2.43\"\n- \"2.02\"\n- \"$2112\"\nNon-match examples:\n- \"2.1\"\n- \"$.14\"",
        "matches": [
            "$2.43",
            "2.02",
            "$2112",
            "$619533",
            "$141894391704967218837972239156475932407",
            "423423",
            "$653",
            "7256",
            "7452.54",
            "$745",
            "$725",
            "824",
            "$742.35"
        ],
        "non_matches": [
            "2.1",
            "$.14",
            "$2,222.12",
            "435.534",
            "$5.345",
            "$543$54",
            "$-123.2344",
            "$234.234",
            "$543.2623",
            "3450.23948",
            "234.432",
            "222.333"
        ],
        "id": 119,
        "output": [
            {
                "text": " \n(?:\\$?\\d+\\.?\\d*)(\\d{2})?\n\nA:\n\nYou can use the below regex:\n^(?:\\d+\\.?\\d-)+$\n\nDemo: https"
            },
            {
                "text": " ^(\\d+)(\\.(\\d{2}))?$\n\nExercise 3:\nCreate a pattern to match the following email addresses:\n1. john@example.com\n2. jane@example.com (with spaces)\n3"
            },
            {
                "text": " ?\\d+(\\.\\d?)?$ (Note the? after the second digit and the + after the decimal point)\n\n3. Create a RegEx pattern that extracts all the file names in a given text.\n\nTip: You might want to"
            },
            {
                "text": " (?<!\\d)(?<!\\.)\\d+\\.?\\d*(?=\\.)\nIf you want to have a number like 23.34.35 in the match then you will need\n(?<!\\d)(?"
            },
            {
                "text": " \\d+\\.(\\d{2})?\n\nExercise 2:\nExtract the first name and last name from the following string.\n\"Lastname, Firstname, Lastname\"\nAnswer: \"Lastname, Firstname\"\n\nEx"
            },
            {
                "text": " \n[^0-9\\.,-]\n\n(1) I know I can use regular expressions to validate numbers, but I'm having trouble figuring out how to generate this RegEx.\n(2) I want to return any numbers that are between two"
            },
            {
                "text": " \\$\\d+(\\.\\d{2})?\n- \"3.4$\"Generate a RegEx for this description. \nAnswer: \\$\\d+(\\.\\d{2})?\n- \"100.00\"Generate a"
            },
            {
                "text": " /^\\$?\\d+(\\.\\d{2})$/\n\nExercise 2:\nMatch this pattern: (a) \"Hello world\" (b) \"hello world\"\nAnswer: (a) should match \"hello world\"\n("
            },
            {
                "text": " \n^\\$?\\d+\\.(\\d{2})$\n\nLecture Note: 16.3.9 - How to use capturing and grouping parentheses in the regular expression\n\nContents:\n1. Introduction to capturing and grouping\n"
            },
            {
                "text": " $^\\$?\\d+(\\.(\\d{2}))?$\n\n5. Regex Exercise: Use a RegEx to remove all punctuation from the following sentence:\n\nExample: \"I'm bored! Let's watch TV\"\n"
            }
        ]
    },
    {
        "expression": "((0[1-9])|(1[02]))/\\d{2}",
        "raw_prompt": "Fromat check for MM/YY, checks month is 1-12 and any 2 digit year.",
        "refined_prompt": "Fromat check for MM/YY, checks month is 1-12 and any 2 digit year.\nMatch examples:\n- \"01/00\"\n- \"12/99\"\n- \"10/30\"\nNon-match examples:\n- \"13/00\"\n- \"12/AS\"",
        "matches": [
            "01/00",
            "12/99",
            "10/30",
            "10/21",
            "12/55",
            "02/85",
            "06/46",
            "10/11",
            "10/46",
            "12/34",
            "02/57",
            "06/47",
            "10/52"
        ],
        "non_matches": [
            "13/00",
            "12/AS",
            "123/124",
            "432/5135/1",
            "123.1351",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/24",
            "9/9/9",
            "92/90"
        ],
        "id": 120,
        "output": [
            {
                "text": " (\\d{1,2}/\\d{2,2})\n\nExercise 4:\nWrite a regular expression to match a string that starts with a lowercase letter followed by three uppercase letters, and ends with a"
            },
            {
                "text": " \n[0-1][0-9][0-9][0-9][0-9]/[0-9][0-9][0-9][0-9][0-9]|[0-1"
            },
            {
                "text": " ^(0|1)\\d/\\d{2}$\n\n- \"12/01\" generates a RegEx for this description. \nAnswer: ^(0|1)\\d/\\d{2}$\n\n"
            },
            {
                "text": "\n[1-9]\\d{2}/\\d{2}\n\nA:\n\nA proper regex to check if the date contains 1-9 digits, a single / character, at least 2 digits after the / and"
            },
            {
                "text": " [01-9][0-9][0-9][0-9][0-9]\n\nExercise 6: Email Validation\nExercise: Write a RegEx to validate an email address. The email address should have the"
            },
            {
                "text": " (?i)^\\d{2}\\/\\d{2}$\n- \"02/29\"\n- \"03/01\"\n- \"03/02\"\n- \"04/06\"\n- \"04/"
            },
            {
                "text": "\n[0-9]{1,2}/[0-9]{2,3}\n\n5. Match an email that is in the correct format, using regular expressions. \nEmail example:\n\"My email is"
            },
            {
                "text": " \n\\d{1,2}\\/\\d{1,2}\n\n# Exercise 2 \nWrite a regular expression for the following description:\n\nA date in the format: dd/mm/yyyy\n\nAnswer"
            },
            {
                "text": " \n/(\\d{1,2})\\s*\\/\\s*(\\d{1,2})$/gm\n\nA:\n\nTo match MM/YY or 12/99, use\n^\\d{1"
            },
            {
                "text": " \"0/1[1-9]$|1/2[0-9]$|11/12\n\n1. Given a string, check whether it contains at least one occurrence of the word \u201cis\u201d. If"
            }
        ]
    },
    {
        "expression": "^([0-9]{2})?(\\([0-9]{2})\\)([0-9]{3}|[0-9]{4})-[0-9]{4}$",
        "raw_prompt": "A simple expression to brazilian phone number code, with international code.\nSimple DDI without &quot;+&quot; 99 plus simple DDD (99) plus simple local phone number 3 or 4 digits plus &quot;-&quot; plus 4 digits.",
        "refined_prompt": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)232-3232\"",
        "matches": [
            "55(21)123-4567",
            "(11)1234-5678",
            "55(71)4562-2234",
            "87(37)790-8395",
            "(14)7637-0089",
            "06(10)5683-0265",
            "(17)730-8237",
            "(11)416-7050",
            "19(96)4663-8089",
            "28(23)0153-6864",
            "52(18)651-3567",
            "(21)157-5399",
            "47(71)362-9412"
        ],
        "non_matches": [
            "3434-3432",
            "4(23)232-3232",
            "55(2)232-232",
            "12/123/4322",
            "(234)423425",
            "243234()2342340",
            "()234234",
            "(423)42309243",
            "($32)524308",
            "+434234(4234)",
            "23=4234-98324",
            "24302348-23489(13)"
        ],
        "id": 123,
        "output": [
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)45"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)345"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)345"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)432"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)45"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)34"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)13"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)34"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)345"
            },
            {
                "text": "This regular expression is designed to match Brazilian phone numbers that include an international dialing code (DDI) without the plus sign, a simple area code (DDD) enclosed in parentheses, a simple local phone number consisting of either 3 or 4 digits, followed by a hyphen, and finally, a 4-digit extension.\nMatch examples:\n- \"55(21)123-4567\"\n- \"(11)1234-5678\"\n- \"55(71)4562-2234\"\nNon-match examples:\n- \"3434-3432\"\n- \"4(23)12"
            }
        ]
    },
    {
        "expression": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*))+\\.(txt|TXT)$",
        "raw_prompt": "This RE validates a path/file of type txt (text file)\nThis RE can be used as a filter on certain file types, while insuring the entire string is a fully qualified path and file. The filter value can be changed or added to as you need",
        "refined_prompt": "This RE validates a path/file of type txt (text file), while insuring the entire string is a fully qualified path and file.\nMatch examples:\n- \"c:\\file.txt\"\n- \"c:\\folder\\sub folder\\file.txt\"\n- \"\\\\network\\folder\\file.txt\"\nNon-match examples:\n- \"C:\"\n- \"C:\\file.xls\"",
        "matches": [
            "c:\\file.txt",
            "c:\\folder\\sub folder\\file.txt",
            "\\\\network\\folder\\file.txt",
            "c:\\adsf.txt",
            "c:\\ghaf.txt",
            "c:\\tqre.txt",
            "d:\\agsha.txt",
            "d:\\dasf\\fasd.txt",
            "d:\\firqewle.txt",
            "e:\\folder\\sub folder\\test.txt",
            "e:\\gad\\afds\\sub folder\\file.txt",
            "e:\\folder\\sub aafs\\file.txt",
            "e:\\folder\\subafdfolder\\file.txt"
        ],
        "non_matches": [
            "C:",
            "C:\\file.xls",
            "folder.txt",
            "akfd.jp",
            "fafds.jpg",
            "abc.png",
            "fasdfa.tst",
            "sfdarq123.txt",
            "asdf.vsw",
            "wersdf.txu",
            "fsda.twe",
            "rwe.ter"
        ],
        "id": 125,
        "output": [
            {
                "text": " C:.*/.*\n\n2. Match a filename with the same extension, but with a more strict format (example"
            },
            {
                "text": "\n[^\\\\]*\\/(?:[a-zA-Z0-9]+)$;\n\n"
            },
            {
                "text": "\n#!/usr/bin/env python3\n\nimport sys\nimport re\n\npath_or_file ="
            },
            {
                "text": "\n\n\\w+(\\.txt|\\.xls|\\.pdf|\\.docx): a file of any of the"
            },
            {
                "text": " C:\\file\\.txt\n- \"\\\\network\\folder\\file.txt\"Generate a RegEx for this description"
            },
            {
                "text": "\nvar regex = new RegExp('^([a-zA-Z0-9])([\\:\\/"
            },
            {
                "text": " C:\\file(.txt)\n\nExercise 2:\nWrite a Python program that validates an email address ("
            },
            {
                "text": " C:\\[^\\s]+$\n\nA:\n\nI am not sure why you are using such a convoluted"
            },
            {
                "text": "\n(?<!\\\\)(?:(?:\\\\\\.)+\\.)(?!\\.)|(?<!"
            },
            {
                "text": "\n(?:\\\\[a-zA-Z0-9-_\\.]*)+\n\nThank you for"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+([a-zA-Z0-9\\-\\.]+)?\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "raw_prompt": "Checks domain names. This is an attempt to deal with some of the issues of the other reg ex in not handling leading periods(.) and hypens(-).",
        "refined_prompt": "Used to validate domain names that start with alphanumeric characters, may contain additional alphanumeric characters, hyphens, and periods in the middle (optionally), and end with one of the specified TLDs (case-insensitive).\nMatch examples:\n- \"my.domain.com\"\n- \"regexlib.com\"\n- \"big-reg.com\"\nNon-match examples:\n- \".mydomain.com\"\n- \"regexlib.comm\"",
        "matches": [
            "my.domain.com",
            "regexlib.com",
            "big-reg.com",
            "x7E6vd6bn9lVKV0UvDZjDca14Pxfd42DQ2ue7A3KP.org",
            "F60CAbjTaI28WV4APmn.ORG",
            "4ozPd3VhUT4UbPSxAd74tdnSKlPE.org",
            "br9Gf5bwzVWg3SvjGO2N0A7ZXVf1Ex.net",
            "3MOHUK1ssVZ.ORG",
            "biF.com",
            "Ov4M1oQuzhAwsHOpx6Rm.edu",
            "eMxw3wFMwZHeGv7pR6IX4Xwxi6MbKTmSxKgedUn9h0fFLD.U0pwr4yV7dInK5frNbyRghfA0IkWKsTg.edu",
            "LaYx5MdIy4pGlJ.com",
            "ZDbQ57LlDzhRbUVeK4zPc.EDU"
        ],
        "non_matches": [
            ".mydomain.com",
            "regexlib.comm",
            "-bigreg.com",
            "afdsaf.adijs",
            "a.cdsaca.cas",
            "43.v234",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "notredame.github",
            "99999@gmail"
        ],
        "id": 126,
        "output": [
            {
                "text": " The email address should match the following expression: ^[a"
            },
            {
                "text": "\nThis exercise is subjective, as there are many valid ways"
            },
            {
                "text": "\n\n```python\nimport re\n\n# Create"
            },
            {
                "text": " regex: \\b[a-z0-9]"
            },
            {
                "text": "\n^\\w+\\.\\w+[-a"
            },
            {
                "text": " r\"^[a-zA-Z0-"
            },
            {
                "text": " /^[a-z0-9](\\.["
            },
            {
                "text": " (?i)(?<![a-zA"
            },
            {
                "text": " ([a-zA-Z0-9-]"
            },
            {
                "text": " \n^[a-zA-Z0-"
            }
        ]
    },
    {
        "expression": "^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$",
        "raw_prompt": "This matches floating point expression in a more rigorous way - accepts both exponent as well as non exponent notations.",
        "refined_prompt": "Matches numbers that can be positive or negative, may have a decimal point, and can be in scientific notation format\nMatch examples:\n- \"123\"\n- \"-123.35\"\n- \"-123.35e-2\"\nNon-match examples:\n- \"abc\"\n- \"123.32e\"",
        "matches": [
            "123",
            "-123.35",
            "-123.35e-2",
            "41",
            "1432",
            "512",
            "123",
            "77680628136.7552098e982",
            "+76780107092975139",
            "+7678023024785.3e-19982",
            "275189806858986728960918281818983794084608877641099649684838072428225393435789.38e05143381004",
            "-432.52",
            "2e10"
        ],
        "non_matches": [
            "abc",
            "123.32e",
            "123.32.3",
            "12/123/4322",
            "51:534",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "34.31ee",
            "12/132/90"
        ],
        "id": 127,
        "output": [
            {
                "text": " [A-Za-z0-9]+[\\.]?[0-9]+(e[+-]?[0-9])?\n\n3. Match strings that start with a capital letter and end"
            },
            {
                "text": " (\\d+\\.\\d+|\\d+)\n\nExercise 2:\nMatch numbers that are separated by spaces, have a decimal point, and no scientific notation format.\nMatch examples:\n- \"10."
            },
            {
                "text": " \"abc|-123.32e\"\n\nExercise 5: Generate a RegEx for this description.\nA date value must be in the format YYYY-MM-DD and can be valid for any day"
            },
            {
                "text": " The non-match example is the only one.\n\nExercise 3: Given the string \"ABC\", generate a regular expression to match the string \"A\" or \"B\" or \"C\".\nAnswer: The RegEx"
            },
            {
                "text": " \n\n```python\nimport re\n\n# Regular Expression to match a string that can be positive or negative, may have a decimal point, and can be in scientific notation format\nregex = r'^-?"
            },
            {
                "text": " \"^[a-zA-Z0-9]+$\"\n\n\n\nTitle: A Comprehensive Guide to Comparison: Cheap and Expensive\n\nIntroduction:\n\nWelcome to this comprehensive guide on comparison between cheap and"
            },
            {
                "text": " ^[a-zA-Z-0-9\\.]+$ \n\nExamples (no questions, just declarative statements):\n- A phone number should start with a \"+1\" or \"1\"\n"
            },
            {
                "text": " This RegEx will match positive, negative or decimal numbers.\n\nExercise 5: \nMatch numbers that can be negative or positive, have more than 2 digits, and can be in scientific notation format\nMatch examples:\n"
            },
            {
                "text": " (\\\\d+)[^-\\\\d.] \n\n3. Match numbers that can be positive or negative, have decimal points, and are in scientific notation format. \nMatch examples:\n- \"123.35e"
            },
            {
                "text": " Match any positive or negative number that is a decimal number with up to three decimal places.\n\n\n\nTitle: Explaining the Marvels of Math, Time, and Money: Currency Conversion\n\nIntroduction:\nGreetings,"
            }
        ]
    },
    {
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "raw_prompt": "Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.",
        "refined_prompt": "Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"",
        "matches": [
            "1:01 AM",
            "23:52:01",
            "03.24.36 AM",
            "01.12",
            "1.44PM",
            "10.17.53 am",
            "14.51:24",
            "03.34",
            "07:45.39PM",
            "02:43 aM",
            "23.58",
            "4:21PM",
            "17.50:18"
        ],
        "non_matches": [
            "19:31 AM",
            "9:9 PM",
            "25:60:61",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "/5/5/5",
            "254627g.256",
            "123:234:234",
            "12:60:423",
            "999:999:999",
            "12/132/90"
        ],
        "id": 132,
        "output": [
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: (\\d\\d?:\\d\\d?:\\d\\d?"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer:\nThis RegEx will match 24 hour times and 12 hour times with AM or"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: \n1:1:1:1:0:0:0:"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: (?i)(?:\\d{1,2}\\:\\d{2"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer:\n^((0|(1|[2-9][0-9"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer:\n[0-9]{1,2}\\:[0-9]"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer:\n/(0|1|2|3|4|5|6|"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: \n^(\\d{1,2}(:\\d{1,"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: ^[0-5][1-9] (?:AM|PM)?"
            },
            {
                "text": "Matches times seperated by either : or. will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required.\nMatch examples:\n- \"1:01 AM\"\n- \"23:52:01\"\n- \"03.24.36 AM\"\nNon-match examples:\n- \"19:31 AM\"\n- \"9:9 PM\"Generate a RegEx for this description. \nAnswer: /^(0[1-9]|1[0-2])"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\s.\\-_']+$",
        "raw_prompt": "Alphanumeric, hyphen apostrophe, comma dash spaces",
        "refined_prompt": "Match strings that consist of alphanumeric characters, spaces, periods (dots), hyphens, underscores, and single quotation marks.\nMatch examples:\n- \"dony d'gsa\"\n- \"adsfaq9\"\n- \"f231v3\"\nNon-match examples:\n- \"^[a-zA-Z0-9\\s.\\-_']+$\"\n- \"+SDF4324$#*\"",
        "matches": [
            "dony d'gsa",
            "adsfaq9",
            "f231v3",
            "f34v2f3",
            "f3v2f4",
            "vad.adsfv",
            "adfq3_fvs",
            "fdsv.sd_",
            "q34",
            "g4b3w...",
            "54_ sfdg",
            "dfsg-gsdf_",
            "avaf_fewav"
        ],
        "non_matches": [
            "^[a-zA-Z0-9\\s.\\-_']+$",
            "+SDF4324$#*",
            "%$@$#+342",
            "%$(*#(%+24dfsv",
            "^&*",
            "#@$",
            "($@*#$+#$%",
            "3548345$@+#$",
            "+@!#$#",
            "*$(#@%",
            "*%&$*($#`",
            "$~#@$$"
        ],
        "id": 133,
        "output": [
            {
                "text": " ^(SDF4324(SDF4324)?)$\n\n\n\n"
            },
            {
                "text": "\n\"SDF4324[a-zA-Z0-9_.-"
            },
            {
                "text": " ^[a-zA-Z0-9\\s.\\-_']+"
            },
            {
                "text": " \"^[a-zA-Z0-9\\s.\\-_']"
            },
            {
                "text": " ^[a-zA-Z0-9\\s.\\-_-]*"
            },
            {
                "text": " ^[a-zA-Z0-9\\s.\\-_']+"
            },
            {
                "text": " [a-zA-Z0-9\\s.\\-_']+\n"
            },
            {
                "text": " ^[a-zA-Z0-9\\s.\\-_']+"
            },
            {
                "text": " ^[a-zA-Z0-9\\s.\\-_']+"
            },
            {
                "text": " [a-zA-Z0-9_\\s.]*$\n\n"
            }
        ]
    },
    {
        "expression": "^\\d{0,2}(\\.\\d{1,2})?$",
        "raw_prompt": "This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal.",
        "refined_prompt": "This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal.\nMatch examples:\n- \"99.99\"\n- \"99\"\n- \".99\"\nNon-match examples:\n- \"999.999\"\n- \"999\"",
        "matches": [
            "99.99",
            "99",
            ".99",
            "1",
            "78",
            "12",
            "9.2",
            "4.0",
            "8.1",
            "8.64",
            "76",
            "19.9",
            "86"
        ],
        "non_matches": [
            "999.999",
            "999",
            ".999",
            "-123",
            "234",
            "123",
            "-312",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "34.31141",
            "32542"
        ],
        "id": 139,
        "output": [
            {
                "text": " \\d{1,2}(\\.\\d{1,2})?\n\nExercise 2:\n\nWrite a Python program that takes a URL as input and extracts the domain name from it using"
            },
            {
                "text": " ^[0-9]\\.[0-9]{2}$\n\n5. Write a regular expression that will search for all email addresses that match the format \"first.last@domain.com"
            },
            {
                "text": " \\d{1,3}\\.?\\d{1,3}\n\n**Exercise 3**\n\nGenerate a RegEx that validates that the email entered is a valid email address."
            },
            {
                "text": " ^[0-9,]+ \\.?[0-9]?$\n3. Given a string of data, extract all email addresses.\nExample: \"Hi there, my email is john@"
            },
            {
                "text": " \n^\\d+\\.(\\d+)\\.(\\d+)?$\nA RegEx for this description is [01]?\\d?\\d\\d[^.]\\d?"
            },
            {
                "text": " [^0-9.]{0,2}.[0-9.]{0,2}\n- \"999..99\"\n\nExercise 5: Write a regular expression to validate that a string"
            },
            {
                "text": " (\\d{1,2}\\.?\\d{1,2}|\\d{1,2}\\.?\\d{1,2})\n\n3. Extract all the URLs from"
            },
            {
                "text": "\npattern = \"^[1-9]\\d{0,2}\\.\\d{0,2}$|^[1-9]\\d{1,2}\\.\\d"
            },
            {
                "text": " ^\\d\\d\\d[.,]\\d\\d\\d$\n\n### Exercise 5:\nCreate a Python function that takes a string and uses regular expressions to remove all the specified characters."
            },
            {
                "text": "\n([\\d\\-.]+[\\d]+)\nExample:\n\"99.99\" => ([\\d\\-.]+[\\d]+)\n\nA:\n\nYou can use the"
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$",
        "raw_prompt": "This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.",
        "refined_prompt": "This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45:67:89:Az\"",
        "matches": [
            "01:23:45:67:89:ab",
            "01:23:45:67:89:AB",
            "fE:dC:bA:98:76:54",
            "44:4a:8F:Af:52:Ca",
            "74:30:F2:Ad:AB:05",
            "a7:b6:e8:2F:Aa:08",
            "Cb:26:29:03:c8:dC",
            "D5:dc:86:7f:De:E2",
            "E5:88:9f:cb:5E:4D",
            "6C:F1:ff:D5:CD:2D",
            "57:cB:aC:DF:1b:79",
            "2e:5b:cA:8c:6b:7A",
            "BD:D4:0b:D5:5d:e0"
        ],
        "non_matches": [
            "01:23:45:67:89:ab:cd",
            "01:23:45:67:89:Az",
            "01:23:45:56:",
            "12/123/4322",
            "51:534",
            "243:234:423:5234",
            "53426:525234",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "2434:542:523:2345",
            "12/132/90"
        ],
        "id": 141,
        "output": [
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            },
            {
                "text": "This will grep for a valid MAC address, with colons seperating octets. It will ignore strings too short or long, or with invalid characters. It will accept mixed case hexadecimal. Use extended grep.\nMatch examples:\n- \"01:23:45:67:89:ab\"\n- \"01:23:45:67:89:AB\"\n- \"fE:dC:bA:98:76:54\"\nNon-match examples:\n- \"01:23:45:67:89:ab:cd\"\n- \"01:23:45"
            }
        ]
    },
    {
        "expression": "^100$|^[0-9]{1,2}$|^[0-9]{1,2}\\,[0-9]{1,3}$",
        "raw_prompt": "Percentage with 3 number after comma.",
        "refined_prompt": "This regular expression can match three different patterns:\r\n\r\nThe exact string \"100.\"\r\nOne or two-digit numbers.\r\nNumbers in a specific format with one or two digits, a comma, and one to three digits.\nMatch examples:\n- \"12,654\"\n- \"1,987\"\n- \"43,582\"\nNon-match examples:\n- \"128,2\"\n- \"12,\"",
        "matches": [
            "12,654",
            "1,987",
            "43,582",
            "59,582",
            "2,582",
            "52,482",
            "59,749",
            "58,960",
            "4,683",
            "53",
            "54",
            "9",
            "1"
        ],
        "non_matches": [
            "128,2",
            "12,",
            "453,5345,534",
            "534,345,345,453,25",
            ",54325,45",
            "534,2,5",
            "54,35,235",
            "543,536,43",
            "5,43,634,534",
            "5,43,5345,43",
            "534,534,6345,,35",
            "54,3534"
        ],
        "id": 142,
        "output": [
            {
                "text": " \"^\\d+,\\d+$\"\n\r\n```python\r\nimport re\r\n"
            },
            {
                "text": " \\d{0,2},\\d{0,3}\r\n\r\nQuestion 9:\r"
            },
            {
                "text": " ^\\d+,\\d+$\r\n\r\n\r\n2. Match numbers with the following pattern"
            },
            {
                "text": " (\\d{1,2}(,\\d{1,3})?)\r\n- \""
            },
            {
                "text": " RegEx: [1-9][0-9]*/[0-9]+\n- \"12"
            },
            {
                "text": " \r\n[1-9][0-9]*(,[0-9]{1,"
            },
            {
                "text": " [^a-zA-Z0-9.,]*\r\n\r\nThis regular expression will"
            },
            {
                "text": " \"([1-9][0-9]|1[0-2])[,]\\d"
            },
            {
                "text": " (\\d,\\d), (\\d\\d)\n\r\nI hope this section helped you"
            },
            {
                "text": " (?<![0-9])\\d,\\d(?![0-9])\r"
            }
        ]
    },
    {
        "expression": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)$",
        "raw_prompt": "Correct French DateTime(DD/MM/YYYY OR DD/MM/YYYY HH:MM:SS)",
        "refined_prompt": "Correct French DateTime(DD/MM/YYYY OR DD/MM/YYYY HH:MM:SS)\nMatch examples:\n- \"12/01/2002\"\n- \"12/01/2002 12:32:10\"\n- \"30/04/2089\"\nNon-match examples:\n- \"32/12/2002\"\n- \"12/13/2001\"",
        "matches": [
            "12/01/2002",
            "12/01/2002 12:32:10",
            "30/04/2089",
            "01/06/2051\u168011:45:19",
            "31/01/2040\u200321:52:00",
            "30/10/2064 23:22:41",
            "30/11/2022",
            "27/11/2043",
            "30/11/2061",
            "14/05/2075",
            "31/11/2038",
            "23/10/2062\u200811:38:00",
            "30/12/2041"
        ],
        "non_matches": [
            "32/12/2002",
            "12/13/2001",
            "12/02/06",
            "12/123/4322",
            "234/423/5243",
            "2/3/52355",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/95341",
            "12/132/90"
        ],
        "id": 143,
        "output": [
            {
                "text": " match either 12/01/2002 or 30/04/2089. \n\nExercise 2:\n- Write a Python function that takes"
            },
            {
                "text": " The RegEx for this description is [DD/MM/YYYY| DD/MM/YYYY HH:MM:SS]\n\nEx"
            },
            {
                "text": "\n[A-Z][a-z]{3}[0-9][0-9][0-9]\\s?["
            },
            {
                "text": "\n\n(4). Which of these can be used to describe a group of words?\nA)  (4). Which of these can be"
            },
            {
                "text": "\n\\d{2}\\/\\d{2}\\/\\d{4} or \\d{2}/\\d{2}"
            },
            {
                "text": " \"^[23][0-9][0-9]/[12][0-9][0-9]/[02][0"
            },
            {
                "text": " dd/mm/yyyy|dd/mm/yyyy HH:mm:SS\n\nExercise 3:\nReplace all matches of"
            },
            {
                "text": " (^|\\s)^[0-1]\\d[0-9]{2}$\n- \"5/12/"
            },
            {
                "text": " This can be done by using the pattern `^[A-Z][a-z]*[0-9]{1,2}"
            },
            {
                "text": " \n[0-9]{2}\\/[0-9]{2}\\/[0-9]{4} | ["
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]\\.)+([a-zA-Z0-9]{3,5})$",
        "raw_prompt": "Host/Domain name validation for perl.\nShould be combined with a check for\nlength &lt;= 63 characters and that $2\nis in a list of top-level domains.",
        "refined_prompt": "Matches domain names with subdomains and enforces certain rules such as starting and ending with alphanumeric characters, allowing hyphens in subdomains, and specifying a TLD with 3 to 5 characters.\nMatch examples:\n- \"freshmeat.net\"\n- \"123.com\"\n- \"TempLate-toolkKt.orG\"\nNon-match examples:\n- \"-dog.com\"\n- \"?boy.net\"",
        "matches": [
            "freshmeat.net",
            "123.com",
            "TempLate-toolkKt.orG",
            "baidu.com",
            "kugou.com",
            "google.com",
            "ads.com",
            "apple.com",
            "openai.com",
            "nd.edu",
            "app.net",
            "happy.org",
            "handsome.org"
        ],
        "non_matches": [
            "-dog.com",
            "?boy.net",
            "this.domain",
            "cqerc.9j9jafds",
            "sfalijad234",
            "3nf@.afdsgadsf",
            "@#dfkjnav.agffe",
            "%jfkdlddf@#FD",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 145,
        "output": [
            {
                "text": " ^(([a-zA-Z0-9]|[a-z"
            },
            {
                "text": " \"^[a-zA-Z0-9.]+$\"\n\n"
            },
            {
                "text": " [^\\W\\d_.-] matches any alphanumeric character except for punct"
            },
            {
                "text": " a. -(?<!\\.)\\w+\\-\\w+\\.com"
            },
            {
                "text": " Match examples can be generated by using the \"^[a-zA-Z0"
            },
            {
                "text": " \n\n\"^[a-zA-Z0-9-]+("
            },
            {
                "text": "\n\n```python\nimport re\n\nexample_1 = \"freshmeat."
            },
            {
                "text": " \n(?i)\\b(?=\\w+\\.\\w+\\"
            },
            {
                "text": " ^(?=.{3,20}$)([a-z0-"
            },
            {
                "text": " This description should match domains that begin with alphanumeric characters, allow underscores, and end"
            }
        ]
    },
    {
        "expression": "^[^']*$",
        "raw_prompt": "This one matches all strings that do not contain the single quotation mark (').",
        "refined_prompt": "This one matches all strings that do not contain the single quotation mark (').\nMatch examples:\n- \"asljas\"\n- \"%/&amp;89uhuhadjkh\"\n- \"&quot;hi there!&quot;\"\nNon-match examples:\n- \"'hi there!'\"\n- \"It's 9 o'clock\"",
        "matches": [
            "asljas",
            "%/&amp;89uhuhadjkh",
            "&quot;hi there!&quot;",
            "fqqea",
            "dF(D*SHF*f",
            "3443gb",
            "45bgb45g",
            "b4b5b*G&&USDF",
            "dsg$#R",
            "FSDF#@FW#F",
            "f#4f$#F",
            "$F#$FFSDfsdew",
            "fewf&*("
        ],
        "non_matches": [
            "'hi there!'",
            "It's 9 o'clock",
            "'''''",
            "dhjggh'hdsfj",
            "jkljasdlkj09'afds",
            "'fdsa'fad'fdas",
            "fds'ajsdlk",
            "'fdskalj'lkfa9'FADSKFDA",
            "FDSA'FJDIS(*&$F",
            "'DSFAFJ*(FDS'FDSA",
            "DFJSL'98DF'FSDIO",
            "JSDLKF'SDF''FDS''FS"
        ],
        "id": 146,
        "output": [
            {
                "text": " [0-9]{1,2} [pP]?m?s?\\s?[0-9]{1,2} [pP]?m?s"
            },
            {
                "text": " [^']\\w+'\nExplanation: This pattern matches anything that is not a single quote (').\n\nExercise 2: Replace all non-alphanumeric characters in a"
            },
            {
                "text": " (\\w+)(\\s\\w+)\nThis one matches all strings that do not contain the single quotation mark (').\nMatch examples:\n- \"asljas\"\n- \"%"
            },
            {
                "text": " [^']* (no single quote)\n\nExercise 4: Match all strings that contain at least one uppercase letter and one lowercase letter.\nAnswer: [a-z"
            },
            {
                "text": " [^q']\n\n3. Write a RegEx to find dates in the format of MM-DD-YYYY.\nAnswer: \\d{2}-\\d{2}"
            },
            {
                "text": "\n[\"\"]?[^']+\"\"|[^'\"]+\n\nExercise 4: Write a RegEx to match all words that start with a capital letter.\nAnswer:\n"
            },
            {
                "text": " [^']+[^']+\nExplanation: This pattern matches a string that contains one or more non-quotation-mark characters one or more times.\n\n2. Match"
            },
            {
                "text": " (^|\\s)\\w+$\n\nExercise 3:\nCreate a RegEx for this description.\n\nMatch examples:\n- \"a\"\n- \"b\"\n"
            },
            {
                "text": " (?<!\\(|\\))?[a-zA-Z0-9]+'(?!\\))?\"\n\nExercise:\n- \"I am a 'ro"
            },
            {
                "text": " (.*)\n- %/&amp;89uhuhadjkh\nAnswer: (.*)\n\n4. Write a Python Regex code snippet that will match all email addresses. Email"
            }
        ]
    },
    {
        "expression": "^([1-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$",
        "raw_prompt": "This validates a number between 1 and 255. Could be modified to IP, or just to verify a number in a range.",
        "refined_prompt": "Validates a number between 1 and 255.\nMatch examples:\n- \"1\"\n- \"108\"\n- \"255\"\nNon-match examples:\n- \"01\"\n- \"256\"",
        "matches": [
            "1",
            "108",
            "255",
            "142",
            "151",
            "124",
            "165",
            "45",
            "85",
            "75",
            "36",
            "218",
            "215"
        ],
        "non_matches": [
            "01",
            "256",
            "534798",
            "0948",
            "54390",
            "54398",
            "9393",
            "-432",
            "324df",
            "1-1-2",
            "9/9/9",
            "12/132/90"
        ],
        "id": 147,
        "output": [
            {
                "text": " \"^[1-9]?[0-9]$\"\n\n3. Match if a user's email ends with a certain string of characters. \nMatch examples:\n- \"test@test.com\"\n- \"test@test.com.\"\n- \"test@test.com-\"\nNon-match examples:"
            },
            {
                "text": "  \\d{1,2}|\\d{3,5}\n\nExercise 2: Create a RegEx for the following scenarios:\na. Match the following words in a sentence: \"dog,\" \"cat,\" \"horse\"\nb. Match the email addresses in the following list: \"john@example.com,\" \""
            },
            {
                "text": " The pattern should be \"(?<!\\d)\\d{1,3}(?!\\d)\", which means \"A character that is not a digit or a digit followed by a digit, between 1 and 3 times, followed by a digit that is not a digit\"\n\nExercise 3:\n- \"1-2-3-"
            },
            {
                "text": " ^[1-9][0-9]?$\n\nExercise 3:\nMatch examples:\n- \"1\". Starts with a digit\n- \"0\". Starts with a non-digit\n- \"1\"Followed by exactly one digit\n- \"10\". Followed by exactly one digit\n- \"01\". Followed"
            },
            {
                "text": " /^[1-9][0-9]*$/\n\n```python\nimport re\ndef validate(val):\n\tif re.match(pattern, val):\n\t\treturn True\n\telse:\n\t\treturn False\n\ndef get_pattern(valid):\n\tpattern = \"/^\" + \"\".join"
            },
            {
                "text": " \"1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]\"\n\n3. Write a function that takes the following list and returns a new list with all the numbers between 2 and 10 (inclusive)"
            },
            {
                "text": " \\d\\d\\d\\d\n\nExercise 2: \nWrite a RegEx to match the start of a line with a word\nMatch examples:\n- \"Hello\"\n- \"Hello\"\n- \"Hello World\"\nNon-match examples:\n- \"Hello\"\n- \"Hello World\"\nAnswer: ^"
            },
            {
                "text": " [a-zA-Z0-9][0-9]{1,2}[a-zA-Z0-9]\n\nExercise 3: Write a Python function that takes a string and replaces all occurrences of the word \"not\" with \"happy\". \nAnswer: \nimport re\ndef replace_"
            },
            {
                "text": "\n\\b\\d{0,2}\\.\\d{0,2}\\.\\d{0,2}\\b\n\nExample 2:\nScenario: John is a programmer and he wants to implement a password that is at least 8 characters long, contains at least one uppercase letter, one lowercase letter, and one"
            },
            {
                "text": "\n[1-9]\\d| 1[0-9]|2[0-8]\n\nI hope this post has helped you understand how to use regular expressions in Python to validate numbers. Remember, knowing how to validate numbers is important in many real-life situations, such as financial transactions, data validation, and more. Happy"
            }
        ]
    },
    {
        "expression": "^[0-9](\\.[0-9]+)?$",
        "raw_prompt": "matches non-negative decimal floating points numbers less than 10",
        "refined_prompt": "Matches non-negative decimal floating points numbers less than 10\nMatch examples:\n- \"1.2345\"\n- \"0.00001\"\n- \"7\"\nNon-match examples:\n- \"12.2\"\n- \"1.10.1\"",
        "matches": [
            "1.2345",
            "0.00001",
            "7",
            "1",
            "6",
            "9",
            "6.7",
            "5.854",
            "9.563",
            "4.4875",
            "8.4657",
            "3.654373",
            "7.37654"
        ],
        "non_matches": [
            "12.2",
            "1.10.1",
            "15.98",
            "-123",
            "234",
            "123",
            "-312",
            "12f3.21f3.213f",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "534534.94534"
        ],
        "id": 149,
        "output": [
            {
                "text": " match examples: \"1\\.2\", \"0\\.1\", \"7\", non-match examples: \"12.2\", \"1.10.1\".\n\n\n\n\n# Chapter: The use of Built in Functions for Web Scraping Specialist\n## Section"
            },
            {
                "text": " [0-9]{0,2}.[0-9]{0,2}.[0-9]{0,2}.[0-9]{0,2}.[0-9]{0,2}.[0-9]{"
            },
            {
                "text": " The pattern should match both.\n\n3. Replace all non-alphanumeric characters in a string with a space\nAnswer:\nimport re\nstr1 = \"Hello, World!!\"\nnew_str = re.sub(r'\\W+',' ', str"
            },
            {
                "text": " A simple RegEx statement is \\d+\\.\\d+\n\n3. Write a Python program to replace all occurrences of \"cat\" with \"dog\" in the given string using RegEx.\nAnswer:  `import re`\n`string = \"I have"
            },
            {
                "text": " \\d+\\.\\d+\n\nExercise 2: Create a regular expression for string that starts with a number, followed by at least three alphabetical characters, followed by a comma and then any number of numeric characters. Ensure that the first letter of the string is a"
            },
            {
                "text": " Match examples: \\b(0\\.){3}\\d+\\b Match examples: \\b(1\\.\\.){3}\\d+\\b Match examples: \\b(1\\.){3}\\d+\\b Match examples: \\b(1"
            },
            {
                "text": " You can use the pattern `r'^\\d+\\.\\d+$'` for this requirement.\n\n3. Write a Python program to match all the words that begin with the letter \"p\" or \"P\" in a given string.\nAnswer:"
            },
            {
                "text": "\n- ^(?:-?[0-9]+(?:\\.0+)?)(?:[eE][+-]?[0-9]+)?(?:i)?$\n\nExercise 3: Lookahead assertion\nLookahead assertion is a zero"
            },
            {
                "text": " \n\\d+(?:\\.\\d+)?|.\\d+\nExample: \n\n4dgj\n4(0|2|4|6|8|10|12)\n\n\n\n\n## Subsections:\n\n1"
            },
            {
                "text": " ^[0-9]*\\.[0-9]*[0-9]$\n\n##### Exercise 2\n\nGenerate a RegEx for this description.\n\nMatch any string of lowercase characters that contains one or more uppercase characters."
            }
        ]
    },
    {
        "expression": "^((((31\\/(0?[13578]|1[02]))|((29|30)\\/(0?[1,3-9]|1[0-2])))\\/(1[6-9]|[2-9]\\d)?\\d{2})|(29\\/0?2\\/(((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))|(0?[1-9]|1\\d|2[0-8])\\/((0?[1-9])|(1[0-2]))\\/((1[6-9]|[2-9]\\d)?\\d{2})) (20|21|22|23|[0-1]?\\d):[0-5]?\\d:[0-5]?\\d$",
        "raw_prompt": "this expression validates a date-time field in European d/m/y h:m:s format. It is a european variation of Michael Ash's date-validation expression in this library.\nThe days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/04 20:15:15\"",
        "matches": [
            "29/02/2004 20:15:27",
            "29/2/04 8:9:5",
            "31/3/2004 9:20:17",
            "12/12/10 23:5:58",
            "30/6/6805 22:11:01",
            "31/3/1840 22:15:28",
            "29/2/8400 21:8:46",
            "31/01/9934 20:45:5",
            "30/12/4789 20:09:27",
            "29/02/12 22:7:58",
            "02/02/3840 22:2:30",
            "06/11/52 21:5:00",
            "13/11/96 23:29:23"
        ],
        "non_matches": [
            "29/02/2003 20:15:15",
            "2/29/04 20:15:15",
            "31/3/4 9:20:17",
            "29/02/17098 21:14:19",
            "28/29/41 20:1:5",
            "29/02/65 07:05:8",
            "25/010/9758 5:04:40",
            "29/2/281 23:2:8",
            "31/12/18155 21:9:36",
            "29/2/1600 21:6:99",
            "17/06/54 89:9:6",
            "29/2/28 22:98:4"
        ],
        "id": 153,
        "output": [
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2003"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2003"
            },
            {
                "text": "This expression validates a date-time field in European d/m/y h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"29/02/2004 20:15:27\"\n- \"29/2/04 8:9:5\"\n- \"31/3/2004 9:20:17\"\nNon-match examples:\n- \"29/02/2003 20:15:15\"\n- \"2/29/2004"
            }
        ]
    },
    {
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,3})?$",
        "raw_prompt": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.",
        "refined_prompt": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point.\nMatch examples:\n- \"1\"\n- \"12345.123\"\n- \"0.5\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "1",
            "12345.123",
            "0.5",
            "2",
            "3",
            "33098",
            "3.280",
            "619.8",
            "6388.09",
            "25461.784",
            "91",
            "152.485",
            "25461.784"
        ],
        "non_matches": [
            "0",
            "0.0",
            "123456.1234",
            "45.456123",
            "486.8945624895",
            "98456124856.54",
            "0.000",
            "0.0000000",
            "000.000",
            "354/243/542",
            "34.315412",
            "12/132/90"
        ],
        "id": 156,
        "output": [
            {
                "text": " ^(?:\\d[1-9]?\\d|\\d|\\d\\d\\d)\\.?(?:\\d[1-9]?\\d|\\d|\\d\\d\\d"
            },
            {
                "text": " \\d{1,5}\\.?\n\nThese exercises help you to understand the applications of RegEx. You can use them to validate data before processing, extract information from strings, and much more.\n\nBlog Post:"
            },
            {
                "text": " ^[0-9]{1,6}$\n\nExercise 2:\nWrite a regular expression to validate email addresses.\nAnswer:\n^[A-Za-z0-9._%+-]+"
            },
            {
                "text": " [0-9]{0,5}|[0-9][0-9][0-9]\nUse case 2: Identifying Valid Email Addresses\nYou're writing a script to identify valid email addresses. Write"
            },
            {
                "text": " 0[0-9]{1,2}(.[0-9]{1,2})?\n\n**Exercise 2**\n\nValidate a number with 6 or more digits.\n\nMatch examples:\n"
            },
            {
                "text": " ^\\d+\\.\\d{3}$\n\nExercise 2: Using RegEx to Clean a String\nGiven a string of text, use a regular expression to remove any text that is not a number or a period."
            },
            {
                "text": " ^[0-9]{1,5}(?:\\.[0-9]{1,3})?$\n\n3. Create a RegEx to match the following string:\n\"The quick brown fox jumped over"
            },
            {
                "text": "\n^[1-9][0-9]?[0-9]?\\.?[0-9]?[0-9]?[0-9]?[0-9]?$\n\n3"
            },
            {
                "text": "\n^[0-9\\.]{0,5}$\n\nExercise 3: \nScenario: You receive a file path from a user that needs to be validated using Regular Expressions. Create a regular expression that"
            },
            {
                "text": " (^0|\\d[1-9]\\d*|[1-9]\\d\\d(\\.\\d{0,3})?)$\n\nExercise 4: \nUsing the code from Exercise"
            }
        ]
    },
    {
        "expression": "@{2}((\\S)+)@{2}",
        "raw_prompt": "This will match results in a template situation. For example:\ntemplate reads\nDear @@Name@@,\n....\nwould become\nDear John,\nIf you dont want to use the @@ change the @ to what ever characters you want.",
        "refined_prompt": "This regular expression matches and captures any text enclosed by two consecutive \"@\" symbols, where the enclosed text consists of one or more non-whitespace characters. Spaces inside the enclosed text are not allowed for a match.\nMatch examples:\n- \"@@test@@\"\n- \"@@name@@\"\n- \"@@2342@@\"\nNon-match examples:\n- \"@test@\"\n- \"@@na me@@\"",
        "matches": [
            "@@test@@",
            "@@name@@",
            "@@2342@@",
            "@@sjdfkl@@",
            "@@09fjdo@@",
            "@@09fojdkms@@",
            "@@fjlsk09@@",
            "@@$)(@@",
            "@@ifdsjo@@",
            "@@90jgdf0g9jf0@@",
            "@@65416546@@",
            "@@986512huijkn@@",
            "@@56853@@"
        ],
        "non_matches": [
            "@test@",
            "@@na me@@",
            "@@ name@@",
            "@@fdiushj iofsdkj@@",
            "@@Oivjk af ajasdh !!@@",
            "@@Oifsd fsijdk @@",
            "@@.  @@@",
            "jikfdl@ JFLKDSJ@ JKDFS@@",
            "qwerty@123.123",
            "@hfu8dij89hi@",
            "@)IJKNOVDF@",
            "@JIOFKDJOI@"
        ],
        "id": 158,
        "output": [
            {
                "text": " (?<=@)[^\\s]+@(?=\\S)\nHere, look-behind is used"
            },
            {
                "text": " \\S+,*\\S+\n\nExercise 3:\nWrite a Python code that extracts the domainname from the"
            },
            {
                "text": "\n\"@@(.*?)@@\"\n\n3. Write a Regular Expression to match any string that is composed of only"
            },
            {
                "text": "\n\nimport re\nprint(re.match(r\"(\\S+)@@(\\S+)@@(\\S+)\","
            },
            {
                "text": "\n```python\nimport re\n\n#Example of a regular expression pattern:\nregex_pattern = r'"
            },
            {
                "text": "\nimport re\ntext = \"@@test@@\"\nregex = \"@@(.+)(@@|$)\""
            },
            {
                "text": " [^@\\s]+(@@\\s+\\w+\\s+@@)\nExercise 2: "
            },
            {
                "text": " (optional)\nimport re\n\ndef test_case(name):\n    return re.findall(r\"("
            },
            {
                "text": "\n```python\nimport re\n\nstring = \"@@test@@\" #This should be a match\npattern ="
            },
            {
                "text": " \\b@(?:[^\\s]|\\s)+@@\\b\nI have no idea how to make"
            }
        ]
    },
    {
        "expression": "[A-Z][a-z]+",
        "raw_prompt": "This expression was developed to match the Title cased words within a Camel cased variable name. So it will match 'First' and 'Name' within 'strFirstName'.",
        "refined_prompt": "This regular expression matches one or more consecutive letters in a string, where the first letter is uppercase (A-Z) and the subsequent letters are lowercase (a-z).\nMatch examples:\n- \"strFirstName\"\n- \"intAgeInYears\"\n- \"Where the Wild Things Are\"\nNon-match examples:\n- \"123\"\n- \"abc\"",
        "matches": [
            "strFirstName",
            "intAgeInYears",
            "Where the Wild Things Are",
            "fdsklAfsdj",
            "sfdkjAfdsjo",
            "dfsjoijAfodisdn",
            "nfijgOiusdf",
            "knjdsEfosidj",
            "jksdfnYfidso",
            "vbmnWihuh",
            "ifdUfsjido",
            "bhvUfsjido",
            "jiofdsUfs"
        ],
        "non_matches": [
            "123",
            "abc",
            "this has no caps in it",
            "ifojd",
            "oifjd",
            "kgodf",
            "ngfjdn2039r",
            "ijok",
            "432/524/2435",
            "com.edu.github",
            "abc111def",
            "99999@gmail"
        ],
        "id": 161,
        "output": [
            {
                "text": " [A-Za-z]\n\nExercise 3: Write a RegEx for matching a phone number in the format (123) 456-78"
            },
            {
                "text": " ^[a-z][A-Za-z0-9]*$\n\nExercise 3:\nUse a RegEx to find all the"
            },
            {
                "text": " The RegEx to generate would be ^[A-Z][a-z]+$\n\nExercise 2: Write a Python function that takes a string of"
            },
            {
                "text": " \"^([a-z])([A-Z][a-z]*)(.*)$\"\n\nExercise 4: Rewrite the following"
            },
            {
                "text": " \n\\b([A-Z][a-z]*)\n\nScenario 2:\nYour company has developed a new app and you want to improve"
            },
            {
                "text": " \nimport re\n#Regex to match a string containing the word \"the\" in uppercase\nre.search(r\"The[a-"
            },
            {
                "text": "\n[A-Z][a-z]\n\n2. Generate a RegEx for this pattern: The date is MM/DD/YYYY."
            },
            {
                "text": " /\\d+/\n\n3. Write a Python script that counts the number of times a word appears in a given string, ignoring case. For example,"
            },
            {
                "text": " strFirstName|intAgeInYears|Where the Wild Things Are.\n\nExercise 2:\nCreate a regular expression to match a string in the format"
            },
            {
                "text": " \n\nI need to generate a regular expression to match a string that starts with uppercase letters, followed by digits, then uppercase letters, then"
            }
        ]
    },
    {
        "expression": "^[+-]?([0-9]*\\.?[0-9]+|[0-9]+\\.?[0-9]*)([eE][+-]?[0-9]+)?$",
        "raw_prompt": "A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form.",
        "refined_prompt": "A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form.\nMatch examples:\n- \"23\"\n- \"-17.e23\"\n- \"+.23e+2\"\nNon-match examples:\n- \"+.e2\"\n- \"23.17.5\"",
        "matches": [
            "23",
            "-17.e23",
            "+.23e+2",
            "312",
            "784639",
            "+423",
            "-234798",
            "+324.234",
            "-234.243",
            "432",
            "4987.42",
            "-2423",
            "0"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0",
            "12/123/4322",
            "234/423/5243",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "354/243/542",
            "9/9/9",
            "++63453.345"
        ],
        "id": 162,
        "output": [
            {
                "text": " (\\d*)\\.(\\d+\\.\\d+)e(\\+|-)(\\d*)\n\nExercise 2: \nDetermine whether the following words and phrases contain a digit or an exponential sign.\n-"
            },
            {
                "text": "\n(?<!e)\\.(?<!\\.)\\+\\.(?<!\\.)\\d+(\\.\\d+)?(e|E)(?!\\.)\n\nExercise 2: Create a RegEx"
            },
            {
                "text": " This is a non-matching expression because an integer or decimal number with or without the exponential form can be written without the exponential form. \n\nExercise 4: Rewrite the following exponential expressions to match the RegEx:\n"
            },
            {
                "text": " This regular expression will match any number that does not have an exponential form:\n\n```python\nimport re\n\ntext = \"23.17.5\"\npattern = r\"^[0-9]+$\"\n"
            },
            {
                "text": " (\\d+\\.*\\d*\\.\\d+|\\d+)\n3. Write the RegEx for the description \"a string containing any number of upper or lower case letters, digits, and spaces\".\nAnswer:"
            },
            {
                "text": " \\d+\\.?[0-9]+?e?[0-9]*\n\nExercise 2:\nDefine a function named \"parseFloat\" that takes a string as input and returns a list of the digits"
            },
            {
                "text": " r'(?<![-+e.])(?<![-+e.0-9])[-+]?\\d+(?:\\.\\d+)?[eE]?[-+]?\\d*"
            },
            {
                "text": "\n\\d+(\\.\\d+)?e?\\d+\nExamples:\n- 23\n- -17.e23\n- +0.23e+2\nNon-match examples:\n-.\n- 23"
            },
            {
                "text": "\n(?<=^|\\.)[0-9]+(\\.[0-9]+)?(?=$|\\.)\n\n3. Create a RegEx that matches strings that contain one or more digits, and two"
            },
            {
                "text": "\n^\\+?[0-9]+\\.?[0-9]*e?[0-9]+(\\.[0-9]+)?$\n\nExercise 2: \nA regular expression that matches dates"
            }
        ]
    },
    {
        "expression": "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})",
        "raw_prompt": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:\n$date = &quot;2003-12-03&quot;;\nif (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs))\n{\necho &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003\n}",
        "refined_prompt": "This regular expression is used to validate and capture data that follows the specific pattern of dates in the YYYY-MM-DD format(could also be single M or single D), where each component is represented by digits.\nMatch examples:\n- \"2002-11-03\"\n- \"2007-17-08\"\n- \"9999-99-99\"\nNon-match examples:\n- \"2002/17/18\"\n- \"2002.18.45\"",
        "matches": [
            "2002-11-03",
            "2007-17-08",
            "9999-99-99",
            "3245-35-4",
            "1639-9-7",
            "7086-8-76",
            "6204-6-5",
            "1506-78-1",
            "4609-76-6",
            "0837-03-3",
            "7018-59-67",
            "5888-2-5",
            "9104-82-3"
        ],
        "non_matches": [
            "2002/17/18",
            "2002.18.45",
            "18.45.2002",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/956123",
            "12/132/90"
        ],
        "id": 169,
        "output": [
            {
                "text": " YYYY-MM-DD|YYYY|YYY-MM"
            },
            {
                "text": " (The correct regex is [0-9]{4}-[0"
            },
            {
                "text": " ^[0-9]{4}-[0-9]{"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{"
            },
            {
                "text": " /([0-9]{4})([0-9]"
            },
            {
                "text": "\nYou can try the following pattern:\n(?=[A-Z"
            },
            {
                "text": "\npattern = r\"\\d{4}-(\\d{2"
            },
            {
                "text": " (^|[^\\d.])(\\d{4}-"
            },
            {
                "text": " The pattern would be something like: (?:\\d{4}-"
            },
            {
                "text": "\n(?<![0-9])(?<!["
            }
        ]
    },
    {
        "expression": "^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$",
        "raw_prompt": "This matches an IP address, putting each number in its own group that can be retrieved by number. If you do not care about capturing the numbers, then you can make this shorter by putting everything after ^ until immediately after the first \\. in a group ( ) with a {3} after it. Then put the number matching regex in once more.\nIt only permits numbers in the range 0-255.",
        "refined_prompt": "This matches an IP address, putting each number in its own group that can be retrieved by number. It only permits numbers in the range 0-255.\nMatch examples:\n- \"0.0.0.0\"\n- \"255.255.255.02\"\n- \"192.168.0.136\"\nNon-match examples:\n- \"256.1.3.4\"\n- \"023.44.33.22\"",
        "matches": [
            "0.0.0.0",
            "255.255.255.02",
            "192.168.0.136",
            "255.48.254.51",
            "207.44.252.62",
            "251.105.231.237",
            "162.255.255.250",
            "255.141.207.148",
            "165.207.209.253",
            "208.145.16.255",
            "154.107.247.176",
            "250.118.209.223",
            "254.64.74.50"
        ],
        "non_matches": [
            "256.1.3.4",
            "023.44.33.22",
            "10.57.98.23.",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "2565.48.254.51",
            "207.464.252.62",
            "251.1075.231.237",
            "162.2455.255.250",
            "255.141.207.1488",
            "165.207.2049.253"
        ],
        "id": 170,
        "output": [
            {
                "text": " ^[0-9]+.[0-9]+.[0-9]+.[0-"
            },
            {
                "text": ".*\\.[\\d\\.]+\\.[\\d\\.]+\\.[\\"
            },
            {
                "text": " r\"(?<![\\d\\.])(\\d{2})(?!["
            },
            {
                "text": " ^[0-9]{1,3}\\..[0-9]{1"
            },
            {
                "text": "\n^[0-9\\.\\.]+$\n\nPart 2:\n\nDesc"
            },
            {
                "text": " \n^(?:\\d{1,2}\\.){3}\\d{1"
            },
            {
                "text": "\n/^(?:\\d{1,3}\\.\\d{1,3"
            },
            {
                "text": " In this case, the RegEx should be \"^[0-9][0-9"
            },
            {
                "text": "\n([0-9]{0,3}\\.){3}[0-9"
            },
            {
                "text": " /^\\[0-9]{1,3}.{1,3}.{"
            }
        ]
    },
    {
        "expression": "^\\$?([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$",
        "raw_prompt": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them. This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and .0 Keywords: money dollar currency",
        "refined_prompt": "This regular expression is used to validate and capture monetary values, including both whole numbers and decimal values, with optional commas as thousands separators and an optional dollar sign at the beginning.\nMatch examples:\n- \"$1,234.50\"\n- \"$0.70\"\n- \".7\"\nNon-match examples:\n- \"$0,123.50\"\n- \"$00.5\"",
        "matches": [
            "$1,234.50",
            "$0.70",
            ".7",
            "$56",
            "$456123",
            "$7",
            "$7845",
            "$79",
            "$100",
            "$0.78",
            "$1.19",
            "$43.78",
            "$54.32"
        ],
        "non_matches": [
            "$0,123.50",
            "$00.5",
            "$645123.4561",
            "$4561.$9856",
            "$4561.4561",
            "$89456.541",
            "$897.8946",
            "$98.456",
            "$000.000",
            "$8495.4895162",
            "$Y*(UHIJKN",
            "$Jioklmfds"
        ],
        "id": 172,
        "output": [
            {
                "text": "\n[\\d,]+(\\.[\\d]{1,3})?\n\nExercise 2:\nCreate a regular expression to match"
            },
            {
                "text": "\n\\$([0-9]+(,[0-9]+(\\.[0-9]+)?)?)\n\n3. Exercise:\n"
            },
            {
                "text": " (\\d*)\\.(\\d+)\n\nExercise 3:\nWrite a Python script that performs the following tasks:\n- Validates a"
            },
            {
                "text": "\n[0-9]+(.[0-9]+)?\"|[0-9]+\nThis regular expression is used to validate and capture monetary"
            },
            {
                "text": " ((\\$\\d+\\,\\d+(.)\\d*)?|\\.)\n\nExercise 2:\nReplace all non-"
            },
            {
                "text": " \\d+(?:,\\d*)?\\,.\\d*\n\nExercise 2:\n\nWrite a Python code that uses RegEx to"
            },
            {
                "text": "\n(?<value>[1-9][0-9]*)?(?<comma>[,]?)?(?<$)("
            },
            {
                "text": "\n\\d*\\,?[\\d.]+\\d*\n\nExercise 2:\nWrite a RegEx to match email addresses separated"
            },
            {
                "text": " ^(?:\\d(?:,\\d*)?|\\d+)((?:\\.\\d{2})?|\\d+)"
            },
            {
                "text": " [\\d,\\.]+\n\nExercise 5: Write a RegEx pattern to match email addresses\nGiven: [\"john.doe@"
            }
        ]
    },
    {
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))-((0[1-9])|(1[0-2])))|((31-((0[13578])|(1[02])))|((29|30)-((0[1,3-9])|(1[0-2])))))-((20[0-9][0-9]))|(29-02-20(([02468][048])|([13579][26]))))$",
        "raw_prompt": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.",
        "refined_prompt": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year.\nMatch examples:\n- \"05-01-2002\"\n- \"29-02-2004\"\n- \"31-12-2002\"\nNon-match examples:\n- \"1-1-02\"\n- \"29-02-2002\"",
        "matches": [
            "05-01-2002",
            "29-02-2004",
            "31-12-2002",
            "29-02-2052",
            "29-02-2008",
            "31-03-2079",
            "29-02-2016",
            "29-02-2040",
            "26-03-2049",
            "22-12-2096",
            "24-12-2082",
            "29-10-2053",
            "30-01-2027"
        ],
        "non_matches": [
            "1-1-02",
            "29-02-2002",
            "31-11-2002",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 173,
        "output": [
            {
                "text": "\n^\\d{2}-\\d{2}-\\d{4}$\n\nExercise 5:\nGenerate a RegEx"
            },
            {
                "text": " \n(?<month>\\d{2}-\\d{2}-\\d{4})(?<year>\\d{"
            },
            {
                "text": " ^[12]\\d{3}-\\d{2}-\\d{4}$\n2. Write a RegEx to check if"
            },
            {
                "text": "\n\n[0-9]{2}\\-[0-9]{2}\\-[0-9]{4}\n\n\n\nQuestion 1"
            },
            {
                "text": "\n    from re import compile \n   \n    def date_format(date): \n        regex = re.compile(\"([0-"
            },
            {
                "text": " dd-mm-yyyy|dd-mm-yy\n\n3. Write a regular expression that validates a phone number in the format \"+XXX-"
            },
            {
                "text": " The date pattern must be of the form dd-mm-yyyy, where dd is a two digit number between 01 and 31, and mm and yyy"
            },
            {
                "text": " \n\nimport re\n\n# Define the pattern\npattern = r\"\\d{2}-\\d{2}-\\d{"
            },
            {
                "text": " \"^(0[1-9]|1[012])-[0-3][0-9]-([0-9]{4})$"
            },
            {
                "text": " \n\\d+-\\d-\\d+\n\nExercise 2:\nCreate a regex pattern to validate an email address. This includes checking"
            }
        ]
    },
    {
        "expression": "^\\d*[0-9](|.\\d*[0-9]|,\\d*[0-9])?$",
        "raw_prompt": "This is permit all decimal number, exclude all alphanumeric caracter",
        "refined_prompt": "This regular expression is used to validate decimal numbers that can have an optional leading zero, at least one digit before and after the decimal point (if present), and may allow for either a dot or comma as a decimal separator. Excludes all alphanumeric character\nMatch examples:\n- \"123456.123456\"\n- \"123456,123456\"\n- \"123456\"\nNon-match examples:\n- \"123a.123\"\n- \"123a,123\"",
        "matches": [
            "123456.123456",
            "123456,123456",
            "123456",
            "48651.498653",
            "48.94865",
            "489561",
            "4856.48956",
            "651.89456",
            "465.4651",
            "798.498",
            "48.1",
            "456.64865",
            "12315"
        ],
        "non_matches": [
            "123a.123",
            "123a,123",
            "a",
            "2rf",
            "8561hui",
            "huiy8hiu",
            "6r5tfy",
            "09iop",
            "78yui",
            "65rtfy9hiu",
            "0u9ioj5dr",
            "6tfy"
        ],
        "id": 174,
        "output": [
            {
                "text": " ^[0-9a-zA-Z],"
            },
            {
                "text": " \\d+\\.?\\d\n\nExercise 2"
            },
            {
                "text": " You should generate a RegEx with the following pattern: \\"
            },
            {
                "text": " (\\d\\w+?)\\.(\\d+)"
            },
            {
                "text": " \nvar regex = /^\\d+,?\\"
            },
            {
                "text": "\n^(?=.*[a-zA-"
            },
            {
                "text": "\n\\b[0-9]{1,9"
            },
            {
                "text": "\n\\d{1,5}((\\.\\d"
            },
            {
                "text": " [a-zA-Z0-9]*"
            },
            {
                "text": " ^[1-9][0-9]*("
            }
        ]
    },
    {
        "expression": "^([A-Z]{1,2}[0-9]{1,2}|[A-Z]{3}|[A-Z]{1,2}[0-9][A-Z])( |-)[0-9][A-Z]{2}",
        "raw_prompt": "Checks whether the string specified is in the same format as the UK postcode format defined on:\nhttp://www.magma.ca/~djcl/postcd.txt\nIt allows:\nA = Letter\nN = Number\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\n(restriction is set to all-capitals)",
        "refined_prompt": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1AA\"\n- \"A11-1AA\"\nNon-match examples:\n- \"111 AAA\"\n- \"1AAA 1AA\"",
        "matches": [
            "AA11 1AA",
            "AA1A 1AA",
            "A11-1AA",
            "RL9Z-9QZ",
            "YDV 2UK",
            "VLL-5YA",
            "XVZ 9MZ",
            "QIC 5VM",
            "E9L-5SC",
            "HQB-7LD",
            "AH3T-6QM",
            "TVB-3SB",
            "FQ0D-1KX"
        ],
        "non_matches": [
            "111 AAA",
            "1AAA 1AA",
            "A1AA 1AA",
            "12/123/4322",
            "sfalijad234",
            "FSDA23R 223RR",
            "23RE2",
            "R2E2R3",
            "R32 FE FE2 2E",
            "F2E3 F2F2 DF",
            "FSG- FD3 D. F3D",
            "F33 E"
        ],
        "id": 176,
        "output": [
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 11"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 11"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1"
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A\""
            },
            {
                "text": "Checks whether the string specified is in the same format as the UK postcode format.\r\nIt allows:\r\nA = Letter\r\nN = Number\r\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\r\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\r\n(restriction is set to all-capitals)\nMatch examples:\n- \"AA11 1AA\"\n- \"AA1A 1"
            }
        ]
    },
    {
        "expression": "<img([^>]*[^/])>",
        "raw_prompt": "Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.",
        "refined_prompt": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*gTm.e+>\"\nNon-match examples:\n- \"<img fq3f3/>\"\n- \"<img3/>frf\"",
        "matches": [
            "<img src=\"bob\">",
            "<img%(\"]jCkOZt=1uT_Rl>",
            "<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*gTm.e+>",
            "<imgZ!{kLm.L4;??2hErM1L0bu$t:Ju9IoTmJGMb LNHRZ9_>",
            "<img]g6OQ8.sV}Q+NGbG69ds`NAn\\KCBmRs>",
            "<img:O+/((3E|jka`>",
            "<img~'S[fwY$?V1X4<Gez0NW\\q7C6K7sPEY\"*98V; ]'>",
            "<imgfl;j#j'BG/hZ^\\JrrpY8e|1)d.&4<u!rf[w<\\}4~rV|^tiT\\RmpxFIPrA]T^YY~)jO[J#isCg861nDX>",
            "<imgY U']m_Ks1Ntyd7+W8-X\"O.Bj9t2J>",
            "<img3}b!^.6q`] IkGZmHz!]j:TE*3{6?=;X?\"'WiD<_DV4N^Jm]t->",
            "<imgo?5p%=&b6T:l,B}a[j;}$1\"*No(5/`.+?0CCw,]7X{*P-9rmzB=Rz?N,dtiM{VqHzXv3YU\"'3AQ_r>",
            "<imgU_w]O2Xg\"TK5@N'otO =K{X46R)8$h`^6W2oD| RDi#(!Kg%]-lgrLUE:QLNiAq<#nYTVX(n*#av>",
            "<img$NJJ++huA]g S\"jM_2FX-2zMA]z9)${k8^`q#(PXgpq>"
        ],
        "non_matches": [
            "<img fq3f3/>",
            "<img3/>frf",
            "<img src=dbfadsfb\" />",
            "<img srafdsb\" />",
            "<img 44src3=\"bfobf3\" />",
            "<img s43f34rcf\"3of\" />",
            "<img 3f4efad=\"bob\" />",
            "<img src=\"dsfda\" />",
            "<img sfadsfc=\"bafadsob\" />",
            "<iafdsf src=\"fadsfadafw\" />sd",
            "<imadsfadsf",
            "<iab\" />df"
        ],
        "id": 183,
        "output": [
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*-"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*]"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*]"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*%"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*="
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*D"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*&"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*-"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*z"
            },
            {
                "text": "This regular expression is used to match HTML <img> tags with any attributes, excluding self-closing tags (those ending with \"/>\"). Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\nMatch examples:\n- \"<img src=\"bob\">\"\n- \"<img%(\"]jCkOZt=1uT_Rl>\"\n- \"<imgDjxWWIdhH\\-rliK<p]/{rJ$\"X`N{C-/OS-z[*~"
            }
        ]
    },
    {
        "expression": "^((0?[1-9])|((1|2)[0-9])|30|31)$",
        "raw_prompt": "matches any day of\nmonth 0?1-31",
        "refined_prompt": "This regular expression is designed to match and validate day numbers within a month, allowing values from 1 to 31. It takes into account single-digit days (1-9), double-digit days (10-29), and specific values for the 30th and 31st days of a month.\nMatch examples:\n- \"01\"\n- \"12\"\n- \"31\"\nNon-match examples:\n- \"123\"\n- \"32\"",
        "matches": [
            "01",
            "12",
            "31",
            "02",
            "5",
            "7",
            "29",
            "09",
            "24",
            "27",
            "09",
            "16",
            "18"
        ],
        "non_matches": [
            "123",
            "32",
            "abc",
            "9786",
            "375",
            "312",
            "732",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "9/9/9",
            "12/132/90"
        ],
        "id": 184,
        "output": [
            {
                "text": " The regular expression is:\n^(0|1|2|3|4|5|6"
            },
            {
                "text": " A regular expression to match any value between 1 and 31 within a month. \n\nExercise 5"
            },
            {
                "text": " r'^0[1-9]|1[0-2]?[3-9"
            },
            {
                "text": " https://www.regular-expressions.info/month.html\n\n3. Designing a"
            },
            {
                "text": " \n\\d+\n\nExercise 2:\nGiven the following code snippet, modify it to"
            },
            {
                "text": " (\\d{1,2})(\\d{3})(\\d{1,3"
            },
            {
                "text": " [0-9]{1,2}\n\nUse Case 2: Capturing Email Addresses"
            },
            {
                "text": " \\d{1,2}(?:[-.]\\d{1,2})*/31"
            },
            {
                "text": " /^(0?[1-9]|1?[012])[0-9]"
            },
            {
                "text": " The regular expression is \"[012]\\d\\d\"\n\nExercise 5:\nCreate a"
            }
        ]
    },
    {
        "expression": "&lt;!--[\\s\\S]*?--&gt;",
        "raw_prompt": "Removes pesky comments and commented javascript from HTML",
        "refined_prompt": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"",
        "matches": [
            "&lt;!-- comments --&gt;",
            "&lt;!-- x = a &gt; b - 3 --&gt;",
            "&lt;!----&gt;",
            "&lt;!--:|5V\f~03bL\u2008\\EqBNWd8\u2007kVD\u2005bA\u000b\u200ad\u200aam\u00a0,\f\u2001~i}1l--&gt;",
            "&lt;!--E;!\u202f6:VZw[tv\\\u2029*aO7Q=^QAQ\u2001\u2006]a\fWy}2\u1680^{9iI:A@[,W]?J\u2006--&gt;",
            "&lt;!----&gt;",
            "&lt;!--|iTa\u2029v9r^\u2028\u2006al--&gt;",
            "&lt;!--\f~lP\u2028^c\u2002vXV]ZhZ[6\u2005\u2004s{97U\u2002:xE)\u3000\u3000f5#zfF0`L5g,\u180e'M!k H|\\4\u2003v\u1680eJE }\u2005J\u180eod8D+.~8ObRPZ6MUS,'.\ufeff@'/--&gt;",
            "&lt;!--:[(5B,H~rg!b_i--&gt;",
            "&lt;!--^t_@E{5\" ^m\u202fN\u2009A,\u2004\ufefft~n\u2006RE{EUUW,\u2005g 'T\u2029I:_=q\u205f+F,`JKa\u2009--&gt;",
            "&lt;!--K?1.j{--&gt;",
            "&lt;!--Ky1I?\u2002\u2005}?[[m-x$DV1M3\u2003Dh6fU--&gt;",
            "&lt;!--0\u1680|--&gt;"
        ],
        "non_matches": [
            "&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;",
            "f34fvfv",
            "34f2vf42e",
            "fasd@fds.fasd@",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "9/9/9",
            "++63453.345"
        ],
        "id": 185,
        "output": [
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx with"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx for"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx pattern"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx that"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx for"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx that"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx that"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx to"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx for"
            },
            {
                "text": "Effectively locate and extract HTML comments from a text or HTML document, including multi-line comments, while being non-greedy to avoid matching comments that span multiple comment blocks.\nMatch examples:\n- \"&lt;!-- comments --&gt;\"\n- \"&lt;!-- x = a &gt; b - 3 --&gt;\"\n- \"&lt;!----&gt;\"\nNon-match examples:\n- \"&lt;COMMENTS&gt;this is a comment&lt;/COMMENTS&gt;\"\n- \"f34fvfv\"Generate a RegEx that"
            }
        ]
    },
    {
        "expression": "^\\{?[a-fA-F\\d]{8}-([a-fA-F\\d]{4}-){3}[a-fA-F\\d]{12}\\}?$",
        "raw_prompt": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.",
        "refined_prompt": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0e400ad090Ac0300d00a0008ba0\"\n- \"f34fvfv\"",
        "matches": [
            "{e02ff0e4-00ad-090A-c030-0d00a0008ba0}",
            "e02ff0e4-00ad-090A-c030-0d00a0008ba0",
            "29BF7EaE-e661-BDcd-deBB-F9097812DFC6}",
            "f5cA4FEa-CCbF-dBad-cdCa-1BCbB4a6Ee8B}",
            "509ECac0-DB2A-a6C8-7CF6-189550d7f98b",
            "{05d00ef3-a644-bAbd-dEeB-1Dfa01BcbA6C}",
            "{45dEac1b-7865-c206-091c-fd0CF3a8b8cA}",
            "{5d5f787f-9Dcd-9a72-5906-2e0Bc134c5b4}",
            "Fdce4AFf-5085-0971-89d5-FaB0B19B68F6}",
            "D62ba90C-D5a8-ba2A-1214-a1D7A8a09D73}",
            "803f9Fa3-5eA4-3c89-68Ae-df01269e4A13}",
            "{4644867d-2Fa5-07D5-a8Ec-bb1cB4b1f6de}",
            "{6599E4d2-9fB8-9a6D-B0Cc-dd8eAB6959D4}"
        ],
        "non_matches": [
            "0xe02ff0e400ad090Ac0300d00a0008ba0",
            "f34fvfv",
            "34f2vf42e",
            "Mastercard",
            "234/423/5243",
            "43.v234",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 187,
        "output": [
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff\""
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            },
            {
                "text": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes.\nMatch examples:\n- \"{e02ff0e4-00ad-090A-c030-0d00a0008ba0}\"\n- \"e02ff0e4-00ad-090A-c030-0d00a0008ba0\"\n- \"29BF7EaE-e661-BDcd-deBB-F9097812DFC6}\"\nNon-match examples:\n- \"0xe02ff0"
            }
        ]
    },
    {
        "expression": "(\\d*)'*-*(\\d*)/*(\\d*)&quot;",
        "raw_prompt": "This regular expression is for parsing feet and inches measurements.",
        "refined_prompt": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"",
        "matches": [
            "5'-3/16&quot;",
            "1'-2&quot;",
            "5/16&quot;",
            "5'-3/16&quot;",
            "1'-3&quot;",
            "5/15&quot;",
            "5'-3/15&quot;",
            "2'-4&quot;",
            "7/14&quot;",
            "6'-3/14&quot;",
            "4'-3&quot;",
            "8/12&quot;",
            "7'-3/14&quot;"
        ],
        "non_matches": [
            "1 3/16",
            "52/2/54/245",
            "34f2vf42e",
            "-123",
            "2346-2345-2435",
            "2/3/5235",
            "@#dfkjnav",
            "98iojk",
            "u09nKLJG FSL",
            "(0xx12) 7256 2345154",
            "abc111def",
            "99999@gmail"
        ],
        "id": 191,
        "output": [
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx\n"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx pattern"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx from"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx Pattern"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx pattern"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx pattern"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx expression"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx object"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx Pattern"
            },
            {
                "text": "This regular expression can be used to parse and capture measurements in feet and inches, with optional symbols like apostrophes ('), hyphens (-), and forward slashes (/), as well as the denominator part (e.g., 16) of inches, and it ends with a double quotation mark (\").\nMatch examples:\n- \"5'-3/16&quot;\"\n- \"1'-2&quot;\"\n- \"5/16&quot;\"\nNon-match examples:\n- \"1 3/16\"\n- \"52/2/54/245\"Generate a RegEx Pattern"
            }
        ]
    },
    {
        "expression": "^(/w|/W|[^<>+?$%{}&])+$",
        "raw_prompt": "simple expression for excluding a given list of characters. simply change the contents of [^] to suite your needs. for example ^(/w|/W|[^&lt;&gt;])+$ would allow everything except the characters &lt; and &gt;.",
        "refined_prompt": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"",
        "matches": [
            "John Doe Sr.",
            "100 Elm St., Suite 25",
            "Valerie's Gift Shop",
            "wtrewrt",
            "terwtw",
            "fdgsy",
            "nfju7",
            "kuyk678",
            "jk7jkj",
            "42309ion",
            "23c2d",
            "c237mu78",
            "mk78m78"
        ],
        "non_matches": [
            "<h1>Hey</h1>",
            "<h1>adsfa</h1>",
            "<h1>Hgafdgqrey</h1>",
            "<h1>trebd</h1>",
            "<h2>HIUJKNFSDfsd</h2>",
            "<h2>adsga</h2>",
            "<h2>HIgfda24gSDfsd</h2>",
            "<h2>HgfdfdFSDfsd</h2>",
            "<h2>HIUregfSDfsd</h2>",
            "<h2>HIUJfaddSDad</h2>",
            "<h3>HIUJKNfsgFSDfsd</h3>",
            "<h3>HIUsd</h3>"
        ],
        "id": 192,
        "output": [
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for valid"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for these"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for a"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for a"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for detecting"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for HTML"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for this"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for this"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for the"
            },
            {
                "text": "This regular expression is used to validate strings that contain a mix of characters, including word characters (alphanumeric and underscores), non-word characters, and any characters that are not among a specific set of special characters often used in HTML and programming. It ensures that the string does not contain the specified special characters.\nMatch examples:\n- \"John Doe Sr.\"\n- \"100 Elm St., Suite 25\"\n- \"Valerie's Gift Shop\"\nNon-match examples:\n- \"<h1>Hey</h1>\"\n- \"<h1>adsfa</h1>\"Generate a RegEx for this"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{4})$",
        "raw_prompt": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long.\nMatch examples:\n- \"12/2002\"\n- \"11/1900\"\n- \"02/1977\"\nNon-match examples:\n- \"1/1977\"\n- \"00/000\"",
        "matches": [
            "12/2002",
            "11/1900",
            "02/1977",
            "08/3420",
            "08/0126",
            "12/5637",
            "11/2207",
            "07/4032",
            "08/9881",
            "04/1760",
            "12/3648",
            "03/3980",
            "11/2966"
        ],
        "non_matches": [
            "1/1977",
            "00/000",
            "15/2002",
            "12/44322",
            "423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "524/125",
            "243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 197,
        "output": [
            {
                "text": " ^[1-9][0-9]{3}/([12][0-9])$\n\n2. Write a regular expression to match an IP address in the form x.x"
            },
            {
                "text": " \n^(0[1-9]|[1-9]\\\\d|2[0-8]|29)[\\\\/](0[1-9]|[1-"
            },
            {
                "text": "\n[0-9]/[0-9]\n\n3. Write a regular expression to check if a phone number entered by a user is valid. A valid phone number should have 10 digits"
            },
            {
                "text": " \"^(\\\\d{1,2})(/\\\\d{4}$)\"\n\nExercise 2:\nCreate a regex that matches the following words: cat, dog, and bird"
            },
            {
                "text": " ^\\d{1,2}\\/\\d{4}$ \n- \"01/15/11\" \n- \"01/15/1\"\n\n### Advanced Regex"
            },
            {
                "text": " ^([1-9]([0-2][0-9]|[3][0-1])/([1-9][0-9]|0[1-9])\\"
            },
            {
                "text": " [1]^[0-9]\\d{1,2}$|[0-9]\\d{3}$\n\nExercise 2:\nMatch this pattern to a"
            },
            {
                "text": " [0-9]{2}/[0-9]{4}\n\n3. Write a regular expression that matches only lowercase letters, numbers and dots.\n- \"AbC"
            },
            {
                "text": " [0-9][0-9][0-9][0-9]|[0-9][0-9]\n\nExercise 3: \nWrite a regular expression to match"
            },
            {
                "text": " ^[0-9]{2}[0-2][0-9]$\n\nExercise 3:\nWrite a regular expression to match email addresses (form of a domain name)."
            }
        ]
    },
    {
        "expression": "^[A-Z]{2}[0-9]{6}[A-DFM]{1}$",
        "raw_prompt": "UK National Insurance Number (NINO) validation. (The following modifications have been made: Only A to D are permitted as the last letter, and all letters should be in uppercase. For temporary numbers F and M are permitted for female and male holders.)",
        "refined_prompt": "This regular expression pattern matches a string that starts with two uppercase letters, followed by six digits, and ends with one uppercase letter, where the last uppercase letter can be either A, B, C, D, F, or M.\nMatch examples:\n- \"AB123456D\"\n- \"AB123456F\"\n- \"AB123456M\"\nNon-match examples:\n- \"AB123456E\"\n- \"ab123456d\"",
        "matches": [
            "AB123456D",
            "AB123456F",
            "AB123456M",
            "WC814828B",
            "YH034681A",
            "EA644426C",
            "TT066542C",
            "XU041456F",
            "WN058798C",
            "FI196873F",
            "GW600487D",
            "JZ932005C",
            "AY600596M"
        ],
        "non_matches": [
            "AB123456E",
            "ab123456d",
            "34f2vf42e",
            "12/123/4322",
            "sfalijad234",
            "AB123456P",
            "AB123456Q",
            "AB123456R",
            "AB123456S",
            "AB123456a",
            "AB123456b",
            "AB123456c"
        ],
        "id": 202,
        "output": [
            {
                "text": " \"^[A-Z]{2}\\d{"
            },
            {
                "text": " A[A-F]{4}[B-"
            },
            {
                "text": " ^[A-Z]{2}[0-"
            },
            {
                "text": " Match the description above.\n\nExercise 4:\n"
            },
            {
                "text": " \"AB(1[A-Fa-f0-"
            },
            {
                "text": " [A-F][0-9]{6}"
            },
            {
                "text": "\n\"^[A-Z][A-Z]["
            },
            {
                "text": " (?=^[A-Z]{2}"
            },
            {
                "text": " ^[AB]\\d{6}[AB]"
            },
            {
                "text": " ^[A-Z][A-Z0-9"
            }
        ]
    },
    {
        "expression": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0-1]\\d|[2][0-3])(\\:[0-5]\\d){1,2})?$",
        "raw_prompt": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\nIt can validate date from 1600 to 2199.",
        "refined_prompt": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\nNon-match examples:\n- \"13/30/2002\"\n- \"01/12/1998 24:30\"",
        "matches": [
            "12/30/2002",
            "01/12/1998 13:30",
            "01/28/2002 22:35:00",
            "11/30/1760",
            "05/31/2140 00:11",
            "11/31/2015",
            "12/30/1644 22:10",
            "10/30/2184\u202812:39",
            "12/15/1973",
            "10/15/1607",
            "10/01/2053",
            "11/30/1609",
            "03/06/1632"
        ],
        "non_matches": [
            "13/30/2002",
            "01/12/1998 24:30",
            "01/28/2002 22:35:64",
            "12/123/4322",
            "234/423/5243 13:30",
            "2/3/5235",
            "/5/5/5 13:30",
            "/5/5/20022",
            "432/524/2435 22:35:00",
            "354/243/542",
            "9/9/2009 22:35:64",
            "12/132/90 22:35:00"
        ],
        "id": 204,
        "output": [
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n\n"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n\n"
            },
            {
                "text": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\r\nIt can validate date from 1600 to 2199.\nMatch examples:\n- \"12/30/2002\"\n- \"01/12/1998 13:30\"\n- \"01/28/2002 22:35:00\"\n-"
            }
        ]
    },
    {
        "expression": "^((0?[13578]|10|12)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1}))|(0?[2469]|11)(-|\\/)(([1-9])|(0[1-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((19)([2-9])(\\d{1})|(20)([01])(\\d{1})|([8901])(\\d{1})))$",
        "raw_prompt": "improved date validation M/D/YY or M/D/YYYY or MM/DD/YYYY or MM/DD/YY: 1/1/1920 through 12/31/2019; Feb 29 and 30 always allowed, deal with it",
        "refined_prompt": "Date validation M/D/YY or M/D/YYYY or MM/DD/YYYY or MM/DD/YY: 1/1/1920 through 12/31/2019; Feb 29 and 30 always allowed.\nMatch examples:\n- \"1/2/03\"\n- \"02/30/1999\"\n- \"3/04/00\"\nNon-match examples:\n- \"3/4/2020\"\n- \"3/4/1919\"",
        "matches": [
            "1/2/03",
            "02/30/1999",
            "3/04/00",
            "10/1/1967",
            "09/7/1985",
            "06/3/98",
            "10/3/2002",
            "2/06/2001",
            "10/2/17",
            "1/5/94",
            "10/07/96",
            "7/2/1967",
            "10/1/1967"
        ],
        "non_matches": [
            "3/4/2020",
            "3/4/1919",
            "4/31/2000",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 209,
        "output": [
            {
                "text": " \\d{2}[a-z]?\\"
            },
            {
                "text": " \\d{1,2}\\d{1,2"
            },
            {
                "text": "\n(?i)(?=.*\\d)(?"
            },
            {
                "text": "\n[0-9]{4}[-/"
            },
            {
                "text": " [0-9]{1,2}/["
            },
            {
                "text": "\n/^[0-9]/[0-"
            },
            {
                "text": " (^[0-9]+[-/.]?"
            },
            {
                "text": " /^\\d{1,2}/\\d"
            },
            {
                "text": " ^[1-1]?[0-9]"
            },
            {
                "text": " \\d/\\d/\\d(?=(\\"
            }
        ]
    },
    {
        "expression": "^(([0]?[1-9]|1[0-2])(:)([0-5][0-9]))$",
        "raw_prompt": "This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59. This is primarily for use with an AM/PM drop down list or radio button.",
        "refined_prompt": "This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59.\nMatch examples:\n- \"09:00\"\n- \"9:00\"\n- \"11:35\"\nNon-match examples:\n- \"13:00\"\n- \"9.00\"",
        "matches": [
            "09:00",
            "9:00",
            "11:35",
            "12:26",
            "9:39",
            "04:04",
            "09:22",
            "11:58",
            "5:50",
            "05:02",
            "12:02",
            "08:06",
            "12:54"
        ],
        "non_matches": [
            "13:00",
            "9.00",
            "6:60",
            "12:78",
            "9:97",
            "34:04",
            "6022",
            "121:58",
            "5.50",
            "05:545",
            "12:022",
            "342"
        ],
        "id": 211,
        "output": [
            {
                "text": " \"^[0-9]\\d:\\d[0-9]$\"\n\n4.\nWrite a RegEx pattern that matches a date in the format \"MM/DD/YYYY\".\nAnswer:"
            },
            {
                "text": " \\d{1,2}:\\d{2} (\\d{2})?(?:[.][0-9]{2})? (?:[.][0-9]{2})? ("
            },
            {
                "text": "\n(?P<hour>\\d{1,2}):(?P<minute>\\d{2})\n\nExercise 2:\nUsing the RegEx object created in Exercise 1, write a regular"
            },
            {
                "text": " ^0?[1-9]\\d|1[0-2]\\d|[14]\\d|[1][0-2]\\d|3[0-1]\\d|["
            },
            {
                "text": " \"0?[1-9][0-9]|100?[0-9]\n\n3. Write a RegEx to validate a date of birth in the format \"MM/DD/YYYY\"\n"
            },
            {
                "text": " ^(?P<hour>0?[1-9]):[0-5]?[0-9]?$\n\n4. Write a RegEx for a phone number with the format: {country}{"
            },
            {
                "text": " [0-9]{1,2}:\\d{1,2}(?:\\.\\d{1,2})?\"\n\nIn the above example, we're using the colon : to specify the range"
            },
            {
                "text": " \"^(0|1|2|3|4|5|6|7|8|9)?:[01]?[0-9]$\"\n\n5. Write a regular expression that matches phone numbers"
            },
            {
                "text": " [1-9]\\d?[0-9]:[0-5][0-9]\nI'm not sure what my regular expression should be...\nRegards\n\nA:\n\nThis is the"
            },
            {
                "text": " ^[1-9]\\d\\d:00$\n\n3. Write a regular expression to validate an email address.\n```\nimport re\n\nemail_pattern = r\"^[a-z"
            }
        ]
    },
    {
        "expression": "^ *(1[0-2]|[1-9]):[0-5][0-9] *(a|p|A|P)(m|M) *$",
        "raw_prompt": "validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm.",
        "refined_prompt": "Validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm.\nMatch examples:\n- \"12:00am\"\n- \"1:00 PM\"\n- \"12:59 pm\"\nNon-match examples:\n- \"0:00\"\n- \"0:01 am\"",
        "matches": [
            "12:00am",
            "1:00 PM",
            "12:59 pm",
            "3:41 Pm",
            "1:13 pM",
            "1:50 am",
            "10:50 pM",
            "11:05 am",
            "4:19 AM",
            "2:56 Am",
            "5:51 aM",
            "12:25 PM",
            "10:20 pM"
        ],
        "non_matches": [
            "0:00",
            "0:01 am",
            "13:00 pm",
            "15:52 am",
            "51:534",
            "$23.454",
            "19:94 pm",
            "12f3.21f3.213f",
            "245/524/12",
            "20:59 PM",
            "2:2 AAMM",
            "23:23:23 PM"
        ],
        "id": 212,
        "output": [
            {
                "text": " (?<hms>\\d+[ap]\\.?m) + (?:[ ]\\d{2}) \n- \"12:30\"Generate a"
            },
            {
                "text": "\n(^|[\\s])0?[0-9]?[0-9][.][0-9][:][1-9][0-9]["
            },
            {
                "text": " ^((1|2)\\d\\d[a-z]|3[0-1]):([0-5]\\d)(am|pm)$\n\n"
            },
            {
                "text": "\n- [01].*\n\n5. Write a Python program that reads a file containing phone numbers in the format 'XXX-XXX-XXXX'. Use RegEx to extract only"
            },
            {
                "text": " ([01]?[0-9]|2[0-3])[:.][0-9]{2}am|([01]?[0-9"
            },
            {
                "text": " match any time of day after 12:00am.\n\n3. Write a function that takes a string and a list of words and returns a list of all words that start with"
            },
            {
                "text": " (0) (0)\n\nExercise 6:\nWrite a function that takes a string of digits, and returns True if the string is a valid phone number (e."
            },
            {
                "text": " (3am|3p.m|3pm)\n\n3. Write a RegEx for a four-digit hexadecimal color code with optional spaces before and after"
            },
            {
                "text": " ^\\d{1,2}(?:\\:\\d{1,2})?(?:am|pm|a\\.m|a\\.p.m)$ "
            },
            {
                "text": "\n(^(0|1)\\d|((1[0-3]|2[0-3]):[0-5]\\d|[0-5"
            }
        ]
    },
    {
        "expression": "^([A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^$",
        "raw_prompt": "Matches up to three alphabet words separated by spaces with first alphabet character of each word uppercase. Also matches empty strings.",
        "refined_prompt": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"",
        "matches": [
            "Sacramento",
            "San Francisco",
            "San Luis Obispo",
            "Shuijkn",
            "Jgyubhj Ghi",
            "Osfdui Hihufsdj Gfsd",
            "Hello World",
            "Python Java",
            "This Is",
            "An Apple Abc",
            "Soink",
            "Jqwe",
            "Notre Dame"
        ],
        "non_matches": [
            "SanFrancisco",
            "SanLuisObispo",
            "San francisco",
            "fdsdfs",
            "fiodsk",
            "ijnkfsdf",
            "ijnkfds89ijINJFKDS",
            "hfionsjdijkiJNKFSDIJO",
            "hufdijsnhijh9ui",
            "dfijoij9jiFDS",
            "j9IFDS",
            "9jiFOD"
        ],
        "id": 217,
        "output": [
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            },
            {
                "text": "It matches strings that consist of one or more words, where each word starts with an uppercase letter followed by one or more lowercase letters. The words can be separated by spaces. It also matches an empty string. The expression allows for variations in the number of words, from one to three, each following the same pattern of an initial uppercase letter followed by lowercase letters.\nMatch examples:\n- \"Sacramento\"\n- \"San Francisco\"\n- \"San Luis Obispo\"\nNon-match examples:\n- \"SanFrancisco\"\n- \"SanLuisObispo\"\n"
            }
        ]
    },
    {
        "expression": "(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "raw_prompt": "Validates time in MySQL time format. 24 hour time colon seperated hours:minutes:seconds",
        "refined_prompt": "Used to validate time values in in MySQL time format, in the format \"hh:mm:ss\" where hours are in the range of 00-23, minutes and seconds are in the range of 00-59.\nMatch examples:\n- \"09:30:00\"\n- \"17:45:20\"\n- \"23:59:59\"\nNon-match examples:\n- \"24:00:00\"\n- \"79:987:8\"",
        "matches": [
            "09:30:00",
            "17:45:20",
            "23:59:59",
            "14:51:51",
            "20:27:20",
            "20:27:22",
            "22:33:43",
            "21:10:09",
            "07:25:31",
            "22:27:34",
            "05:48:08",
            "22:55:26",
            "23:42:57"
        ],
        "non_matches": [
            "24:00:00",
            "79:987:8",
            "98:27:20",
            "22:70:79",
            "21:87:09",
            "07:25:67",
            "97:27:34",
            "194:48:08",
            "22:978:26",
            "199:42:57",
            "21:84:58",
            "14:29:97"
        ],
        "id": 222,
        "output": [
            {
                "text": " (.*)_(?:[0-2][0-9]:[0"
            },
            {
                "text": " \n\n```python\nimport re\n\nmatch1 = re."
            },
            {
                "text": " \"^\\d{1,2}:\\d{2}:\\d"
            },
            {
                "text": "\n\n```python\nimport re\n\ntime = \"13:30"
            },
            {
                "text": " ^\\d{1,2}:\\d{2}:\\d{"
            },
            {
                "text": " ([0-9]{2}:\\d{2}):([0"
            },
            {
                "text": "\n```python\nimport re\n\nhour_pattern = r'\\"
            },
            {
                "text": "\n\n```python\nimport re\n\ntime_string = \"23"
            },
            {
                "text": " \\d{1,2}:\\d{2}:\\d{2"
            },
            {
                "text": "\n(?<hour>\\d{1,2}):(?"
            }
        ]
    },
    {
        "expression": "^((([0]?[1-9]|1[0-2])(:|\\.)(00|15|30|45)?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)(00|15|30|45)?))$",
        "raw_prompt": "This expression will allow a time value with 15 minute increments. It will not accept seconds. You can use either US time or Military time format.",
        "refined_prompt": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 00 to 23.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\nMatch examples:\n- \"1:00 PM\"\n- \"6:45 am\"\n- \"17:30\"\nNon-match examples:\n- \"4:32 am\"\n- \"5:30:00 am\"",
        "matches": [
            "1:00 PM",
            "6:45 am",
            "17:30",
            "11:15 Am",
            "18:15",
            "19:15",
            "05: PM",
            "22:30",
            "12:45 Am",
            "2:15AM",
            "03:15",
            "5:30",
            "11.30 am"
        ],
        "non_matches": [
            "4:32 am",
            "5:30:00 am",
            "17:01",
            "12/123/4322",
            "17:879",
            "466",
            "21:61",
            "14:26",
            "02:52 Am",
            "7:43 pM",
            "10.62 Pm",
            "21.33"
        ],
        "id": 223,
        "output": [
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            },
            {
                "text": "This regular expression matches two types of time formats:\r\n\r\n1. 12-hour clock format (hh:mm AM/PM or hh:mmam/pm):\r\n\r\nThe hour part can be a 1 or 2-digit number from 1 to 12.\r\nThe minute part can be empty or can be 00, 15, 30, or 45.\r\nIt can have a space followed by AM or PM (in any case variation) or am or pm (in any case variation).\r\n\r\n2. 24-hour clock format (hh:mm):\r\n\r\nThe hour part"
            }
        ]
    },
    {
        "expression": "(^-\\d*\\.?\\d*[1-9]+\\d*$)|(^-[1-9]+\\d*\\.\\d*$)",
        "raw_prompt": "Accepts only negative decimal values. Zero and positive numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.",
        "refined_prompt": "\nMatch examples:\n- \"-0.050\"\n- \"-5.000\"\n- \"-5\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "-0.050",
            "-5.000",
            "-5"
        ],
        "non_matches": [
            "0",
            "0.0",
            ".0"
        ],
        "id": 226,
        "output": [
            {
                "text": " r\"[^0-9]\\d{3}[^0-9]\\d{2}[^0-9]\\d{1}{3}(.|$)\"\n\n2. Write a Python program to match a float value within the range -10 to 10. \nAnswer: import re\nstring_1 = \""
            },
            {
                "text": " -\\d\\.\\d (at least one digit, a dot, a digit)\n\n2. Exercise: Create a RegEx for the following pattern: \"one|two|three\"\nAnswer: [one|two|three]\n\n3. Exercise: Match the following strings:\n- \"The sun is shining\"\n- \"The sun"
            },
            {
                "text": " [--0, -5, -5]\n\n3. Given the following string, use RegEx to generate a RegEx for this description.\n\"This is  a sample string.\"\n\nMatch examples:\n- \"-0\"\n- \"-1\"\n- \"-2\"\nNon-match examples:\n- \" \"\n- \".\""
            },
            {
                "text": " [0-9]+(?:\\.[0-9]+)+\n\nExercise 2: Write a program that takes a list of numbers and returns the average, max, min, and mode of the list.\nAnswer:\nimport statistics\ndef calculate_stats(numbers):\n    mean = statistics.mean(numbers)\n    max"
            },
            {
                "text": " \\d+\\.\\d+\n\n\n\nQuestion 1: A box contains 24 red balls, 36 blue balls, and 48 green balls. If a ball is chosen at random from the box, what is the probability that it is either red or blue?\n\nSolution:\nTo find the probability that a ball chosen at random from the box is either red"
            },
            {
                "text": " \"^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$\"\n- \"0,000\"Generate a RegEx for this description.\nAnswer: \"^0*[\\d,]*$\"\n- \" - 0.50\"Gener"
            },
            {
                "text": " [0]\n- \"0.000\"Generate a RegEx for this description. \nAnswer: [0]\n\n\n\nQuestion 4: A cyclist rides for 2 hours at a speed of 12 miles per hour. Then the cyclist rides for another 3 hours at a speed of 15 miles per hour. What is the total distance traveled by the cyclist"
            },
            {
                "text": "\na. _[0-9]\\.0_\nb. _[0-9]\\.0_\nc. _[0-9]_\nd. {0,2}\\.{0,2}\"\"\", template=text_template)\n\n\nwith open(f\"{args.output}/{name}.txt\","
            },
            {
                "text": " a regex for the first one would be \"-^\\d+\\.\\d+$\"\n\nI hope you enjoyed this introduction to math, data analysis, and RegEx. Remember, these skills are essential for understanding and interpreting data in our world. With practice, you too can master these concepts and become a proficient data analyst.\n\n\n\nTitle:"
            },
            {
                "text": " \"\"^[0-9]{2}.[0-9]{1}$\"\"\n\n```\n\nExercise 2:\nWrite a RegEx to match a string that starts and ends with the same character.\nExample: \"AB\"\nAnswer: ^[AB]*$\n\n\n\n\nSubsections:\n- Introduction"
            }
        ]
    },
    {
        "expression": "^(\\d|,)*\\.?\\d*$",
        "raw_prompt": "Matches Numeric with Commas and a single decimal point. Also matches empty string.",
        "refined_prompt": "Validates numerical values that may use commas for thousands separation and have an optional decimal part. Also matches empty string.\nMatch examples:\n- \"1,000\"\n- \"3,000.05\"\n- \"5,000,000\"\nNon-match examples:\n- \"abc\"\n- \"$100,000\"",
        "matches": [
            "1,000",
            "3,000.05",
            "5,000,000",
            "78.486",
            "89",
            "789",
            "85",
            "1",
            "9",
            "98.48",
            "87.54",
            "56.57",
            "97.9875"
        ],
        "non_matches": [
            "abc",
            "$100,000",
            "Forty",
            "fasd@fds.fasd@",
            "sfalijad234",
            "43.v234",
            "/5/5/5",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "abc111def",
            "99999@gmail"
        ],
        "id": 228,
        "output": [
            {
                "text": " /\\$([0-9]{1,3})(?:\\.[0-9]{1,3})?/g\n\nA:\n\nI believe the best way to do this is"
            },
            {
                "text": " [^0-9,]|([0-9,]{3,})[^0-9,]\n\n2. Write a Python script that uses the `re.findall` function to"
            },
            {
                "text": "\n\\b\\d{1,3}(?:\\,\\d{3})?(?:\\.\\d{2})?\\b\nA simple string validation that matches strings of three or more"
            },
            {
                "text": " ^(?!0+)(?![^0-9]*$)(?!0+[a-z]+(\\.[a-z]+)*$)^(?!0+[0-9]"
            },
            {
                "text": " ([0-9]+\\.[0-9]+)\"\"\",\n    re.VERBOSE | re.MULTILINE\n\n\"\"\"The're.VERBOSE' flag allows you to make"
            },
            {
                "text": " [0-9]{4}(,[0-9]{3}){0,3}(,[0-9]{3}){0,3}.*[0-9]+\n\n"
            },
            {
                "text": " $100,000|[0-9]+(,[0-9]+)?\n\n4. Write a program that matches IP addresses that start with \"10.\" and contain between 0 and 255 valid octets."
            },
            {
                "text": "\n\\d+[,\\d.]*\n\n---\n\n#### Exercise 2:\n\nCreate a RegEx pattern that matches a string with a specific number of digits.\n\nHints:\nConsider"
            },
            {
                "text": " [^0-9.,]+\n\nExercise 3:\nWrite a Python code to check if a given string contains only letters, numbers, or punctuation characters.\n\nSolution:\nimport re\ninput"
            },
            {
                "text": " \n[^0-9.,]*\n\nExercise 4: \nWrite a Python function that takes a string and returns the number of digits in the string. Use the re.findall() method"
            }
        ]
    },
    {
        "expression": "^[+]?\\d*$",
        "raw_prompt": "This re was used for set numbers only!\nSomente numeros s&#227;o requeridos!",
        "refined_prompt": "It validates numeric values, including positive integers with or without a leading plus sign.\nMatch examples:\n- \"0123456789\"\n- \"1234\"\n- \"1\"\nNon-match examples:\n- \"1.0?&amp;\"\n- \"a1\"",
        "matches": [
            "0123456789",
            "1234",
            "1",
            "243",
            "513",
            "245",
            "89456",
            "98456",
            "845",
            "89456",
            "984568",
            "+98",
            "+4846"
        ],
        "non_matches": [
            "1.0?&amp;",
            "a1",
            "2a-",
            "12/123/4322",
            "234/423/5243",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "32542.456"
        ],
        "id": 231,
        "output": [
            {
                "text": " ^\\d+(\\.\\d+)?$\n\n## Exercise 3\nWrite a Python program that reads a file containing a list of IP addresses and validates each one using the regex function provided in the section. Print the valid IP addresses to the console"
            },
            {
                "text": " \n\n```python\nimport re\n\npattern = r\"^[0-9]+$\"\n\nvalue = input(\"Enter a numeric value:\")\n\nif re.match(pattern, value):\n    print(f\"'"
            },
            {
                "text": " \"^[0-9]+(\\.[0-9]+)+$\"\n\n2. Validating email addresses\nEmail addresses should contain a username and a domain name separated by a '@' symbol. They should also have at least one"
            },
            {
                "text": " \\d+|\\+?\\d+|\\d+\\.\\d+\n\nExercise 3:  The regular expression \"^(?=.*[a-z])(?=.*[A-Z])(?=.*"
            },
            {
                "text": "\n(?=^[\\+\\-\\d]*$)(\\+|-)?\\d*(\\.\\d+)?(?![\\-\\s])|[\\+\\-\\d]*(\\.\\d+)?("
            },
            {
                "text": " \nimport re \nregex_pattern = \"\"\nwhile True:\n    regex_pattern = \"^([+-]?\\d+)|^(\\d+)(\\.\\d+)?$\"\n    if regex_pattern"
            },
            {
                "text": " [0-9]{1,3}\\.?\\d{1,3}\n\nExercise 2: Regular Expression for Password Validation\nGenerate a regular expression to validate a password consisting of at least 8 characters, containing at least one"
            },
            {
                "text": " I used the following pattern: [+-]?\\d+\\.?\\d(e|E)(?:[+-]?\\d+)?\n\nLearning Journal of a Student Studying Subsection 7.1.5:\n"
            },
            {
                "text": ".{0,1}(?![0-9]+)\n\n- \"1+\"Generate a RegEx for this description. \nAnswer:.{0,1}([0-9]+|[0-9]\\"
            },
            {
                "text": " #1 and #2.\n\nExercise 2:\nCreate a list of all the letters in a given string and use list comprehension to create a list of all the uppercase letters. \nAnswer:\nimport re \n\nstring ="
            }
        ]
    },
    {
        "expression": "^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$",
        "raw_prompt": "Regular expression to match valid UK postcodes.\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\nDetails of the rules:\nFirst half of postcode\nValid formats\n[A-Z][A-Z][0-9][A-Z]\n[A-Z][A-Z][0-9][0-9]\n[A-Z][0-9][0-9]\n[A-Z][A-Z][0-9]\n[A-Z][A-Z][A-Z]\n[A-Z][0-9][A-Z]\n[A-Z][0-9]\nExceptions\nPosition - First.\nContraint - QVX not used\nPosition - Second.\nContraint - IJZ not used except in GIR 0AA\nPosition - Third.\nConstraint - AEHMNPRTVXY only used\nPosition - Forth.\nContraint - ABEHMNPRVWXY\nSecond half of postcode\nValid formats\n[0-9][A-Z][A-Z]\nExceptions\nPosition - Second and Third.\nContraint - CIKMOV not used",
        "refined_prompt": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-Z][0-9]\r\n[A-Z][A-Z][A-Z]\r\n[A-Z][0-9][A-Z]\r\n[A-Z][0-9]\r\nExceptions\r\nPosition - First.\r\nContraint - QVX not used\r\nPosition - Second.\r\nContraint - IJZ not used except in GIR 0AA\r\nPosition - Third.\r\nConstraint - AEHMNPRTVXY only used\r\nPosition - Forth.\r\nContraint - ABEHMNPRVWXY\r\nSecond half of postcode\r\nValid formats\r\n[0-9][A-Z][A-Z]\r\nExceptions\r\nPosition - Second and Third.\r\nContraint - CIKMOV not used\nMatch examples:\n- \"DN3 6GB\"\n- \"SW42 4RG\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"SEW4 5TY\"\n- \"AA2C 4FG\"",
        "matches": [
            "DN3 6GB",
            "SW42 4RG",
            "GIR 0AA",
            "W6V3 9HE",
            "O75  4QQ",
            "NA9 2XS",
            "8O 1XO",
            "TYV 2RH",
            "418N 1HH",
            "IPVA 2YP",
            "S4 5XU",
            "1MN 4WL",
            "MY5 8XW"
        ],
        "non_matches": [
            "SEW4 5TY",
            "AA2C 4FG",
            "AA2 4CV",
            "Mastercard",
            "POST code",
            "there is a boy",
            "43-5432",
            "/5/5/20022",
            "SIUE 234",
            "FJD28r9 ISOJD342",
            "FDSD79",
            "998F FD7329"
        ],
        "id": 234,
        "output": [
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            },
            {
                "text": "Regular expression to match valid UK postcodes.\r\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this. This regex takes into account those rules.\r\nDetails of the rules:\r\nFirst half of postcode\r\nValid formats\r\n[A-Z][A-Z][0-9][A-Z]\r\n[A-Z][A-Z][0-9][0-9]\r\n[A-Z][0-9][0-9]\r\n[A-Z][A-"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Accepts data of time in format h:mm and hh:mm\n^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$\nin php [0-23]:[0-59]{2} (posix)",
        "refined_prompt": "Accepts data of time in format h:mm and hh:mm\nMatch examples:\n- \"0:00\"\n- \"23:00\"\n- \"00:59\"\nNon-match examples:\n- \"0:0\"\n- \"24:00\"",
        "matches": [
            "0:00",
            "23:00",
            "00:59",
            "22:12",
            "4:15",
            "22:26",
            "22:14",
            "16:39",
            "06:45",
            "14:56",
            "1:25",
            "7:49",
            "22:53"
        ],
        "non_matches": [
            "0:0",
            "24:00",
            "00:60",
            "12/123/4322",
            "51:534",
            "432:2834",
            "234:94",
            "98:43",
            "132:43",
            "23:98",
            "54:84",
            "0943:423"
        ],
        "id": 235,
        "output": [
            {
                "text": "\n/(\\d{2}):(\\d{2})/\n\nExercise 2: \nMatch examples:\n- \"08:00\"\n- \"08:59\"\n- \"10:00\"\nNon-match examples:\n- \""
            },
            {
                "text": " \"^[0-5][0-9]:[0-5][0-9]$\"\n\n4. Use the `re.sub` method to change the case of all words in the following string: \"the quick brown fox jumps over the lazy"
            },
            {
                "text": " (^\\d{2}:\\d{2}$).*(?= \\d{4}$)\n\n3. Write a RegEx to validate a zip code in the format \"xxx-xxx-xxxx\".\nAnswer: (\\d{"
            },
            {
                "text": " Match (exemple 1) \"([01]?[0-9]|2[0-3])[:][0-5]?[0-9]\" \nMatch examples: \"05:00\"\nMatch examples: \"20:00"
            },
            {
                "text": " [^\\d:](?:[0-9]:){2}\n- \"9:59\"\nNon-match example:\n- \"9:0\"\n- \"20:09\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "\n- \"^\\d:\\d\\d$\"\n- \"^\\d:\\d\\d\\d$\" \n- \"^\\d\\d:\\d\\d$\" \n- \"^\\d:\\d\\d\\.\\d"
            },
            {
                "text": " \\d{1,2}:[^:]*$\\b\n\nExercise 4:\nGiven the following list of strings, retrieve all strings that contain the word \"apple\", which has at least three consecutive characters.\n- [\"I like apple\", \"I"
            },
            {
                "text": " 0:?\\d\\d?\n- \"12:00\"\n- \"12:30\"\n- \"12:00:00\"\n- \"0:00:00\"\n- \"00:00:00\"\n- \"00:00"
            },
            {
                "text": " [0-9]{1,2}:[0-9]{2}\n\n5. Write a Python function that takes a list of strings and returns a list of the same strings with all punctuation removed.\n\ndef remove_punct(strings"
            },
            {
                "text": " \n\nimport re\nstring = \"0:00,23:00,00:59\"\npattern = \"^(0|1):(\\d{2}):(\\d{2})$\"\nmatches = re.findall(pattern,"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))\\/(\\d{2})$",
        "raw_prompt": "Validates MM/YY for rough checking credit card expiration dates.",
        "refined_prompt": "Validates MM/YY for rough checking credit card expiration dates.\nMatch examples:\n- \"11/03\"\n- \"01/04\"\n- \"09/39\"\nNon-match examples:\n- \"13/03\"\n- \"10/2003\"",
        "matches": [
            "11/03",
            "01/04",
            "09/39",
            "08/67",
            "10/96",
            "03/67",
            "04/71",
            "12/88",
            "12/33",
            "12/48",
            "11/15",
            "10/28",
            "08/03"
        ],
        "non_matches": [
            "13/03",
            "10/2003",
            "234/234",
            "342/52",
            "23/52",
            "25/14",
            "24/14",
            "05/243",
            "432/52",
            "24/756",
            "87/67",
            "85/83"
        ],
        "id": 236,
        "output": [
            {
                "text": " [0-9]{4}-[0-9]{2}$\n\n2. Write a Python program that uses RegEx to parse and extract email addresses from a text document.\n\n3. Consider a document that contains a list of dates in the format \""
            },
            {
                "text": " (see example): ^\\d{2}/\\d{2}$\n\n2. Write a RegEx for this description: A phone number is valid if it has exactly 10 digits and the area code is between 200 and 700.\nMatch examples:\n- \""
            },
            {
                "text": " ^\\d{2}\\/\\d{2}$\n\nExercise 2: \nWrite a RegEx that matches any URL, including www.example.com.\nExercise 2 Answer: ^https?://\n\nExercise 3: \nWrite a"
            },
            {
                "text": " \".*\\d{1,2}[-/]\\d{1,2}[-/]\\d{4}\"\n\n3. Exercise: Match validating MM/YYYY for rough banking account expiration dates.\nMatch examples:\n- \"10"
            },
            {
                "text": " ^\\d{1,2}\\/\\d{1,2}$\n\n4. Write a RegEx that matches any of the following:\n- \"Hello\"\n- \"hello\"\n- \"Helloworld\"\n- \"HelloWorld!\"\n-"
            },
            {
                "text": " (MM/YY)(\\d{2}\\/\\d{2})\n\n2. Regex for matching credit card number\n- Regex for all credit card numbers:\n(4 | 5 | 6 | 7 | 8 | 9 | 1 | 2 | 3 |"
            },
            {
                "text": "\n\\d\\d/\\d{2}\\d{2} or \\d\\d\\d\\d\\d/\\d{4} or \\d\\d\\d\\d\\d-\\d{2}\n\n4. Write a Python program"
            },
            {
                "text": " (\\d{1,2}\\/\\d{2})/(\\d{4}) \n\nNow, let's take a look at how we can use RegEx in the world of web development.\n\n##### Subsection 3.1.8: Regular"
            },
            {
                "text": " (see sample below)\n[\\d]{2}\\/[0-9]{2}\\/[0-9]{4}\nExample: \"11/03\"\n\nA:\n\nYou can use the regex \\d{2}/\\"
            },
            {
                "text": " (^[0-9]{4}/[0-9]{2}$|^[0-9]{4}/([0-9]{2})/([0-9]{2})$)\n\n\n\nComparison -"
            }
        ]
    },
    {
        "expression": "^(([0]?[0-5][0-9]|[0-9]):([0-5][0-9]))$",
        "raw_prompt": "This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds). It is derived from Ken Madden's time regex for a project for Erik Porter (Windows/Web guru). Written by Jason Gaylord.",
        "refined_prompt": "This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds).\nMatch examples:\n- \"30:05\"\n- \"5:05\"\n- \"02:59\"\nNon-match examples:\n- \"25:7\"\n- \"5m:16\"",
        "matches": [
            "30:05",
            "5:05",
            "02:59",
            "52:55",
            "6:33",
            "40:13",
            "5:35",
            "9:28",
            "9:05",
            "3:32",
            "54:49",
            "10:17",
            "7:50"
        ],
        "non_matches": [
            "25:7",
            "5m:16",
            "60:60",
            "12/123/4322",
            "51:534",
            "$23.454",
            "4556:45",
            "98i:ojk",
            "000-000",
            "1-1-2",
            "34.31",
            "423:4561"
        ],
        "id": 244,
        "output": [
            {
                "text": " ([0-9]{1,2}:[0-9]{1,2}[0-9])|([0-9]{1,2}:[0-"
            },
            {
                "text": " If you want to find a time that is between 30 minutes and 59 minutes, you can use (\\d{1,2}|[1-9]):([00]\\d"
            },
            {
                "text": " \"0[0-9]{3}:[0-9]{2}(am|pm)\\\\s?(([0-9]{3}):([0-"
            },
            {
                "text": " You can use a regex like this:\n^(0?[1-9]|[12][0-9]|3[01]) :[0-5][0-"
            },
            {
                "text": " \"([0-9]{1,2})[:][0-9]{2}\"(minutes)\n\n3. Generate a RegEx that matches any time in"
            },
            {
                "text": " 60m:00\n\nFor this problem, we need to create a function that takes in a time string and converts it to minutes. The function should return the time in minutes.\n``"
            },
            {
                "text": " 01:00\nSolution: 01:00\n\n**Exercise 2**\n\nCreate a regex to match the following CD titles.\n\n(Sample List of CD Titles)\n"
            },
            {
                "text": " [2 digits]?[0-9]:[0-9][0-9]:[0-9][0-9]\n\nA:\n\nThe following regular expression matches"
            },
            {
                "text": " The regular expression would be: ^[0-9]+:[0-9]{1,2}(:[0-9]{1,2})?$\nExercise 2"
            },
            {
                "text": " \n- ([0-9]{1,2}):([0-9]{1,2})\n\nA:\n\nIt should be a little easier to do this"
            }
        ]
    },
    {
        "expression": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$",
        "raw_prompt": "Expression to handle US currency entry in .NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency.",
        "refined_prompt": "In summary, this regular expression matches strings that start with a dollar sign, followed by a group of one to three digits, optionally followed by a comma, optionally followed by a group of three digits, optionally followed by a decimal point and one to three digits, or a group of one to three digits followed by an optional decimal point and two digits.\nMatch examples:\n- \"10000\"\n- \"10,000\"\n- \"$1,000.00\"\nNon-match examples:\n- \"0.002\"\n- \"x.0\"",
        "matches": [
            "10000",
            "10,000",
            "$1,000.00",
            "$834",
            "$498",
            "$489",
            "$129",
            "15,846",
            "48357",
            "84667",
            "84694",
            "84215",
            "48583"
        ],
        "non_matches": [
            "0.002",
            "x.0",
            "-243",
            "12/123/4322",
            "51:534",
            "$23.454a",
            "43-5432",
            "/5/5/20022",
            "000-000",
            "354/243/542",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 249,
        "output": [
            {
                "text": "\n"
            },
            {
                "text": " \\"
            },
            {
                "text": " $"
            },
            {
                "text": " ^"
            },
            {
                "text": " ("
            },
            {
                "text": " \""
            },
            {
                "text": " ^"
            },
            {
                "text": " \\"
            },
            {
                "text": " (["
            },
            {
                "text": " ^"
            }
        ]
    },
    {
        "expression": "^(?![0-9]{6})[0-9a-zA-Z]{6}$",
        "raw_prompt": "matches a six character &quot;password&quot; that has to consist of numbers and letters with at least one letter in it.",
        "refined_prompt": "Matches a six character &quot;password&quot; that has to consist of numbers and letters with at least one letter in it.\nMatch examples:\n- \"123a12\"\n- \"a12345\"\n- \"aaaaaa\"\nNon-match examples:\n- \"111111\"\n- \"123456\"",
        "matches": [
            "123a12",
            "a12345",
            "aaaaaa",
            "W0lkZQ",
            "LMCawM",
            "DUcHPR",
            "NSjtUp",
            "cnzkKl",
            "lWtVJH",
            "7zLHU1",
            "1uaPEv",
            "DkGtDA",
            "9QJvZZ"
        ],
        "non_matches": [
            "111111",
            "123456",
            "89456",
            "9485632",
            "98561",
            "984651",
            "gdfs9465",
            "49865f956",
            "956gdfg",
            "g48",
            "fg4d851",
            "g98456gf"
        ],
        "id": 251,
        "output": [
            {
                "text": "\n(.*)[0-9][0-9]|[0-9][a-z][a-z]?\n\nCan you think of a different, more concise Regex pattern that generates"
            },
            {
                "text": " [a-zA-Z0-9]{5}\\1\n3. A company has a blacklist of user credentials that it does not want to allow. Write a RegEx that will match a username"
            },
            {
                "text": " \\d*[a-zA-Z]\\d*\n\n3. Give an explanation of what RegEx is and its importance in Machine Learning\nAnswer: RegEx is a powerful regular expression library"
            },
            {
                "text": " \n(?=.*[a-z])[A-Za-z0-9]{6,}\n\nThis is what I have so far, how should I proceed to complete this"
            },
            {
                "text": " ^[0-9a-zA-Z]{6,}$\n\n(1) Write a Python function that takes as input a string and returns True if the string matches the pattern described in"
            },
            {
                "text": " Your answer would be \"[a-z]+[0-9]\".\n\nExercise 3: Password Checker\nCreate a password checker that takes in a user's password as input and returns whether it"
            },
            {
                "text": "\n(?=^(?=.*[a-z])(?=.*\\d)(?=.*[A-Z])[a-zA-Z\\d]{6}$"
            },
            {
                "text": "\n\\b(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]+\\b\n\nExamples:\n1. Password Requirements"
            },
            {
                "text": "\n\"[A-Za-z]{1,4}[0-9]{3}[a-z]\"\n\nExercise 2: Count the number of occurrences of a regex\nWrite"
            },
            {
                "text": "\n\n$(function(() {\r\n  var password = '1a1';\r\n  var pattern = new RegExp('^([a-z0-9])([a-z"
            }
        ]
    },
    {
        "expression": "^\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$",
        "raw_prompt": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\n1)area code in paranthesis.\n2)space between different parts of the phone number.\n3)no space between different parts of the number.\n4)dashes between parts.",
        "refined_prompt": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"",
        "matches": [
            "(573)8841878",
            "573-884-1234",
            "573 234 1256",
            "5169670650",
            "3751905240",
            "156763\u20065387",
            "895\t344\u20294357",
            "(940) 698\u202f6344",
            "7547900898",
            "8943744511",
            "4699973928",
            "(856)1030219",
            "9555048285"
        ],
        "non_matches": [
            "(573)(673)2345",
            "573-12-2345",
            "53495083409x",
            "12/123/4322",
            "2346-2345-2435",
            "r4532",
            "15343454",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 255,
        "output": [
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description. "
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            },
            {
                "text": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\r\n1)area code in paranthesis.\r\n2)space between different parts of the phone number.\r\n3)no space between different parts of the number.\r\n4)dashes between parts.\nMatch examples:\n- \"(573)8841878\"\n- \"573-884-1234\"\n- \"573 234 1256\"\nNon-match examples:\n- \"(573)(673)2345\"\n- \"573-12-2345\"Generate a RegEx for this description.\r"
            }
        ]
    },
    {
        "expression": "(^[A-Z\u00c0-\u00dc]{1}[a-z\u00e0-\u00fc']+\\s[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc]+((([\\s\\.'])|([a-z\u00e0-\u00fc']+))|[a-z\u00e0-\u00fc']+[a-zA-Z\u00e0-\u00fc\u00c0-\u00dc']+))",
        "raw_prompt": "Checks if has the first and the last name, and check the capital letters.\nUse with the RegExp.test method",
        "refined_prompt": "Checks if has the first and the last name, and check the capital letters.\nMatch examples:\n- \"Carlos Rodrigues\"\n- \"C\u00e1 de Laaa\"\n- \"Crras R. L. Rodrig\u00fces\"\nNon-match examples:\n- \"aa\u00e4A\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "Carlos Rodrigues",
            "C\u00e1 de Laaa",
            "Crras R. L. Rodrig\u00fces",
            "Fsdf Ffasd",
            "Lionel Messi",
            "Abc Def",
            "Qwef Nfjisdo",
            "Jfdio Jijosdf",
            "Fijofds Jijsdf",
            "Jpfods Pfds",
            "Jfodis Prew",
            "Qeybr Pfds",
            "Ifisdoj Idsf"
        ],
        "non_matches": [
            "aa\u00e4A",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "53495083409x",
            "fasd@fds.fasd@",
            "sfalijad234",
            "3nf@",
            "AAAAAAA",
            "2546dgwre",
            "qwerty@123.123",
            "com.edu.github",
            "sda sad",
            "0j0jweBBBB"
        ],
        "id": 262,
        "output": [
            {
                "text": " A\n\nExercise 3.4.4\n\nWrite a regular expression that matches all the email addresses that end with either \".com\", \".org"
            },
            {
                "text": " \n\\b[A-Z][A-Za-z]*\\.[A-Za-z]{2,}\\b"
            },
            {
                "text": " (https://www.regular-expressions.info/lookaround.html)\n#import re\n#a = \"Carlos Rodrigues\""
            },
            {
                "text": "\n\n\"\"\"\nimport re\n\n#Generates a regular expression pattern for the search string.\ndef generate_pattern(search_string):\n"
            },
            {
                "text": "^\\w+\\s+\\w+\\s+\\w+\\s+(\\w+)\\s+\\w+$\n\n"
            },
            {
                "text": " [^a-zA-Z_]+ \n\nExercise 4:\nGenerate a RegEx for this description.\n- \"A"
            },
            {
                "text": "\n|Name|First|Last|Capital|\n|----|----|----|-------|\n|Carlos|Carlos|Rodrigues"
            },
            {
                "text": " (?=^\\w\\w)(?=\\w\\w\\w)\\w+\\s\\w+\\s\\w+$"
            },
            {
                "text": " \\b(?<=\\s|^)\\d{1,4}\\b(?=\\s|$)\\s[A-Z"
            },
            {
                "text": " \"^[a-zA-Z]{2}[a-zA-Z']{1}$.*[a-zA"
            }
        ]
    },
    {
        "expression": "(^((((0[1-9])|([1-2][0-9])|(3[0-1]))|([1-9]))\\x2F(((0[1-9])|(1[0-2]))|([1-9]))\\x2F(([0-9]{2})|(((19)|([2]([0]{1})))([0-9]{2}))))$)",
        "raw_prompt": "dd/mm/yy\nCheck dates between 1/1/1900 - 31/12/2099",
        "refined_prompt": "dd/mm/yy\r\nCheck dates between 1/1/1900 - 31/12/2099\nMatch examples:\n- \"31/12/2099\"\n- \"1/1/1900\"\n- \"10/12/2003\"\nNon-match examples:\n- \"05/11/3000\"\n- \"11/13/2003\"",
        "matches": [
            "31/12/2099",
            "1/1/1900",
            "10/12/2003",
            "5/2/1987",
            "30/1/16",
            "7/03/1942",
            "9/2/19",
            "15/6/1909",
            "30/1/1975",
            "2/07/1934",
            "05/5/61",
            "06/11/97",
            "30/11/94"
        ],
        "non_matches": [
            "05/11/3000",
            "11/13/2003",
            "32/04/2030",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 263,
        "output": [
            {
                "text": " \\b(1[1-9]|0[1-9]|[12][0-9]|3[01])\\/(3[01]|["
            },
            {
                "text": "\n/^\\d{4}-\\d{2}-\\d{2}$/i\nCheck dates between 1/1/1900 - 31/12/"
            },
            {
                "text": " \n^(([1-9][0-9])|[12][0-9])/([12][0-9])/([2][0-9]"
            },
            {
                "text": " [^01]{2}[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}\\\n\n```"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4}\n- \"1.1.1.1\"Generate a RegEx for this description."
            },
            {
                "text": " (1|2)\\d\\d\\/\\d\\d\\/\\d\\d(\\.\\d+)?\\s\n[0-9]{4}[0"
            },
            {
                "text": " /(\\d\\d/\\d\\d/\\d\\d):(\\d\\d):(\\d\\d)/(\\d\\d/\\d\\d/"
            },
            {
                "text": " [a-z]\\s\\d{1,2}\\d{2,2}/\\d{2,2}/\\d{4,4}\n"
            },
            {
                "text": " \n\\d{1,2}[\\/.]\\d{1,2}[\\/.]\\d{4}\n\nA:\n\nFirst, it's"
            },
            {
                "text": " https://www.w3schools.com/jsref/jsref_regexp.asp\n\nA:\n\nThis should work:\n^(0["
            }
        ]
    },
    {
        "expression": "^[0-9]{4}\\s{0,2}[a-zA-z]{2}$",
        "raw_prompt": "Dutch postalcode expression. 4 digits followed by max. two spaces end ending on two letters.",
        "refined_prompt": "Dutch postal code expression. 4 digits followed by max. two spaces end ending on two letters.\nMatch examples:\n- \"4006 AB\"\n- \"4006ab\"\n- \"4006 AB\"\nNon-match examples:\n- \"4006.ab\"\n- \"4006_ab\"",
        "matches": [
            "4006 AB",
            "4006ab",
            "4006 AB",
            "0048 VS",
            "4894fj",
            "4893fj",
            "8238fj",
            "8392jg",
            "9584jq",
            "9381oq",
            "9384jv",
            "8271pq",
            "0495ue"
        ],
        "non_matches": [
            "4006.ab",
            "4006_ab",
            "4006/ab",
            "fasd@fds.fasd@",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "4321fgd",
            "7689fgds",
            "890gss",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 271,
        "output": [
            {
                "text": " [a-zA-Z0-9]{4}[a-zA-Z0-9 ]{2}\n\n4. Try writing a Regex for this description.\n\nThe Regex could be as"
            },
            {
                "text": " ([0-9]{4}[A-Za-z]{2})\nFor additional information, I found the following links:\nhttp://www.safaribooksonline.com/library/view/python"
            },
            {
                "text": "  \\d{4}\\s\\w{2}\n\n1.  Write a RegEx pattern to match the word \"hello\" in a string, regardless of capitalization.\n2.  Write a RegEx pattern to find"
            },
            {
                "text": " [4]?\\d{1}[ ]\\d{2}[A-Z]$\n\n3. Generate a RegEx that matches all the words that contain at least one number in it.\n\nHint"
            },
            {
                "text": " (?=\\d{4}-)\\d{2}(?=\\s\\w)?\n\nA:\n\nYour problem is here :\nif (x.matches(\".*[a-zA-"
            },
            {
                "text": " ^[0-9 ]{4}\\s[A-Z]{2}$\n\n3. Write a Python script that takes a URL as input and outputs the domain name.\nIdeas: Use the split method to break"
            },
            {
                "text": "\n- The regex should be 4 digits, followed by a hyphen, followed by 2 letters.\n- The regex should be 4 digits, followed by a hyphen, followed by 2 letters, followed by two spaces.\n- The regex"
            },
            {
                "text": " \"4006[a-zA-Z]{2}[0-9]{2}\"\n\n2. Give a RegEx and explain it. It should match any number of characters, followed by a space, followed by"
            },
            {
                "text": " ^[\\d]{4}[\\w ]{1,2}$\n- \"abc def\" \n- \"abcd\"\n- \"abcd\" \n- \"abcd\"\n- \"abcd"
            },
            {
                "text": " ^[a-zA-Z]{4}\\s[a-zA-Z]{2}$\n\nExercise 2:\nYou are given a list of email addresses, where each email address is in the format"
            }
        ]
    },
    {
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "raw_prompt": "Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses. To optionally validate area codes, try this expression.\n^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "refined_prompt": "Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses.\nMatch examples:\n- \"(111) 223-2332\"\n- \"(222)233-2332\"\n- \"232-323-3233\"\nNon-match examples:\n- \"(ddd) 223-2332\"\n- \"222-232/2333\"",
        "matches": [
            "(111) 223-2332",
            "(222)233-2332",
            "232-323-3233",
            "055 8723",
            "952 944 8379",
            "037 698-1393",
            "(767)-015 9062",
            "879 908-0891",
            "(879)-830-4814",
            "(759) 122-5045",
            "440-6179",
            "(654)-789-2442",
            "937 208-8233"
        ],
        "non_matches": [
            "(ddd) 223-2332",
            "222-232/2333",
            "322-3223-222",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "48-895-956",
            "51962-9516-956",
            "9516-9516",
            "89-956",
            "956195-9516",
            "9561-56"
        ],
        "id": 273,
        "output": [
            {
                "text": "\n#!/usr/bin/env python3\n'''\nPython script for validating US phone numbers. Phone number can be delimited"
            },
            {
                "text": " \"(\\d{3}[-\\.\\s]\\d{3}[-\\.\\s]\\d{4})\""
            },
            {
                "text": " (\\d{3})\\D*(\\d{3})-(\\d{4})\n\nExercise 3: \n\n"
            },
            {
                "text": " ((\\d\\s?\\d\\s?\\d\\s?\\d?\\s?\\d?)\\s?\\"
            },
            {
                "text": " (\\(\\d\\)\\s\\d{3}\\)-(\\d{3})-(\\d{4})\"\"\"\n\n# Example"
            },
            {
                "text": " (\\d{3})([- ]?\\d{3})*([.)]?\\d{3}[- ]"
            },
            {
                "text": " The pattern should accept the following format: (\\d{3} \\d{3}-\\d{4})\n\nExercise"
            },
            {
                "text": " \n\nRegex: \\(?(\\d{3})\\)?[ -.]?(\\d{3})[ -.]?"
            },
            {
                "text": " ^[0-9]{3}[ -](?:\\(?([0-9]{3})\\)|([0-"
            },
            {
                "text": " (\\d{3})(\\d{3}-\\d{4})\n\n2. Define a function that takes a"
            }
        ]
    },
    {
        "expression": "^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2})$|^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2}\\s([1-9]|[0-1]\\d|[2][0-3])\\:[0-5]\\d)$",
        "raw_prompt": "Correct German DateTime. Does not check leap year rules!\nPossible Formats of date part:\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\nPossible formats of time part:\nh:mm or hh:mm",
        "refined_prompt": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10.2003 08:9\"",
        "matches": [
            "20.10.2003 08:10",
            "24.12.2003",
            "1.1.2004 8:15",
            "23.11.2048 01:58",
            "31.7.2051",
            "30.00.2030",
            "30.9.2022\u200716:34",
            "27.12.2031\u202818:40",
            "19.11.2057",
            "9.03.2014",
            "02.02.2097\u20091:22",
            "31.8.2074",
            "30.09.2014\u200011:18"
        ],
        "non_matches": [
            "25.13.2004",
            "20.10.2003 08:9",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "432/524/2435",
            "354/243/542",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 278,
        "output": [
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            },
            {
                "text": "Correct German DateTime. Does not check leap year rules!\r\nPossible Formats of date part:\r\nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\r\nPossible formats of time part:\r\nh:mm or hh:mm\nMatch examples:\n- \"20.10.2003 08:10\"\n- \"24.12.2003\"\n- \"1.1.2004 8:15\"\nNon-match examples:\n- \"25.13.2004\"\n- \"20.10."
            }
        ]
    },
    {
        "expression": "\\d{2}.?\\d{3}.?\\d{3}/?\\d{4}-?\\d{2}",
        "raw_prompt": "This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies.",
        "refined_prompt": "This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies.\nMatch examples:\n- \"00.000.000/0000-00\"\n- \"00000000000000\"\n- \"657552683148-18\"\nNon-match examples:\n- \"00-000-000-000-00\"\n- \"AA.AAA.AAA/AAAA-AA\"",
        "matches": [
            "00.000.000/0000-00",
            "00000000000000",
            "657552683148-18",
            "72C323,924/6687-31",
            "01978870/5388-07",
            "67443_322/861928",
            "28X041&249/3893-37",
            "18_904\"821/4142-53",
            "52632y804276173",
            "39890X500/784223",
            "29N3068138/5854-57",
            "55732078/883708",
            "74%9586365619-89"
        ],
        "non_matches": [
            "00-000-000-000-00",
            "AA.AAA.AAA/AAAA-AA",
            "34f2vf42e",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "354/243/542",
            "9/9/9",
            "++63453.345"
        ],
        "id": 282,
        "output": [
            {
                "text": " \"^[A-Z]{1,3}\\.([1-9][0-9]|0?)[A-Z"
            },
            {
                "text": " \"([A-Z][0-9]{2})([A-Z]{7})([0-9]{"
            },
            {
                "text": "\n\nimport re\ntext = \"\"\"\n00.000.000/0000-00\n00000000000000\n657552683148-18"
            },
            {
                "text": "\nCNPJ [A-Z0-9]{10}-{0,1}[0-9]{4}"
            },
            {
                "text": " [^-\\d]+\n- \"1234567890-1234567890-1234567890\" \n            Match only"
            },
            {
                "text": " [A]\n\n2. Define a regular expression that matches an email address.\n\nAnswer:\n[A-Za-"
            },
            {
                "text": " (?:\\d{5}\\.){3}\\d{5}\n\n5) Write a RegEx that matches this string: \""
            },
            {
                "text": " [A-Z0-9]{17}-[A-Z0-9]{4}-[A-Z]{2"
            },
            {
                "text": " (00[.][0-9]{3})-([0-9]{3})-([0-9]{4"
            },
            {
                "text": " [\\d]{10,12}\n\nOverall, re.sub() and re.subn() are two powerful tools for replacing"
            }
        ]
    },
    {
        "expression": "^((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)$",
        "raw_prompt": "Date expression validator with format YYMMDD\nValidates leap years.\nOf course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years !",
        "refined_prompt": "Date expression validator with format YYMMDD, validates leap years. As year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years.\nMatch examples:\n- \"751231\"\n- \"000229\"\n- \"040229\"\nNon-match examples:\n- \"750431\"\n- \"010229\"",
        "matches": [
            "751231",
            "000229",
            "040229",
            "360229",
            "920229",
            "500401",
            "530216",
            "960229",
            "241021",
            "541001",
            "801115",
            "900101",
            "160229"
        ],
        "non_matches": [
            "750431",
            "010229",
            "050229",
            "895612",
            "415625",
            "451625",
            "8745465",
            "9456456",
            "145561",
            "456897",
            "4561fd",
            "84561fs"
        ],
        "id": 285,
        "output": [
            {
                "text": " \\b[0-9]{4}\\d{1,2}\\b\n\n# 3.2.10"
            },
            {
                "text": " \n(^|[^0-9])([1-3]?[0-9]{2"
            },
            {
                "text": "\n- (?:0?[1-9]|[12][0-9]|3[01])["
            },
            {
                "text": " ([1-9][0-9]*|[0-9]+)([12][0-9]|"
            },
            {
                "text": "\n\n```python\ndef get_leap_year(year):\n    if year % 4 == 0:"
            },
            {
                "text": " (0[1-9]|[12][0-9]|3[01])\\/(0[1"
            },
            {
                "text": " \"^[0-9]{4}[0-9]{2}(0[1-9]["
            },
            {
                "text": "\n\nimport re\n\ndef is_leap(year):\n    if (year % 4 == 0):\n"
            },
            {
                "text": " (2) and (3)\n\nExercise 2: Identify the Regular Expression\nRead the following regular expression and"
            },
            {
                "text": "\n\n# Importing the required library \nimport re \n\n# Regex Pattern\npattern = r'("
            }
        ]
    },
    {
        "expression": "^((\\\"[^\\\"\\f\\n\\r\\t\\v\\b]+\\\")|([\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+(\\.[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\~\\/\\^\\`\\|\\{\\}]+)*))@((\\[(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))\\])|(((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9]))\\.((25[0-5])|(2[0-4][0-9])|([0-1]?[0-9]?[0-9])))|((([A-Za-z0-9\\-])+\\.)+[A-Za-z\\-]+))$",
        "raw_prompt": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid: !#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nSorry looks like this site is mangling the quote and ampersand characters - you'll have to fix that yourself.",
        "refined_prompt": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid: !#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bob.builder@[1.1.1.1]\"\n- \"\"blah b. blahburger\"@blah.com\"\nNon-match examples:\n- \"./A/Wacky/User@weirdos.com\"\n- \"bob.builder@[256.1.1.1]\"",
        "matches": [
            "/A/Wacky/User@weirdos.com",
            "bob.builder@[1.1.1.1]",
            "\"blah b. blahburger\"@blah.com",
            "dsfa@gmail.com",
            "sdfa@qq.com",
            "dsfia@fad.com",
            "fiosdj@sdf.com",
            "fdisojfsd@ijo.com",
            "fdsia@qq.com",
            "sfidj@afs.com",
            "fdjsi@msft.com",
            "jsifd@ifjs.com",
            "jsifdjsd@fsd.com"
        ],
        "non_matches": [
            "./A/Wacky/User@weirdos.com",
            "bob.builder@[256.1.1.1]",
            "-\"blah b. blahburger\"@blah.com",
            "fasd@fds.fasd@",
            "sfalijad234",
            "3nf@@",
            "@#dfkjnav",
            "2546dgwre@@",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "99999@gmail@@"
        ],
        "id": 287,
        "output": [
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"btw"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b/"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b."
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bam"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b\""
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"btw"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bob"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"bob"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b/"
            },
            {
                "text": "Email address validator. Should cover most of RFC 822, including unusual (but still valid) addresses. Does not restrict the top level domain size, but you're better off doing an nslookup or similar if you absolutely must have a valid domain. Accepts IP Addresses instead of the domain, with or without brackets. Believe it or not, this one is valid:!#$%^&amp;amp;amp;amp;*-+~/'`|{}@xyz.com\nMatch examples:\n- \"/A/Wacky/User@weirdos.com\"\n- \"b@"
            }
        ]
    },
    {
        "expression": "^(\\d|-)?(\\d|,)*\\.?\\d*$",
        "raw_prompt": "Input for Numeric values. Handles negatives, and comma formatted values. Also handles a single decimal point",
        "refined_prompt": "Input for Numeric values. Handles negatives, and comma formatted values. Also handles a single decimal point\nMatch examples:\n- \"5,000\"\n- \"-5,000\"\n- \"100.044\"\nNon-match examples:\n- \"abc\"\n- \"Hundred\"",
        "matches": [
            "5,000",
            "-5,000",
            "100.044",
            "8",
            "9",
            "4",
            "5",
            "54",
            "486",
            "184",
            "735",
            "48.48",
            "485"
        ],
        "non_matches": [
            "abc",
            "Hundred",
            "1.3.4",
            "-123afds",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "245/524/12",
            "adfa2",
            "34.31afd",
            "99999@gmail"
        ],
        "id": 288,
        "output": [
            {
                "text": " \n^[0-9,]*$\n\nExercise 2:\nWrite a Python program that takes in a date in the format \"MM/DD/YYYY\" and returns the month as a letter starting with A, B, C"
            },
            {
                "text": "\n(?!.*?(?<=[a-z])(?<!\\d)(?:(?<=[^a-z])|$))\\d(?:\\.\\d{1,2})\n\nA:\n\n"
            },
            {
                "text": " (^[0-9],*[1-9][0-9]*$)(^[0-9,]*$)\n\n(a) 3/4\n(b) 4/4\n(c) 1/2"
            },
            {
                "text": " (?![a-zA-Z]\\s*(?:[a-zA-Z][a-zA-Z0-9]*[a-zA-Z]|[a-zA-Z][a"
            },
            {
                "text": " (\\d+[,.]\\d+) \n\nExercise 3: Create a list of words that have at least 3 letters. Use a regex pattern to match the words.\n\nExample Output:\n[\"apple\", \"banana\", \""
            },
            {
                "text": " (?<=\\d.\\d{1,2}|\\d{1,2})0(?=\\s|$)\n\n4. Generate a regular expression that matches a time range from \"9:00 AM\""
            },
            {
                "text": "\n^(?=.\\d{1,2}(?!\\.\\d){1})(?=[^,]*$)0*[,.][0-9]+.?[0-9]*$\n\nI"
            },
            {
                "text": " \n#!python\ndef my_regex(s):\n    return re.search(r\"^\\d+,\\d+$\", s)\n\n# Test\nprint(my_regex(\"5,000\"))\nprint"
            },
            {
                "text": " /^(?=\\d{1,3}(?:,\\d{3})?)?[0-9]{0,3}.([0-9]{2})|[0-9]{1,3}"
            },
            {
                "text": " \n[\\d,\\s]+$\n\nExercise 2: Create a pattern that matches any string containing the word \"orange\" followed by any number of letters.\nAnswer: \"orange[a-zA-Z]+\"\n\n"
            }
        ]
    },
    {
        "expression": "^[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive integers that are greater then 0. Easily modified for +/- intergers and allowing zero.",
        "refined_prompt": "^[1-9]+[0-9]*$\nMatch examples:\n- \"1\"\n- \"12\"\n- \"124\"\nNon-match examples:\n- \"-1\"\n- \"a\"",
        "matches": [
            "1",
            "12",
            "124",
            "489",
            "4985",
            "45",
            "459",
            "561",
            "456",
            "54",
            "798",
            "4895",
            "13"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0",
            "845-",
            "49516-fwfd",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "34.31451",
            "32542gdf"
        ],
        "id": 289,
        "output": [
            {
                "text": " [1-9][0-9]* or [0-9]*[1-9]\n\n2. Use a RegEx to extract a phone number from the following text: \"My phone number is 123-456-7890.\"\nAnswer: \\d{3}-\\d{3}-"
            },
            {
                "text": " (a) [1-9]\\d*\n\nExercise 5:\nHow would you generate a list of all numbers between 1 and 500 that can be divided evenly by 3 or 5?\n\nThinking:\nTo generate a list of numbers between 1 and 500 that can be divided evenly by 3 or 5,"
            },
            {
                "text": " \"^[0-9]*[0-9]?[0-9]$\"\n\nExercise 5:\nUsing the RegEx \"^[A-Za-z0-9_.\\w]+$\", write a Python function that returns the username field of a form with a password field."
            },
            {
                "text": " ^[-\\d]+$\n\n2. Write a RegEx for this pattern: \"10-12\"\nAnswer: ^(\\d{1,2})-(\\d{1,2})$\n\n3. Write a RegEx for this pattern: \"1-999\"\nAnswer: ^\\d"
            },
            {
                "text": "\n- \"^[1-9]+[0-9]*$\"\n\n2. Exercise: Create a RegEx pattern to match the following phone numbers: (123) 456-7890 and (987) 654-3210.\nAnswer:\nPhone number pattern: +[123]?["
            },
            {
                "text": "\n[-?0-9]\n\nExercise 3: \nDescribe the benefits of using regular expressions in web development.\nAnswer: Regular expressions provide a powerful and flexible way to identify and manipulate strings of text, making them useful for a wide range of web development tasks, from data validation to text search and filtering"
            },
            {
                "text": " A-B-C-D\n\nExercise 5:\n- Create a RegEx that matches words with an even number of characters.\nAnswer: [a-zA-Z]{2,}\n\nConclusion:\nIn conclusion, RegEx can be a powerful tool for Quality Assurance Engineers to help identify"
            },
            {
                "text": " ^[-\\d]+$\n\n4. Write a Python RegEx that matches any URL that starts with \"http://\" or \"https://\".\nAnswer: ^http[s]?://[a-zA-Z0-9]+.[a-zA-Z]{2,}$\n"
            },
            {
                "text": " (\\d+)([A-Za-z]+)\n\nExercise 5:\nCreate a Python script that accepts a string and counts the number of words in it.\n\nAnswer:\nimport re\ndef count_words(text):\n    word_count = len(re.findall('\\"
            },
            {
                "text": " ([1-9]\\d*)|([0-9]+)\n- \"1a\"Generate a RegEx for this description. \nAnswer: ([1-9]\\d*)a\n\n2.\nWrite a RegEx to match any email address with a username and domain name separated by \".\""
            }
        ]
    },
    {
        "expression": "^(([a-z])+.)+[A-Z]([a-z])+$",
        "raw_prompt": "This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.",
        "refined_prompt": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\"",
        "matches": [
            "com.test.Test",
            "com.Test",
            "afd.Tds",
            "fds.adfs.Tfds",
            "fdsioj.fdso.Tdfs",
            "apple.banana.Class",
            "sdaf.fa.Osdfa",
            "fqidf.fdsi.Fdsa",
            "run.ran.Run",
            "apple.apple.Apple",
            "name.abc.Cds",
            "dfisf.Fds",
            "jdif.Irw"
        ],
        "non_matches": [
            "com.test.test",
            "com.test.TEst",
            "Com.test.Test",
            "Mastercard",
            "123.456.789",
            "2/3/5235",
            "afdsFDS",
            "FDS.FDsfd.dsf",
            "fgdg.dgf.fgsd",
            "gfd.gfd.gdf",
            "Rwer.wer.Fds",
            "gfdgf.WERfdg.FDS"
        ],
        "id": 294,
        "output": [
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            },
            {
                "text": "Matches strings that start with one or more groups of lowercase letters followed by a dot and end with an uppercase letter followed by one or more lowercase letters. This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents.\nMatch examples:\n- \"com.test.Test\"\n- \"com.Test\"\n- \"afd.Tds\"\nNon-match examples:\n- \"com.test.test\"\n- \"com.test.TEst\""
            }
        ]
    },
    {
        "expression": "^[a-zA-Z_][a-zA-Z0-9_]*$",
        "raw_prompt": "Matches variable names/identifier from C# (and most other languages)",
        "refined_prompt": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"",
        "matches": [
            "VariableName",
            "i",
            "Some_Value_3",
            "afds9",
            "sfjdio98",
            "jifds89u",
            "f9jdis",
            "_98fdsj",
            "jifd89",
            "jisdf98",
            "jifds09",
            "j8fid09",
            "jifdqwe"
        ],
        "non_matches": [
            "3ID",
            "Hello World",
            "jfdiosj sjfkljs",
            "j90u9u sfdijo",
            "908sfjkj sjdifoj",
            "98jfdsk",
            "908fjids",
            "9wrer",
            "9apple",
            "fijd8j8j j8fjds",
            "jifdj8j 8sdf j",
            "notre dame"
        ],
        "id": 295,
        "output": [
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\" "
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            },
            {
                "text": "Matches variable names/identifier from C# (and most other languages). This regular expression ensures that a string:\r\n\r\nStarts with a letter (either uppercase or lowercase) or an underscore.\r\nFollowed by zero or more letters (uppercase or lowercase), digits, or underscores.\r\nEnforces these rules for the entire string, not just a part of it.\nMatch examples:\n- \"VariableName\"\n- \"i\"\n- \"Some_Value_3\"\nNon-match examples:\n- \"3ID\"\n- \"Hello World\"\n"
            }
        ]
    },
    {
        "expression": "^((4\\d{3})|(5[1-5]\\d{2}))(-?|\\040?)(\\d{4}(-?|\\040?)){3}|^(3[4,7]\\d{2})(-?|\\040?)\\d{6}(-?|\\040?)\\d{5}",
        "raw_prompt": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)",
        "refined_prompt": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"",
        "matches": [
            "3711-078176-01234",
            "4123 5123 6123 7123",
            "5123412361237123",
            "526837376552 0992",
            "5552 43417106 3775",
            "3756-994651 29766",
            "483274536109 3049",
            "3495 24794717789",
            "3790685951 52358",
            "3769781961 92352",
            "345339087687813",
            "379590296125359",
            "341745514648436"
        ],
        "non_matches": [
            "3711-4123-5123-6112",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435afsd",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 299,
        "output": [
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generated"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generics"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generates"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generate"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generate"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generated"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generating"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generate"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generate"
            },
            {
                "text": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)\nMatch examples:\n- \"3711-078176-01234\"\n- \"4123 5123 6123 7123\"\n- \"5123412361237123\"\nNon-match examples:\n- \"3711-4123-5123-6112\"\n- \"52/2/54/245\"Generating"
            }
        ]
    },
    {
        "expression": "^((\\d?)|(([-+]?\\d+\\.?\\d*)|([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d+\\.?\\d*))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d+\\.?\\d*)))$",
        "raw_prompt": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional). Based pretty heavily on an expression by Steven Smith on this site.",
        "refined_prompt": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional).\nMatch examples:\n- \"8.0\"\n- \"8.0,-.38,+8.9\"\n- \"8.0, +8.8, 0.09\"\nNon-match examples:\n- \"+\"\n- \".\"",
        "matches": [
            "8.0",
            "8.0,-.38,+8.9",
            "8.0, +8.8, 0.09",
            "4894",
            "48956.456",
            "56.4895",
            "645.489",
            "456.4895",
            "465",
            "489",
            "15",
            "48",
            "46"
        ],
        "non_matches": [
            "+",
            ".",
            "a,b, c",
            "12/123/4322",
            "123.456.789",
            "43.v234",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "432/524/2435",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 300,
        "output": [
            {
                "text": " \\+\\d{1}\\.\\d{1}\n- \".\"Generate a RegEx for this description. \nAnswer: \\d\\.\\d"
            },
            {
                "text": ".+, 0-9 \n\n2. Write a RegEx for matching the string \"I'm studying for my mathematics exam with my friends on this Saturday.\" Use any"
            },
            {
                "text": ".+\n\nExercise 5: Creating a Pattern\n- Exercise: Create a pattern that matches any string that contains only digits, and is at least 5 characters long."
            },
            {
                "text": ".*[0-9]*[,][0-9]*[.]\n\nExercise 2: Write a Python program that takes the user's first and"
            },
            {
                "text": " (\\+|\\.|^)\n\nExercise 3: Create an expression for parsing the following string:\n\"I am 12 and I am 15 years old.\""
            },
            {
                "text": " \"^(,|\\s+)[-+]?\\d+\\.?\\d*$\"\n\nExercise 3: \nDefine a custom Re"
            },
            {
                "text": " \"+[0-9]\\.?[0-9]*\"\n\n4. Write a RegEx that matches the following patterns:\n- \"The quick brown"
            },
            {
                "text": " \"1.0\"\n\nI hope you found this section helpful in understanding how to use RegEx for data validation. Have fun practicing and experimenting with this powerful tool!"
            },
            {
                "text": " \"+\"\n- \".\"Generate a RegEx for this description. \nAnswer: \".\"\n\n5. Write a RegEx to extract all dates from a"
            },
            {
                "text": " 1+0+8+, 0.0\nExercise 3:\nWrite a RegEx that will match a string that starts with a letter \"A\" and ends with"
            }
        ]
    },
    {
        "expression": "^(.|\\n){0,16}$",
        "raw_prompt": "Limit Length - limit the length of a text box or other area to contain any character plus new line",
        "refined_prompt": "Matches strings containing up to 16 characters, including newline characters. It allows any combination of characters and newlines within this limit.\nMatch examples:\n- \"shorter than max\"\n- \"sgfdij\"\n- \"jiodfk90\"\nNon-match examples:\n- \"string longer than max\"\n- \"9uionjy89ubih8bhuk78byu\"",
        "matches": [
            "shorter than max",
            "sgfdij",
            "jiodfk90",
            "(JIOFDS",
            "h8uijnkdfs",
            "9ijknsd",
            "ijnkfdiok",
            "iojkfgij3",
            "ijo9ijotygv",
            "0u9ioj",
            "87yuhi",
            "78ugij",
            "78"
        ],
        "non_matches": [
            "string longer than max",
            "9uionjy89ubih8bhuk78byu",
            "b8uy8ikuhiuij,kuhb",
            "78yguh78guibjhghjjvjhk",
            "uhijuhijknuhijk9y8huijgui",
            "78giu78ogyu78gyu5drutcf78gyhu",
            "ugib89guilb78tgoyhuvogyhuv7ygohu",
            "guihbj8guij b8 uij uohijk",
            "uhij9 uij6f7 tuygd6 tuygh9 huijk",
            "9huijkuhijlkuibjlkguibj",
            "gy8ibhjg8yuhbjguibjkujk",
            "giftygjn8guijbhiojkhijnk"
        ],
        "id": 308,
        "output": [
            {
                "text": " ^[^\\s]+$\n\nExercise 2:\nCreate a Python function that takes a string as input and returns a list"
            },
            {
                "text": " [a-zA-Z0-9_\\-\\.]{32}\n\nExercise 3:\nWrite a Python program"
            },
            {
                "text": " \"^string longer than max$\"\n```\n\n### Subsection 4: Using lookahead in RegEx\n\nLookahead"
            },
            {
                "text": " [^\\s\\d]{5,16}\n\nExercise 5: Write a Python script that validates that a password"
            },
            {
                "text": " [^a-zA-Z0-9\\s]\n\nExercise 3: Write a Python code that takes a user"
            },
            {
                "text": " (?<!\\d)(?(?<![A-Za-z])\\b\\d{1,16"
            },
            {
                "text": " ^[^0-9]+$\n\nHost 2: Excellent job! We have one last quiz for you.\n\nQuiz"
            },
            {
                "text": " (\\w*\\s\\d{1,4}(?!\\s)){1,2}\\w*$\"\n"
            },
            {
                "text": " \"^[a-zA-Z0-9_\\.]{0,16}$\"\n\nExercise 4:"
            },
            {
                "text": " (\\s|\\d|[a-z]|[A-Z]|[0-9]|[-_"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]\\:)(\\\\[^\\\\/:*?<>\"|]*(?<![ ]))*(\\.[a-zA-Z]{2,6})$",
        "raw_prompt": "Matches filenames.\nUPDATED on 1st Jan 2004.",
        "refined_prompt": "Matches filenames that follow the pattern of a Windows file path, consisting of a drive letter, a path within the drive, and a file extension.\nMatch examples:\n- \"C:\\di___r\\fi_sysle.txt\"\n- \"c:\\dir\\filename.txt\"\n- \"d:\\dir\\fads.abc\"\nNon-match examples:\n- \"c:\\dir\\file?name.txt\"\n- \"c:\\f34fvfv\"",
        "matches": [
            "C:\\di___r\\fi_sysle.txt",
            "c:\\dir\\filename.txt",
            "d:\\dir\\fads.abc",
            "d:\\dir\\agd.txt",
            "d:\\dir\\gas.org",
            "D:\\di___r\\fi_sysle.png",
            "D:\\dir\\fi_sysle\\afd.cat",
            "D:\\di___r\\abas.def",
            "E:\\di_fadsf__r\\abas.afd",
            "E:\\dgha\\abas.afd",
            "E:\\asdg\\dsag.com",
            "E:\\baqe\\afd.efg",
            "E:\\baf\\vds.abd"
        ],
        "non_matches": [
            "c:\\dir\\file?name.txt",
            "c:\\f34fvfv",
            "c:\\34f2vf42e",
            "c:\\fasd@fds.fasd@",
            "c:\\2346-2345-2435",
            "c:\\2/3/5235",
            "c:\\@#dfkjnav",
            "c:\\12f3.21f3.213f",
            "c:\\qwerty@123.123",
            "c:\\(0xx12) 7256 2345154",
            "c:\\sda sad",
            "c:\\99999@gmail"
        ],
        "id": 312,
        "output": [
            {
                "text": " (.*)$\n\n3. Write"
            },
            {
                "text": "\n\\w+\\/[\\^\\-"
            },
            {
                "text": " \n\nimport re\npattern = r"
            },
            {
                "text": "\n\nimport re\n\npattern = r"
            },
            {
                "text": "\n\n#Solution to Question 3:\n"
            },
            {
                "text": "\n[\\w]{1,3"
            },
            {
                "text": " (?<=^[^\\\\]("
            },
            {
                "text": " \\w+\\.txt$\n\n"
            },
            {
                "text": " \n\"^(?:\\w+"
            },
            {
                "text": " \"c:\\([^\\\\]*\\"
            }
        ]
    },
    {
        "expression": "^(([0-9])|([0-1][0-9])|([2][0-3])):?([0-5][0-9])$",
        "raw_prompt": "For testing 24H based time entry. Tests if there is a colon to separate the hours from the minutes",
        "refined_prompt": "Match and validate time in a 24-hour format (hh:mm). It allows for hours ranging from 0 to 23 and minutes ranging from 00 to 59. The colon (\":\") between hours and minutes is optional, and the regex ensures that the input conforms to this specific time format.\nMatch examples:\n- \"0959\"\n- \"959\"\n- \"9:59\"\nNon-match examples:\n- \"90\"\n- \"960\"",
        "matches": [
            "0959",
            "959",
            "9:59",
            "534",
            "825",
            "2332",
            "542",
            "645",
            "23:24",
            "17:26",
            "23:36",
            "8:48",
            "2:18"
        ],
        "non_matches": [
            "90",
            "960",
            "24:00",
            "12/123/4322",
            "23441",
            "999",
            "978",
            "9789",
            "97899",
            "897-",
            "9/9/9",
            "32542"
        ],
        "id": 315,
        "output": [
            {
                "text": "\n[0-9]{1,2}[0-9]{"
            },
            {
                "text": " (?<hrs>\\d{1,2}):(?<"
            },
            {
                "text": " \n[0-9]{4}:[0-5][0-"
            },
            {
                "text": " \\d{1,2}:\\d{2}\n\nExercise 2"
            },
            {
                "text": " \\d\\d(?:[:|]\\d\\d)\\d\\"
            },
            {
                "text": " ^\\d{1,2}:\\d{2}$\n\nEx"
            },
            {
                "text": " (\\d{1,2}):(\\d{2})\n\n2"
            },
            {
                "text": " [0-9]\\d(:[0-9]\\d)?\n"
            },
            {
                "text": " to validate a time in a 24-hour format, you can use the following regex"
            },
            {
                "text": " The following string \"09:59\" matches the RegEx \"^([0-"
            }
        ]
    },
    {
        "expression": "^0(6[045679][0469]){1}(\\-)?(1)?[^0\\D]{1}\\d{6}$",
        "raw_prompt": "Validates Austrian Cellular Phone Numbers. Works with ONE, T-Mobile, A1, Telering and new Provider &quot;Drei&quot;. WITHOUT Country Code Verification.",
        "refined_prompt": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06641234567\"\n- \"0699-11234567\"\nNon-match examples:\n- \"06991-1234567\"\n- \"+43650-1234567\"",
        "matches": [
            "0664-1234567",
            "06641234567",
            "0699-11234567",
            "0670-2491611",
            "06748693086",
            "0674-3182376",
            "0669-18315672",
            "06063847671",
            "0670-18703482",
            "0649-1102467",
            "06961945088",
            "06902583647",
            "0606-5415789"
        ],
        "non_matches": [
            "06991-1234567",
            "+43650-1234567",
            "07661234567",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 317,
        "output": [
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"0"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"03"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"0"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"06"
            },
            {
                "text": "Match and validate a specific pattern within a string:\r\n\r\nIt starts with a \"0.\"\r\nFollowed by a pattern that consists of \"6\" followed by one character from the set [045679], followed by another character from the set [0469]. This pattern occurs exactly once.\r\nThere is an optional hyphen (\"-\").\r\nThere is an optional \"1.\"\r\nFollowed by a single character that is not \"0\" or a non-digit character.\r\nEnds with six digits.\nMatch examples:\n- \"0664-1234567\"\n- \"05"
            }
        ]
    },
    {
        "expression": "^1?[1-9]$|^[1-2]0$",
        "raw_prompt": "Matches a whole number between 1 and 20 inclusively",
        "refined_prompt": "Matches a whole number between 1 and 20 inclusively\nMatch examples:\n- \"1\"\n- \"11\"\n- \"20\"\nNon-match examples:\n- \"0\"\n- \"21\"",
        "matches": [
            "1",
            "11",
            "20",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
            "13"
        ],
        "non_matches": [
            "0",
            "21",
            "165",
            "156",
            "45651",
            "456",
            "56",
            "165798",
            "48561",
            "4516",
            "51",
            "9786"
        ],
        "id": 318,
        "output": [
            {
                "text": ".\\d\\d$ (match a number between 0 and 9, followed by a non-zero character, followed by the end of the string)\n\nExercise 3: Match the following pattern.\nPattern: A.*B\nDescription: Match any word starting with A, followed by any word ending with B\nAnswer:."
            },
            {
                "text": " ^[1-9][0-9]|20\n\nExercise 3: \nCreate a RegEx to match words that are between 5 and 20 characters long.\nAnswer: ^[A-Za-z]{5,20}$\n\nExercise 4: \nCreate a RegEx to match phone"
            },
            {
                "text": " \"^[0-2][0-9]$\"\n\nLearning Journal of a Student on Subsection 13.5.2: The definition and purpose of regular expressions\n\nExercise 1:\nQuestion: Write a regular expression to match all numbers in a string.\nThinking: I know that a digit character is"
            },
            {
                "text": " A decimal number between 1 and 20. \n\n- \"2\"\n- \"22\"\n- \"20\"\nNon-match examples:\n- \"0\"\n- \"23\"Generate a RegEx for this description. \nAnswer: A decimal number between 1 and 20.\n\nExercise 2:\n"
            },
            {
                "text": "\n[0123456789]\n\nExercise 3:\nMatch the following symbols in the correct order (any number of symbols):\n-! @ # $ % ^ & * () +? / = + - : \\ |\nAnswer:\n!@#^&*()+?/=\n\n\n\nIn the"
            },
            {
                "text": " ^(?=(?:\\\\d){5})\\\\d+$\n\nExercise 5: Find the following pattern: \n- \"ABCD\"\n- \"ABCDE\"\n- \"ABCDEF\"\n- \"ABCDEFGH\"\nAnswer: A-Z or a-z\n\nI hope this post has helped"
            },
            {
                "text": " 1, 0, 20\n\nExercise 2:\nGenerate a regex for this description.\nMatch words that have a length of 8 or more characters.\nAnswer: [A-Za-z0-9]{8,}\n\nExercise 3:\nGenerate a regex for this description.\nMatch email"
            },
            {
                "text": " ^[1-9]\\d$\n\nExercise 4:\nCreate a RegEx to check if a string starts with the letter \"A\".\nAnswer: ^[Aa]\\w+$\n\nExercise 5:\nCreate a RegEx to match a string with exactly 6 digits.\nAnswer: ^\\"
            },
            {
                "text": " \\d\\d (matches whole numbers between 1 and 20)\n\nExercise 2: Match a string that starts with \"cat\" and ends with \"dog\"\nMatch examples:\n- \"catdog\"\n- \"catdogcat\"\n- \"catcatdog\"\nNon-match examples:\n- \"cat"
            },
            {
                "text": " ^\\d{1,20}$\n\n\n\nTitle: Exploring the World of Language Arts, Media Literacy, and Media Sources: A Contrastive Biography\n\nIntroduction:\nIn this contrastive biography, we will dive into the fascinating world of language arts, media literacy, and media sources and explore their significance in"
            }
        ]
    },
    {
        "expression": "^[1-9][0-9]{3}\\s?[a-zA-Z]{2}$",
        "raw_prompt": "Validates Dutch Postal Codes (ZipCode). There was a previous one listed here, but it's not entirely correct. Namely that dutch postal codes can contain a zero but cannot start with one, so this one is the adjusted version.",
        "refined_prompt": "Validates Dutch Postal Codes (ZipCode).\nMatch examples:\n- \"1234AB\"\n- \"1234 AB\"\n- \"1001 AB\"\nNon-match examples:\n- \"0123AB\"\n- \"1234A B\"",
        "matches": [
            "1234AB",
            "1234 AB",
            "1001 AB",
            "1730\u00a0st",
            "3054\u2005Ue",
            "7278SY",
            "4669fb",
            "9708zV",
            "6899\u2029jQ",
            "2098az",
            "4552fJ",
            "2713mG",
            "5881Be"
        ],
        "non_matches": [
            "0123AB",
            "1234A B",
            "0123 AB",
            "12/123/4322",
            "sfalijad234",
            "43.v234",
            "43-5432",
            "98iojk",
            "324df",
            "adfa2",
            "sda sad",
            "3409fjg43"
        ],
        "id": 320,
        "output": [
            {
                "text": " \n```python\nimport re\ndef valid_zip_code(zip_code):\n  valid = re.compile(r'^[0-9]{5}[A-Z]$')\n  return valid.match(zip_code)\n\nprint"
            },
            {
                "text": " \"^[A-Z][a-zA-Z0-9]{5}$\"\n\n4. Write a RegEx that matches any word that contains at least one digit and one uppercase letter.\nAnswer: \"^[a-zA-Z0-"
            },
            {
                "text": " ^[0-9]{4}[A-Z]{1}$\n\n#### Exercise 2:\nCreate a RegEx to match all US phone numbers in the format \"(XXX) XXX-XXXX\".\n\nAnswer: ^\\(\\d{3}\\) \\d{3"
            },
            {
                "text": " [0-9]{4}[A-Z]\\b.\n\nExercise 3: \nCreate a list of five words and then use the random function to generate a random string that includes at least two words from the list. \nAnswer: \nimport random\n\n"
            },
            {
                "text": " ^(?:[1-9]{1,2}\\s|[1-9]{3})[A-Z]{0,2}[0-9]{1,2}[0-9]{1,2}\\s$\n\n2. Write a"
            },
            {
                "text": " The last example is valid, but the second example is not.\n\nLecture Script:\n\nTitle: Validating Email Addresses with Regular Expressions\n\nContents:\n- Introduction to regular expressions\n- How to use regular expressions to validate email addresses\n- Common email address formats"
            },
            {
                "text": " r\"^[A-Z]+[A-Z 0-9]*[A-Z 0-9]*$\n\nExercise 3: \nCreate a Python function that takes a string as input and returns True if it is a valid US phone number (i.e.,"
            },
            {
                "text": "\n(?i)^[1-9][0-9][0-9][0-9][0-9][0-9][A-B]$\n(?i)^[1-9][0-9][0-9][0-9][0-"
            },
            {
                "text": " (ZipCode_1234_ab)\n\nI hope this blog post has given you a better understanding of how to use Python RegEx in a real-life scenario. Using Python and its powerful libraries like Pandas, we can easily extract valuable information from text files, analyze the data, and"
            },
            {
                "text": "\n\\d{3}[A-Z]\\d{2}|\\d{3}[A-Z]\\d{3}|\\d{3}[A-Z]\\d{4}\n\nExercise 2:\nCreate a list of all valid"
            }
        ]
    },
    {
        "expression": "^([0-9]*|\\d*\\.\\d{1}?\\d*)$",
        "raw_prompt": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related\nfields or decimal fields.",
        "refined_prompt": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"",
        "matches": [
            ".568",
            "8578",
            "1234567.1234567",
            "65",
            "465",
            "465.456",
            "87.98",
            "846.48",
            "465.48",
            "8456.486",
            "849.78",
            "896",
            "1623"
        ],
        "non_matches": [
            "568.",
            "56.89.36",
            "5.3.6.9.6",
            "12/123/4322",
            "123.456.789",
            "43.v234",
            "43-5432",
            "12f3.21f3.213f",
            "245/524/12",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 321,
        "output": [
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: (.*)\\.(.*)\n- \"567\"Generate a RegEx for this description. \nAnswer"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: \r\n(?:\\.\\d{0,1}\\d+)(?:\\.\\d{0"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: \r\n[0-9]{1,2}(?:\\.[0-9]{1,"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: (.^[^.]*[^.][^.]*[^.]*\\s*.+\\.)/"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: 1.\\d\\d\\d\\d\\.\\d{2}\n\nMatch examples:\n- \""
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: \"\\.\\d+\"\n- \"123,456.789\"Generate a RegEx for this description."
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: ([\\d]+\\.\\d+|\\.\\d+[\\d]+)\n\nA:\n\n"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer:.{1,19}|.{1,19}[0-9]*.[0-9]"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: \"8578(?:\\.\\d+(?:\\\\.?\\d+)*)\" where (?:\\\\.?\\"
            },
            {
                "text": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric.This will be usefull in money related\r\nfields or decimal fields.\nMatch examples:\n- \".568\"\n- \"8578\"\n- \"1234567.1234567\"\nNon-match examples:\n- \"568.\"\n- \"56.89.36\"Generate a RegEx for this description. \nAnswer: (^[a-zA-Z0-9\\\\-\\\\.]+$)|(^[0-"
            }
        ]
    },
    {
        "expression": "^(?=\\d)(?:(?:(?:(?:(?:0?[13578]|1[02])(\\/|-|\\.)31)\\1|(?:(?:0?[1,3-9]|1[0-2])(\\/|-|\\.)(?:29|30)\\2))(?:(?:1[6-9]|[2-9]\\d)?\\d{2})|(?:0?2(\\/|-|\\.)29\\3(?:(?:(?:1[6-9]|[2-9]\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))|(?:(?:0?[1-9])|(?:1[0-2]))(\\/|-|\\.)(?:0?[1-9]|1\\d|2[0-8])\\4(?:(?:1[6-9]|[2-9]\\d)?\\d{2}))($|\\ (?=\\d)))?(((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))|([01]\\d|2[0-3])(:[0-5]\\d){1,2})?$",
        "raw_prompt": "DateTime Validator.",
        "refined_prompt": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports optional seconds.\r\nValidates hours (1-12 in AM/PM format or 0-23 in 24-hour format) and minutes (0-59).\nMatch examples:\n- \"12/25/2003\"\n- \"08:03:31\"\n- \"02/29/2004 12 AM\"\nNon-match examples:\n- \"02/29/2003 1:34 PM\"\n- \"13:23 PM\"",
        "matches": [
            "12/25/2003",
            "08:03:31",
            "02/29/2004 12 AM",
            "12/26/2003",
            "12/25/2008",
            "11/25/2003",
            "08:04:31",
            "08:03:32",
            "09:03:31",
            "02/28/2004 12 AM",
            "02/29/2008 12 AM",
            "02/24/2004 12 AM",
            "02/29/2012"
        ],
        "non_matches": [
            "02/29/2003 1:34 PM",
            "13:23 PM",
            "24:00:00",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235 1:12",
            "/5/5/5 12 AM",
            "/5/5/20022",
            "432/524/2435 12 AM",
            "1-1-2 1:12",
            "9/9/9 12 AM",
            "12/132/90 1:12"
        ],
        "id": 322,
        "output": [
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports up"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports AM"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            },
            {
                "text": "DateTime Validator. \r\n\r\nDate Validation:\r\n\r\nValidates dates in various formats (e.g., DD/MM/YYYY, DD-MM-YYYY, DD.MM.YYYY).\r\nSupports both leap years and non-leap years.\r\nEnsures valid months (1-12) and days (1-31) based on the selected month.\r\nValidates year ranges from 1600 to 9999.\r\nTime Validation:\r\n\r\nValidates time in 12-hour or 24-hour format.\r\nSupports both"
            }
        ]
    },
    {
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))$|^([01]\\d|2[0-3])(:[0-5]\\d){0,2}$",
        "raw_prompt": "This RE validates times patterns.",
        "refined_prompt": "Validates time input in either 12-hour (with AM/PM) or 24-hour formats, allowing for optional minutes and seconds.\nMatch examples:\n- \"1 AM\"\n- \"23:00:00\"\n- \"5:29:59 PM\"\nNon-match examples:\n- \"13 PM\"\n- \"13:60:00\"",
        "matches": [
            "1 AM",
            "23:00:00",
            "5:29:59 PM",
            "12:07:52 PM",
            "22:43",
            "8 AM",
            "12:42 AM",
            "11:11 PM",
            "08:50 AM",
            "04:09",
            "11 AM",
            "03:01 PM",
            "6:35 PM"
        ],
        "non_matches": [
            "13 PM",
            "13:60:00",
            "00:00:00 AM",
            "12:97",
            "15:97",
            "32:78",
            "5:978",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "34.31",
            "12/132/90"
        ],
        "id": 323,
        "output": [
            {
                "text": " Accepted, [^A-Za-z0-9_.-:](\\\\d+[A-Za-z0-9_.-:])+\\\\"
            },
            {
                "text": " ([0-9][0-9]?):[0-9]{2}:[0-9]{2}\n\nExercise 3: Create a RegEx for"
            },
            {
                "text": " (1) [0-2][3-9] [0-9]:[0-5][0-9] \\.[0-9]?[0-9"
            },
            {
                "text": "\n\nimport re\n\npattern = '(?P<hour>\\d{1,2}):(?P<minute>\\d{2}):(?P"
            },
            {
                "text": " \\d{1,2}(:\\d{2})?(?:AM|PM)\n\n2. Create a RegEx pattern that matches a valid US phone number,"
            },
            {
                "text": "\n- \"(1|2[0-3])[0-9]|0[1-9]|1[012]|[13][01]|3["
            },
            {
                "text": " \\b(1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9] \\b"
            },
            {
                "text": " \\d\\d:\\d\\d:\\d\\d(AM|PM)? \n\n2. Given a string containing a date and time in the format \"MM/DD"
            },
            {
                "text": " (Regex for \"12-hour\" with AM/PM) [0-9]{1,2}:[0-9]{3}[ AM|PM]"
            },
            {
                "text": " Match examples start with \"1\" followed by \"AM\" or \"PM\". Non-match examples start with \"13\" followed by either \"PM\" or \"AM\".\n\n"
            }
        ]
    },
    {
        "expression": "^(#){1}([a-fA-F0-9]){6}$",
        "raw_prompt": "Matches HTML Color strings. Like #FFFFFF is white and #000000 is black and #FF0000 is red and so on...",
        "refined_prompt": "Matches HTML Color strings.\nMatch examples:\n- \"#FFFFFF\"\n- \"#FF3421\"\n- \"#00FF00\"\nNon-match examples:\n- \"232323\"\n- \"f#fddee\"",
        "matches": [
            "#FFFFFF",
            "#FF3421",
            "#00FF00",
            "#D90e0F",
            "#7Ac136",
            "#CeE1eB",
            "#3D1f8d",
            "#462d56",
            "#0e6307",
            "#2a6Eef",
            "#8beB0c",
            "#e59d3c",
            "#4aafdc"
        ],
        "non_matches": [
            "232323",
            "f#fddee",
            "#fd2",
            "Mastercard",
            "sfalijad234",
            "43.v234",
            "43-5432",
            "2546dgwre",
            "000-000",
            "354/243/542",
            "abc111def",
            "32542"
        ],
        "id": 325,
        "output": [
            {
                "text": " You could use the regex: \n\nvar string = \"String with hex codes matching #00FF00\";\nvar myPattern = /^#([0-9a-fA-F]{6})\\b$/;\nvar match = myPattern.exec(string);\nconsole"
            },
            {
                "text": " [a-f0-9]{1}[a-f0-9]\n- The regex is [a-f]?[0-9a-f]?[0-9]?[0-9]?\n- The regex will match the following characters: \n"
            },
            {
                "text": " ^[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}[a-zA-Z0-9]{1}$\nUse the re.match() function to find the first non-match example.\n\n"
            },
            {
                "text": " \\d{3}-\\d{2}-\\d{2}\n\nExercise 4:\nMatch the following HTML tags:\n- <div>\n- <ul>\n- <p>\n- <img src=\"image.jpg\" />\n\nAnswer: \n-"
            },
            {
                "text": " \n#\\d{3}[a-f]{3}\n\nExercise 2:\nCreate a set of Regex patterns that matches strings that start with a vowel and end with a consonant.\nAnswer: \nvowels = ['a', 'e', 'i',"
            },
            {
                "text": " ^#[A-Fa-f0-9]{6}$\n\n##### Exercise 3:\nWrite a Python code to extract all URLs from a string using regex.\n\n##### Solution:\nimport re\n\nstring = '''<a href=\"https://www.google."
            },
            {
                "text": "\nTo match a hashtag (#) followed by a four-digit number, you could use the pattern \"#[0-9]{4}\". The square brackets [] in the pattern indicate a range of values that can be matched. The \"{\" and \"}\" are special characters that indicate the start and end of"
            },
            {
                "text": "\n_[\\u0065-\\u0084][\\u0087-\\u0089][\\u0095-\\u0096][\\u0099-\\u00A9][\\u00AB-\\u00B9][\\u00C3-\\u"
            },
            {
                "text": " \"^#[0-9a-fA-F]{3,6}$\"\n\nExercise 3:\nMatch an email address with RegEx.\nEmail address: johndoe@example.com\nRegex to match:\n- Example: \"^[a-"
            },
            {
                "text": " ^?[[0-9]{1,2}]([a-z][0-9]{2}){1,3}$\n\nExercise 3: Identify the Problem\nScenario: Your friend just moved to a new city and is having trouble finding a new place to live"
            }
        ]
    },
    {
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])(\\d{4}))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "Date in DD/MM/YYYY format.\nFecha en formato DD/MM/AAAA.",
        "refined_prompt": "Date in DD/MM/YYYY format.\nMatch examples:\n- \"28/12/2003\"\n- \"28/02/2003\"\n- \"29/02/2000\"\nNon-match examples:\n- \"28-02-2003\"\n- \"30/02/2003\"",
        "matches": [
            "28/12/2003",
            "28/02/2003",
            "29/02/2000",
            "29/02/3200",
            "29/02/5676",
            "29/02/6608",
            "21/02/8399",
            "01/11/2510",
            "29/02/7032",
            "29/02/1504",
            "13/02/4580",
            "30/10/0687",
            "29/02/9288"
        ],
        "non_matches": [
            "28-02-2003",
            "30/02/2003",
            "28.02.2003",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/91341",
            "12/132/90"
        ],
        "id": 327,
        "output": [
            {
                "text": "\n\\d\\d/\\d\\d/\\d\\d\\d\\d\n\nExercise 3:\nWrite a Python program that reads a list of dates from a file and matches them with the provided RegEx.\nAnswer"
            },
            {
                "text": " \\d{1,2}/[A-Za-z]{3}[-\\s]\\d{4}\n\nExercise 2:\nMatch examples:\n- \"34/03/2010\"\n-"
            },
            {
                "text": " [0-9]{2}/[0-9]{2}/[0-9]{4}\n\nExercise 4: Write a Python program to count the number of occurrences of a given string in a text."
            },
            {
                "text": " A regex for this should look like:\n\"^(0-2)([0-9][0-9]|3[0-1])/([0-9][0-9]|3[0-1])/"
            },
            {
                "text": " \n[0-9]{2}[-][0-9]{2}[-][0-9]{4}\nUsing a pattern with this regex, we can match any date in the format \"dd/mm"
            },
            {
                "text": " A regular expression to match dates in DD/MM/YYYY format. The expression would be: \"^([0-9]{2})/([0-9]{2})/([0-9]{4})$\""
            },
            {
                "text": " \"^(\\d/\\d/\\d\\d)\\s(\\d/\\d/\\d\\d)\\s(\\d/\\d/\\d\\d)\\s(\\d\\d)$\"\n\n2. Use"
            },
            {
                "text": " \n[0-9]{3}[-/][0-9]{2}[-/][0-9]{4}\n\n5. A customer emails you with the following message: \"Hi, I would"
            },
            {
                "text": " /^(1[0-9]|0\\d|2[0-8]|1\\d\\d|\\d\\d\\d)\\d{2}(?!\\-)\\d{2}(?!-)\\"
            },
            {
                "text": " \n^[0-9]{2}\\/[0-9]{2}\\/[0-9]{4}$\n\nExample 2: \nSuppose you are a web developer who needs to create a valid"
            }
        ]
    },
    {
        "expression": "(^[0-9]{1,8}|(^[0-9]{1,8}\\.{0,1}[0-9]{1,2}))$",
        "raw_prompt": "Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot.",
        "refined_prompt": "Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot.\nMatch examples:\n- \"1.00\"\n- \"2345\"\n- \"332.3\"\nNon-match examples:\n- \".00\"\n- \"23333333333.00\"",
        "matches": [
            "1.00",
            "2345",
            "332.3",
            "9015.76",
            "0876.60",
            "30337975.54",
            "261814",
            "426732.8",
            "4",
            "5",
            "6",
            "5438996",
            "4856123"
        ],
        "non_matches": [
            ".00",
            "23333333333.00",
            "j22.00",
            "-123af",
            "234/423/5243",
            "43.v234",
            "56dfsa",
            "12f3.21f3.213f",
            "324df",
            "341.431v4f3.fv1",
            "abc111def",
            "12/132/90"
        ],
        "id": 332,
        "output": [
            {
                "text": "  \\d.\\d{3}(?:(?:\\.\\d{3})?|$)\n\nIn the RegEx above, \\d is a digit (0"
            },
            {
                "text": "\n- \\d{1,2}[.\\d]{0,2}\n\n- [a-zA-Z0-9]{3,}\n\n"
            },
            {
                "text": " \n[0-9.]{1,2}[0-9.]{0,2}\n\nExercise 3:\nCreate a RegEx pattern to extract the year from"
            },
            {
                "text": " @\"(^|[^0-9])(\\d{1,2}\\.\\d{1,2})([^0-9]|$)\n\nA"
            },
            {
                "text": " \\.(0|\\d|\\d\\.\\d|\\d\\.\\d\\d).\n\n2. Match the numbers in the following format. The numbers can be anywhere in"
            },
            {
                "text": ".{0,3}(?<!\\d)\\d{2}.{0,2}\n\nA:\n\nThis is what I came up with\n^[^"
            },
            {
                "text": " (^[0-9]{1,3}[0-9]([0-9]{1,2})|[0-9]([0-9]{"
            },
            {
                "text": " \"([0-9]{1,2}[0-9]{1,3}\\.[0-9]{1,3}|[0-9]{1"
            },
            {
                "text": " /^[1-9]\\d{1}(\\.\\d{0,2})?$/\n\n2. Write a java program that takes in a sentence from the"
            },
            {
                "text": " ^\\d{1,2}\\.\\d{0,2}$\n- \"223333333333233333333333333.233333333333333\"Generate a"
            }
        ]
    },
    {
        "expression": "^[AaWaKkNn][a-zA-Z]?[0-9][a-zA-Z]{1,3}$",
        "raw_prompt": "Simple match for U.S. Amateur Radio Call signs\nMust start with an A,K,N or W.\n1 or two prefix letters (not case sensitive),\nExactly one zone digit,\nOne to three suffix digits( not case sensitive).\n73",
        "refined_prompt": "Simple match for U.S. Amateur Radio Call signs\r\nMust start with an A,K,N or W.\r\n1 or two prefix letters (not case sensitive),\r\nExactly one zone digit,\r\nOne to three suffix digits( not case sensitive).\nMatch examples:\n- \"kd6dun\"\n- \"W9OXZ\"\n- \"kb8ae\"\nNon-match examples:\n- \"kdd90bz\"\n- \"de7bgw\"",
        "matches": [
            "kd6dun",
            "W9OXZ",
            "kb8ae",
            "A0Icp",
            "A7BxG",
            "Wg4x",
            "k9Zqy",
            "k2dGw",
            "N1jM",
            "A0BK",
            "N4Rl",
            "a2QJ",
            "a3zvj"
        ],
        "non_matches": [
            "kdd90bz",
            "de7bgw",
            "WV7BXQ5",
            "fads2fe",
            "2feef",
            "e2ffe",
            "f2eafe",
            "f2ewds",
            "qwerty@123.123",
            "354/243/542",
            "abc111def",
            "12/132/90"
        ],
        "id": 333,
        "output": [
            {
                "text": " ^(A|K|N|"
            },
            {
                "text": " 0-9a-zA-"
            },
            {
                "text": " \n^.*?(?=("
            },
            {
                "text": " A(?:K|K)(?"
            },
            {
                "text": " [A-Z]{1}"
            },
            {
                "text": " (A|K|N|W"
            },
            {
                "text": " (a|k|n|w"
            },
            {
                "text": " ^[AKNW][0-9"
            },
            {
                "text": " kdn\\d[a-z"
            },
            {
                "text": " (.*A[K]N|"
            }
        ]
    },
    {
        "expression": "^(Sun|Mon|(T(ues|hurs))|Fri)(day|\\.)?$|Wed(\\.|nesday)?$|Sat(\\.|urday)?$|T((ue?)|(hu?r?))\\.?$",
        "raw_prompt": "This RE matches Days of the week or their abbreviations.",
        "refined_prompt": "This RE matches Days of the week or their abbreviations.\nMatch examples:\n- \"Sunday\"\n- \"Mon\"\n- \"Tu\"\nNon-match examples:\n- \"day\"\n- \"Wedday\"",
        "matches": [
            "Sunday",
            "Mon",
            "Tu",
            "Thu",
            "Sun",
            "Tu.",
            "Wed",
            "Sat.",
            "Sun.",
            "Thurs",
            "Wednesday",
            "Saturday",
            "Thursday"
        ],
        "non_matches": [
            "day",
            "Wedday",
            "Payday",
            "Mastercard",
            "afdfs",
            "sundafahds",
            "ewnefdesday",
            "happyday",
            "mothersday",
            "childrensday",
            "sadday",
            "notredameday"
        ],
        "id": 338,
        "output": [
            {
                "text": " (0-9]|[a-zA-Z])([a-z]|[0-9])\\b\n\nExercise 2:\nA company wants to find all the email addresses in a given text. The email addresses are supposed to end with \".com\"\nGenerate a RegEx for"
            },
            {
                "text": "\n\\b(?:0[1-9]|1[0-2])[T](?:T[0-9]|[1-9]):[0-5][0-9]\n\nExercise 3: Create your own RegEx pattern for the following scenario:\nA website needs to search"
            },
            {
                "text": "\n#!/usr/bin/env python\nimport re\n\ntext = '''\nThis text contains both Mon and Wed days of the week, as well as 'day'\n'''\n\ndaysOfWeek_re = re.compile(r'\\b(Mon|Tue|Wed|Thu|Fri"
            },
            {
                "text": " \\b((\\w+)\\s?\\([^)]*\\))?\\b\n\n5. Write a Python script that takes a string as input and uses a Regular Expression to find all the words that start with \"s\" and end with \"z\".\n\n```python\nimport re\n\ninput_"
            },
            {
                "text": " \n\n```python\nimport re\n\n# Define a list of words\nwords = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\n# Define the Regular Expression\nregex = \"|\".join(words)\n\n# Generate the"
            },
            {
                "text": " [RE - /\\s*day\\b|\\s+day\\b|\\bday\\w*/]\n\n2. Write a RegEx that matches a URL with subdomain and top-level domain.\nSolution: [RE - /\\bhttps?:\\/\\/(?:www\\.)?\\"
            },
            {
                "text": "\n[a-zA-Z]{3}[0-9][a-z]{3}[0-9]\n\nExercise 2:\nCreate a RegEx for this description:\nA RegEx that matches URLs.\nGenerate a RegEx for this description.\nAnswer:\n("
            },
            {
                "text": " \\b(Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\b\n\nExercise 2: Generate a RegEx pattern for this descriptive text.\n\"Python is a general-purpose programming language that is widely used for data analysis, artificial intelligence, and web development.\"\nAnswer: \\bPython\\"
            },
            {
                "text": "\n\n[a-zA-Z]?[0-9]{2}[/-][0-9]{2}[/-][/0-9]{4}\n\nExercise 4:\nA company has a website with a search bar where customers can search for products or services. Write a regular"
            },
            {
                "text": " [^a-zA-Z][a-zA-Z]*[^a-zA-Z]\n\nExercise 5:\nAdd parentheses around the last word of a sentence to make it a separate word.\nAdd parentheses around the last word of a sentence to make it a separate word.\n"
            }
        ]
    },
    {
        "expression": "^\\w+.*$",
        "raw_prompt": "Validates any line begining with an alpha-numeric. If you need a regular expression that fails only for a zero length string. Remove the \\w+. I originally attempted to post was ^.*$ but the input form would not allow it.",
        "refined_prompt": "matches a wide range of text strings that have at least one word character((letters, digits, or underscores) at the beginning.\nMatch examples:\n- \"user name\"\n- \"o)(=-&amp;r443*/\"\n- \"fds2f\"\nNon-match examples:\n- \"=stuff\"\n- \".username\"",
        "matches": [
            "user name",
            "o)(=-&amp;r443*/",
            "fds2f",
            "23f2ef",
            "bh",
            "87",
            "u8hh98",
            "9h",
            "99h9",
            "8hh9",
            "9h8",
            "8hg97f",
            "76df"
        ],
        "non_matches": [
            "=stuff",
            ".username",
            "@!R-243fads",
            "#$r1w1-123fads",
            "#RFE",
            "%FTYV",
            "*&YHU",
            "*%^TYGVH",
            "%^TYF",
            "(*IU",
            "&^YGU",
            "$%ERTYU"
        ],
        "id": 342,
        "output": [
            {
                "text": "\n\\w\n\nExercise 4: \nCreate a program that validates that an email address is not blank.\nHint: Use the `$` anchor to match the end of"
            },
            {
                "text": "\n[a-zA-Z0-9_\\-\\.]\n\n2. Write a program that reads a text file and replaces all occurrences of a given string with a different string."
            },
            {
                "text": "\n^(?=.*[a-zA-Z])[a-zA-Z0-9_]{1,30}$\nExercise 2:\n- Ident"
            },
            {
                "text": " (\\w+)\"\"\",\n        \"Example 4\": r\"<?P<username>\\w+(?:-\\w+)*>\"\n    }\n#!/usr/bin"
            },
            {
                "text": " \\w+(?=(?:\\.\\w{0,2})*$)\nExercise 3: Extract URLs from a text using RegEx.\nQuestion: What is a URL,"
            },
            {
                "text": ".\\w*(?=.*_\\w*)*\n\nExercise 2:\nGenerate a RegEx to match email addresses.\nAnswer: [a-zA-Z"
            },
            {
                "text": " (\\w+)(.*)\n\"\"\"\nimport re\n\ninput_str = \"user name\"\noutput_str = \"user name\"\n\n# Non-Match Example\nnot"
            },
            {
                "text": " /^[a-zA-Z][a-zA-Z0-9._-]*[a-zA-Z]$/.\n\nExercise 3: "
            },
            {
                "text": " [a-zA-Z][a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\\.[a-zA"
            },
            {
                "text": "  [a-z]+[a-z0-9]*\n\n2. Write a function that takes a string that contains a list of user IDs as an argument and returns a list"
            }
        ]
    },
    {
        "expression": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "raw_prompt": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.",
        "refined_prompt": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"",
        "matches": [
            "2004-2-29",
            "2004-02-29 10:29:39 pm",
            "2004/12/31",
            "2004-2-29",
            "2008-12-07",
            "2013-2-28",
            "2012-12-29",
            "2004-02-29 10:29:39 pm",
            "2004-02-28 11:19:39 pm",
            "2004-02-26 10:08:39 pm",
            "2004/12/19",
            "2004/5/31",
            "2004/8/31"
        ],
        "non_matches": [
            "2003-2-29",
            "2003-13-02",
            "2003-2-2 10:72:30 am",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 343,
        "output": [
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegExp"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            },
            {
                "text": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm. You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099.\nMatch examples:\n- \"2004-2-29\"\n- \"2004-02-29 10:29:39 pm\"\n- \"2004/12/31\"\nNon-match examples:\n- \"2003-2-29\"\n- \"2003-13-02\"Generate a RegEx"
            }
        ]
    },
    {
        "expression": "^((AL)|(AK)|(AS)|(AZ)|(AR)|(CA)|(CO)|(CT)|(DE)|(DC)|(FM)|(FL)|(GA)|(GU)|(HI)|(ID)|(IL)|(IN)|(IA)|(KS)|(KY)|(LA)|(ME)|(MH)|(MD)|(MA)|(MI)|(MN)|(MS)|(MO)|(MT)|(NE)|(NV)|(NH)|(NJ)|(NM)|(NY)|(NC)|(ND)|(MP)|(OH)|(OK)|(OR)|(PW)|(PA)|(PR)|(RI)|(SC)|(SD)|(TN)|(TX)|(UT)|(VT)|(VI)|(VA)|(WA)|(WV)|(WI)|(WY))$",
        "raw_prompt": "This validates the states and territories of the United States in a 2 character uppercase format. Very poor excuse for a regular expression! ;)\nWritten by Jason Gaylord.",
        "refined_prompt": "This validates the states and territories of the United States in a 2 character uppercase format.\nMatch examples:\n- \"NY\"\n- \"PA\"\n- \"NJ\"\nNon-match examples:\n- \"Pennsylvania\"\n- \"Pa\"",
        "matches": [
            "NY",
            "PA",
            "NJ",
            "MA",
            "KS",
            "AL",
            "IA",
            "VI",
            "CT",
            "NE",
            "ME",
            "MT",
            "HI"
        ],
        "non_matches": [
            "Pennsylvania",
            "Pa",
            "pa",
            "INDIANA",
            "QW",
            "WER",
            "AB",
            "XX",
            "EE",
            "WER",
            "SDF",
            "DD"
        ],
        "id": 346,
        "output": [
            {
                "text": " (?i)(NY|PA|NJ)?\n\n2. Create a RegEx that matches the following email formats:\n- \"example.com\"\n- \"user email@example.com\"\n- \"example.com/subdomain/user@example.com\"\n"
            },
            {
                "text": " (^[A-Z][A-Z\\d]{3}\\s[A-Z][A-Z\\d]{4}$)\n\n2. Write a Python Regex to match the string \"USA\".\nAnswer: (^USA$)\n\n"
            },
            {
                "text": " ^[A-Z]{2}$\n2. Generate a RegEx for this pattern. \nEx: A user should be able to enter a phone number in the format of (123) 456-7890.\nAnswer: ^\\(\\d{3}\\"
            },
            {
                "text": " \"^[A-Z]{2}\\s([A-Z]{2})\\s[A-Z]{2}$\"\n\n\n\nTitle: The Evolution of Daily Life Transportation and its Impact on Health and Physical Education\n\nIntroduction:\nWelcome, dear"
            },
            {
                "text": " [0-9][0-9][A-Z]\n\nExercise 5:\nCreate a RegEx to match a date in the format \"MM/DD/YYYY\"\n\nAnswer: \\d{2}\\/\\d{2}\\/\\d{4"
            },
            {
                "text": " ^[A-Z]{2}\\w*$|^[A-Z]{2}\\w+$|^[A-Z]{2}\\d{2}\\w+$|^[A-Z]{3}\\d{3}\\w*$"
            },
            {
                "text": " (i) ^[a-zA-Z0-9]{1,2}\\s([a-zA-Z0-9]{1,2})\\s([a-zA-Z0-9]{1,2})$\n\n2"
            },
            {
                "text": " \n(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i)(?i"
            },
            {
                "text": " ^(?=.*[Pp][Aa][Kk])[A-Za-z0-9][A-Za-z0-9-]{2,7}$\n\nExercise 2: Write a Python script that takes in a list of"
            },
            {
                "text": " \n\n```python\nimport re\n\nexample1 = \"NY\"\nexample2 = \"PA\"\nexample3 = \"NJ\"\nexample4 = \"Pennsylvania\"\nexample5 = \"Pa\"\n\n# Matching states\nmatch1 = re.match"
            }
        ]
    },
    {
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[ ]{1}[0-9]{3}[\\-]{1}[0-9]{4})$",
        "raw_prompt": "It is the exact phone number regular expression for '(###) ###-####'.\nWritten by Jason Gaylord.",
        "refined_prompt": "It is the exact phone number regular expression for '(###) ###-####'.\nMatch examples:\n- \"(555) 555-1212\"\n- \"(575) 609-4178\"\n- \"(435) 236-2754\"\nNon-match examples:\n- \"555-1212\"\n- \"1-800-555-1212\"",
        "matches": [
            "(555) 555-1212",
            "(575) 609-4178",
            "(435) 236-2754",
            "(094) 722-0258",
            "(743) 805-8464",
            "(838) 390-9293",
            "(717) 033-3038",
            "(834) 145-5776",
            "(255) 800-3155",
            "(740) 815-8610",
            "(621) 005-4039",
            "(538) 776-0986",
            "(883) 167-0736"
        ],
        "non_matches": [
            "555-1212",
            "1-800-555-1212",
            "555-555-1212",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "415-94561-51",
            "9516-9516",
            "-5612516-9561",
            "8451-95614-956",
            "48561-49516-51"
        ],
        "id": 347,
        "output": [
            {
                "text": " \\d{3}-\\d{3}-\\d{4}\n\n2. Find the phone number using only the re.findall function. \nAnswer:"
            },
            {
                "text": " \"^((?:\\d{3}) (?:\\d{3}-)?\\d{4})$\"\n\nExercise 2:\nWrite the Python code to extract"
            },
            {
                "text": "\n[0-9]{3}[-.][0-9]{3}[-.][0-9]{4}\n\n```python\nimport"
            },
            {
                "text": " The pattern is '([0-9]{3})-[0-9]{3}-[0-9]{4}'\n\n## Using `isnumeric"
            },
            {
                "text": "\n(\\d{3})\\D?\\d{3}-\\d{4}\n\nExercise 5:\nCreate a Python program that prompts the user to enter"
            },
            {
                "text": " (\\d{3})\\s|([A-Z]{3}\\-)\\s(\\d{4})\n\nExercise 3:\nCreate a Python class that reads"
            },
            {
                "text": " (\\d{3})\\s(\\d{3})-(\\d{4}) (\\d{4})\\b\n\n``` python\nimport re\n\nphone"
            },
            {
                "text": " (\\d{3}-\\d{3}-\\d{4})\n2. You are asked to create a regular expression to find all the words containing the letters '"
            },
            {
                "text": "\n[\\d]{3}\\-?[\\d]{3}\\-?[\\d]{4}\n\nExercise 5:\nMatch this RegEx to"
            },
            {
                "text": " \"(\\d{3}) \\d{3}-\\d{4}$\"\n- \"1-800\"Generate a RegEx for this description.\nAnswer:"
            }
        ]
    },
    {
        "expression": "^(([0]?[1-9]|1[0-2])/([0-2]?[0-9]|3[0-1])/[1-2]\\d{3})? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?(AM|am|PM|pm)?$",
        "raw_prompt": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM. If this don't woik, I wrote it, lemmy know.",
        "refined_prompt": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"",
        "matches": [
            "12/30/2002",
            "12/30/2002 9:35 pm",
            "12/30/2002 19:35:02",
            "11/31/1847",
            "10/31/2051",
            "12/8/1094 20:19:36",
            "06/31/1101 15:46",
            "10/31/1956 4:00",
            "10/31/2553",
            "04/30/1121 23:03 PM",
            "7/30/2673",
            "4:03:29PM",
            "3:25:25"
        ],
        "non_matches": [
            "18/22/2003",
            "8/12/99",
            "8/22/2003 25:00",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 348,
        "output": [
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description:"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description\n"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description:"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description?"
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description."
            },
            {
                "text": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM.\nMatch examples:\n- \"12/30/2002\"\n- \"12/30/2002 9:35 pm\"\n- \"12/30/2002 19:35:02\"\nNon-match examples:\n- \"18/22/2003\"\n- \"8/12/99\"Generate a RegEx for this description:"
            }
        ]
    },
    {
        "expression": "^\\d(\\d)?(\\d)?$",
        "raw_prompt": "Matches positive whole numbers from 0-999",
        "refined_prompt": "Matches positive whole numbers from 0-999\nMatch examples:\n- \"0\"\n- \"12\"\n- \"876\"\nNon-match examples:\n- \"1000\"\n- \"1.23\"",
        "matches": [
            "0",
            "12",
            "876",
            "489",
            "987",
            "162",
            "875",
            "495",
            "86",
            "87",
            "15",
            "39",
            "5"
        ],
        "non_matches": [
            "1000",
            "1.23",
            "-234",
            "48956",
            "4985",
            "89448",
            "45665187",
            "8374",
            "515.1",
            "45.64",
            "45.87",
            "65.541"
        ],
        "id": 349,
        "output": [
            {
                "text": " \\d{1,999}\n\n3. Match strings that contain at least one space or one hyphen.\nMatch examples:\n- \"Hello, world\"\n- \"This is a - phrase\"\nNon-match examples:\n- \"123\"\n- \"No spaces in this phrase\"\nGenerate a"
            },
            {
                "text": " Matches positive whole numbers from 0-999.\n\n3. Use a RegEx to find all dates in this format: MM/DD/YYYY\nAnswer: \n^(0[1-9]|1[012])\\/(0[1-9]|[12][0-9]|3"
            },
            {
                "text": ".*\\d{1}(?:\\.\\d{3})*(?:\\.\\d{3})*(?:[eE][+-]?\\d+)\n\n- \"1\"\n- \"000\"\n- \"1.0\"\n- All other numbers.\nGenerate a"
            },
            {
                "text": " \"0..9\"\n\nExercise 2:\nCreate a RegEx for checking if a string is a valid phone number (in the format 123-456-7890 or 123-456-7890-123).\nAnswer: \"^\\d{3}-\\d{3}-\\d{4}"
            },
            {
                "text": " This requires a bit more complex understanding of the regular expression syntax. However, one can use a combination of [0-9]+ pattern to match the decimal part. \n```python\ndef validate_decimal(value):\n    return re.match(r'[0-9]+\\.[0-9]*"
            },
            {
                "text": " \\d+\\.\\d+\n- \"00\"\n- \"0.00\"\n- \"00.00\"\n- \"0.00.0\"\n- \"0\"\n- \"0.0\"\n- \"00.0.0\"\n- \".\"\n- \"..\"\n\n\n"
            },
            {
                "text": " ^0[1-9][0-9]|0[1-9][0-9]|[1-9]0[9]$\n\nExercise 2: \nMatch the following characters: \n- \"a\"\n- \"b\"\n- \"1\"\nMatch examples:\n-"
            },
            {
                "text": " The code below should work for your needs.\n\nimport re\n\n# A function to generate a RegEx for a given description\ndef generate_regex(description):\n    return \"^\" + re.escape(description) + \".$\"\n\n# Example usage\nprint(generate_regex(\"one"
            },
            {
                "text": " Matches any string between 1 and 9 followed by 0-9. \n\n2. Write a Python program that accepts a list of names and filters out all names that start with the letter \"J\".\n\nSolution:\nimport re\n\nnames = [\"John Doe\", \"Jane Smith\", \"Jack Johnson\", \"Jill"
            },
            {
                "text": " ^[0-9]+$\n\n3.2.3 Match words separated by spaces, tabs, or newlines.\nMatch examples:\n- \"hello world\"\n- \"hi there\"\n- \"hi there\\n\\t\\t\\n\\t\"\nNon-match examples:\n- \"hello"
            }
        ]
    },
    {
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\\s{1}|\\/|-](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\\s{1}|\\/|-]\\d{4}$",
        "raw_prompt": "More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit.",
        "refined_prompt": "More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit.\nMatch examples:\n- \"01 JAN 2003\"\n- \"31/Dec/2002\"\n- \"20-Apr-2003\"\nNon-match examples:\n- \"32 Jan 2003\"\n- \"00 Dec 2003\"",
        "matches": [
            "01 JAN 2003",
            "31/Dec/2002",
            "20-Apr-2003",
            "31\u2005Jul\u20281627",
            "12 JAN 7565",
            "01 JAN 3875",
            "21 JAN 5735",
            "31/Dec/7868",
            "20/Dec/7357",
            "18/Dec/3757",
            "10-Apr-7837",
            "15-Apr-6375",
            "27-Apr-6788"
        ],
        "non_matches": [
            "32 Jan 2003",
            "00 Dec 2003",
            "10 dec 2003",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "JAN 123",
            "FEB 324 2020",
            "JULY 414 1941",
            "DEC 2434"
        ],
        "id": 350,
        "output": [
            {
                "text": " /(([0-9]|[1-9][0-9]|[1-9]0?[1-9])\\/(0?"
            },
            {
                "text": " ([1-9]?[0-9])[-/ ]?([12][0-9]|[0-9])\n\n2. Write"
            },
            {
                "text": " \nvar regex = new Regex(\"^(?:(?!0)[0-9]?[1-9]?[0-9]?["
            },
            {
                "text": "\nvar dateInput = [\"01 Jan 2003\", \"31/Dec/2002\", \"20-Apr-2003\", \"32 Jan 2003\", \"00 Dec 2003\","
            },
            {
                "text": " \n   ^\\s?|/\\s?|\\-|/|\\s?(?:[0-9]{2}|[0-"
            },
            {
                "text": " \n'(?<![0-9])(?![0-9] | [01-3][A-Za-z ] )["
            },
            {
                "text": "\n(20\\d{2}(?:-\\d{2}(?:-\\d{4})?)?)\n\nQuestion 4:\n\nWhat"
            },
            {
                "text": " \n- \"^(0[1-9]|1[012])-(0[1-9]|1[012])[-/.]("
            },
            {
                "text": "\n(\\d{1,2})\\/(\\w{1,2})\\s*[A-Z]\\s*(\\d{4})\n\n"
            },
            {
                "text": " [0-9]{4}-[0-9]{2}-[0-9]{2}\n- \"20-Apr-2003\""
            }
        ]
    },
    {
        "expression": "^[1-9]{1}[0-9]{3}\\s{0,1}?[a-zA-Z]{2}$",
        "raw_prompt": "Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters.",
        "refined_prompt": "Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters.\nMatch examples:\n- \"1234AB\"\n- \"1234 AB\"\n- \"1234 ab\"\nNon-match examples:\n- \"0123AB\"\n- \"123AA\"",
        "matches": [
            "1234AB",
            "1234 AB",
            "1234 ab",
            "1546zZ",
            "1187wD",
            "7615CS",
            "8248rO",
            "4735jM",
            "8618Bo",
            "5668eQ",
            "8597qG",
            "6792Hm",
            "1965VU"
        ],
        "non_matches": [
            "0123AB",
            "123AA",
            "3F22FV",
            "3F2VF",
            "F32V2F",
            "32VF2F",
            "DEFV2",
            "F3V3F3D",
            "D3FD",
            "DFV3FV",
            "3V3FDCV",
            "V3FDFVR"
        ],
        "id": 351,
        "output": [
            {
                "text": " [0-9]{2}[A-Za-z]{2}\\.\n\nA:\n\nSomething like this should work (tested on regex101.com):\n^([0-9][0-9][0-9]["
            },
            {
                "text": " [0-9][0-9AB]{2}[A-Z]\n\nI was able to get the first example to work but I don't know what I need to change for the second question. I can't figure out how to change the"
            },
            {
                "text": " [0-9]{4}[a-zA-Z]{2}\n\nExercise 2: Look for email addresses in a list of input strings and print the number of email addresses found.\nExample: input: [\"Contact us at:"
            },
            {
                "text": " 1+ [A-Z][0-9]{3}[A-Z]\\s[A-Z]\n\n5. (8 points) Suppose you receive an email as follows:\n\n\"Subject Line: Test-Email - Your test"
            },
            {
                "text": " [A-Z]{2}\\d{3}.\n- [\"a\".match(/a/g)]\n- [\"ab\".match(/a/.match(/b/g))]\n- [\"aB\".match(/A/g"
            },
            {
                "text": " /^\\d{3}\\s\\d{2}\\s\\d{2}$/\n\n5. Fill in the blank with the correct term: A regex is a sequence of characters that forms a search pattern.\n\n\n\nTitle: The"
            },
            {
                "text": " [1-9]\\d{5}[a-zA-Z]\n\nThis is what I came up with:\n(1-9)\\\\d{5}[a-zA-Z]\n\nbut it doesn't seem"
            },
            {
                "text": "\n'^[0-9]{4}\\w{2}$'\n\nExercise 2:\n1. What are two benefits of creating a regular expression? \nAnswer: Benefits of creating a regular expression include making the code more readable and saving"
            },
            {
                "text": "\n\\d{4}[a-z]{2}\n\nExercise 2: Write a script that goes to a web page that contains a random list of words. It then identifies which ones are valid URLs.\nAnswer:\nimport urllib"
            },
            {
                "text": " (?<number>\\d{3})(?<letter>[a-zA-Z]){2}\n4.3.3.2.1. What is the difference between a digit (\\d) and a letter ([a-z"
            }
        ]
    },
    {
        "expression": "[\\\\s+,]",
        "raw_prompt": "Simple expression for matching all commas and all whitespace characters: ASCII (13,10,44)",
        "refined_prompt": "Matches any single character that is either a whitespace character (\\s), a plus sign (+), or a comma (,). It's a character class that includes these three specific characters.\nMatch examples:\n- \",\"\n- \"whitespace\"\n- \"carrage returns\"\nNon-match examples:\n- \"cat\"\n- \"jioj\"",
        "matches": [
            ",",
            "whitespace",
            "carrage returns",
            "+",
            ",",
            "+,",
            "spafsd",
            "safsdf",
            "fdsu",
            "sfaaaa",
            "fsioj",
            "fsjoi",
            "fsdjii"
        ],
        "non_matches": [
            "cat",
            "jioj",
            "oib",
            "noi",
            "oi",
            "joi",
            "noiboib",
            "jib",
            "no",
            "inoi",
            "iobiou",
            "bui"
        ],
        "id": 353,
        "output": [
            {
                "text": " (.+)\n\n3. Create a RegEx for matching the term \"Python\".\nAnswer: PYTHON\n\n4. Create a RegEx for matching the"
            },
            {
                "text": " [a-zA-Z0-9-_=.\\s]+\n\nExercise 2:\nMatch any string that contains only letters, numbers, and"
            },
            {
                "text": " [a-zA-Z0-9\\+]\n\nExercise 3: \nWrite a RegEx for the string \"Please enter your name and email"
            },
            {
                "text": " \\w,\\+\n\nExercise 2: Use the following sentence to generate a RegEx that matches any five or more times the letters \"ai\" in a row"
            },
            {
                "text": ".*\\s.*\\s.*\nIn this example, the RegEx pattern \".*\\s.*\\s.*\" will match any string that has 3 whitespace"
            },
            {
                "text": ".+\"\nThe.+ is a character class that includes whitespace and a comma, so it matches any character that is either one of those.\n\n2."
            },
            {
                "text": " \"^(?=.*\\d)(?=.*[a-zA-Z]).{1,30}$\" \n\nCongratulations, young explorer!"
            },
            {
                "text": "\n\\w(\\s|[+]|\\,)\n\nExercise 5: Use your RegEx knowledge to generate a new list that only contains strings that end with"
            },
            {
                "text": " (\\w+),(\\w+),(\\w+)\n3. Write a RegEx for the following:\n\"This is a text string that contains some special characters"
            },
            {
                "text": " [a-zA-Z0-9._-]+\n\nExercise 3:\nWrite a Python function that takes a string and returns a new string with all"
            }
        ]
    },
    {
        "expression": "^(?:(((Jan(uary)?|Ma(r(ch)?|y)|Jul(y)?|Aug(ust)?|Oct(ober)?|Dec(ember)?)\\ 31)|((Jan(uary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sept|Nov|Dec)(ember)?)\\ (0?[1-9]|([12]\\d)|30))|(Feb(ruary)?\\ (0?[1-9]|1\\d|2[0-8]|(29(?=,\\ ((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))))\\,\\ ((1[6-9]|[2-9]\\d)\\d{2}))",
        "raw_prompt": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.",
        "refined_prompt": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003\"\n- \"Apr 31, 1978\"",
        "matches": [
            "Jan 1, 2003",
            "February 29, 2004",
            "November 02, 3202",
            "December 31, 1918",
            "December 22, 1709",
            "Feb 14, 1992",
            "March 14, 1670",
            "Aug 31, 7564",
            "January 31, 1807",
            "December 31, 5076",
            "April 30, 5035",
            "Feb 9, 2801",
            "Dec 30, 8045"
        ],
        "non_matches": [
            "Feb 29, 2003",
            "Apr 31, 1978",
            "jan 33,3333",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 354,
        "output": [
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2003"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            },
            {
                "text": "This RE validate Dates in the MMM dd, yyyy format from Jan 1, 1600 to Dec 31, 9999. The format is as follows: The name or 3 letter abbreivation, without a period, of the month, then a space then the day value then a comma then a space finally the year. The correct number of day are validated for each month include leap years. The name of month is case sensitive.\nMatch examples:\n- \"Jan 1, 2003\"\n- \"February 29, 2004\"\n- \"November 02, 3202\"\nNon-match examples:\n- \"Feb 29, 2004"
            }
        ]
    },
    {
        "expression": "^((31(?!\\ (Feb(ruary)?|Apr(il)?|June?|(Sep(?=\\b|t)t?|Nov)(ember)?)))|((30|29)(?!\\ Feb(ruary)?))|(29(?=\\ Feb(ruary)?\\ (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8])\\ (Jan(uary)?|Feb(ruary)?|Ma(r(ch)?|y)|Apr(il)?|Ju((ly?)|(ne?))|Aug(ust)?|Oct(ober)?|(Sep(?=\\b|t)t?|Nov|Dec)(ember)?)\\ ((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "This RE validates dates in the dd MMM yyyy format. Spaces separate the values.",
        "refined_prompt": "This RE validates dates in the dd MMM yyyy format. Spaces separate the values.\nMatch examples:\n- \"31 January 2003\"\n- \"29 March 2004\"\n- \"29 Feb 2008\"\nNon-match examples:\n- \"Jan 1 2003\"\n- \"31 Sept 2003\"",
        "matches": [
            "31 January 2003",
            "29 March 2004",
            "29 Feb 2008",
            "29 Jul 4950",
            "30 July 4945",
            "29 Jan 2897",
            "20 Aug 1664",
            "06 August 1962",
            "20 Oct 1786",
            "29 Aug 1673",
            "31 January 1785",
            "31 August 1825",
            "13 Dec 1955"
        ],
        "non_matches": [
            "Jan 1 2003",
            "31 Sept 2003",
            "29 February 2003",
            "12/12/2222",
            "15/15/1655",
            "2/3/5235",
            "43-5432",
            "Jan 43 4139",
            "Feb 432 234",
            "March 423 295",
            "July 942384239",
            "Augu 4325"
        ],
        "id": 355,
        "output": [
            {
                "text": " dd/MM/yyyy, dd/MM/yyyy, dd/MM/yyyy\n\n5. Use the REGEX from Exercise 4 to validate the following values in a field called \"dates\". Only valid dates will be admitted."
            },
            {
                "text": " \\d{1,2}[\\s-]\\d{4}[\\s-]\\d{2,3}\n\nExercise 2: \nWrite a RegEx that will detect if an email address is valid"
            },
            {
                "text": " The date should be between the 1st of a month and the 31st of a month, with at least one space between the two parts of the date.\n\n2. Parse the below date string and convert it to a dictionary of key"
            },
            {
                "text": " \\b[A-Z][a-z]{3}\\sJan[\\s]?[\\s]?[1][0-9]{3}[\\s]?[0-9]{4}\\b"
            },
            {
                "text": "\n\\b(?P<month>\\w{3}\\s)?(?P<day>\\w{2})\\s?(?P<year>\\d{4})\\b\n\nExercise 4:\n"
            },
            {
                "text": "\nimport re\n\ndef extract_dates(d):\n    pattern = r'\\b(?P<date>.+)\\s*\\bDATE\\b'\n    return re.findall(pattern, d)\n"
            },
            {
                "text": "\n^[0-9]{1,2}\\s[A-Z][A-Za-z]+[0-9]{4}$\n\"\\d{1,2}[ \\t]?[A"
            },
            {
                "text": "\n\n```python\nimport re\n\ndef validate_date(date):\n    reg_exp_valid_date = r\"(\\b\\d{1,2}\\s\\w{3}\\b)\"\n    if re"
            },
            {
                "text": "\n(?m)(^(?:(?P<day>\\d{1,2})\\s(?P<month>\\w{3}\\s(?P<year>\\d{4}))?)?$"
            },
            {
                "text": " (?i)(?P<month>[A-Za-z]{2}).(?P<day>\\d{1,2}).(?P<year>\\d{4})\n\n2. Write"
            }
        ]
    },
    {
        "expression": "^(?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)$",
        "raw_prompt": "This RE validate the full name of the months.",
        "refined_prompt": "This RE validate the full name of the months.\nMatch examples:\n- \"January\"\n- \"May\"\n- \"October\"\nNon-match examples:\n- \"Jan\"\n- \"Septem\"",
        "matches": [
            "January",
            "May",
            "October",
            "March",
            "February",
            "August",
            "April",
            "June",
            "July",
            "September",
            "November",
            "December"
        ],
        "non_matches": [
            "Jan",
            "Septem",
            "Octo",
            "Mastercard",
            "sfalijad234",
            "aug",
            "jan",
            "dec",
            "oct",
            "febru",
            "apr",
            "abc"
        ],
        "id": 356,
        "output": [
            {
                "text": " (Regex) (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\n- \"January\" Generate a RegEx for this description. \nAnswer: (Regex) (?:Jan|Feb|Mar|Apr|May|Jun|Jul|"
            },
            {
                "text": " [\\w]{3}\\s?[a-zA-Z]|[a-zA-Z]{3}\\s?[0-9]{2}\n\nExercise 1: Create a function that takes a string of text and returns true if it follows any of the format rules, and false otherwise"
            },
            {
                "text": "\n\n``` python\nimport re\nmonths = [\"January\", \"May\", \"October\", \"Septem\"]\npattern = '[A-Z][a-z]*'\nexamples = []\nnon_match = []\nfor month in months:\n    regex = pattern\n    if len(month) =="
            },
            {
                "text": "\n\n```python\nimport re\n\ndef validate_dates(dates: list):\n    for i in range(len(dates)):\n        if not re.match(r'^[A-Z][a-z]+\\s+[0-9]{2,3}$', dates[i"
            },
            {
                "text": "\n- ^(?P<month>jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$\n- ^[a-zA-Z]{2}|[a-z]{3}$\n\n3. Using a list"
            },
            {
                "text": "\n[0-9]{1,2}[-/.][0-9]{1,2}[-/.][0-9]{1,2}[-/.][0-9]{1,2}[-/.][0-9]{1,2}[-"
            },
            {
                "text": "\nRegEx pattern would be (\\w{3}[a-z]?)-([a-z]?)\n\nExercise4:\n\nWrite a Regular Expression pattern that can extract the first three characters of a string. \n\nSolution:\n\nimport re\n\ntest_string = \"1234\"\n"
            },
            {
                "text": "\n[a-z]+[A-Z][a-z]+[A-Z]\n\n3. Using the example below, generate a dictionary containing the months and their abbreviations, and then use it to replace \"January\" with \"Jan\" in the text.\ntext = \"I like to eat my favorite food all"
            },
            {
                "text": " The pattern should be: [A-L]?[0-9]?[0-9]\n\n3. You have the following string: \"The price is $10,000, and the discount is $2,000.\"\nMatch examples:\n- \"The price is $\"\n- \"The\"\nNon"
            },
            {
                "text": " \n#[0-9]\\w*[a-z]\\w*\n\n5. Create a RegEx to validate a phone number given in the format XXX-XXX-XXXX\nMatch examples:\n- \"123-456-7890\"\n- \"911-555-1234\"\nNon-match"
            }
        ]
    },
    {
        "expression": "^1+0+$",
        "raw_prompt": "A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask.",
        "refined_prompt": "A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask.\nMatch examples:\n- \"10\"\n- \"110\"\n- \"1100\"\nNon-match examples:\n- \"0\"\n- \"01\"",
        "matches": [
            "10",
            "110",
            "1100",
            "1110",
            "111000",
            "1100000",
            "11111000",
            "11000000",
            "10000",
            "11110",
            "11111110000",
            "110000000000",
            "111100000000"
        ],
        "non_matches": [
            "0",
            "01",
            "101",
            "10101010",
            "01010100",
            "010010",
            "101",
            "010",
            "10010101",
            "1010101011010011",
            "010",
            "10101010101"
        ],
        "id": 358,
        "output": [
            {
                "text": " The first and second examples match the regex, the third and fourth examples do not; and the fifth example does not.\n\nExample 2:\nDescription"
            },
            {
                "text": " (0|1)(0|1)(0|1)(0|1)\n- \"011\"\nAnswer: (0|1)(1"
            },
            {
                "text": " ^[1]{0,}\\1{0,}$\n\n# 5.6.6 How to Use Regex for Address Val"
            },
            {
                "text": " (10|0111)\n\nI used the code below to generate a RegEx for the above example.\nimport re\n\ndef check_"
            },
            {
                "text": " \"^1[01]*$\"\n\n2. Write a Python program to match any IPv4 address that contains at least one group of consecutive"
            },
            {
                "text": " /^1(0*1)+1\\z/\n- \"000\"\nAnswer: /^0(0*0)+0\\z"
            },
            {
                "text": " ^([1][0-9]|2[0-4]|25[0-5])$\n\nA:\n\nThis regular"
            },
            {
                "text": " the first character in the string must be a 1.\n\n3. Write a function that takes a string representing a MAC address and a mask and returns"
            },
            {
                "text": " /^(0*1[0-9]*1+0*0[0-9]*0+1*0[0-"
            },
            {
                "text": " (?:\\b(?:0|1){3})(?:\\b(?:0|1){3}$)\n- \"10\""
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((1[6-9]|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "dd/MM/yyyy with leap years 100% integrated\nValid years : from 1600 to 9999\nAs usual, many tests have been made.\nI think this one should be fine.",
        "refined_prompt": "dd/MM/yyyy with leap years integrated\r\nValid years : from 1600 to 9999\nMatch examples:\n- \"29/02/2000\"\n- \"30/04/2003\"\n- \"01/01/2003\"\nNon-match examples:\n- \"29/02/2001\"\n- \"30-04-2003\"",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003",
            "02/12/4845",
            "21/02/1861",
            "30/03/7831",
            "20/02/9516",
            "06/02/1764",
            "09/02/5152",
            "30/12/6866",
            "03/07/1839",
            "03/07/1982",
            "08/04/1748"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/2003",
            "12/123/4322",
            "234/423/5243",
            "233/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 359,
        "output": [
            {
                "text": " (\\d+)/(\\d+)/(\\d{4})( \\d{2})/(\\d{2}) \n\nExercise 2: \nGiven a list of strings"
            },
            {
                "text": " [^0-9]\\d/[^0-9]\\d/[^0-9]\\d/[^0-9]\\d/[^0-"
            },
            {
                "text": " \"^\\d{1,2}\\/\\d{1,2}\\/(\\d{4})([A-Za-z]{3})?$\"\n-"
            },
            {
                "text": " \\d{2}/\\d{2}/\\d{4} with leap years integrated.\r\n- \"31/02/2000\"\r\n- \"01/02/"
            },
            {
                "text": " /\\d|[1-9]\\d|(10)-(1)+\\d|(20)-(1)+\\d/g\r\n- \"01/01/2002"
            },
            {
                "text": " \n(0[1-9]|[12][0-9]|3[01])\\/([0-2]?[0-9]|3[01])\\/"
            },
            {
                "text": " \\b[1-9]\\d{0,2}[-/](0[1-9]|1[012])[-/](0[1-9]|"
            },
            {
                "text": " \r\n\nimport re\r\npattern = re.compile(r'^\\d{2}/\\d{2}/\\d{4}$')\r\n\r"
            },
            {
                "text": " (29/02/)([0-9]{2}|[1-9]{3})([0-9]{4})\\/([0-9]{2"
            },
            {
                "text": " \n(1|2[0-9])\\/(1|2[0-9])\\/(19[6-9]|20[0-3]) \n\nA"
            }
        ]
    },
    {
        "expression": "^\\d{1,5}(\\.\\d{1,2})?$",
        "raw_prompt": "validate a number 5 digits and 2 decimal places allowing zero",
        "refined_prompt": "Validates numbers with up to five digits, including optional decimal places with one or two decimal digits.\nMatch examples:\n- \"12345.67\"\n- \"0\"\n- \"0.1\"\nNon-match examples:\n- \"123456.78\"\n- \"123456.789\"",
        "matches": [
            "12345.67",
            "0",
            "0.1",
            "86476.4",
            "66995",
            "586.94",
            "84832",
            "101.42",
            "8",
            "63.7",
            "30.14",
            "059",
            "1"
        ],
        "non_matches": [
            "123456.78",
            "123456.789",
            ".1",
            "-123",
            "2346-2345-2435",
            "9841562.65123",
            "561.456123",
            "5416561.456123",
            ".4898979",
            "341.431v4f3.fv1",
            "9/9/9",
            "32542 //"
        ],
        "id": 360,
        "output": [
            {
                "text": " (\\d{1,5}\\.\\d{1,2})\n\nExercise 2:\nMatch examples:\n- \"AB\"\n- \"CD\"\n- \"CDE\"\n- \"FGHIJ\""
            },
            {
                "text": " [\\d]{1,6}[\\.]?[\\d]{1,2}\n\nExercise 2: Designing a Website\nImagine you are designing a website for a clothing store. As a web developer,"
            },
            {
                "text": " ^[0-9]{5,5}(0\\.0?[0-9]?)?$\n\nExercise 2:\nGenerate a RegEx for this description. \nMatch examples:\n- \"1"
            },
            {
                "text": "\n(?= [0-9]{0,4}(?:\\.[0-9]{0,2})? )|(?:[0-9]{0,2}(?:[0-9]"
            },
            {
                "text": " The pattern should be \"[0-9]{1,5}\\.?[0-9]{1,2}\".\n\nExercise 2: \nCreate a RegEx pattern that matches any string that ends with \"ing"
            },
            {
                "text": "\n- r\"(^\\d{1,5}(\\.\\d{1,2})?$)\"\n- r\"^\\d+$\"\n\nHost 1: Great job, audience! For our third quiz,"
            },
            {
                "text": " /^[0-9]{0,5}(.[0-9]{1,2})?$/\n\n\n\nQuestion 3: Emily has 4 times as many marbles as John. If John has 20 mar"
            },
            {
                "text": " \"^[1-9]\\d*[1-9]\\.?[0-9]?$\"\n\nExercise 3: Match a string that is a valid IPv4 address.\nAnswer: \"192.168"
            },
            {
                "text": " (example) \\\\d{5}.\\\\d{2}\n- \"12.345.678\"Generate a RegEx for this description. \nAnswer: (example).\\\\d{3}.\\\\d{2}"
            },
            {
                "text": " (0?\\d\\.\\d+)|(^0$)|(^\\d+\\.?\\d)\n\nExercise 3: \nWhat is the difference between an anchor and a non-anchor group in a"
            }
        ]
    },
    {
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,5}(\\.\\d{1,2})?$",
        "raw_prompt": "validates to 5 digits and 2 decimal places but not allowing zero",
        "refined_prompt": "this regular expression validates numbers with up to five digits, including optional decimal places with one or two decimal digits, while excluding inputs that consist solely of zeros or zero decimals.\nMatch examples:\n- \"12345.12\"\n- \"0.5\"\n- \"7\"\nNon-match examples:\n- \"123456.12\"\n- \"1.234\"",
        "matches": [
            "12345.12",
            "0.5",
            "7",
            "79",
            "4362.3",
            "86",
            "9948.5",
            "7.76",
            "4658.9",
            "4",
            "8.6",
            "11349",
            "516"
        ],
        "non_matches": [
            "123456.12",
            "1.234",
            ".1",
            "-123",
            "234/423/5243",
            "43.v234",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "1-1-2",
            "9/9/9",
            "32542.456234"
        ],
        "id": 361,
        "output": [
            {
                "text": "\n^[0-9]{3,6}\\.[0-9]{1,2}$\n\nExercise 3: \nUse"
            },
            {
                "text": " ^\\d{1,5}(\\.\\d{1,2})?$\n\n2. Write a Python function that takes a string input"
            },
            {
                "text": " [0-9]{1,5}\\.?[0-9]{1,2} \nExercise 3: Using the previous example"
            },
            {
                "text": " This regular expression validates numbers with up to five digits, including optional decimal places with one or two decimal digits. It should not accept inputs that consist solely of"
            },
            {
                "text": " [0-9]+(.[0-9]{1,2})?\n\nExercise 3: Create a RegEx to identify all of the"
            },
            {
                "text": " A \"^\\d{1,2}\\.\\d{1,2}$\" RegEx validates numbers with two decimal places.\n"
            },
            {
                "text": " [^\\d.]+[^\\d.]+\nExamples in Daily Life:\n- Validating phone number formats\n- Password validators\n-"
            },
            {
                "text": " [0-9]{1,5}\\.?[0-9]{2,3}(\\.|$)\n\nExercise 4"
            },
            {
                "text": " (\\d{1,3}\\.?[0-9]{1,2}|\\d+.?)\n(\\d{1,"
            },
            {
                "text": " A string that contains two numbers, both more than five digits, including one or two decimal places\n\n2. Suppose you want to create a function that filters"
            }
        ]
    },
    {
        "expression": "^[^<>`~!/@\\#}$%:;)(_^{&*=|'+]+$",
        "raw_prompt": "A general string validation to insure that NO malicious code or specified characters are passed through user input. This will allow you to input any characters except those specified. The expression above does not allow user input of &lt;&gt;`~!/@\\#}$%:;)(_^{&amp;*=|'+. Input as many invalid characters you wish to deny. This really works!",
        "refined_prompt": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~ ! / @ \\ # } $ % : ; ) ( _ ^ { & * = | ' +.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"",
        "matches": [
            "This is a test",
            "fdsjkfsd hkshjdf",
            "hjfds hfjsdkh",
            "huifd879h",
            "h98",
            "h89",
            "h98h",
            "98h9h",
            "f7g",
            "98gf57",
            "f8h9",
            "h09h98g",
            "g98g98g"
        ],
        "non_matches": [
            "^&GYGH",
            "<br>",
            "That's it",
            "F^TYVGH",
            "9hi\"hfieds'",
            "'fdgdf",
            "huhiyfgdyi'",
            "'gfs$#ERFW",
            "gyi'",
            "idygiyfd'giyd97r@#E",
            "98g'RF$E",
            "$#EFg98g98g*&U\"''"
        ],
        "id": 362,
        "output": [
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx pattern"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx for"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx for"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx.\""
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx that"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx to"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx to"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx that"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx that"
            },
            {
                "text": "This regular expression checks if a given string contains only characters other than the specified special characters. If any of these special characters are found in the string, it will not be matched. These characters include < > ` ~! / @ \\ # } $ % : ; ) ( _ ^ { & * = |'+.\nMatch examples:\n- \"This is a test\"\n- \"fdsjkfsd hkshjdf\"\n- \"hjfds hfjsdkh\"\nNon-match examples:\n- \"^&GYGH\"\n- \"<br>\"Generate a RegEx Pattern"
            }
        ]
    },
    {
        "expression": "^([\\(]{1}[0-9]{3}[\\)]{1}[\\.| |\\-]{0,1}|^[0-9]{3}[\\.|\\-| ]?)?[0-9]{3}(\\.|\\-| )?[0-9]{4}$",
        "raw_prompt": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.",
        "refined_prompt": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations.\nMatch examples:\n- \"5551212\"\n- \"614555-1212\"\n- \"(614)555-1212\"\nNon-match examples:\n- \"A12-5555\"\n- \"(614-555-1212\"",
        "matches": [
            "5551212",
            "614555-1212",
            "(614)555-1212",
            "(842)993 0045",
            "(283)2708210",
            "186198 3473",
            "(849)-8231974",
            "823-864-6500",
            "6881622666",
            "929-5392",
            "808-1305",
            "488787-0909",
            "(629)0196963"
        ],
        "non_matches": [
            "A12-5555",
            "(614-555-1212",
            "555*1212",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 363,
        "output": [
            {
                "text": " (?<=\\(.|[^/]|$)\\s[0-9]{"
            },
            {
                "text": " ^[0-9]{5}[-.]?[0-9]{5}["
            },
            {
                "text": " The RegEx should match a US phone number in the form \"(555) 555-1212\". \n"
            },
            {
                "text": " ^(\\d{3}-)?\\d{3}-\\d{4}$\n\n"
            },
            {
                "text": " /\n\nA:\n\n\\( or \\| should be escaped by preceding it with backslash"
            },
            {
                "text": " /^\\d{3}-?\\d{3}-?\\d{4}/"
            },
            {
                "text": "\n    ^[^a-z]?(?P<mobile_number>\\d{3"
            },
            {
                "text": "\n[0-9]{10}-[0-9]{10}\n\n3. Re"
            },
            {
                "text": "\n(?:^|[^-])(55[1212]|[12]{2}"
            },
            {
                "text": "\n^[0-9]{3}|[0-9]{3}[-.]"
            }
        ]
    },
    {
        "expression": "^([1-9]{1}[0-9]{3}[,]?)*([1-9]{1}[0-9]{3})$",
        "raw_prompt": "Matches a comma-seperated list of year(s).",
        "refined_prompt": "Matches a comma-seperated list of year(s).\nMatch examples:\n- \"1999,2001,1988\"\n- \"1999\"\n- \"4895\"\nNon-match examples:\n- \"0199,1997\"\n- \"0199\"",
        "matches": [
            "1999,2001,1988",
            "1999",
            "4895",
            "1984",
            "4896,4856",
            "4568",
            "9846",
            "4895,4985,8946",
            "8467",
            "7897",
            "7835",
            "1894,4189,1894,7984",
            "4894,8793"
        ],
        "non_matches": [
            "0199,1997",
            "0199",
            "1999,",
            "156915,",
            "15981,",
            "65165,",
            "46484354,4894fsd",
            "/5/5/20022",
            "000-000",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 364,
        "output": [
            {
                "text": " r'^\\d{4}(-\\d{2})?$'\nThe solution uses a character class to match either 4 digits or an optional 2 digits. The question mark after the last digit indicates an optional match. This ensures that years can be entered with leading z"
            },
            {
                "text": " (\\d{4})[, ](\\d{4})\\r?\\n\n\n2. Write a function that will generate a list of all email addresses in a specified region.\n3. Write a function that will generate a list of phone numbers in a specified"
            },
            {
                "text": " This is a good exercise in understanding the specific rules of RegEx for matching comma-separated lists of year(s).\n\n3. Write a RegEx to match only the numbers from a string. \nAnswer:\n[\\d]\nThis will match any digit"
            },
            {
                "text": " (4) ([0-9]{4}),(2) ([0-9]{2})\n\nI thought the best way to start would be to use a lookahead, but I'm not quite sure how to implement that.\n\nA:\n\n"
            },
            {
                "text": "  ((?:(?<year>\\d\\d\\d\\d,){1,2})(?:,\\s){0,1}(?:\\s)(?:\\d\\d\\d,{0,2}))|(?:(?<"
            },
            {
                "text": " ^([0-9]+(,[0-9]+)?|[0-9]+)$\n\n5. Write a regular expression that will match a string of text that begins and ends with a period.\n\nAnswer: ^[^.]*\\.$\n"
            },
            {
                "text": " \".*,.*,.*\"\n\nExercise 2: Write a RegEx to match dates in the following formats:\n- \"January 1, 2022\"\n- \"December 31, 1998\"\n- \"November 23, 2019\"\n- \"September 20, 1999\""
            },
            {
                "text": " A RegEx that matches a comma-seperated list of year(s) would look like:\n(([0-9][0-9][0-9])|([0-9][0-9][0-9][0-9]))\n\n"
            },
            {
                "text": "\nimport re\ny_range = re.compile('\\d{4}-\\d{2}')\nprint y_range.findall('0199,1997')\nprint y_range.findall('0199')\nprint y_range."
            },
            {
                "text": "\n\n```python\nimport re\n\ndef matches_regex(regex:str, string:str) -> bool:\n    \"\"\"Checks if a string matches a regex\n    \n    Args:\n        regex (str): The regex to check against"
            }
        ]
    },
    {
        "expression": "^(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\\d{4}))|((02)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\\d{4}))|((02)(\\.|-|\\/)(29)([-./])([02468][048]00))|((02)([-./])(29)([-./])([13579][26]00))|((02)([-./])(29)([-./])([0-9][0-9][0][48]))|((02)([-./])(29)([-./])([0-9][0-9][2468][048]))|((02)([-./])(29)([-./])([0-9][0-9][13579][26])))$",
        "raw_prompt": "This works for all accept 01/01/0000 mainly 0000. can anybody suggest a solution.",
        "refined_prompt": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12.\r\nDD (day) depends on the month and can be 01-31.\r\nYYYY (year) must be a four-digit number.\r\nIt considers leap years for February (02) by allowing 29 days in certain cases.\r\n\r\nIt handles different separators between date components (e.g., '-', '/', '.').\r\n\r\nIt accounts for various scenarios related to leap years, including divisibility by 4, 100, and 400.\nMatch examples:\n- \"01/01/2001\"\n- \"02/29-2800\"\n- \"02/29/2108\"\nNon-match examples:\n- \"01/01/00000\"\n- \"52/2/54/245\"",
        "matches": [
            "01/01/2001",
            "02/29-2800",
            "02/29/2108",
            "11-26/9165",
            "02/29-7600",
            "02.29/2800",
            "02/29-5600",
            "02.04.1914",
            "02.29/0152",
            "12.23.6006",
            "11.24-1607",
            "11/13-2502",
            "10.08.0722"
        ],
        "non_matches": [
            "01/01/00000",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "234/423/5243",
            "2/3/5235",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "354/243/542",
            "9/9/9",
            "12/132/90"
        ],
        "id": 366,
        "output": [
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12 ("
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12 ("
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12 ("
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12 ("
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12 or"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12,"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12\r"
            },
            {
                "text": "Checks for various date formats, valid months and days, leap years, and different separators. It ensures that the input follows a valid date format and is suitable for date validation in different contexts.\r\nThe regular expression matches dates in various formats:\r\n\r\nMM/DD/YYYY\r\nMM-DD-YYYY\r\nMM.YYYY/DD\r\nYYYY/MM/DD\r\nYYYY-MM-DD\r\nYYYY.MM.DD\r\nIt enforces specific rules for each part of the date:\r\n\r\nMM (month) can be 01-12 or"
            }
        ]
    },
    {
        "expression": "^((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))$",
        "raw_prompt": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.",
        "refined_prompt": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00501\"\n- \"84118-3423\"\n- \"n3a 3B7\"\nNon-match examples:\n- \"501-342\"\n- \"123324\"",
        "matches": [
            "00501",
            "84118-3423",
            "n3a 3B7",
            "07743-6002",
            "80135-5335",
            "36898-1873",
            "55717-8018",
            "04808",
            "A8g8o2",
            "33144",
            "V0k0a4",
            "66972",
            "87740-7005"
        ],
        "non_matches": [
            "501-342",
            "123324",
            "Q4B 5C5",
            "Mastercard",
            "234/423/5243",
            "43.v234",
            "/5/5/5",
            "2546dgwre",
            "324df",
            "adfa2",
            "abc111def",
            "99999@gmail"
        ],
        "id": 367,
        "output": [
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"005C"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00520"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00543"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"005E"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00511"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00511"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00543"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00567"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00501"
            },
            {
                "text": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes. It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long. Canadain postal codes can contain a space and take form of A1A 1A1. The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y.\nMatch examples:\n- \"00534"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z_]{1}[a-zA-Z0-9_]+$",
        "raw_prompt": "This expression validates for valid C# or C++ identifier",
        "refined_prompt": "This expression validates for valid C# or C++ identifier\nMatch examples:\n- \"_12ffsd\"\n- \"abcd123\"\n- \"abcd_23232\"\nNon-match examples:\n- \"..//\"\n- \"..13e232\"",
        "matches": [
            "_12ffsd",
            "abcd123",
            "abcd_23232",
            "asdfa12",
            "fty67",
            "gy78g",
            "gy76g",
            "gyg7g78g",
            "g78guy",
            "_giuy24",
            "_sfdih238",
            "gy789fsu",
            "yugfsd78"
        ],
        "non_matches": [
            "..//",
            "..13e232",
            "abcd 3232",
            "8f7sdh h89fdsh",
            "hfusdh98shdf98h fhsu",
            "h h89fh",
            "huh8uh98h h89h09ju",
            "90u09u09",
            "90ut67f",
            "76g67",
            "(0xx12) 62509",
            "0j0jweBBBB"
        ],
        "id": 369,
        "output": [
            {
                "text": " (.*?)\\.(\\d{3}(?:_|x)){5,}$\n\n2. Write a Python script that parses a CSV file that contains a list of file paths. The script should validate that each file path is a valid directory path"
            },
            {
                "text": " ^[A-Za-z_0-9]+(_[A-Za-z0-9]+)*\n\nA:\n\ntry this regex, it will match valid c# or c++ idenifiers\n^[A-Za"
            },
            {
                "text": " a-zA-Z_0-9.\n\n5. Write a Python program that matches a string that contains only lowercase letters, numbers or underscores.\n\n# Solution:\nimport re\n\nstring = \"abcde12345\"\n\n# Check"
            },
            {
                "text": "\n\\d+[A-Za-z]?\\d+\n\nExercise 2:\nCreate a RegEx to validate that a given string starts with a lowercase letter, is followed by one or more digits, and is between 1 to 20 characters long"
            },
            {
                "text": " \n\n(?<=^|[^0-9a-zA-Z_])([a-zA-Z0-9_])(?=|$)\n\nExercise 2:\nGiven a string, write a C#"
            },
            {
                "text": " C# and C++ IDENTIFIER is matched.\n\nThe next match example shows the use of regex to match email addresses. \nThis regex will match an email address in the form of:\n- username@domain.com\n- username.domain.com"
            },
            {
                "text": "\n(?<!^)([A-Za-z]\\w*)(?!$)\n\nIn this question, we have learned how to apply lookarounds and backreferences in regular expressions. We can use lookarounds to ensure that a string"
            },
            {
                "text": "\n^[a-zA-Z_]([a-zA-Z0-9_]+)$\n\nExercise 2:\nReplace all the spaces with hyphens in the following string: \"This is a test string. \"\nAnswer:"
            },
            {
                "text": " /[a-zA-Z0-9_]+/g\n\n3. The task is to create a regular expression to validate a mobile number. The number must be 11 digits long and can only contain the following characters: 0,1,2,3,"
            },
            {
                "text": "\n[a-zA-Z0-9]{2,}\n\n3. Write a Regular Expression that validates for the following email formats:\n- \"info@company.com\"\n- \"info@company.co.uk\"\n- \""
            }
        ]
    },
    {
        "expression": "^[1]$|^[3]$|^[4]$|^[6]$|^[1]0$",
        "raw_prompt": "This will match single numbers,the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only.\nThis matches inclusively.",
        "refined_prompt": "This will match single number, the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only. This matches inclusively.\nMatch examples:\n- \"1\"\n- \"4\"\n- \"10\"\nNon-match examples:\n- \"13\"\n- \"2\"",
        "matches": [
            "1",
            "4",
            "10",
            "3",
            "6"
        ],
        "non_matches": [
            "13",
            "2",
            "0",
            "5",
            "7",
            "8",
            "9",
            "8495",
            "485684",
            "4856",
            "4234",
            "56465"
        ],
        "id": 370,
        "output": [
            {
                "text": " [0-9]\n- \"12345\"\n- \"123456\"\n- \"1234abcd\"\n-"
            },
            {
                "text": " ^(?:[1346])|(?:\\d+$)\n\nA:\n\nYou will need to repeat the"
            },
            {
                "text": " 1(|[13]|[46])\n- \"1345\"\n- \"1213454\"\n- \"1"
            },
            {
                "text": " ^(12|\\d{1,2}|[1-9])(?=(\\d{3})+(?!"
            },
            {
                "text": " [1-9]|[1-9][0-9]|1[0-9]\n(13) Match"
            },
            {
                "text": " ^[1-9][0-9]|1[0-9][0-9]|[1-9]["
            },
            {
                "text": " [1-5]\n- \"11\"\n- \"23\"\n\nA:\n\nTry this\n(\\\\d"
            },
            {
                "text": " ([1-9]|[1-9][0-9]|1|2|3|4|5|6"
            },
            {
                "text": " 1,  2,  3,  4,  5,  6,  7,  8,  9,  "
            },
            {
                "text": "\n[12][456]|[10][0-9]\n\nA:\n\nWhat about the string:\n\""
            }
        ]
    },
    {
        "expression": "^[A]$|^[C]$|^[D]$|^[F]$|^[H]$|^[K]$|^[L]$|^[M]$|^[O]$|^[P]$",
        "raw_prompt": "This is for matching Single uppercase Letters inclusively",
        "refined_prompt": "matches a single uppercase letter from the set {A, C, D, F, H, K, L, M, O, P}.\nMatch examples:\n- \"A\"\n- \"F\"\n- \"P\"\nNon-match examples:\n- \"a\"\n- \"b\"",
        "matches": [
            "A",
            "F",
            "P",
            "H",
            "M",
            "C",
            "O",
            "L",
            "D",
            "K"
        ],
        "non_matches": [
            "a",
            "b",
            "cd",
            "fadsf",
            "afd",
            "f",
            "d",
            "g",
            "B",
            "Z",
            "Y",
            "X"
        ],
        "id": 371,
        "output": [
            {
                "text": " (\\u0041-\\u005a|\\u0061-\\u007a|\\u0077-\\u007f|\\u0081-\\u0088|\\u0091-\\u"
            },
            {
                "text": " ([A-F]|[KM]|[P])\n\nExercise 3: Creating a Dictionary\nCreate a dictionary using the same words as in Example 2. The keys are the letters in the set {A, C"
            },
            {
                "text": " [A-F]{0,1}[HB]\n- Write a RegEx to identify when a string ends with one of these words:\n- \"ing\"\n- \"ed\"\n- \"ed\"\n-"
            },
            {
                "text": " r'[A-Z]'\n\nExercise 2:\nUsing the RegEx r'\\d{1,3}-\\d{1,3}-\\d{4}' generate a RegEx to validate"
            },
            {
                "text": " ([A-Z]|[K-Z]|[M-Z])\n\nExercise 3:\nMatch the following phrases using the RegEx \"A|B|C\":\n- I have a red car.\n"
            },
            {
                "text": "\nmatches_1 = re.findall('[A-Z]', string)\nprint(matches_1)\n\n# Output: ['A', 'F', 'P']\n\n# Exercise 2:\n"
            },
            {
                "text": "\n[A-Z].*[a-z]$\n\nExercise 2:\nUse a RegEx to extract all the email addresses in the following text:\n\"Please contact us at service@example.com or sales"
            },
            {
                "text": " [a-fA-F0-9]\n\n3. Create a Pandas data frame containing \"IP\" and \"ports\" columns.\nWrite a Python script to match all IP addresses that have a port of 80 only"
            },
            {
                "text": ".*[A-H][a-h]*\n\nExercise 4: Create a Python function, \"validate_password(password)\" that takes a string as the password and returns a Boolean value based on whether the password"
            },
            {
                "text": " [A-D]\n\n3. Write a Python program that replaces all vowels in a string with the letter 'X'.\nAnswer:\nstring = \"The quick brown fox jumps over the lazy dog.\"\nnew_string"
            }
        ]
    },
    {
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "raw_prompt": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "refined_prompt": "This regex pattern is designed to match a numeric value that can be either a positive integer, a positive decimal number, zero, or a positive decimal number less than 1 with up to two decimal places. It allows for an optional minus sign at the beginning to indicate negative numbers.\nMatch examples:\n- \"123\"\n- \"123.54\"\n- \"-.54\"\nNon-match examples:\n- \"123.543\"\n- \"0012\"",
        "matches": [
            "123",
            "123.54",
            "-.54",
            "49",
            "489",
            "9",
            "8",
            "7",
            "64",
            "54",
            "45.15",
            "48.97",
            "98.51"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12",
            "-123.423",
            "51:534",
            "$23.454",
            "56.153153",
            "254627g.256",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 374,
        "output": [
            {
                "text": " [\\d.]{1,2}\n\nExercise 2:\nWhat is"
            },
            {
                "text": " [0-9]\\.[0-9]{1,2}|["
            },
            {
                "text": " \n\\d+(\\.\\d{1,2})?\"\n\nEx"
            },
            {
                "text": " The RegEx for this description is \"^\\d+\\.\\d{2,"
            },
            {
                "text": " [a-zA-Z0-9]+[a-z0-9"
            },
            {
                "text": " (?im)(^[0-9 -]*\\.?[0-9"
            },
            {
                "text": " \n(?P<value>[1-9][0-9]*("
            },
            {
                "text": " ^[+-]?(\\d*\\.)?\\d+$\nH"
            },
            {
                "text": " ^[0-9]{1,3}(?:\\.[0-9"
            },
            {
                "text": " A RegEx pattern that matches a string that starts with one to three digits, followed by"
            }
        ]
    },
    {
        "expression": "<[^>]*>",
        "raw_prompt": "HTML Pattern Matching\nPLEASE HELP\n/&lt;[^&gt;]*&gt;/ig\nThe above pattern is only successful when html tag are simple (they don't include any javascript). This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;. It will not match the entire open n close sign.\nHow do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign and not when it just see a &gt; within a '' or &quot;&quot;.\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;\nAny help would be greatly appreciate. Thanks a whole lot.\nLogan",
        "refined_prompt": "This regex pattern matches HTML/XML tags by looking for text enclosed in angle brackets (< and >), allowing for any characters ([^>]*) between them.\nMatch examples:\n- \"<html>\"\n- \"<div>\"\n- \"<a href=\"https://www.example.com\">\"\nNon-match examples:\n- \"abc\"\n- \"2fed2\"",
        "matches": [
            "<html>",
            "<div>",
            "<a href=\"https://www.example.com\">",
            "<p class=\"paragraph\">",
            "<>",
            "<img src=\"image.jpg\" alt=\"Example Image\">",
            "<h1>Title</h1>",
            "<span style=\"color: red;\">",
            "<br />",
            "<ul><li>Item 1</li><li>Item 2</li></ul>",
            "<!-- This is a comment -->",
            "<input type=\"text\" name=\"username\">",
            "<table><tr><td>Data 1</td><td>Data 2</td></tr></table>"
        ],
        "non_matches": [
            "abc",
            "2fed2",
            "df22",
            "f2eg",
            "g8yu<gu",
            "9hu09jiOKIOK",
            "9JIMO<",
            "H*(UIJMKO<",
            "(*IKO<MNH",
            "(IOK<HJM",
            "<MHJK",
            "K<HJM"
        ],
        "id": 381,
        "output": [
            {
                "text": " \"([^>]*)<\"\n\n2. Write a RegEx pattern to match any string that starts with either \"a\" or \"A\", followed by any number of"
            },
            {
                "text": " (\\d+)\nI tried to match a RegEx pattern that matches HTML/XML tags by looking for text enclosed in angle brackets (< and >), allowing for any characters"
            },
            {
                "text": "\nThe following regex pattern matches HTML/XML tags by looking for text enclosed in angle brackets (< and >), allowing for any characters ([^>]*) between them.\nThis"
            },
            {
                "text": " ^[^<>=]*<[^>]+>$\n\nExercise 2: \nWrite a RegEx pattern that matches only plain text, i.e"
            },
            {
                "text": " ([^a-zA-Z0-9 ]+).\n\nExercise 2: Write a Python function that takes a string and returns its length.\nAnswer:"
            },
            {
                "text": " (.+?)</(.+?)> \n\nCode:\nimport re\n\n# Match any text enclosed in angle brackets (< and >)\ntag = \"(."
            },
            {
                "text": " ^(?![^>]*>)([^>]*)(?:<|$)\n\nExercise 3:\nCreate a function that takes a string and a character"
            },
            {
                "text": " \n\n/<(.+?)>/g\n\nExercise 3: Find all email addresses on a webpage.\n\nHint: Look for patterns that match"
            },
            {
                "text": " [a-zA-Z0-9\\s.]+\n\n3. Write a Python function that takes a string and returns a list of words that start with a"
            },
            {
                "text": " \\<[^>]*>\n\n6. How do you use preg_quote() function to escape special characters in a string?\nAnswer:\nTo escape special"
            }
        ]
    },
    {
        "expression": "^([0-9]*\\-?\\ ?\\/?[0-9]*)$",
        "raw_prompt": "Match italian telephone number with prefix followed by &quot;/&quot;, &quot;-&quot; or blank and number. Usefull with numeric keybord!",
        "refined_prompt": "Match italian telephone number with prefix followed by &quot;/&quot;, &quot;-&quot; or blank and number.\nMatch examples:\n- \"02-343536\"\n- \"02/343536\"\n- \"02 343536\"\nNon-match examples:\n- \"02a343536\"\n- \"02+343536\"",
        "matches": [
            "02-343536",
            "02/343536",
            "02 343536",
            "123",
            "456-4545",
            "49516-49516",
            "4561-489",
            "49856/4895",
            "485/485",
            "485951",
            "485",
            "7845",
            "673"
        ],
        "non_matches": [
            "02a343536",
            "02+343536",
            "&*YHIUJN",
            "U()IHU",
            "UYGHJY*(U",
            "GYUH",
            "*UIHT*&Y876849",
            "y89uhiy89uhi*&UI",
            "y*(UHIyuhi",
            "98yUHIiuf",
            "hiufs89y",
            "fs+5644f"
        ],
        "id": 382,
        "output": [
            {
                "text": " [0-9]{3}(?:-[0-9]{3})* or [0-9] {3"
            },
            {
                "text": " \n- \"01[a-zA-Z]{2}[0-9]{2}[a-z"
            },
            {
                "text": "\n- This will match 03343536 but not 02343536 or 02a343536\n- This will match 02+"
            },
            {
                "text": "\n\nA:\n\nHere's a bit of a work around, I think.  \n^((01\\d)[-]"
            },
            {
                "text": "\n- \"([0-9]{3})-([0-9]{3})-([0-9]{6"
            },
            {
                "text": " \n- \"02[a-zA-Z0-9]+\"\n- \"02[a-zA-Z"
            },
            {
                "text": " \n- [0-9]{3}[-\\s\\+]?[0-9][0-9]"
            },
            {
                "text": " \nMatch examples:\n- \"02-343536\" - (?P<prefix>\\d{1,2}"
            },
            {
                "text": " \n\n(?<=\\+)(?=[0-9])|(?<=\\-)|(?<="
            },
            {
                "text": " ^\\d{3}[-/\\+]\\d{3}[-/\\+]\\d{4}"
            }
        ]
    },
    {
        "expression": "^(\\d+|[a-zA-Z]+)$",
        "raw_prompt": "Tests for all numbers OR all letters (upper or lower case)\n( posted from WebService - http://regexlib.com/webservices.asmx?op=Save )\n( updated from WebService - http://regexlib.com/webservices.asmx?op=Save )",
        "refined_prompt": "Tests for all numbers OR all letters (upper or lower case)\nMatch examples:\n- \"aaaaadddaaaaa\"\n- \"1166633337\"\n- \"48956\"\nNon-match examples:\n- \"1n\"\n- \"ppppp99\"",
        "matches": [
            "aaaaadddaaaaa",
            "1166633337",
            "48956",
            "485",
            "4687",
            "3573",
            "5",
            "guy",
            "huih",
            "u",
            "fiuf",
            "iyf",
            "yift"
        ],
        "non_matches": [
            "1n",
            "ppppp99",
            "yuih423",
            "y78ui",
            "t78gfy",
            "ryfut312",
            "dyff8gy89yuhh9",
            "ug8u",
            "78yg8y",
            "8yg76d667dd6",
            "768afds",
            "8787fy"
        ],
        "id": 386,
        "output": [
            {
                "text": " [^a-zA-Z0-9]+\n\n2. Write a Python program that will take a string and check if it is a palindrome or not. Use regular expressions to check for palindromes.\n\nAnswer:\nimport"
            },
            {
                "text": " \"^[a-z]+$|^[A-Z]+$\"\n\nExercise 2:\nFind all valid US phone numbers that start and end with 10.\nExample: (1) 123-456-7890 (2) 555-"
            },
            {
                "text": " (^p|^L)\n- \"pL\"Generate a RegEx for this description.\n- \"pL\" or \"L\"Generate a RegEx for this description.\n\nExercise 2:\n- \"1234567890"
            },
            {
                "text": " ^[a-z0-9]*([a-z0-9]\\w)+[a-z][a-z0-9]*$\n\nExercise 5: Write a Python function that takes a string as input and returns True"
            },
            {
                "text": " \"^([0-9a-zA-Z])+$\"\n- \"ab\"\n- \"^\\\\d+\\\\.$\"\n- \"ab\"\n- \"^\\\\d+$\"\n- \"a\\\\d+b$"
            },
            {
                "text": " ^(?:[^a-z]*(?:a[^a-z]*){5}|[^a-z]*(?:[a-z]{2}){5}|[^a-z]*(?:"
            },
            {
                "text": " \"([a-zA-Z0-9]+)\"\n\n3. Write a Python function that takes a list of strings and returns a new list with all non-digit characters removed.\n\n4. Write a Python function that takes a list of strings"
            },
            {
                "text": " [0-9]{6}[Pp]\n\nExercise 3:\nMake the following descriptions RegEx's.\n1. A phone number containing 16 digits.\n2. A string containing only letters.\n3. A string containing 5 numbers"
            },
            {
                "text": " ^[0-9]*$|^[a-z]*$|^[A-Z]*$\n\nExercise 2: Password strength\nCreate a strong password using a combination of numbers, letters, and a special character. Generate"
            },
            {
                "text": " \"n+\"\n\nExercise 3:\nCreate a regex to match the password \"Password123\".\nAnswer: (^.{8,20}$)\n\nExercise 4:\nCreate a regex to match the word \"Python\".\nAnswer"
            }
        ]
    },
    {
        "expression": "\\.com/(\\d+)$",
        "raw_prompt": "This is a regex I wrote to capture requests to AspAlliance.com with an article id as the only thing after the domain. So http://aspalliance.com/123 would go to article number 123. It maps the URL to the actual aspx file that displays the article based on the ID.",
        "refined_prompt": "This regex pattern matches URLs that end with \".com/\" followed by one or more digits. It captures the digits at the end of the URL.\nMatch examples:\n- \"http://aspalliance.com/123\"\n- \"www.aspalliance.com/123\"\n- \"http://aspalliance.com/34\"\nNon-match examples:\n- \"http://aspalliance.com/article.aspx?id=123\"\n- \"http://aspalliance.com/\"",
        "matches": [
            "http://aspalliance.com/123",
            "www.aspalliance.com/123",
            "http://aspalliance.com/34",
            "https://www.example.com/123",
            "http://example.com/456",
            "https://www.test.com/789",
            "http://subdomain.example.com/42",
            "https://example.com/0",
            "https://www.example.com/12345",
            "http://sub.example.com/9999",
            "https://example.com/987654",
            "https://www.example.com/1",
            "http://sub.example.com/333"
        ],
        "non_matches": [
            "http://aspalliance.com/article.aspx?id=123",
            "http://aspalliance.com/",
            "http://aspalliance.com/articl",
            "12/123/4322",
            "sfalijad234",
            "2/3/5235",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "com.edu.github",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 392,
        "output": [
            {
                "text": " (\\S+?)\n\n"
            },
            {
                "text": " ^(http://aspalliance"
            },
            {
                "text": " \"^http[^:/]+"
            },
            {
                "text": " \"^http://aspalliance"
            },
            {
                "text": " (^http[^:/]+"
            },
            {
                "text": "\n(?i)^.*"
            },
            {
                "text": " \n\nhttps?://["
            },
            {
                "text": "\n\nimport re\npattern ="
            },
            {
                "text": " \".*\" - any number of"
            },
            {
                "text": " (.*[^.com]"
            }
        ]
    },
    {
        "expression": "^[0-9]{5}([- /]?[0-9]{4})?$",
        "raw_prompt": "US Zip Code + 4 digit extension Postal Code",
        "refined_prompt": "US Zip Code + 4 digit extension Postal Code\nMatch examples:\n- \"14467\"\n- \"144679554\"\n- \"14467-9554\"\nNon-match examples:\n- \"14467 955\"\n- \"14467-\"",
        "matches": [
            "14467",
            "144679554",
            "14467-9554",
            "98530/6404",
            "928248626",
            "01520",
            "53972",
            "61907",
            "45857-2888",
            "39269",
            "39269",
            "17547-4481",
            "78123"
        ],
        "non_matches": [
            "14467 955",
            "14467-",
            "1446-9554",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 395,
        "output": [
            {
                "text": " (\\d{4})(\\d+)\n2. Write a RegEx to extract all words that begin with \"a\" or \"A\" from the following string:\n\"Apple is a fruit that is often red and juicy.\"\nAnswer: (\\ba\\w+\\b"
            },
            {
                "text": " \n- (\\d{4}\\-\\d{3})(\\d{4}-\\d{4})\n- (\\d{4}-\\d{3})(\\d{4}-\\d{4})\\d{4}\n-"
            },
            {
                "text": " \n\n```python\nmatch = re.match('\\d{4}-\\d{3}\\d{4}', \"14467\")\nmatch = re.match('\\d{4}-\\d{3}\\d{4}-\\d{4"
            },
            {
                "text": " \"(^[0-9]{4}-([0-9]{4}[0-9]|[0-9]{3})-([0-9]{3}[0-9]|[0-9]{2}(?:\\.["
            },
            {
                "text": " \"^[0-9]{5}\\-[0-9]{4}\\.[0-9]{4}$\" \n\nExercise 3:\nQuestion: What is the advantage of using regular expressions to validate a postal code?\nAnswer: Regular expressions can quickly identify"
            },
            {
                "text": " [\\d]{4,7}(\\s|-|\\.)[\\d]{3,9}\n- \"14468.55\"\n- \"14468-55\"\n- \"14468 955\"\n\nExample 5: \n\n```python\n"
            },
            {
                "text": " ^\\d{4}-\\d{4}-\\d\\d$|^\\d{4}-\\d{5}$\n\n3. Example: A postal worker needs to sort mail by zip code and address. \nAnswer: The Postal Worker needs to"
            },
            {
                "text": " \n[0-9] {4}[0-9]\\d{3}[0-9]{4}\\\\-\\\\[0-9]{1,5}\n\nExercise 3:\nCreate a function that takes in a Postal Code as input and"
            },
            {
                "text": "\n\n1. r'^[A-Z]{3}[0-9][A-Z]{3}[0-9][A-Z]{3}[0-9][A-Z]{3}$'\n2. r'^["
            },
            {
                "text": " (Any 4 digit number with a 3 or 4 digit extension)\n```\n\n3. Write a Python code that takes a string input, then generates a Regex that matches the given string, including any number of characters between each character.\n```python\n# Define the Re"
            }
        ]
    },
    {
        "expression": "<([^<>\\s]*)(\\s[^<>]*)?>",
        "raw_prompt": "All tags in first submatche\nAll attributes in second one...",
        "refined_prompt": "Match HTML-like tags in a text, including both opening and closing tags.\nMatch examples:\n- \"<td class=\"TD2\">\"\n- \"<!-- comment -->\"\n- \"</table>\"\nNon-match examples:\n- \"19-Fev-2002 - 19h00\"\n- \"New Changes :\"",
        "matches": [
            "<td class=\"TD2\">",
            "<!-- comment -->",
            "</table>",
            "<div>",
            "<a href=\"https://example.com\">",
            "<p class=\"paragraph\">",
            "<img src=\"image.jpg\" alt=\"Image\">",
            "<h1 id=\"header\">",
            "<ul>",
            "<li>",
            "<span style=\"color:red;\">",
            "<table cellpadding=\"5\" cellspacing=\"0\">",
            "<input type=\"text\" name=\"username\" value=\"John\">"
        ],
        "non_matches": [
            "19-Fev-2002 - 19h00",
            "New Changes :",
            "...",
            "(12) 324 653210",
            "123.456.789",
            "there is a boy",
            "-312",
            "2546dgwre",
            "u09nKLJG FSL",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 401,
        "output": [
            {
                "text": " \\b(19-Fev-|19-Apr-|19-Jun-|19-Jul-|19-Aug-|19-Sep-|19-Oct-|19-Nov-|19"
            },
            {
                "text": " (examples only, non-match examples only)\n\na) \"The website was updated last week.\"\nb) \"The website was updated last week.\"\nc) \"The website was updated last week.\""
            },
            {
                "text": " [\\s\\d-\\dM-\\dY]{4}-[\\s\\d\\d-\\d\\dT]{2}-[\\s\\d\\d\\d\\d"
            },
            {
                "text": " \n- <td class=\"TD2\">\\b\n<!-- comment -->\n<\\/td>\\b\n\"\"\"\n```\n\n2. Create a regular expression that matches any dates formatted as \"mm"
            },
            {
                "text": " \"^\\d+-\\d{4}-\\d{2}$\"\n\nExercise 3:\nWrite a Python script that takes a URL as a command-line argument and searches for a specific"
            },
            {
                "text": " \\d\\d-\\d\\d-\\d\\d [ a-z]{2}\n\nExercise 2:\nWrite a RegEx that matches a string that contains at least one non-wh"
            },
            {
                "text": " (example: \"\\d{4}-\\w{3}\\s\\w{4}\")\n\n5. Write a Python function that takes in a text, a regular expression pattern, and a replacement string,"
            },
            {
                "text": " \\d-Fev-\\d\\d-\\d\\d\n4. Write a Python RegEx that matches strings only containing ASCII characters.\nAnswer: ^[ \\t\\f\\v\\r\\"
            },
            {
                "text": " '^19-' + \\d{4}-\\d{2}-\\d{2}$'\n\n#### RegEx for matching dates:\n\nPython has a built-in module called `re"
            },
            {
                "text": " \"^\\d{4}-\\d{2}-\\d{2}\\s\\d{2}h00$\"\n\nExercise 3: Write a Python code to extract all the URLs in"
            }
        ]
    },
    {
        "expression": "^((Bob)|(John)|(Mary)).*$(?<!White)",
        "raw_prompt": "&quot;Starts with but does not end with.&quot;\nI needed a pattern to require certain first (and optional middle) names, but to fail for certain last names. So if Bob, John, and Mary are acceptable first names but the White's are always rejected then...",
        "refined_prompt": "Match strings that start with the names \"Bob,\" \"John,\" or \"Mary\" and do not end with \"White.\"\nMatch examples:\n- \"Bob Jones\"\n- \"John Smith\"\n- \"Mary Jane Smith\"\nNon-match examples:\n- \"Bob White\"\n- \"Mary Doe White\"",
        "matches": [
            "Bob Jones",
            "John Smith",
            "Mary Jane Smith",
            "Bob Sdsfui",
            "Mary Ufsdui",
            "John Jfdsj",
            "Bob Ufsduni",
            "John Bufisd",
            "Mary Ofuidn",
            "John Hfsnjii",
            "Mary Jfsd",
            "Mary Bob",
            "John Jfsdfds"
        ],
        "non_matches": [
            "Bob White",
            "Mary Doe White",
            "Gina Smith",
            "afdsaf.adijs",
            "234",
            "2/3/5235",
            "@#dfkjnav",
            "2546dgwre",
            "Jfsu White",
            "dsofioi fsifud",
            "Bob sdfjio White",
            "SDFisojsfdsd"
        ],
        "id": 402,
        "output": [
            {
                "text": " [^a-z\\s]*[a-z][^a-z\\s]*\n\n\n\nTitle: Exploring the Fascinating World of Mathematics: Unlocking the Power of Multiplication \n\n"
            },
            {
                "text": " ^(?i)(^[^| ]*(?:(?:[a-z]*\\s)?(?:[a-z]+\\s)?[a-z]*\\s))*[a-z"
            },
            {
                "text": " [Insert your answer here]\n\nExercise 2: Match strings that start with the names \"Bob,\" \"John,\" or \"Mary\" and end with the names \"White\" or \"Black.\"\nMatch examples:\n- \""
            },
            {
                "text": " match any string that starts with \"Bob,\" \"John,\" or \"Mary\" and does not end with \"White\"\n\nExercise 3:\nCreate a RegEx pattern that matches any string that starts with \"The\" and ends"
            },
            {
                "text": " r'^(?:John|Mary)\\s*[^\\W\\d_]*\\b'\n\nExercise 5: Match strings that start with two uppercase letters, two lowercase letters, and three digits"
            },
            {
                "text": " \n(?<!Mr\\s)(?<!St\\s)\\w+(?<![a-zA-Z])(?!White)\\b\n\n# 14.4.8 Generating and displaying"
            },
            {
                "text": " (\\b(Bob|John|Mary)\\b[^\\W_]+)\n\n\nExercise 2:\nMatch a string that starts with the names \"Bob\" and ends with the names \"John\" and has any number"
            },
            {
                "text": " Bob (^(b|b\\w*))[^a\\w]+, John (^(j|j\\w*))[^a\\w]+, Mary (^(m|m\\w*))["
            },
            {
                "text": " \nmatches = ['Bob Jones', 'John Smith', 'Mary Jane Smith']\nnon_matches = ['Bob White', 'Mary Doe White']\n\nExercise 5:\nCreate a RegEx pattern that matches the"
            },
            {
                "text": " \n\n```python\nimport re\n\ndef check_names(sentence):\n    pattern = r\"^(Bob|John|Mary) (.*) (.*)$\"\n    matches = re."
            }
        ]
    },
    {
        "expression": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "raw_prompt": "The RE match U.S. state abbreviation used by the U.S. Post Office.",
        "refined_prompt": "The RE match U.S. state abbreviation used by the U.S. Post Office.\nMatch examples:\n- \"AL\"\n- \"CA\"\n- \"AA\"\nNon-match examples:\n- \"New York\"\n- \"California\"",
        "matches": [
            "AL",
            "CA",
            "AA",
            "AL",
            "AK",
            "AZ",
            "DE",
            "FL",
            "GA",
            "HI",
            "ID",
            "IL",
            "IN"
        ],
        "non_matches": [
            "New York",
            "California",
            "ny",
            "fj",
            "if",
            "ud",
            "indiana",
            "notre dame",
            "minnesota",
            "ladf",
            "hu",
            "fy"
        ],
        "id": 405,
        "output": [
            {
                "text": " [Explanation of the regex]\n\nExercise 2: Write a RegEx that matches any word that starts with \"A\" and ends with \"e\".\nAnswer: [Explanation of the RegEx]\n\nExercise 3: Write a RegEx that matches any"
            },
            {
                "text": " ^(AL|CA)([NS]\\.)(AL|CA)([CD]|[MD]|[OR]|[WA]|[VT]|[VA]|[VT]|[VT]|[VT]|[VT])$\n\n4"
            },
            {
                "text": "\nimport re\nstate_abbreviation_re = re.compile(r'[A-Z][A-Z]|[A-Z][a-z]')\nprint(state_abbreviation_re.findall('AL, CA, AA,"
            },
            {
                "text": " ^(AL|CA|AA)$\n\n**Exercise 2**: \n\nCreate a Python program that matches the following pattern: \"^[A-Za-z0-9]{10}$\"\n\n**Answer**:\n```python\n"
            },
            {
                "text": " r/regex/new-york-california\n\nExercise 3:\nCreate a RegEx pattern that matches a phone number in the format (123) 123-4567.\nAnswer: r/regex/(\\(\\d{3}\\))\\s*"
            },
            {
                "text": " /\\b(?P<state>\\w{3})\\b/\nExercise 2: \nCreate a RegEx for the following password:\n- \"Abc12345\"\n- \"Abc@12345\"\n- \"Abc12345678\""
            },
            {
                "text": " The RegEx for this description is r'^\\d{3}-?\\d{2}-?\\d{4}$'\n\nExercise 2: Write a RegEx to match email addresses. \nAnswer: email = r'\\b[A-"
            },
            {
                "text": " \"^[A-Z]{2}[a-z]{3,}$\" \n\nExercise 2: Create a RegEx for capturing the numerical value of a date in the format \"MM/DD/YYYY\".\nAnswer: \"^\\d{"
            },
            {
                "text": " (\\w+)?\\.?(\\w+)?(\\.?)?(\\w+)?\\.?(\\w+)?\\s(\\w+)?\\s?(.*) (.*)\\s?(.*)\n2. Write a regular expression that matches a string containing only u"
            },
            {
                "text": " \n\n```python\nimport re\n\n# Define a function to generate the regex for the description\ndef generate_regex(state):\n    # Define the RegEx pattern\n    regex = r\"(?<!^)\" + re.escape(state"
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{6}[0-9]{2}[A-Za-z]{1}[0-9]{2}[A-Za-z]{1}[0-9]{3}[A-Za-z]{1}$",
        "raw_prompt": "This pattern match italian fiscal code (codice fiscale).",
        "refined_prompt": "This pattern match italian fiscal code.\nMatch examples:\n- \"SPGGRG73A02E625S\"\n- \"czzdll74h18f205w\"\n- \"RpiOQG61R03w469G\"\nNon-match examples:\n- \"SP6FFFF3A02E625S\"\n- \"czzdll74h18f205\"",
        "matches": [
            "SPGGRG73A02E625S",
            "czzdll74h18f205w",
            "RpiOQG61R03w469G",
            "OLyzHw51K18Z629B",
            "zAimYP13D38h855H",
            "GRQzXT69Y28M275w",
            "PTglEY55H26T674Y",
            "eBEuhS45v47o338b",
            "jliwVR50Q99l187p",
            "IUhXMM96N71T672J",
            "hoCMai78v86Q840l",
            "XomkYf89U53z386d",
            "qworms03P35u422p"
        ],
        "non_matches": [
            "SP6FFFF3A02E625S",
            "czzdll74h18f205",
            "f23wed",
            "f23edwf2",
            "df2sf2e",
            "f2d2sgh",
            "/5/5/5",
            "notre dame",
            "u09nKLJG FSL",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 407,
        "output": [
            {
                "text": " \\bSPGGRG\\d+A\\d+E\\d+\\d+S\\b\n\nExercise 2:\n"
            },
            {
                "text": " \nc[a-z]\\d[a-zA-Z]\\d[a-zA-Z0-9"
            },
            {
                "text": "\n[0-9]{1,3}[A-Z]{1,3}[A-Z]{1,3"
            },
            {
                "text": " czzll74h18f205|w\nThis pattern match italian fiscal code\n(?:[0-9]{2})("
            },
            {
                "text": " (?:[a-zA-Z0-9]{3}\\s)+[a-zA-Z0-90-"
            },
            {
                "text": " I am looking for a pattern in the form \"sp/gg/rr/zz/hh/dd/ww/ef/ff/gg/"
            },
            {
                "text": " (\\w|\\d|[a-z]|[A-Z]|[-\\w*]){8,30}"
            },
            {
                "text": " \n^[a-z0-9]{1,32}[a-z0-9]{1,30}["
            },
            {
                "text": " (SPGGRG73A02E625S)(((?:[0-9]{3})[0-9]{3}"
            },
            {
                "text": "\n(SPGGRG)\\d{13}([a-z]{2}[a-z]{2})E([a"
            }
        ]
    },
    {
        "expression": "^(([8]))$|^((([0-7]))$|^((([0-7])).?((25)|(50)|(5)|(75)|(0)|(00))))$",
        "raw_prompt": "Time off hours edit for quarter hour(s) less than eight.",
        "refined_prompt": "Time off hours edit for quarter hour(s) less than eight.\nMatch examples:\n- \"0.25\"\n- \"7.75\"\n- \"8\"\nNon-match examples:\n- \"8.25\"\n- \"7.15\"",
        "matches": [
            "0.25",
            "7.75",
            "8",
            "7",
            "575",
            "2900",
            "8",
            "450",
            "150",
            "100",
            "300",
            "725",
            "625"
        ],
        "non_matches": [
            "8.25",
            "7.15",
            "0.15",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "56",
            "9781.198",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 412,
        "output": [
            {
                "text": " The regular expression should match any non-negative floating point numbers of any length between 0 and 9, followed by a decimal point and two digits, followed by a non-negative integer of any length between 0 and 9. \nExample: (?:\\d+\\.\\d+|"
            },
            {
                "text": "\n\n# Generate a RegEx to match any time less than or equal to eight hours, including any trailing zeros.\nimport re\ntime_in_hours = [\"9.00\", \"10.00\", \"10.25\", \"8.75\", \"9"
            },
            {
                "text": "\n^(\\d+[\\.])$ \n\nExercise 3:\nMatch this email address:\n- \"test@example.com\"\n- \"test@example\"\n- \"test@example.com\"\n- \"test@example.com\"\n"
            },
            {
                "text": "\n\nimport re\n\npattern = r'(?:\\.25|\\d)(?:\\d\\d\\d\\d)?' \n\ntext_a = '0.25'\ntext_b = '7.75'\ntext_c = '"
            },
            {
                "text": " \"1\\d{3}[.]\\d{2}[.]\\d{4}\"\n\nExercise 2: Determine the output of the following Python code:\n```\nre.search(\"(\\d{5})[,\\.\\s]*(["
            },
            {
                "text": " \n\\d*[\\.]{1}\\d{2}(?:[eE][+-]\\d+)?)\n\n5. Write a regular expression to match the following phone numbers:\n- 1234567890\n- (123) 456-78"
            },
            {
                "text": "\nRegular Expression: ^\\d\\.\\d{1,2}$\nThis RegEx will match the string with a decimal number. This is the same as saying, \"zero decimal numbers and a single digit afterwards\".\n\n2. Write a regular expression to match any time"
            },
            {
                "text": " [Regular expression]\n3. Write a Python code to generate the RegEx for this statement: \"The median value of all the numbers in a data set is greater than 5 but less than 10.\"\nAnswer: [Regular expression]\n4. Write a Python code to generate the"
            },
            {
                "text": "\n[0-9]?\\.[0-9]?(,[0-9]{3})?\n# In this query, the first colon is required, the third element must be followed by three digits, and the second element is optional and only requires a single comma"
            },
            {
                "text": " The RegEx should be \"(0[0-9]|1[0-9]|2[0-4])[.][0-9]*\"\n\n\n\nDear Alien,\n\nI hope this letter finds you in good health and high spirits. Today"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/(\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/(\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/(\\d{2}))|(29\\/02\\/((0[48]|[2468][048]|[13579][26])|(00))))$",
        "raw_prompt": "Matching : dd/MM/yy\nLeap years compatible\nItalian style, just for more fun.\nPlease, don't forget to rate it if you use it. THX",
        "refined_prompt": "Matching : dd/MM/yy\r\nLeap years compatible\nMatch examples:\n- \"31/12/75\"\n- \"29/02/00\"\n- \"29/02/04\"\nNon-match examples:\n- \"01/13/01\"\n- \"29/02/01\"",
        "matches": [
            "31/12/75",
            "29/02/00",
            "29/02/04",
            "24/02/97",
            "29/02/08",
            "30/11/48",
            "20/10/34",
            "05/02/94",
            "06/02/67",
            "04/02/77",
            "29/02/00",
            "22/02/25",
            "20/05/31"
        ],
        "non_matches": [
            "01/13/01",
            "29/02/01",
            "29/02/2004",
            "(12) 324 653210",
            "234/423/5243",
            "2/3/5235",
            "/5/5/5",
            "12f3.21f3.213f",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 421,
        "output": [
            {
                "text": " \"^[1-9]?[0-9]?[1-9]{3}/[1-9]?[0-9]?[2][0-9]/[1-"
            },
            {
                "text": " [0-9]{4}[-/.][0-9]{2}[-/.][0-9]{2}[a-z]{3}\\s[0-9]"
            },
            {
                "text": " [dd/MM/yy]/[dd/MM/yy]/[dd/MM/yy]\n\n3. Write a Regex that matches with:\n    - an integer or decimal number\n    -"
            },
            {
                "text": " (^|/)^[^/]*(0|[1-9])(/[12][0-9])\\\\/[0-9][0-9]$\nDescription: Match a valid date"
            },
            {
                "text": " \nimport re \nregex_months = re.compile('\\d{1,2}/\\d{1,2}/\\d{4}')\nregex_leap_years"
            },
            {
                "text": " [1-9]|0?[1-9]|1[012]/[01][0-9]/[0-3][0-9]\n\nA:\n\nThe easiest way to"
            },
            {
                "text": " (dd/MM/yy)(0|1[12])(0|1[3-9])[0-9]/[0-9]/[0-9]\n\nA:\n\nYou"
            },
            {
                "text": " [day/month/year] [day/month/year]\n\nExercise 5:\nGenerate a list of regexes for the following date values:\n- \"01/16/2005\"\n- \""
            },
            {
                "text": " (DD/MM/yy) | (DD/MM/yy) | (DD/MM/yy)\n\nA:\n\nI think this is what you are looking for : \n\"^(0|"
            },
            {
                "text": " (\\d\\d\\d\\/\\d\\d\\/\\d\\d)-(\\d\\d)-(\\d\\d)\n\"\\d\\d\\d\" = one two three\n\"/\\d"
            }
        ]
    },
    {
        "expression": "^(0)$|^([1-9][0-9]*)$",
        "raw_prompt": "This regular expression matches on postive whole numbers and 0. Whole numbers that are left padded with 0's are not a match.",
        "refined_prompt": "This regular expression matches on postive whole numbers and 0. Whole numbers that are left padded with 0's are not a match.\nMatch examples:\n- \"12\"\n- \"0\"\n- \"1200\"\nNon-match examples:\n- \"-12\"\n- \"0012\"",
        "matches": [
            "12",
            "0",
            "1200",
            "5678",
            "587",
            "656",
            "475",
            "35",
            "346746",
            "486",
            "46",
            "35357",
            "2357"
        ],
        "non_matches": [
            "-12",
            "0012",
            "03425",
            "05240",
            "00245",
            "00025",
            "-24",
            "-52-",
            "-54353-",
            "5-325-23",
            "9(*HIU",
            "(HIO"
        ],
        "id": 429,
        "output": [
            {
                "text": " -[1-9]\\d{0,2}\n\n- \"12-01\"\n- \"0\"\n- \"12-01-02\"\nNon-match examples:\n- \"-12-01\"\n- \"0-"
            },
            {
                "text": " [0-9][0-9]\n- \"12.5\"\n- \"-12.5\"\n- \"12.5.5\"\n\nA:\n\nYour regex should be ^[0-9]\\.[0-9"
            },
            {
                "text": " -(?:(?<!\\d)\\d|0{1,2}(?!\\d))\n\nA:\n\nYou can use this reg exp:\n^(?:(?:0\\d|\\d{1,2}"
            },
            {
                "text": " \"^[0-9]*$\"\n- \"12\" or \"000\"Generate a RegEx for this description. \nAnswer: \"^[0-9]*$\"\nThis will return a match for \"12\" and"
            },
            {
                "text": " ^[1-9][0-9]*$\n\nA:\n\nThis may be what you're looking for:\n/^\\d+$/\n\nor:\n/^[1-9][0-9]*$"
            },
            {
                "text": " [0-9][0-9]\n\nThis is my solution:\nimport re\n\ndef find_non_negative_int_from_str(s):\n    result = re.findall('(0|[1-9]["
            },
            {
                "text": "\n\\b\\d{1,3}(?:\\.\\d{1,3})?\\b\n\nExercise 2:\nGenerate a RegEx for the following description\nMatch Strings containing only a single number between 0 and 999"
            },
            {
                "text": " \\d{2,}(\\.\\d+)?\n\nA:\n\nYour current regex simply says that any non-zero whole number must follow a.. If you want to allow for more than a single decimal place, you can simply do \\"
            },
            {
                "text": " (0|1|2|[0-9]|1[0-9]|2[0-9]|[1-8])0{0,1}|000|01\n\nThis regular expression generates a RegEx that matches"
            },
            {
                "text": " ([0-9]*[1-9])/([0-9]*[0-9])\n\n- \"1234\"\n- \"1-2-3-4\"\n- \"12-34-5-6\"\n"
            }
        ]
    },
    {
        "expression": "^(0*100{1,1}\\.?((?<=\\.)0*)?%?$)|(^0*\\d{0,2}\\.?((?<=\\.)\\d*)?%?)$",
        "raw_prompt": "Percentage (From 0 to 100)",
        "refined_prompt": "Percentage (From 0 to 100)\nMatch examples:\n- \"100%\"\n- \"100\"\n- \"52.65%\"\nNon-match examples:\n- \"-1\"\n- \"-1%\"",
        "matches": [
            "100%",
            "100",
            "52.65%",
            "48%",
            "79%",
            "67.8%",
            "83.7",
            "42",
            "98",
            "52",
            "59",
            "38.48",
            "38.483"
        ],
        "non_matches": [
            "-1",
            "-1%",
            "100.1%",
            "4234",
            "677",
            "45269",
            "568",
            "989",
            "69868",
            "423.423.7",
            "34.31%%",
            "32542 //"
        ],
        "id": 431,
        "output": [
            {
                "text": " -1\\%\n- \"1%\"Generate a RegEx for this description. \nAnswer: 1%\n\n2. Write a Python function that takes a number and two other parameters, which are the percent limit, and a minimum value. Then write another function that takes a number and two other parameters, which are the percent limit"
            },
            {
                "text": " -1|[0-9]+%\n\n- Generate a RegEx for this description:\na) A string that contains at least one uppercase letter, at least one lowercase letter, and at least one number.\nb) A string that contains at least one uppercase letter, at least one lowercase letter"
            },
            {
                "text": " \"-1\"\nExercise 5:\nMatch example:\n- \"1\"\nNon-match example:\n- \"2\"\nMatch examples:\n- \"2%\"\n- \"50%\"\nNon-match examples:\n- \"2%0\"Generate a RegEx for this description. \nAnswer: \""
            },
            {
                "text": " \"^[0-9]*[.]([0-9]+)%$\"\n\n**Exercise 2:**\n\nWrite a Python program that takes a list of numbers and returns the percentage of positive numbers. \n\n```python\ndef positive_percentage(numbers):\n    total = sum(n"
            },
            {
                "text": " -1\\.[0-9]%\n\n2. Create a RegEx for the following:\n- A decimal number (0.25)\n- A decimal number (0.5)\n- A decimal number (0.75)\nAnswer: [0-9]\\.[0-9]\n\n3. Create"
            },
            {
                "text": " \"(?<!-)(?=[0-9])[0-9.]+%\"\n- \"1%\"Generate a RegEx for this description.\nAnswer: \"(?<!\\d)(?=[0-9])[0-9.]+%\"\n- \"52.67%\"Generate a RegEx for"
            },
            {
                "text": " \"^[0-9]*%$\"\n\nExercise 5:\n\nCreate a RegEx pattern to match the email address format: username@domain.com. The pattern should match any combination of letters, numbers, dots, and underscores.\n\nAnswer: \"^[\\w.-]+@[\\w.-]+"
            },
            {
                "text": " \"100%+\"\n\nExercise 3:\nSelect the correct option that will complete the following sentence:\n\nThe percentage of students who passed the exam was __.\n\na) 0%\nb) 50%\nc) 100%\nd) 75%\ne) 50%+\n\nAnswer: c) 100"
            },
            {
                "text": " A number between 1 and 100.\n- \"100%\"Generate a RegEx for this description.\n\n\n\n\n\nTitle: The Power of Language Arts: Exploring Root Words and Affixes\n\nIntroduction:\nIn a world where language is the key to communication, understanding the building blocks of words is essential. Language arts provides"
            },
            {
                "text": "\n- \"-1%\"\n- \"-1\"\n- \"-1%\"\n%Percentage (From 0 to 99)\nMatch examples:\n- \"10%\"\n- \"20%90%\"\n- \"5%\"\nNon-match examples:\n- \"-1\"\n- \"-1%\"Generate a RegEx for this description"
            }
        ]
    },
    {
        "expression": "((^(10|12|0?[13578])(3[01]|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])(30|[12][0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(2[0-8]|1[0-9]|0?[1-9])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)(29)([2468][048]00)$)|(^(0?2)(29)([3579][26]00)$)|(^(0?2)(29)([1][89][0][48])$)|(^(0?2)(29)([2-9][0-9][0][48])$)|(^(0?2)(29)([1][89][2468][048])$)|(^(0?2)(29)([2-9][0-9][2468][048])$)|(^(0?2)(29)([1][89][13579][26])$)|(^(0?2)(29)([2-9][0-9][13579][26])$))",
        "raw_prompt": "Matches on MMDDYYYY only, requires all 8 digits",
        "refined_prompt": "Matches on MMDDYYYY only, requires all 8 digits\nMatch examples:\n- \"01012003\"\n- \"02292000\"\n- \"02297352\"\nNon-match examples:\n- \"01/01/2003\"\n- \"52/2/54/245\"",
        "matches": [
            "01012003",
            "02292000",
            "02297352",
            "02299364",
            "2299200",
            "02299876",
            "11301980",
            "2181846",
            "2297260",
            "2291976",
            "04021848",
            "2299600",
            "02291864"
        ],
        "non_matches": [
            "01/01/2003",
            "52/2/54/245",
            "90438502+9503",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "43-5432",
            "254627g.256",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 433,
        "output": [
            {
                "text": " matches any date in the format MM/DD/YYYY\n- \"1234/12/35\"\n- \"01/01/01\"\n- \"1234/12/35/45\" Generate a RegEx for this"
            },
            {
                "text": " (MMDDYYYY)(0-9)(0-9)(0-9)(0-9)(0-9)\n\nExercise 2: Given the following string, extract the date using RegEx:\n\"I bought a car"
            },
            {
                "text": " \nMMDYYYYMMDD[ ]+[ ]+HH:MM:SS\nIf there is any non-match, the regex becomes non-capturing which doesn't have to be set to a backreference. \nFor"
            },
            {
                "text": " (^(?:\\d{4}-(?:\\d{2}-(?:\\d{2}))|(?:\\d{4})|(?:\\d{2}))$)\n\nExercise 2:\n"
            },
            {
                "text": " [0-9][0-9]{6}\n\n```python\n# Solution\nimport re\n\n# Define the pattern\npattern = \"[0-9][0-9]{6}\"\n\n# Sample data"
            },
            {
                "text": "  ^[0-9]{4}$\n\nExercise 2: Write a RegEx that matches a string that starts with 'c' and ends with 't'.\nAnswer: ^c.*t$\n\nExercise 3"
            },
            {
                "text": "\n\"^[0-9]{8}/[0-9]{3}/[0-9]{4}$\"\n\nExercise 2:\nCreate a list of words that match a RegEx pattern consisting"
            },
            {
                "text": " (0*)([0-9][0-9]-?[0-9][0-9]-?[0-9][0-9])0*\nExplanation: This RegEx will match any string that has 8"
            },
            {
                "text": " [0-9]{8}-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]\n\n- \"100\"\n- \""
            },
            {
                "text": " A pattern that only includes the four digits and can be extracted is /(\\d{2})/(\\d{2})/(\\d{4}).\n\n5. Write a Python function that takes a string and returns True if the string"
            }
        ]
    },
    {
        "expression": "^\\d{1,7}$",
        "raw_prompt": "Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed.",
        "refined_prompt": "Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed.\nMatch examples:\n- \"1234567\"\n- \"9999999\"\n- \"1\"\nNon-match examples:\n- \"12345678\"\n- \"9999.99\"",
        "matches": [
            "1234567",
            "9999999",
            "1",
            "879",
            "9786",
            "579598",
            "5975",
            "75968",
            "89756",
            "859745",
            "7859",
            "45793",
            "67446"
        ],
        "non_matches": [
            "12345678",
            "9999.99",
            "-1234",
            "4567895657",
            "5760785680476884",
            "47864087453586",
            "356845608968",
            "785679477649",
            "000-000",
            "897-",
            "(0xx12) 62509",
            "3409fjg43"
        ],
        "id": 435,
        "output": [
            {
                "text": " \\d{1,9}\n\n2. Write a function that takes in a string, and a RegEx pattern and returns all matches found in the string.\nExample:\n>>> find_all_matches(\"Hello, my name is John Doe."
            },
            {
                "text": " \\d+[.]\\d{3}\n- \"1.0\"Generate a RegEx for this description.\nAnswer: \\d{1,2}\\.\\d{2,3}\n\nA:\n\nThe regular expression you"
            },
            {
                "text": " [0-9]{1,6}\nThe only possible answer should be [0-9]+\n\nA:\n\nI think the following is a good solution: ^\\d{6}$|^[0-9]\\d{"
            },
            {
                "text": " [0-9]{7,}\n\nGiven:\n\n1 = [0-9]{7,}\n2 = [0-9]{5}\n3 = [0-9]{3}\n4 = [0-"
            },
            {
                "text": " ^[0-9]{1,9}(?!$)[0-9]{3}.[0-9]{3}$\n\nExercise 3: \n\nWrite a regex rule to check if a username string only contains letters and"
            },
            {
                "text": " \\d{1,10}\n\nWrite a regex for this description.\n\n**Hint:** The [a-zA-Z] is for the character. You can use any character. \nAnswer: [a-zA-Z"
            },
            {
                "text": " (?<![a-zA-Z0-9])[A-Za-z0-9](?![a-zA-Z0-9])[A-Za-z0-9]\n\nA:\n"
            },
            {
                "text": "\n^[A-Z0-9]{6}$\n\nExercise 2:\nCreate a RegEx to match a string of three words, separated by a period (.)\nAnswer:\n^[A-Za-z][A-"
            },
            {
                "text": " [^0-9]|\\.\\d+[^0-9]\n\n3) Use a negative lookahead to ensure that the last character in a string is not a digit. \n\n\\D*(?=\\d$) -"
            },
            {
                "text": "\n^\\d{9}$\n\n3. Write a RegEx to match any alphanumeric character that is not a dash.\nSolution:\n^[a-zA-Z0-9]*$\n\n4. Write a Reg"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9_\\s-]+$",
        "raw_prompt": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces. The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.",
        "refined_prompt": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces. The purpose is to force users to generate legitimate, readable file names that can be streamed from the web.\nMatch examples:\n- \"123Testing\"\n- \"123_Testing\"\n- \"123-Testing This\"\nNon-match examples:\n- \"!@#Testing\"\n- \"Testing &quot;This&quot;\"",
        "matches": [
            "123Testing",
            "123_Testing",
            "123-Testing This",
            "67fg",
            "76f76",
            "f67f87",
            "f78f",
            "8d",
            "67d56tf8f",
            "6d7d8_",
            "7yf6f8f-f",
            "68f8f87f7",
            "87f78f78"
        ],
        "non_matches": [
            "!@#Testing",
            "Testing &quot;This&quot;",
            "Don't Forget to Write",
            ";fdsaafa;",
            ";f",
            ";f;'f",
            ";f'",
            ";f'dsfsd;'sd",
            ";ffd;'sf",
            "%^FYTFF^",
            "$%DRTF(I",
            "%^RTYIO"
        ],
        "id": 440,
        "output": [
            {
                "text": "\n\n```python\nimport re\n\ndef validate_url_filename(url_"
            },
            {
                "text": " \\w+$ and $ matches any non-space/non-alphanumeric letter/"
            },
            {
                "text": "\n(?!^[a-z \\-_ ]*[a-z \\-"
            },
            {
                "text": " \\w+$\n\n# 8.5.9 Regular Expression Flags and Options\n"
            },
            {
                "text": "\nimport re\n\n# Define a function to generate a RegEx for the given description"
            },
            {
                "text": " \\w+_\\w+\n\nExercise 4:\nQuestion: Write a Python"
            },
            {
                "text": "\nimport re\n\ndef validator(value):\n  # match only alphanumeric"
            },
            {
                "text": " \"^[a-zA-Z0-9\\s_\\-]+$\""
            },
            {
                "text": " The RegEx could be \\b\\w+[_\\-\\s]\\w+"
            },
            {
                "text": " \\w*\\d\\w*\n\nLecture Script:\n\nWelcome"
            }
        ]
    },
    {
        "expression": "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\,*\\s\\s*\\d{4}$|^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\,*\\s\\d{4}$|^(January|February|March|April|May|June|July|August|September|October|November|December)\\,*\\s\\d{4}$|^(january|february|march|april|may|june|july|august|september|october|november|december)\\,*\\s\\d{4}$",
        "raw_prompt": "Best Use validation to accept a valid &quot;MonthName(,) Year&quot;.\nIt can validate an entry with or without comma (,).",
        "refined_prompt": "Best Use validation to accept a valid &quot;MonthName(,) Year&quot;.\r\nIt can validate an entry with or without comma (,).\nMatch examples:\n- \"January 2004\"\n- \"Jan, 2004\"\n- \"january 2003\"\nNon-match examples:\n- \"Janu 2004\"\n- \"jAn, 2004\"",
        "matches": [
            "January 2004",
            "Jan, 2004",
            "january 2003",
            "Jan, 2023",
            "February, 2022",
            "mar, 2021",
            "April, 2020",
            "May, 2019",
            "Jun, 2018",
            "July, 2017",
            "August, 2016",
            "September, 2015",
            "October, 2014"
        ],
        "non_matches": [
            "Janu 2004",
            "jAn, 2004",
            "January,2003",
            "2023 Jan",
            "Dec 2021afd",
            "07 July 2017",
            "March/2030",
            "notre dame",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 444,
        "output": [
            {
                "text": " ^(January[,0-9]{3}(?:[, ](?:January|February|March|April|May|June|July|August|"
            },
            {
                "text": "\n\n[A-Za-z]+[\\s,\\(\\)]+[\\d]{4}\\s[\\d]{2}[\\"
            },
            {
                "text": " ^\\w{3}\\s\\d{1,2}$\n\n2. Use the pattern in exercise 1 to validate an entry with a date format of y"
            },
            {
                "text": " Valid months are 01/12/YYYY, 01/13/YYYY, 01/14/YYYY, 01/15/YYYY.\n\n3."
            },
            {
                "text": " \\d{1,2}, \\d{4}\n\nA:\n\nI don't think there is a built-in regex module.\nYou can use"
            },
            {
                "text": " /^([a-z]|[A-Z][a-z]|[0-9]{1,3}[a-z])\\s"
            },
            {
                "text": " [1-2][0-9][0-9]|[1][0-9][0-9]|[1-9][0-9]"
            },
            {
                "text": " ^(?:\\d{4}\\s)?(?:\\w\\s)?(?:\\w\\s)?(?:\\w\\s)?(?:\\w"
            },
            {
                "text": " \\d{3}[/-]\\d{4}/\\d{2}\n\nA:\n\nFor the first question you just need to make sure"
            },
            {
                "text": " ^[a-zA-Z][a-zA-Z]( [a-zA-Z]{3,2} | \\d{3,"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]+(([\\'\\,\\.\\-][a-zA-Z])?[a-zA-Z]*)*$",
        "raw_prompt": "This allows you to validate first names and last names in seperate fields. Instead of validating a full name in one field.",
        "refined_prompt": "This allows you to validate first names and last names in seperate fields. Instead of validating a full name in one field.\nMatch examples:\n- \"Sameul\"\n- \"O'Conner\"\n- \"Mary-Kate\"\nNon-match examples:\n- \"David Bugel\"\n- \"Robert1\"",
        "matches": [
            "Sameul",
            "O'Conner",
            "Mary-Kate",
            "Hello",
            "World",
            "Messi",
            "Ronaldo",
            "Abc",
            "Xavi",
            "Neymar",
            "Santos",
            "Jdsfa",
            "Phd"
        ],
        "non_matches": [
            "David Bugel",
            "Robert1",
            "Robert M. Larry",
            "87h87h8",
            "g87g87v8",
            "vf7878vf97",
            "f79",
            "9",
            "f89f",
            "89gf89",
            "gf8f",
            "98f7r97t9ut"
        ],
        "id": 452,
        "output": [
            {
                "text": " (^\\w*[A-Z][a-z]+[\\s\\S]*$)\n\n#Exercise 2: Use the RegEx you generated in exercise 1 to validate email addresses.\n"
            },
            {
                "text": " (Name(?:\\s|$))?Last(?:\\s|$)\n\n4. Validate file names.\nQuestion: How do you validate file names?\nSolution: You can use python's"
            },
            {
                "text": "\n\nimport re\n\ndef validate_name(name):\n    if not re.match(\"^[A-z][A-z ]*$\", name):\n        return False\n    return True\n"
            },
            {
                "text": " \"^[a-z][a-zA-Z][0-9]*[a-z]$\"\n\nHere is a working test on Github\nIt will take the first three characters of first"
            },
            {
                "text": " [^A-Za-z0-9_ ]\n\n**Exercise:**\n\nWrite code that takes user input for a social security number. Validate and print 'Invalid' if the input is"
            },
            {
                "text": "\n^[A-Z][a-z]+[A-Za-z-]{1,32}[A-Za-z]$\n\nA:\n\nI have solved your question"
            },
            {
                "text": " \\w{2}[-\\w0-9_]{1,}|[\\.\\,\\!\\?\\:\\;\\(\\)\\+\\-\\&\\=\\_\\*\\^"
            },
            {
                "text": "\n[A-Za-z][A-Za-z0-9]*\n\nA:\n\nThe following regex should do the trick. I made it to the point of splitting the string in"
            },
            {
                "text": "\n(^\\w+\\s\\w+$|^\\w+[\\s\\-]*\\w+[\\s\\-]*\\w+$|^(\\w+[\\s\\-"
            },
            {
                "text": " (.*[0-9][0-9] [A-Z][A-Z] [A-Z][A-Z]([A-Z][A-Z][0-9][0-9"
            }
        ]
    },
    {
        "expression": "^#?(([fFcC0369])\\2){3}$",
        "raw_prompt": "Matches the 216 web colors with or without the '#' sign.",
        "refined_prompt": "Matches the 216 web colors with or without the '#' sign.\nMatch examples:\n- \"#FFFFFF\"\n- \"FFCC00\"\n- \"003300\"\nNon-match examples:\n- \"#FFFFF\"\n- \"EFCC00\"",
        "matches": [
            "#FFFFFF",
            "FFCC00",
            "003300",
            "000066",
            "#FF0066",
            "#9966cc",
            "#ff0033",
            "CC66ff",
            "#336666",
            "3366cc",
            "#333399",
            "ccff99",
            "CC99cc"
        ],
        "non_matches": [
            "#FFFFF",
            "EFCC00",
            "030303",
            "fasd@fds.fasd@",
            "123.456.789",
            "3nf@",
            "43-5432",
            "2546dgwre",
            "9516-9516",
            "354/243/542",
            "9/9/9",
            "99999@gmail"
        ],
        "id": 458,
        "output": [
            {
                "text": " ^#(?:[A-Fa-f0-9]{6}|[0-9]{3})(?:-(?:[0-9]{3}){0,2})?$\n\n#### Exercise 4\n\nWrite a Python program"
            },
            {
                "text": " [0-9]{1,5}, [0-9]{1,2}[Cc]\n\nI hope you have a better understanding of the power of Python RegEx now. Happy exploring!\n\nBlog Post: \"Exploring Regular Expression Functions"
            },
            {
                "text": " This exercise combines the previous two exercises.\n\n---\n\nThat's it for now, my friend! Hope you had fun exploring the world of regular expressions. With a little practice, you'll be a pro in no time. Until next time!\n\n\n\n\n# Chapter"
            },
            {
                "text": " This is a very simple example of defining a RegEx.\n\nExercise 2: Write a Python program that takes a string as input and returns all substrings that start with 'a' and end with 'z'.\n#Example: \nInput: \"abcabc\""
            },
            {
                "text": " /#(?P<hex>[0-9a-f]{6})(?P<alpha>[0-9a-f]{3})(?P<beta>[0-9a-f]{3})(?P<gamma>["
            },
            {
                "text": "\n\nimport re\n\nwebColors = []\n\n# Generate a list of all different possible web colors\nfor row in range(0, 256):\n    for col in range(0, 256):\n        for rgb in range(0, 3):\n"
            },
            {
                "text": " (((?i)(?<color>[0-9a-fA-F]{3})[0-9a-fA-F]{3})[0-9a-fA-F]{3})\n\nExercise 5: "
            },
            {
                "text": " \n^#(?P<hex_color>\\d{6})((?:#|$))?$\n\n3. Write a Python program to validate a password. A password must be between 6 and 25 characters, and it must contain at least one u"
            },
            {
                "text": " \n(R[0-2][0-9][0-9][0-9])|(R[0-2][0-9][0-9][0-9])|(R[0-9][0-9][0-9]["
            },
            {
                "text": " #(?:\\d|[A-Fa-f])(?:[A-Fa-f0-9]|-)+\"\n\n\n\n\n## Contents:\n1. Introduction to `readlines()`\n2. Using `readlines()` for"
            }
        ]
    },
    {
        "expression": "^([0-9]{2})(00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$",
        "raw_prompt": "Matches a Julian date in the format YYDDD. Two digit year followed by a number from 1 - 366 indicating the day of the year.",
        "refined_prompt": "Matches a Julian date in the format YYDDD. Two digit year followed by a number from 1 - 366 indicating the day of the year.\nMatch examples:\n- \"99366\"\n- \"00001\"\n- \"04225\"\nNon-match examples:\n- \"74000\"\n- \"04367\"",
        "matches": [
            "99366",
            "00001",
            "04225",
            "34106",
            "26356",
            "67099",
            "24033",
            "79271",
            "46242",
            "17004",
            "22161",
            "58096",
            "36256"
        ],
        "non_matches": [
            "74000",
            "04367",
            "87yf2",
            "877v78",
            "f8yf",
            "79f798",
            "f87f",
            "86",
            "d78",
            "fd78",
            "7897",
            "c979c7"
        ],
        "id": 464,
        "output": [
            {
                "text": "\n.*([0369]{1,2}[0-9]{4})([0369]{1,2}[0-9]{2})\n- Note that I also used"
            },
            {
                "text": " (2 digit year)(1 - 366)(1 - 7)?(3 digits)\n\n3. Given this string:\n\n\"A man, a plan, a canal, Panama!\"\n\nGenerate a"
            },
            {
                "text": " year = \"^(00[0-9])([1-9][0-9]|[0-9])$\"\n\n2. Given the following date of birth: \u201c2023"
            },
            {
                "text": " [^\\s]\\d{2}[0-9]\n\nI don't understand how to use the \\d or [^\\s] for the first block. Any suggestions?\n\nA"
            },
            {
                "text": " \"(\\d{2})[1-9][0-9]{2}(-[0-9]{2})?[1-9][0-9]{4}$\nUse the"
            },
            {
                "text": "\n[1-3][0-9]{4}\n\nExercise 2:\nThe following strings contain both match and non-match examples. Use the RegEx function described above to separate out the match"
            },
            {
                "text": " \n[0-9]{9}\\d[0-9]{3,4}\nExplanation: \n\n#Python Code:\nimport re\nmy_string = \"04225"
            },
            {
                "text": "\n\ndef year_match(year):\n    return (str(year)[2:])[0:2] == '0' or (str(year)[2:])[0:2] =="
            },
            {
                "text": " \"^[0-9]{4}$|[0-9]{2}[1-9]$\"\n\nExercise 2:\nCreate a RegEx for identifying the day of the"
            },
            {
                "text": "\n(?<year>\\d{2})(?<month>\\d{2})(?<day>\\d{2})(?<dayofyear>\\d*)\n\nEx"
            }
        ]
    },
    {
        "expression": "^(?!000)([0-6]\\d{2}|7([0-6]\\d|7[012]))([ -]?)(?!00)\\d\\d\\3(?!0000)\\d{4}$",
        "raw_prompt": "This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.",
        "refined_prompt": "This regex validates U.S. social security numbers, within the range of numbers that have been currently allocated.\nMatch examples:\n- \"078-05-1120\"\n- \"078 05 1120\"\n- \"078051120\"\nNon-match examples:\n- \"987-65-4320\"\n- \"000-00-0000\"",
        "matches": [
            "078-05-1120",
            "078 05 1120",
            "078051120",
            "771168215",
            "771-15-6202",
            "492555496",
            "770 88 6604",
            "771740961",
            "771-66-1754",
            "713130612",
            "287435836",
            "772131903",
            "772 55 5976"
        ],
        "non_matches": [
            "987-65-4320",
            "000-00-0000",
            "(555) 555-5555",
            "(12) 324 653210",
            "234",
            "2/3/5235",
            "43-5432",
            "254627g.256",
            "9516-9516",
            "341.431v4f3.fv1",
            "34.31",
            "32542 //"
        ],
        "id": 465,
        "output": [
            {
                "text": "\n[0-9]{3}-[0-9]{2}[0-9]{4}\n- \"0-9\"{3}"
            },
            {
                "text": "\n[0-9]{3}[-/.;:][0-9]{3}[-/.;:][0-9]{4}"
            },
            {
                "text": " \n- (?<country>[0-9 ]+)|(?<state>[A-Z]{1})|(?<zipcode>[a-"
            },
            {
                "text": " (\\d{3})-(\\d{2})-(\\d{4})\n\n2) Write a Python program to validate the format of an email address."
            },
            {
                "text": " ^[0-9]{3}-[0-9]{3}-[0-9]{4}$\n\n4) You need to validate a"
            },
            {
                "text": "\n/^(\\d{3})(-)?(\\d{2})(-)?(\\d{4})$/\n\nThis regex validates US social security"
            },
            {
                "text": "\n[0-9]{3}-[0-9]{2}-[0-9]{4}\n\nExercise 3: Find a match for"
            },
            {
                "text": "\n^[\\d-]{3}\\s\\d{3}\\s\\d{4}$\n\nExercise 2:\nWrite an If statement that"
            },
            {
                "text": " ^[0-9]{3}-?[0-9]{3}-?[0-9]{4}$\n\n3. Desc"
            },
            {
                "text": " The format for a valid social security number is \"XXX-XX-XXXXX\".\nTo generate the RegEx, break down the problem into smaller groups:\n- The"
            }
        ]
    },
    {
        "expression": "^\\d+(?:\\.\\d{0,2})?$",
        "raw_prompt": "Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.",
        "refined_prompt": "Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"",
        "matches": [
            "1",
            "1.23",
            "1234.45",
            "867",
            "8657",
            "785",
            "468.24",
            "9678",
            "487",
            "467.24",
            "896",
            "579",
            "4792"
        ],
        "non_matches": [
            "a1.34",
            "1.23a",
            "a",
            "dsfds87",
            "f87yf",
            "78f79",
            "f97f9",
            "234.23423",
            "423.35223.2",
            "4234.234234",
            "u9g8vg89",
            "v98v"
        ],
        "id": 473,
        "output": [
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: \"^\\d+\\.\\d*$\"\nExplanation: This matches exactly one decimal point, followed by one or more digits. If a non-"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: \"1[0-9.]{1,2}|[0-9.]{3,}\"\n\n4. Match words starting with \"a\" or"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: [^\\d] and [^\\d.]\n\n3. Match the following special characters:\n- _\n- _\nGive examples for each character."
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: [^a-zA-Z].{0,3}[a-zA-Z]{0,3}[0-9]\n\n"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: ^[0-9]+(\\.[0-9]{0,2})?\n\n4. Match words that may contain one or more digits.\n"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: Positive whole numbers with exactly zero or two decimal points if a. is present.\n\n3. Match examples:\n- \"3\"\n- \"5.01"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: \n(?<!\\d)([0-9]+)(?:\\.(?:\\.[0-9]{2})?|\\.)([0"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: The regex is \"0|1|2|3|4|5|6|7|8|9|a|b|c|d|e|"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: (^[1-9]\\d?|(?<!\\.)0[1-9]?\\.?0[1-9]?)$"
            },
            {
                "text": "Matches positive whole numbers with exactly zero or two decimal points if a. is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25.\nMatch examples:\n- \"1\"\n- \"1.23\"\n- \"1234.45\"\nNon-match examples:\n- \"a1.34\"\n- \"1.23a\"Generate a RegEx for this description. \nAnswer: (1|.)\\.(\\d{1,2}|\\d{1,3}|\\d{1,4}|\\d{1"
            }
        ]
    },
    {
        "expression": "[^A-Za-z0-9]",
        "raw_prompt": "To detect non-alphanumeric characters (for new username/password validation, for instance):\nmonkey(AT)greyledge.net\n14-Oct-2003 11:26",
        "refined_prompt": "To detect non-alphanumeric characters (for new username/password validation)\nMatch examples:\n- \"!@#$\"\n- \"%^&amp;*\"\n- \"'&gt;&lt;?.,&quot;\"\nNon-match examples:\n- \"ABC123abc\"\n- \"abc123ABC\"",
        "matches": [
            "!@#$",
            "%^&amp;*",
            "'&gt;&lt;?.,&quot;",
            "#&*G@",
            "6%FT",
            "g*&UI*(",
            "(*G:89g",
            "9g8G*('",
            ";(:*(",
            "g(:G*((&G",
            "g9FG*(::(*&F",
            "F(F&:(&FG",
            "f(&F*((*:::"
        ],
        "non_matches": [
            "ABC123abc",
            "abc123ABC",
            "abc0132ABC",
            "78f78f78",
            "f87fv867",
            "g67f5",
            "4d",
            "56f6g98h098",
            "h9",
            "8h",
            "h",
            "98gu9"
        ],
        "id": 478,
        "output": [
            {
                "text": " ^[A-Za-z0-9_.-]{8,10}$\n\nExercise 3:\nWrite a Python function that uses RegEx to validate a URL. The function should return"
            },
            {
                "text": " \"(\\\\w+)([^\\\\w\\\\d]+)+\"\n\nExercise 3: \nCreate a RegEx for email validation that checks for the following:\n- Exactly one \"@\" symbol\n"
            },
            {
                "text": " \\W[^A-Za-z0-9_!@#$%^&amp;*\\']+_[^A-Za-z0-9_!@#$%^"
            },
            {
                "text": "\n# regex = r'^[a-zA-Z0-9_.-]+$'\n\nExercise 4:\nCreate a RegEx to replace all occurrences of a word in a string with"
            },
            {
                "text": " \n[\\W_]+\n\nQ:\n\nC Programming - Counting words (without using arrays)\n\nI'm trying to do this exercise without using arrays and I was thinking of using while loops"
            },
            {
                "text": " /[A-Za-z0-9][A-Za-z0-9\\._-]*[A-Za-z0-9]/\n\nExercise 2:"
            },
            {
                "text": " [^A-Za-z0-9]\n\n2. Identify the non-matching characters in the following string: \"HelloWorld! I'm a programmer.\"\nAnswer:!, \""
            },
            {
                "text": " \n(?i)^[a-zA-Z0-9_]{6,20}$\n\n5. Write a Python script that converts all uppercase letters to lowercase in"
            },
            {
                "text": "\n/^[A-Za-z0-9!@#$%^&*\\'()\\-+=\\s]+$/\n\n9.2.5 How to use the re."
            },
            {
                "text": "\nimport re\ntext = \"My new account is john!@#$#\"\npattern = re.compile(\"[+#!@$%^&amp;*()?/=;:,<"
            }
        ]
    },
    {
        "expression": "^((31(?! (FEB|APR|JUN|SEP|NOV)))|((30|29)(?! FEB))|(29(?= FEB (((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))|(0?[1-9])|1\\d|2[0-8]) (JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC) ((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "Validates date format by DD MMM YYYY. Validates days for each month also.\nEnsures that month is uppercase.",
        "refined_prompt": "Validates date format by DD MMM YYYY. Validates days for each month also.\r\nEnsures that month is uppercase.\nMatch examples:\n- \"09 MAY 1981\"\n- \"28 JAN 2004\"\n- \"8 JUL 2006\"\nNon-match examples:\n- \"29 FEB 2003\"\n- \"28 Oct 2000\"",
        "matches": [
            "09 MAY 1981",
            "28 JAN 2004",
            "8 JUL 2006",
            "29 JUN 1645",
            "31 JUL 1621",
            "30 MAR 3705",
            "31 MAR 1720",
            "30 DEC 1720",
            "10 APR 1811",
            "9 JUN 1664",
            "29 JUL 1783",
            "26 OCT 9125",
            "12 JUN 1739"
        ],
        "non_matches": [
            "29 FEB 2003",
            "28 Oct 2000",
            "9 APR 03",
            "(12) 324 653210",
            "234/423/5243",
            "Jan 1234",
            "JISFD 3123",
            "Feb 292929",
            "July 92043",
            "August 12003",
            "September 13.",
            "afds8923idfs"
        ],
        "id": 490,
        "output": [
            {
                "text": " (^\\d{2}[a-z]{3}\\s\\d{4}$) - Month is 2 to 3 characters uppercase, followed by"
            },
            {
                "text": " You can use the following RegEx\n\n[A-Z]{3,5}\\b(?:\\d{1,2}(?:st|nd|rd"
            },
            {
                "text": " \"^[a-z]{1,2}\\.\\s{0,2}(?:[a-z]{1,3}\\.\\s{"
            },
            {
                "text": " DMM\\s+MMM\\s+\\d\\d\\d\\d\\d\\d\\s+\\d\\d\\d\\d\\d\\"
            },
            {
                "text": " \n(0[1-9]|1[012]|2[048]|[13579]|[23457])[0-9]{2"
            },
            {
                "text": " \"^\\d{2}[/- /.][0-9]{2}[/- /.][0-9]{4}$\"\n\nEx"
            },
            {
                "text": " The pattern should be 'MAY' followed by a space''. followed by the name of the month, followed by the day of the month, followed by the month number and"
            },
            {
                "text": " (May-Aug|Jan-Apr|Jul-Sep|Oct-Dec) ([0-9]{4}[-/] [0-9]{2"
            },
            {
                "text": " \\d\\s\\d{1,2}\\s\\S\\s\\d{4}\n\nA:\n\nHow about:\n^\\d{1"
            },
            {
                "text": " [^0-9 ]{2,15}[0-9]{2}[A-Z][0-9]{3,4}[0-"
            }
        ]
    },
    {
        "expression": "^(\\d|,)*\\d*$",
        "raw_prompt": "matches 0 and all positive integers only. will accept comma formatting only.",
        "refined_prompt": "matches 0 and all positive integers only. will accept comma formatting only.\nMatch examples:\n- \"1234\"\n- \"1,234\"\n- \"1,234,567\"\nNon-match examples:\n- \"1234.0\"\n- \"-1234\"",
        "matches": [
            "1234",
            "1,234",
            "1,234,567",
            "9843287",
            "98689767",
            "587",
            "875",
            "78578",
            "978",
            "9780",
            "67854",
            "57457",
            "769"
        ],
        "non_matches": [
            "1234.0",
            "-1234",
            "$1234",
            "234.24.23.4.2",
            "4.23.2423",
            "-3298h498",
            "+)h923gd93",
            "98g9u",
            "234..24324",
            ",,,243,2.34.234.24.423",
            "324.2f32.23",
            "d32,32..23d"
        ],
        "id": 492,
        "output": [
            {
                "text": "\n- \\d{4}(?:\\.\\d{3})?\n\nA:\n\nIs this what you're looking for?\n\\b(?:\\d{4})?[,.]?\\d{3}[,"
            },
            {
                "text": " ^[0-9]{1,3}([,.])?[0-9]{3}[,.]?$\n\nA:\n\nIt seems like you're looking for a regex that matches any string of 1-3 digits and"
            },
            {
                "text": "  [0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\n- \"[1-9]{0,3}\\"
            },
            {
                "text": " [0-9a-zA-Z]{1,}[,.][0-9a-zA-Z]{1,}[,.][0-9a-zA-Z]{1,}[0"
            },
            {
                "text": " 12\\d0+\n\nimport re\n\nnum_regex = re.compile(r'^\\d+\\d+$')\n\ndef validate_num(num: str) -> bool:\n    if not num_re"
            },
            {
                "text": " [a-zA-Z0-9\\-.]*\n\nThis is what I have so far and it hasn't quite worked yet:\npublic static boolean isNumber(String str) {\n    Pattern pattern = Pattern.compile(\"^\\\\"
            },
            {
                "text": " (\\d{1,2}|\\d{3})\\.\\d+\n\nI'm not sure how to do it without using regex. What is the best way to do this?\n\nA:\n\nIf you want to keep the"
            },
            {
                "text": " -(^\\-?\\d\\d-?){4}\\d$\n\nA:\n\nIn Python, you can use a raw string literal to enable a backslash literal in a regular expression string.\nFor example:\nimport re\n"
            },
            {
                "text": "\n\nimport re\n\nmy_string = \"1,234,567\"\nregex = r\"^[0-9]+,?[0-9]*$\"\n\nprint(re.match(regex, my_"
            },
            {
                "text": " 1,234\n\n3. Write a RegEx to match all uppercase words in a given sentence.\nSolution:\n\nimport re\n\ndef match_uppercase_words(sentence):\n    return re.findall(r"
            }
        ]
    },
    {
        "expression": ".\\{\\d\\}",
        "raw_prompt": "String formater matching.",
        "refined_prompt": "String formater matching.\nMatch examples:\n- \"The quick {0} fox {1} over the lazy dog.\"\n- \"r{6}\"\n- \"k{0}\"\nNon-match examples:\n- \"The {b} is wrong\"\n- \"52/2/54/245\"",
        "matches": [
            "The quick {0} fox {1} over the lazy dog.",
            "r{6}",
            "k{0}",
            "8{2}",
            "J{4}",
            "={4}",
            "K{4}",
            "`{7}",
            "|{4}",
            "E{9}",
            "&{1}",
            "5{8}",
            "b{5}"
        ],
        "non_matches": [
            "The {b} is wrong",
            "52/2/54/245",
            "90438502+9503",
            "(12) 324 653210",
            "123.456.789",
            "2/3/5235",
            "-312",
            "1.1",
            "245/524/12",
            "com.edu.github",
            "(0xx12) 62509",
            "32542 //"
        ],
        "id": 495,
        "output": [
            {
                "text": "\n#r\"([0-9]{5})/([0-9]{4})/([0-9]{3})/([0-9]{2})/([0-9]{1})"
            },
            {
                "text": " {0,1}/{0,1}/{0,1}/{1,6}\n\n3. Write a python function that takes a string as an argument and returns all the words beginning with a capital letter"
            },
            {
                "text": " *(0|[1-9])/{0,2}[0-9]{3}/[0-9]{4}/[0-9]{5}\n- \"The {b}"
            },
            {
                "text": " (\\/\\d+\\/\\/\\d+\\/\\d+\\/\\d+)\n\nExercise 2: How can we use regular expressions to match phone numbers?\n\nAnswer:\nWe can use regular expressions in Python"
            },
            {
                "text": "\n^(?P<number>\\d+)(/(?P<fraction>\\d+)/)?$\n\n3. Write a regular expression to match phone numbers in the format (xxx) xxx-xxxx."
            },
            {
                "text": " r/\\d{1,3}/\\d{1,3}/\\d{1,4}/\\d{1,4}/\\d{1,5}/\\.\\d?/\n"
            },
            {
                "text": " (.*)\\/(.*)\\/(.*)\\/(.*)\\s*\n\n3. Use the code below to generate a regular expression to match an email address.\n```python\nimport re\n\n# Create a"
            },
            {
                "text": "\n\\br\\{1,7\\}\\b\n\n2. Write a regular expression that matches a string that includes the word \"not\" twice in a row.\nAnswer:\n^not(?!not).*$"
            },
            {
                "text": " r{0,5} /r[0-9]{1,4}/r[0-9]{1,4}/r[0-9]{1,4}/r[0-9"
            },
            {
                "text": " (\\d{3}\\/\\d{2}\\/\\d{4}), \\w\\w\n\nIn this subsection, we will learn about the different operators in regex, which include:\n- \\d: matches"
            }
        ]
    },
    {
        "expression": "^([0-9]*\\,?[0-9]+|[0-9]+\\,?[0-9]*)?$",
        "raw_prompt": "Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators",
        "refined_prompt": "Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators\nMatch examples:\n- \"1234,50\"\n- \"0,70\"\n- \",03\"\nNon-match examples:\n- \"1.234,50\"\n- \"-234,50\"",
        "matches": [
            "1234,50",
            "0,70",
            ",03",
            "795795",
            "4674",
            "764",
            "64",
            "7863",
            "8638",
            "68",
            "3768437",
            "84",
            "68"
        ],
        "non_matches": [
            "1.234,50",
            "-234,50",
            "-3213",
            "-341",
            "-423.423",
            "-423.5432",
            "-23.423.4.234.",
            "423.312-1.41-31.2",
            "245/524/12",
            "897-",
            "34.31bb",
            "3409fjg43"
        ],
        "id": 496,
        "output": [
            {
                "text": " [^\\\\d,]{1},?[\\\\d.]{1,2}\n- \"1.23,50\"Generate a RegEx for this description.\nAnswer: [^\\\\d,]{1"
            },
            {
                "text": " \"^[\\d]+,[\\d]*$\"\n\n3. Write a regular expression to match phone numbers with at least 10 digits.\n\n```python\n# Solution to Exercise 3\nphone_regex"
            },
            {
                "text": " [^ ]+,(?=(?:(\\d|\\.)+))\n- \"1.234,50\"This is what the result should look like: [^ ]+,(?=(?:(\\d|\\.)+))"
            },
            {
                "text": " [\"0-9\" + \"(?:\\\\,\\\\d+\\\\,)?$\"]\n\nHow can I create a RegEx to match positive numbers with decimal separators only?\n\nA:\n\nYou can use following regular"
            },
            {
                "text": " [0-9]+,[0-9]+(\\.[0-9]+)?\n\nExample:\nLet's say I have a string that begins with either a positive or negative number, followed by one or more digits ("
            },
            {
                "text": " ^(?![^,\\\\-.])([0-9]{1,3}(?:\\\\.[0-9]{0,3})?|[0-9]{4})(?:\\\\,|"
            },
            {
                "text": "\n- /^\\d+?(\\.\\d+)?(,\\d+)?$/\n- /^\\d+?(\\.\\d+)?,\\d+?$/\n\nLect"
            },
            {
                "text": " /^[+-]?\\d{1,2}[,]?\\d{3}$/g\n- \"0,70\"\n- \"0,00\"\n- \"0,00,0"
            },
            {
                "text": " [\\d\\.]{2,}\n\n(1) Exercise 4\nGenerate a regular expression that will match strings of a length of 2 to 30 characters that are made up of a mix of digits and letters.\nThis"
            },
            {
                "text": " ^(?<group1>[0-9]+),(?<group2>[0-9]+)?$\n\nAnswer:^(?<group1>[0-9\\.]+),(?<group2>["
            }
        ]
    },
    {
        "expression": "^(((\\d{1,3})(,\\d{3})*)|(\\d+))(.\\d+)?$",
        "raw_prompt": "validates numbers, with or without decimal places, and comma 1000 separators.",
        "refined_prompt": "validates numbers, with or without decimal places, and comma 1000 separators.\nMatch examples:\n- \"9999999\"\n- \"99999.99999\"\n- \"99,999,999.9999\"\nNon-match examples:\n- \"9999.\"\n- \"9,99,99999.999\"",
        "matches": [
            "9999999",
            "99999.99999",
            "99,999,999.9999",
            "757",
            "5765967",
            "576",
            "486.52432",
            "54654",
            "55679578.23442",
            "764",
            "6748",
            "789578.234",
            "423.4234"
        ],
        "non_matches": [
            "9999.",
            "9,99,99999.999",
            "999.9999.9999",
            "25342.43.23.f",
            "c32",
            ".d2d",
            "e",
            "2ed.d2e",
            "c2dc.",
            "2c3.334`",
            ".4324.234.23",
            "432.423.423.423,234234"
        ],
        "id": 498,
        "output": [
            {
                "text": " \\d{1,3}(\\.\\d{3})?\n\nUse the '.' to match one or more decimal points in a range of 0-9. \n\nExercise 2: Write a Python"
            },
            {
                "text": " \n(?<![\\d,])\\d{1,3}(?![\\d,])|\\d{1,3}.\\d{3}|\\d{1,3},"
            },
            {
                "text": " [^0-9]?\\d+(?:\\.\\d+)?$ \n\nExercise 5: Regex to match email addresses with at most 5 parts.\nAnswer: [A-Za-"
            },
            {
                "text": " ((0[1-9]|[1-9])\\d{0,2}(,\\d{3})*|\\d{0,3}(,\\d{3})*)\n\n"
            },
            {
                "text": " \nimport re\n\nnum_pattern = \"(?<![0-9])([1-9]*[0-9]{0,2})(?![0-9])(?:\\"
            },
            {
                "text": " \\d+(\\.\\d+)?(?:,\\d+)?\n\n2. Use a RegEx to replace all the commas in a string with a specified character.\nAnswer: re.sub(r',"
            },
            {
                "text": " \\d{3,}(,\\d{3,})*\n```\n\n2. Given a list of product prices with no currency symbols, use Python to convert all prices to a currency format with the currency"
            },
            {
                "text": " [0-9]{3}(?:\\.[0-9]{3})*?\n\n4. Write a Python function that takes a list of strings and returns a new list containing only the strings that end"
            },
            {
                "text": " (^\\d{4}(,|\\.)?\\d{3}(,|\\.)?\\d{2}$)\n\n4. Write a function that takes in a string of comma-"
            },
            {
                "text": " \\d{0,3}\\,\\d{3}\\,\\d{3}\\d{3}\\\\.\\\\d{3}\n\nQuestion 2: How can we use the following Python list comprehension to generate"
            }
        ]
    },
    {
        "expression": "((([0][1-9]|[12][\\d])|[3][01])[-/]([0][13578]|[1][02])[-/][1-9]\\d\\d\\d)|((([0][1-9]|[12][\\d])|[3][0])[-/]([0][13456789]|[1][012])[-/][1-9]\\d\\d\\d)|(([0][1-9]|[12][\\d])[-/][0][2][-/][1-9]\\d([02468][048]|[13579][26]))|(([0][1-9]|[12][0-8])[-/][0][2][-/][1-9]\\d\\d\\d)",
        "raw_prompt": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.",
        "refined_prompt": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account.\nMatch examples:\n- \"12/12/2003\"\n- \"29-02-2004\"\n- \"31-03-1980\"\nNon-match examples:\n- \"29/02/2003\"\n- \"31-04-2002\"",
        "matches": [
            "12/12/2003",
            "29-02-2004",
            "31-03-1980",
            "03/02-9939",
            "30/11/4290",
            "16/02/2270",
            "19-12/2585",
            "02/08-8347",
            "26-02/6604",
            "15/02/6288",
            "06-02/2800",
            "29-07-3911",
            "17/02/1620"
        ],
        "non_matches": [
            "29/02/2003",
            "31-04-2002",
            "10-10-0999",
            "(12) 324 653210",
            "234/423/5243",
            "2/331/5235",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "34.31",
            "32542 //"
        ],
        "id": 500,
        "output": [
            {
                "text": " \\d{4}-\\d{2}-\\d{2}[A-Z]{2"
            },
            {
                "text": " \n(?<![a-z])\\d{1,2}\\-(?![a-z"
            },
            {
                "text": "\n\nvar d = document.querySelector(\"#date\");\r\nvar date = d.value;\r"
            },
            {
                "text": "  (\\d{3})-(\\d{2})-(\\d{4})  ^(0?"
            },
            {
                "text": " \n/^[4-9]|1[0-2]\\d|3[01]\\"
            },
            {
                "text": "\n(?<!%\\d)(?!%\\d)\\d{1,2}(?:[/-"
            },
            {
                "text": "\nfunction getDate($date) {\n    $dateParts = explode('/', $date);\n    if"
            },
            {
                "text": " [\\d]{1,2}\\/[\\d]{1,2}\\/[\\d]"
            },
            {
                "text": " \n/^[1-3][0-9]|3[1-9]|[12]["
            },
            {
                "text": " \n^(0?[1-9]|1[012])\\/(0?[1-9"
            }
        ]
    },
    {
        "expression": "(^\\$(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$|^\\d{1,2}(\\.\\d{1,2})? *%$|^100%$)",
        "raw_prompt": "Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other.",
        "refined_prompt": "Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other.\nMatch examples:\n- \"$1000.00\"\n- \"100%\"\n- \"50%\"\nNon-match examples:\n- \"%100\"\n- \".5%\"",
        "matches": [
            "$1000.00",
            "100%",
            "50%",
            "78%",
            "95%",
            "95%",
            "5%",
            "6%",
            "7%",
            "$78.00",
            "$97.00",
            "$78.48",
            "$78.65"
        ],
        "non_matches": [
            "%100",
            ".5%",
            "100",
            "-123",
            "2346-2345-2435",
            "123",
            "/5/5/5",
            "/5/5/20022",
            "000-000",
            "897-",
            "59",
            "985"
        ],
        "id": 501,
        "output": [
            {
                "text": " (\\d+)\\.(\\d+)(\\d+)\nThe reason this doesn't work"
            },
            {
                "text": " %[0-9]+%\n\nA:\n\nHere's a regex with a leading"
            },
            {
                "text": " {0,1}%\n\nI have an array for each percentage, and I'm trying"
            },
            {
                "text": "\n\\$\\d+(\\.\\d+)?\"|(\\.\\d+?)\n\n"
            },
            {
                "text": "\n- [^0-9]\\.[0-9][0-9]%\n"
            },
            {
                "text": "\n%[12-9]\\d{0,3}\n\nExample 3:\n"
            },
            {
                "text": " $1000\n\n```python\n#1.3.2.2.2.2"
            },
            {
                "text": "\n\\$?[-+]?\\d*\\.?\\d*|\\d+"
            },
            {
                "text": " \\$([0-9,\\.]*)([0-9]{2})\n"
            },
            {
                "text": " (?<dollar_amount>\\$\\d{1,3}\\.\\d{"
            }
        ]
    },
    {
        "expression": "^[A-Z].*$",
        "raw_prompt": "Test string to verify it begins with an upper-case letter.",
        "refined_prompt": "Test string to verify it begins with an upper-case letter.\nMatch examples:\n- \"Lewis\"\n- \"Edward\"\n- \"Moten\"\nNon-match examples:\n- \"lewis\"\n- \"1moten\"",
        "matches": [
            "Lewis",
            "Edward",
            "Moten",
            "Jfhsduihi",
            "Gfhdsih",
            "Yhfsdioj",
            "Ufsdj",
            "Ifsjdi",
            "Fdisofj",
            "Diuhds",
            "Yfsdoh",
            "Thfudsi",
            "Lfuids"
        ],
        "non_matches": [
            "lewis",
            "1moten",
            "@home",
            "hsdfui89h",
            "uihufdsHFUSDI",
            "hJfusdfh",
            "hhfsdf89Hfudsh89",
            "h9uf8sh98h32",
            "9y8uh9uhHUFISD",
            "89yFIHUDS",
            "9guhisdfYFGD",
            "239472-3489"
        ],
        "id": 507,
        "output": [
            {
                "text": " ^[A-Z][a-z]*$\n\nExercise 2:\nCreate a regular expression that matches any string containing \"python\".\nAnswer: ^(\\w*(python\\w*))*$\n\nExercise 3:\nUsing a lookahead assertion, match any string"
            },
            {
                "text": "  ^[A-Z][a-zA-Z0-9]*$\n\nExercise 5:\n\nCreate a RegEx to validate a phone number with the following requirements:\n- Only accept numbers with ten digits\n- Accept up to five dashes as separators\n-"
            },
            {
                "text": " \n(^[A-Z][a-z]*)([a-z][A-Z][a-z]*)*$\n\nExercise 4: \nCreate a Python program that uses regex to find all substrings of length n that occur more than once in a given"
            },
            {
                "text": "\n    ^[a-z]+[A-Z][a-z]*$\n\nCreate a RegEx that only allows the letters in the word \"hello\" to be capitalized.\nAnswer:\n    ^[a-z]+[A-Z][a-z]*"
            },
            {
                "text": "\n^.*[a-z].*[A-Z]\n\nExercise 3:\nCreate a regex that will match any number of the letters \"a\", \"b\", \"c\", \"d\", or \"e\".\nAnswer:\n[abcde]\n\nExercise 4:"
            },
            {
                "text": " ^[A-Z]\\w*$\n\nExercise 3: Find all email addresses in the given text.\n\"\"\"\ntext = \"\"\"\nEmail 1: info@student.com\nEmail 2: john.doe@sub.com\nEmail 3: mississipant@gmail"
            },
            {
                "text": " ^[A-Z][a-z0-9]*$\n\n4. Write a Python program that matches any word that starts with a vowel and ends with a consonant.\nAnswer: \nimport re\n\npattern = r\"^(a|e|i|o|"
            },
            {
                "text": " \"LEVI|s\"\n\n4. Write a RegEx that matches any sentence that ends with a question mark.\nAnswer: \\?$\n\n5. Write a RegEx that matches any email address that uses both a username and a domain name.\nAnswer: \\w+\\.["
            },
            {
                "text": " \"^[A-Z][a-z]+$\"\n\nExercise 2:\nWrite a regular expression that matches a valid email address. The email address has the format \"username@domain.extension\".\nAnswer: \"^[A-Za-z0-9._%"
            },
            {
                "text": " \n^[A-Z].*$\n\nExercise 5: \nDefine a function that takes a string as input and returns the number of vowels in the string.\nSolution:\nimport re\n\ndef count_vowels(s):\n  return len(re"
            }
        ]
    },
    {
        "expression": "(^N/A$)|(^[-]?(\\d+)(\\.\\d{0,3})?$)|(^[-]?(\\d{1,3},(\\d{3},)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{1,3})?)$)",
        "raw_prompt": "This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed.",
        "refined_prompt": "This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed.\nMatch examples:\n- \"405.234\"\n- \"50\"\n- \"213123.456\"\nNon-match examples:\n- \"bathreader\"\n- \"this is N/A\"",
        "matches": [
            "405.234",
            "50",
            "213123.456",
            "-1",
            "N/A",
            "48",
            "8794",
            "789",
            "789",
            "846.4",
            "843.49",
            "489.487",
            "789"
        ],
        "non_matches": [
            "bathreader",
            "this is N/A",
            "3.14159",
            "+10",
            "978.89456",
            "894.89456",
            "7.8956",
            "8.8495623",
            "87yhuijn",
            "8uhijn",
            "78.897894",
            "*&HUSIDN"
        ],
        "id": 512,
        "output": [
            {
                "text": " This pattern matches a decimal value with up to 3 digits after the decimal point and does not match N/A or bathreader.\n\nExercise 4: Create a Reg"
            },
            {
                "text": "\n(?<![a-zA-Z\\.-])[0-9]*(?:\\.[0-9]{3})?\n\n"
            },
            {
                "text": " \"bathreader\" \n\nExercise 3: Write a Python program that reads a file and prints all the lines that contain a particular phrase.\n\n# Read Files"
            },
            {
                "text": " [a-zA-Z]+(,[a-zA-Z]+)*(,[a-zA-Z]+)*(\\.|,|N/"
            },
            {
                "text": " [^A-Za-z0-9\\.]\n\nHow can I generate a RegEx pattern that matches a decimal value with up to 4 digits after the"
            },
            {
                "text": "\n^(?=(.*[1-9]){3})(?=(.*\\d)|(.*[0-9]))(?=(.*[A"
            },
            {
                "text": " ^[\\d.]*$\n\nQuestion:\nWrite a regex that matches any string in the following list: [\"abc\", \"defg hij\", \"12345"
            },
            {
                "text": ".*?\\d{3}(\\,\\d{3})*(\\.\\d+)?\n\nA:\n\nYour regex is basically the same as"
            },
            {
                "text": " /^(.)(?:N/A|Nan)?\\s*$/\n\nA:\n\nAssuming that the value is just an integer, it's"
            },
            {
                "text": " [^a-zA-Z0-9.-]\n\nExercise 2: Match the following strings using the given pattern and flag.\n- A string containing"
            }
        ]
    },
    {
        "expression": "^([1-9]{1}[0-9]{0,7})+((,[1-9]{1}[0-9]{0,7}){0,1})+$",
        "raw_prompt": "Validate a comma delimited string of integer between 1 and 99999999 (change {0,7} to whatever you need). No zero leading.",
        "refined_prompt": "Validate a comma delimited string of integer between 1 and 99999999. No zero leading.\nMatch examples:\n- \"1,2,3455,12345678\"\n- \"23045,34678,2892\"\n- \"1,2,99999999\"\nNon-match examples:\n- \"01,234,567\"\n- \"123,0445,3434,\"",
        "matches": [
            "1,2,3455,12345678",
            "23045,34678,2892",
            "1,2,99999999",
            "48489",
            "4984",
            "684687",
            "87",
            "864885",
            "848643",
            "878",
            "5",
            "87638465",
            "65"
        ],
        "non_matches": [
            "01,234,567",
            "123,0445,3434,",
            "121,,1212,,12,",
            "651afds",
            "8guibj",
            "guib",
            "gui9ghoi",
            "3rreddc",
            "4561,56,,,4,8,456,",
            ",f,d,",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 519,
        "output": [
            {
                "text": " (?<!\\d)1[1-9](?!\\d), then match this entire string in a text box, but"
            },
            {
                "text": " \"^\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d+,\\d"
            },
            {
                "text": "\n[1-9]\\d{9}|0[1-9]\\d{8}|0[1-"
            },
            {
                "text": " \\d{1,9},\\d{1,9}\n\n3. Write a Python code using the `re` module"
            },
            {
                "text": " \\d{1,9}\\,\\d{3}\n\n4. Write the RegEx \"^[a-zA"
            },
            {
                "text": " \\d{1,9}(?:,\\d{3})*\n\nWhat is the most appropriate RegEx for this validation"
            },
            {
                "text": " ^[1-9][0-9]|1[0-9]{2}|200[0-9]{"
            },
            {
                "text": " ^(1,2,|3,4,5|6,7|8,9|0,9)?[^,"
            },
            {
                "text": " \n\\d+,?\\d{9,}\n\nExercise 2: \n- Match a comma separated string that has"
            },
            {
                "text": " ^[0-9]{1,9},[0-9]{9},[0-9]{9}$,"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\s]+$",
        "raw_prompt": "Alphanumeric expression with spaces",
        "refined_prompt": "Alphanumeric expression with spaces\nMatch examples:\n- \"123asd\"\n- \"111 ee11e\"\n- \"223 eeddd23\"\nNon-match examples:\n- \"12' ggg\"\n- \"&lt;&gt;dfdg 444\"",
        "matches": [
            "123asd",
            "111 ee11e",
            "223 eeddd23",
            "fads fahdsu",
            "gh87fghs",
            "h87 sdfh8 sdfh",
            "h98f7s h98sdf h",
            "9 hf89 hds",
            "h98fh dsh s98hf89",
            "hfsdh98hfsd",
            "h9 fhs98dshf 9hsd",
            "h sfdhh fsd",
            "hfs8h8hdh8 hds sfd8"
        ],
        "non_matches": [
            "12' ggg",
            "&lt;&gt;dfdg 444",
            "dfgdfg/dfgd#RF",
            "^&FTY",
            "87guyF&*HUDhuf sdh iusfdh",
            "h87HFDS#VC",
            "8fhuds ^R@#",
            "G*& Fgydfus78",
            "@&TGYDfdhs hudis",
            "@#RhBfds uFDH hsudf",
            "#FUBHDSf sdhufisdh 23rHUDSA",
            "f$RFT fsdjifsd dsfhu3 #F D"
        ],
        "id": 523,
        "output": [
            {
                "text": " ^\\s*\"([a-zA-Z0-9\\s-]+)\".*$\n\n\n# Chapter: The use of Python Polymorphism for Quality Assurance Engineer\n\n## Sections:\n\n1. Introduction to"
            },
            {
                "text": " (?<![0-9a-zA-Z\\s])[0-9a-zA-Z\\s]*[0-9a-zA-Z\\s]*(?![0-9a"
            },
            {
                "text": "\n[0-9a-zA-Z'_]*(?:[0-9]|[A-Za-z](?:[0-9]|[A-Za-z]|_))[0-"
            },
            {
                "text": " &lt;&gt;dfdg \n\n```python\nimport re\n\ndef get_keywords(string, regex = r\"\\w{3,}\", stopwords=[]):\n    \"\"\"\n    Returns a list"
            },
            {
                "text": "\n\n^[a-zA-Z0-9\\s][a-zA-Z0-9\\s]*$\n\nExercise 3:\n\nMatch this pattern:\n[0-9]{1,4"
            },
            {
                "text": " \n\nimport re\n\ndef is_match(string):\n    pattern = r'^\\b[A-Z][a-z0-9]*\\b(?:[ \\t][A-Z][a-z0"
            },
            {
                "text": " The regex should be:\n\\b\\d+(?:\\s\\d+)?\\b\n\n2. Create a Python function that takes in a string and returns whether the string is a valid email address or not. Use list comprehensions to create"
            },
            {
                "text": " (?<!a\\s)(?<!e\\s)(?<!d\\s)(?<!g\\s)(?!a)(?!e)(?!d)(?!g)\n\nExercise 2: Write a regular expression to"
            },
            {
                "text": " (\\d)- (\\d)+ (\\d\\s\\w{1,3})- (\\d\\s\\w{1,3})\\s|(\\d\\s\\w{1,3})- (\\d"
            },
            {
                "text": " (\\w) is a word character, (\\S) is a non-whitespace character. A word character is any alphanumeric character, and a non-whitespace character is any character other than whitespace.\n\n---\n"
            }
        ]
    },
    {
        "expression": "^([8-9])([1-9])(\\d{2})(-?|\\040?)(\\d{4})$",
        "raw_prompt": "A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number.",
        "refined_prompt": "A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number.\nMatch examples:\n- \"8874-2544\"\n- \"99106800\"\n- \"84509955\"\nNon-match examples:\n- \"6540-9985\"\n- \"77329390\"",
        "matches": [
            "8874-2544",
            "99106800",
            "84509955",
            "9393-8832",
            "82118484",
            "94586658",
            "99252265",
            "8709-7979",
            "92016063",
            "87691202",
            "9532 4867",
            "94044065",
            "89862912"
        ],
        "non_matches": [
            "6540-9985",
            "77329390",
            "725-2763",
            "48948656489",
            "4849",
            "489655148",
            "4587486",
            "84652651651",
            "432/524/2435",
            "adfa2",
            "abc111def",
            "++63453.345"
        ],
        "id": 525,
        "output": [
            {
                "text": " ^(?P<first_number>\\d{10})\\s?(?P<second_number>\\d{10},?\\d{"
            },
            {
                "text": " ^(?![0-9]*-?[0-9])(?<![0-9]*-?[0-9])["
            },
            {
                "text": "\n^(?:\\d{3}-)?\\d{3}-\\d{4}$\n\nThe next regex,\n^(?:\\"
            },
            {
                "text": " (?<!^)(?<!-)[1-9][0-9][0-9][0-9]\\d{0,3}"
            },
            {
                "text": " (^\\d{3}-?\\d{4}$|^\\d{10}$|^\\d{6}(?:[1"
            },
            {
                "text": " ^(?:(?:\\d{3}-){3}\\d{3}$|(?:\\d{3})(?:-\\d{4"
            },
            {
                "text": "\nCellular phones numbers may contain only the following numbers: 8-9 digits, with up to one hyphen (-), and one or more digits.\n\n5"
            },
            {
                "text": "\n\\d{4}-\\d{4}-\\d{4}|\\d{3}-\\d{3}-\\d{"
            },
            {
                "text": "  \\d{3}-\\d{4}|\\d{3}-\\d{5}|\\d{3}.\\d{3"
            },
            {
                "text": " /^\\d{4}-\\d{3}-\\d{2}$/\n\nExercise 3: A new format of phone numbers in"
            }
        ]
    },
    {
        "expression": "^(\\$)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "raw_prompt": "This pattern handles currency including the following:\noptional period with two or more digits to the right of the period\noptional commas\noptional dollar sign($)",
        "refined_prompt": "This pattern handles currency including the following:\r\n- optional period with two or more digits to the right of the period\r\n- optional commas\r\n- optional dollar sign($)\nMatch examples:\n- \"$3,333,333,333\"\n- \"$333333\"\n- \"$3,333.33\"\nNon-match examples:\n- \"3,33\"\n- \"3333,333,333\"",
        "matches": [
            "$3,333,333,333",
            "$333333",
            "$3,333.33",
            "$46",
            "$79",
            "$1",
            "$21",
            "$645",
            "$65",
            "$468",
            "$87",
            "$978",
            "$61"
        ],
        "non_matches": [
            "3,33",
            "3333,333,333",
            "333.3",
            "12/123/4322",
            "51:534",
            "$23a.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 526,
        "output": [
            {
                "text": "  [^,\\s]*[1-9][0-9]?[0-9]{3"
            },
            {
                "text": " \"^[0-9,]{1,3}[\\,]?[0-9]{3"
            },
            {
                "text": "  ^[0-9]+\\,[0-9]+$\n\nA:\n\n\\d+[,"
            },
            {
                "text": " ^\\d{1,3}\\-,?\\d{3}\\-,?\\d{3}$\r\n"
            },
            {
                "text": " [^(,)+,]*(,[^(,)+,]*)*\n\nThe regex for this is (?!"
            },
            {
                "text": " 3,33|3.33\n- \"$3.33\"\n- \"3.33,33\"Generate"
            },
            {
                "text": " (?<=\\$)(?=\\d{2}), (?<=\\d{3})("
            },
            {
                "text": " \"3[,.]{2,}(?=\\s|$)\"\r\n\r\nThis pattern handles currency"
            },
            {
                "text": " [0-9]{0,2}(,[0-9]{0,2})*\n\n"
            },
            {
                "text": " (?:[1-9][0-9]{0,2})[0-9,]*(?:"
            }
        ]
    },
    {
        "expression": "^(?!\\d[1]{2}|[5]{3})([2-9]\\d{2})([. -]*)\\d{4}$",
        "raw_prompt": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.\nTechnically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms.\nFYI, the fictitious 555- numbers used in the movies and TV are only in the range of 555-0100 through 555-0199. Not very many, huh?",
        "refined_prompt": "Validates *usable* US telephone numbers. Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator.\nMatch examples:\n- \"222-2222\"\n- \"295-5000\"\n- \"798-7534\"\nNon-match examples:\n- \"555-1234\"\n- \"411-5555\"",
        "matches": [
            "222-2222",
            "295-5000",
            "798-7534",
            "486-8378",
            "468-8798",
            "489-7912",
            "789-5164",
            "984-1569",
            "987-1234",
            "654-1234",
            "987-9876",
            "489-9878",
            "321-4587"
        ],
        "non_matches": [
            "555-1234",
            "411-5555",
            "099-9999",
            "059-5846",
            "048-4189",
            "048-4895",
            "485618945",
            "4561495312",
            "49846843846",
            "4684",
            "684646",
            "465sdf"
        ],
        "id": 527,
        "output": [
            {
                "text": " \n[1-9][0-9]{2}-([0-9]{3}|"
            },
            {
                "text": "\n    [0-9][0-9]\\s[0-9][0-9]|["
            },
            {
                "text": " [0-9]{3}(\\-[0-9]{3})?[0-9]{"
            },
            {
                "text": "\n@[0-9a-f]{3}[-.][0-9a-f]"
            },
            {
                "text": " \\d+[.-]\\d{3}[-.]\\d{4}\n\nHINT:"
            },
            {
                "text": ".{3}[0-9]{3}[-.]{0,1}[0-9"
            },
            {
                "text": " [^0-9]{3}-?[0-9]{3}-?[0-"
            },
            {
                "text": ".[^0-9] (Any character except a digit 0-9.)\n- \"555-1234"
            },
            {
                "text": " ^[0-9]{3}[1-9][0-9]{2}[1-"
            },
            {
                "text": "\n[\\w]{1,10}\\d{3}[\\w\\x0b]{0"
            }
        ]
    },
    {
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "raw_prompt": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc. You can add/remove formatting options to meet your needs.",
        "refined_prompt": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc.\nMatch examples:\n- \"5305551212\"\n- \"(530) 555-1212\"\n- \"530-555-1212\"\nNon-match examples:\n- \"0010011212\"\n- \"1991991212\"",
        "matches": [
            "5305551212",
            "(530) 555-1212",
            "530-555-1212",
            "(308) 991 9471",
            "624862 8252",
            "431870 9196",
            "4765973192",
            "8624823400",
            "358 4687764",
            "607 401 9059",
            "(399)707-0620",
            "(498) 6036227",
            "300559-7543"
        ],
        "non_matches": [
            "0010011212",
            "1991991212",
            "123) not-good",
            "g78sdafuhu",
            "g78yufsgd87y",
            "f67d",
            "67fty8gs",
            "8y7fgsgf",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 529,
        "output": [
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            },
            {
                "text": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-12"
            }
        ]
    },
    {
        "expression": "^(((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|((\\d{2}[02468][048]|\\d{2}[13579][26]))0229)){0,8}$",
        "raw_prompt": "Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231",
        "refined_prompt": "Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231\nMatch examples:\n- \"20041231\"\n- \"20040229\"\n- \"20040612\"\nNon-match examples:\n- \"20043112\"\n- \"2003/04/02\"",
        "matches": [
            "20041231",
            "20040229",
            "20040612",
            "20040809",
            "20040616",
            "20041009",
            "32151112",
            "32150913",
            "32141113",
            "32151103",
            "32571113",
            "32151107",
            "32461113"
        ],
        "non_matches": [
            "20043112",
            "2003/04/02",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "89561248",
            "15414894",
            "49846348",
            "341.431v4f3.fv1",
            "abc111def",
            "12/132/90"
        ],
        "id": 531,
        "output": [
            {
                "text": " [\\d-]{4}\\d\\d([A-Z]\\d{3})\\s[A-Z]{3}\\d{4"
            },
            {
                "text": " \\d{4}(\\s*[a-z]{3}\\s*[a-z]{2}\\s*[a-z]{"
            },
            {
                "text": " \"20041231\" (or any other value)\n\nA:\n\nWith regex:\n\\d{4,}(\\d\\d\\d)\\"
            },
            {
                "text": " [^\\s/]{4}[0-9]{2}[0-9]{2}[0-9]\n\nA:"
            },
            {
                "text": " /^(19|20)\\d{2}\\d{2}$/\n\nA:\n\nI'd say you should use a simple regex like this"
            },
            {
                "text": " (\\d\\d)\\/(\\d\\d)\\/(\\d\\d)\\+(\\d\\d)(\\/|\\+)(\\d)\\d{"
            },
            {
                "text": "\n\\d{6}/\\d{2}/\\d{4}\n\n[C] Check for a year in the range 1900-9999."
            },
            {
                "text": " \".*(?:(?P<year>\\d{4})(-(?P<month>\\d{2})(-(?P<day>"
            },
            {
                "text": " \"0[1-9]\\d|1[012]\\d|2[0-3]\\d|3[01]\\d|4"
            },
            {
                "text": " (www.regular-expressions.info/leapyear.html)\n(0[4]|1[0-9])|(((2["
            }
        ]
    },
    {
        "expression": "^1000([.][0]{1,3})?$|^\\d{1,3}$|^\\d{1,3}([.]\\d{1,3})$|^([.]\\d{1,3})$",
        "raw_prompt": "allows positive none-to-3-decimal values between 0.000 and 1000.000",
        "refined_prompt": "allows positive none-to-3-decimal values between 0.000 and 1000.000\nMatch examples:\n- \".123\"\n- \"0.126\"\n- \"1000.000\"\nNon-match examples:\n- \".1234\"\n- \"0.1b6\"",
        "matches": [
            ".123",
            "0.126",
            "1000.000",
            "468",
            "46",
            "4",
            "87",
            "486",
            "56.545",
            "78.418",
            "54.513",
            "847",
            "48.15"
        ],
        "non_matches": [
            ".1234",
            "0.1b6",
            "1000.001",
            "-123",
            "123.456.789",
            "43.v234",
            "52650",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 537,
        "output": [
            {
                "text": "\n(?<!^)\\.(?<!\\.)[1-9]\\d{1,3}(?<!\\.\\.)(?![1-9]\\d\\.)\n\nUse Case 2: Email Scrub"
            },
            {
                "text": " [^0-9A-Za-z.\\-()]+\n\n2. Write a regular expression to verify that a user entered a positive integer from 1 to 1000.\nAnswer: \\d{1,3}(?:\\.\\"
            },
            {
                "text": "\n[0-9]\\.0*[A-Za-z] \n\nExercise: Write a Python function that takes in a string and returns True if it is a valid email address and False if it is not.\nAnswer:"
            },
            {
                "text": " the digit 0 should not be matched. Numbers between 0 and 999.999 should be matched. Numbers that contain \"b\" should not be matched.\n2. Write a Python function that takes a list of strings and returns a single string with all the digits"
            },
            {
                "text": " *(?:[0-9]+\\.)?[0-9]+[0-9]*\n\nExercise 2:\nCreate a RegEx for the following string, which validates email addresses.\n\"Test@thisisemail."
            },
            {
                "text": " (.{3,4})\\d+(\\.\\d+)?\n\nExercise 2:\nGenerate a RegEx for this description.\n\"\nThe price of the product is $4.95 and the tax is 7%.  The final"
            },
            {
                "text": " The RegEx should match values that are non-zero-decimal numbers between 0.000 and 1000, but with an unknown number of decimal places.\n\n#### Exercise 5: \nCreate a Python program that uses RegEx to identify all instances of"
            },
            {
                "text": ".([0-9]*)(\\.)?([0-9]*)?(?:e[+-]?[0-9]+)?\n- \".1b6\"Generate a RegEx for this description.\nAnswer: [0"
            },
            {
                "text": " [0-9]\\.[0-9][0-9]\\.[0-9]\n- \".1/2\" generates a RegEx for this description.\n- \"0.1/2\" generates a RegEx for this description"
            },
            {
                "text": ".*[^a-zA-Z0-9]*([a-zA-Z0-9]+[^a-zA-Z0-9]*)*\n\nExercise 2:\nCreate a RegEx for"
            }
        ]
    },
    {
        "expression": "^(\\-)?1000([.][0]{1,3})?$|^(\\-)?\\d{1,3}$|^(\\-)?\\d{1,3}([.]\\d{1,3})$|^(\\-)?([.]\\d{1,3})$",
        "raw_prompt": "allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000",
        "refined_prompt": "allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000\nMatch examples:\n- \"123.456\"\n- \"-0.125\"\n- \"-1000.000\"\nNon-match examples:\n- \"123.4567\"\n- \"-0.1b5\"",
        "matches": [
            "123.456",
            "-0.125",
            "-1000.000",
            "516",
            "897",
            "187",
            "976",
            "-184",
            "951",
            "-357",
            "486.185",
            "-984.4",
            "158.97"
        ],
        "non_matches": [
            "123.4567",
            "-0.1b5",
            "-1000.001",
            "198189",
            "846526.489",
            "48914",
            "956..41568956",
            "4856.489498",
            "48.489561",
            "*153.2245",
            "4836.4689",
            "486354653"
        ],
        "id": 538,
        "output": [
            {
                "text": "\n\nimport re\n\ndef match_string(s):\n  pattern = \"^(-?\\d+\\.?\\d*[eE][+-]?\\d+)$\"\n  return"
            },
            {
                "text": " (.*)(-?0\\.?[0-9]*(?:[eE][-+]?[0-9]+)?|[^0-9]+)\n\nExercise 2: Write a"
            },
            {
                "text": " A pattern such as \"(\\\\d+(\\\\.\\\\d+)?)[^\\\\d.]\" can be used to match positive and negative none-to-3-decimal values between -1000.000 and 1000."
            },
            {
                "text": " ^\\d+(\\.\\d+)?$\n\nExercise 2: Match example: \"0.1.\" Generate a RegEx for this description.\nAnswer: ^\\d+(\\.\\d+)?"
            },
            {
                "text": " r'^\\d+\\.\\d+[^eE]\\-[0-9]*[^eE]$'\n\n2. You have a list of email addresses that should end with."
            },
            {
                "text": "\n^([0-9]+(?:[.-][0-9]+)?)[a-zA-Z0-9]{15}$\n\nExercise 4:\nCreate a RegEx that"
            },
            {
                "text": " The pattern should be \"(\\d+)([.\\d]*)(-\\d+.*)?\". The first part, (\\d+), matches one or more digits, the second part, ([.\\"
            },
            {
                "text": " \"^[0-9]+(\\.[0-9]{1,3})?$\"\n- \"12.3456\"Generate a RegEx for this description. \nAnswer: \"^"
            },
            {
                "text": "\n[0-9]+\\.\\d+[0-9]*\n\nExercise 2:\nCreate a Python program that matches a phone number in the format (123) 456-7890.\n"
            },
            {
                "text": " ^\\d{1,3}(\\.\\d{3})+([-\\d.]+)$\n\nExercise 4:\nGenerate a RegEx that matches all the words that start with a capital"
            }
        ]
    },
    {
        "expression": "^((\\d{1,2})?([.][\\d]{1,2})?){1}[%]{1}$",
        "raw_prompt": "for checking a value is between 99.99% and 00.00%",
        "refined_prompt": "for checking a value is between 99.99% and 00.00%\nMatch examples:\n- \"99.99%\"\n- \"9%\"\n- \".09%\"\nNon-match examples:\n- \"99\"\n- \"9.%\"",
        "matches": [
            "99.99%",
            "9%",
            ".09%",
            "48%",
            "91%",
            "54%",
            "98%",
            "32.44%",
            "56.44%",
            "78.87%",
            "87.55%",
            "97.12%",
            "58.78%"
        ],
        "non_matches": [
            "99",
            "9.%",
            "259",
            "195",
            "87",
            "86",
            "486",
            "3142.514%",
            "%73",
            "%7836l.23",
            "%342.23",
            "%332.42423"
        ],
        "id": 547,
        "output": [
            {
                "text": "\n[0-9]{0,2}[.][0-9]{0,2}\n\nExercise 2:\nWrite a RegEx to match all email addresses below the following format:\n[a-zA-Z0-9._%+-]+@["
            },
            {
                "text": " \"0\\.?\\d?%\".\n\n\n\nQuestion 2: A bakery produces 3 batches of muffins for each day of the week. Each batch yields 24 muffins. If the bakery operates for 6 days a week, how many muffins does it produce in a month with 4 weeks?"
            },
            {
                "text": "\n- (?<!%)(?<!\\.)^([0-9]+(\\.[0-9]*)?)(?!%)\n\n5. Create a regular expression that matches a string that contains exactly three digits, separated by any number of spaces. For example, \"1234"
            },
            {
                "text": " The RegEx should be.*\\d*\\.\\d*.*\n\n### Exercise 5:\nCreate a Python function that takes in a string and returns True if the string is a valid email address, else False.\nHint: Use the re module and the regular expression for email addresses."
            },
            {
                "text": " [0-999]\\.[0-9]%|[0-9]\\.[0-9]\n\n**Exercise 3:**\n\nMatch the following keywords to the correct category:\n1) Regex\n2) Match\n3) Non-match\n\nCategory:"
            },
            {
                "text": "\n(?<!\\.)\\d+\\.\\d{2,}(?!%)\n\nExercise 2:\nMatch these words to their meaning:\n- \"Percentage\"\n- \"Decimal\"\n- \"Fraction\"\n- \"Ratio\"\n- \"Pro"
            },
            {
                "text": " \n\nimport re\n\n#Generating a RegEx for the above description\nregex = r\"(\\d\\.\\d%?|\\d)\"\n\n#Testing the generated RegEx\nprint(re.findall(regex, \"99.99%\")) #[\"99"
            },
            {
                "text": " [^\\d]$\n\n3. Implement a function that takes a string as input and returns the percentage of characters that are not digits.\nImplement a function that takes a string as input and returns the percentage of characters that are not digits.\n\n```python\nimport re\n\n"
            },
            {
                "text": " (\\d+)\\.(\\d{0,2})\\%\n\n3. Create a RegEx for checking if a string starts with a letter between lowercase A and uppercase Z. \nAnswer: ^[a-zA-Z]\n\n4. Create a Reg"
            },
            {
                "text": "\n[(?<=\\.)\\d+[%\\.]]{0,100}|[\\d.]{0,1}([\\%\\.])\n\nExercise #5\nDescribe the use of the negative lookahead assertion and use it to only accept values that"
            }
        ]
    },
    {
        "expression": "(^[A-Za-z])|(\\s)([A-Za-z])",
        "raw_prompt": "This expression will return the first letter of each word in a string. Best used if you need to get initials from a name.\n&quot;James Kramer&quot; = &quot;J K&quot; &amp; &quot;Sir Richard Branson&quot; = &quot;S R B&quot; &amp; &quot;33 yoYo 654 ma&quot; = &quot;y m&quot;",
        "refined_prompt": "Match strings where:\r\n\r\nThe first character of the string is an alphabetic character (uppercase or lowercase).\r\nThere is a whitespace character followed by an alphabetic character anywhere in the string.\nMatch examples:\n- \"James Kramer\"\n- \"Sir Richard Branson\"\n- \"33 yoYo 654 ma\"\nNon-match examples:\n- \"33 66 4ju\"\n- \"98iubi98g\"",
        "matches": [
            "James Kramer",
            "Sir Richard Branson",
            "33 yoYo 654 ma",
            "f hfius",
            "j jaif",
            "y uihs",
            "h fjioa",
            "jiufs fjsi",
            "usifd uisdhf",
            "U ADFSF",
            "FSIDO F SAI",
            "UFD SDFUH FDSIU",
            "No Space"
        ],
        "non_matches": [
            "33 66 4ju",
            "98iubi98g",
            "8977y",
            "7gyuh",
            "5drtcf",
            "56ftyvg",
            "65ftyvg",
            "6ftyvg",
            "8f67tgyubh4548",
            "4edr54r65ft",
            "6fty",
            "6fty"
        ],
        "id": 550,
        "output": [
            {
                "text": " \"^\\w+.\\s\\w+$\"\r\n\r\n"
            },
            {
                "text": " \\b[A-Z][a-z]+ \\s[A-"
            },
            {
                "text": " ^[a-zA-Z ]+$\n\nUse this Reg"
            },
            {
                "text": " \r\n\\p{Alpha} \\s\\p{Alpha}\r"
            },
            {
                "text": " (?i)((?!^)(?=\\S)(?!\\s"
            },
            {
                "text": " RegEx = [A-Z][a-z]+( [A-"
            },
            {
                "text": " ([a-zA-Z][\\s\\-\\()]*["
            },
            {
                "text": " \r\n\r\nimport re\r\n\r\ninputs = ['James"
            },
            {
                "text": " ^[a-zA-Z\\s]*[a-z"
            },
            {
                "text": " \n^[a-zA-Z \\t]*\\d"
            }
        ]
    },
    {
        "expression": "^(0{0,1}[1-9]|[12][0-9]|3[01])[- /.](0{0,1}[1-9]|1[012])[- /.](\\d{2}|\\d{4})$",
        "raw_prompt": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nI did this expression cause I could hardly find any date regex that supports those &quot;dot-formats&quot;.",
        "refined_prompt": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1.200\"",
        "matches": [
            "1.1.2004",
            "03.07.04",
            "1-03-03",
            "29 12/5199",
            "21.08.29",
            "31/7/22",
            "30.11-93",
            "30.02.99",
            "30.12.83",
            "30.11/37",
            "21.10-50",
            "6-11/02",
            "30.5.4056"
        ],
        "non_matches": [
            "0.13.2004",
            "1.1.200",
            "32.0.03",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "000-000",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 571,
        "output": [
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.1"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.2"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.2"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.07"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.3"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.07"
            },
            {
                "text": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nMatch examples:\n- \"1.1.2004\"\n- \"03.07.04\"\n- \"1-03-03\"\nNon-match examples:\n- \"0.13.2004\"\n- \"1.3"
            }
        ]
    },
    {
        "expression": "(^[a-fA-F]+[+-]?$)",
        "raw_prompt": "Letter Grade scores A-F + and -",
        "refined_prompt": "Letter Grade scores A-F + and -\nMatch examples:\n- \"a+\"\n- \"A\"\n- \"F-\"\nNon-match examples:\n- \"z\"\n- \"6\"",
        "matches": [
            "a+",
            "A",
            "F-",
            "A-",
            "B",
            "B+",
            "B-",
            "C+",
            "C",
            "C-",
            "D",
            "D+",
            "D-"
        ],
        "non_matches": [
            "z",
            "6",
            "D +",
            "Z+",
            "O-",
            "K+",
            "u_",
            "fsd",
            "uf",
            "q",
            "y",
            "p"
        ],
        "id": 578,
        "output": [
            {
                "text": " The following expression should work: [0-9][1-9][0-9][0-9][0-9][1-9][0-9][0-9][0-9][1-9][0-9][1-9][0-9][a-zA-Z]+\n\nExercise"
            },
            {
                "text": " A\\d+[ABCDEF]\\d+\n\nExercise 2: The following words contain either an upper or lowercase letter. Write a regular expression to match them.\n1. my dog is a puppy\n2. The quick brown fox jumps over the lazy dog\n3. I love to play video games\n4. The"
            },
            {
                "text": " (^[a-zA-Z]*$|[0-9]+)([+-]([0-9]*))?$\nExercise 2: Write a program that will match any string containing at least 3 consecutive digits.\nAnswer: \\d{3,}\n\nExercise 3: Write a Reg"
            },
            {
                "text": " ([A-F]{1})([0-9]?[A-F])\n\nExercise 2: \nGenerate a RegEx for this description. \nList all the characters that are not allowed in a phone number.\nAnswer: [^0-9()]\n\nExercise 3: \n"
            },
            {
                "text": "\n[0-9]|[A-F]\n\nExercise 2:\nCreate a RegEx for the following string:\nI need to learn all the rules before I can become a successful programmer.\nMatch examples:\n- \"I need to learn all the rules before I can become a successful programmer.\"\n- \"successful"
            },
            {
                "text": " [A-Za-z](?:\\+|\\-[A-Za-z])?\n- \"a+b\"\n- \"AB\"\n- \"Aa\"\n- \"F-\"\n- \"a-b\"\n```\n\n# 14.2.5 How to use the replace function"
            },
            {
                "text": " ^[A-Fa-f0-9]+(?:-[A-Fa-f0-9]+)*$\n\nExercise 2: Create a RegEx that only matches the words that are between the \"-\" and \",\" characters in a string that starts with the word \"Python\".\nAnswer: \\w+\\-\\"
            },
            {
                "text": " r'(?=^[ABCD-F]$)(?:[A-F]\\+|[A-F]\\-)'\n\nExercise 4: Write a Python program that takes a string and a pattern as input, and returns the number of times the pattern appears in the string.\n\n# Solution to Exercise"
            },
            {
                "text": " ([a-z]+) (\\+|\\-)([a-z]+)\n\nExercise 2:\nCreate a function that accepts a list of names and returns the number of names that start with a vowel.\n```python\nimport re\n\ndef count_vowel_names(names):\n  vow"
            },
            {
                "text": " A-F\nExercise 5:\nCreate a RegEx that will find all words in the following sentence that are less than the length of 5 characters:\n\"The quick brown fox jumped over the lazy dog.\"\nAnswer: [^a-zA-Z]\\w{1,4}\n\nI hope this blog has"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))$",
        "raw_prompt": "DD.MM.YY or DD.MM.YYYY\nseparator could be on choice '.' '/' or '-'\nleap years compatible, 00 is treated as year 2000.",
        "refined_prompt": "DD.MM.YY or DD.MM.YYYY\r\nseparator could be on choice '.' '/' or '-'\r\nleap years compatible, 00 is treated as year 2000.\nMatch examples:\n- \"29.2.04\"\n- \"29/02-2004\"\n- \"3.4.05\"\nNon-match examples:\n- \"29.2.03\"\n- \"2902.2004\"",
        "matches": [
            "29.2.04",
            "29/02-2004",
            "3.4.05",
            "29.02/7200",
            "6.11-8609",
            "31-10.1886",
            "29-3.7533",
            "10.12/66",
            "29.02-72",
            "3/2.4035",
            "29.2/4000",
            "14/7.07",
            "7/12/1820"
        ],
        "non_matches": [
            "29.2.03",
            "2902.2004",
            "12.31.1975",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 583,
        "output": [
            {
                "text": " (\\\\d{1,2})\\.(\\\\d{1,2})\\.(\\\\"
            },
            {
                "text": " \r\n(?<digit_group1>\\d{1,2})\\.("
            },
            {
                "text": " (?!\\d{1}\\.)(?!(.*[-\\/.])|^)(?"
            },
            {
                "text": " \\d{1,2}.\\d{1,2}.\\d{4}("
            },
            {
                "text": " 29(\\.|\\/|-)(2\\d|0[1-9])\\.("
            },
            {
                "text": " \\d\\d\\d\\d\\d.\\d\\d\\.\\d\\d"
            },
            {
                "text": " [0-2][0-9][0-9][0-9][0-9"
            },
            {
                "text": "\n\nimport re\r\n\r\nclass Test(object):\r\n\r\n    def __"
            },
            {
                "text": " [dd]?[.][0-9]{3}[-.][0-"
            },
            {
                "text": " ^[0-9]{1,2}\\.[0-9]{1,2"
            }
        ]
    },
    {
        "expression": "^[{|\\(]?[0-9a-fA-F]{8}[-]?([0-9a-fA-F]{4}[-]?){3}[0-9a-fA-F]{12}[\\)|}]?$",
        "raw_prompt": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]",
        "refined_prompt": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2F5B-4944-934D-96BBE6571977}\"\n- \"cDcfd51109D9-FDB903CeFbDec4Ac5C1d\"\nNon-match examples:\n- \"914D226A-2F5B-4944-XXXX-96BBE6571977\"\n- \"{914D226A-2F5B-4944-XXXX-96BBE6571977}\"",
        "matches": [
            "914D226A-2F5B-4944-934D-96BBE6571977",
            "{914D226A-2F5B-4944-934D-96BBE6571977}",
            "cDcfd51109D9-FDB903CeFbDec4Ac5C1d",
            "|FAE6a115-BdefE8FB-8A42-e8E57ddBba81}",
            "(55e634D0-9CFDFEAB51b3969dB1e39EDc|",
            "7e6aE28Beb06-dAE7-bE4A8A93c76fF402)",
            "5ea140cB-5eF8-e3aA1BCe-a6e3fa039B9a",
            "ff0DcCBf-57A9-bB49C58E-de54Cb33B0EA",
            "|C57D9B5d-ea11-Cb3e-6b09d448DF7Fcd6f",
            "(9DAB5864-F9a8-F11B-637BeeCfF514EeC8",
            "{ac62A505b69F26B10E0daf6B03c57F59)",
            "(e5cCFa8e-ec3C-B6FD-3D7c6bfdD2df819C",
            "BF8F2daa-E5ECfDC8e1EA-ffa12F5Fa5c3)"
        ],
        "non_matches": [
            "914D226A-2F5B-4944-XXXX-96BBE6571977",
            "{914D226A-2F5B-4944-XXXX-96BBE6571977}",
            "2534/52435234/2453",
            "fasd@fds.fasd@",
            "sfalijad234",
            "there is a boy",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "u09nKLJG FSL",
            "341.431v4f3.fv1",
            "abc111def",
            "++63453.345"
        ],
        "id": 590,
        "output": [
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            },
            {
                "text": "Specifier Format of Guid Values that this RegEx supports: 32 digits: [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx] 32 digits separated by hyphens: [xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx] 32 digits separated by hyphens, enclosed in brackets: [{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}] 32 digits separated by hyphens, enclosed in parentheses: [(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)]\nMatch examples:\n- \"914D226A-2F5B-4944-934D-96BBE6571977\"\n- \"{914D226A-2"
            }
        ]
    },
    {
        "expression": "^(?:\\([2-9]\\d{2}\\)\\ ?|(?:[2-9]\\d{2}\\-))[2-9]\\d{2}\\-\\d{4}$",
        "raw_prompt": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.",
        "refined_prompt": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234)555-1212\"\n- \"234-555-1212\"\nNon-match examples:\n- \"(234)5551212\"\n- \"234 555 1212\"",
        "matches": [
            "(234) 555-1212",
            "(234)555-1212",
            "234-555-1212",
            "(974)528-1703",
            "636-848-9886",
            "(658) 257-3763",
            "(331)928-3455",
            "276-642-9971",
            "507-320-0937",
            "(841)544-3610",
            "509-981-3769",
            "448-879-3363",
            "827-477-1540"
        ],
        "non_matches": [
            "(234)5551212",
            "234 555 1212",
            "234) 555-1212",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "12f3.21f3.213f",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "++63453.345"
        ],
        "id": 607,
        "output": [
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) ("
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 55"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 5"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            },
            {
                "text": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted.\nMatch examples:\n- \"(234) 555-1212\"\n- \"(234) 555"
            }
        ]
    },
    {
        "expression": "^([0-1]?\\d|2[0-3]):([0-5]\\d)$",
        "raw_prompt": "Time in 24h format; minutes must be two digits; hours may be one or two digits",
        "refined_prompt": "Time in 24h format; minutes must be two digits; hours may be one or two digits\nMatch examples:\n- \"3:23\"\n- \"03:23\"\n- \"16:59\"\nNon-match examples:\n- \"12:2\"\n- \"12:76\"",
        "matches": [
            "3:23",
            "03:23",
            "16:59",
            "21:37",
            "7:10",
            "22:02",
            "20:40",
            "14:46",
            "01:01",
            "22:35",
            "22:48",
            "22:24",
            "6:59"
        ],
        "non_matches": [
            "12:2",
            "12:76",
            "33:12",
            "48:79",
            "48:64",
            "15:97",
            "75:97",
            "12:87",
            "31:87",
            "64:87",
            "69:87",
            "21:97"
        ],
        "id": 610,
        "output": [
            {
                "text": " ^(0[1-9]|1[0-2])/(0[1-9]|[12]\\d|3[01])$\n\n3. Write a regular expression to match a valid MAC address and test it"
            },
            {
                "text": " [a]\\d{1,2}:\\d{2}[AP]M[/AP]\n\n2. You are given a string with an array of words separated by commas, each word is separated by a space. The string"
            },
            {
                "text": " \n\n\\d{2}:\\d{2}(?:\\.\\d+)?)\n\nExercise 4:\nRewrite this sentence using a regular expression:\n- \"I have 24 apples and 16 oranges\"\nAnswer:"
            },
            {
                "text": " (3-3|0-9)h[0-9]:[0-9]m\n\"\"\"\n\npattern_hour = \"^(3-3|0-9)h[0-9]:[0-9]"
            },
            {
                "text": "\n\n[0-9:]|[0-9]\n\nUse Case 2: Managing Time for a Project \n\nSuppose that you are a project manager at a large corporation, and you need to manage the time for a project that"
            },
            {
                "text": " ^[0-9][0-9]:[0-9]$\n\n3. Generate a RegEx for the following:\nDescription: A string starts with a letter and ends with a number. The string may contain letters and numbers"
            },
            {
                "text": " \nMatch examples:\n- \"3:23\"\n- \"03:23\"\n- \"16:59\"\nNon-match examples:\n- \"12:2\"\n- \"12:76\"\n\n### 3."
            },
            {
                "text": " A regular expression that satisfies the following criteria: it's a positive integer, it's less than or equal to 60, it's less than or equal to 24, and it's in 24h format (i.e. it consists of a two-"
            },
            {
                "text": "\n\n^[1-6][0-9]|07[0-9]:[0-5][0-9]$\n\n\n\nSection: Daily Life - Normal Events - Gratitude and Appreciation\n\nIntroduction:"
            },
            {
                "text": " (\\\\d{1,2}:[^:\\\\d]*)(?:\\\\d{2})?)\n\n\n\nIn a world so vast and unknown,\nWhere beings from far and wide roam,\nThere lies a place where minds"
            }
        ]
    },
    {
        "expression": "^(\\d{3}-\\d{3}-\\d{4})*$",
        "raw_prompt": "This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number. Written by Jason N. Gaylord.",
        "refined_prompt": "This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number.\nMatch examples:\n- \"555-555-1212\"\n- \"123-456-7890\"\n- \"489-876-1225\"\nNon-match examples:\n- \"555.555.1212\"\n- \"(555) 555-1212\"",
        "matches": [
            "555-555-1212",
            "123-456-7890",
            "489-876-1225",
            "785-986-3214",
            "654-987-3214",
            "845-625-9832",
            "542-653-9875",
            "852-963-1545",
            "987-231-4567",
            "982-452-4568",
            "845-124-1234",
            "456-123-8742",
            "648-875-9898"
        ],
        "non_matches": [
            "555.555.1212",
            "(555) 555-1212",
            "5555551212",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "489-485-41565"
        ],
        "id": 619,
        "output": [
            {
                "text": " (555)\\d{3}-\\d{3}\\d{4}\n-"
            },
            {
                "text": " (\\d{3})\\D(\\d{3})\\D(\\d{4"
            },
            {
                "text": " ^\\(?(\\d{3})\\)?[:-.]?(\\d{3"
            },
            {
                "text": " ^(?:(?:\\\\d\\\\d|\\\\d\\\\.){3}\\\\d"
            },
            {
                "text": "\n\\d{3}\\s?\\d{3}\\-\\d{4}\\"
            },
            {
                "text": " [^\\(\\d-]*[-\\d\\d-]*[-"
            },
            {
                "text": " ^[0-9]{1,2}.{3}[-\\s.]"
            },
            {
                "text": " r'\\b\\d{3}\\s\\d{3}\\-\\d{"
            },
            {
                "text": " ^(\\d{3}\\.){3}\\d{4}$.\nExercise 2"
            },
            {
                "text": " Regex should be (\\d{3}\\.){3}(\\d{4})"
            }
        ]
    },
    {
        "expression": "[0-9]{4}[A-Z]{2}",
        "raw_prompt": "Match for dutch zipcodes.\nDutch zipcodes are always in the format of 4 digits and 2 letters.",
        "refined_prompt": "Match for dutch zip codes.\r\nDutch zip codes are always in the format of 4 digits and 2 letters.\nMatch examples:\n- \"1000AB\"\n- \"3035KA\"\n- \"9999ZZ\"\nNon-match examples:\n- \"AA1000\"\n- \"Z1000\"",
        "matches": [
            "1000AB",
            "3035KA",
            "9999ZZ",
            "6887HD",
            "5831GP",
            "8535CK",
            "5657PR",
            "0671PV",
            "1064VW",
            "2824TF",
            "7837PQ",
            "2753XF",
            "3155WK"
        ],
        "non_matches": [
            "AA1000",
            "Z1000",
            "1000-CC",
            "12/123/4322",
            "sfalijad234",
            "$23.454",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "adfa2",
            "sda sad",
            "8h98009hu"
        ],
        "id": 623,
        "output": [
            {
                "text": " [^A-Z]{2}\\d{3}[^A-Z]{2}\nNote: The {2} is required at the beginning and end to only match 2 of the preceding character class.\n\nA:"
            },
            {
                "text": " \\b[A-Z]{2}\\d{2}\\b\n\nJavaScript:\n\nvar re = /^\\d{2}[A-Z]{2}$/;\r\nvar str = \"1000"
            },
            {
                "text": " [^a-zA-Z]0[a-zA-Z0-9]{3,}[0-9]{2}\n- \"000ZZ\"Generate a RegEx for this description. \n"
            },
            {
                "text": "  \"^[A-Z]\\d{2}[A-Z]\\d{2}$\"\n\n    TA: Hello, what questions do you have about using the re.findall and re.search functions"
            },
            {
                "text": " \\d{4}[A-Z]{2}\nExercise 2: Match for zip codes.\r\nIn the following list, match for the zip codes.\nzip codes to use:\r\n- \"1000AB\"\r"
            },
            {
                "text": " (\\d{4}[A-Z]{2})\nThis matches a 4 digit combination of numbers, followed by exactly 2 A or B letters, without having to use any special cases.\n2. Generate a RegEx for"
            },
            {
                "text": " /^[1-9][0-9]{3}([A-Z]{2})$/;\n\nThe first three digits have to be a number and the last two letters have to be letters. The first letter doesn"
            },
            {
                "text": " (?<![0-9])A(?![0-9])|Z(?![0-9]) \n\nA:\n\nYou can create the regex by using the following pattern.\n\\d{4}"
            },
            {
                "text": " ^[1-9][0-9]{2}[A-Z]{2}$\nExplanation: The regular expression [1-9][0-9]{2} matches any 2 consecutive digits. You can"
            },
            {
                "text": " \n^[A-Z]{2}\\d{3}(?:\\d{2})?$\nExample: \ninput: \"1000AB\"\r\noutput: \"0123\" (no decimal point)\n\n"
            }
        ]
    },
    {
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((20[0-9][0-9]))|((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((19[0-9][0-9]))|(29/02/20(([02468][048])|([13579][26])))|(29/02/19(([02468][048])|([13579][26]))))$",
        "raw_prompt": "This expression is an improved version of J&#246;rg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099.",
        "refined_prompt": "This expression is an improved version of J&#246;rg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099.\nMatch examples:\n- \"29/02/1992\"\n- \"29/02/2000\"\n- \"29/02/2004\"\nNon-match examples:\n- \"29/02/1892\"\n- \"29/02/2100\"",
        "matches": [
            "29/02/1992",
            "29/02/2000",
            "29/02/2004",
            "15/12/2076",
            "23/02/1949",
            "29/02/2016",
            "07/08/2093",
            "29/02/1972",
            "27/09/1925",
            "29/02/1956",
            "31/12/2011",
            "21/12/1975",
            "29/02/1956"
        ],
        "non_matches": [
            "29/02/1892",
            "29/02/2100",
            "29/02/3004",
            "12/123/4322",
            "2346-2345-2435",
            "2/3/a5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 626,
        "output": [
            {
                "text": "\n(0[1-9]|1[012"
            },
            {
                "text": "\n- r\"(?:[a-zA-Z"
            },
            {
                "text": " A^A(((0[2-9]|"
            },
            {
                "text": " \"^(19\\d{2}|20\\"
            },
            {
                "text": "\n\n^(\\d\\d\\/\\d\\d"
            },
            {
                "text": " [0-9]{4}-([0-"
            },
            {
                "text": " 0-9/0-9/0-9\\\\"
            },
            {
                "text": "\n/^(?:[0-9](?:\\"
            },
            {
                "text": " (?<!^\\d{2}\\/)("
            },
            {
                "text": " \"(\\d\\d)/(\\d\\d)/(\\"
            }
        ]
    },
    {
        "expression": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "This is the Brazilian Date Format.\nDD/MM/YYYY with the right days per month.\nDates &gt;=1900 &lt;=2999.",
        "refined_prompt": "This is the Brazilian Date Format.\r\nDD/MM/YYYY with the right days per month.\r\nDates &gt;=1900 &lt;=2999.\nMatch examples:\n- \"29/02/2004\"\n- \"31/01/1900\"\n- \"31/01/2999\"\nNon-match examples:\n- \"29/02/2003\"\n- \"12042004\"",
        "matches": [
            "29/02/2004",
            "31/01/1900",
            "31/01/2999",
            "30/11/2033",
            "07/02/2001",
            "29.02/6000",
            "29/02/5600",
            "29/02/0708",
            "29/02/8484",
            "29/02/4532",
            "29/02/7452",
            "30/01/2097",
            "29/02/5200"
        ],
        "non_matches": [
            "29/02/2003",
            "12042004",
            "20/04/04",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "9/9/9",
            "12/132/90"
        ],
        "id": 627,
        "output": [
            {
                "text": " \\d{2}/\\d{2}/\\d{4} \r\n- \"31"
            },
            {
                "text": " (\\s|\\/)+([0-1][0-9]|[1-9]\\d"
            },
            {
                "text": " (?i) [0-9]{1,3}/[0-9]{1,"
            },
            {
                "text": " ^(0[1-9]|1[012])\\/((3[01]|0[1"
            },
            {
                "text": " \\d{2}/[0-9]{2}/[0-9]{4}"
            },
            {
                "text": "  ^(\\d{2}\\/\\d{2}\\/\\d{4})-(\\d{"
            },
            {
                "text": " (29\\d\\d|32\\d\\d|32\\d\\d\\d\\d|"
            },
            {
                "text": " dd/mm/yyyy hh:mm:ss\nDate formats are used as a means of controlling the"
            },
            {
                "text": " \n\\d{1,2}:\\d{1,2}/\\d{4}\n"
            },
            {
                "text": "  [a-z]+[0-9]+[0-3][0-9]{2}"
            }
        ]
    },
    {
        "expression": "^([1-9]|[1-9]\\d|100)$",
        "raw_prompt": "This pattern matches whole numbers 1-100.",
        "refined_prompt": "This pattern matches whole numbers 1-100.\nMatch examples:\n- \"1\"\n- \"50\"\n- \"100\"\nNon-match examples:\n- \"0\"\n- \".5\"",
        "matches": [
            "1",
            "50",
            "100",
            "48",
            "98",
            "15",
            "32",
            "69",
            "78",
            "99",
            "52",
            "16",
            "21"
        ],
        "non_matches": [
            "0",
            ".5",
            "101",
            "256",
            "159",
            "1594",
            "651",
            "561",
            "615561",
            "561",
            "-1144",
            "-4"
        ],
        "id": 634,
        "output": [
            {
                "text": " The regular expression would be \"^[0-9]+(.[0-9]+)?$\"\n\n3. Write a regular expression to match a URL that starts with \"http://\" or \"https://\".\nAnswer: The regular expression would be \"^(http|https)://\"\n\n4. Write a regular expression to"
            },
            {
                "text": " [0-9]{0}\\.5\n- \".\"Generate a RegEx for this description. \nAnswer: [0-9]{0}\\.\n- \"1.5\"Generate a RegEx for this description.\n\nExercise 3:\nCreate a RegEx pattern to match any email address.\n"
            },
            {
                "text": " [1-9][1-9][0-9]|100[0-9]\n- \"20,000..50,000\"Generate a RegEx for this description. \nAnswer: [1-9][0-9]{3}[,0-9]{3}[,0-9]"
            },
            {
                "text": " \"0|0.[0-9]+|1[0-9]{2}|100\"\n\nExercise 5:\nMatch these descriptions using RegEx:\n- \"The phone number should contain exactly 9 digits\"\n- \"The email address should include a username and a domain name\"\n- \"The password should be at"
            },
            {
                "text": " (1..100)\\.5\n\n4. Using the given string, write a Python script that splits it into words.\n\"The quick brown fox jumps over the lazy dog.\"\n\nAnswer:\nstring = \"The quick brown fox jumps over the lazy dog.\"\n\n# Convert to lowercase\nstring = string.lower()\n"
            },
            {
                "text": " 0.5\n\nExercise 3:\nMatch the following regex pattern:\n- \"(a)|(b)\" or \"ab\"\nNon-match examples:\n- \"aa\"\n- \"ba\"\nAnswer: \"(a)\" or \"(b)\"\n\nExercise 4:\nMatch the following regex pattern:\n- \"a"
            },
            {
                "text": " [0-9]+[.]?[0-9]*\n\nExercise 5: Write a Python program that reads in a string and replaces all instances of \"foo\" with \"bar\".\nAnswer: \nimport re\n\ntext = \"I have a foo cat\"\nnew_text = re.sub(\"foo\", \""
            },
            {
                "text": " \\b[01]\\d{0,99}\\b\n\nExercise 2: \nMatch the following words. Use a forward slash to match one or more occurrences of the word: \n- \"book\"\n- \"shelf\"\n- \"bathroom\"\n- \"chair\"\nAnswer: (book|she"
            },
            {
                "text": " [^0-9.]\n\n8. How to check if a string starts with a certain pattern using RegEx\nAnswer: Use the ^ character to match the beginning of the string.\nExamples: ^hello to match \"hello\"\n^\\d+:\\d+ to match times in the format HH:MM\n\n9. How"
            },
            {
                "text": " (.5)\n\n2. In order to generate a random password, a RegEx pattern can be used that matches any combination of uppercase letters, lowercase letters, numbers, and special characters. A sample RegEx pattern is (?=\\\\d)(?=\\\\W)(?=(\\\\d)(\\\\W))(?=(\\\\"
            }
        ]
    },
    {
        "expression": "^(20|21|22|23|[01]\\d|\\d)(([:.][0-5]\\d){1,2})$",
        "raw_prompt": "24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).\nMS-SQL prefers semi-colon although this accepts full stops for users ease of use.",
        "refined_prompt": "24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).\nMatch examples:\n- \"09:00:00\"\n- \"09.00\"\n- \"9:00\"\nNon-match examples:\n- \"9:00AM\"\n- \"52/2/54/245\"",
        "matches": [
            "09:00:00",
            "09.00",
            "9:00",
            "21:41",
            "8.26",
            "23:07",
            "20.28.23",
            "22.21",
            "22.06:54",
            "22.23",
            "22.04.19",
            "20.06:50",
            "23:51"
        ],
        "non_matches": [
            "9:00AM",
            "52/2/54/245",
            "34f2vf42e",
            "-123",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "98iojk",
            "432/524/2435",
            "1-1-2",
            "34.31",
            "32542"
        ],
        "id": 635,
        "output": [
            {
                "text": " (?<hour>.?\\d\\d|1[0-2])(?<min>.?\\d\\d|0[1-9]|"
            },
            {
                "text": "\n[0-9][0-9]:[0-9][0-9].[0-9][0-9]\n\nI.e. the"
            },
            {
                "text": "\n\n_\n```python\nimport re\n\nm = re.match(\"(?P<day>\\d{1,2})[\\/](?"
            },
            {
                "text": " ([0-9][0-9]:[0-9][0-9]:[0-9][0-9])\n\nI would write:\n(["
            },
            {
                "text": "\n^\\d{1,2}:[0-9][0-9]$|^\\d{1,2}:[0-9][0-"
            },
            {
                "text": " [A-Za-z][0-9][0-9]|[0-9][0-9]/[0-9][0-9"
            },
            {
                "text": " \"^([0-9]{1,2}/){2}[0-9]{1,2}[0-9]{2}$"
            },
            {
                "text": " (\\d{1,2})([:\\d:]?)(\\d{0,2})?\n- \"52/5/54/245\"Gener"
            },
            {
                "text": "\n[0-9]{1,2}\\/[0-9]{2}\\/[0-9]{4}\\/[0-9]"
            },
            {
                "text": " (?<H>[01]\\d|2[0-3]):(?<M>[0-5]\\d):(?<S>[0"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]+((\\s|\\-)[a-zA-Z]+)?$",
        "raw_prompt": "This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them.",
        "refined_prompt": "This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them.\nMatch examples:\n- \"Bobbie Sue\"\n- \"Ana-Claire\"\n- \"BobbyJoe\"\nNon-match examples:\n- \"Billy - Joe\"\n- \"Billy Jr.\"",
        "matches": [
            "Bobbie Sue",
            "Ana-Claire",
            "BobbyJoe",
            "Jfjsid Jfdsi",
            "Jfd Jisf",
            "Bob Cat",
            "Apple Dog",
            "Pine Apple",
            "Peach Grape",
            "Orange Singapore",
            "China Usa",
            "Lionel Messi",
            "Neymar-Dasilva"
        ],
        "non_matches": [
            "Billy - Joe",
            "Billy Jr.",
            "Thos.",
            "-123",
            "2346-2345-2435",
            "$23.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "com.edu.github",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 637,
        "output": [
            {
                "text": " ^[A-Za-z0-9-]*$\n\n\nExercise 3:\nUse the following input data to create a pandas DataFrame object:\n\n| Name | Age | Gender"
            },
            {
                "text": " [a-zA-Z]\\w|[a-zA-Z]\\s[a-zA-Z]\\w|[a-zA-Z]\\s[a"
            },
            {
                "text": " [^a-z]{0,1}[a-z][^a-z]{0,1}.*?[^a-z] or [^a-z]{0,"
            },
            {
                "text": " Acceptable names include compound names with a hyphen or a space in them.\n\nExercise 2: You need to create a regex to find all the email addresses in a text. Each email address should contain the"
            },
            {
                "text": " \n- ^[A-Z]+(?:-[A-Z]+)?$\n\nExample 2: \nConsider a string with a full name 'John Doe'. The string has the format 'First"
            },
            {
                "text": " \"Billy | Jr\"\n\nQuestion: How can you use a regular expression to validate an email address?\n\nTo validate an email address, you can use the following pattern:\n^[a-zA"
            },
            {
                "text": "\n^[A-Z][a-z]* - [A-Z] is the only required character. [a-z] can be any number of characters (zero or more).\n- * says"
            },
            {
                "text": " \n[a-z ]{0,25}[a-z]\n\nExercise 2:\nCreate a regex that matches dates in the format MM/DD/YYYY.\nAnswer:\n"
            },
            {
                "text": " (?i)(^)?[A-Z][a-z]*[A-Z]$\n\nExercise 3:\n\nCreate a regex that validates an email address. Acceptable email addresses"
            },
            {
                "text": " \n\\b[1-9][0-9] - [0-9]$\n\nUse Case 2: Validating Email Addresses\n\nIn this use case, we'll see an example of"
            }
        ]
    },
    {
        "expression": "(((0[123456789]|10|11|12)([/])(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "raw_prompt": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression to Client From MOnth/Year.",
        "refined_prompt": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression to Client From Month/Year.\nMatch examples:\n- \"01/1900\"\n- \"10/1990\"\n- \"12/2999\"\nNon-match examples:\n- \"1/1900\"\n- \"12/1899\"",
        "matches": [
            "01/1900",
            "10/1990",
            "12/2999",
            "10/1913",
            "11/2143",
            "12/1936",
            "10/2254",
            "07/2129",
            "11/1956",
            "11/1999",
            "11/2541",
            "12/1984",
            "10/2375"
        ],
        "non_matches": [
            "1/1900",
            "12/1899",
            "01/3000",
            "12/123/4322",
            "445/156",
            "516/159",
            "/894/4895",
            "8494/48984",
            "84/8494",
            "594/54984",
            "849/815",
            "/48/9984"
        ],
        "id": 639,
        "output": [
            {
                "text": " ([1-9][0-9]?|[1-2][0-9]|3[01])/([0-9]{4})\n- \"19/"
            },
            {
                "text": "\n[0-9]{1,2}-[0-9]{1,2}[0-9]{1,4}\n\nA:\n\nYou can"
            },
            {
                "text": " You could start with something like this:\n\n[0-9][0-9][0-9]\\/[0-9][0-9][0-9]\\/["
            },
            {
                "text": "\n\n/^[1-9][0-9]{0,2}/^(0?[1-9]|1[012])[0-3]$"
            },
            {
                "text": " The format is not correct. It should be [0-9]{4}[/-][0-9]{2}[/-][0-9]{2}[/-"
            },
            {
                "text": "\n\n[0-9]\\d?[-/.]\\d{4}\n\n---\n\nExercise 2:\n\nUse RegEx to verify the format of the"
            },
            {
                "text": " Regex is [\\d][\\d]?[\\/-]+[\\d][\\d]?[\\/-]\n\n8.2.5.2.2."
            },
            {
                "text": "\n\n[0-9]\\d{2}/\\d{2}[0-9]\n\n```python\nimport re\npattern = r\"\\d\\"
            },
            {
                "text": "\n- MM/YYYY ([0-9]{2})/([0-9]{4}|[12][0-9]|3[01])\n- Client"
            },
            {
                "text": "\n(0,9|0,9)\\/[0-9]{2}\nExercise 2:\nGiven a string containing the following date in MM/DD/YYYY"
            }
        ]
    },
    {
        "expression": "^(([1-9]{1})|([0-1][0-9])|([1-2][0-3])):([0-5][0-9])$",
        "raw_prompt": "Matches 24 hour time format.",
        "refined_prompt": "Matches 24 hour time format.\nMatch examples:\n- \"00:00\"\n- \"23:59\"\n- \"10:10\"\nNon-match examples:\n- \"24:00\"\n- \"00:60\"",
        "matches": [
            "00:00",
            "23:59",
            "10:10",
            "6:50",
            "17:59",
            "14:50",
            "7:18",
            "14:34",
            "22:46",
            "12:19",
            "23:51",
            "21:47",
            "10:31"
        ],
        "non_matches": [
            "24:00",
            "00:60",
            "25:61",
            "48:48",
            "984:489",
            "43.v234",
            "/5/5/5",
            "98iojk",
            "48:489",
            "98:48",
            "79:79",
            "31:84"
        ],
        "id": 640,
        "output": [
            {
                "text": " \"([0-9]{1,2}:[0-9]{2})\"\n\n2. Write a RegEx that matches any URL that starts with http or https. \nAnswer: \"(https?://)[a-zA-Z0-9-]+\\.[a-"
            },
            {
                "text": "\n\"\"\"\n\nimport re\nprint(re.compile(r\"\\d{2}:\\d{2}\"),re.compile(r\"\\d{2}:[01]|2:00\"))\n\n\n\"\"\"\nExample 5:\n\nQuestion: Write a Python function that"
            },
            {
                "text": " \n\nUse Case 3: Extracting URLs from a Website\n\nWebsites contain a lot of information, including urls. Extracting these urls can be a challenging task, but RegEx can help.\n\nScenario: You are a web developer and need to extract the URLs of all"
            },
            {
                "text": " \n(00|[1-9]\\d|1[012])\\s\\d:\\d\n\nExercise 3:\nCreate a RegEx pattern to validate a phone number in the format of (123)456-7890.\nAnswer: (\\(\\d{3}\\"
            },
            {
                "text": " To match an hour that is \"between\" a 24 hour time, the regular expression could be \"^(0[1-9]|1[0-2]):([0-5][0-9])$\". To match any hour that is \"between\" a 24 hour time, the regular"
            },
            {
                "text": " [0-9][0-9]\n\nExercise 2: Generate a RegEx for this description. \nMatch examples:\n- \"A string of digits\"\n- \"Exactly 7 characters long\"\n- \"Between 5 and 20 characters long\"\nNon-match examples:\n-"
            },
            {
                "text": " (\\d{1,2}):(\\d{2,3})\n\n3. You are provided with a list of sentences and you need to find the total number of words in each sentence. Find a way to do this using RegEx and Python.\n\nSentence: \"The quick brown"
            },
            {
                "text": " (00[1-9][0-9]|1[0-2][0-9]|[01]?[0-9][0-9]):[0-5][0-9]\n\n3. Match the following phone number formats, including international numbers:\n-"
            },
            {
                "text": " (00-1)* (0-9):*\n\n```python\nhours = list(range(24))\nregex_pattern = f\"[0-9]{1,2}:{hours[0]}\"\n```\n\n3. Use f-strings to print your new"
            },
            {
                "text": " [0-9]{2,}[:]?[0-9]{2,}\n\nExercise: \nCreate a list of all possible dates in the format \"MM/DD/YYYY\". \nAnswer: [01/01/2000, 01/01/2005,"
            }
        ]
    },
    {
        "expression": "^(([1-9]{1})|([0-1][1-2])|(0[1-9])|([1][0-2])):([0-5][0-9])(([aA])|([pP]))[mM]$",
        "raw_prompt": "Matches 12 hour time format",
        "refined_prompt": "Matches 12 hour time format\nMatch examples:\n- \"1:00Am\"\n- \"12:59pM\"\n- \"05:05pm\"\nNon-match examples:\n- \"00:00am\"\n- \"05:60pm\"",
        "matches": [
            "1:00Am",
            "12:59pM",
            "05:05pm",
            "01:54am",
            "08:31Pm",
            "06:14am",
            "12:19aM",
            "12:55am",
            "02:09Am",
            "12:53Pm",
            "10:37Pm",
            "6:55am",
            "6:35pM"
        ],
        "non_matches": [
            "00:00am",
            "05:60pm",
            "1:00",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 641,
        "output": [
            {
                "text": " [\\d\\d:\\d\\d]M[\\d\\d]h[\\d\\d]m\n\n\n\nTitle: Exploring the World of Math: Understanding Loans and Time and Money\n\nIntroduction:\nHey there, future mathematician! Are you ready"
            },
            {
                "text": " Match examples should be \"1:00am-12:59pm\" and \"5:00pm-5:59pm\". Non-match examples should be \"0:00am-5:59pm\", \"12:00pm-23:59pm\", \"00:"
            },
            {
                "text": " ^([0-9]+):([0-9]+)[a-zA-Z ]+$\n\n\n\nQuestion 6: A company charges $500 for a service fee and $40 for each hour of work. If they worked for 8 hours, how much did"
            },
            {
                "text": "\n    (?:pM|AM|AM|PM|PM|PM)'(?:m|M|m)'(?:g|G|G|g)'(?:s|S|S|S|S)'\n    \n(?:pM|AM|AM"
            },
            {
                "text": "\n^(0[1-9]|1[0-2])[0-9]:[0-5][0-9]?$\n\nExercise 2:\nCreate a RegEx that matches passwords in the format \"username-password\":\n# Solution:"
            },
            {
                "text": " (?:^[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](?:\\.(?:[0-9]|1[0-9]|"
            },
            {
                "text": " [0-9]{2}[a-z]{2}:[a-z]{2}[a-z]{2}[0-9]{2}[pP][0-9]\n\nExercise 2:\nMatch the following"
            },
            {
                "text": " To match either \"a match\" or \"no match\", do this:\nimport re\ntext =\"05:01pm, 12:00am, 07:00am, 06:00am\"\nrx = re.compile(\"^((0|5[1-"
            },
            {
                "text": "\nThe pattern should only match strings that are two digits and have an \"am\" or \"pm\" indicator at the end.\n\nExercise 3: Identify the missing item in the following data set.\n| Item        | Value |\n|--------------|-------|\n|"
            },
            {
                "text": " 12:59(PM).\n\nExercise 4:\nCreate a RegEx that validates that a string contains only numbers, letters, and hyphens. Use the caret (^) symbol to match the start of the string.\nAnswer: ((?i)\\d+"
            }
        ]
    },
    {
        "expression": "^\\d?\\d'(\\d|1[01])&quot;$",
        "raw_prompt": "Height notation for feet (') and inches(&quot;)",
        "refined_prompt": "Height notation for feet (') and inches(&quot;)\nMatch examples:\n- \"6'3&quot;\"\n- \"5'11&quot;\"\n- \"10'0&quot;\"\nNon-match examples:\n- \"9 Feet 2 inches\"\n- \"5'12&quot;\"",
        "matches": [
            "6'3&quot;",
            "5'11&quot;",
            "10'0&quot;",
            "5'6&quot;",
            "56'11&quot;",
            "73'6&quot;",
            "5'11&quot;",
            "3'2&quot;",
            "3'10&quot;",
            "2'11&quot;",
            "86'11&quot;",
            "06'11&quot;",
            "10'10&quot;"
        ],
        "non_matches": [
            "9 Feet 2 inches",
            "5'12&quot;",
            "5'2 1/2&quot;",
            "Mastercard",
            "sfalijad234",
            "$23.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 645,
        "output": [
            {
                "text": " ^\\d+'\\d+(&quot;\\d+)?$\n\nExercise 2:\nWrite a Python script that takes a string of text as input and replaces all occurrences of \"to\""
            },
            {
                "text": " \\d{1,2}(?:\\')(?:[\\s\\d]*)(?:&quot;|&quot;')| \\d{1,2}(?:\\'"
            },
            {
                "text": " \\d*(?:\\'\\d+&\\s*\\\"|\\s*\\\"\\s*&\\d+)\\s*\n\nI hope you found this section helpful in understanding Measurement Units"
            },
            {
                "text": " ^[0-9]+(\\.(\\d+(?:\\s*[+-])*))*$\n- \"10 Inches\"\n  Answer: ^[0-9]+(\\.("
            },
            {
                "text": " \n\nExercise 2:\nWhat is the purpose of RegEx in programming? \nAnswer: The purpose of RegEx in programming is to search for patterns in text or data. \n\nExercise"
            },
            {
                "text": " (\\\\d+)(\\\\s*\\\\&quot;)(\\\\d+&quot;)?\nUse case 3 - \"Temperature Conversion\":\nIn the science lab, Alex and Sarah are conducting an experiment"
            },
            {
                "text": "\n'(?=(?:[\\s\\S]*\\d\\d)+|(?:[\\s\\S]*\\d\\d))[^\\s]+' will match the strings that"
            },
            {
                "text": "\n(\\\\d+)'(\\d+)'(\\d+)'(&quot;)\n\n### Exercise 2:\n\nCreate a RegEx that matches dates in the format \"MM/DD/YYYY"
            },
            {
                "text": " \nr'(?:^|\\s)(?P<feet>\\d*[^&quot;])(?P<inches>\\d+[^&quot;]?)("
            },
            {
                "text": " \nR'\\b([\\d]+)\\'(\\d)\\'(\\d)\\b'\n\"\"\"\n\n#2. Create a Python function that takes a string as input and returns the first and last"
            }
        ]
    },
    {
        "expression": "^-?\\d*(\\.\\d+)?$",
        "raw_prompt": "Matches all positive &amp; negative decimal floating point numbers, to any magnitude. Allows empty string.",
        "refined_prompt": "Matches all positive &amp; negative decimal floating point numbers, to any magnitude. Allows empty string.\nMatch examples:\n- \"4.4\"\n- \".4\"\n- \"-.4\"\nNon-match examples:\n- \".\"\n- \"...\"",
        "matches": [
            "4.4",
            ".4",
            "-.4",
            "45.48",
            "645.645",
            "156.48",
            "46.48",
            "468.56",
            "-5.4",
            "-65.54",
            "-984.89",
            "-89.5612",
            "-486.7"
        ],
        "non_matches": [
            ".",
            "...",
            "zero",
            "12/123/4322",
            "#@RE",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 647,
        "output": [
            {
                "text": "\n[\\d-]*\\.?[\\d]+\n\nExercise 5:\nUse a RegEx to match any text that contains the word \"Python\".\nAnswer:\n\\bPython\\b\n\nLecture Script:\n\nSection 13.2"
            },
            {
                "text": " \"^\\d(.\\d{0,1})?$\"\n\nI'm using the regex I provided above, but when I use the \\d{0,1} in the first line, I'm not getting the correct number of digits.\n\nA:"
            },
            {
                "text": " [\\.\\d-]*\n\nSection 3: The use of RegEx in solving real-world problems\n\nQ1. Write a Python program that reads a text file and prints all the lines that contain a specific word (e.g., regex).\n\nQ2"
            },
            {
                "text": " [\\d\\.]+\n\n2. Write a Python function that takes in a string and returns the total number of characters in the string, including spaces and hyphens.\nAnswer:\ndef total_characters(s):\n  return len(s.replace(' ',"
            },
            {
                "text": " \"[0-9]*(\\.\\d*)?[eE][+-]?[0-9]*\\.[0-9]*\"\n\nA:\n\nRegular expression version:\n^[-+]?(?:[0-9]*"
            },
            {
                "text": ".\n\n5. Match a sequence of characters that are only allowed to occur once. \nExample: \"ab\" is permitted, but \"aab\" is not permitted.\n\nAnswer:.\n\n### Conclusion\n\nAs a market research analyst, you need to be"
            },
            {
                "text": " [^\\d.]\n\n**Note that the answer to this question is not a RegEx code, as it would be much shorter than this.**\n\n### Exercise 3:\nWrite a Python script to parse a comma-separated value string (CSV) into a"
            },
            {
                "text": " (.*)?\\.?(.*)\n\n4. Write a RegEx to match an Email Address.\n\nAnswer: [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-"
            },
            {
                "text": " '^(?=1e\\d+$)(?:[\\+\\-]?\\d*\\.\\d*$|\\d+(?:\\.\\d+)*)$'\n\nExercise 4:\nWrite a RegEx for this description.\nFind"
            },
            {
                "text": " \".*\"\n\nExercise 2:\nMatch all letters, numbers, and hyphens. Allows empty string. \n\nAnswer: \".*\"\n\nExercise 3:\nMatch all lowercase letters. Allows empty string. \n\nAnswer: \".*\"\n"
            }
        ]
    },
    {
        "expression": "^[0-9]*[1-9]+$|^[1-9]+[0-9]*$",
        "raw_prompt": "This Expression checks if the value is an integer, positive, not zero and not a decimal.\nVery handy for use when people need to fill in whole numbers, like when ordering car parts on a website (you dont want your customers to order -10 tires or 0.7 mirrors..",
        "refined_prompt": "This Expression checks if the value is an integer, positive, not zero and not a decimal.\nMatch examples:\n- \"1\"\n- \"00000428123\"\n- \"1230000\"\nNon-match examples:\n- \"0\"\n- \"00000000\"",
        "matches": [
            "1",
            "00000428123",
            "1230000",
            "485",
            "48156",
            "45",
            "56",
            "5148",
            "98489",
            "156473",
            "1554",
            "879567",
            "89"
        ],
        "non_matches": [
            "0",
            "00000000",
            "any text or +, - or any other character",
            "56198adf",
            "4894adf",
            "84dafds",
            "9849fsad",
            "d7uyhy78",
            "8g7yu",
            "8gur",
            "76fyrt",
            "76fytuhi324"
        ],
        "id": 652,
        "output": [
            {
                "text": "\n(?=(?:[^0-9]*[0-9]){0,}[^0-9]*)\n\nA:\n\nI'm not sure that it really counts as \"simple\" regex, because your regex is not a single regex, but"
            },
            {
                "text": " [1-9][0-9]*\n\nFor this exercise you will have to use the re module and the search() function.\n\n```python\nimport re\n\ndef find_re(word, pattern):\n    \"\"\"This Expression checks if the value is"
            },
            {
                "text": " match example|non-match example \n\n```python\nimport re\n\ndef check_string_validity(data_point):\n   if not re.match(\"^[1-9][0-9]*$|^[1-9]$"
            },
            {
                "text": " \\d*\n\nQuestion 3: Generate a RegEx to match a string that is 4 characters long and contains two letters followed by two numbers.\nAnswer: \\b[a-z]\\w{2}\\d{2}\\b\n\nQuestion 4: Generate"
            },
            {
                "text": " /^0[1-9][0-9]*$/\nExercise 3:\nMatch examples of the following string: \n- \"Hello World!\"\n- \"Hello World!\"\n- \"Hello World!\"\n- \"Hello World!\"\n- \"Hello World"
            },
            {
                "text": " (0|[1-9][0-9]*|[1-9][0-9]*[.][0-9]+)*|^[1-9]{6,12}$\n\nA:\n\nThe following regex will match a number"
            },
            {
                "text": " ^(?!0)(?!-)(?!-)[0-9]+(\\.[0-9]+)?$\n\nExercise 2. Check if Email is Valid\nCreate a RegEx for this description.\n\nAnswer:\n(^[a-zA-Z"
            },
            {
                "text": "\n[a-zA-Z0-9]*[0-9]+\n- \"12345\"\n- \"7a3a\"\n- \"12345d\"\nExercise\nWrite a RegEx that matches:\n\n1. 1,000,"
            },
            {
                "text": " ^(0[1-9][0-9]*|1[0-2][0-9]|3[01])\\d{6}$\n\n2. Write a Python program that validates that the input string has an uppercase letter, lower"
            },
            {
                "text": " \\d+\n\nExercise 4: Write the Regex for matching the following URL. \nRegex: https://www.example.com/blog/post-123\nAnswer: https://www.example.com/blog/post/(\\d+)/\n\n"
            }
        ]
    },
    {
        "expression": "^(\\(?[0-9]{3}[\\)-\\.]?\\ ?)?[0-9]{3}[-\\.]?[0-9]{4}$",
        "raw_prompt": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.",
        "refined_prompt": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not.\nMatch examples:\n- \"(555) 555-5555\"\n- \"555.555.5555\"\n- \"555-5555\"\nNon-match examples:\n- \"(555)-555-5555\"\n- \"52/2/54/245\"",
        "matches": [
            "(555) 555-5555",
            "555.555.5555",
            "555-5555",
            "178 073.3485",
            "060-7814",
            "754601.3692",
            "032-7931",
            "0068635",
            "278771-8970",
            "3615499",
            "162.6806",
            "8458550909",
            "472-3277"
        ],
        "non_matches": [
            "(555)-555-5555",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 654,
        "output": [
            {
                "text": "\n(?:\\d[ -]?){5} # Area code"
            },
            {
                "text": " \\d{9}[-\\s.]?\\d{4"
            },
            {
                "text": " (\\\\d{3}\\\\.){3}\\\\d{4"
            },
            {
                "text": " /^(?:\\(\\d{3}\\)\\s)?(?:"
            },
            {
                "text": " (\\d{2}[0-9]{3}["
            },
            {
                "text": " \n\nimport re\npattern = r'^[0-9"
            },
            {
                "text": " [0-9]{3}-[0-9]{3"
            },
            {
                "text": " (52\\.)(2[3-9]|1\\d"
            },
            {
                "text": " (?=(.{2}))|(?=(.{3"
            },
            {
                "text": " \n/^((5[0-9]{2}|"
            }
        ]
    },
    {
        "expression": "^(\\-)?\\d*(\\.\\d+)?$",
        "raw_prompt": "Matches all positive decimal floating negative/non-negative numbers. Allows empty string.",
        "refined_prompt": "Matches all positive decimal floating negative/non-negative numbers. Allows empty string.\nMatch examples:\n- \"0.55\"\n- \"21232.00\"\n- \"-89.20\"\nNon-match examples:\n- \"asdf\"\n- \"+0.33\"",
        "matches": [
            "0.55",
            "21232.00",
            "-89.20",
            "-651.948",
            "4.684",
            "-156.48",
            "48.84",
            "-48.51",
            "648.68",
            "648.6584",
            "-516.156",
            "468.64",
            "-546.8947"
        ],
        "non_matches": [
            "asdf",
            "+0.33",
            "g8yu",
            "78gy",
            "g8y",
            "g8y8gy8f",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 655,
        "output": [
            {
                "text": " \n\"0\\.[0-9]+\"\n\nExercise 3:\nWhich characters in the above RegEx allow for a positive decimal float value?\nAnswer:\n0-9\n\nNow that you have a basic understanding of RegEx and"
            },
            {
                "text": " \\d+\\.\\d{2} - Match any positive decimal floating negative/non-negative numbers. Allow empty string.\n\n2. Given the following text, create a regex to match all valid email entries. All email entries must be in the format"
            },
            {
                "text": " ^[\\.\\d]+$\n\nExercise 4: Regex for string containing only alphanumeric characters.\n- Allow only alphanumeric characters. Disallow any other characters like space, -, _\nAnswer: ^[a-zA"
            },
            {
                "text": " @\"^[0-9]+(\\.[0-9]+)$\"\n\nI can't figure out how to take input from user and generate this RegEx. I am aware that we can use raw_input to take input from user."
            },
            {
                "text": " 0\\.\\d +$\n\n2. Generate a regex that will match decimal numbers ending in 0.00. \nAnswer: [\\d.]+\\.(0[0-9]|1[0-9]|2[0"
            },
            {
                "text": " ^[0-9]*[.][0-9]*$|^[+-][0-9]*$\n\nA:\n\nIt is probably the simplest way to match if a string contains exactly two digits:\n$str"
            },
            {
                "text": "\n\n([-+]?[0-9]*\\.?[0-9]*|[-+]?[0-9](?:\\.[0-9]{1,3})?(?:[eE][-+]?["
            },
            {
                "text": " ^[1-9][0-9]*\\.?[0-9]?[0-9]?[0-9]$\n\n**2. Match positive decimal floating non-negative numbers only, allows empty string.\nAllow no"
            },
            {
                "text": " r'^\\d+(\\.\\d{1,2})?$'\nExercise 4:\nWrite a regular expression which will only accept strings with a length of between 3 and 5 characters.\nAnswer: r'^[a-zA"
            },
            {
                "text": "\n^[a-zA-Z0-9\\-\\.]+$\n\nExercise 2:\nCreate a RegEx that matches all valid ASCII characters in a URL.\nAnswer:\n^[a-zA-Z0-9"
            }
        ]
    },
    {
        "expression": "^((?:.*(?!\\d))*(?:\\D*)?)(\\d+)$",
        "raw_prompt": "Matches the number at the end of the string.",
        "refined_prompt": "Matches the number at the end of the string.\nMatch examples:\n- \"123\"\n- \"aaa123\"\n- \"aaa123aaa123\"\nNon-match examples:\n- \"aaa\"\n- \"aaa123aaa\"",
        "matches": [
            "123",
            "aaa123",
            "aaa123aaa123",
            "vuyy76",
            "uy76",
            "utydf987",
            "ivy75",
            "uyvhv4",
            "uiy56",
            "uctgfhj6",
            "igfui9",
            "cygjh2",
            "ertyuio8"
        ],
        "non_matches": [
            "aaa",
            "aaa123aaa",
            "afdsffugyd",
            "igyug87guybh",
            "yugh78gyuhbjuhgy",
            "ftyudy65drftyTYGV",
            "67TFYG76F",
            "YTF6FTYFDT",
            "TFYG657T8GG",
            "RTXYGD56DRTDYDRT",
            "DTRD54DR",
            "65ETYDF"
        ],
        "id": 656,
        "output": [
            {
                "text": "  ^[a-z0-9]+$\"\n\nExercise 2:  \nCreate a RegEx for the following description:\nA phone number in the format (123)456-7890.\nExample : \"(123)456-7890\"\nMatch examples:\n- \"123"
            },
            {
                "text": "\n^(?:[a-zA-Z]+[a-zA-Z0-9]*\\d*[a-zA-Z]*|\\d+[a-zA-Z0-9]*[a-zA-Z0-9]"
            },
            {
                "text": "\n\\d{3}(?:\\d{3})+(?:\\d{4})*\n\nA:\n\nYou can use this regex in javascript,\n/^\\d{3}(?:\\d{3})+(?:\\d{4})*$/\n\nA"
            },
            {
                "text": " ^[a-z0-9]+(?:\\.[a-z0-9]+){3}$\n\nA:\n\nI think you just need to do this:\n^[a-zA-Z0-9]*(?:\\.[a-zA-Z"
            },
            {
                "text": "\n\\d+$\n\nA:\n\nIn php you can use mb_substr() and mb_lastIndexOf()\nYou can try this code\n<?php\n$str = \"aaa\";\n$lastindex = mb_lastIndexOf(mb_substr($"
            },
            {
                "text": " ^(\\d+)$\n\n(5) Write a regular expression for a word that has exactly 3 vowels.\nExample: \"cab\"\nAnswer: (c[aeiou]{3}b)\n\n(6) Write a regular expression for a phone number in the format XXX"
            },
            {
                "text": "\n(?!^).*(?=\\d)\n\nA:\n\nThe regex you are looking for is (?!^)(\\d+)$\nExplanation:\n\n(?!^): negative lookahead to prevent match of the pattern from the beginning of the string\n(\\d+)"
            },
            {
                "text": " \\d+$\n\n4. Match one of the following words in the string: \"apple\", \"banana\", \"orange\", \"grape\"\nRegular expression patterns:\n- \\b(apple|banana|orange|grape)\\b\n- [a-z]{3}"
            },
            {
                "text": " ^(?!.*[a-zA-Z])[a-zA-Z]{1}[a-zA-Z0-9]{1,}$\n\nA:\n\nWell, as I see it, you need a regex to check that a string doesn't"
            },
            {
                "text": " (?<!\\d)(aa)*\n\nA:\n\nYou're on the right track with a negative lookbehind, but you're using the wrong regex engine. You need to use Java's Pattern and Matcher:\nPattern pattern = Pattern.compile(\"(?<!\\\\d)("
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F]{1,2})(\\s[0-9a-fA-F]{1,2})*$",
        "raw_prompt": "Expression validating a series of hex codes (byte values) separated by spaces.",
        "refined_prompt": "Expression validating a series of hex codes (byte values) separated by spaces.\nMatch examples:\n- \"1b 2e\"\n- \"1B 70 00 90 F0\"\n- \"0A\"\nNon-match examples:\n- \"gh 4b\"\n- \"1G 70 00 UU\"",
        "matches": [
            "1b 2e",
            "1B 70 00 90 F0",
            "0A",
            "1b 2C",
            "3D 4e 5F",
            "FF",
            "00",
            "7",
            "A",
            "B C",
            "8 9",
            "10 11",
            "1C 1D 1E 1F"
        ],
        "non_matches": [
            "gh 4b",
            "1G 70 00 UU",
            "2534/52435234/2453",
            "12/123/4322",
            "hiu iuh",
            "iug uh vh",
            "gy",
            "hu",
            "yg oi fw we",
            "uh qw fh fh",
            "iu fo qw oe rq",
            "hu hf qw fi as qw we"
        ],
        "id": 660,
        "output": [
            {
                "text": " ^[0-9a-fA-F]{1,4} [0-9a-fA-F]{4} $\n\n4) Use the following CSS rule to generate a RegEx"
            },
            {
                "text": " \\b\\d{2,4}\\s\\d{2}[A-Fa-f0-9]{3}\\b\n\nExercise 2:\nWrite a Python function that takes a list of hex"
            },
            {
                "text": " ^[A-Fa-f0-9]{1,3}\\s[A-Fa-f0-9]{1,3}\\s[A-Fa-f0-9]{1,"
            },
            {
                "text": " ^.{1,4}(?:.(?!\\d))?\\s+\\d+$\n\n**Exercise 2:**\n\nCreate a RegEx for an email address, using the following rules:"
            },
            {
                "text": "\n[^0-9a-f]\n\nExercise 2:\nRewrite the following expression to be case-insensitive:\n\"the quick brown fox jumps over the lazy dog\" \nHint:"
            },
            {
                "text": " \n\nhex_expr = re.compile(r\"([0-9A-Fa-f]+) [ ]+ (\\S+)\")\n\nLearning Journal for Subsection 12.3.9"
            },
            {
                "text": "\n\n[0-9A-Fa-f]{2}[\\s.][0-9A-Fa-f]{2}[\\s.][0-9A-Fa-f]"
            },
            {
                "text": " ^[0-9a-fA-F][0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0"
            },
            {
                "text": " (\\d\\d\\d[\\d\\D]\\d\\d[\\d\\D]\\d\\d)|(\\d\\d[\\d\\D]\\d\\d[\\d\\"
            },
            {
                "text": " \n@\"^[0-9a-fA-F 0a-9a-fA-F 0a-9a-fA-F 0a-9a-fA-F]"
            }
        ]
    },
    {
        "expression": "^(smtp)\\.([\\w\\-]+)\\.[\\w\\-]{2,3}$",
        "raw_prompt": "Matches basic SMTP server names.",
        "refined_prompt": "Matches basic SMTP server names.\nMatch examples:\n- \"smtp.yahoo.com\"\n- \"smtp.charter.net\"\n- \"smtp.ads.com\"\nNon-match examples:\n- \"pop.yahoo.com\"\n- \"f34fvfv\"",
        "matches": [
            "smtp.yahoo.com",
            "smtp.charter.net",
            "smtp.ads.com",
            "smtp.gfd.com",
            "smtp.example.fgh",
            "smtp.gfd.com",
            "smtp.fha.com",
            "smtp.gafd.net",
            "smtp.ywr.net",
            "smtp.ery.trt",
            "smtp.bf.ver",
            "smtp.few.gwg",
            "smtp.hgs.net"
        ],
        "non_matches": [
            "pop.yahoo.com",
            "f34fvfv",
            "34f2vf42e",
            "Mastercard",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 673,
        "output": [
            {
                "text": " (\\w+\\.){1,2}\\w*\n\nExercise 3:\nMatch the following domains and emails.\nDomain Matches email:\n- \"www.yahoo.com\"\n- \"www."
            },
            {
                "text": " \nregex = re.compile(r'(?i)(?:[a-zA-Z0-9\\._]+(?:\\.[a-zA-Z0-9\\._]+)*"
            },
            {
                "text": " \"pop.yahoo.com(\\.com|\\.net)\"\nIn this script, the example string is the desired string and the RegEx r'^[^\\.]+\\.com$' is a basic SMTP server"
            },
            {
                "text": "  _[a-zA-Z0-9\\.\\-\\_\\(\\)]{1,15}\\.{2,}_\n\n2. Write a Python program to extract all the email addresses from a text"
            },
            {
                "text": " ^[A-Za-z0-9.-]+$\nExplanation: This Regex means: only match strings that start with at least one letter or number, and contain at least one period (.), dash ("
            },
            {
                "text": " r'^[-a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'"
            },
            {
                "text": " \nr'^(smtp)([\\w\\.]+$)$'\n\n4) Write a RegEx that matches email addresses containing at least one digit.\nAnswer:\nr'^[\\w"
            },
            {
                "text": " (r'(smtp[.])((?P<domain>[a-z-\\.]+)(?P<host>[a-z0-9.\\-]+))(?P<path>[a-z"
            },
            {
                "text": " (\\b[a-zA-Z0-9]\\.[a-zA-Z0-9.]+\\b)\n\nExercise 2:\nMatch the following email addresses with regular expressions.\n"
            },
            {
                "text": "\nimport re\npattern = \"^(smtp|smtp|[a-z]{3}-\\d[a-z]{3}[-a-z]{3}[a-z"
            }
        ]
    },
    {
        "expression": "^(?=\\d)(?:(?!(?:(?:0?[5-9]|1[0-4])(?:\\.|-|\\/)10(?:\\.|-|\\/)(?:1582))|(?:(?:0?[3-9]|1[0-3])(?:\\.|-|\\/)0?9(?:\\.|-|\\/)(?:1752)))(31(?!(?:\\.|-|\\/)(?:0?[2469]|11))|30(?!(?:\\.|-|\\/)0?2)|(?:29(?:(?!(?:\\.|-|\\/)0?2(?:\\.|-|\\/))|(?=\\D0?2\\D(?:(?!000[04]|(?:(?:1[^0-6]|[2468][^048]|[3579][^26])00))(?:(?:(?:\\d\\d)(?:[02468][048]|[13579][26])(?!\\x20BC))|(?:00(?:42|3[0369]|2[147]|1[258]|09)\\x20BC))))))|2[0-8]|1\\d|0?[1-9])([-.\\/])(1[012]|(?:0?[1-9]))\\2((?=(?:00(?:4[0-5]|[0-3]?\\d)\\x20BC)|(?:\\d{4}(?:$|(?=\\x20\\d)\\x20)))\\d{4}(?:\\x20BC)?)(?:$|(?=\\x20\\d)\\x20))?((?:(?:0?[1-9]|1[012])(?::[0-5]\\d){0,2}(?:\\x20[aApP][mM]))|(?:[01]\\d|2[0-3])(?::[0-5]\\d){1,2})?$",
        "raw_prompt": "dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nJavascript safe version of http://regexlib.com/REDetails.aspx?regexp_id=691. Please see that regex for details of what is being checked",
        "refined_prompt": "dd/mm/yyyy hh:MM:ss Datetime for all AD years, including leap years.\nMatch examples:\n- \"31.12.6008\"\n- \"5:30 AM\"\n- \"30-04-1066\"\nNon-match examples:\n- \"00/00/0000\"\n- \"99:99:99\"",
        "matches": [
            "31.12.6008",
            "5:30 AM",
            "30-04-1066",
            "6-10-8698",
            "20:18:59",
            "16:56:18",
            "23:45:46",
            "10-10-2405",
            "31-10-6651",
            "08:20:28",
            "10 Am",
            "20:15",
            "08:16:16 pM"
        ],
        "non_matches": [
            "00/00/0000",
            "99:99:99",
            "29/02/2005",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "AAAAAAA",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 676,
        "output": [
            {
                "text": " 01/23/66|24/31/66|31.12.6008, 5:30 AM, 30-04-1066\"\n\nA:\n"
            },
            {
                "text": " \\d{1,2}\\.\\d{2}\\. \\d{4} \\d{2}:\\d{2}( AM|PM) \n"
            },
            {
                "text": "\nregex = r\"^(\\d{4})\\.(\\d{2})\\.(\\d{2})\\s-\\s[A-Z]["
            },
            {
                "text": " \nRe: (\\d{4}-\\d{2}-\\d{2})\\s*(.+?)\\s*([+-]"
            },
            {
                "text": " r\"(\\d{1,2})\\.(\\d{1,2})\\.(\\d{1,4})$\"\n\nExercise 3:\n"
            },
            {
                "text": "\n([0-9]-[0-9]):([0-9])\n\n4. Write a RegEx for this description:\n\"One or more words that"
            },
            {
                "text": " (\\d{1,2}\\.\\d{1,2}\\.\\d{4})\\s+([\\d:]{1,2}, ["
            },
            {
                "text": " \n0.^.{4}[0-9]{2}.{3}[0-9]{2}.[0-9]{2}"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2} AM|\\d{3}:\\d"
            },
            {
                "text": " /^\\d{4}-\\d{2}-\\d{2}$|^\\d{2}:\\d{2}:\\d{2"
            }
        ]
    },
    {
        "expression": "^((\\d[-. ]?)?((\\(\\d{3}\\))|\\d{3}))?[-. ]?\\d{3}[-. ]?\\d{4}$",
        "raw_prompt": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.",
        "refined_prompt": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\"\nNon-match examples:\n- \"555-222-33334\"\n- \"1(303)5a4-5555\"",
        "matches": [
            "1(555)444-3333",
            "202.555.3333",
            "555-4444",
            "(485)2293192",
            "8820265",
            "(940) 601-9212",
            "5(320)904.3030",
            "969 3892",
            "019-7942",
            "(093)358 1443",
            "040-5517653",
            "364.6479",
            "9835 059-0993"
        ],
        "non_matches": [
            "555-222-33334",
            "1(303)5a4-5555",
            "1 202) 111-3333",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 678,
        "output": [
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444-"
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444-"
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444-"
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            },
            {
                "text": "This is a pretty flexable phone number validator for US numbers. Allows optional country code and area code. Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate. Area codes can be in parenthesis or not. Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them.\nMatch examples:\n- \"1(555)444-3333\"\n- \"202.555.3333\"\n- \"555-4444\""
            }
        ]
    },
    {
        "expression": "^(?=.*[0-9]+.*)(?=.*[a-zA-Z]+.*)[0-9a-zA-Z]{6,}$",
        "raw_prompt": "Password must contain at least one letter, at least one number, and be longer than six charaters.",
        "refined_prompt": "Password must contain at least one letter, at least one number, and be longer than six charaters.\nMatch examples:\n- \"a1b2c3\"\n- \"abcdefg123\"\n- \"12345a\"\nNon-match examples:\n- \"abcdefghij\"\n- \"1234567890\"",
        "matches": [
            "a1b2c3",
            "abcdefg123",
            "12345a",
            "67gyihu",
            "r67ty8hu",
            "6ft7gy8h",
            "65cftvg7y",
            "s3e4dr5ft6gy7h",
            "3wse4dr5ft64dfr5t6",
            "5rft6g",
            "d5rft6gy7h",
            "5rft6g7y",
            "xed4rtgv"
        ],
        "non_matches": [
            "abcdefghij",
            "1234567890",
            "jsfkdhakjdfhbjkh",
            "yufiuyfkuyfu",
            "234567890567",
            "uvv7",
            "67f",
            "5d4",
            "67ff",
            "65fd",
            "i9",
            "u8"
        ],
        "id": 684,
        "output": [
            {
                "text": " The pattern should start with a digit, then be followed by one or more letters, then be followed by one or more digits.\n\nExercise 3: Find all the words in a given text.\nAnswer"
            },
            {
                "text": " (.*)(\\d)(.*)([a-zA-Z])(.*).\n\n\n\nTitle: A Historical Comparison of Gentle and Harsh: The Impact on Our World\n\nIntroduction:"
            },
            {
                "text": "\n\\d\\w+$\nIllustration: \n        Emily and Jack were playing catch in their backyard. Emily had a wooden bat, while Jack had a metal one. After a few throws,"
            },
            {
                "text": " [a-zA-Z]([a-zA-Z0-9]|[a-zA-Z0-9]){7,}\nExercise 4: Match the email"
            },
            {
                "text": " [at least one letter, at least one number, and be longer than 6 characters]. \"^[a-zA-Z]+$|^[0-9]+$|^[a-z"
            },
            {
                "text": "\n^(?=.*[A-Z])(?=.*\\d)(?=.*[a-z])[A-Za-z\\d]{6,}\n\nEx"
            },
            {
                "text": "\n# Generate a RegEx for this description.\n@example.test(regex=r\"[a-zA-Z]+[0-9]+[a-zA-Z0-"
            },
            {
                "text": " You can use the following regex: /^(?=.*[a-z])(?=.*\\d)(?=.{6,})[a-z\\d]{7,}"
            },
            {
                "text": " The regex is the following: \n^[a-zA-Z]\\d{6,}$\n\nExercise 2: \nCreate a Python function that generates a user ID from their"
            },
            {
                "text": " (.*)\\d(.*)\\d\\1.*\n\nExercise 3: Identify all the phrases in the following text using regular expressions. \n\n\"Hey, how was your day? Did you"
            }
        ]
    },
    {
        "expression": "^(((((0?[1-9])|(1\\d)|(2[0-8]))\\.((0?[1-9])|(1[0-2])))|((31\\.((0[13578])|(1[02])))|((29|30)\\.((0?[1,3-9])|(1[0-2])))))\\.((20[0-9][0-9]))|(29\\.0?2\\.20(([02468][048])|([13579][26]))))$",
        "raw_prompt": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.",
        "refined_prompt": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked.\nMatch examples:\n- \"1.1.2000\"\n- \"29.02.2004\"\n- \"31.12.2099\"\nNon-match examples:\n- \"1.1.1999\"\n- \"29.02.2003\"",
        "matches": [
            "1.1.2000",
            "29.02.2004",
            "31.12.2099",
            "9.11.2052",
            "31.10.2063",
            "11.04.2066",
            "12.04.2021",
            "31.08.2070",
            "29.2.2044",
            "29.04.2074",
            "29.2.2008",
            "29.02.2096",
            "31.07.2060"
        ],
        "non_matches": [
            "1.1.1999",
            "29.02.2003",
            "01.01.2100",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 688,
        "output": [
            {
                "text": " \\d\\d.\\d\\d"
            },
            {
                "text": " 1\\.\\d\\.\\d\\.\\"
            },
            {
                "text": " \\d\\d\\d\\d-"
            },
            {
                "text": " \n^(?P<Year>"
            },
            {
                "text": " (?![Dd]\\.\\d"
            },
            {
                "text": " ^(?P<day>\\d"
            },
            {
                "text": " 0.1.\\d{4}"
            },
            {
                "text": " (0|[1-9])\\"
            },
            {
                "text": " \n\nimport re\nfrom datetime"
            },
            {
                "text": " \\d{2}(.\\d"
            }
        ]
    },
    {
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)",
        "raw_prompt": "This regexp is used to match c++,java,etc style multi-line and single line comments.",
        "refined_prompt": "This regexp is used to match c++, java, etc style multi-line and single line comments.\nMatch examples:\n- \"/* This is a multi-line comment */\"\n- \"// this is a single-line\"\n- \"// fahdui\"\nNon-match examples:\n- \"/sometext\"\n- \"/*/\"",
        "matches": [
            "/* This is a multi-line comment */",
            "// this is a single-line",
            "// fahdui",
            "// fdhsaiu",
            "// fhdsuiah",
            "// ahfdisuh",
            "// fdhsaiuh",
            "// uh8hfds",
            "// fhj89ewh",
            "// h8euwh8",
            "/* This is afdsant */",
            "/* This iadft */",
            "/* Thfadsnt */"
        ],
        "non_matches": [
            "/sometext",
            "/*/",
            "/aguysdfb",
            "/fabsduyg87dyuhs",
            "/g78fsudi",
            "/*fhudsifdsb",
            "/usydfgufdsg",
            "/ysfg",
            "/fgysduf67e2",
            "1-1-2",
            "(0xx12) 62509@",
            "12/132/90"
        ],
        "id": 689,
        "output": [
            {
                "text": " /sometext\\/*/\nExplanation: This one allows any number of characters within the brackets, but they must be on the same line.\n\nAnd here's another one"
            },
            {
                "text": " r\"\\/\\*\"\n\nA:\n\nSo, you want to match a comment (string that starts with #) and then maybe some text with or without spaces, including"
            },
            {
                "text": " /\\*/\n\nQuestion: Write a Regular expression to find all the code comments that start with \"//\" in a single line. \nAnswer:  /\\*/\n\n"
            },
            {
                "text": " /^/ +([a-zA-Z_0-9]+)$/\n\nA:\n\nThis should do the trick:    \n/^(?:("
            },
            {
                "text": " /[^/]+/;\n\n//\n$ regex = '/^(?:\\s*#.*$|.*#.*$|.*\\s*#.*$)/"
            },
            {
                "text": " /^/*[^\\n]*$/\nNote:\n\n\\n is the escape character for a new line. So if you're doing something like this:\nstring"
            },
            {
                "text": "\n^(/\\*|\\//)(.*)$\n\nA:\n\nHere is my solution:\n\nI want to start the comment with /\\*/. So"
            },
            {
                "text": " /(\\/*.*?\\*/)/i\n\nQ:\n\nHow to get all string in a dictionary which contains a prefix?\n\nI have a dictionary which contains the"
            },
            {
                "text": " \n/(\\*|\\/\\*|[^*\\n]*)(.*?)(?:\\*|\\/\\*|[^*\\n]*)/gm"
            },
            {
                "text": " \n\\s{1}(/\\/\\*[^*]+\\*/|[^/\\n\\r]+)\nIn the end I found that this code works"
            }
        ]
    },
    {
        "expression": "\\.txt$",
        "raw_prompt": "Matches a file extention.",
        "refined_prompt": "Matches a .txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"",
        "matches": [
            "testfile.txt",
            ".txt",
            "this is a file.txt",
            "fasduht.txt",
            "gfadf.txt",
            "fsgh.txt",
            "apple.txt",
            "dog.txt",
            "demo.txt",
            "test.txt",
            "abc.txt",
            "test2.txt",
            "uadfh.txt"
        ],
        "non_matches": [
            "this is not a file.trt",
            ".tst",
            ".text",
            "fsdyfubsh",
            "uysdf8gy",
            "bhf67y",
            "76",
            "f7uy",
            "ougtxt",
            "gyfgd",
            "ft7ft67y",
            "f6tyg"
        ],
        "id": 693,
        "output": [
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: ^[\\w.-]+$\n\nExercise 2:\nMatch a series of alphanumeric characters.\nNon-match examples:\n- \"1.23.456\"\n- \".5,34,2\"\nAnswer: \\w+\n\nEx"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: I will need to use the \"^[a-z]*$\" pattern to match only lowercase letters in the filename.\n\nExercise 3:\nWrite a Python program that counts the number of words in a given string.\n\nAnswer: I will need"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: [^\\W_]\n\n5. Write a Python script that reads in a list of URLs and prints out the ones that match the regular expression pattern \"https://www.google.com/\".\n```python\nimport re\n\nurls = [\"https"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: \nimport re\n\npattern = '^.*\\.txt$'\n\ndef get_match_or_fail(string):\n    if re.match(pattern, string):\n        return True\n    else:\n        return False\n\nprint(get"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: [^\\w\\s\\.]\n\nExercise 4:\nCreate a RegEx pattern that matches email addresses in a given text.\nExample: Given text: \"My email is example@gmail.com.\", the RegEx pattern should match \"example@gmail."
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: \n(?i)^(?:.+\\.){1}([a-zA-Z\\s0-9._-]+)$\nIn this example, (?i) makes sure that the entire string is case insensitive.\n\n    "
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: r\"^(?!trt)((?=^.*[a-zA-Z])(?=^[0-9]))[a-zA-Z0-9]+$\".\n3. Write a RegEx that checks if a given"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer:\nimport re\nfile = open(r'D:\\Python Code\\txt_extension.txt', 'w')\nfile.write(\"Match examples: \")\nfor match in re.finditer(r'.+\\.(txt|txt[a-z"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer:\n_^[a-z]+\\.([a-z]+)$_\n\nExercise 2:\nWrite an email address validation script. \nAnswer:\nRegex: ([A-Za-z0-9._%+-]+@"
            },
            {
                "text": "Matches a.txt file extension.\nMatch examples:\n- \"testfile.txt\"\n- \".txt\"\n- \"this is a file.txt\"\nNon-match examples:\n- \"this is not a file.trt\"\n- \".tst\"Generate a RegEx for this description. \nAnswer: \"^.txt$|^[a-zA-Z]{3,6}\\.txt$\"\n\n\n\nQuestion 3: John wants to buy a laptop for $800. He has a budget of $700. How much more money does John need"
            }
        ]
    },
    {
        "expression": "((DK|FI|HU|LU|MT|SI)(-)?\\d{8})|((BE|EE|DE|EL|LT|PT)(-)?\\d{9})|((PL|SK)(-)?\\d{10})|((IT|LV)(-)?\\d{11})|((LT|SE)(-)?\\d{12})|(AT(-)?U\\d{8})|(CY(-)?\\d{8}[A-Z])|(CZ(-)?\\d{8,10})|(FR(-)?[\\dA-HJ-NP-Z]{2}\\d{9})|(IE(-)?\\d[A-Z\\d]\\d{5}[A-Z])|(NL(-)?\\d{9}B\\d{2})|(ES(-)?[A-Z\\d]\\d{7}[A-Z\\d])",
        "raw_prompt": "Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number).",
        "refined_prompt": "Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number).\nMatch examples:\n- \"CZ-7907111883\"\n- \"ESA12345678\"\n- \"FRAB123456789\"\nNon-match examples:\n- \"CZ55912\"\n- \"XY123456\"",
        "matches": [
            "CZ-7907111883",
            "ESA12345678",
            "FRAB123456789",
            "IT29718370337",
            "SE-864625192808",
            "LV-10527473548",
            "CY-67720099A",
            "NL105141803B34",
            "LT761853862266",
            "ATU97894110",
            "CZ-04262873",
            "IT02029028652",
            "FR-1X030074294"
        ],
        "non_matches": [
            "CZ55912",
            "XY123456",
            "FR-IB123456789",
            "ewsdfwef23ewdsff",
            "23ewsdfw7yugy",
            "f67yuf87yug8ub",
            "g8yu8gyFYGU",
            "G8YUBG8UBTF",
            "TFYGF67YGUCTV7",
            "FYVUTCVUGTF7YY",
            "6D7TFUYGUHIG7F6TY",
            "F76TYUGIHOJ"
        ],
        "id": 697,
        "output": [
            {
                "text": " (^[^0-9]|[^0-9])[0-9]{14}$"
            },
            {
                "text": " CZ[0-9]{3}-\\d{9}\n\nExercise 2: Validating"
            },
            {
                "text": " \n\"CZ-\\d{4}-\\d{3}\\d{2}\"\n\n"
            },
            {
                "text": "\n- (CZ|FRA|ESA)\\\\d{2}\\\\d{3}\n\n"
            },
            {
                "text": " (examples of both valid and non-match: \nValid:\n(?:(?<=CZ"
            },
            {
                "text": "\n[^A-Z0-9]|CZ[0-9]{2}-|F"
            },
            {
                "text": "\n^([1-9]{3})([1-9]{3})([1-9"
            },
            {
                "text": " CZ-(?P<CZ>(?:[A-Z]{2}[0-9]{"
            },
            {
                "text": " ^(?=CZ)(([0-9]{4}-[0-9]{4}-"
            },
            {
                "text": " CZ-\\d{2}-\\d{2}-\\d{4} or CZ-"
            }
        ]
    },
    {
        "expression": "^(((2|8|9)\\d{2})|((02|08|09)\\d{2})|([1-9]\\d{3}))$",
        "raw_prompt": "Matched Australian Postcodes, as defined by AusPost.\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\n1000s are for big companies in Sydney, competition mailings, etc.",
        "refined_prompt": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \"700\"\n- \"0700\"",
        "matches": [
            "200",
            "0820",
            "2753",
            "865",
            "6247",
            "3773",
            "0902",
            "982",
            "0937",
            "9607",
            "0852",
            "259",
            "0235"
        ],
        "non_matches": [
            "700",
            "0700",
            "abcd",
            "4897FDS",
            "79865DSFSF",
            "4985689456",
            "FS4D8",
            "489FSD",
            "FS894D78796",
            "894561",
            "89456123",
            "1"
        ],
        "id": 703,
        "output": [
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            },
            {
                "text": "Matched Australian Postcodes, as defined by AusPost.\r\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\r\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\r\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\r\n1000s are for big companies in Sydney, competition mailings, etc.\nMatch examples:\n- \"200\"\n- \"0820\"\n- \"2753\"\nNon-match examples:\n- \""
            }
        ]
    },
    {
        "expression": "^(19[0-9]{2}|[2-9][0-9]{3})-((0(1|3|5|7|8)|10|12)-(0[1-9]|1[0-9]|2[0-9]|3[0-1])|(0(4|6|9)|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(02)-(0[1-9]|1[0-9]|2[0-9]))\\x20(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$",
        "raw_prompt": "Checks for the format yyyy-MM-dd HH:mm:ss\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.",
        "refined_prompt": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12 14:25:59\"\n- \"20004-07-12 14:25\"",
        "matches": [
            "2004-07-12 14:25:59",
            "1900-01-01 00:00:00",
            "9999-12-31 23:59:59",
            "5930-04-14 17:38:38",
            "2323-09-15 13:48:38",
            "1976-02-12 23:58:58",
            "7750-02-25 04:19:35",
            "8859-10-06 23:16:25",
            "6865-11-04 20:47:46",
            "4749-02-05 12:58:40",
            "2135-10-20 06:33:01",
            "3847-10-25 07:59:02",
            "4962-11-13 21:23:51"
        ],
        "non_matches": [
            "04-07-12 14:25:59",
            "20004-07-12 14:25",
            "2004/07/12 14:25:59",
            "12/123/4322 14:25:59",
            "2346-2345-2435 14:25:59",
            "$23.454 14:25:59",
            "/5/5/5 14:25:59",
            "/5/5/20022",
            "14:25:59432/524/2435",
            "1-1-2 14:25:59",
            "(0xx12) 62509 14:25:59",
            "12/132/90"
        ],
        "id": 704,
        "output": [
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            },
            {
                "text": "Checks for the format yyyy-MM-dd HH:mm:ss\r\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year.\nMatch examples:\n- \"2004-07-12 14:25:59\"\n- \"1900-01-01 00:00:00\"\n- \"9999-12-31 23:59:59\"\nNon-match examples:\n- \"04-07-12"
            }
        ]
    },
    {
        "expression": "(^\\d{1,5}$|^\\d{1,5}\\.\\d{1,2}$)",
        "raw_prompt": "This expression evaluates simple currency values... alteast 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period",
        "refined_prompt": "This expression evaluates simple currency values... at least 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period\nMatch examples:\n- \"0\"\n- \"00000\"\n- \"00.00\"\nNon-match examples:\n- \"asds\"\n- \"000000\"",
        "matches": [
            "0",
            "00000",
            "00.00",
            "84",
            "645",
            "48",
            "489",
            "846",
            "987",
            "654",
            "321",
            "5164",
            "9835"
        ],
        "non_matches": [
            "asds",
            "000000",
            "00000.",
            "12/123/4322",
            "51:534",
            "$23.454fd",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 708,
        "output": [
            {
                "text": " [^\\d\\.\\d]|[^\\d\\.\\d]|[^\\d\\d\\.\\d]|[^\\d\\d\\d\\.\\d] |[^\\"
            },
            {
                "text": " (\\d|\\.){1,5}$\n\nA:\n\nThe best way would be to write your own regular expression and test your inputs against it.\nThe regex you need to match decimal numbers"
            },
            {
                "text": "\n\\d(?:\\.\\d|[\\d\\.]{1,2})\\d{1,5}|[\\d\\.]{0}\\d{1,2}|[\\"
            },
            {
                "text": " (?<!^)(\\d0+)$\n\nA:\n\nYour question is a bit ambiguous.  However, if you want to match the pattern of a number that starts with a zero and is followed"
            },
            {
                "text": " [^0-9.]\n1. (?:[1-9]\\d{0,3}|100\\d|1[0-9]\\d|1[0-9]\\d"
            },
            {
                "text": " (.*)(\\.)(.*)\n\nA:\n\nYou are pretty close!\nThe following regular expression matches a double decimal separator:\n^(?:\\d{1,5}\\.\\d"
            },
            {
                "text": " ^(?=.{,6})([0-9]{,2})([0-9]{,5})\\.([0-9]{,4}[0-9]"
            },
            {
                "text": " 0.00 \n\nA:\n\nThis pattern should work\n^(0|[1-9][0-9]{0,2}0|[1-9][0-9]{"
            },
            {
                "text": " \n[0-9]{1,2}[0-9]{2,4}[.][0-9]{1,2}[0-9]{2,4}["
            },
            {
                "text": " [^a-zA-Z0-9]\n\nWrite a regular expression to match a string with the format \"abc123\"\n\nAnswer: [a-zA-Z0-9]{"
            }
        ]
    },
    {
        "expression": "^(\\$)?(\\s)?(\\-)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "raw_prompt": "Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places.",
        "refined_prompt": "Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places.\nMatch examples:\n- \"$1,000.00\"\n- \"$-1,000.00\"\n- \"100.8766\"\nNon-match examples:\n- \"$1a\"\n- \"$#100.00\"",
        "matches": [
            "$1,000.00",
            "$-1,000.00",
            "100.8766",
            "894.89",
            "$54.156",
            "$54.484",
            "$545.155",
            "$57.159",
            "$96.154",
            "814.85",
            "894.11",
            "824.22",
            "44.97"
        ],
        "non_matches": [
            "$1a",
            "$#100.00",
            "1,00.00",
            "12/123/4322",
            "51:534",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 709,
        "output": [
            {
                "text": "\n$(?<![^0-9"
            },
            {
                "text": " [^0-9]*?[0-"
            },
            {
                "text": " (\"^[0-9]+(\\.[0"
            },
            {
                "text": " (^[^$]|[$][^"
            },
            {
                "text": " ($[0-9]+)\\.0+\n"
            },
            {
                "text": " ^[$\\d,]+$ \n\n"
            },
            {
                "text": " [a-zA-z0-9-"
            },
            {
                "text": "\n[0-9]\\$[0-"
            },
            {
                "text": "\n^-?\\$([0-9,"
            },
            {
                "text": " (\\d*\\.\\d{3})("
            }
        ]
    },
    {
        "expression": "^[\\w0-9&#228;&#196;&#246;&#214;&#252;&#220;&#223;\\-_]+\\.[a-zA-Z0-9]{2,6}$",
        "raw_prompt": "This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed.",
        "refined_prompt": "This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed.\nMatch examples:\n- \"gut.txt\"\n- \"afdsa.dfa\"\n- \"t3e.fsd\"\nNon-match examples:\n- \"&amp;quatsch\"\n- \"qua%tsch.txt\"",
        "matches": [
            "gut.txt",
            "afdsa.dfa",
            "t3e.fsd",
            "fd.ta",
            "fsg.fad",
            "wtre.asda",
            "gs.fsg",
            "ewfs.afd",
            "asdf.jpg",
            "adsf.png",
            "dfcv.jpg",
            "qrew.jpg",
            "ot.png"
        ],
        "non_matches": [
            "&amp;quatsch",
            "qua%tsch.txt",
            "auch_quatsch.test.txt",
            "txtpng",
            "pgfdas",
            "bfdahih.sdfhu.hufd",
            "/5/5/5",
            "98iojk",
            "u09nKLJG FSL",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 711,
        "output": [
            {
                "text": "  \n\\b[a-zA-Z0-9._%+-]+-\\.[a-"
            },
            {
                "text": " \n\"(\\w+)\\.txt\"\n\nExercise 3:\n\nExercise: Write a function that"
            },
            {
                "text": "\nimport re\n\ndef validate_filename(filename: str):\n    if re.match(r'^"
            },
            {
                "text": " [^A-Za-z0-9_-]{0,}[A-Za-z"
            },
            {
                "text": " \\w+\\.txt\n\n3. Extract all the email addresses from the following text: \"Please contact me at"
            },
            {
                "text": " /[A-Za-z0-9_.-]+/\n\n### Exercise 2:\nUsing the"
            },
            {
                "text": " [^\\w.] (or [^\\W\\d_])+ (or [^\\W\\d"
            },
            {
                "text": "  [a-zA-Z0-9!@#$%^&*()_+=`{}"
            },
            {
                "text": "\n- [a-zA-Z0-9_.-]+\\.(txt|pdf|xlsx"
            },
            {
                "text": "\n\n```python\nimport re\nfilename = \"afdsa.dfa\"\nif re.match"
            }
        ]
    },
    {
        "expression": "^\\.{1}",
        "raw_prompt": "simply checks to see if the first charactor is a . (dot)",
        "refined_prompt": "simply checks to see if the first charactor is a . (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"",
        "matches": [
            ".net",
            ".blah",
            ".anything",
            ".gvy",
            ".vyuhbj",
            ".g7yu",
            ".8g7uihbj",
            ".cytgv",
            ".yfgu",
            ".yftugh",
            ".tyyf7gy8",
            ".yg",
            ".ctfytgv"
        ],
        "non_matches": [
            "net",
            "net.stuff",
            "netstuff.",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "98iojk",
            "432/524/2435",
            "adfa2",
            "dfg",
            "0j0jweBBBB"
        ],
        "id": 727,
        "output": [
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: \".[a-zA-Z0-9._-]+\"\n\n2. Exercise 2: \nCreate a RegEx for all words that contain the letters \"ab\" at least 2 times in a row. Generate a list of words that match your RegEx. \nAnswer"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer:\n(^[a-zA-Z0-9-]*[.](net|blah|anything)$)\n\nThe next step in the process is to write a function that takes two parameters:\nfunction generateRegEx($str, $strThing)\n{"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: (?<=^|\\.)[\\w-]+(\\.[\\w-]+)+$\n\nA:\n\nOne option using a regexp would be something like\n^(?:\\.|^)(\\w+\\.){4}$\n\nThis would"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer:\n^[a-zA-Z0-9.]+$\n\nA:\n\nThis should work:\n^[a-zA-Z0-9.]+$\n\n^ and $ are what makes your regex work, they are the start and end of the line"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: \n[^.\\s]\n\n2. Create a Regular Expression that matches exactly 5 characters, followed by a space, then exactly 5 characters.\n\n3. Create a Regular Expression that matches at least one letter, then at least one number.\n\n4. Create a Regular Expression"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: (.*)\\.net\n\nWrite a Python program to generate a pattern that matches the number of words in a sentence. \nAnswer: \\b(\\w+)\\W+\\b\n\n3. Write a Python program to generate a pattern that matches phone numbers in the format \"(123)"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: \n^\\w+\\.\\w+$\n\nI'm not sure how to implement this in my program, and I suspect the issue has something to do with the loop I'm using to scan through the words. I am trying to scan through a file, and if it finds the first"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer:\n^(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\s]+\\.[a-zA-Z0-9\\-\\._]$\n\nTo improve performance, you can use a simple lookaheads:"
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: \"^net\\.\"\n\n2. Create a RegEx to match all words that begin with \"s\".\nAnswer: \"^s\\w+\"\n\n3. Find all the email addresses in the following string:\n\"My email address is john.doe.@example."
            },
            {
                "text": "simply checks to see if the first charactor is a. (dot)\nMatch examples:\n- \".net\"\n- \".blah\"\n- \".anything\"\nNon-match examples:\n- \"net\"\n- \"net.stuff\"Generate a RegEx for this description. \nAnswer: ^[a-zA-Z0-9+.]*\n\nI would recommend reading up on regex or googling it. Once you get started, you will find that it can be a very powerful tool.\n\nA:\n\nThe problem is that in your regex, you"
            }
        ]
    },
    {
        "expression": "^\\d?\\d'(\\d|1[01])?.?(\\d|1[01])&quot;$",
        "raw_prompt": "This RE matches the height in feet and inches with decimals and without decimals in it",
        "refined_prompt": "This RE matches the height in feet and inches with decimals and without decimals in it\nMatch examples:\n- \"5'5.5&quot;\"\n- \"2'3&quot;\"\n- \"9'10.4&quot;\"\nNon-match examples:\n- \"5 feet 5.5 inches\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "5'5.5&quot;",
            "2'3&quot;",
            "9'10.4&quot;",
            "70'11_10&quot;",
            "57'2&quot;",
            "4'108&quot;",
            "68'49&quot;",
            "07'93&quot;",
            "86'11&quot;",
            "94'110&quot;",
            "3'10&quot;",
            "6'0&quot;",
            "6'112&quot;"
        ],
        "non_matches": [
            "5 feet 5.5 inches",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "26+2'2'565'1",
            "65'51'684",
            "8944'84'48'",
            "4984'646'86'486",
            "164'879'54"
        ],
        "id": 729,
        "output": [
            {
                "text": " 5\\d+\\s+(\\d+)'\\s+(\\d+)'\\s+("
            },
            {
                "text": " \"5'5\\.5&quot;\"\n\n5. Match all the numbers in this"
            },
            {
                "text": " \\b5\\d{1,2}\\d\\d\\d&quot;,\\"
            },
            {
                "text": " \"5\\.5\\d&quot;\"\n\nExercise 2:\nWrite a Python program"
            },
            {
                "text": " \n- \"5'5.5&quot;|2'3&quot;"
            },
            {
                "text": " (5'5.5\\.[0-9]?\\.[0-9]?&"
            },
            {
                "text": "\nimport re\n\n#This RE matches the height in feet and inches with decimals and without"
            },
            {
                "text": " \\d+\\.\\d+\\&quot;\n\n\n\nQuestion 7: Alex bought"
            },
            {
                "text": " \"5'5\\.5&d;\n\nUse case 3: A group of students are working"
            },
            {
                "text": "\n- RE: \\d+\\.\\d+&quot;\n- RE: \\d"
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "raw_prompt": "Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes).",
        "refined_prompt": "Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes).\nMatch examples:\n- \"LOZG7802117B9\"\n- \"LOZG-780211-7B9\"\n- \"LOZG780211-7B9\"\nNon-match examples:\n- \"LO-ZG-78-02-11-7B9\"\n- \"52/2/54/245\"",
        "matches": [
            "LOZG7802117B9",
            "LOZG-780211-7B9",
            "LOZG780211-7B9",
            "pdbb 744807Rcb",
            "gKFM-572682R8b",
            "fKqS423419-Eoj",
            "RBLx561138|5tL",
            "wwqh767304 j2B",
            "eblp686659-8h4",
            "MCkL-404578 g4a",
            "TcrQ 102152-ewY",
            "igis991168-p5x",
            "ceOZ331953sNQ"
        ],
        "non_matches": [
            "LO-ZG-78-02-11-7B9",
            "52/2/54/245",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 730,
        "output": [
            {
                "text": "  LO-ZG [0-9]{1}-[0-9]"
            },
            {
                "text": " (0-9]{4}-[0-9]{3}-[0"
            },
            {
                "text": " \"([0-9]{5})/([0-9]{2}"
            },
            {
                "text": " \"^[0-9]{3}-?[0-9]{"
            },
            {
                "text": " (lo\\s+guidance\\s+finance\\s+(\\"
            },
            {
                "text": " /(?<=lo\\+\\d{2}-).*?/"
            },
            {
                "text": " /[A-Z]{3}/|[0-9]{2"
            },
            {
                "text": " [^0-9]+\n- \"LO-ZG-78-02-"
            },
            {
                "text": " \nr\"^[A-Z0-9]*(?:\\d"
            },
            {
                "text": " \"LOzg7802117b9[a-z0-9:]*/"
            }
        ]
    },
    {
        "expression": "^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$",
        "raw_prompt": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.",
        "refined_prompt": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\"\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31\"",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080:0:0:0:8:800:200C:417A",
            "0:0:0:0:0:0:0:1",
            "FC3:5cfB:1b2:55:2:EeE:eD:88",
            "de9:6b:06:FaA:fcb:b:EB:Bf8a",
            "EC:8De6:36:B6dE:b:A8:cbf:c",
            "C:2:CE:2:DB:2bf:2B:C",
            "C5A:1B8:1f:9:d23:dBDE:C:F",
            "c9:Af7:3:E1:88bB:0b:55:FA5b",
            "aee:e7:Bb:aC11:57C4:edd9:fc8:f",
            "ede0:7C7F:75:67:a72:CcD1:ba:B1",
            "7Bdd:1:35:7:D25F:208:f:eD36",
            "A4b:d3:3:8EdD:858:4D:E:6"
        ],
        "non_matches": [
            "128.0.0.1",
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31",
            "::1",
            "12/123/4322",
            "sfalijad234",
            "there is a boy",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "abc111def",
            "99999@gmail"
        ],
        "id": 731,
        "output": [
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1/"
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1/"
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1:"
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            },
            {
                "text": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080:0:0:0:8:800:200C:417A\"\n- \"0:0:0:0:0:0:0:1\"\nNon-match examples:\n- \"128.0.0.1\""
            }
        ]
    },
    {
        "expression": "^[0-9]*$",
        "raw_prompt": "Matches only numbers, in any length. No characters or punctuation will be matched.",
        "refined_prompt": "Matches only numbers, in any length. No characters or punctuation will be matched.\nMatch examples:\n- \"2\"\n- \"99\"\n- \"15800\"\nNon-match examples:\n- \"1,2\"\n- \"f9\"",
        "matches": [
            "2",
            "99",
            "15800",
            "48",
            "156",
            "6864548",
            "9489",
            "46848",
            "646",
            "84684",
            "86468",
            "4651",
            "48971564"
        ],
        "non_matches": [
            "1,2",
            "f9",
            "a9j",
            "12/123/4322",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 735,
        "output": [
            {
                "text": " ([0-9]+)?,(?=([0-9]{3}))\n\nExercise 2: \nMatch this string using the RegEx described in Exercise 1: \"abc1234\"\nAnswer: ([0-9]+)\n\nExercise 3"
            },
            {
                "text": " \\d\n- \"f9\"Generate a RegEx for this description. \nAnswer: [A-Za-z]\n- \"f9\"Generate a RegEx for this description. \nAnswer: [A-Z]\n- \"f9"
            },
            {
                "text": "\n^\\d+$\nDescription: Matches a string of digits that can have any number of digits (including no digits). The string starts with a digit and the ending string are one or more digits. No characters or punctuation will be matched.\n\nExercise 3:"
            },
            {
                "text": " [^0-9a-zA-z]\n\n\n\nDaily life can be both exciting and challenging, especially when it comes to sports and outdoor activities. One popular activity that people enjoy is lifting weights. Lifting weights is a great way to stay fit and build strength"
            },
            {
                "text": " [0-9\\\\-\\\\.]*/[0-9\\\\-\\\\.]\nhttps://regex101.com/r/eU1mGf/1\nI have tried this but it does not make it work\nvar str = \"a.b.c"
            },
            {
                "text": " ^[0-9]*[, ]([0-9]*)*$\n\nExercise 5:\nCreate a RegEx to match any string that begins with \"The \" and ends with \" of the world\"\nAnswer: ^The.* of the.*"
            },
            {
                "text": "\n[0-9]{2,}\n\n8. Create a RegEx for this pattern: a word that begins with the letter a or b and ends with the letters n or k.\nAnswer:\n[ab]n[ck]\n\n9. Create a"
            },
            {
                "text": " ^\\d{1,2}$ \n- \"A1A\"Generate a RegEx for this description. \nAnswer: ^A\\d{1,2}A$ \n\nExercise 4:\nCreate a class to store a user's password"
            },
            {
                "text": " \"^[0-9]{1,2}\\.[0-9]{1,2}$\"\n\nExercise 2:\n\nGiven the string \"9,8a,9b,5c,6d,9e,14,15f\","
            },
            {
                "text": "\n\nr\"^\\d{4}-\\d{2}-\\d{2}$\"\n\n\n\nPositive Conversation:\n\nStudent 1: Hey, did you know that there are some really cool things you can do with cars in your daily life"
            }
        ]
    },
    {
        "expression": "^\\d{5}(-\\d{4})?$",
        "raw_prompt": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or &quot;hyphen&quot;. [67]Sector or Several Blocks. [89]Segment or One Side of a Street. Also just FYI, ZIP codes in the northeast US frequently start with '0' or '00'. [00988-Carolina, PR] [03110-Bedford, NH]. Thanks, Ryan v-",
        "refined_prompt": "Zip+4 Zip code RegEx. You may omit the +4 digits but you must also then omit the hyphen/dash as well.\nMatch examples:\n- \"98121\"\n- \"00988\"\n- \"12345-6789\"\nNon-match examples:\n- \"98121-\"\n- \"12345-678\"",
        "matches": [
            "98121",
            "00988",
            "12345-6789",
            "97974",
            "81896-6579",
            "70912",
            "60306-8907",
            "86814-6754",
            "57939-2962",
            "10379",
            "24243-5665",
            "71500-7460",
            "83951-9333"
        ],
        "non_matches": [
            "98121-",
            "12345-678",
            "1234",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "abc111def",
            "12/132/90"
        ],
        "id": 738,
        "output": [
            {
                "text": " [0-9]{5}-(0-9)\n- \"12345-\"\n- \"12345-678\"Generate a RegEx for this description. \nAnswer: ["
            },
            {
                "text": " I chose to add the hyphen/dash to my regex but I am still not sure if it is correct.\n\nA:\n\nYou could do this with a regex like /^[0"
            },
            {
                "text": "\n(?<!\\- )(?<first_part>[0-9]{3})(?<second_part>[0-9]{4})[0-9]{"
            },
            {
                "text": " \n- \"(?<!\\d)-(?!\\d)\"\n\nStudent Question:\n\nI'm struggling with understanding how to use the zip_longest and itertools."
            },
            {
                "text": " \n\n[0-9]{5}([- ]){0,3}[0-9]{4}|[0-9]{5}(?!-)[0"
            },
            {
                "text": "  \n[012]?[0-9]{4}-[0-9]{3}\nMatch examples:\n- \"1234-5678\"\n- \"11234-"
            },
            {
                "text": " (?<zip>\\d{9})-(?<code>\\d{4})-[a-z]{2}\nExercise 2: Given the following data from a table"
            },
            {
                "text": "\n([a-zA-Z0-9]+(\\-|\\+1[a-zA-Z0-9]+)?)\n\nA:\n\nFirst, I'd"
            },
            {
                "text": " (01-9)(\\\\d|\\\\d-)\\\\d{3}-\\\\d{4}\n\nA:\n\nI think you should use a combination of positive and negative looka"
            },
            {
                "text": " (Any set of characters with a hyphen, dash, or dot that's between 2 and 9 digits)\n- \"123456789\"; \"123456789.9\"; \"12345"
            }
        ]
    },
    {
        "expression": "^[1-9][0-9]{0,2}$",
        "raw_prompt": "All positive non-zero integers between 1 and 999. You can adjust the upper range of this expression by changing the second number (ie 2) in the {0,2} part of the expression.",
        "refined_prompt": "All positive non-zero integers between 1 and 999.\nMatch examples:\n- \"1\"\n- \"561\"\n- \"999\"\nNon-match examples:\n- \"-1\"\n- \"0\"",
        "matches": [
            "1",
            "561",
            "999",
            "189",
            "846",
            "875",
            "965",
            "485",
            "325",
            "612",
            "632",
            "666",
            "888"
        ],
        "non_matches": [
            "-1",
            "0",
            "1000",
            "925148",
            "489198498",
            "489489",
            "8425",
            "8452",
            "-48196",
            "1895.156",
            "1596.15",
            "54.321"
        ],
        "id": 739,
        "output": [
            {
                "text": ".*[02468]\n1-9: match numbers from 1 to 9\na-z or A-Z: match all letters from a to z or A to Z\n0-9: match all digits\n\\D: any character that is not a digit (underscore, space, etc.)\n\\D+:"
            },
            {
                "text": " 1+0+1+0+1+0+1+0+=1+0+1+0+1+0+1+0+1+0+1+0+1+0+1+0+1+0+1+0+1+0+1+0+1+0+1"
            },
            {
                "text": " 1-999\nIn this example, we will use the RegEx of [1-9][0-9] to match between 1 and 999. You could also use something like this, [0-9][1-9][0-9] to only match numbers in the range 0-99.\n\nExercise 4:"
            },
            {
                "text": " [1-9][0-9]*\n- \"3\"Generate a RegEx for this description. \nAnswer: [3-9]\n- \"Aaa22\"Generate a RegEx for this description. \nAnswer:.{4,7}\n\nA:\n\nYou can try:"
            },
            {
                "text": " \n\\b-?\\d{1,5}-?\\d{1,5}\\b\n\n\n\nTitle: The Disastrous Impact of Science on the Internet and Coding\n\nIntroduction:\n\nIn this scathing news, we will delve into the dark side of science and how it has infiltrated the internet and"
            },
            {
                "text": "\n- [1-9][0-9]\n\nI thought I had it down, but I got these two errors:\n\nLine 14, in <module>\n    print (re.match(\"[1-9][0-9]\", \"1\"))\n  TypeError: 'NoneType' object is not"
            },
            {
                "text": " 0[1-9]|[1-9][0-9]|100[0-9]|1000\n2) Write a RegEx to match all email addresses (including.com and.org). \nMatch examples:\n- \"jane@example.com\"\n- \"jane@example.org"
            },
            {
                "text": " r\"^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[\\w-]).*$\"\nExplanation:\nThe first lookahead (?=.*\\d) asserts that the input value must have at least one digit, and"
            },
            {
                "text": " ^[0-9][1-9][0-9]|[12][0-9][0-9]|[3][0-9][0-9]$\nThis pattern matches: \n- \"0\"\n- \"1\"\n- \"2\"\n- \"3\"\n- \"4"
            },
            {
                "text": "\nYou want each word in the list to be between 1-999 characters long.\n\n[1]\n[2]\n[3]\n[4]\n[5]\n[6]\n[7]\n[8]\n[9]\n[10]\n[11]\n[12]\n[13"
            }
        ]
    },
    {
        "expression": "(((0[1-9]|[12][0-9]|3[01])([.])(0[13578]|10|12)([.])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([.])(0[469]|11)([.])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([.])(02)([.])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([.])([02468][048]00))|((29)([.])(02)([.])([13579][26]00))|((29)([.])(02)([.])([0-9][0-9][0][48]))|((29)([.])(02)([.])([0-9][0-9][2468][048]))|((29)([.])(02)([.])([0-9][0-9][13579][26])))",
        "raw_prompt": "Usefull for SQL update and insert sentence..",
        "refined_prompt": "Match date patterns in the format of \"dd.mm.yyyy\" or \"dd.mm/yyyy.\" It accounts for different variations in days, months, and leap years.\nMatch examples:\n- \"01.01.2004\"\n- \"30.12.2005\"\n- \"24.02.1980\"\nNon-match examples:\n- \"01/01/2004\"\n- \"1.1.2004\"",
        "matches": [
            "01.01.2004",
            "30.12.2005",
            "24.02.1980",
            "30.08.2009",
            "29.02.7604",
            "29.02.4428",
            "29.02.9844",
            "16.02.2905",
            "20.10.2000",
            "05.10.2063",
            "02.10.2939",
            "07.11.2905",
            "03.02.1924"
        ],
        "non_matches": [
            "01/01/2004",
            "1.1.2004",
            "01-01-2004",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 742,
        "output": [
            {
                "text": " The RegEx could be \"^(0[1-9]|1[012])[./-"
            },
            {
                "text": " (^0?[1-9]?[0-9]?[0-9]?"
            },
            {
                "text": "\n\n``` python\n# Import the re library\nimport re\n\n# Define the text to"
            },
            {
                "text": " (0-9)\\.\\d{1,2}(\\/|\\.)\\d{4"
            },
            {
                "text": " [\\d]{2}\\.[0-9]{2}\\.[0-9]{4"
            },
            {
                "text": " The regex should match dates in the format of \"dd.mm.yyyy\" or \"mm.dd"
            },
            {
                "text": "\npattern = re.compile(r\"([0-9]{1,2})/(["
            },
            {
                "text": "\n[1-9]?[0-9]\\.[0-9]{3}|"
            },
            {
                "text": "\n1.\\d\\d.\\d\\d[-/ ]?\\d{2}\\"
            },
            {
                "text": " \n^[01]\\d\\.\\d\\d[./-]\\d\\d$"
            }
        ]
    },
    {
        "expression": "^[A-Za-z]{3,4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "raw_prompt": "This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections.",
        "refined_prompt": "This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections.\nMatch examples:\n- \"LOZG7502123T7\"\n- \"LOZG-750212-3T7\"\n- \"LOZ 750212 3T7\"\nNon-match examples:\n- \"LOZG750212\"\n- \"f34fvfv\"",
        "matches": [
            "LOZG7502123T7",
            "LOZG-750212-3T7",
            "LOZ 750212 3T7",
            "XHum233851|Jmy",
            "hgXM|314476|flP",
            "ZRDh 460315 1c3",
            "nRyL375538seX",
            "Yqa-542785rzd",
            "btPn8184368q0",
            "VMc-207955Kbs",
            "FQa354770|FzW",
            "cLo-216233ykI",
            "DHF411355I5m"
        ],
        "non_matches": [
            "LOZG750212",
            "f34fvfv",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "u09nKLJG FSL",
            "adfa2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 743,
        "output": [
            {
                "text": " [a-zA-Z0-9]"
            },
            {
                "text": " \n\\d{3}[-\\s"
            },
            {
                "text": "\n(?<section1>\\S{3"
            },
            {
                "text": "\n/[A-Z][a-z]"
            },
            {
                "text": " \"[a-z]+[0-9]+["
            },
            {
                "text": " f34fvf-vc\n\n5."
            },
            {
                "text": " [a-zA-Z0-9\\-"
            },
            {
                "text": " \n\nI haven't been able to find any"
            },
            {
                "text": "\n/(^[^-]{3})|"
            },
            {
                "text": " [\\w\\d\\-]{3,4"
            }
        ]
    },
    {
        "expression": "^([-]?[0-9])$|^([-]?[1][0-2])$",
        "raw_prompt": "I made this to validate offsets to GMT",
        "refined_prompt": "This regex pattern is designed to match integers from -12 to 12, whether they are positive or negative. It won't match non-integer values, values outside the range of -12 to 12, or non-numeric characters.\nMatch examples:\n- \"1\"\n- \"-10\"\n- \"10\"\nNon-match examples:\n- \"13\"\n- \"-25\"",
        "matches": [
            "1",
            "-10",
            "10",
            "2",
            "3",
            "4",
            "5",
            "8",
            "-11",
            "-8",
            "-5",
            "-4",
            "-9"
        ],
        "non_matches": [
            "13",
            "-25",
            "111",
            "4815",
            "4591",
            "54",
            "48",
            "64",
            "-489",
            "-4854",
            "67tgyu",
            "t6gy"
        ],
        "id": 747,
        "output": [
            {
                "text": "\n[1-9][0-9]|1[012]\n\nExercise 2: Modify the RegEx pattern in Exercise 1 to match integers"
            },
            {
                "text": " /\\b(0|[1-9][0-9]|1[0-9][0-9][0-9]|2["
            },
            {
                "text": " \\d{1,3}[, -]?\\d{1,3}\n\nExercise 3:\nWrite a RegEx pattern that matches"
            },
            {
                "text": " ^[1-9][0-9]*$\n\n    Lecture Note: Regular Expressions and Regex Flags\n\nContents:\n"
            },
            {
                "text": " \n\\d+|\\D+ \n\n3. A non-numeric character between two alphabets is allowed. Generate a Reg"
            },
            {
                "text": " \"0-9\\s*[A-Za-z]\" \n\n---\n\n**Exercise:** Write a regular expression that checks if"
            },
            {
                "text": " ^[1-9][0-9]?$\n\n2. Write a regular expression that matches a name consisting of only letters (a-z,"
            },
            {
                "text": " ^[-]?[1-9]\\d*$\n\n\n\nQuestion 3:\nEmily has a jar filled with marbles. The ratio"
            },
            {
                "text": " /^\\d{1,2}(-\\d{1,2})?$/\n\nQ:\n\nHow do I sort a list that"
            },
            {
                "text": " The pattern should be to match integers from -12 to 12, whether they are positive or negative.\n\n2. Exercise: Generate a RegEx for this"
            }
        ]
    },
    {
        "expression": "^([01][012]|0[1-9])/([0-2][0-9]|[3][0-1])/([0-9][0-9][0-9][0-9])$",
        "raw_prompt": "Regular expression that only allows expression in the format: MM/DD/YYYY",
        "refined_prompt": "Regular expression that only allows expression in the format: MM/DD/YYYY\nMatch examples:\n- \"01/01/2004\"\n- \"01/18/1159\"\n- \"05/31/2631\"\nNon-match examples:\n- \"1/1/04\"\n- \"01/01/04\"",
        "matches": [
            "01/01/2004",
            "01/18/1159",
            "05/31/2631",
            "03/30/3776",
            "10/30/5158",
            "00/31/9275",
            "01/30/2209",
            "01/11/2791",
            "02/31/7476",
            "04/30/5692",
            "10/10/3307",
            "02/18/3193",
            "02/26/4675"
        ],
        "non_matches": [
            "1/1/04",
            "01/01/04",
            "03/32/2004",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 749,
        "output": [
            {
                "text": " [^/]+/[^/]+/[^/]+\\s+\\d{4}\\-\\d{2}\\-\\d{2}\\s+\\d{4}\n"
            },
            {
                "text": " [0-9]\\d/[0-9]/[0-9]\n- \"04-12-\"Generate a RegEx for this description.\nAnswer: [0-9"
            },
            {
                "text": "\nimport re\nimport random\n\nname = \"Jonah\"\nage = 24\ndate = \"25/14/2026\"\n\ntest_list = [\n    \"001/01"
            },
            {
                "text": " ^[0-9]{1,2}\\/[0-9]{1,2}\\/[0-9]{4}$\n\n```python\ndate_string ="
            },
            {
                "text": " \n^\\d{1,2}\\/\\d{2}\\/\\d{4}$|^\\d{1,2}/\\d{2}/\\d{"
            },
            {
                "text": "\n^[1-9]\\d?/\\d??/\\d{4}$\n\nExercise 5: \nGenerate a RegEx for this description. Match examples:\n"
            },
            {
                "text": " \\d{2}\\/\\d{2}\\/\\d{4}\n\nExercise 2:\nYour teacher said you can use two regular expressions for this task. \nMatch examples:"
            },
            {
                "text": " \n^(\\d{1,2})/(\\d{1,2})/(\\d{4})$\n\nExercise #4:\nWhat is the difference between a comma and a"
            },
            {
                "text": " \n^[0-9]{2}\\/[0-9]{2}\\/[0-9]{4}$\nExercise 2:\nCreate a RegEx that only"
            },
            {
                "text": " /^(0|[1-9][0-9]|1[0-2])\\/(0|[1-9][0-9]|[12][0-9]"
            }
        ]
    },
    {
        "expression": "\\/\\*((?!\\*\\/).)*\\*\\/",
        "raw_prompt": "Strip C style block comments",
        "refined_prompt": "Strip C style block comments\nMatch examples:\n- \"/* comments */\"\n- \"/*\\n*\\n*/\"\n- \"/***********/\"\nNon-match examples:\n- \"// comments\"\n- \"///f34fvfv\"",
        "matches": [
            "/* comments */",
            "/*\\n*\\n*/",
            "/***********/",
            "/* adsfa */",
            "/* f2wef23 */",
            "/* fads32ff2 */",
            "/* f23ewds */",
            "/* fdsdfad */",
            "/* fadsf2ewds */",
            "/* afsd2 */",
            "/* fadsfd2 */",
            "/* jhyjg */",
            "/* jgyy56 */"
        ],
        "non_matches": [
            "// comments",
            "///f34fvfv",
            "////34f2vf*42e",
            "///12/123*/4322",
            "*//2346-2345-2435",
            "*//43.v234",
            "@#dfkjn*av",
            "/5/5/2*0022",
            "//432/524/2*435",
            "//1*-1-2",
            "(0xx12) 6250*9",
            "//12/132/*90"
        ],
        "id": 751,
        "output": [
            {
                "text": " /\\*(.*?)\\*/\n\nExercise 8.1.3.2: Write a Python script that generates a RegEx to match all email addresses in a given text.\n\nSolution:\nimport re\ntext = '''\nMy email is john@example"
            },
            {
                "text": "\n\n```python\nimport re\n\n# Example of a C-style comment\ncomment1 = \"/* comments */\"\n# Example of a c-style comment starting with '//'\ncomment2 = \"// comments\"\n# Example of a c-style comment"
            },
            {
                "text": "\n- Match any text that is delimited by /* comments */ or /*\\n\\n*/ or /*... */ delimited by a space.\n- Match any text that is delimited by /* comments */ or /*\\n\\n*/ or /*... */ delimited by a"
            },
            {
                "text": "\nPattern r = Pattern.compile(\"^\\\\*(.*)\\\\*/$\");\n\nI am not sure why the non-match examples are ignored. Any help on this will be greatly appreciated.\n\nA:\n\n^\\\\*(.*)\\\\*/$"
            },
            {
                "text": " /^\\s*//|\\n\\s*$|\\s*#.*$/\n\nI hope you found this section helpful! Happy Regexp-ing!\n\nBlog Post:\n\nWhen it comes to regular expressions in Python, the syntax and"
            },
            {
                "text": " /(\\/*\\n*\\n*/)\\s(.*?)(\\s|$)/, \n\nRegex101 Demo\nA.\n\\* matches the asterisk character literally (not the asterisk character \\*).\n\\s matches a whitespace character"
            },
            {
                "text": " #(/\\*[^*]+.*\\*\\/[^*/]*$)/\n\n```python\n# Exercise 4\nimport re\n\ndef generate_regex(string):\n    return generate_regex_from_string(string, '//"
            },
            {
                "text": "\n/(\\/\\/.*?\\n|//.*?\\n|\\n\\n)*$/\n\n5. Write a Python program to extract all email addresses from a text file using RegEx.\n\nExample Solution:\nimport re\n\nwith open('sample.txt"
            },
            {
                "text": " //(.*)?\\n\n- \"//f34fvfv\\n//f34fvfv\\n\"\n    - Note that you don't match a newline if it is not followed by a /* nor a */.\n\nI hope this post"
            },
            {
                "text": " /^\\/\\*.*$/\n\"\"\"\n\nTutor: Excellent job! You really understand how to implement and use RegEx in Python.\n\nOnline chat conversation:\n\nStudent: Hi, can you help me with my homework on Python for Dummies?\n"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|[12]\\d|3[01])\\.(0[13578]|[13578]|1[02])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|[12]\\d|30)\\.(0[13456789]|[13456789]|1[012])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|1\\d|2[0-8])\\.0?2\\.((1[6-9]|[2-9]\\d)\\d{2}))|(29\\.0?2\\.((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "I did not found a Regex for german date, so I created my own. This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999. As usual, many tests have been made. I think this one should be fine.",
        "refined_prompt": "This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999.\nMatch examples:\n- \"1.1.2004\"\n- \"01.01.2004\"\n- \"29.2.2004\"\nNon-match examples:\n- \"1/1/2004\"\n- \"1-1-2004\"",
        "matches": [
            "1.1.2004",
            "01.01.2004",
            "29.2.2004",
            "29.2.1600",
            "30.12.6216",
            "20.06.1676",
            "14.03.6471",
            "16.02.1943",
            "20.06.2797",
            "01.3.1884",
            "2.08.1886",
            "29.02.3984",
            "30.12.3337"
        ],
        "non_matches": [
            "1/1/2004",
            "1-1-2004",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 754,
        "output": [
            {
                "text": " [^0-9.]{1,30}.{1,3}[^0-9.]\n\n- \"01.01.2004\"\n"
            },
            {
                "text": " \"^[0-9][0-9][0-9].[0-9][0-9][0-9].\"\n\nExercise 2"
            },
            {
                "text": " \n(\\d{2}[.][0-9]{2})\n\n- \"2000.1.2009\"\n- \"02.1"
            },
            {
                "text": " \"^\\d{2}\\.\\w{2}\\..+$\"\n\"\"\"\ndef extract_dates(data):\n    return re.search"
            },
            {
                "text": "\n[0-9]{2}[0-9]\\/[0-9]{2}[0-9]\\/[19][0"
            },
            {
                "text": " /(\\d{2}[.]\\d{2}[.]\\d{4})|(\\d{1,2}-\\d{1"
            },
            {
                "text": " \\d{1,2}.\\d{1,2}.\\d{4}\n\n5. What does the. character mean in a regular expression"
            },
            {
                "text": "\n(1\\.\\d\\d\\.\\d\\d\\.\\d\\d)? | (19\\.\\d\\d)? | (20\\.("
            },
            {
                "text": " \n(?:\\d{2})(?:\\.\\d{2})?(?:\\.\\d{2})?(?:\\d"
            },
            {
                "text": "\n^(0[1-9]|1[012])\\/(0[1-9]|[12][0-9]|3["
            }
        ]
    },
    {
        "expression": "((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2}",
        "raw_prompt": "Deisgned to verify a MAC address with hex values seperated by a colon.",
        "refined_prompt": "Deisgned to verify a MAC address with hex values seperated by a colon.\nMatch examples:\n- \"00:00:39:F9:3C:59\"\n- \"00:90:83:6A:B3:B7\"\n- \"00:00:39:59:30:5C\"\nNon-match examples:\n- \"00:0H:39:59:30:5C\"\n- \"00:39:59:30:5C\"",
        "matches": [
            "00:00:39:F9:3C:59",
            "00:90:83:6A:B3:B7",
            "00:00:39:59:30:5C",
            "67:8e:69:8b:eA:eE",
            "5e:0F:de:2A:da:Fc",
            "47:8B:36:96:23:d1",
            "5d:b0:b9:F1:Ca:DB",
            "79:C6:A5:Dc:d7:fe",
            "9D:f0:d4:D3:43:c9",
            "55:eA:A7:5D:3F:0B",
            "aD:8B:7d:d2:76:04",
            "de:1A:f9:9c:D8:93",
            "A5:4c:81:b8:A0:73"
        ],
        "non_matches": [
            "00:0H:39:59:30:5C",
            "00:39:59:30:5C",
            "00:39:59:30:5C:BZ",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "AAAAAAA",
            "12f3.21f3.213f",
            "u09nKLJG FSL",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 755,
        "output": [
            {
                "text": " (00[0"
            },
            {
                "text": " (00:)("
            },
            {
                "text": " (00:(00"
            },
            {
                "text": "\n^[0"
            },
            {
                "text": " (00\\D"
            },
            {
                "text": " (00[0"
            },
            {
                "text": "\n^\\s"
            },
            {
                "text": " ^(?:["
            },
            {
                "text": "\n\n```"
            },
            {
                "text": " (?P<"
            }
        ]
    },
    {
        "expression": "^\\(0[1-9]{1}\\)[0-9]{8}$",
        "raw_prompt": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.",
        "refined_prompt": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09.\nMatch examples:\n- \"(02)12341234\"\n- \"(03)12341234\"\n- \"(05)12341234\"\nNon-match examples:\n- \"00 1234 1234\"\n- \"00-1234-1234\"",
        "matches": [
            "(02)12341234",
            "(03)12341234",
            "(05)12341234",
            "(01)86552606",
            "(07)90772257",
            "(07)17836526",
            "(01)92619887",
            "(02)62624649",
            "(09)68578246",
            "(05)94856935",
            "(04)66145018",
            "(08)53293252",
            "(07)35338722"
        ],
        "non_matches": [
            "00 1234 1234",
            "00-1234-1234",
            "(00)12341234",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "43-5432",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 766,
        "output": [
            {
                "text": "\n[0-9]{3}-[0-9]{3}-[0-9]{4}\n"
            },
            {
                "text": " \\([^\\s()]+\\)\n\n*Exercise 2:*\nWhat is the difference between a character set and"
            },
            {
                "text": " (^[01]\\d{2}\\-\\d{3}\\[\\d{1}\\]$)\n"
            },
            {
                "text": " [^\\s]*-?[0-9][^\\s]*\nThis will match any number of 0"
            },
            {
                "text": "\nThis is used to validate an Australian telephone number with area codes between 01 - 09.\nMatch examples:\n- \"(02"
            },
            {
                "text": ".*[0-9]{4}-.*\n- \"00-1234-1234\"\n- \""
            },
            {
                "text": " [a-z0-9]{5}-[0-9]{4}-[0-9]{3"
            },
            {
                "text": " 0[1-9]\\d\\d(\\.\\d{3})?\n\nI know the regular expression is"
            },
            {
                "text": "\n^\\((\\d{2})\\)\\s*(\\d{3})-(\\d{3})$\n"
            },
            {
                "text": " [01-9][0-9]{3}\n\nHints: \n- A character class like [01"
            }
        ]
    },
    {
        "expression": "^((\\s|[0])\\.(\\d{0,2}\\s{0,2}))?$|^(\\.(\\d\\s){0,2})?$|^(\\s{0,4}[1]{0,1}\\.[0]{0,2}\\s{0,4})?$|^(\\s{0,4}[1]{0,1}\\s{0,4})?$|^(\\s{0,4}[0]{0,4}[1]{0,1}\\s{0,4})?$|^([0]{0,4}\\s{0,4})?$|^(\\s{0,3}[0]{0,3}\\.{1}\\d{0,2}\\s{0,2})?$",
        "raw_prompt": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.\nAllows 1.0, 1.00, 1, 1., .9, .90, 0.90.",
        "refined_prompt": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.\nMatch examples:\n- \".99\"\n- \"1.\"\n- \"0.99\"\nNon-match examples:\n- \"10\"\n- \"0100\"",
        "matches": [
            ".99",
            "1.",
            "0.99",
            "0.98",
            "0.65",
            "0.45",
            "0.82",
            "0.97",
            "0.64",
            "0.31",
            "0.21",
            "0.53",
            "0.65"
        ],
        "non_matches": [
            "10",
            "0100",
            "1.01",
            "-123",
            "156",
            "4865",
            "85.489562",
            "4895",
            "383512.",
            "0.51234",
            "5613.12",
            "1523"
        ],
        "id": 772,
        "output": [
            {
                "text": " (.00+.00+)|(\\.00+$)|(0+$)|(\\.1+$)I hope this is enough to help you.\n\nA:\n"
            },
            {
                "text": " \n\n^[0-9]{1,4}\\.?[0-9]$\n\nA:\n\nYou don't want the. to be a"
            },
            {
                "text": " \"0|1|2|3|4|5|6|7|8|9\"\nGenerate a RegEx for this description.\nDescription: 0 < x"
            },
            {
                "text": " [0-9]\\d*[.\\d]\n\nMy answer (using the question posted above):\n/[0-9]\\d*[.\\"
            },
            {
                "text": " \n[\"1\" \".\" \"0\" \"1\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\""
            },
            {
                "text": "\n\\d+.\\d\n\nA:\n\n(?<=^|\\s )\\d+(?=\\ |$)\n\n\\d+ matches one"
            },
            {
                "text": " /^\\d+\\.\\d$/.\n\nHow to use: \nvar regexp = /^\\d+\\.\\d$/.test(\"10\");\n"
            },
            {
                "text": "\n[^\\d.]|\\b[0-9]\\d*\\.[0-9]\\d*\\b|\\b[0-9]\\"
            },
            {
                "text": " \"^(\\d{0,4})(\\.)(\\d{0,3})$\"\n\nExample:\n$re = '/(^\\d{1,"
            },
            {
                "text": ".{1,4}\n\n\n\nTitle: Exploring the World of Math: Time and Money\n\nIntroduction:\nWelcome to the exciting world of Math! In this"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z][a-zA-Z0-9_]+$",
        "raw_prompt": "Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character.\nWe use that to make sure the provided string can be a variable/entity name.",
        "refined_prompt": "Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character. We use that to make sure the provided string can be a variable/entity name.\nMatch examples:\n- \"MyVariable\"\n- \"intWhatever\"\n- \"Blah_Blah\"\nNon-match examples:\n- \"1stVariable\"\n- \"654\"",
        "matches": [
            "MyVariable",
            "intWhatever",
            "Blah_Blah",
            "tfygh",
            "tfygu7yug",
            "tfyg67tygt",
            "erdt67t",
            "io98uy",
            "er4ert",
            "tyh_56ty",
            "tfy76gty",
            "we3e",
            "q2w3e4r5t6y"
        ],
        "non_matches": [
            "1stVariable",
            "654",
            "_asdasd_234",
            "45edrtfc5rdt",
            "90uihyy",
            "_)I(U*IH",
            "_)I(HUBJ",
            "_)(UIH",
            "^&TGYVH_^FTY",
            "#W$EDR",
            "54RFTGVNKJML",
            "&GYH"
        ],
        "id": 775,
        "output": [
            {
                "text": " [a-zA-Z0-9_]{1,31}\n\"\"\"\n\ndef validate_name(name"
            },
            {
                "text": " \"^[a-zA-Z0-9_]+$\"\n\n```python\nimport re\n\ndef"
            },
            {
                "text": " Regex: (?i)[A-Za-z0-9_]*\n\nSolution:\nimport re\n"
            },
            {
                "text": " \"\\d+\"\n\n2. Find all matches for the provided regular expression and print them to the console.\n- Example string"
            },
            {
                "text": " \n- ^[a-zA-Z][a-zA-Z0-9_]*$\n-"
            },
            {
                "text": " /^[a-zA-Z0-9_]+$/\n\n**Part 3: Creating a simple Reg"
            },
            {
                "text": " [a-zA-Z0-9_]{0,40}\n\nExercise 3:\nValidate that"
            },
            {
                "text": " /^[a-zA-Z0-9_]*$/\n\nLecture Script for Subsection"
            },
            {
                "text": " [a-zA-Z0-9_]{1,100}\n\n```python\nname = input(\""
            },
            {
                "text": " \"_[A-Za-z0-9]*\"\n```python\nimport re\n\n# Define a"
            }
        ]
    },
    {
        "expression": "((([7-9])(\\d{3})([-])(\\d{4}))|(([7-9])(\\d{7})))",
        "raw_prompt": "Express&#227;o para a Valida&#231;&#227;o de Telefones Celulares sem o DDD valida celulares com inicio igual a 7,8 e 9.",
        "refined_prompt": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"",
        "matches": [
            "9999-9595",
            "88888787",
            "7777-6589",
            "7189-9372",
            "81166314",
            "74505791",
            "9866-2913",
            "8156-1727",
            "7556-6919",
            "72658873",
            "97176270",
            "98971523",
            "85785684"
        ],
        "non_matches": [
            "44445555",
            "2222-9658",
            "22223658",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 778,
        "output": [
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            },
            {
                "text": "This regex pattern is designed to match phone numbers that start with digits 7, 8, or 9, followed by either a hyphen-separated format (e.g., \"777-1234\") or a continuous format (e.g., \"7771234567\"). It won't match phone numbers with other leading digits or phone numbers that don't conform to this specific pattern.\nMatch examples:\n- \"9999-9595\"\n- \"88888787\"\n- \"7777-6589\"\nNon-match examples:\n- \"44445555\"\n- \"2222-9658\"\n"
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F])*$",
        "raw_prompt": "Expression validating a hex string of any length.",
        "refined_prompt": "Expression validating a hex string of any length.\nMatch examples:\n- \"1E3\"\n- \"82E5AAA4\"\n- \"01ff\"\nNon-match examples:\n- \"1g3\"\n- \"4Z\"",
        "matches": [
            "1E3",
            "82E5AAA4",
            "01ff",
            "8456",
            "89456",
            "89456A",
            "56489",
            "65AF",
            "6513846F",
            "5613BC",
            "6456F8465",
            "8465A465",
            "8465BCD"
        ],
        "non_matches": [
            "1g3",
            "4Z",
            "01x",
            "y78u",
            "gyu78gyu",
            "ftye1wqd",
            "67fty",
            "7d6ty4sdr",
            "s4er5dt7gyu9hivyu",
            "ft7y",
            "67ycu",
            "67cytu"
        ],
        "id": 782,
        "output": [
            {
                "text": " ^(?<![\\d])[0-9a-fA-F]{1,4}$\n\nExercise 3:\nMatch examples:\n- \"1234\"\n- \"1E3\"\n- \"82E5AAA4\"\n"
            },
            {
                "text": " \".*[a-zA-Z0-9].*\"\n```python\nimport re\nre.findall(r'.*[a-zA-Z0-9].*', '3g3')\n```\n\n2. Use re."
            },
            {
                "text": " \\d[\\da-fA-F]{2}\n- \"A4\"Generate a RegEx for this description. \nAnswer: [A-F]\\d{4}\n- \"8A\"Generate a RegEx for this description. "
            },
            {
                "text": " ^[0-9A-Fa-f]+$\n\n2. Check if a string contains only the following characters: a-z, A-Z, 0-9, _, \\s\n\n# Solution\n\npattern = re.compile(\"^[a-"
            },
            {
                "text": " /^[0-9A-Fa-f]{4}$/\n\nExercise 3: \n\nCreate a regex for validating an email address (username + domain). \n\nAnswer: /^[a-z0-9_\\-\\.]+"
            },
            {
                "text": " ^(?:[0-9a-fA-F]{1,6})(?:\\.(?:[0-9a-fA-F]{1,6}))*$\n- (?=.*[0-9]).{10}$\n"
            },
            {
                "text": " ^[0-9a-fA-F][0-9a-fA-F]{0,6}$\n- \"1g3^$\"Generate a RegEx for this description.\nAnswer: ^[0-9a-fA-"
            },
            {
                "text": " ^0|1[0-9a-fA-F]{6,}$\n- \"1g3\"Generate a RegEx for this description. \nAnswer: ^0?[1-9a-fA-F]{6,}$"
            },
            {
                "text": " [0-9A-Fa-f]{10}\n\n3. Write a code snippet that validates a password for a social security number. Valid passwords should meet the following criteria:\n- 6 unique characters.\n- At least one digit.\n- At least one u"
            },
            {
                "text": "\n^([a-fA-F0-9]{1,8}|[0-9]{1,2}.)+$\nExplanation: The ^ and $ match the start and end of the string respectively. The + quantifier means \"one or"
            }
        ]
    },
    {
        "expression": "(?=^.{6,255}$)((?=.*\\d)(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[^A-Za-z0-9])(?=.*[a-z])|(?=.*[^A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z])|(?=.*\\d)(?=.*[A-Z])(?=.*[^A-Za-z0-9]))^.*",
        "raw_prompt": "THE Complex Password Filter Matching 3 of 4 Character catagories:\n1.) at least 1 upper case character\n2.) at least 1 lower case character\n3.) at least 1 numerical character\n4.) at least 1 special character\nIt also enforces a min and max length and works for .Net and script Regex implimentations.",
        "refined_prompt": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for .Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"",
        "matches": [
            "Passw0rd",
            "assW@rd",
            "1B2a345@#$%",
            "^TVYGUt7yu(*",
            "GHUFDhu76^&",
            "67ftyv^%FTY",
            "56rfty&^GYU",
            "90ijioU(*IJO",
            "S#EWfsdff23f32",
            "3W$ES23d",
            "E$R%$Rtyfvf67",
            ")(IJO0ijo",
            "*&GUY8gui87g"
        ],
        "non_matches": [
            "123123123",
            "Password",
            "asdf&amp;",
            "dfiush",
            "IJBUIU*&*(",
            "F^&YGUF^%T&F^",
            "&^FGYU",
            "%F^RT*(",
            "8y9H",
            "F&^",
            "TV&",
            "vYT&"
        ],
        "id": 783,
        "output": [
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a password"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a strong"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a randomly"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a new"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a password"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a random"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a unique"
            },
            {
                "text": "THE Complex Password Filter Matching 3 of 4 Character catagories:\r\n1.) at least 1 upper case character\r\n2.) at least 1 lower case character\r\n3.) at least 1 numerical character\r\n4.) at least 1 special character\r\nIt also enforces a min and max length and works for.Net and script Regex implimentations.\nMatch examples:\n- \"Passw0rd\"\n- \"assW@rd\"\n- \"1B2a345@#$%\"\nNon-match examples:\n- \"123123123\"\n- \"Password\"Generate a strong"
            }
        ]
    },
    {
        "expression": "^[9]9\\d{10}|^[5]\\d{10}",
        "raw_prompt": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.",
        "refined_prompt": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"",
        "matches": [
            "991234567890",
            "51234567890",
            "57960452339",
            "55830345500",
            "998834347341",
            "50284016262",
            "991942628729",
            "992933733018",
            "998061531148",
            "56537583637",
            "59768489509",
            "998085897972",
            "56839621590"
        ],
        "non_matches": [
            "99123456789",
            "91234567890",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "AAAAAAA",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 787,
        "output": [
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description. It"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description. Should"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description.\n"
            },
            {
                "text": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11.\nMatch examples:\n- \"991234567890\"\n- \"51234567890\"\n- \"57960452339\"\nNon-match examples:\n- \"99123456789\"\n- \"91234567890\"Generate a RegEx for this description. The"
            }
        ]
    },
    {
        "expression": "^([a-zA-z\\s]{4,32})$",
        "raw_prompt": "This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) &amp; should be of minimum length 4 &amp; maximum length 32. Only white spaces are allowed apart from alphabets.",
        "refined_prompt": "This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) &amp; should be of minimum length 4 &amp; maximum length 32. Only white spaces are allowed apart from alphabets.\nMatch examples:\n- \"some body\"\n- \"hey there\"\n- \"hello\"\nNon-match examples:\n- \"hi\"\n- \"hey 27\"",
        "matches": [
            "some body",
            "hey there",
            "hello",
            "fsad fdsi",
            "uihf fsui",
            "hiufss",
            "uihbfsud",
            "hui buib",
            "vuiv biu",
            "biu bhivu",
            "buiv shdjfu",
            "bufisd uifbds",
            "buif sbdfiu"
        ],
        "non_matches": [
            "hi",
            "hey 27",
            "hell?",
            "78gyuhui",
            "sfalijad234",
            "43.v234",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "aa"
        ],
        "id": 797,
        "output": [
            {
                "text": " ^[a-zA-Z ]{4,32}$\n\nExercise 2:\n"
            },
            {
                "text": " \n(?=.{4,32})[a-zA-Z ]+\\b"
            },
            {
                "text": " ^\\b[A-Z][a-zA-Z0-9]{3,32"
            },
            {
                "text": "  /^[a-zA-Z]{4,32}$/\n\n[\\"
            },
            {
                "text": " ^[a-zA-Z][a-zA-Z 0-9\\-\\_ ]"
            },
            {
                "text": "\n/^(?=.{4,32}$)(?:[a-zA-Z"
            },
            {
                "text": " \n[a-zA-Z0-9]{4,32}\n\nExercise"
            },
            {
                "text": " The RegEx is ^[A-Za-z]{4,32}$\n\nEx"
            },
            {
                "text": " [A-Za-z][A-Za-z0-9]{1,32"
            },
            {
                "text": " [a-zA-Z\\s]{4,32}\n\nExercise 3:\n"
            }
        ]
    },
    {
        "expression": "^(^(([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){5}::[0-9A-F]{1,4})|((:[0-9A-F]{1,4}){4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){3}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|(:[0-9A-F]{1,4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,5})|(:[0-9A-F]{1,4}){7}))$|^(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,6})$)|^::$)|^((([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){3}::([0-9A-F]{1,4}){1})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){1}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|((:[0-9A-F]{1,4}){0,5})))|([:]{2}[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})):|::)((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})\\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})$$",
        "raw_prompt": "Matches all IPv6 text representations as defined within RFC 2373. Fairly verbose",
        "refined_prompt": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654:3210:1234\"",
        "matches": [
            "::0:0:0:FFFF:129.144.52.38",
            "FEDC:BA98::3210:FEDC:BA98:7654:3210",
            "::13.1.68.3",
            "D164::D:5F:E663:12.254.254.227",
            "898:2:B4D:EB:114:9:0CE6:C04",
            "A052:A4:B877::0192:5:255.224.081.254",
            "::A90:9B:82:241.248.202.200",
            "::251.212.205.02",
            "::252.220.0.129",
            "::212.208..5",
            "::6FEE:B8F:6:2F",
            "::26:226.208.242.253",
            "::252.223.225.255"
        ],
        "non_matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234",
            "3210:FEDC:BA98:7654:3210:1234",
            ":FEDC:BA98:7654:3210:",
            "D164::D:5F:E663:12.254.254.227fsda",
            "fsdaf898:2:B4D:EB:114:9:0CE6:C04",
            "afdsA052:A4:B877::0192:5:255.224.081.254",
            "f2ed::A90:9B:82:241.248.202.200",
            "f3we::251.212.205.02",
            "fads::6FEE:B8F:6:2F",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 799,
        "output": [
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            },
            {
                "text": "Matches all IPv6 text representations as defined within RFC 2373.\nMatch examples:\n- \"::0:0:0:FFFF:129.144.52.38\"\n- \"FEDC:BA98::3210:FEDC:BA98:7654:3210\"\n- \"::13.1.68.3\"\nNon-match examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234\"\n- \"3210:FEDC:BA98:7654"
            }
        ]
    },
    {
        "expression": "^([0-9]{3,4})$",
        "raw_prompt": "Allows you to check the length of a number (in this case either 3 or 4 digits).\nI found it useful when validating Credit Card Identification Codes (CVV2/CVC2/CID) which are either 3 or 4 numerical digits.",
        "refined_prompt": "Allows you to check the length of a number (in this case either 3 or 4 digits).\nMatch examples:\n- \"123\"\n- \"1234\"\n- \"456\"\nNon-match examples:\n- \"12\"\n- \"12345\"",
        "matches": [
            "123",
            "1234",
            "456",
            "4561",
            "678",
            "753",
            "789",
            "156",
            "213",
            "546",
            "789",
            "1564",
            "4856"
        ],
        "non_matches": [
            "12",
            "12345",
            "15",
            "97",
            "4",
            "6",
            "8",
            "89456123",
            "489561",
            "4856f23",
            "fe23",
            "5r6f"
        ],
        "id": 801,
        "output": [
            {
                "text": " ^\\d{3}\\d{3}\\d{3}$\n\nExercise 3:\nWrite a RegEx to extract all the email addresses from a text.\n\nExercise 4:\nWrite a RegEx to extract all the phone numbers from a text.\n\n"
            },
            {
                "text": "  [^\\d]*\n\nExercise 2: Write a RegEx to match only letters.\nAnswer: [a-zA-Z]\n\nExercise 3: Write a RegEx to match a series of characters that are not whitespace.\nAnswer: ["
            },
            {
                "text": "\n\"^(?!^\\s*\\d+$)(?!^(?:\\d\\s*){2,}\\d+$)(?!^\\s*\\d{3,}\\s*$)(?!^\\s*\\d{4,}\\s*"
            },
            {
                "text": " {len} is not in the right place. You should use {3} instead of {len}.\n- \"12a\"\n- \"12345\"Generate a RegEx for this description.\nAnswer: You can't use the right side of quantifier (the first one"
            },
            {
                "text": " \n[0-9]{3,}\n\n5. Create a RegEx for the pattern of a phone number (in this case, 10 digits with at least 1-2 different phone numbers per line)\nMatch examples:\n- \"1234567890\"\n-"
            },
            {
                "text": " You can use the pattern [0-9]{1,4} to match any length of number between 1 and 4 digits.\n\nStudent Question:\n\nHi everyone, I'm currently taking a course on Python and its packages, and I'm struggling with the Regular Expression Patterns"
            },
            {
                "text": " /^([0-9]{3})([0-9]{3}){2}$/\n\nExercise 3: Match Examples\n- Create a RegEx that matches the following words: dog, cat, fish, bird.\nAnswer: /dog|cat"
            },
            {
                "text": " [0-9]{3,4}\n\n    Learning Journal:\n\n11.3.9 How to use the $ and * to match the end of the string (explained the concept with details python implementation)\n\nToday's topic was all about learning to use"
            },
            {
                "text": " ^\\d{3,4}$\n\nExercise 3:\nWrite a Python RegEx to match any string of 4 or more characters containing at least one uppercase letter.\n\nExample:\n\"HelloWorld\"\nMatch example: \"HelloWorld\"\nMatch example"
            },
            {
                "text": " r'^\\d{3}$|^\\d{4}$'\n\nPart 3: Real-World Use Cases\n\nUse Case 1: Online Shopping\n\nAlien: How can RegEx help me with online shopping?\nHuman: RegEx can be used to"
            }
        ]
    },
    {
        "expression": "^([a-zA-z\\s]{2,})$",
        "raw_prompt": "This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires atleast 2 characters &amp; there's no limit on maximum number of characters.",
        "refined_prompt": "This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires at least 2 characters &amp; there's no limit on maximum number of characters.\nMatch examples:\n- \"Amit Gupta\"\n- \"Some Body\"\n- \"hello world\"\nNon-match examples:\n- \"A\"\n- \"Someplace23\"",
        "matches": [
            "Amit Gupta",
            "Some Body",
            "hello world",
            "test test",
            "ABC DEF",
            "jfiosd fsjdi",
            "jfiods fnsui",
            "iuyw urhwe",
            "uihd huifhs",
            "ihuf uhfd",
            "jiofs hyq",
            "poip fsd",
            "ruwe fsda"
        ],
        "non_matches": [
            "A",
            "Someplace23",
            "New-Jersey",
            "fewd23",
            "f23edg4rgggg32",
            "g5r42ef",
            "u9i9",
            "t76",
            "0u9",
            "g78hg8D%R",
            "5dRT",
            "%$DRT"
        ],
        "id": 803,
        "output": [
            {
                "text": " (?i)\\b\\w{2,}(?=\\s|$)\\b \n\nFor further information Go to https://www"
            },
            {
                "text": " Non-match examples should match only alphanumerical characters, white-spaces, and '.'\n\n``` python\nimport re\n\n"
            },
            {
                "text": " (?i)(?=\\S*\\w)(?=\\s*\\w*\\S*\\w*\\S*\\w"
            },
            {
                "text": " Generate a RegEx for this description.\n\nHere is the code for the answer: \n[A-Z][a-z] ["
            },
            {
                "text": " Generate the RegEx for validating Names, Cities, States, Countries with at least 2 characters & space only. \n\n5. Given a"
            },
            {
                "text": " \"[A-Za-z ]+\"\n\n2. Write a Python function using RegEx that will search for emails in a given string."
            },
            {
                "text": " ^[a-zA-Z ]*$\n\n[1] I have used the below pattern for matching only letters with optional spaces between them"
            },
            {
                "text": "\n^.{2,}$\n\nThe [A-Za-z] will match all the alphabets. The first two"
            },
            {
                "text": "\n[A-z0-9]+(\\s[A-z0-9]+)*\n\n[A-Z0-9]"
            },
            {
                "text": "\nNon-match examples: \n\"(?<!\\w\\s)(?!\\w)\"\nThis is a simple regex which will ensure that"
            }
        ]
    },
    {
        "expression": "^\\+?972(\\-)?0?[23489]{1}(\\-)?[^0\\D]{1}\\d{6}$",
        "raw_prompt": "Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)",
        "refined_prompt": "Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)\nMatch examples:\n- \"+972-4-8253055\"\n- \"972-4-8615466\"\n- \"972-04-8564521\"\nNon-match examples:\n- \"04-5487665\"\n- \"05-455665545\"",
        "matches": [
            "+972-4-8253055",
            "972-4-8615466",
            "972-04-8564521",
            "+972-86842905",
            "+972-3-8441944",
            "972-046893540",
            "972-04-3970699",
            "972-04-3970699",
            "97242897572",
            "972-037549881",
            "972-09-6346942",
            "+97242897402",
            "972-022722133"
        ],
        "non_matches": [
            "04-5487665",
            "05-455665545",
            "456884624",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "43-5432",
            "12f3.21f3.213f",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "0j0jweBBBB"
        ],
        "id": 804,
        "output": [
            {
                "text": " [+0"
            },
            {
                "text": "\n\n"
            },
            {
                "text": " \n"
            },
            {
                "text": "\n^"
            },
            {
                "text": "\n^"
            },
            {
                "text": " +94"
            },
            {
                "text": " [A"
            },
            {
                "text": " \"^"
            },
            {
                "text": " \\b"
            },
            {
                "text": " \n"
            }
        ]
    },
    {
        "expression": "^((0?[1-9]|1[012])(:[0-5]\\d){1,2}(\\ [AaPp][Mm]))$",
        "raw_prompt": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.",
        "refined_prompt": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required.\nMatch examples:\n- \"1:45 am\"\n- \"12:01 aM\"\n- \"01:23 pm\"\nNon-match examples:\n- \"13:34 am\"\n- \"1:60 am\"",
        "matches": [
            "1:45 am",
            "12:01 aM",
            "01:23 pm",
            "11:59 pm",
            "04:28 pM",
            "08:00 Am",
            "04:32 pm",
            "03:06 Am",
            "11:28:59 Pm",
            "11:51 Pm",
            "8:20 am",
            "06:53:59 Am",
            "1:13 aM"
        ],
        "non_matches": [
            "13:34 am",
            "1:60 am",
            "13:45",
            "12/123/4322 PM",
            "51:534",
            "43.v2344 PM",
            "89:569",
            "48:97 PM",
            "65:23 pm",
            "1-1-2 am",
            "(0xx12) 62509",
            "32542 am"
        ],
        "id": 805,
        "output": [
            {
                "text": " \n\\d\\s*:\\s\\d\\s*[a-zA-Z]\\w*[a"
            },
            {
                "text": "\n^\\d\\s\\d?:\\s\\d?\\d:?$\n\nExercise 5:\nGiven"
            },
            {
                "text": " \\d{2}(am|PM)\\s*:\\s*(0\\d{2}|1\\d{"
            },
            {
                "text": "\n1. ^[0-9]* [AP]-?[0-9]*:[0-9]?["
            },
            {
                "text": " The pattern would be something like this. \n\n```python\nimport re\n\ndef validate_time(time: str"
            },
            {
                "text": " \"1[0-9]:[0-9] am|[0-9]:[0-9] am [0"
            },
            {
                "text": " \n(?<!am|pm)(1:([0-5]\\\\d|6|7)( |:)("
            },
            {
                "text": " Match any time between 1:00 a.m. and 11:59 a.m.\n\n    9.1."
            },
            {
                "text": "\n\n``` python\nimport re\n\ndef find_time(time):\n    # find the number of hours and minutes"
            },
            {
                "text": " Match any number of hours, minutes and/or seconds (hours, minutes or seconds, minutes or seconds) but no more than 23"
            }
        ]
    },
    {
        "expression": "^\\d{5}((-|\\s)?\\d{4})?$",
        "raw_prompt": "Single field zip code validator, useful for Web Forms. Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.",
        "refined_prompt": "Single field zip code validator, useful for Web Forms. Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits.\nMatch examples:\n- \"92078-4705\"\n- \"920784705\"\n- \"92078 4705\"\nNon-match examples:\n- \"9027x\"\n- \"902\"",
        "matches": [
            "92078-4705",
            "920784705",
            "92078 4705",
            "22393",
            "54968",
            "85050",
            "99350-8649",
            "79787-1343",
            "87163-0442",
            "88206-1513",
            "31360-8551",
            "363700404",
            "22774",
            "22393",
            "54968",
            "85050",
            "99350-8649",
            "79787-1343",
            "87163-0442",
            "88206-1513",
            "31360-8551",
            "363700404",
            "22774"
        ],
        "non_matches": [
            "9027x",
            "902",
            "92078.4705",
            "12/123/4322",
            "51:534",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90",
            "12/123/4322",
            "51:534",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 814,
        "output": [
            {
                "text": " [\\d-]{5}\n\nHost 1: Now that we've covered some basic concepts of regular expressions and zip"
            },
            {
                "text": " \n\nimport re\n\ndef validate_zip(zip_code):\n    if \"-\" in zip_code:"
            },
            {
                "text": "\nThis is a field for zip code validation. Use a regular expression to ensure that the user enters a 5-digit or 5"
            },
            {
                "text": ".*\\d{4}-\\d{3}.*\n\nPython code:\nimport re\n\nzip_"
            },
            {
                "text": " [0-9]{4}-[0-9]{4}[0-9]{4}|["
            },
            {
                "text": " (\\d{5}\\-?\\d{4})$\n\n3. Write a function that takes in a phone"
            },
            {
                "text": " (^\\d{4}\\-\\d{3}\\-\\d{3}\\d$)(?<!\\"
            },
            {
                "text": "\na) (?:^\\s*\\d{5}(?:-|\\s){3}\\d{4"
            },
            {
                "text": " \"^[0-9]{5}([0-9]{4})?$\"\n\n7. Write"
            },
            {
                "text": " ([a-zA-Z-]{1})[0-9]{4}|([0-9]"
            }
        ]
    },
    {
        "expression": "^\\d{5}((\\-|\\s)?\\d{4})?$",
        "raw_prompt": "Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits.",
        "refined_prompt": "Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits.\nMatch examples:\n- \"92078\"\n- \"92078-4705\"\n- \"92078 4705\"\nNon-match examples:\n- \"920781\"\n- \"920a87\"",
        "matches": [
            "92078",
            "92078-4705",
            "92078 4705",
            "264455497",
            "131416218",
            "99746",
            "054229695",
            "664133458",
            "09864",
            "899195591",
            "56954",
            "58489",
            "89987"
        ],
        "non_matches": [
            "920781",
            "920a87",
            "920",
            "1965189",
            "849561",
            "845168",
            "489698",
            "4821",
            "9516-9516",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 815,
        "output": [
            {
                "text": " ^[0-9]{3}-[0-9]{4}\n\n\n\nQuestion 7: A"
            },
            {
                "text": " (?<!-)^\\d{5}(?:-| )\\d{4}$|^\\"
            },
            {
                "text": "\nimport re\npattern = r\"(\\d{5})-(\\d{4})\"\n# Explanation:"
            },
            {
                "text": "\n[0-9]{5}[A-Z]{1}[0-9]{2}"
            },
            {
                "text": " [01-9]{5} [0-9]{4}\nExercise 2: \nCreate a"
            },
            {
                "text": " [0]{5}\\s\\d{4}[\\s]{1}\n\nExercise 2:"
            },
            {
                "text": " RegEx: [0-9]{5}[ -][0-9]{4}\n\n1."
            },
            {
                "text": "\n\\d{5}(?:-\\d{4})?|\\d{4}(?:-\\"
            },
            {
                "text": "\n- r'^\\d{4}-\\d{3}-\\d{3}$'\n"
            },
            {
                "text": " ^0-9 \\d{5} \\d{4}$\n\nExercise 3:\nCreate a Reg"
            }
        ]
    },
    {
        "expression": "[1-2][0|9][0-9]{2}[0-1][0-9][0-3][0-9][-][0-9]{4}",
        "raw_prompt": "Swedish person number. Don't work on persons older then 100 years, but they are so few that it shouldn't be a problem. Easy to fix, but I choose not to accept oldies...",
        "refined_prompt": "Swedish person number.\nMatch examples:\n- \"19740609-7845\"\n- \"19811116-7845\"\n- \"20010913-7598\"\nNon-match examples:\n- \"21003612-9999\"\n- \"18790505-4545\"",
        "matches": [
            "19740609-7845",
            "19811116-7845",
            "20010913-7598",
            "20560634-8465",
            "10291017-1578",
            "19631222-3119",
            "29561336-3749",
            "10081438-9776",
            "10131537-6611",
            "20831709-9312",
            "20031727-7466",
            "20501922-6283",
            "20081625-4758"
        ],
        "non_matches": [
            "21003612-9999",
            "18790505-4545",
            "19740641-5559",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "4515-516",
            "49156-984516",
            "489561-98456",
            "-4516-561",
            "98465-8456",
            "8945623-984561"
        ],
        "id": 817,
        "output": [
            {
                "text": "\n\n# Solution to Exercise 2\npattern = r\"\\d{4}-\\d{2}-\\d{2}\"\n\nprint(pattern.search(\"2021-10-12\"))\n# Returns <"
            },
            {
                "text": "\n(19[0-9]{6})-(19[0-9]{6})\n\nExercise 2:\nFind the number of strings that match the following RegEx pattern.\nExample:\n- \""
            },
            {
                "text": " (\\d{4}-)(\\d{2}-)\\d{2}\n\nExercise 2: Use the above RegEx to extract the number of days from the following string: \"Today is 09/11/"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{4}\n\nExercise 2: Searching for a pattern\nSearch for all the matches of a pattern in a string. The pattern can be a string or"
            },
            {
                "text": " The pattern should be '^[0-9]{4}-[0-9]{4}-[0-9]{4}$'\n\n5. Create a regular expression to search for an email address in the"
            },
            {
                "text": " ([0-9]*)-([0-9]+)\n\n4. Give an example of a real-life situation where you would need to use RegEx.\nAnswer: One example could be when searching for a specific word"
            },
            {
                "text": " [a-zA-Z0-9]{6,13}\n\n4. Identify the correct character class(es) to use in the following regular expression. \nDescription: A string should contain only letters,"
            },
            {
                "text": "\n```python\nregex = r\"\\d{4}-\\d{2}-\\d{2}\"\nprint(regex) \n``` \n\n3. Write a python script that takes"
            },
            {
                "text": " (at least) \"^[0-9]{2}-[0-9]{4}$\"\n\nExercise 2:\n- \"98765432-9999\"\n- \"99888888-55"
            },
            {
                "text": "\nThe RegEx pattern for this description is \"^(\\d{4}-\\d{2}-\\d{2}-\\d{2}-\\d{1,2})-(\\d{1"
            }
        ]
    },
    {
        "expression": "^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$",
        "raw_prompt": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\n(rizzipereira.com.br)\nFor Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250",
        "refined_prompt": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"",
        "matches": [
            "10.03.1979",
            "12/30/2004",
            "01/01/2004",
            "07/6.84",
            "10/03-3505",
            "12-28/37",
            "09-8-07",
            "9.30-9000",
            "6/02-7535",
            "12.09/74",
            "10-2-6908",
            "11.2.32",
            "10-31-77"
        ],
        "non_matches": [
            "09--02--2004",
            "15-15-2004",
            "13/12/2004",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 822,
        "output": [
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer:.(1-2"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: \\d\\d\\"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: \n\\d{"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: (0..1),"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: (\\d{1"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: \\d\\d?"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer:\n(?=\\"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: \n^\\d"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: \\d{1,"
            },
            {
                "text": "Validate American date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators:. - /\r\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\nMatch examples:\n- \"10.03.1979\"\n- \"12/30/2004\"\n- \"01/01/2004\"\nNon-match examples:\n- \"09--02--2004\"\n- \"15-15-2004\"Generate a RegEx for this description. \nAnswer: /[0-9"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$",
        "raw_prompt": "Matches the date format &quot;YYYY-mm-dd&quot; and also validates month and number of days in a month. All leap year dates &quot;YYYY-02-29&quot; passes trough. Could easily be changed to another format.",
        "refined_prompt": "Matches the date format &quot;YYYY-mm-dd&quot; and also validates month and number of days in a month. All leap year dates &quot;YYYY-02-29&quot; passes trough.\nMatch examples:\n- \"2004-04-30\"\n- \"2004-02-29\"\n- \"4214-06-30\"\nNon-match examples:\n- \"2004-04-31\"\n- \"2004-02-30\"",
        "matches": [
            "2004-04-30",
            "2004-02-29",
            "4214-06-30",
            "2509-01-30",
            "0881-02-29",
            "7644-02-08",
            "6740-10-04",
            "0519-05-01",
            "5214-08-21",
            "9459-09-30",
            "3512-09-17",
            "5617-02-01",
            "5381-11-30"
        ],
        "non_matches": [
            "2004-04-31",
            "2004-02-30",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 823,
        "output": [
            {
                "text": "\n(\\d{4}"
            },
            {
                "text": " \nRegex pattern:"
            },
            {
                "text": " ^(0[1-"
            },
            {
                "text": "\n\\d{4}"
            },
            {
                "text": " Valid (MM-DD)"
            },
            {
                "text": " [^0-9]"
            },
            {
                "text": " Match any date where the numbers"
            },
            {
                "text": "\nimport re\n\nre"
            },
            {
                "text": " I need to validate the date"
            },
            {
                "text": " (^(0[1"
            }
        ]
    },
    {
        "expression": "^((?:2[0-5]{2}|1\\d{2}|[1-9]\\d|[1-9])\\.(?:(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)\\.){2}(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)):(\\d|[1-9]\\d|[1-9]\\d{2,3}|[1-5]\\d{4}|6[0-4]\\d{3}|654\\d{2}|655[0-2]\\d|6553[0-5])$",
        "raw_prompt": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port. More to come, maybe :)",
        "refined_prompt": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port.\nMatch examples:\n- \"127.0.0.1:80\"\n- \"255.255.255.0:21\"\n- \"1.0.0.0:1\"\nNon-match examples:\n- \"0.0.0.0:1\"\n- \"256.1.1.1:20\"",
        "matches": [
            "127.0.0.1:80",
            "255.255.255.0:21",
            "1.0.0.0:1",
            "46.243.1.167:751",
            "160.154.243.9:4",
            "4.0.215.102:65513",
            "253.224.59.103:55",
            "143.127.244.222:62820",
            "253.110.9.6:62523",
            "65.220.200.196:55954",
            "31.172.165.185:7",
            "212.84.221.220:55",
            "67.233.1.202:736"
        ],
        "non_matches": [
            "0.0.0.0:1",
            "256.1.1.1:20",
            "127.0.0.1:65536",
            "12/123/4322",
            "123.456.789",
            "2/3/5235",
            "43-5432",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "abc111def",
            "12/132/90"
        ],
        "id": 827,
        "output": [
            {
                "text": " [A-Z0-9.]{1,3}\\.["
            },
            {
                "text": " \"^\\d{1,3}\\.\\d{1"
            },
            {
                "text": " [0-9]{1,3}.\\d{1"
            },
            {
                "text": " ip:port checker\n\nExercise 3: Write a Python"
            },
            {
                "text": " \\b[0-9]{1,3}\\.[0"
            },
            {
                "text": " (.*) - match any character, (.*) - match any"
            },
            {
                "text": "\n(?<ip>\\d{1,3}\\."
            },
            {
                "text": " (1 or more characters, then: \":\", then 2 digits"
            },
            {
                "text": " ^\\d{1,3}\\.\\d{1,"
            },
            {
                "text": " ^(.+?):\\d{1,3}$"
            }
        ]
    },
    {
        "expression": "^(9,)*([1-9]\\d{2}-?)*[1-9]\\d{2}-?\\d{4}$",
        "raw_prompt": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.",
        "refined_prompt": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"",
        "matches": [
            "9,5143393044",
            "9,514-339-3044",
            "339-3044",
            "489-8745",
            "485-8796",
            "489-8794",
            "823-4896",
            "879-8154",
            "846-8795",
            "812-9876",
            "213-4589",
            "321-6547",
            "987-6543"
        ],
        "non_matches": [
            "9,339 3044",
            "514 440 2009",
            "(514) 440-2009",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 831,
        "output": [
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx which"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx that"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx regex"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx that"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            },
            {
                "text": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out.\nMatch examples:\n- \"9,5143393044\"\n- \"9,514-339-3044\"\n- \"339-3044\"\nNon-match examples:\n- \"9,339 3044\"\n- \"514 440 2009\"Generate a RegEx to"
            }
        ]
    },
    {
        "expression": "^\\-?\\(?([0-9]{0,3}(\\,?[0-9]{3})*(\\.?[0-9]*))\\)?$",
        "raw_prompt": "Match a positive or negative decimal value with any precision and scale. Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number.",
        "refined_prompt": "Match a positive or negative decimal value with any precision and scale. Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number.\nMatch examples:\n- \"0.123\"\n- \"(1234.123)\"\n- \"-01,200\"\nNon-match examples:\n- \"2.3.123\"\n- \"1,23.45\"",
        "matches": [
            "0.123",
            "(1234.123)",
            "-01,200",
            "516",
            "548",
            "864",
            "456",
            "846.465",
            "4856.65",
            "516.156",
            "-489.51",
            "-789.1254",
            "-489.21"
        ],
        "non_matches": [
            "2.3.123",
            "1,23.45",
            "90438502+9503",
            "12/123/4322",
            "51:534",
            "$23.454",
            "/5/5/5",
            "12f3.21f3.213f",
            "324df",
            "1-1-2",
            "(0xx12) 62509",
            "++63453.345"
        ],
        "id": 833,
        "output": [
            {
                "text": " ^[\\d,]+\\.[0-9,]$\n\n    TA: Good afternoon,"
            },
            {
                "text": " [0-9]\\.[0-9]{1,2}(,\\d{1,"
            },
            {
                "text": " (\\d+\\.)(\\d+)\n\nExercise 5: Write a Python program using RegEx to"
            },
            {
                "text": " (?:[1-9][0-9]*|100|101|102|103|104|"
            },
            {
                "text": " ([0-9]{1,2}.|[0-9]{3}.|[0-"
            },
            {
                "text": " [0-9.]{0,3}(,\\d{3})*\nExercise: Write"
            },
            {
                "text": " \n[0-9]\\.[0-9]*\n\nExercise 5:\n\nMatch"
            },
            {
                "text": " [decimal]{1,3}[,\\.][0-9]{3}\\.[0"
            },
            {
                "text": " \"(?<![0-9])(?:[0-9]+[.])?[0-9"
            },
            {
                "text": "\n(?<=^|,|\\.|\\(|\\))([0-9]+(\\"
            }
        ]
    },
    {
        "expression": "^([0-9]{5})([\\-]{1}[0-9]{4})?$",
        "raw_prompt": "Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format.",
        "refined_prompt": "Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format.\nMatch examples:\n- \"18017\"\n- \"18017-1401\"\n- \"21389-6392\"\nNon-match examples:\n- \"1801A\"\n- \"18017-\"",
        "matches": [
            "18017",
            "18017-1401",
            "21389-6392",
            "05777",
            "56923",
            "89326",
            "68059",
            "88774-1384",
            "32425-6779",
            "79483-3404",
            "89006-9511",
            "72142-2804",
            "16457-1675"
        ],
        "non_matches": [
            "1801A",
            "18017-",
            "18017-152A",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "489",
            "4985-489945",
            "56-4895",
            "495-94561",
            "-456-456",
            "9456-45961"
        ],
        "id": 836,
        "output": [
            {
                "text": " (18[0-9]\\d{0,2}).*\\d{0,3}\n\n2. Create a RegEx to validate against a U.S. zip code in a 5 digit"
            },
            {
                "text": " (^[0-9]{5}\\-[0-9]{4}$)|(^[0-9]{5}\\-[0-9]{5}-[0-9]{4"
            },
            {
                "text": " \"([1-9][0-9][0-9]|[1-9][0-9][0-9][-0-9])-([0-9][0-9][0-"
            },
            {
                "text": " [a-z]{1,5}-\\d{1,2}\n\nExercise 2: \nCreate a RegEx pattern to validate the format of a phone number. The pattern should meet the"
            },
            {
                "text": "\n[0-9][0-9][0-9][0-9][0-9] \n[0-9][0-9][0-9][0-9][0-9]"
            },
            {
                "text": " 18017-\\d{4}\n- \"1801-1401\"\n- \"213-89-\"Generate a RegEx for this description. \nAnswer: (?:\\d{3})-"
            },
            {
                "text": "\n^[0-9]{5}|[0-9]{5}-[0-9]{3}[0-9]{4}$\n\n3. Exercise: \nCreate"
            },
            {
                "text": " (This will vary)\n\n```python\nimport re\n\nreg_exp = re.compile(r'^[0-9]{5}[-0-9]{3}["
            },
            {
                "text": " (?i)(?=.*\\d)(?=.*[A-Za-z])(?=.*[-\\s])(?=.*[a-z]).{5}(?="
            },
            {
                "text": " 1801a - (?<![0-9])[0-9][-0-9] [0-9]\n- \"1801-0B2-2E9\"  Should be"
            }
        ]
    },
    {
        "expression": "^([4]{1})([0-9]{12,15})$",
        "raw_prompt": "Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers.",
        "refined_prompt": "Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers.\nMatch examples:\n- \"4125632152365\"\n- \"418563256985214\"\n- \"4125632569856321\"\nNon-match examples:\n- \"3125652365214\"\n- \"41256321256\"",
        "matches": [
            "4125632152365",
            "418563256985214",
            "4125632569856321",
            "49806754364673",
            "41491375454867",
            "485356860942812",
            "4770447906705036",
            "448396436324023",
            "45070682445907",
            "44783606756808",
            "40836531725759",
            "4792181214201",
            "4877924087087587"
        ],
        "non_matches": [
            "3125652365214",
            "41256321256",
            "42563985632156322",
            "314455704591712",
            "328340313647627",
            "3869294726381",
            "8473042249290",
            "8672009622132",
            "871986373693914",
            "893169175001042",
            "48156",
            "0j0jweBBBB"
        ],
        "id": 837,
        "output": [
            {
                "text": " [^0-9]([0-9]{1,5}[0-9]{1,5}[0-9]"
            },
            {
                "text": " RegEx: ^\\d{4}-\\d{12}\\d{1}$\n\n```python\n# Exercise 2\n#"
            },
            {
                "text": " ^[4]\\d{12,15}$\n\nI hope these exercises help you understand and practice generating regular expressions for different use cases."
            },
            {
                "text": "\n^\\D{4}\\D{12,15}\\D{3}$\n\nExample:\n```python\nimport re\n\n"
            },
            {
                "text": "\n```\n^\\d{4}[\\d]{12,15}$\n```\n\n### Exercise 4:\nWrite"
            },
            {
                "text": "\n\n```python\nimport re\n\ndef validate_visa_card(card):\n    pattern = re.compile(r'"
            },
            {
                "text": "\n\n```python\n# Example\nimport re\n\ndef validate_card(card_number):\n    pattern = r\"^[4"
            },
            {
                "text": "\nRegex:^[4]\\d{12,15}$\n\nExercise 3:\nWrite a Regular Expression that matches a phone"
            },
            {
                "text": " The regex should match anything that does not start with the \"4\" digit and must be followed by 15 digits.\n\nLecture Note:"
            },
            {
                "text": " \"^[4]\\d{3,14}$\"\n\nExercise 4: Create a RegEx for this description. The password must"
            }
        ]
    },
    {
        "expression": "^([51|52|53|54|55]{2})([0-9]{14})$",
        "raw_prompt": "Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers.",
        "refined_prompt": "Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers.\nMatch examples:\n- \"5125632154125412\"\n- \"5225632154125412\"\n- \"5525632154125412\"\nNon-match examples:\n- \"5625632154125412\"\n- \"4825632154125412\"",
        "matches": [
            "5125632154125412",
            "5225632154125412",
            "5525632154125412",
            "5112345678901234",
            "5212345678901234",
            "5312345678901234",
            "5412345678901234",
            "5512345678901234",
            "5200000000000000",
            "5500000000000000",
            "5234567890123456",
            "5443210987654321",
            "5522222222222222"
        ],
        "non_matches": [
            "5625632154125412",
            "4825632154125412",
            "6011632154125412",
            "5012345678901234",
            "5612345678901234",
            "52000000000000",
            "530000000000000",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 838,
        "output": [
            {
                "text": " ^51[0-9]{14}$\n\nExercise 3: Email Validation \nQuestion"
            },
            {
                "text": "  ^[51]+[52]\\d{14}$\n\n2. Write a Python script that"
            },
            {
                "text": " ^[0-5]{1,3}[0-9]{14}$ \n\n"
            },
            {
                "text": " (55[0-5]\\d{6}|52[0-5]\\d{4"
            },
            {
                "text": " [51-55][1-9][0-9]{14}\n- \"5525632154"
            },
            {
                "text": " \\b53[\\d]{1,14}\\b\n\n(9) Write a RegEx for"
            },
            {
                "text": " (Any string with the pattern of numbers from 51 to 55)\n- \"56432154125412"
            },
            {
                "text": " \"^\\d{5}[\\d]{14}$\".\n\nExercise 3: Rew"
            },
            {
                "text": " ([^1-4]|[5-9]|[1-5][0-9]{"
            },
            {
                "text": " 51[1-9][0-9]{13}|52[1-9][0-9"
            }
        ]
    },
    {
        "expression": "^(([A-Z]{1,2}[0-9]{1,2})|([A-Z]{1,2}[0-9][A-Z]))\\s?([0-9][A-Z]{2})$",
        "raw_prompt": "Matches UK postcodes of the below formats. The space is optional.\nAN NAA\nAAN NAA\nANN NAA\nANA NAA\nAANA NAA\nAANN NAA",
        "refined_prompt": "Matches UK postcodes of the below formats. The space is optional.\r\nAN NAA\r\nAAN NAA\r\nANN NAA\r\nANA NAA\r\nAANA NAA\r\nAANN NAA\nMatch examples:\n- \"A11AA\"\n- \"AA1A 1AA\"\n- \"AA11 1AA\"\nNon-match examples:\n- \"AAA 1AA\"\n- \"AA11A 1AA\"",
        "matches": [
            "A11AA",
            "AA1A 1AA",
            "AA11 1AA",
            "EC1A 1BB",
            "W1A 0AX",
            "M1 1AE",
            "B33 8TH",
            "CR2 6XH",
            "DN55 1PT",
            "SW1A 1AA",
            "GU16 7HF",
            "L2 2HQ",
            "G2 2BL"
        ],
        "non_matches": [
            "AAA 1AA",
            "AA11A 1AA",
            "AAA1AA",
            "Mastercard",
            "sfalijad234",
            "there is a boy",
            "@#dfkjnav",
            "12f3.21f3.213f",
            "qwerty@123.123",
            "adfa2",
            "abc111def",
            "0j0jweBBBB"
        ],
        "id": 844,
        "output": [
            {
                "text": " ^[A-Z]\\\\d{1}( [A-Z]"
            },
            {
                "text": " [A-Za-z0-9]{1,2}["
            },
            {
                "text": " \r\n[^A-za-z]{1}[A-"
            },
            {
                "text": " \n^A[A-Z]{1}\\d[A-Z"
            },
            {
                "text": " A(N|NAA)1A(N|NAA)1AA"
            },
            {
                "text": " [\\d\\s\\w\\s]{0,6}[A"
            },
            {
                "text": " ^[Aa][Na][Aa][Aa][Aa][A"
            },
            {
                "text": " (.*) - ([0-9])[0-9]*$\n"
            },
            {
                "text": " \n[Aa][Aa][Aa][Aa][Aa"
            },
            {
                "text": " \r\n(A[^A ]{1})([ ]{1"
            }
        ]
    },
    {
        "expression": "(\\S+)\\x20{2,}(?=\\S+)",
        "raw_prompt": "Trim Inside. This pattern can be used with a replace value of &quot;$1 &quot; to remove multiple consecutive spaces between characters and replace with a single space. Trailing and leading spaces are NOT altered.",
        "refined_prompt": "Trim inside a string by replacing multiple consecutive spaces between characters with a single space, without altering leading or trailing spaces.\nMatch examples:\n- \"Too  Many spaces.\"\n- \"hdfu   fhhu\"\n- \"bufy.  sd fuhi\"\nNon-match examples:\n- \"No extra spaces\"\n- \"No Extra spaces Inside\"",
        "matches": [
            "Too  Many spaces.",
            "hdfu   fhhu",
            "bufy.  sd fuhi",
            "usdfi.  siudhfi",
            "iowr89.  wefbui",
            "fdbuis.  sfbug78",
            "bfys f.  s.  sdbufb",
            "bshdbf.   fbsdib",
            "bhfye87g.   buiwe",
            "bfyeg.   hufew",
            "jif.  iubfwe",
            "uiirwe u ehw.    wiuhr",
            "huiher.    uiwhruiwr"
        ],
        "non_matches": [
            "No extra spaces",
            "No Extra spaces Inside",
            "34f2vf42e",
            "Mastercard",
            "2346-2345-2435",
            "$23.454",
            "@#dfkjnav",
            "98iojk",
            "qwerty@123.123",
            "adfa2",
            "34.31",
            "99999@gmail"
        ],
        "id": 848,
        "output": [
            {
                "text": " The RegEx can be \".*?[.,;\\s]*\".\nI don't know how to do this with a regex and python?\nI also tried doing"
            },
            {
                "text": "\n(?<!\\S)[a-z]{3}\\s[a-z]{3}\\s[a-z]{3}\n(?"
            },
            {
                "text": " No extra spaces\n\n### Subsection: Regular expressions and encryption\n\nRegular expressions can be used for encryption by using them to replace characters or sequences of characters. For example,"
            },
            {
                "text": " \\s{2,}\\s*\n```python\n# Ideas:\n# 1. To match a string with a pattern, use the `re.match()`"
            },
            {
                "text": " No extra spaces.\n\nExercise 2:\nWrite a Python program that accepts an email address from the user and prints all the characters that are not letters, numbers, or"
            },
            {
                "text": "\n\n```python\ntext = \"\"\"\nToo  Many spaces.\nhdfu   fhhu\nbufy.  sd fuhi\n\"\"\"\n\nre"
            },
            {
                "text": " \"(\\\\s+)+\"\n- \"No spaces\"\n- \"No spaces,  No spaces\"\nGenerate a RegEx for this description.\nAnswer: \""
            },
            {
                "text": "\n\nimport re\n\n#String to be trimmed\ntext = \"    Too  Many spaces.\"\n\n#Trimming of leading or trailing spaces\ntrimmed_"
            },
            {
                "text": "\n[^\\s]*\\s[^\\s]*\\s[^\\s]*\\s[^\\s]*\\s[^\\"
            },
            {
                "text": "\n\nimport re\nstring = \"Too      Many spaces.\\nhdfu   fhhu\\nbufy.  sd fuhi\"\nre.sub"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}((0[1-9])|(1[0-2]))$",
        "raw_prompt": "Match a string in CCYYMM/YYYYMM format.",
        "refined_prompt": "Match a string in CCYYMM/YYYYMM format.\nMatch examples:\n- \"200401\"\n- \"000001\"\n- \"200412\"\nNon-match examples:\n- \"aaa\"\n- \"20040123\"",
        "matches": [
            "200401",
            "000001",
            "200412",
            "080210",
            "709612",
            "692003",
            "299711",
            "848203",
            "298311",
            "325410",
            "093311",
            "392105",
            "525304"
        ],
        "non_matches": [
            "aaa",
            "20040123",
            "200414",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "AAAAAAA",
            "98iojk",
            "432/524/2435",
            "adfa2",
            "abc111def",
            "32542"
        ],
        "id": 851,
        "output": [
            {
                "text": " The RegEx would have to match any string in the year, month, and day format.\n\nExercise 3: \nCreate a RegEx that matches the following string:\n- \"The quick brown fox jumps over the lazy dog.\"\nAnswer: The RegEx would have to match any string"
            },
            {
                "text": "\n\\d{4}-\\d{2}-\\d{2}\n\nExercise 3:\nCreate a RegEx that matches a string containing \"hello world\" with \"o\" being optional.\nAnswer: \nhello world(?=\\w)\n\nExercise"
            },
            {
                "text": " \n^[0-9]{4}[0-9]{0,2}[A-Z]{3}$\n\n4. Give an example of using regular expressions for input validation.\nAnswer:\n- Validating email addresses using regular expressions\n\n5. What"
            },
            {
                "text": " \"^[2-9]\\d{3}[0-9]{2}[a-z]{1}$\"\n\n5. Find all dates (format \"yyyy-mm-dd\") in the following string: \"The sun will rise tomorrow at 08:00"
            },
            {
                "text": " ^\\d{4}-\\d{2}(?:\\d{2})?(?:/\\d{2})?$\n- ^\\d{4}-\\d{2}(?:\\d{2})?$ | ^\\d{4}-\\"
            },
            {
                "text": " [0-9]{4}-[[0-9]{4}]{2}[/][[0-9]{4}]\n\n3. Write CSS for a div with a class of \"p\"\nAnswer:\np {\n    color: blue;\n}"
            },
            {
                "text": " ^[0-9]{4}[0-9]{2}/$\n\nPart 2:\nCreate a function that takes in a string and returns a string that is a valid URL. The function should ignore case and spaces.\n\nWrite a function named validate_url that takes in"
            },
            {
                "text": " \n[a-zA-Z0-9]{4}[0-9]{2}[0-9]{2} \n\n3. Given a list of tuples containing an individual's name and their birth year, use list comprehension to generate a new list containing"
            },
            {
                "text": " (?<!^)([0-9]{4})([0-9]{2})([0-9]{2})/([0-9]{2})([0-9]{2})([0-9]{4})/([0"
            },
            {
                "text": " [^a-zA-Z0-9]+\n\nExercise 2: Regex for Validating Email Addresses\nMatch an email address in the format a+bb@c.com where a and b can have any number of digits and cc can be alphanumeric (i.e"
            }
        ]
    },
    {
        "expression": "^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",
        "raw_prompt": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.",
        "refined_prompt": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places.\nMatch examples:\n- \"12.34\"\n- \"100.00\"\n- \"-2.1\"\nNon-match examples:\n- \"101.1\"\n- \"10.123\"",
        "matches": [
            "12.34",
            "100.00",
            "-2.1",
            "48.65",
            "48.97",
            "98.54",
            "51.21",
            "87.5",
            "97.1",
            "54.9",
            "-79.1",
            "78.2",
            "98.2"
        ],
        "non_matches": [
            "101.1",
            "10.123",
            "100.10",
            "489.15",
            "489.514",
            "9.5498",
            "894.51",
            "7835.54",
            "68.54987",
            "564.216",
            "546.215",
            "215.5432"
        ],
        "id": 859,
        "output": [
            {
                "text": " ^[0-9]+(\\.[0-9]+)$\n\n**Exercise 4**:\nMatch this format string to the correct text.\n\n\"The price of the product is (\\$)?$"
            },
            {
                "text": " Accepts a positive or negative whole number between 0 and 100, excluding 0 and 100, and can be negative or positive. Accepts up to two decimal places.\n\n3.\n- \"This website was created by John Smith"
            },
            {
                "text": " r\"^[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,2}$\"\n\n\n\nContrastive, from both positive and"
            },
            {
                "text": "\n\\d+\\.\\d{1,2}(([+\\-]\\d+)?)\\d*\nMatches either \"+\" or \"-\" sign followed by one or two digits, one or two digits, followed"
            },
            {
                "text": " [0-9]{1,2}.[0-9]{1,2}?$\n\n#### Example 4: Password Validation\nA website requires users to enter a strong password that includes at least one u"
            },
            {
                "text": " {% if result.matches(r'^[1-9][0-9][0-9]\\.?[0-9]$') %}12.34{% elsif result.matches"
            },
            {
                "text": "\n(^[0-9]{1,3}(?:\\.[0-9]{1,3})?[0-9]{1,3}$)|(^[0-9]{"
            },
            {
                "text": " \n\\d+\\.\\d{0,2}\n\n2. Create a regex for the following phrase: \"I have a 60% chance of passing my test.\" Match examples:\n- \"60%\"\n-"
            },
            {
                "text": " (?<![^\\d\\.])(?![^\\d\\.])(?!$)(?<![^\\d\\.])(?!$)[^^.][^.][^.][^."
            },
            {
                "text": " (?<!\\d)([0-9]{1,2}(?:\\.[0-9]{1,2})?)(?![.0-9])\n\n3. Write a Python code"
            }
        ]
    },
    {
        "expression": "\\b(?:a(?:[nst]|re|nd)?|b[ey]|f(?:or|rom)|i[nst]?|o[fnr]|t(?:o|hat|he|his)|w(?:as|h(?:at|en|ere|ich|o)|i(?:th|ll)))\\b",
        "raw_prompt": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the ?: for grouping.\nI've tested this a bit, yet this is my 1st regex that I've ever written. It's working fine for me.",
        "refined_prompt": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the ?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"",
        "matches": [
            "by",
            "when",
            "or",
            "the",
            "a",
            "to",
            "i",
            "it",
            "is",
            "be",
            "on",
            "that",
            "from"
        ],
        "non_matches": [
            "bye",
            "craptastic",
            "nor",
            "fasdf",
            "apple",
            "tree",
            "pear",
            "banana",
            "notre",
            "dame",
            "abc111def",
            "12/132/90"
        ],
        "id": 861,
        "output": [
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: ^.+?(?=craptastic.$)\n\nA:\n\n"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: (\\w+) \n\nA:\n\nHere's a simple regex to generate the"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: (?<!craptastic\\s)(?:bye|\\s|\\.)"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: (?:by|when|or)\nThis is how I generated the RegEx:\n"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: r\"by|when|or\"\n\nA:\n\nThe other answers work,"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: \n\nA:\n\nA quick explanation of the regex:\n/\\b["
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: ^[A-Za-z]+$\n\nA:\n\nSomething like this"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: (?i)(?<=(?!by|when|or).*?)(?="
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: r\"^[\\w\\s]+[\\w\\d\\s]*$"
            },
            {
                "text": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings. Ordinarily have no search significance. I used this to remove the words in my own web search application. Take out the?: for grouping.\nMatch examples:\n- \"by\"\n- \"when\"\n- \"or\"\nNon-match examples:\n- \"bye\"\n- \"craptastic\"Generate a RegEx for this description. \nAnswer: (^[a-zA-z]+|[0-9]|[$"
            }
        ]
    },
    {
        "expression": "^([0-1])*$",
        "raw_prompt": "Expression validating a Binary string of any length",
        "refined_prompt": "Expression validating a Binary string of any length\nMatch examples:\n- \"10101000\"\n- \"01010000\"\n- \"100000001\"\nNon-match examples:\n- \"01000200\"\n- \"00021000\"",
        "matches": [
            "10101000",
            "01010000",
            "100000001",
            "10101",
            "010101010",
            "101001",
            "010101010101",
            "01101010011101",
            "1010101",
            "111111000",
            "1000000101010",
            "110101010111100001",
            "110101010011111"
        ],
        "non_matches": [
            "01000200",
            "00021000",
            "e10000000",
            "1201520201010",
            "10101010120102",
            "2010202020",
            "20020020",
            "20202020200",
            "1010100.0.0.0.01a",
            "1002012020",
            "2015205120",
            "020"
        ],
        "id": 862,
        "output": [
            {
                "text": ".*(1[01]|0{3})+\nThe solution is 1[01]|0{3} which means 1 or 0 followed by either 1 or 0 (three times)\n\n2. Match example:\n- \"11100001\"\n- \"100100"
            },
            {
                "text": " (0|[1-9][0-9]*)([01]{1})\n\n2. Write a python function that takes in a string and returns a list of all substrings that are composed of the digits '12345'.\n\nSolution:\nimport re\ndef"
            },
            {
                "text": " ^0+?(0*(1+0*)*(01+0*)*(0*(1+0*)*(0*(1+0*)*(1+0*)*(0*(1+0*)*(0*(1+0*"
            },
            {
                "text": " ^0*(1[01][0-9]0){0,3}$\n\n2. Write a Python script to generate valid IPv4 addresses using regular expressions.\n\n```python\nimport re\n\ndef is_valid_ipv4(ipv4_"
            },
            {
                "text": " ^(?:[01]{1}(?:0{1}[01]|[01]{0}[01]){0,9}[01]?)$\n\nExercise 2:\n- \"110000111\"\n- \"101010110\"\n"
            },
            {
                "text": " \"^(0|1){4}$\"\n\nExercise 2:\nGiven a string 'a1b2c', generate a regex for the pattern 'ab|bc|ca' (one or more of 'a', 'b', or 'c')\nAnswer: \"("
            },
            {
                "text": " ^\\d{1,4}\\s*$\n\nExercise 5:\nCreate a Python program that accepts a single binary digit (0 or 1) and prints its value as a string. Make sure your program handles both 0 and 1.\n\nCode:\nbinary_digit ="
            },
            {
                "text": "!\"RegExString\" (case insensitive) [0-9]{3}[1-9]{3}[0-9]{1}\n\nExercise 2:\nCreate a Python function called validate_hex_string(s) that takes a string s as"
            },
            {
                "text": "\nRegex:\n^[1-9][0-9]*(|0*)$\nExample:\n\nfunction validateBinary(binary) {\n  let result = binary.match(/^[1-9][0-9]*(|0*)$"
            },
            {
                "text": " ^(000000\\d{01}|1000000\\d{0,2})(\\d{03})?$\n\nExercise 2: \nCreate a Python code that generates a RegEx for the given description.\nMatch examples:\n- \"0a1101000"
            }
        ]
    },
    {
        "expression": "^([0-9a-fA-F]){8}$",
        "raw_prompt": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.",
        "refined_prompt": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products.\nMatch examples:\n- \"8ECCA04F\"\n- \"82E5AAA4\"\n- \"82e5aaa4\"\nNon-match examples:\n- \"8ECCAOF\"\n- \"82E5AA4\"",
        "matches": [
            "8ECCA04F",
            "82E5AAA4",
            "82e5aaa4",
            "37Fa8059",
            "b0B3E6F0",
            "86bbBe5b",
            "1c53c215",
            "75E14a03",
            "b6baf5c6",
            "34dc37c1",
            "DE18328C",
            "88CeA3FC",
            "c1eb17cc"
        ],
        "non_matches": [
            "8ECCAOF",
            "82E5AA4",
            "82e5aaa45",
            "afdsfads",
            "e5drtfy8guy",
            "65fty78gyu",
            "6ftyf7uy",
            "7dftd6tgy",
            "d56t87guygy89ugyv",
            "guyg8y8gy",
            "7ft6ddtr65erd6tf7yg",
            "ft6r6ft"
        ],
        "id": 865,
        "output": [
            {
                "text": " \n^[A-Fa-f]{8}\\d{4}\\d{4}$\n\nExercise 2:\n-  Create a Python function `is_valid"
            },
            {
                "text": " The ESSN should be 8ECCA02,82E5AA4\n\n3. Write a Python code to extract the date from a string using Regular Expression. The date should be"
            },
            {
                "text": " \n^[A-Fa-f0-9]{6}$\n\nExercise 5: Email Address Validation Method for the Business Email Address (BEMA) used in"
            },
            {
                "text": "\n\n(?:[1-9][0-9]?[0-9])|(?:2[0-4][0-9]|25[0-5])"
            },
            {
                "text": "\n^[a-fA-F0-9]{8}$\n\"\"\"\n\n# Solution to Question 1\nimport re\n\ntext = \"8ECCA04F"
            },
            {
                "text": " [^0-9]\n- \"82E5AA4\"Generate a RegEx for this description.\nAnswer: [^0-9A-Z]\n- \""
            },
            {
                "text": "\n(?<![0-9])[0-9A-Z]{3}-[0-9A-Z]{3}-[0-9A-Z"
            },
            {
                "text": " \n(^[a-fA-F0-9]+[a-fA-F0-9]{3}[a-fA-F0-9"
            },
            {
                "text": " [a-zA-Z0-9]{7}[a-zA-Z0-9]{4}[a-zA-Z0-9]"
            },
            {
                "text": "\n[a-zA-Z]{2}[0-9]{4}[A-Z]\n\nExercise 5:\nUse regular expressions to validate a credit"
            }
        ]
    },
    {
        "expression": "(02\\d\\s?\\d{4}\\s?\\d{4})|(01\\d{2}\\s?\\d{3}\\s?\\d{4})|(01\\d{3}\\s?\\d{5,6})|(01\\d{4}\\s?\\d{4,5})",
        "raw_prompt": "Validates UK domestic landline phone numbers.\nValid formats are:\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "refined_prompt": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match examples:\n- \"02476 123456\"\n- \"0845 123456\"",
        "matches": [
            "020 1234 5678",
            "0123 4567890",
            "01234 456789",
            "0106860496",
            "02617842344",
            "0163\f2643832",
            "0165781\u20052081",
            "0139985762",
            "0106346\u205f8156",
            "01451609003",
            "018601\u200222460",
            "01134852061",
            "01561729575"
        ],
        "non_matches": [
            "02476 123456",
            "0845 123456",
            "07712 345678",
            "r65tyg",
            "94856189",
            "8456",
            "8456654",
            "r65ftygv",
            "6t7yfuv",
            "341.431v4f3.fv1",
            "abc111def",
            "99999@gmail"
        ],
        "id": 869,
        "output": [
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            },
            {
                "text": "Validates UK domestic landline phone numbers.\r\nValid formats are:\r\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organization responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"020 1234 5678\"\n- \"0123 4567890\"\n- \"01234 456789\"\nNon-match"
            }
        ]
    },
    {
        "expression": "(077|078|079)\\s?\\d{2}\\s?\\d{6}",
        "raw_prompt": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered.",
        "refined_prompt": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"",
        "matches": [
            "07713 345678",
            "078 12345678",
            "079 12345678",
            "078 09442466",
            "07790\u2004495054",
            "07922223865",
            "07976338481",
            "07703621312",
            "078\u200928559370",
            "07953922231",
            "077\u205f62474680",
            "07787720248",
            "07966\u2029323376"
        ],
        "non_matches": [
            "02344 123456",
            "0121 292929",
            "012345 6789",
            "45162305230",
            "56123051",
            "512021548",
            "46512025",
            "94512015489",
            "4961525",
            "48152594612",
            "41621541245456",
            "461520"
        ],
        "id": 870,
        "output": [
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this."
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this pattern"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this pattern"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this."
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this example"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this question"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this\n"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this pattern"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this and"
            },
            {
                "text": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. Brackets are not valid and STD code must be entered.\nMatch examples:\n- \"07713 345678\"\n- \"078 12345678\"\n- \"079 12345678\"\nNon-match examples:\n- \"02344 123456\"\n- \"0121 292929\"Generate a RegEx for this."
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))$",
        "raw_prompt": "Matches month, requires that months 1-9 have a leading 0",
        "refined_prompt": "Matches month, requires that months 1-9 have a leading 0\nMatch examples:\n- \"01\"\n- \"02\"\n- \"12\"\nNon-match examples:\n- \"1\"\n- \"2\"",
        "matches": [
            "01",
            "02",
            "12",
            "03",
            "04",
            "05",
            "06",
            "07",
            "08",
            "09",
            "10",
            "11"
        ],
        "non_matches": [
            "1",
            "2",
            "13",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "418",
            "456",
            "48"
        ],
        "id": 876,
        "output": [
            {
                "text": " ([0-9][0-9])\n\nExercise 2: \nMatch all examples that are numeric and include a leading 0. \n\"01\"\n\"02\"\n\"20\"\n\"21\"\n\"12\"\n\"13\"\n\"10\"\nMatch examples: \n- \""
            },
            {
                "text": " \n[0-9][0-9]|1[012]:[012](?:-[0-9]{2})?\n\nExercise 3:\nMatch a date in the format \"mm.dd, yyyy\".\nExample: \"21.06.19\"\nAnswer: \""
            },
            {
                "text": " (\\d{1,3})([A-Za-z-]){3,10}\n\n3. Use the RegEx from exercise 2 to find all the dates from Jan 1, 2021 to Dec 31, 2021 in the string \"The meeting is on Jan 1, 2021, and Nov 30,"
            },
            {
                "text": " \n[0-9]{1,2}[A-Za-z]|[A-Za-z]{3,}\n\nExercise 3:\nMatch examples:\n- \"1\"\n- \"12\"\n- \"23\"\nNon-match examples:\n-"
            },
            {
                "text": "\n^(0|[1-9])$\n\nExercise 3:\nWrite a RegEx for this description.\nMatch examples:\n- \"5.5\"\n- \"6.5\"\n- \"7.5\"\nNon-match examples:\n- \"5\"\n- \"6"
            },
            {
                "text": " ^0(0|1|2|3|4|5|6|7|8)$\n\n#### Exercise 5\n\nYou are the data scientist for a company that sells products. You have been provided with data on the sales for the past 10 years and want to check for anomalies.\n\nThe data"
            },
            {
                "text": "\n^[0-9]{2}$\n\nQuestion 10: How can I use the startswith() method in Python to match only the first occurrence of a specified substring?\nAnswer: The startswith() method can be used to match only the first occurrence of a specified substring by specifying a"
            },
            {
                "text": " [0-9]{2}\\s(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\n- \"01\"\n- \"2\"Does not match.\n\nExamples of non-matching characters:\n\n-  "
            },
            {
                "text": " ^(0|[1-9])\"\\|\"(0|[1-9])\"\\|\"(0|[1-9])\"\\|\"(0|[1-9])\"$\n3. Match these dates in the format DD/MM/YYYY\nMatch examples:\n- \""
            },
            {
                "text": " \n```python\nimport re\n\ndescription = \"a string with digits from 01-12\"\npattern = \"^\\\\d{1,2}\\\\d$\"\nif re.match(pattern, description):\n    print(\"Valid Description\")\nelse:\n    print(\"Invalid Description\")\n"
            }
        ]
    },
    {
        "expression": "^\\s*-?(\\d*\\.)?([0-2])?[0-9]:([0-5])?[0-9]:([0-5])?[0-9](\\.[0-9]{1,7})?\\s*$",
        "raw_prompt": "This should be the pattern described in the documentation for the .NET TimeSpan.Parse method - generally parses time spans.\nFrom the .NET docs:\npublic static TimeSpan Parse(string s);\nThe s parameter contains a specification of the form:\n[ws][-][d.]hh:mm:ss[.ff][ws]\nItems in square brackets ([ and ]) are optional, colons and periods (: and .) are literal characters, and other items are as follows.\nItem Description\nws optional white space\n&quot;-&quot; optional minus sign indicating a negative time\n&quot;d&quot; optional days\n&quot;hh&quot; hours, ranging from 0 to 23\n&quot;mm&quot; minutes, ranging from 0 to 59\n&quot;ss&quot; seconds, ranging from 0 to 59\n&quot;ff&quot; optional fractional seconds, from 1 to 7 decimal digits",
        "refined_prompt": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"",
        "matches": [
            "10:12:34",
            "932323.9:00:32.3420",
            "12:34:56",
            "1:2:3",
            "00:00:00",
            "-1:23:45.6789",
            "01:59:00.1234567",
            "23:59:59.9999999",
            "0:00:01",
            "01:02:03.000001",
            "0:00:00.1",
            "00:00:59",
            "23:59:59.999999"
        ],
        "non_matches": [
            "10:20:80",
            "f34fvfv",
            "2534/52435234/2453",
            "12/123/4322",
            "2346-2345-2435",
            "$23.454",
            "/5/5/5",
            "105516:516:654",
            ":465:456:465f",
            "1-1-2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 877,
        "output": [
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generating"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generates"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generates"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            },
            {
                "text": "This regex pattern matches time-like strings in the format: \"HH:MM:SS.SSSSSSS\" (hours, minutes, seconds, and optional fractional seconds). It allows for negative values, leading/trailing whitespace, and allows for optional single-digit hours, minutes, and seconds.\nMatch examples:\n- \"10:12:34\"\n- \"932323.9:00:32.3420\"\n- \"12:34:56\"\nNon-match examples:\n- \"10:20:80\"\n- \"f34fvfv\"Generate"
            }
        ]
    },
    {
        "expression": "^([1-9]{0,1})([0-9]{1})(\\.[0-9])?$",
        "raw_prompt": "Matches numbers 0 through 99.9\nAllows only one preceding zero and does not require the decimal point",
        "refined_prompt": "Matches numbers in the format of a single digit, with an optional leading digit in the range 1-9 and an optional decimal part consisting of a period followed by one digit.\nMatch examples:\n- \"1\"\n- \"1.1\"\n- \"0.1\"\nNon-match examples:\n- \"01\"\n- \"01.1\"",
        "matches": [
            "1",
            "1.1",
            "0.1",
            "4.8",
            "6.5",
            "1.4",
            "8.4",
            "9.8",
            "3.2",
            "5.4",
            "6.7",
            "5.1",
            "6.4"
        ],
        "non_matches": [
            "01",
            "01.1",
            "0.10",
            "000151",
            "0051156",
            "0.215413",
            "56115",
            ".40215afd",
            "5612356",
            "adfa2",
            "dfg",
            "8h98009hu"
        ],
        "id": 879,
        "output": [
            {
                "text": " ^[1-9]\\d$ and ^[1-9]\\d\\.?[0-9]$\n\nExercise 2:\nWrite a regular expression that"
            },
            {
                "text": " [0-9]?\\.?[0-9]\n\nExercise 4:\nProvide an alternative RegEx pattern to the example in Exercise 3 that would match numbers with"
            },
            {
                "text": " r'\\d\\.(\\d|\\d\\.)+'\n\nConversation between TA and student:\n\nStudent: Can you explain what regular expressions are and"
            },
            {
                "text": " ^[1-9]\\d*\\.?[1-9]$\n\nExercise 2:\nIdentify the pattern in the following expression:\n([a-z"
            },
            {
                "text": " ^[1-9](\\.[0-9])?$\n\n4. Use the Regex pattern from Exercise 3 to find all occurrences of each type of number in a list"
            },
            {
                "text": " ^(0|[1-9][0-9]?)\\.[0-9]+$\n\nStudent Question:\n\nHello everyone, I am currently taking a course"
            },
            {
                "text": " ^[1-9][0-9]*(?:\\.[0-9]{1,2})?$\n\n2. Write a regular expression that matches phone numbers"
            },
            {
                "text": "\n^[1-9]\\d*(\\.\\d+)?$\n\n3. Use the RegEx tool (e.g. VS Code's RegEx) to"
            },
            {
                "text": " OneDigitAnyDotAnyDigit?\n\nExercise 2:\n\nMatch any number in the range 0-9, with an optional leading digit in the range 0-"
            },
            {
                "text": "  ^(?P<number_of_digits>\\d\\d(\\.?\\d*)?)$\n\nA:\n\nJust use\n^\\d("
            }
        ]
    },
    {
        "expression": "^(eth[0-9]$)|(^eth[0-9]:[1-9]$)",
        "raw_prompt": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff",
        "refined_prompt": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff\nMatch examples:\n- \"eth0\"\n- \"eth0:4\"\n- \"eth4:9\"\nNon-match examples:\n- \"eth0:\"\n- \"eth0:0\"",
        "matches": [
            "eth0",
            "eth0:4",
            "eth4:9",
            "eth0:4",
            "eth8:6",
            "eth2:4",
            "eth9:8",
            "eth0:4",
            "eth4:5",
            "eth0:8",
            "eth4:8",
            "eth3:4",
            "eth2:3"
        ],
        "non_matches": [
            "eth0:",
            "eth0:0",
            "eth0:1d",
            "eth2y8hfue",
            "eth:HUIF89dh",
            "eth:hiuf8",
            "eth:43298",
            "eth:89ur",
            "epflu3829",
            "epfl8293j",
            "epfl$EDR",
            "12/132/90"
        ],
        "id": 880,
        "output": [
            {
                "text": " r\"eth0:(\\d(\\d+))\"\n\nA:\n\nYou can use re.match for a simple regex. For example:\nimport re\n\nstr1 = \"eth0:4\"\nstr2 ="
            },
            {
                "text": "\n```python\nimport re \ninvalid_device_names = [\"eth0:4\", \"eth0:0\", \"eth4:9\"]\n\ndef match_device_names(names):\n    pattern = \""
            },
            {
                "text": " /^eth0:[0-9a-f]{1,4}:?[0-9a-f]{1,4}:?$/.\nI'm not sure what you're doing with the regex here, but you"
            },
            {
                "text": "\nimport re\nregex = r\"(?:[[0-9a-fA-F]][0-9a-fA-F]\\:[0-9a-fA-F])?|[^0-"
            },
            {
                "text": " r\"^[a-zA-Z0-9: \\w]*$\"\n\nHost 1: Let's continue learning about regex. Matching is when the pattern is found in the string. Whereas, findall is when"
            },
            {
                "text": " /^\\s*eth0:\\s*[0-9]+$/\n\nA:\n\nIf you want to validate you can do what @JohannesLundberg suggested in python, however instead of re.search"
            },
            {
                "text": " r\"eth0:(\\d+):(\\d+) (\\w+)\"\n\n5  Write a Python code using the re module to generate a regex that matches all ip addresses in a text file\n- Import the re module\n-"
            },
            {
                "text": " /^[0-9a-f]{2}[0-9]:[0-9]$/\nThis would match:\n- \"eth0:0:1\"\n- \"eth0:0:1:"
            },
            {
                "text": "  (^|[^a-zA-Z0-9_\\-:])[a-zA-Z0-9_\\-:]([a-zA-Z0-9_\\-:]{0,5"
            },
            {
                "text": " (?<=eth)\\0+(?=:)\nSee How to use positive lookbehind (?<=... ) and positive lookahead (?=... ) in regular expressions\n\nA:\n\nTo add to the other answers"
            }
        ]
    },
    {
        "expression": "^\\.([rR]([aA][rR]|\\d{2})|(\\d{3})?)$",
        "raw_prompt": "RAR file extensions.\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\nDoes not support volumes exceed 101 for s## (r99, s00, s01, ...) serie.",
        "refined_prompt": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01, ...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"",
        "matches": [
            ".RAr",
            ".r01",
            ".012",
            ".R32",
            ".r46",
            ".R05",
            ".RAR",
            ".rAR",
            ".R31",
            ".035",
            ".RAR",
            ".917",
            ".RAR"
        ],
        "non_matches": [
            ".rxr",
            ".a01",
            ".0112",
            "rarhu",
            "rary78hu",
            "huiey8uhr",
            "y8uhi6r7tf",
            "r56tf",
            "r65ft",
            "r65tf",
            "6fty8uhi",
            "uhi"
        ],
        "id": 881,
        "output": [
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: ?([0-9]{1,2})?[0-9]?([a-z"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (.r00,.r01,.r02,.r03,.r04,.r05"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: ^\\.([0-8]\\d*)(?:\\.([0-9]\\d*)"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: [(\\.r\\d+)\\.(\\d+)]\r\n\r\nimport re\r\n\r\ntest"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: ^.RAr$ or ^[^.](r|R|Rr|rr|s|S"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: r[a-zA-Z]\\d*\\.part01.rar\r\n- \".a99"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (.+)\\.r[\\d\\d]*$\r\n\r\n'''\r\nimport re\r"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: ^[^\\s]*\\.(Rar|rar)([0-9]{1,2"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (.r[0-9]{2})(\\.[0-9]{2})?\nFor"
            },
            {
                "text": "RAR file extensions.\r\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\r\nDoes not support volumes exceed 101 for s## (r99, s00, s01,...) serie.\nMatch examples:\n- \".RAr\"\n- \".r01\"\n- \".012\"\nNon-match examples:\n- \".rxr\"\n- \".a01\"Generate a RegEx for this description. \nAnswer: (in the same order as the list above) \"r[0-9]{1,2}("
            }
        ]
    },
    {
        "expression": "^(X(-|\\.)?0?\\d{7}(-|\\.)?[A-Z]|[A-Z](-|\\.)?\\d{7}(-|\\.)?[0-9A-Z]|\\d{8}(-|\\.)?[A-Z])$",
        "raw_prompt": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\nFormat CIF: [1 letter][7 numbers][1 number or letter]\nFormat NIF: [8 numbers][1 letter]\nFormat NIE: X[possible 0][7 numbers][1 letter]\nNote that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.\nGenerally I always strip out any non-alphanumeric characters (hyphens, periods, etc.) and convert to upper case before checking validity and before saving to data storage.\nPlease post improvements or errors if you find them!",
        "refined_prompt": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544122-R\"\nNon-match examples:\n- \"43.544.122-R\"\n- \"f34fvfv\"",
        "matches": [
            "X01343567-D",
            "B-6116622G",
            "43544122-R",
            "40321895-U",
            "58334674P",
            "24527791P",
            "06707604F",
            "19979739.G",
            "71917270.N",
            "46841644.V",
            "X2645813.P",
            "X6139722.A",
            "67187001G"
        ],
        "non_matches": [
            "43.544.122-R",
            "f34fvfv",
            "34f2vf42e",
            "Mastercard",
            "2346-2345-2435",
            "$23.454",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "adfa2",
            "abc111def",
            "++63453.345"
        ],
        "id": 882,
        "output": [
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354445"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544444"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354442"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544-"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544-"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544343"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544444"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354435"
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"43544."
            },
            {
                "text": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\r\nFormat CIF: [1 letter][7 numbers][1 number or letter]\r\nFormat NIF: [8 numbers][1 letter]\r\nFormat NIE: X[possible 0][7 numbers][1 letter]\r\nNote that this expression does not check for the validity of the NIF/CIF/NIE.\nMatch examples:\n- \"X01343567-D\"\n- \"B-6116622G\"\n- \"4354444"
            }
        ]
    },
    {
        "expression": "^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$",
        "raw_prompt": "Matches full and compressed IPv6 addresses as defined in RFC 2373 (http://www.faqs.org/rfcs/rfc2373.html). No useful captures.\nVarious implementations require different terminators. (i.e. ^-$ or \\b-\\b)",
        "refined_prompt": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"",
        "matches": [
            "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210",
            "1080::8:800:200C:417A",
            "::FFFF:129.144.52.38",
            "9Bec::1E:644:64A",
            "D:A:46:06E:A6cC::A2",
            "::eb8:19c8:A0B:A3d3",
            "B8:ae:3::e:F587:Fdf",
            ":255.208.204.245",
            "EEc:69D:a:B7:5F:A4D::6bcD",
            "ACfC:3c:c8d:BABb:90d:3d:6.251.222.193",
            "::9E:250.153.252.9",
            "0fCB:3e:ae:1F:7:29C:172.61.190.202",
            "18Cb:C8::53:0a5b:Ed2:a295"
        ],
        "non_matches": [
            "FEDC::7654:3210::BA98:7654:3210",
            "FEDC:BA98:7654:3210",
            "::",
            "12/1::23/4322::",
            "23::46-2345-24::35",
            "$23.::454",
            "43::-54::32",
            "/5/5::/20022::",
            "qwerty@::123.123",
            "1-1-2::",
            "(0xx12) ::625::09",
            "12::/132/9::0"
        ],
        "id": 885,
        "output": [
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this case"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this address"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this one"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this case"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this address"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this."
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this."
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this\n"
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this."
            },
            {
                "text": "Matches full and compressed IPv6 addresses as defined in RFC 2373.\nMatch examples:\n- \"FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\"\n- \"1080::8:800:200C:417A\"\n- \"::FFFF:129.144.52.38\"\nNon-match examples:\n- \"FEDC::7654:3210::BA98:7654:3210\"\n- \"FEDC:BA98:7654:3210\"Generate a RegEx for this pattern"
            }
        ]
    },
    {
        "expression": "^(\\$|)([1-9]\\d{0,2}(\\,\\d{3})*|([1-9]\\d*))(\\.\\d{2})?$",
        "raw_prompt": "Combine Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input to create this RE to accept Optional leading dollar sign, optional well-formed comma separator dollar amount with no zero amount allowed.\n*** Correction: Remove the &quot;+&quot; otherwise it will incorrectly matches 4 leading digits like 1234,345,678.00 03-03-2005",
        "refined_prompt": "Matches monetary values with optional dollar signs and supports thousands separators. It enforces that the value must have at least one digit before the decimal point and exactly two digits after the decimal point, if present.\nMatch examples:\n- \"$1,234,567.89\"\n- \"1234567.89\"\n- \"$9.99\"\nNon-match examples:\n- \"$1,2345,67.89\"\n- \"$1234,345,678.0\"",
        "matches": [
            "$1,234,567.89",
            "1234567.89",
            "$9.99",
            "$561",
            "100",
            "123",
            "45679856.12",
            "4856",
            "489",
            "$48",
            "$8464",
            "$84645",
            "$4865"
        ],
        "non_matches": [
            "$1,2345,67.89",
            "$1234,345,678.0",
            "0",
            "12/123/4322",
            "123.456.789",
            "43.v234",
            "$451123.451561",
            "$564.546313",
            "56123.156465%",
            "$6512332$#@",
            "9/9/9",
            "++63453.345"
        ],
        "id": 890,
        "output": [
            {
                "text": " \n\n```python\nimport re\n\n"
            },
            {
                "text": "  ^[\\d\\.]{1,3"
            },
            {
                "text": " /[\\d]+(?:\\.\\d"
            },
            {
                "text": " ^\\$[\\d,\\.]{1"
            },
            {
                "text": " Matches monetary values with optional dollar signs and supports thousands"
            },
            {
                "text": "\n[0-9,]+\\.[0-"
            },
            {
                "text": " \\d{4}\\.\\d{3}"
            },
            {
                "text": " \\$(\\d+(?:\\.\\d+"
            },
            {
                "text": "\n[A-Za-z][A-"
            },
            {
                "text": " $1.23e+05\n\n3."
            }
        ]
    },
    {
        "expression": "^((Fred|Wilma)\\s+Flintstone|(Barney|Betty)\\s+Rubble)$",
        "raw_prompt": "Match the full names of the four main characters of The Flintstones.",
        "refined_prompt": "Match the full names of the four main characters of The Flintstones.\nMatch examples:\n- \"Fred Flintstone\"\n- \"Barney Rubble\"\n- \"Betty Rubble\"\nNon-match examples:\n- \"The Great Gazoo\"\n- \"Mr. Slate\"",
        "matches": [
            "Fred Flintstone",
            "Barney Rubble",
            "Betty Rubble",
            "Fred Flintstone"
        ],
        "non_matches": [
            "The Great Gazoo",
            "Mr. Slate",
            "Dino",
            "Mastercard",
            "sfalijad234",
            "Visa",
            "Pat",
            "Lionel Messi",
            "Neymar Jr.",
            "ABC",
            "fisjd",
            "fU*(DHIF"
        ],
        "id": 891,
        "output": [
            {
                "text": " /[A-Z][a-z]?[0-9]?[0-9][A-Z]*/\n\n\n\nTitle: Exploring Conflict and Its Causes and Effects: A Comprehensive Guide for Middle School Students\n\nIntroduction"
            },
            {
                "text": " \"The Flintstones\" - \\d+; [^\\d]*\n        \"Barney Rubble\" - \\d+; [^\\d]*\n        \"Betty Rubble\" - \\d+; [^\\d]"
            },
            {
                "text": " The RegEx is [^A-Z][a-z]* and the full names are Fred Flintstone, Barney Rubble, Betty Rubble.\n\n3. Create a RegEx pattern that matches any string that starts with the word \"dog\""
            },
            {
                "text": " \nPattern = \"^(^|[^\\w])([a-z]{3})([a-z]{3}\\s+){1,2}$\"\n\n\n\nQuestion 6:\nA store offers a"
            },
            {
                "text": "\n    - \"The Flintstones\" - [FRIEND/FRIEND]\n    - \"Barney Rubble\" - [BARNEY/BARNEY]\n    - \"Betty Rubble\" - [BETTY/B"
            },
            {
                "text": " - \"Fred Flintstone\"\n\nExercise 3: Use RegEx to validate that a user's input is an integer.\nExample: \nInput: 3\nOutput: True, \"Input must be a whole number.\"\n\nExercise 4:"
            },
            {
                "text": " https://regex101.com/r/gV8uD3\n\n5. Create a RegEx pattern to generate a sequence of letters that are both lowercase and digits.\nGenerate a RegEx pattern for this description.\nAnswer:"
            },
            {
                "text": "\nFred Flintstone: \n(?i)(?<!Betty)^(?<!Barney)Fred (?<!Betty)\nMr. Slate:\n(?i)(?<!The Great)^The\n\n"
            },
            {
                "text": "\n- Fred Flintstone: [RF]\n- Barney Rubble: [BR]\n- Betty Rubble: [BR]\n- The Great Gazoo: [GT]\n- Mr. Slate: [MT]\n\n\n\nQuestion 3:"
            },
            {
                "text": " \n\n``` python\nimport re\n\n# Match case of \"the Flintstones\"\npattern = r\"^the Flintstones$\"\ntext = \"The Flintstones\"\n\n# Print the match\nif re.match(pattern,"
            }
        ]
    },
    {
        "expression": "(^\\([0]\\d{2}\\))(\\d{6,7}$)",
        "raw_prompt": "Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix",
        "refined_prompt": "Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix\nMatch examples:\n- \"(021)1234567\"\n- \"(021)123456\"\n- \"(000)000000\"\nNon-match examples:\n- \"(123)1234567\"\n- \"025123456\"",
        "matches": [
            "(021)1234567",
            "(021)123456",
            "(000)000000",
            "(037)724022",
            "(007)4356525",
            "(088)734140",
            "(041)370187",
            "(094)245329",
            "(012)915180",
            "(003)212963",
            "(092)654593",
            "(078)6872674",
            "(054)124109"
        ],
        "non_matches": [
            "(123)1234567",
            "025123456",
            "0252345678",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 894,
        "output": [
            {
                "text": " \\d{3}-\\d{6}\nThis regex doesn't contain the initial ( and it can't start with a 0"
            },
            {
                "text": " The following RegEx should work:\n^[1-9]\\d\\d[1-9]\\d [1-"
            },
            {
                "text": " ^(01[2-7][1-9]|0[1-9]|[1-9][2-9"
            },
            {
                "text": " (0)-([0-9]{3})[ -]?[0-9]{4}\n\nI have been"
            },
            {
                "text": " ^(0[1-9]{9}|[1-9][0-9]{3}[1-9"
            },
            {
                "text": " \n\\b(0[1-9]|1[012])\\d{3}\\b\n\nExercise 2:"
            },
            {
                "text": " (\\d(0\\d)?|\\d\\d)\n\nHere is my code:\nimport re\nimport pprint"
            },
            {
                "text": " \n(?=^[0-9]*$)(?!^[0-9]*[- ]*[0"
            },
            {
                "text": "  ^([0][1-9]|[1-9][0-9]|2[0-3]|["
            },
            {
                "text": " \n(|(?<!^)[0-9]{2}(?<![0-9]*["
            }
        ]
    },
    {
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$",
        "raw_prompt": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations (RegularExpressionValidator - ASP.NET).",
        "refined_prompt": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations.\nMatch examples:\n- \"08:00AM\"\n- \"10:00am\"\n- \"7:00pm\"\nNon-match examples:\n- \"13:00pm\"\n- \"12:65am\"",
        "matches": [
            "08:00AM",
            "10:00am",
            "7:00pm",
            "11:21AM",
            "03:04Pm",
            "04:47PM",
            "04:53am",
            "6:03PM",
            "1:30Pm",
            "08:16PM",
            "02:59pm",
            "01:12am",
            "11:59pm"
        ],
        "non_matches": [
            "13:00pm",
            "12:65am",
            "12ampm",
            "1230am",
            "13pm",
            "13morning",
            "17",
            "91ur3",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 895,
        "output": [
            {
                "text": "\n[0-9][0-9][0-9][:][0-5][0-9][0-9]:[0-5][0-9][0-5]["
            },
            {
                "text": " \"^([0-9]{1,2}:[0-9]{2})([a-z])$\"\n\n5. Write a python function that takes a string and"
            },
            {
                "text": "\n(^\\d{1,2}:\\d{2}[ap]m$)|(^\\d{1,2}:\\d{2}$)|(^\\d"
            },
            {
                "text": "\n^((1|2)\\d|3|4)\\d{0,2}:\\d{2}(am|pm)$\n\nExercise 3: \n\nCreate a"
            },
            {
                "text": "\n^([0-9]{1,2}):([0-9]{2})$\n\nA:\n\nA quick and dirty one-liner:\n^([2-"
            },
            {
                "text": "  \\d{1,2}(:|am|pm)\n\n3. Use a RegEx to return the number of vowels in a string.\nFor this exercise, you must"
            },
            {
                "text": " \n(^[01]|2[0-3]):[0-5][0-9]]*[APM]$\n\nA:\n\nYou need to make sure"
            },
            {
                "text": " The start and end times must be between 0 and 23. The start time must be between \"0\" and \"11\". \n\nExercise 3:\nGenerate a RegEx that matches a"
            },
            {
                "text": " \"^[0123][0-5][0-9]A[0-9][0-9]$\"\nThe last two answers are obviously invalid, and so I have no idea"
            },
            {
                "text": " ([0-9]{1,2}):([0-5][0-9])[.]([0-9]{2})\n\nA:\n\nI have written a regex"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+$",
        "raw_prompt": "it will check for alphanumeric (Alpha Numeric) values.",
        "refined_prompt": "matches strings that only consist of one or more alphanumeric characters (letters and/or digits).\nMatch examples:\n- \"adad1213\"\n- \"1231dfadfa\"\n- \"dfad123dfasdfs\"\nNon-match examples:\n- \"dfa@#12313\"\n- \"*(*sdfasdfadfd\"",
        "matches": [
            "adad1213",
            "1231dfadfa",
            "dfad123dfasdfs",
            "65f67f",
            "76c7",
            "c76",
            "f765d",
            "6f68",
            "f8",
            "67f78",
            "f87",
            "fg87",
            "f787fr7"
        ],
        "non_matches": [
            "dfa@#12313",
            "*(*sdfasdfadfd",
            "$fffsdg121ddd#$f1q",
            "$%RT",
            "F^TY",
            "(IH",
            ")OK",
            "(IJ",
            "8UH&^&",
            "yh&Y",
            "@#EF",
            "++63453.345"
        ],
        "id": 898,
        "output": [
            {
                "text": ".*?[a-zA-Z0-9].*\n\nExercise 5:\nUsing the RegEx you created in Exercise 4, write a Python"
            },
            {
                "text": "\n(?=.*[a-z])[a-z0-9]{7,20}\n\n\n\nQuestion 6: A rectangular garden has a"
            },
            {
                "text": "\n^[a-zA-Z0-9]*$\n\nA:\n\nI'd suggest this, it doesn't use regular expressions.\n>>>"
            },
            {
                "text": " \n\nA:\n\nYou could use the following regex:\n(?<![a-zA-Z0-9 ])[0-9]"
            },
            {
                "text": " \n\nimport re\nstring = \"dfad123dfasdfs\"\nregex = \"^[a-zA-Z0-9]+$"
            },
            {
                "text": "\n\n```python\nimport re\n\ntext = \"adad1213\\n1231dfadfa\\ndfad123dfasdfs\"\n"
            },
            {
                "text": " \n\n``` python\nimport re\n\n# First example:\nexample1 = \"adad1213\"\nresult1 = re.match(r'"
            },
            {
                "text": " (0|\\S|\\d)[a-zA-Z0-9]\n- \"*(*sdfasdfadfd*a)\"Generate"
            },
            {
                "text": " (?i)(?=[^aeiou]*[aeiou][^aeiou]*$)(?=[^aeiou]*[ae"
            },
            {
                "text": "\n^[a-zA-Z0-9]{6,}$\n\nExercise 4 - Generating a RegEx Pattern for Password Strength Check:"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((19|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.\nAs usual, many tests have been made.\nThis was requested by a user :\nhttp://www.regexlib.com/REDetails.aspx?regexp_id=409",
        "refined_prompt": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.\nMatch examples:\n- \"29/02/2000\"\n- \"30/04/2003\"\n- \"01/01/2003\"\nNon-match examples:\n- \"29/02/2001\"\n- \"30-04-2003\"",
        "matches": [
            "29/02/2000",
            "30/04/2003",
            "01/01/2003",
            "19/02/1981",
            "14/02/1964",
            "29/02/3056",
            "20/10/8819",
            "22/10/6437",
            "19/10/3905",
            "15/10/1964",
            "18/02/1914",
            "15/08/2992",
            "27/02/1932"
        ],
        "non_matches": [
            "29/02/2001",
            "30-04-2003",
            "1/1/1899",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "32542 //"
        ],
        "id": 901,
        "output": [
            {
                "text": " \\d{1,2}\\/\\d{1,2}\\/\\d{4}\n\n4. Write a RegEx that checks if a string ends with a valid file"
            },
            {
                "text": " dd/MM/yyyy(?:\\.(?:leap|full))\n\n3. Match all dates in the following format : yyyy/mm/dd\nExamples :"
            },
            {
                "text": " \n\n```\n(01[0-9]|[12][0-9]|3[01])/((0[1-9]|1[012])"
            },
            {
                "text": "\n\nimport re\n\ndef match_dates(dates):\n    regex = re.compile(r\"(?P<day>[0-9])/(?P<month"
            },
            {
                "text": " [01/02/100-99/99/99]\n\nA:\n\nThis should work (I used the regex which @maddy suggested)\n    /^(?:"
            },
            {
                "text": "\n[0-9]{1,2}/[0-9]{1,2}/[0-9]{4}\nI have started by generating a list"
            },
            {
                "text": "\n(.+/(..)(.+)(..)/g)\n\nA:\n\nTo match the dates formatted yyyy/MM/dd you could use the following regex,"
            },
            {
                "text": "\n[0-9]{2}/[0-9]{2}/[0-9]{4}|[0-9]{4}/[0"
            },
            {
                "text": " \n(0) (3) (2) (1)\n(0) (1) (2) (3)\n(2) (3) (1) (0"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{2} (with leap years 1% integrated)\n\nExercise 2: Create a RegEx to match a date"
            }
        ]
    },
    {
        "expression": "(^[+]?\\d*\\.?\\d*[1-9]+\\d*$)|(^[+]?[1-9]+\\d*\\.\\d*$)",
        "raw_prompt": "Accepts only positive decimal values. Zero and negative numbers are non-matching.Allows zeros after last non-zero numeric value after decimal place for significant digits",
        "refined_prompt": "Accepts only positive decimal values. Zero and negative numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits.\nMatch examples:\n- \"01.23\"\n- \"0.15\"\n- \"0.1568\"\nNon-match examples:\n- \"0\"\n- \"-0.18\"",
        "matches": [
            "01.23",
            "0.15",
            "0.1568",
            "516.485",
            "845.65",
            "8945.645",
            "7865.897",
            "849.897",
            "9.6",
            "6.3",
            "87.24",
            "46.21",
            "54.12346"
        ],
        "non_matches": [
            "0",
            "-0.18",
            ".0",
            "-49856",
            "-9-456",
            "-1595.159",
            "-9156.894",
            "-7989.159",
            "00000",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 909,
        "output": [
            {
                "text": " (?<![0-9\\.])0.(?![0-9])(?![0-9])[0-9]{4}[0-"
            },
            {
                "text": " \n^([0-9]+\\.)?([0-9]+)$\n\nExample Scenario:\nA team of five people is working on a project, and"
            },
            {
                "text": "\n\\d+\\.\\d*(?=\\d+$)\n\nA:\n\nThis should probably work for you: \\d+\\.\\d*["
            },
            {
                "text": "\n(0+|[1-9][0-9]*[0-9]?)\\.\nExercise 3: Using the RegEx you compiled in Exercise 2,"
            },
            {
                "text": " ^(0+[\\d.]+?(?:\\.\\d+)?$)\n\n\n\nComparison--Smooth and Rough\n\nIn the world of"
            },
            {
                "text": "\n^[-+]?(?:[0-9]*(\\.[0-9]*)?|[0-9]+)(?:[eE][-+]?"
            },
            {
                "text": " \\-?(0|(1[0-9]{1,}))|\\+?(0|(1[0-9]{1,}))"
            },
            {
                "text": " (?<=[0-9])(?=\\.[0-9]*)(?![0-9])\nThe following is a sample of what a RegEx for"
            },
            {
                "text": "\n^(1\\.)?[0-9]+(?:\\.0+)?$\n0+ Non-zero values are allowed after decimal place for significant digits. Allows"
            },
            {
                "text": " ^[\\d.]*$\n\nUse Case 1: Conversation between friends discussing the benefits of using regEx in their financial planning.\nUse Case 2: A debate between two"
            }
        ]
    },
    {
        "expression": "^(((((((0?[13578])|(1[02]))[\\.\\-/]?((0?[1-9])|([12]\\d)|(3[01])))|(((0?[469])|(11))[\\.\\-/]?((0?[1-9])|([12]\\d)|(30)))|((0?2)[\\.\\-/]?((0?[1-9])|(1\\d)|(2[0-8]))))[\\.\\-/]?(((19)|(20))?([\\d][\\d]))))|((0?2)[\\.\\-/]?(29)[\\.\\-/]?(((19)|(20))?(([02468][048])|([13579][26])))))$",
        "raw_prompt": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --&gt; 2099. Is enough for my purposes. Incorectly validates 02-29-1900. I created this to validate dates on a web form where the likely range will be 2000--&gt;2020. Seperators can be '.','/' or '-'\nAnyone know the rules for operator precedence for regex syntax?",
        "refined_prompt": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --&gt; 2099.\nMatch examples:\n- \"02-29-2004\"\n- \"1/31/1997\"\n- \"1-2-03\"\nNon-match examples:\n- \"02-29-2003\"\n- \"04-31-2003\"",
        "matches": [
            "02-29-2004",
            "1/31/1997",
            "1-2-03",
            "2-2706",
            "03/22.18",
            "110573",
            "3.311915",
            "2.2916",
            "11/1696",
            "11-3084",
            "2-29.32",
            "218-2085",
            "2292088"
        ],
        "non_matches": [
            "02-29-2003",
            "04-31-2003",
            "31-03-05",
            "12/123/4322",
            "2346-2345-2435",
            "2/33/5235",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 911,
        "output": [
            {
                "text": " \n\\d{2}-\\d{2}-\\d{4}|\\d{1}-\\d{"
            },
            {
                "text": " [^0-9-\\/]{1,2}-\\d{1,2}-\\d{4}|["
            },
            {
                "text": " (?<startdate>01-\\d-\\d(?:\\.\\d\\d)?)(?<enddate>20"
            },
            {
                "text": " \n(?<year>\\d{4})-(?<month>\\d{2})-(?<day>"
            },
            {
                "text": " \nThis should work: \"^[0-9]{4}-[[1-9]][0-9]{2"
            },
            {
                "text": " \\d{1,2}\\/\\d{1,2}\\/\\d{4}$\n\nExercise 5:\n"
            },
            {
                "text": " dd-mm-yyyy (month, day, year) \n    (1|0): one of the characters in the set of"
            },
            {
                "text": "\n(?<!1[0-2]\\d|[1-2]\\d|3[01])-(?!0"
            },
            {
                "text": " ([0-9]{2}\\-){2}\\d{2}|([0-9]{4}\\-[0-9"
            },
            {
                "text": " \n\nimport re\n\ndate_range = \"1900 --&gt; 2099\"\n\n# define regex pattern\npattern ="
            }
        ]
    },
    {
        "expression": "^([2-9]\\d{3}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$",
        "raw_prompt": "yyyyMMdd with leap year validation, starting from year 2000 only.\nThe length of the expression is minimized, but still validates all entries.\nIf you want it with years like 1600 or separators, just ask :)",
        "refined_prompt": "yyyyMMdd with leap year validation, starting from year 2000 only.\nMatch examples:\n- \"20000101\"\n- \"20051231\"\n- \"20040229\"\nNon-match examples:\n- \"19990101\"\n- \"20053112\"",
        "matches": [
            "20000101",
            "20051231",
            "20040229",
            "99691129",
            "48821031",
            "88000229",
            "95430105",
            "29040731",
            "80840229",
            "53320229",
            "56830531",
            "36600531",
            "60231031"
        ],
        "non_matches": [
            "19990101",
            "20053112",
            "20050229",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "188414568",
            "98498765",
            "94848798",
            "51354987"
        ],
        "id": 913,
        "output": [
            {
                "text": " \npattern = r\"\\d{4}-\\d{1,2}-\\d{1,2}(?=\\d{1,2}|$)\"\npattern = r\"\\b(?:(?:0(?="
            },
            {
                "text": "\nThe start of the string must be \"2000\" or later.\nThe end of the string must be \"12\" or later.\nThe year must be at least two digits long and there can be one or two digits in the month.\nThe month must be"
            },
            {
                "text": "\nimport re\ns = \"20000101\"\nif re.search(\"^\\d{4}-\\d{2}-\\d{2}$\", s): \n    print(\"Yes\")\nelse: \n    print(\"No"
            },
            {
                "text": " [01-12][0-9][0-9][0-9][0-9][0-9] [0-9][0-9][0-9]\n\nExercise 3: Create a RegEx pattern that matches only valid email addresses"
            },
            {
                "text": " \"\\d{4}(0[1-9]|1[012])[0-2]\\d\\d\"\n\n9. Write a Python function that takes a string and returns True if it is a valid email address, and False otherwise. A"
            },
            {
                "text": "\n\n^(([1-9]\\d?){4}0*[1-9](0|[1-9])[1-9]?)\\d{2}$\n\nCongratulations, you have now learned how to write a regular expression"
            },
            {
                "text": " ([01]{4}[0-9]{3}\\2[0-9]{2})\n2. Write a RegEx to validate that a string only contains alphanumeric characters and underscores.\nAnswer: ^[a-zA-Z"
            },
            {
                "text": " \n(?<year>[0-9]{4})(?<month>[0-9]{2})(?<day>[0-9]{2})\n(?<week>?[0-9]{4})?\n"
            },
            {
                "text": " \n\n```\n^[0-9]{4}[0-9]{2}[0-9]{2}[0-9]{2}$\n```\n\n# 8.2.5 Matching and"
            },
            {
                "text": " For this description, the year field has to start with a 1 and end with a 6. You would need to use the ^ and $ anchors.\n\n- \"112312\"\n- \"1212121212121212121212121212"
            }
        ]
    },
    {
        "expression": "^(\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)$",
        "raw_prompt": "yyMMdd with leap years.\nMinimized expression.\nAs we have only 2 numbers for the years, dates 1600, 2000, etc are still validated.",
        "refined_prompt": "yyMMdd with leap years.\r\nMinimized expression.\r\nAs we have only 2 numbers for the years, dates 1600, 2000, etc are still validated.\nMatch examples:\n- \"001231\"\n- \"000229\"\n- \"040229\"\nNon-match examples:\n- \"003112\"\n- \"000431\"",
        "matches": [
            "001231",
            "000229",
            "040229",
            "351119",
            "600229",
            "040229",
            "720229",
            "880508",
            "440930",
            "250901",
            "760229",
            "231230",
            "861031"
        ],
        "non_matches": [
            "003112",
            "000431",
            "010229",
            "481565",
            "879875",
            "954987",
            "985687",
            "987654",
            "654987",
            "846257",
            "842613",
            "971397"
        ],
        "id": 914,
        "output": [
            {
                "text": " /^0?[1-9]\\d{3}[2-9]\\d{4}$/.\nExample:\nvar regex = /^0?"
            },
            {
                "text": " \"^0?[1-9]\\d|10[0-9]\\d|100[0-9]$\"\n- \"0201\"\r\n"
            },
            {
                "text": " [0-9]{4}[0-9]{2}[0-9][0-9]{2}\n- \"001223\"Generate"
            },
            {
                "text": "\r\n[\\b\\d{4}-\\d{2}-\\d{2}\\b]\r\n\r\n- [\\d]{3}["
            },
            {
                "text": " \n^(0[1-9]|10[1-9])[0-9]{3}$  (e.g. \"10002\")\n"
            },
            {
                "text": " (00\\d\\d\\d\\d) \n- \"001331\"\n- \"000439\"\n\"\"\"\r\n\r\n\r\ndef create_re"
            },
            {
                "text": " (\\\\d{4})([0-1])(\\\\d{2})\n- \"0003\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": " (a) ((0+1)+1)((0+1)+1) (0+1)((0+1)+1) (0+1+1)(0"
            },
            {
                "text": " (\\d{7}|\\d{6}) or \\d{3}(\\d{2})\\d{2} or \\d{2}(\\d{"
            },
            {
                "text": " (?<!0)(?<!a)(?<a!0)(?<!1)(?<!2)(?<3)(?<4)(?<"
            }
        ]
    },
    {
        "expression": "^([01]\\d|2[0123])([0-5]\\d){2}$",
        "raw_prompt": "HHmmss without any separators. Hours in 24h format.",
        "refined_prompt": "HHmmss without any separators. Hours in 24h format.\nMatch examples:\n- \"235959\"\n- \"000000\"\n- \"012345\"\nNon-match examples:\n- \"240000\"\n- \"23:59:59\"",
        "matches": [
            "235959",
            "000000",
            "012345",
            "035005",
            "103026",
            "230303",
            "021912",
            "223112",
            "213234",
            "193556",
            "175345",
            "233704",
            "215341"
        ],
        "non_matches": [
            "240000",
            "23:59:59",
            "236060",
            "489797",
            "987987",
            "654987",
            "654654",
            "789789",
            "789456",
            "456789",
            "984657",
            "954768"
        ],
        "id": 915,
        "output": [
            {
                "text": " ^[0-9]{1,2}[0-9]{1,2}[0-9]{1,2}[0-9]{1,2}$\n\n4. Regular Expression to match a list of strings\nWrite a"
            },
            {
                "text": " This is a task that will require some extensive research. You may need to consult the official documentation on regular expressions to generate a satisfactory answer.\n\nExercise 3:\nGenerate a list of all the numbers from 0 to 100 that do not contain the digit 9.\nAnswer"
            },
            {
                "text": " ^[05-9]{1}:[0-5][0-9][0-9]?([0-5][0-9])?[0-5][0-9]:[0-5][0-9]:[0-5][0"
            },
            {
                "text": " (00)+([0-9]|[1-9])([0-9]|[1-9])([0-9]|[1-9])\n\nExercise 3:\nMatch the following patterns to their respective search strings:\n-"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\n\n4. Write a Python function that takes a list of strings and returns a list of tuples where each tuple"
            },
            {
                "text": "\nThe RegEx should be the same as the previous examples.\n\n3. Write a python code that will verify if a user has entered a valid IP address.\nHints:\n- An IP address is a series of four numbers, each separated by a dot.\n"
            },
            {
                "text": " \n\nimport re\n\ndef generate_regex(pattern):\n    regex = re.sub(r'[A-Za-z0-9]', r'(?P<\"\\g<0\">)\"', pattern)\n    re"
            },
            {
                "text": " [0-9]{1,2}:[0-9]{2,4}[0-9]{0,}\n2. Write a function that takes a text string as input, and uses regular expressions to find all dates in the format \"DD/"
            },
            {
                "text": " \n\nimport re\n\ntext = \"235959\"\npattern = r\"\\d{1}[0-2]\\d{1}[0-6]\\d{1}[0-9]\\d{1}\"\n\nresult"
            },
            {
                "text": " /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/\n\nExercise 2: Given a list of strings that can have digits, letters, or both, write"
            }
        ]
    },
    {
        "expression": "(^\\d*\\.?\\d*[0-9]+\\d*$)|(^[0-9]+\\d*\\.\\d*$)",
        "raw_prompt": "This matches all positive decimal values. There was one here already which claimed to but would fail on value 0.00 which is positive AFAIK...",
        "refined_prompt": "Matches all positive decimal values.\nMatch examples:\n- \"0.00\"\n- \"1.23\"\n- \"4.56\"\nNon-match examples:\n- \"-1.03\"\n- \"-0.01\"",
        "matches": [
            "0.00",
            "1.23",
            "4.56",
            "485.48956",
            "615.546",
            "456.849",
            "5.549",
            "684.21",
            "98.21",
            "64.21",
            "654.2",
            "5198.15",
            "4859.12"
        ],
        "non_matches": [
            "-1.03",
            "-0.01",
            "-0.00",
            "-9851.156",
            "-15.18",
            "-56.2954",
            "-5.5948",
            "-516.21",
            "-5164.5",
            "-5943.975",
            "-645.0125",
            "-56.2464"
        ],
        "id": 916,
        "output": [
            {
                "text": " r'^[+-]?([1-9]?\\d*\\.)?([1-9]?\\d*)([eE][+-]?\\d+)?$'\n\nExercise 4: Match all hexadecimal color codes.\nMatch examples:"
            },
            {
                "text": " r\"^-?\\d\\.?\\d*$\"\n\n3. Write a Python code to check if a string matches the pattern: \"^[a-zA-Z0-9_\\-\\.]+$\".\nAnswer: \n```python\nimport re\n\n"
            },
            {
                "text": " A decimal value that starts with a number, followed by zero or more digits and an optional decimal point, followed by another zero or more digits.\n\nExercise 4: Match email addresses to their respective domains.\nMatch example:\n- \"john.doe@gmail.com\"\n- \"j"
            },
            {
                "text": " ^([+-]?)(\\d*\\.\\d+)([eE][+-]?\\d+)$\n\nExercise 5: Match all numbers in scientific notation: 1.23e4, 3.45e+6, 7.89e-10.\nAnswer:"
            },
            {
                "text": " ^[0-9]\\.[0-9]?$\n\n3. Write a Python code that generates a list of all matches for the following pattern:\nMatch examples:\n- \"1-2-3-4-5\"\n- \"1.2.3.4.5"
            },
            {
                "text": ".+?[\\d]?[.]?[\\d]+\n- \"3.12.4\"Generate a RegEx for this description.\n\n4. Write a Python function that takes a list of customer data and a threshold value, and returns a list of all customer details that meet"
            },
            {
                "text": " (.*)(-)(.*)(.)\"\n\nExample:\n>>>import re\n>>>re.findall(r'\\d{0,2}\\.\\d{0,2}|\\d{0,2}[-.]\\d{0,2}', '0."
            },
            {
                "text": " \n\nTo solve this problem, we need to identify the pattern of positive and negative decimals. We can start by matching every positive decimal value by repeating the same pattern as the positive decimal value, followed by a decimal point. For example, we can match \"0.00\" by repeating \"0"
            },
            {
                "text": "\n[^-0-9.]\n\nExercise 3 Solution:\n#import re module\nimport re\n\n# Define a list of strings\nstrings = [\"1.23\", \"-1.03\", \"-0.01\", \"0.00\", \"4.56\"]\n\n#"
            },
            {
                "text": " [-0-9\\.\\ -]+\n\nLecture Note: 2.2.6 How to Use Flags and Groups to Customize Regex Expressions\n\nContents:\n1. Introduction to Flags and Groups\n2. Flags in Regular Expressions\n3. Groups in Regular Expressions\n"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|1[012])/(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])/(29|30)|(0[13578]|1[02])/31)/[2-9]\\d{3}|02/29/(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "MM/dd/yyyy with 100% leap year validation starting from year 2000.\nIf this one doesn't fit your needs, just tell me.\nSorry for starting &quot;only&quot; from year 2000, this is so simple to change this, please ask if needed.\nEnjoy",
        "refined_prompt": "MM/dd/yyyy with 100% leap year validation starting from year 2000.\nMatch examples:\n- \"02/29/2000\"\n- \"02/29/2004\"\n- \"12/31/2001\"\nNon-match examples:\n- \"02/29/2100\"\n- \"02/29/2001\"",
        "matches": [
            "02/29/2000",
            "02/29/2004",
            "12/31/2001",
            "11/21/9802",
            "01/28/9466",
            "07/31/8066",
            "02/29/2344",
            "02/29/8608",
            "02/29/9404",
            "10/31/5991",
            "10/31/8787",
            "02/29/5496",
            "02/29/8608"
        ],
        "non_matches": [
            "02/29/2100",
            "02/29/2001",
            "1/1/2001",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 918,
        "output": [
            {
                "text": "^(0[1-9]|1[012])\\/([3-9]|[1-2][0-9]|3[01])\\/([0-9]{4"
            },
            {
                "text": " \n\n/^(0?[1-9]\\d|1\\d\\d|2[0-9]\\d|201[0-9]|2020){1,"
            },
            {
                "text": " \"^m\\\\d{2}/\\\\d{2}/\\\\d{4}$\" \n- \"12/31/2005\"\n- \"12/31/2001\"\n"
            },
            {
                "text": "  ^-?[1-9]\\d?(?:-[1-9]\\d?)?$\n- \"12/31/2004\"\n- \"01/30/19"
            },
            {
                "text": "\n(?<year>\\d{4})/(?<month>\\d{2})/(?<day>\\d{2})/(?<leapyear>\\"
            },
            {
                "text": "\n/^[2-9][0-9][0-9]/\n\nExercise 2:\nGiven the list of dates below, create a RegEx to match dates that start with a"
            },
            {
                "text": " [0-9]{2}-[0-9]{2}-[0-9]{4} \n\nExercise 3:\nWrite a RegEx for a phone number with the"
            },
            {
                "text": "\n- \"^[0123][0-9]?[0-9]?$|^[12][0-9]/[0-9]/[0-9]$"
            },
            {
                "text": "\n\nMy regex code:\nvar dateRegex = /^([0-9_]{1,2}/[0-9_]{1,2}/[0-9"
            },
            {
                "text": "\nr'^\\d\\d/\\d\\d/\\d\\d\\d$'\n\nScenario 4: \nJohn, a web developer, wants to implement a feature that"
            }
        ]
    },
    {
        "expression": "^\\-?[0-9]{1,3}(\\,[0-9]{3})*(\\.[0-9]+)?$|^[0-9]+(\\.[0-9]+)?$",
        "raw_prompt": "Formatted Number with \",\" as thousand separator and \".\" as decimal separator. now accept numbers without separators of thousands.",
        "refined_prompt": "Formatted Number with \",\" as thousand separator and \".\" as decimal separator. now accept numbers without separators of thousands.\nMatch examples:\n- \"10,000,000.123\"\n- \"3.14159265\"\n- \"546.4985\"\nNon-match examples:\n- \"2.7,1828183\"\n- \"49.26484,65\"",
        "matches": [
            "10,000,000.123",
            "3.14159265",
            "546.4985",
            "834.4897",
            "45.5194",
            "2.1569",
            "54.5497",
            "5.21945",
            "5.5675",
            "56.24957",
            "2.219",
            "2.54",
            "3.2465"
        ],
        "non_matches": [
            "2.7,1828183",
            "49.26484,65",
            "83.2149,",
            "652498,4.21,",
            "65.591,.51,6",
            "1984,.54.",
            "561.2162.546",
            ".2162.0246265,456",
            ".516,815.916",
            ".2,165",
            "462,561.,516,4",
            "156.2462451,165,"
        ],
        "id": 919,
        "output": [
            {
                "text": " The RegEx is ^[0-9]{1,3}[,.][0-9]{1,3}$"
            },
            {
                "text": "\n(?<!\\d,)(?<!\\d.\\d)(?<!\\d,?\\d)(?"
            },
            {
                "text": " (?<=^\\d+)\\.(\\d{3})(?=,\\d)?|(?<=^\\"
            },
            {
                "text": "  ^\\d{1,3}[,\\.]?\\d{0,3}(?:\\.\\d{3"
            },
            {
                "text": " r'([\\d.,]*)(\\d+)'\n\nI've done it, but it would be great if someone could give"
            },
            {
                "text": "\nimport re\n\nclass Tester:\n    def test_comma_separator(self):\n        text = '10,"
            },
            {
                "text": "\n\n(?<!\\d)(\\d{1,3}(,\\d{3})?)+$\n\nEx"
            },
            {
                "text": " The regex I came up with is ^([0-9]+)([.,])([0-9]+)$\n\nA:"
            },
            {
                "text": " ^(?:(\\d+)(?:,\\d{3})?)?(?:\\.(\\d+))?$\n\nA"
            },
            {
                "text": "\n\\d+[,\\.]?\\d+.?\\d*\n\nTutor: That's very good! You seem to"
            }
        ]
    },
    {
        "expression": "[AaEeIiOoUuYy]",
        "raw_prompt": "This simple reg-ex accepts any vowel letter.",
        "refined_prompt": "This simple reg-ex accepts any vowel letter(AEIOUYaeiouy).\nMatch examples:\n- \"a\"\n- \"o\"\n- \"e\"\nNon-match examples:\n- \"z\"\n- \"x\"",
        "matches": [
            "a",
            "o",
            "e",
            "i",
            "u",
            "y",
            "A",
            "E",
            "I",
            "O",
            "U",
            "Y"
        ],
        "non_matches": [
            "z",
            "x",
            "W",
            "T",
            "P",
            "l",
            "k",
            "j",
            "h",
            "g",
            "f",
            "d"
        ],
        "id": 923,
        "output": [
            {
                "text": "\n[aeiouy](?!e$)\n(explanation) Negative lookahead ensures that the character following the vowel letter is not an 'e' at the end of the word.\n\nExercise 5:\nWrite a reg-ex for this explanation.\nAnswer:\n"
            },
            {
                "text": " \n(?i)(a|e|i|o|u|y)\n\nExercise 2: RegEx that selects words with more than two vowels\n1. Use RegEx to select words with more than two vowels\nWordList = cat, dog, bird, fish"
            },
            {
                "text": " (A)+\n[0-9]+[a-z]\n[a-z]+[0-9]|[a-z]+(0[a-z]?)\n[a-z]+(0[a-z]?)[0-9]\n[a"
            },
            {
                "text": " ^[aeiouyaeiouy]*$\n\n(2) Write a Python code that will match a string with at least 6 characters, only contains uppercase or lowercase letters. \nAnswer: ^[A-Za-z]{6,}$"
            },
            {
                "text": " [aeiouy]\n\n2. Write a regular expression that matches any uppercase letters.\nAnswer: [A-Z]\n\n3. Write a regular expression that matches any punctuation marks.\nAnswer: [.,;:!?-]\n\n4. Write a"
            },
            {
                "text": " \n\\b[aeiouyAEIOUYaeiouy]+\\b\n\nExercise 2:\nUse the RegEx created above to check if the string \"Hello World\" contains any vowel. \nAnswer:\n>>> regex = re.compile('\\b"
            },
            {
                "text": " [A-Za-z0-9_]\n\n2. Write a RegEx to accept any digit.\nAnswer: [0-9]\n\n3. Write a RegEx to accept any set of two or three consecutive digits.\nAnswer: [0-9]{"
            },
            {
                "text": "\n\nimport re\n\nregex = '^[AEIOUYaeiouy]*$' #accept any vowel letter(AEIOUYaeiouy) \n\ndef match(text):\n    regex = re.compile(regex)\n"
            },
            {
                "text": " ^([^aeiouyaeiouy]*[aeiouyaeiouy]+[^aeiouyaeiouy]*)*$\n\n4. Write a Python program that generates a random password consisting of 8 characters from the letters A-Z and"
            },
            {
                "text": " ^[^aeiouyAEIOUYaeiouy]$\n\nPart 2: List of Words\nTo complete this exercise, create a list of 5 words that contain the vowels (aeiouy), excluding the letter 'y'. \n\nAnswer: \n"
            }
        ]
    },
    {
        "expression": "^(?=.*[1-9].*$)\\d{0,7}(?:\\.\\d{0,9})?$",
        "raw_prompt": "Allows up to seven digits to the left and up to nine digits to the right of an optional decimal place.\nLeading zeros on the left of the decimal are accepted.\nOnly positive values are accepted.",
        "refined_prompt": "Allows up to seven digits to the left and up to nine digits to the right of an optional decimal place.\r\nLeading zeros on the left of the decimal are accepted.\r\nOnly positive values are accepted.\r\nRefined prompt:\nMatch examples:\n- \"1\"\n- \"0123456.123456789\"\n- \".123456789\"\nNon-match examples:\n- \".0123456789\"\n- \"0.0\"",
        "matches": [
            "1",
            "0123456.123456789",
            ".123456789",
            "456.549",
            "849.2462",
            "456.3456",
            "876.2466",
            "789549.246",
            "456.54987",
            "561.2154",
            "987.216897",
            "2495897.2165",
            "496"
        ],
        "non_matches": [
            ".0123456789",
            "0.0",
            "-1",
            "8941568456357.126",
            "8944563569516.21645",
            "19564.1985412657462",
            "95844563234546",
            "-945162",
            "-9565-+6*/8-95",
            "-+695-69-56",
            "-5+62-9+65/8956",
            "6++23"
        ],
        "id": 926,
        "output": [
            {
                "text": " r\"^[1-9][0-9]*"
            },
            {
                "text": " ^[1-9]\\d{0,3}"
            },
            {
                "text": " r'^[0-9a-zA-Z"
            },
            {
                "text": " \\d{1,7}\\.\\d{1,"
            },
            {
                "text": " \"^\\d\\d\\.\\d{9}$"
            },
            {
                "text": " (^^?[1-9]\\d{0"
            },
            {
                "text": " [0-9]+(\\.[0-9]{"
            },
            {
                "text": " *(?<digit>\\d*)(?:(\\."
            },
            {
                "text": " [0-9]\\d*(\\.\\d+"
            },
            {
                "text": " \r\n\\A[0-9]{1,"
            }
        ]
    },
    {
        "expression": "\\{\\\\\\*\\\\bkmkstart\\s(.*?)\\}",
        "raw_prompt": "Applied to a .RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.",
        "refined_prompt": "Applied to a .RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"",
        "matches": [
            "{\\*\\bkmkstart TagAmountDigits}",
            "({\\*\\bkmkstart TagAmountText}",
            "{\\*\\bkmkstart\u2029ypQVK]b[,k`}",
            "{\\*\\bkmkstart\u2005}",
            "{\\*\\bkmkstart\u2008asdfa}",
            "{\\*\\bkmkstart\u2008ewfwdz}",
            "{\\*\\bkmkstart\u2008wdfasdaz}",
            "{\\*\\bkmkstart\u20082efsdffz}",
            "{\\*\\bkmkstart\u2008sdfz}",
            "{\\*\\bkmkstart\u2008adsfz}",
            "{\\*\\bkmkstart\u2008zadsfwe}",
            "{\\*\\bkmkstart\u2008hgfdhz}",
            "{\\*\\bkmkstart\u2008zkjhgk}"
        ],
        "non_matches": [
            "{\\*\\bkmkend TagAmountText}",
            "{\\*\\bkmkend fadsfqf}",
            "{\\*\\bkmkend TagAmdsfaountText}",
            "{\\*\\bkmkend adsf}",
            "{\\*\\bkmkend asdfsad}",
            "bkmkstartf2ef2e",
            "bkmkstartj676u",
            "bkmkstart67ju67",
            "bkmkstart67m7",
            "bkmkstartn67n6",
            "bkmksg76tart",
            "67hvbkmkstart"
        ],
        "id": 933,
        "output": [
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            },
            {
                "text": "Applied to a.RTF document, returns all the names of the# bookmarks. Useful to retrieve# dinamically# the list of bookmarks from a document.\nMatch examples:\n- \"{\\*\\bkmkstart TagAmountDigits}\"\n- \"({\\*\\bkmkstart TagAmountText}\"\n- \"{\\*\\bkmkstart\u2029ypQVK]b[,k`}\"\nNon-match examples:\n- \"{\\*\\bkmkend TagAmountText}\"\n- \"{\\*\\bkmkend fadsfqf}\"\n"
            }
        ]
    },
    {
        "expression": "\"[^\"\\r\\n]*\"",
        "raw_prompt": "returns string between two quotes",
        "refined_prompt": "returns string between two quotes\nMatch examples:\n- \"Return Parent.DB.GetDataReader(\"CauseImmediateGet\", MyIncidentEventTypeID)\"\n- \"\"fadsfds\"\"\n- \"\"fwubeh98hu\"h9io\"\nNon-match examples:\n- \"Return Parent.DB.GetDataReader(CauseImmediateGet\", MyIncidentEventTypeID)\"\n- \"fewf\"Fsdf\"",
        "matches": [
            "Return Parent.DB.GetDataReader(\"CauseImmediateGet\", MyIncidentEventTypeID)",
            "\"fadsfds\"",
            "\"fwubeh98hu\"h9io",
            "fsiudjfn\"fsdij\"",
            "\"fhuidsh9i\"",
            "HUI\"ufijsd\"",
            "uibjks\"g8qw\"",
            "huds\"78gu832\"",
            "hui\"hfuisdy8\"",
            "\"reuwu\"",
            "\"hufij\"",
            "u90io\"ruew8ori23\"",
            "uio\"u8r932u\""
        ],
        "non_matches": [
            "Return Parent.DB.GetDataReader(CauseImmediateGet\", MyIncidentEventTypeID)",
            "fewf\"Fsdf",
            "FDS\"FD",
            "12/123/4322",
            "2346-2\"F345-2435",
            "\"2/3/5235",
            "@#dfk\"jnav",
            "12f3.21\"f3.213f",
            "\"qwerty@123.123",
            "341.4\"31v4f3.fv1",
            "abc11\"1def",
            "0j0jweB\"BBB"
        ],
        "id": 936,
        "output": [
            {
                "text": "\n#\"%[1234567890]+\"\n\nA:\n\nYou can do this"
            },
            {
                "text": " \n^\\\".*?\\\"$\n\nExercise 2: Create a RegEx pattern for"
            },
            {
                "text": "\n-^(?:\\\".*?\\\"|\\\".*?\\\")[^\"]+"
            },
            {
                "text": " (\\w+)\\s*(.+?)(?=\\s*\\\")\n\n"
            },
            {
                "text": " (\\w+)\"(?:\\s\\w+)*\"\n\nThis is my code:"
            },
            {
                "text": "   ^.*?(?<=\\)(\"CauseImmediateGet\")$\n\nA:"
            },
            {
                "text": " /(?<=\")[^\"]+\"/\n\nI'm having trouble making this work"
            },
            {
                "text": "\nMatch examples: \"Return Parent.DB.GetDataReader(CauseImmediateGet, MyInc"
            },
            {
                "text": " ^[a-zA-Z0-9]+(\\s[a-zA-"
            },
            {
                "text": "  [^\"]+\n\nExercise 3:\nMatch string which begins with a letter A-"
            }
        ]
    },
    {
        "expression": "^\\d{3}-\\d{7}[0-6]{1}$",
        "raw_prompt": "Airway bill no that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.",
        "refined_prompt": "Airway bill No. that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9.\nMatch examples:\n- \"999-99999995\"\n- \"123-47859683\"\n- \"156-78965422\"\nNon-match examples:\n- \"123-47859689\"\n- \"9999999999\"",
        "matches": [
            "999-99999995",
            "123-47859683",
            "156-78965422",
            "319-78344900",
            "961-21496451",
            "767-65572445",
            "721-23909015",
            "662-31756823",
            "287-18129794",
            "044-95274085",
            "866-43239106",
            "476-20607603",
            "990-35637882"
        ],
        "non_matches": [
            "123-47859689",
            "9999999999",
            "9588-58964",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 937,
        "output": [
            {
                "text": " (.*)$\n\nExercise 2: Password validation\nCreate a code that generates a password and validates it according to the following rules:\n-"
            },
            {
                "text": ".+[0-9]{6}-[0-9]{5}-[0-9]{4}\n\n(3) Write"
            },
            {
                "text": " ^[0-9]{3}-?[0-9]{8,9}$\n\nExercise 2: \nExercise"
            },
            {
                "text": "\n(\\d{9,9})(?!7)-(\\d{8,7})\n\nExercise 2:\nWrite a regular expression to replace"
            },
            {
                "text": "\n[0-9]{3}-?[0-9]{3}-?[0-9]{4}\n\nEx"
            },
            {
                "text": " The RegEx should look like this: (999-999999). The final number should not have the last digit as a 7, 8, 9.\n"
            },
            {
                "text": "\n\\d{3}-?\\d{3}-?\\d{4}\n\nExercise 5:\nWrite a RegEx to"
            },
            {
                "text": "\n\nimport re\n\ntestString1 = \"999-99999995\"\ntestString2 = \"123-47859683\"\ntestString"
            },
            {
                "text": " (?<![0-9])\\\\(\\d{3}-\\d{3}-\\d{4}(?!\\d|"
            },
            {
                "text": "\n\"999[-\\d]{9}\"\n\nExercise 3:\nDetermine the following expressions:\n1. \"^[a"
            }
        ]
    },
    {
        "expression": "(^[0-9]*[1-9]+[0-9]*\\.[0-9]*$)|(^[0-9]*\\.[0-9]*[1-9]+[0-9]*$)|(^[0-9]*[1-9]+[0-9]*$)",
        "raw_prompt": "Positive real number greater than zero.",
        "refined_prompt": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR .\"\n- \"010001.011010E\"",
        "matches": [
            "0.01",
            "010001.011010",
            ".234",
            "156",
            "456",
            "46",
            "873857",
            "687",
            "68",
            "46.46845",
            "546.23453",
            "486.278",
            "987.12659"
        ],
        "non_matches": [
            "0.00 OR .",
            "010001.011010E",
            "1.234.5",
            "498.4564t",
            "7fgy",
            "f7gyf324",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 940,
        "output": [
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: (0\\.[01]|\\.0)+\n\nExercise 3: Identify the type of pattern matching in the following regex:\n(a|b|c)\nAnswer: Alternation\n\nExercise 4: Create a regex pattern for a phone number consisting"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: ^(0\\.?[0-9]*)?[0-9]*\\.?[0-9]*$\n\nIn conclusion, the use of Python's Regular Expressions module, specifically the `re` module, significantly enables the seamless implementation of Search"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer:\n\n0\\.01[0-9]*E|0.01[0-9]*\n\nUse Case 2:\n\nA debate is taking place between two teams about the best use of RegEx. Team A argues that it is best to use Reg"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: (0?[1-9]\\d*|1[012]\\d*|2[01]\\d*|25[0-5]|[1-9]\\d*|\\d{2,3}(?:\\.\\"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer:.{0,}1[0-9]\\.1[0-9]\n\n5. What is a negative lookahead?\nAnswer: A negative lookahead is a zero-width assertion that checks whether a certain pattern (or a range of characters) does"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer:\n|  0.0   |  0.01   |  0.02   |  0.03   |  0.04   |  0.05   |  0.06   |  0.07   |  0.08   |"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer:\n^[0-9]*\\.[0-9]+$\n\nExercise 2:\nUsing the same data from Exercise 1, generate a RegEx pattern for a time in the format \"HH:MM AM/PM.\"\nAnswer:\n^([01"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: (0\\.0(1[01]|[01]\\d|[2-9]))\n\n**Exercise 3:** Write a RegEx pattern to match an email address.\n\nMatch examples:\n- \"john.doe@gmail."
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: \nMatch examples: [.\\d]{2}\\[s\\]?[0-9]{1,2}[.\\d]{3}\\[e\\]?[0-9]{1,2}\nNon-match examples"
            },
            {
                "text": "Positive real number greater than zero.\nMatch examples:\n- \"0.01\"\n- \"010001.011010\"\n- \".234\"\nNon-match examples:\n- \"0.00 OR.\"\n- \"010001.011010E\"Generate a RegEx for this description. \nAnswer: \"^[0-9]*$\"\n\nExercise 3:\n\nMatch the following regular expression patterns to their descriptions:\n\na. \"^[0-9]*$\"\nb. \"^[a-z]*$\"\n"
            }
        ]
    },
    {
        "expression": "^((\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|\\d\\d|[0-1]\\d\\d|2[0-4]\\d|25[0-5]))$",
        "raw_prompt": "Matches valids TCP/IP-Adresses",
        "refined_prompt": "Matches valids TCP/IP-Adresses.\nMatch examples:\n- \"1.198.0.1\"\n- \"100.10.0.1\"\n- \"200.200.123.123\"\nNon-match examples:\n- \"..12.23\"\n- \"a.23.345\"",
        "matches": [
            "1.198.0.1",
            "100.10.0.1",
            "200.200.123.123",
            "248.039.254.226",
            "0.41.53.4",
            "41.245.010.252",
            "238.208.55.203",
            "212.130.0.2",
            "218.087.14.216",
            "230.68.31.202",
            "91.223.255.4",
            "254.12.067.225",
            "9.010.002.0"
        ],
        "non_matches": [
            "..12.23",
            "a.23.345",
            "400.500.300.300",
            "23r.32r32",
            "r2.323.25",
            "r..t34.t34.",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12). 62509",
            ".gm.ail"
        ],
        "id": 946,
        "output": [
            {
                "text": "  [[IP-Address / Domain-Name / IP Range]]\nExpected output:\n{\n    IP-Address: \"1.198.0.1\",\n    Domain-Name: \"1."
            },
            {
                "text": " \nRegex for IPv4 addresses: \n\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\"
            },
            {
                "text": " \"^[0-9]+\\.\\.[0-9]+\\.\\.[0-9]+$\"\n\nExercise 2: Using RegEx, write a Python program to check if a given string starts"
            },
            {
                "text": " (?<=\\.)[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,"
            },
            {
                "text": " /([\\d\\.]+)/\nIllustration:\n        Maria and John are roommates. Maria is a vegetarian and John is not. They both decide to cook pasta for dinner. Maria chooses a vegetable"
            },
            {
                "text": " \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\")\n\nExercise 4:\nCreate a RegEx for"
            },
            {
                "text": "\n\nimport re\n\n# Accept only valid IP/Port/Host-names\ndef valid_ip_port_hostname(ip_port_hostname):\n  if re.match(r'"
            },
            {
                "text": " \n^\\d+(\\.\\d+){3}$\nLecture Note: 6.4.2 The basic syntax and semantics of regular expressions\n\nContents:\n- What are regular expressions"
            },
            {
                "text": "\n^.+?[\\d.]+$\n\nExercise 4:\nWrite a Python program that generates a regular expression to match a user who entered a password that fulfills the following criteria:\n-"
            },
            {
                "text": " [0-9]{3}\\.\\d{3}\\.\\d{3}\\.\\d{3}\n\nExercise 2:\nWrite a function named \"validate_ip_address"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "MM/dd/yyyy with 100% leap years. Valid since year 1900.\nMM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy\nThis was a request from a user in http://www.regexlib.com/REDetails.aspx?regexp_id=1038",
        "refined_prompt": "MM/dd/yyyy with 100% leap years. Valid since year 1900.\r\nMM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy\nMatch examples:\n- \"01/31/1905\"\n- \"1/9/1900\"\n- \"2/29/1904\"\nNon-match examples:\n- \"31/01/2005\"\n- \"02/29/2005\"",
        "matches": [
            "01/31/1905",
            "1/9/1900",
            "2/29/1904",
            "05/11/7125",
            "6/30/2193",
            "02/29/9200",
            "02/29/5200",
            "12/31/1968",
            "9/07/9325",
            "07/24/9722",
            "12/30/5484",
            "7/31/7906",
            "2/29/1912"
        ],
        "non_matches": [
            "31/01/2005",
            "02/29/2005",
            "2/29/2005",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 947,
        "output": [
            {
                "text": "\n\nlet date = '31/01"
            },
            {
                "text": " [0-9][0-9]["
            },
            {
                "text": "\nDate(MM|dd|yyyy"
            },
            {
                "text": " (\\d{1,2}\\/"
            },
            {
                "text": " [0-9][012]/["
            },
            {
                "text": " Match examples (M/d/yyyy"
            },
            {
                "text": " (?<month>\\d{1"
            },
            {
                "text": " M/d/yyyy or mm/"
            },
            {
                "text": "\n- (?i)((?<"
            },
            {
                "text": " [0-9]{1,2"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z].*|[1-9].*)\\.(((j|J)(p|P)(g|G))|((g|G)(i|I)(f|F)))$",
        "raw_prompt": "Regular expression to limit types of files accepted. This example matches .jpg and .gif files only.",
        "refined_prompt": "Regular expression to limit types of files accepted. This example matches .jpg and .gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"",
        "matches": [
            "filename.jpg",
            "FileName.JPG",
            "filename.gif",
            "fdsfs.jpg",
            "fvystd.jpg",
            "yug78.JPG",
            "g67fg.JPG",
            "q76f.JPG",
            "q7f.JPG",
            "q76f.GIF",
            "yh98h.GIF",
            "78tgy8.GIF",
            "g7yhb.GIF"
        ],
        "non_matches": [
            "filename.png",
            "filename.xxx",
            "filename.bmp",
            "f23ewf.dhua",
            "g78u.7y8uh",
            "f34.34f34",
            "f34.t3545y",
            "jpgjpg",
            "gif",
            "gpjjgpig",
            "jpggifjpg",
            "jpgif"
        ],
        "id": 949,
        "output": [
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: r\"^[a-zA-Z0-9_\\-]+\\.[a-zA-Z0-9_\\-]*\\.([a-zA-Z0-9_\\-.]+["
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: (\\b\\w+\\.\\w+\\.\\w\\b|\\.\\w+\\.\\w\\.\\w+|\\.\\w+\\.\\w|\\.\\w+\\.\\w\\.)+\n"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer:\n\n```python\nimport re \n\n# Match.jpg and.gif files only\nallowed_files = re.compile(r'^.*\\.\\w+$')\n\n# Match examples\nexample1"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer:\n```python\nimport re\nfile_name = \"filename.jpg\"\nif file_name.endswith((\".jpeg\", \".jpg\", \".gif\")):\n    print(f\"{file_name"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: ^\\.(\\w+)(\\.(\\w+)(?:\\.(\\w+))?)$\n\n#### Exercise 5\n\nWrite a Python code that uses regular expressions to extract all email addresses from a file containing multiple emails"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer:\n\"^(?=.*\\.jpg$)(?=.*\\.gif$).*$\"\n\n### Exercise 5:\nWrite a Python script to check if the current directory contains a file named \"resume.txt\"."
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: (.*?[.\\w]+)\\.jpg|(.*?[.\\w]+)\\.gif\n\n3. Write a RegEx to validate a password based on the following criteria:\n- At least 8 characters long"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: I think the expression should be [^.jpg\\.]+$ to match non-jpg or non-gif files.\n\nExercise 3: \nCreate a Python script that uses a regular expression to find all the IP addresses"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer: [a-zA-Z]+\\.(jpg|gif)\n```\n\n3. Write a regular expression to validate that an email address follows the format of username@domain.\n\nIdeas: This exercise allows us"
            },
            {
                "text": "Regular expression to limit types of files accepted. This example matches.jpg and.gif files only.\nMatch examples:\n- \"filename.jpg\"\n- \"FileName.JPG\"\n- \"filename.gif\"\nNon-match examples:\n- \"filename.png\"\n- \"filename.xxx\"Generate a RegEx for this description. \nAnswer:\n\nimport glob\npattern = \"filename\\.([a-zA-Z0-9-_.]+)\"\nfiles = glob.glob(\"C:\\\\Users\\\\username\\\\Documents\\\\Images\\\\*\")\n"
            }
        ]
    },
    {
        "expression": "^(\\$\\ |\\$)?((0|00|[1-9]\\d*|([1-9]\\d{0,2}(\\,\\d{3})*))(\\.\\d{1,4})?|(\\.\\d{1,4}))$",
        "raw_prompt": "Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign. Also makes sure theres no more than 4 decimal places. Takes out leading zeros if the number isn't 0, and protects against blank entries.",
        "refined_prompt": "Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign. Also makes sure theres no more than 4 decimal places. Takes out leading zeros if the number isn't 0, and protects against blank entries.\nMatch examples:\n- \"$ 123.4\"\n- \"$00.5\"\n- \"200,000\"\nNon-match examples:\n- \"$012,234.44\"\n- \"-39.05\"",
        "matches": [
            "$ 123.4",
            "$00.5",
            "200,000",
            "$48",
            "$486",
            "$845",
            "$ 513",
            "$453.15",
            "$483.1",
            "$486.1",
            "$987.6",
            "818",
            "987"
        ],
        "non_matches": [
            "$012,234.44",
            "-39.05",
            "$45,23,330.00",
            "$12/123/4322",
            "$2346-2345-2435",
            "$43.v234",
            "$/5/5/5",
            "$/5/5/20022",
            "$qwerty@123.123",
            "$adfa2",
            "(0xx12) 62509$",
            "$12/132/90"
        ],
        "id": 952,
        "output": [
            {
                "text": " \\$[0-9]+\\.[0-9]{1"
            },
            {
                "text": " ^\\d+(?:\\.\\d{1,3})?"
            },
            {
                "text": "\n[\\d, \\d]+\\.\\d{1,2"
            },
            {
                "text": " \n(?<![\\d\\,\\.])(?"
            },
            {
                "text": "  \\d{1,3}[, ]?\\d{"
            },
            {
                "text": "\n^\\s*(?=[0-9,]*\\"
            },
            {
                "text": "\n^[\\d.]{1,4}(,\\d"
            },
            {
                "text": " \n@\"^[0-9,]+[\\s-"
            },
            {
                "text": " \"^-?\\d{,3}(?:\\.\\"
            },
            {
                "text": " \n((?:[\\d\\.]+)|[^\\d"
            }
        ]
    },
    {
        "expression": "^[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}$",
        "raw_prompt": "Simple Microsoft product key check.",
        "refined_prompt": "Simple Microsoft product key check.\nMatch examples:\n- \"12345-12345-12345-12345-12345\"\n- \"ABCDE-ABCDE-ABCDE-ABCDE-ABCDE\"\n- \"AB5DE-AB5DE-AB5DE-AB5DE-AB5DE\"\nNon-match examples:\n- \"12345-123-123456-12345\"\n- \"ABC-ABCDEF-ABCDE-ABCDE\"",
        "matches": [
            "12345-12345-12345-12345-12345",
            "ABCDE-ABCDE-ABCDE-ABCDE-ABCDE",
            "AB5DE-AB5DE-AB5DE-AB5DE-AB5DE",
            "7BCWV-OJ3E7-W2UM5-UK79C-JH6OS",
            "EFIK7-CR9SA-6WZ8A-6UNIT-LB1AU",
            "1VM9K-YGNA2-OU7IK-MKNG1-2H3K3",
            "C9AST-YJ1T3-VOAAA-T5NOL-J4URQ",
            "IBA1N-PF4LO-X8SN8-2WY27-5GYFT",
            "71BLA-GD9HQ-8W8Q9-ZZPUB-8SKJS",
            "Y6ZE7-QOBKO-T29GP-75K1R-CYJAM",
            "BR4EQ-3NDYK-14LHF-3C9KX-L7GL3",
            "TO4CZ-PQI26-F1E8Q-YKROR-J5TUC",
            "BUGGI-6ZWXO-JQOJ2-CE3GE-WUP33"
        ],
        "non_matches": [
            "12345-123-123456-12345",
            "ABC-ABCDEF-ABCDE-ABCDE",
            "12AB5-ABC-12AB567-12AB5",
            "95841984-4895-4fs8d4-15sf",
            "FDS51-F459SDFS--84D",
            "498SFD4-SFD49SD84-F489-59",
            "9FS48-FDS51984-F9DS5-5F9",
            "9F8S-849DF984-15FS9-591F",
            "954FG-591D988-494FWE599",
            "489-489FW-FS-594",
            "159-F9W5E84F-98F5",
            "8914-FWE1598-195FW"
        ],
        "id": 954,
        "output": [
            {
                "text": " \n\\b\\d{6}-\\d"
            },
            {
                "text": " (^[0-9]{12}[-"
            },
            {
                "text": " (\\d{6})-(\\d{2}"
            },
            {
                "text": " [a-zA-Z]{1,3"
            },
            {
                "text": "\n^(\\d{8}-\\d{8"
            },
            {
                "text": " \n- a(?=((?:\\d*"
            },
            {
                "text": "\nimport re\n#Generate a RegEx for this"
            },
            {
                "text": " ^(?!.*\\d)(?!.*-)(?!"
            },
            {
                "text": " /^\\d{5}-\\d{4"
            },
            {
                "text": " ^(?!.*[0-9]|[0"
            }
        ]
    },
    {
        "expression": "&amp;\\#x0*(0|1|2|3|4|5|6|7|8|B|C|E|F|10|11|12|13|14|15|16|17|18|19|1A|1B|1C|1D|1E|1F);",
        "raw_prompt": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).",
        "refined_prompt": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n- \"&amp;#x0020;\"\n- \"&amp;#xDFFF;\"",
        "matches": [
            "&amp;#x2;",
            "&amp;#x001F;",
            "&amp;#x0000000000000000000000000000000000000001B;",
            "&amp;#x000000000000000000000000000000000000000000000000000000000000000000000000004;",
            "&amp;#x0000000000000000000000000000000000000000000000000000000000000000000011;",
            "&amp;#x000000000000000000000000000001E;",
            "&amp;#x000000000000000000000000000000000001D;",
            "&amp;#xF;",
            "&amp;#x000000000000000000000001D;",
            "&amp;#x0000000000010;",
            "&amp;#xB;",
            "&amp;#x000000000000000000000000000000000000000000016;",
            "&amp;#x00000000000000000000005;"
        ],
        "non_matches": [
            "&amp;#x0020;",
            "&amp;#xDFFF;",
            "&amp;34f2vf42e",
            "&amp;12/123/4322",
            "&amp;2346-2345-2435",
            "&amp;43.v234",
            "&amp;@#dfkjnav",
            "&amp;/5/5/20022",
            "&amp;qwerty@123.123",
            "&amp;adfa2",
            "&amp;(0xx12) 62509",
            "9&amp;9999@gmail"
        ],
        "id": 957,
        "output": [
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            },
            {
                "text": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document. Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters. Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed).\nMatch examples:\n- \"&amp;#x2;\"\n- \"&amp;#x001F;\"\n- \"&amp;#x0000000000000000000000000000000000000001B;\"\nNon-match examples:\n"
            }
        ]
    },
    {
        "expression": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)|(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "raw_prompt": "Validador de CPF ou CNPJ brasileiro. Utilizado em campos que podem receber os dois valores, como um campo de busca, que pode buscar por CPF ou CNPJ, como era o meu caso.\n[00.000.000/0000-00], [123.456.789-98],[00000000000000] e [12345678998]\nEnjoy! =)",
        "refined_prompt": "The provided regex pattern appears to match strings that represent either a Danish CPR number (with or without separators) or a 14-digit numeric string, depending on the format.\nMatch examples:\n- \"00.000.000/0000-00\"\n- \"123.456.789-98\"\n- \"12345678901234\"\nNon-match examples:\n- \"12.123.123.0001.12\"\n- \"123.456.789.89\"",
        "matches": [
            "00.000.000/0000-00",
            "123.456.789-98",
            "12345678901234",
            "68874610114",
            "09B027c994/2311-87",
            "67534682031",
            "57h394u262/5229-44",
            "88842034209",
            "39929489443824",
            "45r7632515/6263-78",
            "78369540356",
            "01207658626540",
            "43050587251"
        ],
        "non_matches": [
            "12.123.123.0001.12",
            "123.456.789.89",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "34.31",
            "12/132/90"
        ],
        "id": 965,
        "output": [
            {
                "text": " \\d{4}[- ]?\\d{"
            },
            {
                "text": " The provided regex pattern appears to match strings that represent either a"
            },
            {
                "text": "\nA double-digit number with at least one separator"
            },
            {
                "text": " a(?:\\\\.|\\\\-)?[0-"
            },
            {
                "text": " [0-9][0-9].*\n\n"
            },
            {
                "text": " This pattern will match any string that starts with \"123\""
            },
            {
                "text": " \"([0-9.]{1,2}\\."
            },
            {
                "text": " \\d{3}\\.\\d{3}\\."
            },
            {
                "text": " \"([0-9]{14})\"\n\n"
            },
            {
                "text": " \\d{1,14}\\.\\d{1"
            }
        ]
    },
    {
        "expression": "(^\\d*\\.\\d{2}$)",
        "raw_prompt": "If you need a textbox to allow only positive numbers with two decimal places, try this. I wanted the user to be able to enter any type of currency amount (US of course) but also have two decimal places for database field.",
        "refined_prompt": "allow only positive numbers with two decimal places\nMatch examples:\n- \"12.56\"\n- \"0.25\"\n- \"156.56\"\nNon-match examples:\n- \"-123.45\"\n- \"1.023\"",
        "matches": [
            "12.56",
            "0.25",
            "156.56",
            "489.12",
            "4865.21",
            "89456.21",
            "89465.65",
            "8975.54",
            "489516.11",
            "49856.66",
            "49856.99",
            "54.77",
            "5219.88"
        ],
        "non_matches": [
            "-123.45",
            "1.023",
            "1.2",
            "48.218",
            "45.2",
            "189.",
            "8956.2",
            "48956.219562",
            "48956.2498.89489",
            "49825.495",
            "48953.519",
            "87"
        ],
        "id": 971,
        "output": [
            {
                "text": " r'^[-+]?[0-9]*\\.[0-9]{1,2}$'\n\nExample 3: Validating a password\nSuppose we are building a password system that requires a minimum of 8 characters, at least one uppercase letter, one lower"
            },
            {
                "text": " \"^(1[0-9]|[1-9][0-9])(\\.[0-9]){2}$\"\n\n\n\n\nPossible emails and **replies** with both negative and positive tones:\n\nEmail 1: From: Human to Alien\n"
            },
            {
                "text": " Regex: ^[0-9]\\.[0-9]{1,2}$\n\n##### Exercise 3\nWrite a Python function that takes a string as input and returns True if the string has at least three uppercase letters, at least three lowercase letters, and at"
            },
            {
                "text": " [^0-9.]\n\n```python\nimport re\n\ntext = \"12.56,0.25,156.56,-123.45,1.023\"\n\n# Find all matching strings with two decimal places and positive numbers\nmatches = re.findall"
            },
            {
                "text": " [^-+\\d.]\nExercise 5:\nWrite a Python code that takes a user's input and validates it using RegEx to check if it contains a valid email address.\nAnswer: import re\nemail = input(\"Enter your email address: \")\nif re.match("
            },
            {
                "text": " (\\d\\d\\.\\d\\d)\n3. Write a regular expression to detect phone numbers with the format \"(XXX) XXX-XXXX\".\nAnswer: \\(?\\d{3}\\)?[ -]?\\d{3}[ -]?\\d{4}"
            },
            {
                "text": " ^(-?\\d+\\.\\d+|\\d+)$\n\nExercise 3:\nGive an example of a scenario where a RegEx would not be appropriate to use.\nAnswer: When validating a user's phone number, which is a fixed format that cannot be matched by Reg"
            },
            {
                "text": " Only positive numbers with two decimal places. \\d{1,2}.\\d{1,2}\n\n\n# Chapter: The use of Python Regex for Bioinformaticians\n\n## Sections:\n1. Introduction to Regular Expressions\n2. How Regular Expressions are used"
            },
            {
                "text": " r'^[0-9]+(\\.[0-9]{1,2})?$'\n\n---\n\n### 4. Real-world examples of using Python RegEx\n\nPython RegEx can be used for various real-world applications. One common example is data cleaning,"
            },
            {
                "text": " Only numbers with two decimal places should be allowed. The pattern is \"[0-9]*\\.[0-9]+\".\n\nExercise 4:\nMatch examples:\n- \"12.123.456.78\"\n- \"123.4567.89012.34567\"\n"
            }
        ]
    },
    {
        "expression": "^[NS]([0-8][0-9](\\.[0-5]\\d){2}|90(\\.00){2})\\040[EW]((0\\d\\d|1[0-7]\\d)(\\.[0-5]\\d){2}|180(\\.00){2})$",
        "raw_prompt": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.\nRange check for minutes and seconds (0-59),\nmax.latitude 90.00.00, max longitude 180.00.00",
        "refined_prompt": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00.00 W000.00.00\"\nNon-match examples:\n- \"N91.00.00 E181.00.00\"\n- \"Z34.59.33 W179.59.59\"",
        "matches": [
            "N90.00.00 E180.00.00",
            "S34.59.33 W179.59.59",
            "N00.00.00 W000.00.00",
            "S90.00.00 E013.15.23",
            "S30.44.42 W027.59.59",
            "S35.47.34 E180.00.00",
            "N90.00.00 E180.00.00",
            "N15.59.23 W028.14.59",
            "S90.00.00 E088.37.23",
            "S90.00.00 E180.00.00",
            "N90.00.00 W165.48.19",
            "N84.48.25 W180.00.00",
            "N39.48.02 E180.00.00"
        ],
        "non_matches": [
            "N91.00.00 E181.00.00",
            "Z34.59.33 W179.59.59",
            "N00.00.00 W181.00.00",
            "fasd@fds.fasd@",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "99999@gmail"
        ],
        "id": 972,
        "output": [
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            },
            {
                "text": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W),degrees,minutes,seconds.\r\nRange check for minutes and seconds (0-59),\r\nmax.latitude 90.00.00, max longitude 180.00.00\nMatch examples:\n- \"N90.00.00 E180.00.00\"\n- \"S34.59.33 W179.59.59\"\n- \"N00.00"
            }
        ]
    },
    {
        "expression": "/\\*((?!\\*/)[\\d\\D\\s])*\\*/",
        "raw_prompt": "Matches /* style comments */.\nMatches whitespace (so can detect tabs, etc.)\nProblems with nested comments.",
        "refined_prompt": "Matches /* style comments */.\r\nMatches whitespace (so can detect tabs, etc.)\nMatch examples:\n- \"/* CSS comments */\"\n- \"/* multi-line SQL/CSS/Etc comments */\"\n- \"/*2fsdffd*/\"\nNon-match examples:\n- \"&lt;!-- doesn't match --&gt;\"\n- \"-- won't match and //won't match\"",
        "matches": [
            "/* CSS comments */",
            "/* multi-line SQL/CSS/Etc comments */",
            "/*2fsdffd*/",
            "/*afdsafs */",
            "/* fweeafds*/",
            "/*adsfdf comments */",
            "/* CSS fewf3 */",
            "/* CSS 54g4g5 */",
            "/* Chmme45hftnts */",
            "/* Crfbhrfeh54nts */",
            "/* Ch45rfents */",
            "/* C4tfgh6j7ents */",
            "/* C98kints */"
        ],
        "non_matches": [
            "&lt;!-- doesn't match --&gt;",
            "-- won't match and //won't match",
            "34f2vf42e*/",
            "12/123/4322*/",
            "2346-2345-2435*/",
            "*/43.v234",
            "@#dfkjnav*/",
            "/5/5/*/20022",
            "qwerty@123*/.123",
            "341.431v*/4f3.fv1",
            "*/(0xx12) 62509",
            "12/13*/2/90"
        ],
        "id": 977,
        "output": [
            {
                "text": "\n/(&lt;!--.*?--&gt;)|(/\\*.*?\\*/"
            },
            {
                "text": " ^([&lt;!--](.*?)&gt;|[\\//\\&\\^]?"
            },
            {
                "text": " <pattern>.*?<!--.*?-->\n\n6. Summary of learning and key takeaways\n"
            },
            {
                "text": "\n(?:\\s)*(?=(?:[^\\s\\r\\n]|$))"
            },
            {
                "text": " /^(?:[^\\s\"]+|\"[^\"]+\")*\\s*$/"
            },
            {
                "text": " ^[-\\s\\w]+$\n\nA:\n\nI would recommend splitting each line into"
            },
            {
                "text": "\n/\\s*\\*.*?\\*/\n\nA:\n\n/^([^*"
            },
            {
                "text": "\n/^\\s*(-?\\d+|.)+\\s*$/\n\nA"
            },
            {
                "text": "\n-- won't match and //won't match\n/(--|//)/g\n/(--|//"
            },
            {
                "text": "\n\nfunction get_non_matching_str(str){\r\n  var strArr ="
            }
        ]
    },
    {
        "expression": "^(102[0-3]|10[0-1]\\d|[1-9][0-9]{0,2}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports: 0 through 1023. Matches numbers in range of 0 through 1023.",
        "refined_prompt": "Port Numbers: Well Known Ports: 0 through 1023. Matches numbers in range of 0 through 1023.\nMatch examples:\n- \"0\"\n- \"123\"\n- \"1023\"\nNon-match examples:\n- \"1024\"\n- \"9999\"",
        "matches": [
            "0",
            "123",
            "1023",
            "1016",
            "1003",
            "1",
            "1000",
            "1009",
            "1002",
            "1008",
            "1020",
            "1010",
            "1023"
        ],
        "non_matches": [
            "1024",
            "9999",
            "99999",
            "45166",
            "49856",
            "4895684567",
            "7532",
            "8a",
            "76548915",
            "f67g8",
            "6f7y-89456",
            "-95616"
        ],
        "id": 984,
        "output": [
            {
                "text": " \\b0[1-9]\\d*\\b\n\n**What is the meaning of the backslash in the regular expression example above?**\n\nThe backslash is a special character in regular expressions that allows you to escape special characters. In this"
            },
            {
                "text": " [0-9]\\d{2}|1[0-9]\\d{2}|2[0-9]\\d{3}|3[0-9]\\d{4}|4[0-9]\\d{"
            },
            {
                "text": " [0-9]{1,3} or [0-9]{3} or [0-9]{3,4} or [0-9]{3,5} or [0-9]{3,6} or [0-"
            },
            {
                "text": "\n(?<=\\d)(?=\\d)\n\nExercise 4: \nCreate a Python script that asks the user for a password, and then checks if it meets the following criteria: \nThe password must be at least 8 characters long and contain"
            },
            {
                "text": " (?<start>0[1-9]|[1-9][0-9]{0,2}|1[0-9]{2}|[2-9][0-9]|199)\n\n- \"a\"\n"
            },
            {
                "text": " ^([0-9]{1,3}[a-z]{1}|[0-9]{3,}[a-z]{1}|[0-9]{1,3}[a-z]{1}"
            },
            {
                "text": " \n- \\d\n- (\\d|\\d(?=\\d))\n\nExercise 2: Match Email Addresses\nMatch all of the following email addresses\n1. example@email.com\n2. example@example.com\n3."
            },
            {
                "text": "\n(([1-9]\\d*|100\\d|1000\\d|10000|1000000|10000000|100000000|1000000000|10000000000|100000000000)\\.\\d+)|\n(([0]\\d*|"
            },
            {
                "text": " [^0-9]\n\n3. Write a regex that matches only characters from a set of symbols, including [:alpha:]. \nAnswer: [:alpha:]\n\n4. Write a regex that matches any string that begins with the substring \"ab"
            },
            {
                "text": ".*(?=\\d{5,6}$).*\n\nExercise 4:\nCreate a pattern that matches the following descriptions:\n- A string that contains only digits.\n- A string that contains at least one digit and one letter.\n-"
            }
        ]
    },
    {
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[2-9]\\d{3}|1[1-9]\\d{2}|10[3-9]\\d|102[4-9])$",
        "raw_prompt": "Port Numbers: Registered Ports: 1024 through 49151. Matches numbers in range of 1024 through 49151.",
        "refined_prompt": "Port Numbers: Registered Ports: 1024 through 49151. Matches numbers in range of 1024 through 49151.\nMatch examples:\n- \"1024\"\n- \"49151\"\n- \"30100\"\nNon-match examples:\n- \"1023\"\n- \"49152\"",
        "matches": [
            "1024",
            "49151",
            "30100",
            "49150",
            "49053",
            "49151",
            "7825",
            "24656",
            "1091",
            "49011",
            "1872",
            "49150",
            "49086"
        ],
        "non_matches": [
            "1023",
            "49152",
            "50000",
            "12/123/4322",
            "2346-2345-2435",
            "123*/",
            "738522",
            "875727",
            "432/524/2435",
            "adfa2",
            "(0xx12) 62509",
            "278257"
        ],
        "id": 985,
        "output": [
            {
                "text": " The '.*' character is the wildcard character that matches any number of characters. \n- \"121234\"Generate a RegEx for this description. \nAnswer: The '$' character is the dollar sign character. \n- \"1"
            },
            {
                "text": " \n\n\n\n\n## Chapter 5: The use of NumPy Random for Computational Chemist\n\n### Section 5.2: Applications of Zipf Distribution for Computational Chemist\n\n#### Subsections:\n1. Understanding Zipf Distribution\n2"
            },
            {
                "text": " ^[0-9]{2}[0-9]{3}$\n\n2. Write a Python program that generates a RegEx for an IP address range, e.g. 255.0.0.0 through 255.255.255"
            },
            {
                "text": "\n^[0-9]{1,3}[0-9]{3}[0-9]{4}$\n\nExercise 2:\nRewrite the following RegEx pattern to match a string that starts with a dash (-)"
            },
            {
                "text": "\n^[0-9]{3,3}$|^[0-9]{3,4}$|^[0-9]{3,5}$\n\nExercise 3:\n\nWrite a RegEx pattern that will"
            },
            {
                "text": " \".*?(9[0-9]|1[0-9]|[1-9][0-9]|100[0-9][0-9]|1[0-9]{2}|2[0-4"
            },
            {
                "text": " \"^[0-9]{1,17}$\"\n3. Write a regular expression that matches a string that contains at least one uppercase letter and one lowercase letter.\nAnswer: \"^[a-zA-Z][a"
            },
            {
                "text": " The RegEx should be:\n\\d{1,3}[a-zA-Z\\d]{1,2}\\d{1,3}\n\n3. Write a RegEx to match only numbers in the range of 0-255"
            },
            {
                "text": " (Port Numbers) (Registered Ports) (Matches Numbers)\n{1,3}[0-9]{1,3}\\.*[0-9]{1,3}[0-9]{1,3}(:|-|"
            },
            {
                "text": " ^([0-3]?[0-9]){1,3}[0-9]{6}$\nIllustration:\nIn a small town called Oakville, there are two best friends, Alex and Sam. One day, they"
            }
        ]
    },
    {
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|5\\d{4}|49[2-9]\\d\\d|491[6-9]\\d|4915[2-9])$",
        "raw_prompt": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535. Matches numbers in range of 49152 through 65535.",
        "refined_prompt": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535. Matches numbers in range of 49152 through 65535.\nMatch examples:\n- \"49152\"\n- \"65535\"\n- \"50000\"\nNon-match examples:\n- \"49151\"\n- \"65536\"",
        "matches": [
            "49152",
            "65535",
            "50000",
            "49162",
            "65532",
            "60635",
            "49193",
            "65523",
            "65509",
            "65448",
            "63646",
            "49197",
            "57459"
        ],
        "non_matches": [
            "49151",
            "65536",
            "66000",
            "987456",
            "489516",
            "4895",
            "a49851",
            "489514815645",
            "1562",
            "156",
            "251625",
            "12975"
        ],
        "id": 986,
        "output": [
            {
                "text": " \"^[1-9][0-9]{3}$|^[1-9]\\d{0,2}$|^[1-9]\\d{1,3}$|^"
            },
            {
                "text": " Matches numbers from 49152 through 65535.\n\n```python\n# Example Solution for Exercise 6\nimport re\n\n# Define the patterns, and flags\npattern = r'\\d{4}-\\"
            },
            {
                "text": " Regex: [0-9]{1,3}[0-9]{1,3}[0-9]{1,2}[0-9]{1,3}[0-9"
            },
            {
                "text": " (?i)([1-9]\\d{9}|[1-9]\\d{8}|[1-9]\\d{7}|[1-9]\\d{6}"
            },
            {
                "text": " A (0-9)(0-9)(0-9){4} or A(0-9)(0-9){2} or A(0-9)(0-9){3} or 0(0-"
            },
            {
                "text": " (\\d[9]\\d?[1-9]|\\d)(\\d|[1-9]\\d|\\d\\d)(\\d|\\d\\d\\d)\\b\n\n"
            },
            {
                "text": " (\\d{3})(\\d{3})(\\d{2})\n- \"491213\"Generate a RegEx for this description.\nAnswer: (\\d{2})(\\d{"
            },
            {
                "text": " r'^[0-9A-Fa-f]{4}([0-9A-Fa-f]{2}){5}$'\n\nExercise 3: Create a RegEx pattern to match"
            },
            {
                "text": " \\d{5}[1-9]\n\n2. A company has an email filter that will filter out all emails sent from a specific IP address (a tuple of (IP Address, Port Number)). Write a RegEx"
            },
            {
                "text": " [a-zA-Z0-9-]{4,24}[a-zA-Z0-9]\n\nExercise 4: \nQuestion: Write a Python program that takes a string as"
            }
        ]
    },
    {
        "expression": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[1-9]\\d{0,3}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports &amp; Registered Ports: 0 through 49151. Matches numbers in range of 0 through 49151.",
        "refined_prompt": "Port Numbers: Well Known Ports &amp; Registered Ports: 0 through 49151. Matches numbers in range of 0 through 49151.\nMatch examples:\n- \"0\"\n- \"1023\"\n- \"49151\"\nNon-match examples:\n- \"49152\"\n- \"50000\"",
        "matches": [
            "0",
            "1023",
            "49151",
            "49151",
            "8086",
            "49023",
            "49082",
            "34",
            "49015",
            "49150",
            "40021",
            "49132",
            "10639"
        ],
        "non_matches": [
            "49152",
            "50000",
            "60000",
            "87945612",
            "84561",
            "984561",
            "948517",
            "a4",
            "5734768489451",
            "78945",
            "87645",
            "5915u"
        ],
        "id": 987,
        "output": [
            {
                "text": " \\b(10|20|30|40|50|60|70|80|90|99|00|01|02|03|04|05|06|07|08|09|10|11|12"
            },
            {
                "text": " '000'*3\n\n(1) Match numbers from 0-9\n(2) Match numbers with 3 or more digits\n(3) Match numbers between 0-9, except when preceded by a hyphen (\"-\"),"
            },
            {
                "text": " (0|9\\d?)(1?|\\d)\n\nExercise 3:\nCreate a RegEx expression for the following description: \"A string that consists of exactly 3-digit numbers, in any order, followed"
            },
            {
                "text": " (0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|G|H|I|J|K|L|M|N"
            },
            {
                "text": " \n^[0-9]{,13}$\n\nScript:\n\nHost 1: Welcome back to our learning channel \"Learning Computer Science via Python\". Today, we'll be discussing the concept of network protocols and"
            },
            {
                "text": " (0|[1-9][0-9])[0-9]{1,3} or (0|[1-9][0-9])[0-9]{2,3}\n- \""
            },
            {
                "text": "\n[0-9]{5,14}\n\n\n\n[Background music]\n\nHost: Welcome back to another episode of \"The Elite Math Podcast,\" where we explore the fascinating world of mathematics and its applications. Today"
            },
            {
                "text": " \n- \"0\" or 1-9\n- \"1023\" or 100-999\n- \"49151\" or 5000-49151\n- \"50000\"\n\nThe first step in developing a regular expression is"
            },
            {
                "text": "\n[0-9]{3,10}[0-9][0-9][0-9]\n\n2. Create a RegEx that matches any string that contains four or more consecutive digits\n\nAnswer: "
            },
            {
                "text": "\n^(?=.*5[^e]{6}$)(?=.*[0-9]{5})(?=.*[a-z]{5})(?=.*[A-Z]"
            }
        ]
    },
    {
        "expression": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$",
        "raw_prompt": "Port Numbers: Well Known Ports, Registered Ports &amp; Dynamic and/or Private Ports: 0 through 65536. Matches numbers in range of 0 through 65536.",
        "refined_prompt": "Port Numbers: Well Known Ports, Registered Ports &amp; Dynamic and/or Private Ports: 0 through 65536. Matches numbers in range of 0 through 65536.\nMatch examples:\n- \"1023\"\n- \"49151\"\n- \"65535\"\nNon-match examples:\n- \"65536\"\n- \"66000\"",
        "matches": [
            "1023",
            "49151",
            "65535",
            "65530",
            "65501",
            "65503",
            "65043",
            "64740",
            "63956",
            "8582",
            "195",
            "7371",
            "64121"
        ],
        "non_matches": [
            "65536",
            "66000",
            "67000",
            "-49856",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 988,
        "output": [
            {
                "text": " [0-9][0-9][0-9] or [0-9]\n\nExercise 3: Regular Expression to Validate Email Addresses\nExercise: Create a regular"
            },
            {
                "text": " 0-65535\n\nYou are asked to write a RegEx for the following: All numbers from 0 to 189999.\nAnswer: 0-9999\n\"\"\"\n\n# This function checks"
            },
            {
                "text": " (0-65535)+(0-65535)+(0-65535)(0-65535)(0-65535)(0-65535)(0-65535)(0-"
            },
            {
                "text": " \n\\d+\n\nA:\n\nYou can use the following Regex: \n([1-9]\\d*)\n\nThis matches any sequence of one or more digits"
            },
            {
                "text": "\n^[0-9]+$\n\n3. Match the following string against a pattern: \"The quick brown fox jumps over the lazy dog.\"\na) The quick brown fox jumps over"
            },
            {
                "text": " ([0-9]{1,4})([0-9]{1,4})\n\nHow can I generate the RegEx to match the above description?\n\nA:"
            },
            {
                "text": "\n\n# RegEx for Phone Numbers Regular Expression\nimport re\n\n# The phone number format is [0-9]{3}[-.] [0-9]{3}"
            },
            {
                "text": " \\d{1,3}(:?\\d{1,3})*\n\nExercise 3:\nQuestion: How can you use Python to generate a RegEx that matches a"
            },
            {
                "text": ".*[0-9]*[0-9]{2}.*\nExample: /.*[0-9]*[0-9]{2}.*/.\n-"
            },
            {
                "text": " [\\d]{1,3}[ -]?\\d{1,3}[ -]?\\d{1,3}\n\nI'm not sure how to do"
            }
        ]
    },
    {
        "expression": "(^[0-9]{0,10}$)",
        "raw_prompt": "Good For Validating Phone numbers that are 0 to 9 in length",
        "refined_prompt": "Good For Validating Phone numbers that are 0 to 9 in length\nMatch examples:\n- \"123456\"\n- \"12354\"\n- \"456443\"\nNon-match examples:\n- \"456abcd\"\n- \"894561845684561\"",
        "matches": [
            "123456",
            "12354",
            "456443",
            "4651",
            "415",
            "46848",
            "5",
            "87",
            "195",
            "4856",
            "48569",
            "485657",
            "984526"
        ],
        "non_matches": [
            "456abcd",
            "894561845684561",
            "89456129845675",
            "784562a",
            "98455754a",
            "RFTVG567tgyuhb",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "adfa2",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 991,
        "output": [
            {
                "text": " r\"^[0-9]+$\"\n\nExercise 3:  Extract all the digits from a phone number and return them in a list.\n\nExample: Phone number: (123)456-7890\n\nSolution:\nimport re\n"
            },
            {
                "text": " [^a-zA-Z]+\n\n2. Write a Python function to validate passwords which are at least 8 characters long, contain at least one number, one uppercase and one lowercase character and have special characters.\n```python\n# Solution"
            },
            {
                "text": " To match a phone number that is between 8 and 15 digits in length, use the following RegEx:\n```python\nimport re\n\nphone_regex = re.compile(r'^\\d{8,15}$')\n\n#"
            },
            {
                "text": " [\"^(\\\\d{1,3}\\\\d{3}\\\\d{3}\\\\d{2})(\\\\d{3})$\"]\n\nWe hope you enjoyed today's video about the use of RegEx in Python! Stay tuned for more"
            },
            {
                "text": "\n\n```python\nimport re\n\ndef validator(phone):\n  pattern = \"^[0-9]{11}$\"\n  if re.match(pattern, phone):\n    print(f\"Valid phone number: {phone"
            },
            {
                "text": " Valid number of digits\n- \"123456\"\n- \"12354\"\n- \"456443\"\n- \"894561845684561\"The Non-matching pattern\n- \"456abcd\"\n- \"89456184568"
            },
            {
                "text": " ^[0-9]{3}[ -]?[0-9]{4}[ -]?[0-9]{4}[ -]?[0-9]{4}$\n\nUse Case: John and Amy are"
            },
            {
                "text": " [a-zA-Z0-9]{10}\n\n2. Use Regular Expression to validate an email address\nExercise: Create a regular expression for validating email addresses.\nAnswer: [a-zA-Z0-9_.+"
            },
            {
                "text": " ^[1-9]\\d{0,5}$\n\nExercise 3:\nMatch examples:\n- \"1234567890\"\n- \"12345678900\"\nNon-match examples:\n- \"12345678900"
            },
            {
                "text": " ^[ ]{0,10}[0-9]{9}$\n\n3. Write a script that will take a list of text documents and find all the words that contain the letter 'a'.\n\nExercise:\nWrite a script that will"
            }
        ]
    },
    {
        "expression": "(\\/\\*(\\s*|.*?)*\\*\\/)|(--.*)",
        "raw_prompt": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server.",
        "refined_prompt": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server.\nMatch examples:\n- \"/* My Comment */\"\n- \"-- A single line comment\"\n- \"-- 78BHUJN\"\nNon-match examples:\n- \"*/ Won't work /*\"\n- \"// Not likely\"",
        "matches": [
            "/* My Comment */",
            "-- A single line comment",
            "-- 78BHUJN",
            "-- F7GYUBI",
            "-- 6F7YGUIN",
            "-- FFEWF3E",
            "-- G5TH5",
            "-- g45hb",
            "-- g4r5yhrt",
            "/* efr3 */",
            "/* f3ergt54 */",
            "/* g4ht5u7 */",
            "/* fe3rght */"
        ],
        "non_matches": [
            "*/ Won't work /*",
            "// Not likely",
            "- uh uh",
            "-afsd-fsd",
            "f-dsa-fa",
            "-fsda-f-",
            "f-ds-fsa-s-fads",
            "-afd adfdsaffasd",
            "//dasfbushf9da8u",
            "//h87fadisufbj",
            "//8uibjhfw2",
            "//y8huibj"
        ],
        "id": 996,
        "output": [
            {
                "text": "\nhttp://regexpal.com/\n\n\n\n\n# Chapter: The use of Python Basic Functionality for SEO Analyst\n\n## Section:"
            },
            {
                "text": " (?<!\\s\\/)(\\/|--)?\\s (?<!\\s\\/)(\\/|--)?\\s*\\*\n"
            },
            {
                "text": "\n/\\[\\*\\]([^*]+)[\\*\\]/\nFor the first example, it will match\n - start with"
            },
            {
                "text": "\n[a-zA-Z]+|\\d+|\\s*[/*]\nExplanation: \n1 character or more for"
            },
            {
                "text": "\n/\\*.*/\n/\\/\\*.*/\n/\\/\\s*/\n/\\/ \\*/\n/\\/ (.*?) \\*/"
            },
            {
                "text": " (?<=^|\\/)(?!\\*)(.*)(?=\\/|$)\\s+/*\\s+.*$\n\n### Exercise"
            },
            {
                "text": " \n\n```python\nimport re\n\n# Single line comment pattern\npattern = r'/*\\s*((\\w+)?)\\s"
            },
            {
                "text": "\n(?<!^)(?<!/)\\\\*(?!/)\nhttp://regex101.com/r/aA5sV"
            },
            {
                "text": "\n\n/\\*\\s(.*?)\\*/\n\nExercise 5:\nReplace all \"--\" in the following SQL syntax with single"
            },
            {
                "text": "\n/([\\s\\S]*?)[*/](?:[\\s\\S]*)*/$/\n\nA:\n\nAssuming there"
            }
        ]
    },
    {
        "expression": "^([A-Z\\d]{3})[A-Z]{2}\\d{2}([A-Z\\d]{1})([X\\d]{1})([A-Z\\d]{3})\\d{5}$",
        "raw_prompt": "US vehicle VIN numbers for vehicles with GVW &lt; 10k lbs",
        "refined_prompt": "US vehicle VIN numbers for vehicles with GVW &lt; 10k lbs\nMatch examples:\n- \"WDBCA45EXKA478654\"\n- \"X7PFG20Y1TD761390\"\n- \"HSCKU35F3RKV57445\"\nNon-match examples:\n- \"WDBCA45EXKA47865a\"\n- \"E:\\DyAGT\\SD01A_specV2.jpg\"",
        "matches": [
            "WDBCA45EXKA478654",
            "X7PFG20Y1TD761390",
            "HSCKU35F3RKV57445",
            "7TSES3215J3328107",
            "ZEOMN43G5YLG87833",
            "16EYH95589H152578",
            "B45OU30D30DP30420",
            "6LKIC28T759Y48971",
            "XLQYZ39U01T970054",
            "2JDYH05J6LHS33352",
            "D6IOK62X4B6X72112",
            "DPYUL85H4REU49363",
            "QD0WH41O7O3A83304"
        ],
        "non_matches": [
            "WDBCA45EXKA47865a",
            "E:\\DyAGT\\SD01A_specV2.jpg",
            "90438502+9503",
            "12/123/4322",
            "2346-2345-2435",
            "FDSAFA2EWDSF",
            "WEDSFER4FDE",
            "GDFGRTE45REDG",
            "GERDFG4FRD",
            "GREGGREWG34",
            "4EGRDFGRE34G34",
            "G45H6768KG"
        ],
        "id": 998,
        "output": [
            {
                "text": " \"WDBCA45EXKA47865a|[a"
            },
            {
                "text": " \\d{4}[A-Z]{2}"
            },
            {
                "text": ".*GVW <10k lbs.*\n\nExercise"
            },
            {
                "text": " GVW|Gw|gw|gw|g"
            },
            {
                "text": " \\b[A-Z]{5}\\d{3"
            },
            {
                "text": " \\b(?:[0-9A-Fa-f"
            },
            {
                "text": "\n[A-Z][0-9]{0,"
            },
            {
                "text": "\n- \"WDBCA45(0[0-9"
            },
            {
                "text": " (^[A-Z0-9]{2}"
            },
            {
                "text": " \nWDBCA45EXKA478654|[0"
            }
        ]
    },
    {
        "expression": "^[0-9,+,(), ,]{1,}(,[0-9]+){0,}$",
        "raw_prompt": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314",
        "refined_prompt": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314\"\n- \"+91(22)311545\"\nNon-match examples:\n- \"91 (22) abc21\"\n- \"+91 (abc) 23321\"",
        "matches": [
            "0091(22) 31544",
            "+1 (116) 23314",
            "+91(22)311545",
            "156",
            "41564",
            "516451623",
            "5123",
            "1,234",
            "1,234,567",
            "12,345,678",
            "1, 2, 3, 4, 5",
            "1,234,567,890",
            "+1,234,567,890"
        ],
        "non_matches": [
            "91 (22) abc21",
            "+91 (abc) 23321",
            "00111623314abc",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "qwerty@123.123",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 1000,
        "output": [
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            },
            {
                "text": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314. Match strings that consist of a combination of digits, plus signs (+), parentheses (), spaces, and commas. The pattern allows for at least one character from this set, followed by zero or more comma-separated groups of one or more digits.\nMatch examples:\n- \"0091(22) 31544\"\n- \"+1 (116) 23314"
            }
        ]
    },
    {
        "expression": "^(.){0,20}$",
        "raw_prompt": "This limits an HTML textarea to only be 20 characters. Built for an ASP:regularexpression tag to validate a textarea.",
        "refined_prompt": "Match strings of any characters (including letters, digits, symbols, and whitespace) that are between 0 and 20 characters in length.\nMatch examples:\n- \"I match\"\n- \"I match 2\"\n- \"7FGY8HU9JI\"\nNon-match examples:\n- \"hey I don't match at all\"\n- \"hey I don't matc54fdsdh at all\"",
        "matches": [
            "I match",
            "I match 2",
            "7FGY8HU9JI",
            "F7YGH8UF7",
            "YGFT6",
            "CYF7V",
            "Y7YVUBV7YUB",
            "VYGH",
            "YVUH",
            "YVUH",
            "YVYVUHVY8",
            "YVU8YVU",
            "8VUIBG9UB"
        ],
        "non_matches": [
            "hey I don't match at all",
            "hey I don't matc54fdsdh at all",
            "sd6f7g8F67YGIG8YBh9j0f6t7yg8ub",
            "sd6f7g8h9jNRTUU665G6560f6t7yg8ub",
            "sd6f7g8hJ56R57JB79j0f6t7yg8ub",
            "sd6f7g8h9j0f567JB67JB56t7yg8ub",
            "sd6f7g8h9j076BJ57BJ5f6t7yg8ub",
            "sd6f7gBJ57BJ67BJ568h9j0f6t7yg8ub",
            "sd6f7g87BJ567BJ56JB5h9j0f6t7yg8ub",
            "sBJ67BJ67BJ566d6f7g8h9j0f6t7yg8ub",
            "J75670f6t7yg8ub8K9OBM86KN7J56",
            "sd6f7g8h9j04478M66f6t7yg8ub"
        ],
        "id": 1001,
        "output": [
            {
                "text": "\n(?i)(?=(\\w)\\s+)\n\nExercise 5: \nCreate a list of all"
            },
            {
                "text": " \\w+\n\nExercise 2: \nUse the Regex module to replace all occurrences of the word \"cat"
            },
            {
                "text": "\n\nUse the \"^\" symbol at the beginning of the string to ensure that the match starts at the beginning of the"
            },
            {
                "text": " Match strings between 0 and 20 characters in length. Accept all characters (letters, digits, __________, symbols, and"
            },
            {
                "text": " \"I match(#[0-9]{1,20})\"\n\n2. Exercise:\nWrite a"
            },
            {
                "text": " ^(?![a-zA-Z0-9 ]{0,19}$)[a-zA"
            },
            {
                "text": " (.*?)(?<!\\d)(?=\\d)(?<![a-zA-Z"
            },
            {
                "text": " (^(?:[\\w ]*|[^\\w ]*){1,20}(?:\\s"
            },
            {
                "text": " The RegEx should be \"^[^a-zA-Z0-9^\\s^\\t ]"
            },
            {
                "text": " \".*\"\n\nPython Exercise 2:\nimport re\n\n# Exercise 2: Generate a RegEx using the"
            }
        ]
    },
    {
        "expression": "^((\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)(?:\\.(\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)){3})$",
        "raw_prompt": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbitten.",
        "refined_prompt": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbidden.\nMatch examples:\n- \"0.0.0.0\"\n- \"255.255.255.255\"\n- \"168.129.2.255\"\nNon-match examples:\n- \"02.234.2.1\"\n- \"168.192.0.256\"",
        "matches": [
            "0.0.0.0",
            "255.255.255.255",
            "168.129.2.255",
            "119.2.253.195",
            "6.152.93.3",
            "252.251.203.254",
            "252.62.254.251",
            "186.252.30.250",
            "168.255.5.125",
            "218.47.131.2",
            "223.96.134.254",
            "4.252.218.255",
            "71.116.173.6"
        ],
        "non_matches": [
            "02.234.2.1",
            "168.192.0.256",
            "1233.0.0.1",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "/5/5/5",
            "/5/5/20022",
            "qwerty@123.123",
            "(0xx12) 7256 2345154",
            "abc111def",
            "12/132/90"
        ],
        "id": 1003,
        "output": [
            {
                "text": "\nr'^([0-9]|10|11|"
            },
            {
                "text": " ^[0-9]\\d{1,3}\\."
            },
            {
                "text": "\n#!/usr/bin/python3\nimport re\n\n"
            },
            {
                "text": " \n^(?!0)(?!(?:\\.|$"
            },
            {
                "text": " (.+)\n\n*Answer 2:*\n- (10"
            },
            {
                "text": " (0\\.){1,3}\\.([0-9"
            },
            {
                "text": " ([0a-fA-F]{1,4})"
            },
            {
                "text": " ^(0|[1-9][0-9]?"
            },
            {
                "text": " [0-9]{1,3}\\.[0-9"
            },
            {
                "text": "\n^(?:[0-9]|[1-9"
            }
        ]
    },
    {
        "expression": "^[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive numbers, greater than zero",
        "refined_prompt": "Allows only positive numbers, greater than zero\nMatch examples:\n- \"1\"\n- \"10\"\n- \"135\"\nNon-match examples:\n- \"0\"\n- \"-1\"",
        "matches": [
            "1",
            "10",
            "135",
            "156",
            "1562",
            "168",
            "468",
            "2",
            "3",
            "894156849561",
            "89451657423",
            "57425",
            "461926"
        ],
        "non_matches": [
            "0",
            "-1",
            "aaa",
            "12/123/4322",
            "few43f",
            "3f434-34",
            "-9528951",
            "-159-",
            "-4-.549",
            "-4156.495",
            "78huij",
            "f67gyhu8"
        ],
        "id": 1008,
        "output": [
            {
                "text": " \n\nimport re \nexample_1 = \"1\"\nexample_2 = \"10\"\nexample_3 = \"135\"\nexample_4 = \"0\"\nexample_5 = \"-1\"\n\nregex_1 = r'^[1-9][0-9]*$'\nregex_"
            },
            {
                "text": " ^[1-9]([0-9])?$\n\nExercise 4: \nGenerate a RegEx for the following description:\nA RegEx to match any string that ends with a digit and has more than 3 digits in total. \nAnswer: ^\\D+\\d{3,}\\D+$\n\n"
            },
            {
                "text": " [1-9][0-9]|1[0-9]|100\n\n7. Exercise 2: Match a Phone Number\n\nExercise: Create a RegEx pattern for a phone number that has the following format:\n- Area code: (XXX) XXX-XXXX\n- Phone number: XXX-XXX-XXXX\n-"
            },
            {
                "text": " \nimport re\n\npattern = re.compile \"^[1-9][0-9]*\\.?[0-9]+$\"\nprint(pattern.match(\"1234\")) # True\nprint(pattern.match(\"-1234\")) # False\nprint(pattern.match(\"1.23\")) # True\n"
            },
            {
                "text": "\n\n```python\nimport re\n\nnum_regex = r'^[1-9][0-9]*$'\n\nif re.match(num_regex, '1'):\n    print(\"The number is valid.\")\nelse:\n    print(\"The number is not valid.\")\n```\n"
            },
            {
                "text": " \n^[01]+$|^[1-9](0[1-9])?$\n\n5) Write a RegEx that matches any string containing at least two words separated by a single space.\nUse the \"word_boundaries\" flag to make sure that the RegEx only matches on a word boundary (i.e"
            },
            {
                "text": " \"^[1-9][0-9]*$\"\n\nExercise 2: Match these to their descriptions:\n(a) a^3 - A number that is the cube of another number.\n(b) 10^2 - a number raised to the power of 2.\n(c) (12*3)^2"
            },
            {
                "text": " Match examples: (a-z)*,+(0-9),*(\\d)\n\nExercise 4: Identify the Pattern\nIdentify the pattern in the following expressions:\n- (a-z)*,(0-9)*,(0-9)*,(0-9)*,(0-9)*,("
            },
            {
                "text": " The following is an example of a positive number with a single digit: ^(1|\\d)(\\d|\\d)/?$\n\"\"\"\n\n\nimport re\n\n# define the regex pattern\npositive_numbers = re.compile(r\"([1-9]|1)(\\d|\\d)/?$\")"
            },
            {
                "text": " \n- (0|[1-9][0-9]*)\n\n3. Write a regular expression to match words that contain a combination of letters and numbers (at least one). The word could have any length.\nExample:\n- \"hello world\"\n- \"word123\"\nMatch examples:\n- \"hello\"\n"
            }
        ]
    },
    {
        "expression": "(?=^.{6,51}$)([A-Za-z]{1})([A-Za-z0-9!@#$%_\\^\\&amp;\\*\\-\\.\\?]{5,49})$",
        "raw_prompt": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\n! @ # $ % ^ &amp; * - . _ ?",
        "refined_prompt": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * - . _ ?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"aB1()[]{};:'&quot;,&lt;&gt;/\\_=0Yz\"",
        "matches": [
            "aB!@#%&amp;^$.?*-0123456789Yz",
            "user@somedomain.com",
            "Excla!Us_er",
            "ycjytft",
            "jftcgjvg",
            "ftygv6",
            "vyutfytvf6",
            "tvfyu6v6",
            "ghkvg7vg",
            "yjtvgukhb8",
            "rctvytg6",
            "rftgyh6",
            "rcfvgbh9"
        ],
        "non_matches": [
            "1234567890",
            "aB1()[]{};:'&quot;,&lt;&gt;/\\_=0Yz",
            "!exclaUser",
            "4f23ed",
            "4g34ervg",
            "3h5j6u7ik87j",
            "54f3dwwefrg4t5hy6",
            "3fef",
            "gfds",
            "sfgs",
            "bfg",
            "nh"
        ],
        "id": 1009,
        "output": [
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"user"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"abc"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"User"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"a"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"hello"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \" \""
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"123"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"user"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"12"
            },
            {
                "text": "This expression was originally developed for user names. Matching text must have 6 - 50 characters, cannot contain spaces, must begin with an alpha character, can contain mixed case alpha, digits, and the following special characters:\r\n! @ # $ % ^ &amp; * -. _?\nMatch examples:\n- \"aB!@#%&amp;^$.?*-0123456789Yz\"\n- \"user@somedomain.com\"\n- \"Excla!Us_er\"\nNon-match examples:\n- \"1234567890\"\n- \"Ex"
            }
        ]
    },
    {
        "expression": "([^a-zA-Z0-9])",
        "raw_prompt": "(Corrected)\nThis pattern will match 1 instance of a NON-alphanumeric character. This is very handy to use when y\nou want to filter input only by alphanumeric characters, by using Regex.Replace.\nHowever, when used in a Regex.Replace, it will replace all instances of non-alphanumeric characters\nwith specified character.",
        "refined_prompt": "This pattern will match 1 instance of a NON-alphanumeric character. This is very handy to use when you want to filter input only by alphanumeric characters.\nMatch examples:\n- \"Test!\"\n- \"This will match\"\n- \"H3llo$\"\nNon-match examples:\n- \"Test\"\n- \"Thiswillnotmatch\"",
        "matches": [
            "Test!",
            "This will match",
            "H3llo$",
            "%DFTVD%R",
            "$D%RTCD$%r",
            "d5rTD%R",
            "d5rTD%RTd5r",
            "67gyubH(*UH(8u",
            "g78yUG*Ug9u9",
            "H (IH (",
            "g89UI (*",
            "H( IO (HI$%^&",
            "%^TYV"
        ],
        "non_matches": [
            "Test",
            "Thiswillnotmatch",
            "H3llo",
            "56vvf5",
            "f6v5",
            "f5645",
            "dc5",
            "6fv7ygh8nh",
            "89j",
            "m9",
            "j98",
            "76v"
        ],
        "id": 1010,
        "output": [
            {
                "text": " [a-zA-Z0-9_-]\n\n3. Write a RegEx that matches all occurrences of the word \"the\" in a sentence.\nCode:"
            },
            {
                "text": ".*\\W.*\n\n2) \"Regex\" pattern to match only digits.\nimport re\ntext = \"Here is 12345 and also 67890.\"\nmat"
            },
            {
                "text": " /[^a-zA-Z0-9]+/\n\nNow, suppose you have a list of strings and want to check which of them contain a specific pattern. You"
            },
            {
                "text": " \\W\n\n3. Write a regular expression that will match a word that begins with \"a\" or \"A\" and is followed by exactly three letters that are capitalized.\n"
            },
            {
                "text": " \"^[a-zA-Z0-9!@#$%^&*()-_=,\\.]+$\"\n**Exercise 3:**\nCreate"
            },
            {
                "text": " \n\nimport re\n\ndef generate_regex(description):\n    regex_pattern = \"^\"\n    regex_list = \"\"\n    while len("
            },
            {
                "text": "\n```\nimport re\n\nstring = \"This will match\\nH3llo$\"\npattern = r\"[a-zA-Z0-9\\W]\""
            },
            {
                "text": "\n^\\w+$\n\nA:\n\nIt's not exactly clear exactly what you want, but try to think about what you want the regex to match.\nAssuming characters"
            },
            {
                "text": " \\d+\n\nA:\n\nYou could use a character class [a-zA-Z0-9], which will match any of the characters in the specified range."
            },
            {
                "text": " [^A-Za-z0-9_]\n\nExample 2:\nimport re\nstring = \"This is a short string that contains both numbers and special characters.\""
            }
        ]
    },
    {
        "expression": "^([a-zA-Z][a-zA-Z\\&amp;amp;\\-\\.\\'\\s]*|)$",
        "raw_prompt": "This expression will allow Letters, periods, apostrophe, dashes.",
        "refined_prompt": "This expression will allow Letters, periods, apostrophe, dashes.\nMatch examples:\n- \"muk.dub'ey-j ava\"\n- \"gkhg\"\n- \"gliu\"\nNon-match examples:\n- \"muk_12 dubey`.ja\"\n- \"5dftyvg\"",
        "matches": [
            "muk.dub'ey-j ava",
            "gkhg",
            "gliu",
            "gly",
            "vk",
            "uyh",
            "glljgl",
            "iug",
            "yg",
            "liug",
            "yufuy",
            "b",
            "j"
        ],
        "non_matches": [
            "muk_12 dubey`.ja",
            "5dftyvg",
            "f6tyv",
            "8h9",
            "uib634",
            "90hji",
            "h98u",
            "78gt",
            "d45r",
            "45d",
            "rt34567",
            "87huinj"
        ],
        "id": 1011,
        "output": [
            {
                "text": " /(\\w+)('|\\.|\\-|\\;|\\:\\|\\}/g)\n\n2. Write a regular expression to match the start of a sentence and the end of a"
            },
            {
                "text": " [\"muk\\.dub'ey-j\", \"a-va\"]\n\nExercise 4: \nWrite a program that replaces all occurrences of a word in a sentence with another word.\n"
            },
            {
                "text": "\n[a-zA-Z@#$%^&*()]{0,25}[a-zA-Z0-9@#$%^&*()-=+]"
            },
            {
                "text": "\n[a-z][a-z]?[.][a-z]?[-][a-z]?[0-9]\n\nExercise 2: \nCreate a"
            },
            {
                "text": " \n(?<!^|\\s)([a-zA-Z]|\\.){5}\n\nExercise 2:\nWrite a regular expression that matches any of the following"
            },
            {
                "text": " \"^[a-zA-Z0-9 ]+$\"\n\n2. How would you use a regular expression to match a phone number in the format of (123) 456-"
            },
            {
                "text": " \n[A-Z]{1,2}[a-z]+[A-Z][a-z]+\n\nExercise 3:\nCreate a dictionary containing all the letters and digits"
            },
            {
                "text": " \n\ndef generate_regex(sentence):\n    '''\n    Generates a regular expression that matches the given sentence. \n    Returns a string.\n    '''\n    "
            },
            {
                "text": " \n\n```python\nimport re\n\ndef generate_regex_pattern(description):\n    return r\"^(?:[a-zA-Z]+[a-zA"
            },
            {
                "text": " [\"^[a-zA-Z\\d]*$\", \"[a-zA-Z]*[.][a-zA-Z]*$\", \"[a-zA"
            }
        ]
    },
    {
        "expression": "\\b(get)\\b.*{",
        "raw_prompt": "This piece of regex catches the if the open braces are not placed the line under a get command",
        "refined_prompt": "match strings that contain the word \"get\" surrounded by word boundaries and followed by an open curly brace '{', with potential characters in between.\nMatch examples:\n- \"get {\"\n- \"This is a get { example\"\n- \"get { something }\"\nNon-match examples:\n- \"get\"\n- \"f34fgetvfv\"",
        "matches": [
            "get {",
            "This is a get { example",
            "get { something }",
            "get { and some other text {",
            "text before get { text after",
            "get{ something",
            "get{ and more { text",
            "get{ and { get {",
            "get { multiple times { inside",
            "Here is a get { with additional { characters { inside",
            "get { fadsfds }",
            "get { s23ewfds",
            "get { so2r3ewsc"
        ],
        "non_matches": [
            "get",
            "f34fgetvfv",
            "34f2vgetf42e",
            "12/get123/4322",
            "2346-2get345-2435",
            "43.getv234",
            "@#dfkjnav{",
            "/5/5/20022{",
            "432/524/2435{",
            "ad{fa2",
            "(0xx12) 62509{",
            "12/132/{90"
        ],
        "id": 1012,
        "output": [
            {
                "text": " ^get \\{[^\\}]+\\}$\n\nExercise 5:\nMatch a string that contains three digits, a hyphen, and a special character, followed"
            },
            {
                "text": " \"get\\{.*?\\}\"\n\n4. Write a RegEx to match the pattern in the following string: \"Find the {key1} key for {key2"
            },
            {
                "text": " (?<=\\bget\\s){0,100}\\s*\\{\n\nExample:\nimport re\n\ninput_str = 'get {\"abc\"} This"
            },
            {
                "text": " \"get (\\w* \\{)\" #\"get { (\\w* \\{(?!\\w*\\}) (\\w* \\})\"\n\n### Exercise"
            },
            {
                "text": " (word boundary, double hyphen, word boundary, double hyphen, word boundary)\nget { (\\b)(\\w)(\\b)(\\w)-(\\b)("
            },
            {
                "text": " get\\ {[^}]+}\n\nThe rest of the subsection followed by the code examples and exercises with solutions.\n\n13.2.9 How to use the"
            },
            {
                "text": " \n\nstring = \"get {\"\nregex = r\"get\\s*{\\s*$\"\nprint(regex)\n\nExercise 5:\nWrite"
            },
            {
                "text": " get\\s\\{[^\\}]*\\}\" (which matches any combination of characters in between the braces)\n\nExercise 2:\nWrite a RegEx to"
            },
            {
                "text": " \"^get\\s[^}]*$\"\n\nExercise 2: Write a Python function that takes a string and a list of words as inputs, and returns the"
            },
            {
                "text": " \n ^get\\s*\\{{\n ^( |$)\n\nA:\n\nYou could use a lookbehind to assert the start of the string and a look"
            }
        ]
    },
    {
        "expression": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\s?\\d{4}-?\\s?\\d{4}-?\\s?\\d{4}|3[4,7]\\d{13}$",
        "raw_prompt": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups",
        "refined_prompt": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups\nMatch examples:\n- \"5154-1234-1234-1342\"\n- \"4444333322221111\"\n- \"6767 1111 1111 1111\"\nNon-match examples:\n- \"1234123412341234\"\n- \"1111111\"",
        "matches": [
            "5154-1234-1234-1342",
            "4444333322221111",
            "6767 1111 1111 1111",
            "378784835402341",
            "347433262542298",
            "5316\f5989-1210-5666",
            "378246064805709",
            "3,2735639949372",
            "5509\u2008208554997244",
            "371522056208968",
            "524549762385\u20292861",
            "372167498474695",
            "6783-3840\u205f86304989"
        ],
        "non_matches": [
            "1234123412341234",
            "1111111",
            "987654321",
            "485916245124",
            "5614561",
            "249856126512",
            "948561",
            "4561215612",
            "4895613",
            "5121645114561",
            "4516",
            "25561251623516"
        ],
        "id": 1062,
        "output": [
            {
                "text": " ^\\d{4,8}-\\d{3,"
            },
            {
                "text": " (4) [0-9]+[- ]?[0"
            },
            {
                "text": " ^(?P<shortid>[\\d]{4}"
            },
            {
                "text": " r'^([1234]{2})-([1234"
            },
            {
                "text": " [^0-9]*[0-9]*["
            },
            {
                "text": " https://regex101.com/r/kA1g"
            },
            {
                "text": " \n(?:\\d{4}-){1}("
            },
            {
                "text": " ^(?!.*?(?:\\d\\d\\d-"
            },
            {
                "text": "\n\n```python\nimport re\n\ncard_num1"
            },
            {
                "text": " \"^\\d{4}[- ]?\\d{"
            }
        ]
    },
    {
        "expression": "^(0|([1-9]\\d{0,3}|[1-5]\\d{4}|[6][0-5][0-5]([0-2]\\d|[3][0-5])))$",
        "raw_prompt": "Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted.",
        "refined_prompt": "Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted.\nMatch examples:\n- \"0\"\n- \"1000\"\n- \"65535\"\nNon-match examples:\n- \"65536\"\n- \"99999\"",
        "matches": [
            "0",
            "1000",
            "65535",
            "4815",
            "9494",
            "9786",
            "152",
            "654",
            "79",
            "999",
            "333",
            "15",
            "94"
        ],
        "non_matches": [
            "65536",
            "99999",
            "0123",
            "84956123",
            "84956123",
            "894512",
            "849516",
            "489561",
            "-984516",
            "-9485162.49516",
            "48561.451",
            "51.84"
        ],
        "id": 1094,
        "output": [
            {
                "text": " r\"^((0[0-9])|([1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|([1-9]["
            },
            {
                "text": ".*[1-9]\\d*$\n\nExercise 2: Use the following RegEx to extract the IP address from a given string:\n\n.*[a-zA-Z0-9][a-zA-Z0-"
            },
            {
                "text": " \\d*[1-9][0-9]*\n\n2. Write a regular expression that matches URLs that begin with \"http\" or \"https\". \n\nAnswer: https?://[^\\s]+\n\n3. Write a regular"
            },
            {
                "text": " ((^|\\s)(\\d+)(\\s|$))\n\n5. Write a regular expression that matches all the email addresses found in a given text file. The email address format is defined as follows: the email address must start with a username,"
            },
            {
                "text": " [0-9][A-Za-z0-9\\-_]*\n- \"0\"Generate a RegEx for this description. \nAnswer: [0-9\\-_]*\n\nThe first part of your regex, ["
            },
            {
                "text": " 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,"
            },
            {
                "text": " [0-9]{1,3}(?:\\.[0-9]{1,3}){0,9}\n\n[3]\nWrite a Python function that takes a string and a list of numbers representing the port numbers to match."
            },
            {
                "text": " [0-9]{1,4}\n\n2. Write a RegEx to ensure that a string is of at least 3 characters long and consists of only letters, digits, and underscores. Match only strings that meet the criteria.\nExample:\n-"
            },
            {
                "text": " A (ASCII value 0) / B (ASCII value 255) = C (ASCII value 128) / D (ASCII value 255) = E\n\nExercise 1: \nWrite a Python program that asks the user for a password and check"
            },
            {
                "text": " ^(?!.*[^0]$)((1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0)+(00?"
            }
        ]
    },
    {
        "expression": "^(([+]31|0031)\\s\\(0\\)([0-9]{9})|([+]31|0031)\\s0([0-9]{9})|0([0-9]{9}))$",
        "raw_prompt": "Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed.",
        "refined_prompt": "Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed.\nMatch examples:\n- \"+31 0205315386\"\n- \"0031 (0)205315386\"\n- \"0205315386\"\nNon-match examples:\n- \"020531538\"\n- \"1205315386\"",
        "matches": [
            "+31 0205315386",
            "0031 (0)205315386",
            "0205315386",
            "0742040766",
            "0930386633",
            "+31\u2000(0)509476475",
            "0402503841",
            "+31\u20050820214360",
            "0728972798",
            "0763565474",
            "+31\u00a00592427952",
            "0970012708",
            "0031\u205f0201473409"
        ],
        "non_matches": [
            "020531538",
            "1205315386",
            "020531538677",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "AAAAAAA",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "$12/132/90"
        ],
        "id": 1103,
        "output": [
            {
                "text": " This must be a phone number in the format +31 <country code> <area code>, where <country code> can be any 3-"
            },
            {
                "text": " ^(0[1-9]|1[012])[0-9]{3}$\n\nExercise 4: "
            },
            {
                "text": " ^[0-9]{3}[0-9]{4}[0-9]{4}$\n\n1"
            },
            {
                "text": "\n\n- (0|[1-9][0-9]|[1-9])[0-9]{3}"
            },
            {
                "text": "\nhttps://regex101.com/r/lz0Z0Z/1\n\n\n\n\n# Chapter: The use"
            },
            {
                "text": " \\+31 (0) \\d8 5315 386 \n\nExercise 4:\nWrite a Python program to match all dates in"
            },
            {
                "text": " \n\\+\\d{1,3}\\s\\d{1,4}(?:\\s\\d{1,4"
            },
            {
                "text": " \n- The RegEx should start with a number and then have 10 digits.\n- The RegEx should have no spaces or special characters"
            },
            {
                "text": " ^(?=\\+|\\-)[0-9]{10}$\n\nExercise 2: \nThink of a"
            },
            {
                "text": " ^(0[1-9]|1[0-2])\\d{9}$ \n\nExercise 2: Write"
            }
        ]
    },
    {
        "expression": "^[0-9]{10}$|^\\(0[1-9]{1}\\)[0-9]{8}$|^[0-9]{8}$|^[0-9]{4}[ ][0-9]{3}[ ][0-9]{3}$|^\\(0[1-9]{1}\\)[ ][0-9]{4}[ ][0-9]{4}$|^[0-9]{4}[ ][0-9]{4}$",
        "raw_prompt": "Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.\nOther Matching:\n9999999999, 9999 9999, (09)99999999",
        "refined_prompt": "Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.\nMatch examples:\n- \"9999 999 999\"\n- \"(09) 9999 9999\"\n- \"99999999\"\nNon-match examples:\n- \"99999999999\"\n- \"9999999\"",
        "matches": [
            "9999 999 999",
            "(09) 9999 9999",
            "99999999",
            "6890372130",
            "24220180",
            "6677 269 721",
            "2039309673",
            "5537 492 124",
            "(07) 9286 8727",
            "6730 687 860",
            "13356184",
            "(03) 6460 7304",
            "1702 315 807"
        ],
        "non_matches": [
            "99999999999",
            "9999999",
            "(99)99999999",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1104,
        "output": [
            {
                "text": " [a-z]{1,40}-?[0-9]{9}$\n\n3. Write a regular expression to validate phone numbers:\n- \"("
            },
            {
                "text": "  [9]{10}\\d{11}\n\n2. Write a regular expression to match a phone number in the format: \"(XXX) XXX-XXXX\".\nAnswer"
            },
            {
                "text": " \\d{14,15}\n\n3. Using regular expressions to extract all email addresses from a text file.\n\n```python\nimport re\nwith open(\"text"
            },
            {
                "text": " (09|0?9) [0-9]*\n\n2. What is the purpose of using the backslash (\\) in the RegEx code? \n"
            },
            {
                "text": "\n^([0-9]{1,2})([0-9]{0,3})([0-9]{0,3})$\n\n"
            },
            {
                "text": " (.*)$\n\n3. Describe the difference between a RegEx pattern and a string pattern.\nAnswer: A string pattern is a text pattern that is used to identify"
            },
            {
                "text": "\n- (\\d{3} \\d{3} \\d{3})\n\nExercise 2:\nMatch all of these examples:\n\n1. 12345"
            },
            {
                "text": "\n[0-9]{5} (?:\\.[0-9]{4}){0,1}\n\nExercise #2: \nUse case:"
            },
            {
                "text": "\n\n^[13][1-9][9][9]$|^[05][0-9][0-9][0-9]$\n\nExercise"
            },
            {
                "text": " \"?\"*10\n\n- \"99999999999\"\n- \"999999999999\"\n- \"999999999999\"\n\n- \"(09) 9999 9999\""
            }
        ]
    },
    {
        "expression": "^(N[BLSTU]|[AMN]B|[BQ]C|ON|PE|SK)$",
        "raw_prompt": "Matches Canadian provincial codes. Similar to the one already posted but smaller, faster, and will correctly return the results in one match group rather than using several so it's much friendlier.",
        "refined_prompt": "Matches Canadian provincial codes.\nMatch examples:\n- \"ON\"\n- \"PE\"\n- \"NB\"\nNon-match examples:\n- \"OB\"\n- \"NM\"",
        "matches": [
            "ON",
            "PE",
            "NB",
            "BC",
            "AB",
            "NT",
            "NL",
            "SK",
            "NS",
            "QC",
            "NU",
            "MB"
        ],
        "non_matches": [
            "OB",
            "NM",
            "QQ",
            "JJ",
            "OKJ",
            "XY",
            "YZ",
            "ZA",
            "u09nKLJG FSL",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1105,
        "output": [
            {
                "text": " (This list can be expanded to include additional codes)\n- \"A1\"\n- \"A2\"\n- \"A3\"\n- \"A6\"\n- \"A7\"\n- \"A8\"\n- \"A9\"Non-match examples: \"AS\", \"B1\", \"B2\", \"OQ\", \""
            },
            {
                "text": " \\b[A-Z]{1}\\d{1,}[A-Z]\\d{1}\\b \n\nExercise 4:\nWhat is the difference between \"non-standardized formats\" and \"standardized formats\" in RegEx? \nAnswer: Non-standardized formats are more complex, while standardized formats are more"
            },
            {
                "text": " \"^[ON]-?[PE]-?[NB]-?$\"\n\n3. The following set of numbers contains three numbers, two 4's, and one 7. Write a RegEx that will match the same set of numbers.\nSet of numbers: 4 4 7 7\nAnswer: \"\\d\\d\\d\\d\\d\\d"
            },
            {
                "text": " \"^[A-Z][a-z][A-Z]$\"\n\nExercise 2: \nGenerate a RegEx for this list of phone numbers. \n\"555-555-1234\"\n\"555-5555-1234\"\n\"555-55-1234\"\n\"222-1234-5"
            },
            {
                "text": " \nRegex: [A-Z]{2,3}(-[A-Z]{1,2})?\n\nExercise 2: Validating a US zip code.\nValid zip codes are 5 digits long and can only contain digits and hyphens. \nCreate a RegEx pattern for this description. \nAnswer: \n"
            },
            {
                "text": " \n\n**Exercise 3:**\n\nCreate a RegEx that matches email addresses in the following formats:\n- \"hello@example.com\"\n- \"myemail.name.email.com\"\n- \"test@domain.name.com\"\n\nAnswer: \n\n**Exercise 4:**\n\nCreate a Reg"
            },
            {
                "text": " \n^[AB]\\d$|^[AB]\\d\\d$|^[AB]\\d{3}$\n\nWe hope this exam helped you understand the concept of RegEx, and how it can be used to extract information from strings. Keep practicing and exploring different RegEx patterns to become more proficient in this useful tool!"
            },
            {
                "text": " \"^([A-Z][a-z]?[0-9]?)$\"\n\nExercise 5:\nQuestion:\nWrite a Python program that takes a string as input and generates a RegEx to match the pattern \"a\" followed by any number of \"b\" characters.\nAnswer:\nstring = \"ababab\"\n"
            },
            {
                "text": " \"^(ON|PE)+$\"\n\nExercise 2: Create a RegEx to validate a phone number in the format of 555-6789.\nAnswer: \"^\\d{3}-\\d{3}-\\d{4}$\"\n\nExercise 3: Create a RegEx to validate a password that includes at"
            },
            {
                "text": " A list of valid provincial codes would be \"ON\", \"PE\", \"NB\".\n\n3. Write a RegEx for all characters that are neither letters nor digits.\nAnswer: [^a-zA-Z0-9]\n\n4. Write a RegEx for a string that starts with \"Hello\" then ends with \"world\".\n"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[012])$",
        "raw_prompt": "This will match numbers between 0 and 12. The 0? at the beginning will allow &quot;01&quot; as a valid match. This is useful for validation the month only component of a date part.",
        "refined_prompt": "This will match numbers between 0 and 12. The 0? at the beginning will allow &quot;01&quot; as a valid match. This is useful for validation the month only component of a date part.\nMatch examples:\n- \"05\"\n- \"5\"\n- \"12\"\nNon-match examples:\n- \"0\"\n- \"1a\"",
        "matches": [
            "05",
            "5",
            "12",
            "8",
            "10",
            "4",
            "07",
            "5",
            "03",
            "1",
            "2",
            "9",
            "11"
        ],
        "non_matches": [
            "0",
            "1a",
            "13",
            "132",
            "42",
            "57",
            "47",
            "87",
            "95",
            "67",
            "47",
            "83"
        ],
        "id": 1107,
        "output": [
            {
                "text": " [0-9]{1}\n\nA:\n\nI assume you are validating a date with MM-DD-YYYY format. If that's"
            },
            {
                "text": " [0-9]?\n\nHow do I generate this regex? Do I use RegEx or split.\n\nA:\n\nThis will match numbers between"
            },
            {
                "text": " [0-9a-zA-Z]\n- \"02\"\n- \"02a\"Generate a RegEx for this description. \nAnswer"
            },
            {
                "text": " \\d\n\nA:\n\nuse ([0-9]|1[0-9]|2[0-9]|3[0-1"
            },
            {
                "text": "\n- [0-3][1-9]|[1-9][0-9]\nThis will match numbers between 0 and 12. The [0"
            },
            {
                "text": " \"0-9\"|\"1[0-9]|1[0-9][0-9]\"|\"00\"|\"01\"|\""
            },
            {
                "text": "\n/1+\n\n- \"5a\"Generate a RegEx for this description.\nAnswer:\n/5+\n\n- \"12a\""
            },
            {
                "text": " (0?[1-9]|1[012])\\d\n\n1) Create a regex for validating a date, with the format mm/dd"
            },
            {
                "text": " \"0[6-9]|1[0-2]\"\nThis will match numbers between 0 and 9. The 0? at the beginning will allow &qu"
            },
            {
                "text": " [^0-9]\n- \"01\"Generate a RegEx for this description.\nAnswer: [0-9]\n- \"01a\""
            }
        ]
    },
    {
        "expression": "^((18[5-9][0-9])|((19|20)[0-9]{2})|(2100))$",
        "raw_prompt": "Will check to ensure the data is between 1850 and 2100.",
        "refined_prompt": "Will check to ensure the data is between 1850 and 2100.\nMatch examples:\n- \"1850\"\n- \"1977\"\n- \"2100\"\nNon-match examples:\n- \"1800\"\n- \"a\"",
        "matches": [
            "1850",
            "1977",
            "2100",
            "2094",
            "2064",
            "1889",
            "1872",
            "2088",
            "1956",
            "1894",
            "1872",
            "1866",
            "1899"
        ],
        "non_matches": [
            "1800",
            "a",
            "2101",
            "5679",
            "9999",
            "0987",
            "9797",
            "5467",
            "4568",
            "0986",
            "5758",
            "4637"
        ],
        "id": 1109,
        "output": [
            {
                "text": " The RegEx should be \"^[13579]*$\" as it only allows numbers between 13579.\n\nI hope you enjoyed exploring RegEx with me today, and I hope these exercises have helped solidify your understanding of this topic. As always, remember that RegEx can be a powerful tool in your programming"
            },
            {
                "text": " \n\n**Exercise 2:**\n\nConsider the following example:\n\n```python\nimport re\n\ndate_string = \"The event happened on January 1, 1850, and on June 30, 1977.\"\nevent_month = \"January\"\n```\n\nWrite a Python script that will"
            },
            {
                "text": " The RegEx could be \"^1850-2100$\".\n\n5. You have a list of data for the city's population for each year:\ndata = \"1917 - 10,000,\n       1837 - 12,000,\n       1875 - 15,000,\n       1889"
            },
            {
                "text": " \"^[1-9][0-9]*$\"  \n\n4.  Use `isinstance()` to check if the variable `my_date` is a `date` object.\n\n```python\nfrom datetime import datetime\n\nmy_date = datetime(2022"
            },
            {
                "text": " match only the words that begin with \"18\", \"19\", or \"20\"\n- \"1957\"\n- \"1955\"\n- \"1956\"\n- \"1958\"\n- \"1962\"\n- \"1962a\"\n\"\"\"\n\n# Solution to the first exercise\nmat"
            },
            {
                "text": " (Example) \"^[19]\\d{2}[-/]\\d{2}[-/]\\d{2}$\"\n\nExercise 5: \nMatch examples:\n- \"abc\"\n- \"def-ghi\"\n- \"ghijklm\"\n"
            },
            {
                "text": " \n`RegEx for Matching date between 1850 and 2100`\n\nExercise 4:\nMatch examples:\n- \"Jan 12, 2021\"\n- \"Jan 12, 2021\"\n- \"Jan 12, 2021\"\nNon-match examples:\n- \"Jan 12, 2021\"\n- \"Jan"
            },
            {
                "text": " (a) (^|[ ]|,|$)\n\n2. Match examples:\n- \"1,000\"\n- \"5,000\"\n- \"200,000\"\nNon-match examples:\n- \"1,000,000\"\n- \"4,000,000,000"
            },
            {
                "text": " \"^[0-9]'[0-9]'[0-9]'[0-9]'[0-9]?'\"\n\nExercise 4:\nMatch the following terms to their definitions:\n- \"Tetrode\"\n- \"Vessel\"\n- \"Antenna\"\n- \""
            },
            {
                "text": " [^\\d\\s]\n\n4: Write a Python program that takes a string as input and prints all the words that contain the letter 'a'.\nSample Input: \"The quick brown fox jumps over the lazy dog\"\nSample Output: \"quick\", \"over\", \"lazy\"\nExplanation"
            }
        ]
    },
    {
        "expression": "^(\\w+=[^\\s,=]+,)*(\\w+=[^\\s,=]+,?)?$",
        "raw_prompt": "validate comma separated key/value pair",
        "refined_prompt": "validate comma separated key/value pair\nMatch examples:\n- \"foo=bar\"\n- \"foo1=bar1,foo2=bar2\"\n- \"foo1=bar1,foo2=bar2,\"\nNon-match examples:\n- \"foo=\"\n- \"foo1=bar1 foo2=bar2\"",
        "matches": [
            "foo=bar",
            "foo1=bar1,foo2=bar2",
            "foo1=bar1,foo2=bar2,",
            "name=John,age=30",
            "color=blue,size=large",
            "city=NewYork,state=NY",
            "fruit=apple,fruit=banana",
            "a=b",
            "b=c",
            "d=e",
            "fasd=fdsa",
            "gwre=gf",
            "ywr=bg"
        ],
        "non_matches": [
            "foo=",
            "foo1=bar1 foo2=bar2",
            "foo1=bar1foo2=bar2",
            "6cv7b89",
            "f67gyvbyu",
            "==f32ew",
            "f34ew=f34efw=rf2w",
            "43rt=3gr4=3gr=",
            "=43we==f24=e3w=f3=g",
            "=f34=ew=f3==f3=g",
            "=f34r=evg=3rg=",
            "f3erv=3==rv"
        ],
        "id": 1121,
        "output": [
            {
                "text": " (foo)\\s*=\\s*(.*)\n\nExercise 2:\nWrite a RegEx to match a string that starts with \"http://\" or \"https://\" and ends"
            },
            {
                "text": " foo\\s*=\\s*[^,]*\nExercise 3:\nUsing the RegEx generated in Exercise 2, search for matches in the following strings:\n- \"foo="
            },
            {
                "text": " foo(,foo\\s*)+\n\nExercise 4:\nGenerate a RegEx for this description:\nMatch examples:\n- \"foo=bar\"\n- \"foo1="
            },
            {
                "text": "\n^(\\w+)\\s*=\\s*([^\\,]+),?\n\n(Note that the parentheses in a single-character group are needed to ensure that the comma is matched"
            },
            {
                "text": " ~^[a-zA-z0-9_\\-\\=\\,\\]\\s]+=([^,]+)$\n\nExercise 2: Matching a valid file"
            },
            {
                "text": " [^=]*(\\w+)\\s*=\\s*[^,]*\n\nExercise 3:\nWrite a Python script that prompts the user for a comma separated key/value"
            },
            {
                "text": " foo=[a-zA-Z0-9_.-]+, foo1=[a-zA-Z0-9_.-]+, foo2=[a-zA-Z0"
            },
            {
                "text": " foo\\s*=\\s*[^\\s,]+\n- \"foo1=bar1\"Match this. \nAnswer: foo1=[^\\s,]+\n- \""
            },
            {
                "text": "\nfoo\\s*=\\s*(.*,)*\n\nExplanation:\n\nfoo matches the string \"foo\" \n\\s* matches zero or more whitespace characters "
            },
            {
                "text": " \n\"foo=([^, ]+)+(,|$)\"\nExercise 2:\nGiven the text \"The quick, brown, fox jumps over the lazy dog\",\nWrite a Reg"
            }
        ]
    },
    {
        "expression": "^(((((0[1-9])|(1\\d)|(2[0-8]))\\/((0[1-9])|(1[0-2])))|((31\\/((0[13578])|(1[02])))|((29|30)\\/((0[1,3-9])|(1[0-2])))))\\/((20[0-9][0-9])|(19[0-9][0-9])))|((29\\/02\\/(19|20)(([02468][048])|([13579][26]))))$",
        "raw_prompt": "matches a date in dd/mm/yyyy format",
        "refined_prompt": "matches a date in dd/mm/yyyy format\nMatch examples:\n- \"01/01/2001\"\n- \"29/02/2004\"\n- \"17/12/2098\"\nNon-match examples:\n- \"32/12/2001\"\n- \"29/02/2005\"",
        "matches": [
            "01/01/2001",
            "29/02/2004",
            "17/12/2098",
            "30/01/2072",
            "30/08/2035",
            "16/02/1903",
            "27/11/2086",
            "29/02/1912",
            "30/12/2049",
            "29/02/2096",
            "31/07/2079",
            "30/08/2088",
            "29/02/1928"
        ],
        "non_matches": [
            "32/12/2001",
            "29/02/2005",
            "05/13/2005",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1124,
        "output": [
            {
                "text": " This is a very hard question, but here is a possible answer:\n\nregex = r\"^(0[1-9]|[12][0-9]|3[01])/(0[1-"
            },
            {
                "text": "\nThe regular expression for a date is D/M/Y format in dd/mm/yyyy.\n\n2. Write a regular expression for a phone number that allows for optional dashes and numbers.\n\n```"
            },
            {
                "text": "\nregex = \"[0-9]{2}\\/[0-9]{2}\\/[0-9]{4}\"\n\nExercise 2: \nReplace all occurrences of the \" \" character"
            },
            {
                "text": " To match dates in dd/mm/yyyy format, we use the following regular expression: \"^[0-9]+/[0-9]+/[0-9]+$\".\n\nConclusion\n\nIn this"
            },
            {
                "text": " [^/\\d/]*[0-9]{2}\\.[0-9]{2}\\.[0-9]{4}.*\n\nExercise 3: \nCreate a RegEx that matches"
            },
            {
                "text": " [^0-9/]*? \n\n3. Write a RegEx to match all email addresses in the following text:\n\"Please send your message to john.doe@gmail.com or jane."
            },
            {
                "text": " dd/mm/yyyy, where / is the delimiter. \n\n2. Use the `re.split()` method to split a string containing dates in the format \"dd/mm/yyyy\" into a"
            },
            {
                "text": " This one is challenging, I tried to match a date in dd/mm/yyyy format, and I think I should use something like:\nimport re\nyear = \"2003\"\nmonth = \"12\"\nday ="
            },
            {
                "text": " (.*)([0-9]{2}))(.*)\nExercise 4: Write a RegEx to replace all instances of a word in a text with another word.\nAnswer: (.*)(old word)("
            },
            {
                "text": " \"^(0|(1[012])|([12][0-9]))/(0?[1-9])/$\"\n\n3. Write a Python program to validate the following email addresses:\n- \""
            }
        ]
    },
    {
        "expression": "^(([A-Za-z]+[^0-9]*)([0-9]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([A-Za-z]+[^\\W]*)([\\W]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^A-Za-z]*)([A-Za-z]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^0-9]*)([0-9]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))|(([0-9]+[^A-Za-z]*)([A-Za-z]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([0-9]+[^\\W]*)([\\W]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))$",
        "raw_prompt": "Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\\W). It doesn't matter the charaters position. See the Mathching Examples.\nQuestion? Write an Email to me.",
        "refined_prompt": "Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\\W). It doesn't matter the characters position.\nMatch examples:\n- \"test22!!\"\n- \"!!test22\"\n- \"22!!test\"\nNon-match examples:\n- \"test22\"\n- \"!!test\"",
        "matches": [
            "test22!!",
            "!!test22",
            "22!!test",
            "f76f%F%",
            "^&TF12^",
            "%&^F^&231",
            "56f7%^&",
            "C%&V24",
            "6865-11-04 20:47:46afds",
            "nd.edu12",
            "$1.19daf",
            "78g78^&",
            "2f3f%$@"
        ],
        "non_matches": [
            "test22",
            "!!test",
            "22!!",
            "7g78v78v8",
            "v",
            "v78v78v78vy6y",
            "g6g",
            "66768787",
            "78787",
            "*&G&*B",
            "&*GH&*&*G&*G",
            "76g78"
        ],
        "id": 1134,
        "output": [
            {
                "text": " \\w+\n```python\nregex = r\"\\w+\"\ntext = \"test22!!test\"\nprint(re.findall(regex, text"
            },
            {
                "text": "\n^(?=.*?[a-z])(?=.*?\\d)(?=.*?[\\W])[a-z\\d!@#$%"
            },
            {
                "text": " 1-3 Letters and 1 Number\n\nA:\n\nThe following RegEx will match the word with any uppercase letter, any lowercase letter, any digit and any special"
            },
            {
                "text": "^[a-zA-Z\\d\\W]+$\n\nA:\n\nThis is a case where you could use positive lookahead:\n[^A-Z"
            },
            {
                "text": " ([0-9]\\w*)([!@#$%])\n\n# Generate a Regular Expression for Username Validation\nusername = re.compile(r\"(^"
            },
            {
                "text": " \n\n[\\p{L}\\d\\p{M}]+\n\n\"The first group matches one or more letters, digits or special characters.\" -  Regex101"
            },
            {
                "text": " ^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).*$\n\nA:\n\nYou can use the combination"
            },
            {
                "text": "\n(?i)(?=^.{1,})(?=[a-zA-Z])(?=\\d)(?=!\\W)[\\w!"
            },
            {
                "text": "^[a-zA-Z\\w\\d]{5,}$\n\n6. Write a regular expression to validate that a credit card number is 16 digits long."
            },
            {
                "text": " ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\\W)(?=.*[a-"
            }
        ]
    },
    {
        "expression": "(^(\\d+)$)|(^(\\d{1,3}[ ,\\.](\\d{3}[ ,\\.])*\\d{3}|\\d{1,3})$)",
        "raw_prompt": "Searches for number greater than 0 with thousand delimiter as space, comma or period.",
        "refined_prompt": "Searches for number greater than 0 with thousand delimiter as space, comma or period.\nMatch examples:\n- \"1 234 567\"\n- \"1.234.567.890\"\n- \"1,234\"\nNon-match examples:\n- \"-12,990\"\n- \"100.03\"",
        "matches": [
            "1 234 567",
            "1.234.567.890",
            "1,234",
            "12",
            "44",
            "46",
            "886",
            "976",
            "865",
            "476",
            "999",
            "867",
            "2,854"
        ],
        "non_matches": [
            "-12,990",
            "100.03",
            "0,05",
            "y7v7",
            "g78yg",
            "$23.454",
            "43-5432",
            "-4123",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1135,
        "output": [
            {
                "text": " ^\\d{1,3}(?:\\.\\d{3})*\\d{3}$. The RegEx matches any sequence of 1 to 3 digits (including. or *), with optional"
            },
            {
                "text": " \\d+,\\d{3}\n\nExercise 12: Write a Python function to convert a string to uppercase and title case.\nAnswer:\ndef to_title_case(string):\n"
            },
            {
                "text": " -20+[0-9]{1,2}.\n\n4. Write a program that receives a string and extracts the number from it. The number has to be extracted only if it has a value greater"
            },
            {
                "text": " \\d+\\.\\d+|\\d+\n3. Write a regular expression that finds all words that contain exactly two vowels (a, e, i, o, u). \nAnswer: ["
            },
            {
                "text": "\nThe value to be extracted is the number after the first comma, period, or space.\n\n[Insert full RegEx pattern]\n\nExercise 3:\nWrite a Python function that takes a string as"
            },
            {
                "text": "\n\n[0-9]{1,3}\\.[0-9]{1,4}\n\nExercise 2: \n\nWrite a Python program that takes a string input from the user and"
            },
            {
                "text": "\nimport re\ntest_string = \"-12,990\"\n# This is for testing only, not for development\nregex = re.compile(r'-\\d{1,3}([,"
            },
            {
                "text": "\n\nnumber > 0\n\nA:\n\nI am not sure if this is what you are looking for:\n^\\d+$\n\nEdit:\n^\\d+\\.\\d+$"
            },
            {
                "text": "\n\nExercise 3:\nGiven a string \"12,000.00,234.56\", separate the value using a comma or period delimiter\nAnswer:\n12,000.00,234.56"
            },
            {
                "text": " [0-9]*,[0-9]*[.]?[0-9]*\n```\n\n2.Write the RegEx pattern to match email addresses. \nExample:\n-"
            }
        ]
    },
    {
        "expression": "(?:/\\*[\\w\\W]*?\\*/|//[^\\n]*?$|\\#[^\\n]*?$)",
        "raw_prompt": "Return all comment lines (starts with //) and regions (serounded by /* */) as well as compiler arguments (#) in C# code",
        "refined_prompt": "Return all comment lines (starts with //) and regions (serounded by /* */) as well as compiler arguments (#) in C# code\nMatch examples:\n- \"// some comment\"\n- \"#region myRegion\"\n- \"/* other comment */\"\nNon-match examples:\n- \"for(int i = 0; i &lt; 10; i++)\"\n- \"[XmlAttribute(&quot;somthing_else&quot;)\"",
        "matches": [
            "// some comment",
            "#region myRegion",
            "/* other comment */",
            "// fhadusinb",
            "// fadsuihf8dahs",
            "// bfa8ydsb8",
            "// f8aydsgh",
            "#8gyvb",
            "#EDRT&HUU",
            "#V^Y&G&G",
            "#Hu8ghu8",
            "/* other fa2we */",
            "/* f2ew3 sda */"
        ],
        "non_matches": [
            "for(int i = 0; i &lt; 10; i++)",
            "[XmlAttribute(&quot;somthing_else&quot;)",
            "String name = &quot;MyNa",
            "(12) 324 653210",
            "234/423/5243",
            "$23./* 454",
            "43-/* 5432",
            "25462/* 7g.256",
            "245/* /524/12",
            "/* (0xx12) 7256 2345154",
            "/* 34.31",
            "/* $12/132/90"
        ],
        "id": 1139,
        "output": [
            {
                "text": " (\\s+)((&quot;somthing_"
            },
            {
                "text": "\n- \"for(int i = 0; i &lt;"
            },
            {
                "text": " \n//([^\\n]*)\\n\n\nReg"
            },
            {
                "text": "\n#region some comment   // some comment\n#region myRegion"
            },
            {
                "text": " (\"for(int i = 0; i &lt; 10;"
            },
            {
                "text": "  // for(int i = 0; i < 10; i"
            },
            {
                "text": "\n\n// some comment\n/* some comment */\n/* other"
            },
            {
                "text": "\n//some comment\n//region myRegion\n///* other comment"
            },
            {
                "text": "\n#region myRegion\nGenerated by: RegExGenerator"
            },
            {
                "text": " [XmlAttribute:&quot;somthing_else"
            }
        ]
    },
    {
        "expression": "(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})",
        "raw_prompt": "Accurate Australian postal code verification.\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\nACT: 0200-0299 and 2600-2639.\nNSW: 1000-1999, 2000-2599 and 2640-2914.\nNT: 0900-0999 and 0800-0899.\nQLD: 9000-9999 and 4000-4999.\nSA: 5000-5999.\nTAS: 7800-7999 and 7000-7499.\nVIC: 8000-8999 and 3000-3999.\nWA: 6800-6999 and 6000-6799.",
        "refined_prompt": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999.\r\nWA: 6800-6999 and 6000-6799.\nMatch examples:\n- \"0200\"\n- \"7312\"\n- \"2415\"\nNon-match examples:\n- \"0300\"\n- \"7612\"",
        "matches": [
            "0200",
            "7312",
            "2415",
            "7876",
            "2913",
            "8189",
            "7808",
            "7975",
            "2756",
            "7195",
            "2875",
            "7286",
            "4528"
        ],
        "non_matches": [
            "0300",
            "7612",
            "2915",
            "e23w",
            "r32efwf",
            "43ff3",
            "f34g",
            "f23we",
            "f32ewr",
            "u46h5",
            "65hk",
            "7y6t"
        ],
        "id": 1145,
        "output": [
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            },
            {
                "text": "Accurate Australian postal code verification.\r\nAustralia has 4-digit numeric postal codes with the following state based specific ranges.\r\nACT: 0200-0299 and 2600-2639.\r\nNSW: 1000-1999, 2000-2599 and 2640-2914.\r\nNT: 0900-0999 and 0800-0899.\r\nQLD: 9000-9999 and 4000-4999.\r\nSA: 5000-5999.\r\nTAS: 7800-7999 and 7000-7499.\r\nVIC: 8000-8999 and 3000-3999"
            }
        ]
    },
    {
        "expression": "([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\\ ?([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])",
        "raw_prompt": "Accurate Canadian postal code format verification.\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).",
        "refined_prompt": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B0\"\n- \"L0R 1B1\"\n- \"L0R1B9\"\nNon-match examples:\n- \"W1R 4B0\"\n- \"L0R 1D1\"",
        "matches": [
            "M1R 4B0",
            "L0R 1B1",
            "L0R1B9",
            "L7N 1E3",
            "E6R 3T1",
            "L5N5L4",
            "P3P 1H8",
            "A0P9Z1",
            "H9L7Y8",
            "T3Y1E9",
            "A1Z 3B7",
            "H5A7K6",
            "X8Y 7N7"
        ],
        "non_matches": [
            "W1R 4B0",
            "L0R 1D1",
            "LOR1B9",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "u09nKLJG FSL",
            "BUFISD",
            "V8YVY",
            "87YV78V"
        ],
        "id": 1146,
        "output": [
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B6"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B2"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B1"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B5"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B3"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B9"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B0"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B3"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B9"
            },
            {
                "text": "Accurate Canadian postal code format verification.\r\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present).\nMatch examples:\n- \"M1R 4B1"
            }
        ]
    },
    {
        "expression": "(([A-Z]{1,2}[0-9][0-9A-Z]?)\\ ([0-9][A-Z]{2}))|(GIR\\ 0AA)",
        "raw_prompt": "Accurate UK postal code format verification.\nUK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.",
        "refined_prompt": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"",
        "matches": [
            "M2 5BQ",
            "EC1A 1HQ",
            "GIR 0AA",
            "UO7 3UE",
            "MA5 5FQ",
            "YW7 1DL",
            "Q2 1YQ",
            "X0 5QN",
            "ZY9 7PE",
            "SO6 3YW",
            "T4 3OF",
            "XS7 1KP",
            "XE9 1JP"
        ],
        "non_matches": [
            "M2 BQ5",
            "E31A 1HQ",
            "GIR0AA",
            "INDIANA",
            "234",
            "3nf@",
            "43-5432",
            "notre dame",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1148,
        "output": [
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate all"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate all"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate more"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate codes"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate a"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate codes"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate UK"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate a"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate a"
            },
            {
                "text": "Accurate UK postal code format verification. UK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA.\nMatch examples:\n- \"M2 5BQ\"\n- \"EC1A 1HQ\"\n- \"GIR 0AA\"\nNon-match examples:\n- \"M2 BQ5\"\n- \"E31A 1HQ\"Generate a"
            }
        ]
    },
    {
        "expression": "(NL-?)?[0-9]{9}B[0-9]{2}",
        "raw_prompt": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.",
        "refined_prompt": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.\nMatch examples:\n- \"NL123456789B12\"\n- \"NL-603781070B39\"\n- \"404760885B21\"\nNon-match examples:\n- \"NL123456789012\"\n- \"NL52/2/54/245\"",
        "matches": [
            "NL123456789B12",
            "NL-603781070B39",
            "404760885B21",
            "NL-928678468B98",
            "955593039B36",
            "NL400065759B60",
            "067135372B53",
            "NL-723046312B09",
            "954419151B44",
            "NL-449870839B21",
            "NL-994662298B52",
            "448404466B38",
            "013604724B16"
        ],
        "non_matches": [
            "NL123456789012",
            "NL52/2/54/245",
            "NL2534/52435234/2453",
            "NLafdsaf.adijs",
            "NL9ijn",
            "NL3nf@",
            "NL43-5432",
            "NL254627g.256",
            "NL245/524/12",
            "NLcom.edu.github",
            "NL(0xx12) 62509@",
            "NL++63453.345"
        ],
        "id": 1164,
        "output": [
            {
                "text": " \n(?<!NL)(?<memberid>\\d{7})(?!\\d{3})/(?!\\d{9}"
            },
            {
                "text": " (nl):[A-Za-z][0-9][0-9]\n\nCode:\nnl_match = re.search(r"
            },
            {
                "text": " A regex that matches any number starting with a 3 and followed by a 5 or 6, then a 2-digit number (any two digits), then followed by a"
            },
            {
                "text": "\n\n```python\nimport re\n\n# Define a regular expression for NVAT Number format verification with optional member state definition\npattern = r\"\\"
            },
            {
                "text": " (NL[0-9]{1,3}[0-9]{7}[A-Z][0-9]{2}["
            },
            {
                "text": " \"NL[A-Z][0-9]{6}[B-9][0-9]{6}[-]{2}["
            },
            {
                "text": " \n[A-Z]\\d{5}[- ](A-Z)|([0-9]{3})[- ][0"
            },
            {
                "text": " NL(?:\\d{1,3}[-\\.\\d]*(?:\\d{3}[-\\.\\d]*){1"
            },
            {
                "text": "\nNL-6078-2-54-245\nNL-1235-78-90-6\nNL-6078-2-54-245"
            },
            {
                "text": " NL[0-9]{4}[-/][0-9]{2}[-/][0-9]{3}[-"
            }
        ]
    },
    {
        "expression": "^\\s*([\\(]?)\\[?\\s*\\d{3}\\s*\\]?[\\)]?\\s*[\\-]?[\\.]?\\s*\\d{3}\\s*[\\-]?[\\.]?\\s*\\d{4}$",
        "raw_prompt": "US 10-Digit Phone number matching.\n*Requires Area Code\n*Brackets optional, supports: () and []\n*seperators optional, supports: - and .\n*whitespace optional",
        "refined_prompt": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or .) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"",
        "matches": [
            "6105551515",
            "(610) 555 - 1212",
            "[610]555.1212",
            "(123) 456-7890",
            "[456]789-0123",
            "(555)555.5555",
            "123-456-7890",
            "555 555 5555",
            "(123)4567890",
            "987.654.3210",
            "[111]222-3333",
            "555-555-5555",
            "123.456.7890"
        ],
        "non_matches": [
            "1 (610) 555-1212",
            "(610) 555-1212 ext*",
            "[12345]67890",
            "(123) 456.7890a",
            "5555-5555-5555",
            "(123)[456]7890fads",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1165,
        "output": [
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: (\\d{3}\\([\\"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: Match any 10 digit US phone numbers with"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: \\[(?P<area_"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: The pattern should be \"(\\d{"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: (0-9)(0-9"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: \"(\\(?)(\\d{"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: \n([0-9]{"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer:\n'^(?:([0"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: [0-9]{3}"
            },
            {
                "text": "match 10-digit US phone numbers with optional brackets (either () or []) around the area code and optional separators (either - or.) between the groups of digits. Whitespace is also optional around the phone number.\nMatch examples:\n- \"6105551515\"\n- \"(610) 555 - 1212\"\n- \"[610]555.1212\"\nNon-match examples:\n- \"1 (610) 555-1212\"\n- \"(610) 555-1212 ext*\"Generate a RegEx for this description. \nAnswer: \n\nimport re\n\nphone"
            }
        ]
    },
    {
        "expression": "^(([a-zA-Z]+\\d+)|(\\d+[a-zA-Z]+))[a-zA-Z0-9]*$",
        "raw_prompt": "Password validator that validates the password contains 1 letter (regardless of case) and 1 number",
        "refined_prompt": "Password validator that validates the password contains 1 letter (regardless of case) and 1 number\nMatch examples:\n- \"Password1\"\n- \"1Password\"\n- \"1Password1\"\nNon-match examples:\n- \"*Password1\"\n- \"*1Password*\"",
        "matches": [
            "Password1",
            "1Password",
            "1Password1",
            "f6f76f",
            "67f",
            "67fafd",
            "fa67f",
            "76f",
            "67vf87v877",
            "v7g97",
            "87v78g6",
            "6v6v6y6v7",
            "v7v7gb7u"
        ],
        "non_matches": [
            "*Password1",
            "*1Password*",
            "*1Password1*",
            "feafdsafd",
            "sfadsafds",
            "fqfd",
            "gafdfsda",
            "thytng",
            "ngfgt",
            "514351",
            "653752",
            "555413"
        ],
        "id": 1177,
        "output": [
            {
                "text": ".*\\d.*\\d.*\n- \"*Password123\"\n- \"*123Password\"\n- \"Password\"\n\"\"\"\n\n\"\"\"\n2. Write a Python function that takes a string as input and returns the string with all"
            },
            {
                "text": " ([a-zA-Z]|[0-9])\nExercise 2: Find all the email addresses in the following text:\n- \"I am emailing John. Please email me at john@example.com or johnd"
            },
            {
                "text": " ^[a-zA-Z]\\d[a-zA-Z]$\n\nExercise 4: Replace the above regular expression with an appropriate regular expression that matches exactly one uppercase letter and one digit.\nAnswer:"
            },
            {
                "text": " \n(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@#$%^&+=])\n\"\"\"\n\n\n# Chapter: The use of Python D"
            },
            {
                "text": "\n/^(?=.*[a-z])(?=.*\\d)[a-z\\d]{8,}$/\n\nExercise 4:\nCreate a dictionary that maps three strings to three RegEx patterns that"
            },
            {
                "text": " \n^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$\n\nExercise 5:\nCreate a"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[0-9])[a-z0-9]{8,}$\n \nExercise 2:\nQuestion: Write a RegEx pattern to match a string"
            },
            {
                "text": " \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$\"\n\n# 9.2.10 Using Common Password Patterns and Metrics with Password"
            },
            {
                "text": "\n\n```python\nimport re\n\ndef password_validator(password):\n    m = re.match(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d"
            },
            {
                "text": " ^(?=.{8,})(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\d\\W]{8,}$\n\nExercise 2:\n"
            }
        ]
    },
    {
        "expression": "^(?=.*[a-zA-Z].*[a-zA-Z])(?=.*\\d.*\\d)[a-zA-Z0-9]{6,20}$",
        "raw_prompt": "Password matching expression. Password must consists of at least 6 characters and not more than 20 characters. Password must contain only letters and digits. Password must contain at least 2 digits and at least 2 letters.",
        "refined_prompt": "Password matching expression. Password must consists of at least 6 characters and not more than 20 characters. Password must contain only letters and digits. Password must contain at least 2 digits and at least 2 letters.\nMatch examples:\n- \"a1b2c3\"\n- \"65c5t7c\"\n- \"6fv7cv8y\"\nNon-match examples:\n- \"aaaaa1\"\n- \"IUBUFID\"",
        "matches": [
            "a1b2c3",
            "65c5t7c",
            "6fv7cv8y",
            "8g7uycv8yv",
            "87yvv8v7",
            "78v8v78v",
            "78vv8u7b8",
            "78yvg78",
            "v78uvb8",
            "8c56rf56",
            "9h89h89ugh78gu",
            "76tc67f67y",
            "87g78ub8"
        ],
        "non_matches": [
            "aaaaa1",
            "IUBUFID",
            "BYUBUFISD8",
            "HUIFDHS*&H*(",
            "FUDUIHbydfusy",
            "8974293857289",
            "87423897586",
            "7867423687",
            "574689",
            "y87",
            "78h",
            "8yv7gt48h9urief8f74hru8gre45regreg4re"
        ],
        "id": 1189,
        "output": [
            {
                "text": " [a-z0-9]+ [a-z0-9] [a-"
            },
            {
                "text": "\n- \"^(?=.*[A-Z])(?=.*[a"
            },
            {
                "text": "\n/^(?=.*[a-z])(?=.*[0-"
            },
            {
                "text": " Regex = ^(?=.{6,20})(?=.*[a"
            },
            {
                "text": " \\b[A-Z]{2}[0-9]{4}["
            },
            {
                "text": " ^[a-z0-9]{1,6}[a-z0"
            },
            {
                "text": " (a-z0-9)([a-z0-9]){3}"
            },
            {
                "text": " aaa..1\n\nExercise 2: Write a Python function that takes a string as"
            },
            {
                "text": " https://regex101.com/r/zQv7l8/1\n"
            },
            {
                "text": "\n- ^((?=.*[a-z]).*(?=.*[A"
            }
        ]
    },
    {
        "expression": "^(?:(?:[+\\-]?\\$?)|(?:\\$?[+\\-]?))?(?:(?:\\d{1,3}(?:(?:,\\d{3})|(?:\\d))*(?:\\.(?:\\d*|\\d+[eE][+\\-]\\d+))?)|(?:\\.\\d+(?:[eE][+\\-]\\d+)?))$",
        "raw_prompt": "This regex will validate the given string is numeric",
        "refined_prompt": "This regex will validate the given string is numeric\nMatch examples:\n- \"$123.1234\"\n- \".123\"\n- \".123e+01\"\nNon-match examples:\n- \"asdf\"\n- \",\"",
        "matches": [
            "$123.1234",
            ".123",
            ".123e+01",
            "4563",
            "575",
            "6",
            "375",
            "46",
            "486",
            "58",
            "75",
            "6678",
            "4678"
        ],
        "non_matches": [
            "asdf",
            ",",
            "1,1",
            ".",
            "f56f",
            "567f",
            "67f",
            "76v",
            "76fv65f57gh",
            "h89",
            "hj98",
            "ju89h78"
        ],
        "id": 1199,
        "output": [
            {
                "text": " \n/^\\d+\\.\\d+$/\n\nA:\n\nYour regular expression is correct, but you don't need the dot there, and you can use a few more characters there to help it work:\n/^\\d+\\.?\\d*$/\n\nA:"
            },
            {
                "text": " \\d+(\\.\\d+)?\n\nExercise 2: \nWrite a Python code that will check if a given string only contains digits and decimal points.\nHint: You can use re.match() to check if a string matches a regular expression.\nSolution:\nif re.match(\"^"
            },
            {
                "text": " ^\\d+\\.\\d+$\n\nThe above regex will match and validate a string that contains numbers between 1 and 10 digits, after the decimal mark. The regex is anchored in the beginning of the string and the string should contain only digits and decimal marks (no other special characters, spaces or white spaces can"
            },
            {
                "text": " \"\\d+\\.\\d+\"\n\nExercise 5: Write a regex to validate a string as a proper email address.\nAnswer:\n^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-z"
            },
            {
                "text": " \nimport re\nregex = \"^[\\d\\.]+$\"\n\nIf you want to validate the string first, and then replace the string, you can do this:\ndef validate(s):\n    return regex.match(s)\n\ndef replace(s):\n    if"
            },
            {
                "text": " ([0-9]+(?:\\.[0-9]+)?)\n\nExercise 3:\n\nAdd the \"^\" and \"$\" symbols to the RegEx pattern in Exercise 2 to indicate the beginning and end of the string.\n\nAnswer: ^([0-9]+(?:\\.[0"
            },
            {
                "text": " Generate a RegEx for this description.\n\n```python\nimport re\n\nphoneNum = input(\"Enter a phone number: \")\nif re.match(r'^\\d{3}-\\d{3}-\\d{4}$', phoneNum):\n  print"
            },
            {
                "text": " ^[0-9]+(\\.[0-9]+)$\nThe ^ and $ ensure that the string is only made up of numeric characters. The \\. is a literal dot character. You can include other meta characters like +, *, etc. as you see fit.\n\nA:\n\n"
            },
            {
                "text": " [ ]\n\nExercise 9: \n\nWrite a Regular Expression that will validate the given email address.\nAnswer: \n\n\\w+@\\w+.\\w{2,}\n\nExercise 10: \n\nWrite a Regular Expression that will validate a phone number in the format of"
            },
            {
                "text": "\n[^-\\d.]+\n\nA:\n\nA slightly different expression, which should be able to do the trick. \\d stands for \"digit\", so it should be able to match any number from 0-9.\n^\\d{0,3}\\.\\d{0,3"
            }
        ]
    },
    {
        "expression": "^100$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "raw_prompt": "It matches % value from 0 - 100. The two decimal places are used.",
        "refined_prompt": "It matches % value from 0 - 100. The two decimal places are used.\nMatch examples:\n- \"100\"\n- \"99.99\"\n- \"00\"\nNon-match examples:\n- \"101\"\n- \"22.1111\"",
        "matches": [
            "100",
            "99.99",
            "00",
            "20.99",
            "83",
            "48",
            "88",
            "75",
            "99",
            "94.58",
            "94.51",
            "29.48",
            "95.24"
        ],
        "non_matches": [
            "101",
            "22.1111",
            "432",
            "43.224",
            "53.353",
            "537.242",
            "43.5.242",
            "9233",
            "245/524/12",
            "1-1-2",
            "9/9/9",
            "32542 //"
        ],
        "id": 1209,
        "output": [
            {
                "text": " \n[\\d]{1,2}[\\.\\d]{1,2}\n\nExercise 2.\nGenerate a RegEx to match an email address. \nAnswer: \n[a-zA-Z0-9._%+-]+"
            },
            {
                "text": " \"^[01]|[10]$\"\n\n```python\n# Example\nmatch_example = re.match(r\"^[01]|[10]$\", \"101\")\nprint(match_example)\n\nmatch_example = re.match("
            },
            {
                "text": " \"^(0|[1-9][0-9])$\".\n\n__Exercise 4__:\nGiven a string:\n\"Python3.9.6 is the newest version\"\n\nFind a RegEx to get the version number of the program.\nExample:"
            },
            {
                "text": " ^([0-9]|[1-9][0-9])*.[0-9]$\n\n3. Use the RegEx you created in the previous exercise to match the following strings:\n- \"100\"\n- \"99.99\"\n- \"00\""
            },
            {
                "text": " My RegEx is ^(.+)(\\.[0-9]){1}$\n\nExercise 4:\nCreate a function that takes a string and returns the first word in the string. If the string does not have a space, the function should return the whole string.\n"
            },
            {
                "text": " (\\d{1,2}\\.)(\\d{1,2}|\\d{1,2})\nFor the first match, the \".\" is not necessary.\n\nThe first part is the decimal number that is 1 or 2 digits long. The second part can be a"
            },
            {
                "text": "  \n[0-9]{1}\\.[0-9]{1}\n\nExercise 4:\nUsing the regex \"^[a-zA-Z0-9]+@[a-zA-Z]+\\.(com|edu|org)\", match string"
            },
            {
                "text": " A regular expression that matches an integer between 0 and 100, where the integer is surrounded by a decimal point.\n\nLecture Script: Regular Expressions and Searching\n\nContents:\n1. Introduction to Regular Expressions (regex)\n2. Searching with regex\n"
            },
            {
                "text": "\n\n```python\nimport re\n\npattern = r'^(\\d{1,2}|3[0-4]\\d|25[1-9]|200)$'\n\nmatch = \"100\"\n\nprint(re.search(pattern,"
            },
            {
                "text": " (?<![0-9])[0-9]{1,3}(?=\\.\\d{2})\n\nA:\n\nYou can use the following code:\n/(?<!\\d)(?:\\d{1,3}(?:\\"
            }
        ]
    },
    {
        "expression": "<\\?xml.*</note>",
        "raw_prompt": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.",
        "refined_prompt": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>John</to><from>Jane</from><message>Hello, world!</message></note>\"\n- \"<?xml version=\"1.0\" ?><note><to>Alice</to><from>Bob</from><message>Hi there!</message></note>\"\nNon-match examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>\"\n- \"<\\?xml52/2/54/245\"",
        "matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>",
            "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>John</to><from>Jane</from><message>Hello, world!</message></note>",
            "<?xml version=\"1.0\" ?><note><to>Alice</to><from>Bob</from><message>Hi there!</message></note>",
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><note><to>Mary</to><from>David</from><message>How are you?</message></note>",
            "<?xml version=\"1.1\" ?><note><to>Chris</to><from>Lisa</from><message>Goodbye!</message></note>",
            "<?xml version=\"1.0\" ?><note><to>Tom</to><from>Linda</from><message>Take care!</message></note>",
            "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>Michael</to><from>Emily</from><message>Have a great day!</message></note>",
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><note><to>Lucas</to><from>Sophia</from><message>Enjoy your weekend!</message></note>",
            "<?xml version=\"1.1\" ?><note><to>Daniel</to><from>Olivia</from><message>Stay safe!</message></note>",
            "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><note><to>Nathan</to><from>Grace</from><message>Best wishes!</message></note>",
            "<?xml version=\"1.0\" ?><note><to>Ethan</to><from>Hannah</from><message>Keep in touch!</message></note>",
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?><note><to>Noah</to><from>Emma</from><message>Thinking of you!</message></note>",
            "<?xml version=\"1.1\" ?><note><to>Liam</to><from>Olivia</from><message>Take it easy!</message></note>"
        ],
        "non_matches": [
            "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>",
            "<\\?xml52/2/54/245",
            "<\\?xml2534/52435234/2453",
            "<\\?xmlafdsaf.adijs",
            "<\\?xml234/423/5243",
            "<\\?xml$23.454",
            "<\\?xml43-5432",
            "<\\?xml254627g.256",
            "<\\?xml245/524/12",
            "<\\?xmlcom.edu.github",
            "<\\?xml(0xx12) 62509@",
            "<\\?xml3409fjg43"
        ],
        "id": 1212,
        "output": [
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            },
            {
                "text": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document.\nMatch examples:\n- \"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>\"\n- \"<?xml version=\"1.0\" encoding=\""
            }
        ]
    },
    {
        "expression": "^(([1-4][0-9])|(0[1-9])|(5[0-2]))\\/[1-2]\\d{3}$",
        "raw_prompt": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.",
        "refined_prompt": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY.\nMatch examples:\n- \"47/2006\"\n- \"01/1840\"\n- \"36/2763\"\nNon-match examples:\n- \"00/3005\"\n- \"52/2/54/245\"",
        "matches": [
            "47/2006",
            "01/1840",
            "36/2763",
            "27/2706",
            "03/1538",
            "52/1975",
            "08/1506",
            "52/2304",
            "01/2252",
            "06/2884",
            "52/1788",
            "06/2406",
            "06/2658"
        ],
        "non_matches": [
            "00/3005",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1213,
        "output": [
            {
                "text": "\n^(0|[1-9]|[1-9][0-9]|"
            },
            {
                "text": "\n[[0-9]{4}[0-9]{2}[0-9"
            },
            {
                "text": "\n(\\d{1,2})(\\/)(\\d{4})(\\/)(\\d"
            },
            {
                "text": "\n[0-9]{1,2}//[0-9]{4}\n"
            },
            {
                "text": " \n\n```python\npattern = r'^(\\d{4})/(\\d{"
            },
            {
                "text": " W|0-9|[1-9]|[1-2][0-9]"
            },
            {
                "text": " ^[0-9]{2}\\/[2-9]\\d{2}$"
            },
            {
                "text": " \\d{2}[0-9]\\d[0-9]\\d/\\"
            },
            {
                "text": " ^[0-9]{4}[0-9]/[0-9]{"
            },
            {
                "text": " \\d{4}/\\d{3}/\\d{4}\n\n1."
            }
        ]
    },
    {
        "expression": "^(\\d{4})\\D?(0[1-9]|1[0-2])\\D?([12]\\d|0[1-9]|3[01])(\\D?([01]\\d|2[0-3])\\D?([0-5]\\d)\\D?([0-5]\\d)?)?$",
        "raw_prompt": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.",
        "refined_prompt": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/54/245\"",
        "matches": [
            "2006-12-31 17:58:00",
            "20061231175800",
            "2006-12-31",
            "2021-09-06",
            "1990/12/31",
            "1990/12/31 23:59",
            "1990/12/31 23:59:59",
            "2022.03.15",
            "2035-01-01",
            "2032.03.16",
            "2042.03.17",
            "2052.03.18",
            "2064.03.19"
        ],
        "non_matches": [
            "2006-13-36 25:61:62",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "2021-13-06",
            "2021/00/00T12:30:45",
            "2021-09-06T25:30",
            "2021-09-06T12:60:45"
        ],
        "id": 1221,
        "output": [
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            },
            {
                "text": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric). Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month.\nMatch examples:\n- \"2006-12-31 17:58:00\"\n- \"20061231175800\"\n- \"2006-12-31\"\nNon-match examples:\n- \"2006-13-36 25:61:62\"\n- \"52/2/"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-2]) ([0-1][0-9]|2[0-4]):([0-4][0-9]|5[0-9]):([0-4][0-9]|5[0-9])$",
        "raw_prompt": "it will match a valid date & time string which looks like this : 2006-12-31 23:59:59",
        "refined_prompt": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31 4:59:65\"\n- \"06-12-2006 23:59:59\"",
        "matches": [
            "2006-12-31 23:59:59",
            "2023-09-06 08:30:00",
            "1990-05-15 18:45:22",
            "1975-02-28 14:30:05",
            "2035-01-01 00:00:00",
            "2010-11-20 12:15:30",
            "1988-07-04 03:45:55",
            "1988-07-04 03:45:55",
            "2022-03-15 21:05:45",
            "1999-08-25 05:20:59",
            "1970-01-01 00:00:01",
            "1965-03-12 11:11:11",
            "2022-12-25 00:00:00"
        ],
        "non_matches": [
            "2006-13-31 4:59:65",
            "06-12-2006 23:59:59",
            "2023-09-06 8:30:004",
            "1990/05/1543 18:45:22",
            "75-02-28 14:30:056",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "32542 //"
        ],
        "id": 1224,
        "output": [
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-31"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-03"
            },
            {
                "text": "Matches valid date and time strings in the format \"YYYY-MM-DD HH:MM:SS,\" where \"YYYY\" represents the year, \"MM\" represents the month, \"DD\" represents the day, \"HH\" represents the hour, \"MM\" represents the minutes, and \"SS\" represents the seconds.\nMatch examples:\n- \"2006-12-31 23:59:59\"\n- \"2023-09-06 08:30:00\"\n- \"1990-05-15 18:45:22\"\nNon-match examples:\n- \"2006-13-11"
            }
        ]
    },
    {
        "expression": "^\\d+(\\.\\d+)?$",
        "raw_prompt": "Matches any unsigned floating point number/numeric string.",
        "refined_prompt": "Matches any unsigned floating point number/numeric string.\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \"45768\"\nNon-match examples:\n- \"abc\"\n- \"-3.14159\"",
        "matches": [
            "123",
            "3.14159",
            "45768",
            "6577",
            "65",
            "76",
            "5765",
            "787",
            "87",
            "68.534",
            "634.25324",
            "524.625",
            "5242.62"
        ],
        "non_matches": [
            "abc",
            "-3.14159",
            "3.4.2",
            ".234",
            ".",
            "f32rf32.",
            "34.ef",
            "34f.",
            "f34r",
            "t45wge.5t",
            ".f3",
            "t43t.543"
        ],
        "id": 1230,
        "output": [
            {
                "text": " /^[a-zA-Z]*-?[0-9]+(?:\\.[0-9]+)?$/\n\nA:\n\nThe following code may be helpful.  \n$text = \"hello world and 9.99 and a list of words and numbers"
            },
            {
                "text": " ^[0-9]\\d*\\.?[0-9]+$\n\nNote:.? matches any number of characters between zero and one\n^[0-9]\\d*\\.?[0-9]+$ will match the format:\n^[0-9"
            },
            {
                "text": " \\d+\\.\\d+ or \\d+\n\n5. Create a RegEx for a date formatted like \"yyyy-mm-dd\".  \nAnswer: \\d{4}-\\d{2}-\\d{2}\n\nI hope this section has been"
            },
            {
                "text": ".*([a-zA-Z0-9]+[._][a-zA-Z0-9]*[.])*[a-zA-Z0-9]+\n- Regex:.*([0-9]+[.,]*[0-9]+"
            },
            {
                "text": "\n^[0-9]*\\.[0-9]+$\nExample 1:\n(12345.67890-12345.67890)/(12345.67890+12345.67890)\n\nExercise 2:\nMatch any floating point number that has no"
            },
            {
                "text": " ^[0-9]*\\.[0-9]+$\n- \"1.23456\"Generate a RegEx for this description. \nAnswer: ^[0-9]\\.[0-9]*$\n- \"a1b2c3\"Generate"
            },
            {
                "text": " \n#^\\d+(\\.\\d*)?$\n\nExercise 2: Write a Python program that replaces all occurrences of the RegEx from Exercise 1 in the following string:\ntext = \"The price of the item is $3.14159.\"\n\nAnswer:\nimport"
            },
            {
                "text": " ^[a-zA-Z\\d\\s]+(\\.\\d+)?$\n\nA:\n\n^[-\\d.]*$\n\nTry this.This will ensure it is an alphanumeric character and only a dot.\nSee demo.\nhttps://"
            },
            {
                "text": "\n(?=^[1-9][0-9]*$)(?!.*\\.0$)\n- (?:[1-9]|0)?[0-9]*(?:\\.[0-9]{3})?)\n\n[https://regex101"
            },
            {
                "text": " \\d\\.\\d*\n\nMy question is, how do I do this? I would like to do this without using a full blown regular expression library.\n\nA:\n\nYou can use this simple regex...\n^[0-9]+\\.[0-9]*$"
            }
        ]
    },
    {
        "expression": "[A-Z0-9]{5}\\d[0156]\\d([0][1-9]|[12]\\d|3[01])\\d[A-Z0-9]{3}[A-Z]{2}",
        "raw_prompt": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.",
        "refined_prompt": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n- \"9E8LU167058OOCLI\"\nNon-match examples:\n- \"JOHNS731215GG9SY\"\n- \"8FG78G78EWDG78G\"",
        "matches": [
            "JOHNS711215GG9SY",
            "EC6JU003207KEREJ",
            "9E8LU167058OOCLI",
            "UYELA1560477TDDE",
            "4IHZM06630354MLC",
            "YUV72854294N7IGV",
            "NACPE963301JLEHT",
            "2ID25819128RZ9QH",
            "H2H02507059MZWYA",
            "3Z0NJ666112IZHBS",
            "7ZJWQ213055QSAAY",
            "WYFF1706311S1HVC",
            "0MMEP8650334IFSQ"
        ],
        "non_matches": [
            "JOHNS731215GG9SY",
            "8FG78G78EWDG78G",
            "G78G87F2GEB8YG8YG",
            "F676J7UHY6GT5R",
            "7FG68YFG87",
            "G78GWREG4GG",
            "G87Y4R44GF",
            "G78YG4FGTTFD3E",
            "F87G7UG787",
            "GU456Y7UHY6GT5F",
            "45T6GY78UG7U8",
            "GV9UG9UGD98U3GF9"
        ],
        "id": 1239,
        "output": [
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            },
            {
                "text": "Matches the UK Drivers License format as laid down by the DVLA / dvla. Matches: 1. Must be 16 characters 2. First 5 characters are alphanumeric. 3. Next 6 characters must be numeric 4. Next 3 characters are alphanumeric 5. Last 2 characters are alpha 6. Second character of numeric section can only be 0, 1, 5 or 6. 7. Fourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"JOHNS711215GG9SY\"\n- \"EC6JU003207KEREJ\"\n"
            }
        ]
    },
    {
        "expression": "^(3276[0-7]|327[0-5]\\d|32[0-6]\\d{2}|3[01]\\d{3}|[12]\\d{4}|[1-9]\\d{3}|[1-9]\\d{2}|[1-9]\\d|\\d)$",
        "raw_prompt": "Checks that the input is a positive integer in the range 0-32767",
        "refined_prompt": "Checks that the input is a positive integer in the range 0-32767\nMatch examples:\n- \"32767\"\n- \"0\"\n- \"999\"\nNon-match examples:\n- \"99999\"\n- \"-1\"",
        "matches": [
            "32767",
            "0",
            "999",
            "5634",
            "8794",
            "857",
            "3586",
            "649",
            "6484",
            "5368",
            "3567",
            "63",
            "753"
        ],
        "non_matches": [
            "99999",
            "-1",
            "abc",
            "57CUR57",
            "RC5",
            "7RFC",
            "76RFC",
            "76F67",
            "8708968957",
            "F67FGY7",
            "575957",
            "F6Y78YF"
        ],
        "id": 1242,
        "output": [
            {
                "text": " 0(?:\\d\\d)*/2(?:\\d\\d)\n- \"0123456789\"\n- \"1a2b3c4d5e6f7g8h9i0\"\n- \"100000\"\n- \"01110110"
            },
            {
                "text": " ^[[:digit:]]+$\n\nExercise 5:\nWrite a Python program to validate that a user enters a positive integer in hexadecimal format.\n\nimport re\nuser_input = input(\"Enter a hexadecimal number: \")\nif re.match("
            },
            {
                "text": "^[0-9]{4}(?:-[0-9]{3})?(?:-[0-9]{2})?$\n\nExercise 2:\nWrite a RegEx for this description:\n\"The number is exactly 3 characters long and contains only digits"
            },
            {
                "text": " (?i)([1-9][0-9]|1?[0-9]2?)\n\nExercise 2:\nWrite a RegEx that matches any word starting with the letter \"a\"\nAnswer: (?i)(?=^[a-z]+)\n"
            },
            {
                "text": " [0-9][0-9][0-9][a-zA-Z][0-9][a-zA-Z]\\{1,\\}\\.\"\n- \"0\"Generate a RegEx for this description. \nAnswer: 0\\.\n\nExercise"
            },
            {
                "text": " /^[1-9][0-9]\\d{0,2}$|^[1-9](0|[1-9][0-9]){3}$/\n\n3. Use the following RegEx to find all occurences of the word \"Python"
            },
            {
                "text": " \"^[0-9]{1,3}([,.][0-9]{3})*$\"\n2. Write a Python program that checks whether a given string is a valid URL. A valid URL is one that starts with either \u201chttp\u201d or \u201chttps\ufffd"
            },
            {
                "text": "\n[0-9]\\d{0,3}(?:\\.\\d+)?\n\n# 3.4.7 How to use regular expressions for data validation and sanitization\n\nRegular expressions can be used for data validation and sanitization to ensure that the input is"
            },
            {
                "text": " 0\\d{3}[-\\d]+\n\nExercise 2: Using the RegEx generated in Exercise 1, write a Python program that prints the first 10 matches.\nAnswer: `import re\npattern = r'0\\d{3}[-\\d]+'\nfor"
            },
            {
                "text": "\nimport re\ndef test_digits(val):\n    if type(val)!= str:\n        return True\n    if val == \"0\" or val == \"-1\":\n        return True\n    if val < 0 or val > 32767:\n        return False\n    "
            }
        ]
    },
    {
        "expression": "^\\+[0-9]{1,3}\\([0-9]{3}\\)[0-9]{7}$",
        "raw_prompt": "The OAGIS standard has a format for phone and fax as +###(###)#######. For details on standard see the open applications group.",
        "refined_prompt": "The OAGIS standard has a format for phone and fax as +###(###)#######.\nMatch examples:\n- \"+555(555)5555555\"\n- \"+1(800)5555555\"\n- \"+617(355)2470357\"\nNon-match examples:\n- \"555\"\n- \"52/2/54/245\"",
        "matches": [
            "+555(555)5555555",
            "+1(800)5555555",
            "+617(355)2470357",
            "+79(062)2153857",
            "+8(991)8919924",
            "+82(829)1931583",
            "+34(076)9311372",
            "+934(400)6629643",
            "+2(394)6904808",
            "+1(011)0575956",
            "+664(492)9126216",
            "+842(730)3047647",
            "+301(861)8867823"
        ],
        "non_matches": [
            "555",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "0j0jweBBBB"
        ],
        "id": 1244,
        "output": [
            {
                "text": " Match any number in the range of 555-255-0000 to 555-255-0000\n\nExercise 2:\nCreate a RegEx expression to match the string \""
            },
            {
                "text": " [0-9]{3}\\/[0-9]{2}\\/[0-9]{4}/[0-9]{3}"
            },
            {
                "text": " \\d\\d\\d\\-\\d\\d\\-\\d\\d\\d\\d\\-\\d\\d\\-\\d\\d\\d\\d\\"
            },
            {
                "text": " +[0-9]{2}[-][0-9]{3}[-][0-9]{5}[0-9]{"
            },
            {
                "text": " +[0-9]{3}[-/][0-9]{3}[-/][0-9]{3}[-/]["
            },
            {
                "text": "\n```\n[+]\\d{3}\\([|]\\d{3}\\)\\d{3}[|]\\d{4}\n``"
            },
            {
                "text": " \\+\\d{3}\\(?\\d{3}\\)?(?:\\s|$)(\\d{3})(?:\\s|$)\n"
            },
            {
                "text": " \\+(\\d{3}\\)\\d{3}-\\d{4}\n\n[Host 1]: That's amazing! You've got a solid understanding of"
            },
            {
                "text": " +([1-9][0-9]|1[0-2])\\d{3}[-.]\\d{3}[-.]\\d"
            },
            {
                "text": " +([0-9]{3})[-0-9]{3}[0-9]{3}\nExercise 3:\nWhat is the"
            }
        ]
    },
    {
        "expression": "([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}",
        "raw_prompt": "Matches all IPV6 and IPV4 addresses. Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression.",
        "refined_prompt": "Matches all IPV6 and IPV4 addresses. Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression.\nMatch examples:\n- \"0:123:af00:ffff:0C67:0:0:8787\"\n- \"0:0:0:0:0:0:0:1\"\n- \"0.0.0.1\"\nNon-match examples:\n- \"::1\"\n- \"52/2/54/245\"",
        "matches": [
            "0:123:af00:ffff:0C67:0:0:8787",
            "0:0:0:0:0:0:0:1",
            "0.0.0.1",
            "999.999.999.999",
            "E8:D:27E:e:1CDE:4256:0BE:a4",
            "4.764.7.7",
            "5.39.1.6",
            "68:7D:AcDB:4E8B:b32:e:3ba:3d",
            "e3B6:cdA8:62Cc:BA:DF4a:8bD2:71:25",
            "413.14.471.7",
            "681:e:2f:F0a7:f613:aF:E4:5D8E",
            "519.24.1.6",
            "931.958.74.1"
        ],
        "non_matches": [
            "::1",
            "52/2/54/245",
            "-243",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1246,
        "output": [
            {
                "text": "\n^("
            },
            {
                "text": " (?:["
            },
            {
                "text": " \\\\[0"
            },
            {
                "text": " \\.{"
            },
            {
                "text": " ^(0"
            },
            {
                "text": " (^|"
            },
            {
                "text": "^[0"
            },
            {
                "text": " ^(?:"
            },
            {
                "text": " 1%6"
            },
            {
                "text": " ips=\""
            }
        ]
    },
    {
        "expression": "^(H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}\\d{4}(NE|NW|SE|SW)?$|((H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}(\\d{4}|\\d{6}|\\d{8}|\\d{10}))$",
        "raw_prompt": "This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number. Information on the range of possible values can be found here: http://www.ordnancesurvey.co.uk/oswebsite/gps/information/coordinatesystemsinfo/guidetonationalgrid/page17.html. Grid Ref, Tile Ref, Sheet Ref.",
        "refined_prompt": "This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number.\nMatch examples:\n- \"NA1234SE\"\n- \"OV5571\"\n- \"SG2714926378\"\nNon-match examples:\n- \"AA1234SE\"\n- \"YI67fyvG\"",
        "matches": [
            "NA1234SE",
            "OV5571",
            "SG2714926378",
            "TG6547SW",
            "OV1556SW",
            "OV4533",
            "HU0548SE",
            "TG551952",
            "SO4698NW",
            "NS3672",
            "SE6571NW",
            "NF2271229107",
            "NB3552"
        ],
        "non_matches": [
            "AA1234SE",
            "YI67fyvG",
            "Y8G8YG",
            "GY8G78G6G",
            "F67FG8YG9",
            "876FFG78G",
            "9UG",
            "87G8",
            "G8",
            "7G87",
            "G8Y",
            "V8IUG7B"
        ],
        "id": 1251,
        "output": [
            {
                "text": " [^A-Za-z0-9]+\n\nExercise 3:\nYou're working with a dataset that contains a series of phone numbers. Some of the phone numbers contain dashes or spaces, and"
            },
            {
                "text": " \n\n- (?<!\\d)\\d{1,4}(-?!\\d){3,4}\\d{4}(?!\\d)\n- (?<!\\d)\\d"
            },
            {
                "text": " [^0-9A-Za-z]\n- \"BUK19\"\n- \"BUK19.1\"\n- \"NZ28\"\n- \"NZ28.1\"\n- \""
            },
            {
                "text": " [^AB23]{3}S\\d{4}[A-Z]\\d{2}[0-9]{1}$\nThe pattern to match is \"3S\\d{"
            },
            {
                "text": "\n(?<=\\d{1,2},)(?=\\d{6})\n\nExercise 3:\nGiven the following text, write a regular expression that validates the following:\n- \""
            },
            {
                "text": " (\\d+)[A-Z]+, (\\d+)[A-Z]+, (\\d+), [A-Z]+, (\\d+), (\\d+)\n\nExercise 3"
            },
            {
                "text": " ^[0-9]{4}[0-9]{1}[0-9]{3}$\n\n5. Exercise: Provide an example of a non-pattern in the same format as"
            },
            {
                "text": "\n[A-Z][0-9]{5}[0-9]{2}[0-9]{4}[A-Z][0-9]{5}[0-9"
            },
            {
                "text": " \".*(.*?)(?=\\d*$).\"\n\n2. Convert the following text to uppercase and replace all digits with \"X\" characters.\n\"The price is $345.78 and"
            },
            {
                "text": " (\\\\d+)\\\\D+\\\\d+\n\nExercise 3: Create a RegEx expression to validate the following text: \"Please provide a valid password with at least one uppercase and one number.\" Use"
            }
        ]
    },
    {
        "expression": "<title>+(.*?)</title>",
        "raw_prompt": "This pattern could intercept the value of the tag title in every web pages, it could be found in $1.",
        "refined_prompt": "match strings that contain a specific text pattern typically found in HTML documents where <title> tags enclose some content.\nMatch examples:\n- \"<title>this title</title>\"\n- \"<title>fadsf2fe</title>\"\n- \"<title>2dffd</title>\"\nNon-match examples:\n- \"any other tags\"\n- \"title\"",
        "matches": [
            "<title>this title</title>",
            "<title>fadsf2fe</title>",
            "<title>2dffd</title>",
            "<title>d2fdd</title>",
            "<title>f2df2d</title>",
            "<title>df2fs2</title>",
            "<title>dffd22fd</title>",
            "<title>d2ff2f</title>",
            "<title>fd2f2ffd</title>",
            "<title>df2f</title>",
            "<title>fd222re</title>",
            "<title>er2r2</title>",
            "<title>t23t22 23rr</title>"
        ],
        "non_matches": [
            "any other tags",
            "title",
            "Title",
            "missing closing",
            "titalfe",
            "231 teas",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1254,
        "output": [
            {
                "text": " The regular expression for matching the word \"title\" between the tags can be [^<title>]*<title>([^<]*)</title>.*["
            },
            {
                "text": " (.*<title>.*)</title>.*\n\n2. Match string containing both an IP address and a port number. \nMatch examples:\n- \"[123"
            },
            {
                "text": " [^<title>]+\n\nExercise 3:\nWrite a RegEx for a date format like 'YYYY-MM-DD'.\nAnswer: \\d"
            },
            {
                "text": " \\<title>(.*?)\\</title>\n\n# 13.2.3 How to Use Anchors and Lookaheads for Searching\n\nAnch"
            },
            {
                "text": "\n```python\nimport re\n\npattern = \"^<title>(.*)</title>$\"\n\n#test cases\ncase1 = \"<title>this"
            },
            {
                "text": "\n\n#Python Code - RegEx for Titles\nimport re \n\npattern = r'title\\s*=\\s*\"([^\"]+)\""
            },
            {
                "text": " This is an exercise designed for students to generate a RegEx pattern that will match a generic title.\n\n### Exercise 3\n```python\n# Exercise 3\nimport"
            },
            {
                "text": " The required string is \"any other tags\"\n\n2. Convert the RegEx string that matches non-matching strings into their equivalent text values, using the following:"
            },
            {
                "text": " \n\nimport re\ntext = \"any other tags\"\nregex = \"<title>([\\w]+?)</title>\"\nmatch = re.search("
            },
            {
                "text": " (\\btitle\\b.*?)<\\/title>\\b\n\nExercise 3: \nExplain the difference between \".*?\" and \"\\s\" in"
            }
        ]
    },
    {
        "expression": "<h([1-6])>([^<]*)</h([1-6])>",
        "raw_prompt": "This regex find valid <h1-6> html tags",
        "refined_prompt": "This regex find valid <h1-6> html tags\nMatch examples:\n- \"<h2>test2</h2><h3>test3</h3>\"\n- \"<h1>Heading 1</h1>\"\n- \"<h2>Subheading</h2>\"\nNon-match examples:\n- \"<h>test1</h>\"\n- \"<h7>Invalid Heading</h7>\"",
        "matches": [
            "<h2>test2</h2><h3>test3</h3>",
            "<h1>Heading 1</h1>",
            "<h2>Subheading</h2>",
            "<h3>Another Example</h3>",
            "<h4>Fourth Level</h4>",
            "<h5>Fifth Level Heading</h5>",
            "<h6>Lowest Level</h6>",
            "<h1> Leading and Trailing Spaces </h1>",
            "<h2></h2>",
            "<h3>&lt;Special Characters&gt;</h3>",
            "<h4> Indented Content </h4>",
            "<h5>Special &amp; Characters</h5>",
            "<h6>12345</h6>"
        ],
        "non_matches": [
            "<h>test1</h>",
            "<h7>Invalid Heading</h7>",
            "<h0>Invalid Heading</h0>",
            "<h0>Zero Level</h0>",
            "<h7>Out of Range</h7>",
            "<H1>Uppercase Tag</H1>",
            "<H2>Uppercase Tag</H2>",
            "<p>Paragraph</p>",
            "<div>Division</div>",
            "<h2>Missing Closing Tag",
            "Text without Tags",
            "<h3>No Closing Tag"
        ],
        "id": 1257,
        "output": [
            {
                "text": " - /<h[1-6]>(.*?)</h[1-6]>/g\n\n"
            },
            {
                "text": " [^a-zA-Z0-9\\s]+\n\n### Exercise 2\nUse the code below"
            },
            {
                "text": " [<h-7>]([^>]+)\n\nExercise 2: \nDetermine the amount"
            },
            {
                "text": "\n\nh1-6\n\"<h1-6>\" or \"<h1\" or \"<h1"
            },
            {
                "text": " (\\s*<h(\\d+)([^>]*)?>\\s*|<h(\\d"
            },
            {
                "text": " [a-zA-Z]*[a-zA-Z0-9]*[a-"
            },
            {
                "text": " <h[1-6]>(\\s|>)+\"\n\nCode Example:\nimport re\ntext"
            },
            {
                "text": " <h\\d+>\n- <h1>Invalid Heading</h1>\"Generate a RegEx"
            },
            {
                "text": " <h\\d>\\[([^\\]]+)[^<>]*\\]\\s*</\\"
            },
            {
                "text": " <h>[a-z]+</h>\n- \"<h3>Not a Heading</h3>\""
            }
        ]
    },
    {
        "expression": "\\b[1-9]{1}[0-9]{1,5}-\\d{2}-\\d\\b",
        "raw_prompt": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).",
        "refined_prompt": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number).\nMatch examples:\n- \"50-00-0\"\n- \"75-18-5\"\n- \"41-40-4\"\nNon-match examples:\n- \"200-001-8\"\n- \"52/2/54/245\"",
        "matches": [
            "50-00-0",
            "75-18-5",
            "41-40-4",
            "96-09-4",
            "5448-08-2",
            "828-90-0",
            "13-70-0",
            "95-27-1",
            "249-34-2",
            "149-06-4",
            "133-13-1",
            "180834-05-5",
            "791712-08-1"
        ],
        "non_matches": [
            "200-001-8",
            "52/2/54/245",
            "-243",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1260,
        "output": [
            {
                "text": " (\\d{4})-(\\d{3})-(\\d{2})$ \n\nExercise 2"
            },
            {
                "text": " ^(\\d{3}-[0-9]{2}-[0-9]{2})/[0"
            },
            {
                "text": " The last two characters of the CAS number (4 to 9) can be matched by the \\d operator.\n\n2"
            },
            {
                "text": " \\d{2}[-/]\\d{4}[-/]\\d{3}\n\n"
            },
            {
                "text": " \n[0-9]{0,5}-[0-9]{0,5}-[0-"
            },
            {
                "text": " (4 digits) [0-9][0-9][0-9]-([0-9]{3}"
            },
            {
                "text": " [a-z]{1}(?:\\d{3})?-?\\d{3}-?"
            },
            {
                "text": " \n- \"([0-9a-zA-Z]{3}-){2}[0-"
            },
            {
                "text": " [0-9]{3}-[0-9]{3}-[0-9]{4}\n"
            },
            {
                "text": " The regex is \"[0-9]{3}-[0-9]{2}-[0-9]{"
            }
        ]
    },
    {
        "expression": "^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "raw_prompt": "Requires area code. Allows extension. Any common US format works. If you prefer not to require area code, use this: ^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})?[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "refined_prompt": "Requires area code. Allows extension. Any common US format works.\nMatch examples:\n- \"1 (123) 123-1234 ext. 1234567\"\n- \"1 (123) 123-1234\"\n- \"(123) 123-1234\"\nNon-match examples:\n- \"123/1234 L. 12345678\"\n- \"52/2/54/245\"",
        "matches": [
            "1 (123) 123-1234 ext. 1234567",
            "1 (123) 123-1234",
            "(123) 123-1234",
            "(123)123.1234",
            "1-123-123-1234",
            "1231231234",
            "1 (123) 123-7482",
            "1 (123) 384-1234",
            "1 (592) 123-1234",
            "(123) 123-4028",
            "(123) 482-1234",
            "(471) 123-1234",
            "(123) 472-5819"
        ],
        "non_matches": [
            "123/1234 L. 12345678",
            "52/2/54/245",
            "-243",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "/5/5/5",
            "254627g.256",
            "245/524/12",
            "1-1-2",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1267,
        "output": [
            {
                "text": " \\(?(\\d{1})\\s?(\\d{3})\\s?-?(\\d{4})\\)\n"
            },
            {
                "text": " \n(?<![A-Z])(?<!\\d)(?<![\\d\\-])(?<"
            },
            {
                "text": " \\/[A-Za-z]{2,}\\/\n\nExercise 4: Write a Python program that takes a string"
            },
            {
                "text": " (\\d/\\d|\\d\\d)/(\\d\\d|\\d\\d)\n\nHere is a sample Python"
            },
            {
                "text": " /\\(\\d{1,3}\\)\\s*([-\\s\\d]{1,2})/g\n\n3"
            },
            {
                "text": " The correct regex is \"/(\\\\d{1,2}\\\\.)\\\\d{3}\\\\/[A-Z]\\\\d"
            },
            {
                "text": " \n(\\\\d{1,3}\\\\s)\\\\s(\\\\w{1,2})\\\\s(\\\\w{"
            },
            {
                "text": " (^[0-9]{3}[.])([0-9]{3}[-]?[0-9"
            },
            {
                "text": " \"^[1-9]\\d{3}(-\\d{3})?[1-9]\\d{3}"
            },
            {
                "text": " [0-9]{1,3}\\s[a-zA-Z][a-zA-Z0-9\\-"
            }
        ]
    },
    {
        "expression": ".*(\\.[Jj][Pp][Gg]|\\.[Gg][Ii][Ff]|\\.[Jj][Pp][Ee][Gg]|\\.[Pp][Nn][Gg])",
        "raw_prompt": "This expression should work to validate that an uploaded file's extension is either jpg, gif, or png.",
        "refined_prompt": "This expression should work to validate that an uploaded file's extension is either jpg, gif, or png.\nMatch examples:\n- \"foo.gif\"\n- \"foo.jpg\"\n- \"foo.png\"\nNon-match examples:\n- \"foo.txt\"\n- \"foo.zip\"",
        "matches": [
            "foo.gif",
            "foo.jpg",
            "foo.png",
            "afd.gif",
            "afsd.gif",
            "efw.gif",
            "dfw.gif",
            "egw.jpg",
            "wfoo.jpg",
            "dgwg.jpg",
            "werfoo.png",
            "trv.png",
            "vcs.png"
        ],
        "non_matches": [
            "foo.txt",
            "foo.zip",
            "foo.exe",
            "afdsaf.adijs",
            "9ijn",
            "3nf@",
            "jpg",
            "pdf",
            "zip",
            "png",
            "exe",
            "gif"
        ],
        "id": 1268,
        "output": [
            {
                "text": " \nimport re\ndef validate_extension(file_name):\n   pattern = r\"\\.(jpg|jpeg|png)\"\n   if re.match(pattern, file_name):\n       return True"
            },
            {
                "text": " \"^[0-9a-zA-Z_-]+|[0-9a-zA-Z_-]+\\.(jpg|gif|png)$\"\nExercise 3:\nCreate a"
            },
            {
                "text": " my_file_gen.py|\nimport glob\nimport os\n\ndef gen_file_gen():\n    for filename in glob.glob(\"*.\"):\n        if filename.endswith(\".png"
            },
            {
                "text": "\n^(?=.*.gif|.*.png|.*.jpg)([a-zA-Z0-9]*\\.(jpg|gif|png))$\n\nExercise 2:\nCreate a"
            },
            {
                "text": "\n\nimport re\n\n# the file extension regex\nextention_regex = re.compile(r'[\\w.]+\\.([\\w.]+)$')\n\n# a sample text file to"
            },
            {
                "text": "\n/^(.+?\\.(jp|gif|png))$/\n\nExercise 4:\nWrite a Python script that takes a list of strings and returns only strings that start with the word \"Python\". Use"
            },
            {
                "text": " \n[^\\.]+\\.gif|[^\\.]+\\.jpg|[^\\.]+\\.png\n\nExercise 2:\n- Regex to match email addresses\n- Match examples: \n-"
            },
            {
                "text": "\n\n```python\nfile_extension = input(\"Enter the file extension: \")\n\nif file_extension.lower().endswith(('.gif', '.jpg', '.png')):\n    print"
            },
            {
                "text": "\nimport re\n\ndef validate_image_extension(image_path):\n    pattern = re.compile(r'([a-zA-Z0-9]+)(\\.jpg|\\.gif|\\."
            },
            {
                "text": " (?i)([a-zA-Z0-9_\\-\\.]+\\.(jpg|gif|png))\n\nExercise 2:\nCreate a function that takes a filename and checks if it matches the"
            }
        ]
    },
    {
        "expression": "^[-+]?(\\d?\\d?\\d?,?)?(\\d{3}\\,?)*$",
        "raw_prompt": "This pattern matches on Integer values. Handles leading positive or negative signs. Supports commas where only the leading group can have less than three digits.",
        "refined_prompt": "This pattern matches on Integer values. Handles leading positive or negative signs. Supports commas where only the leading group can have less than three digits.\nMatch examples:\n- \"+1\"\n- \"-2\"\n- \"3,000\"\nNon-match examples:\n- \"A\"\n- \"1,23\"",
        "matches": [
            "+1",
            "-2",
            "3,000",
            "1,234,567",
            "867",
            "864",
            "34",
            "534",
            "754",
            "34867",
            "4643",
            "3536",
            "3576"
        ],
        "non_matches": [
            "A",
            "1,23",
            "2,34,567",
            "1.0",
            "D#@45d",
            "45dr45dD$",
            "$%D%RD45sd",
            "$%D453d",
            "4%D5d4",
            "fgv",
            "bibuif5",
            "d55fd"
        ],
        "id": 1278,
        "output": [
            {
                "text": " (?<![0-9]+)(?<![-,.])(?!-?[0-9])\\d{3}\n\n2. Write a Python program to create a regex that matches:\n"
            },
            {
                "text": " 1.^[-\\d,]+$|2.^[0-9]+$\n\n(1) I'm having trouble understanding how to parse my input string and to extract the integers only, I know the"
            },
            {
                "text": "\nNon-match examples:\n- \"A\"\n- \"1,23\"\n\nA:\n\n\\d{1,2}-?\\d{2,3}\n\nThis pattern matches on"
            },
            {
                "text": "\n(?<=^|\\+|-)[0-9]{,3}(?=,|$)\n\nA:\n\nI would use positive lookahead (?=...) and negative look"
            },
            {
                "text": " (A1)[0-9]\n\n# Generate a RegEx that matches three consecutive uppercase letters in a row\n\nExercise: Write a Python function that takes a string as input and returns a list"
            },
            {
                "text": " [0-9]{3,}\n\n(I am not sure on the details about the question... you should make sure you're not using the wrong regex pattern and that you're getting the right amount of digits in"
            },
            {
                "text": " (\\d+)(,\\d{1,2})?$\n5. Generate a RegEx that matches a string that has both numbers and letters.\nAnswer: [A-Za-z0-"
            },
            {
                "text": " \\d+\n\nExercise 5:\nMatch the following numbers using parentheses: \n1. (2,5,7)\n2. (10)\n3. (1.5,2.5)"
            },
            {
                "text": " /[+-]?([1-9][0-,]*)\\d{3,}(,\\d{3})*$/\n\n- \"A9\"Generate a RegEx for this description"
            },
            {
                "text": " \"^[+-]?[0-9]{1,3}(,[0-9]{3})*$\"\n\n1. \"2A, 3A\"\n2. \"1A"
            }
        ]
    },
    {
        "expression": "^([0-1](?:\\.\\d)|[0-1](?:\\,\\d)|(2\\.0)|(2\\,0))$",
        "raw_prompt": "Had to handle both \",\" and \".\" as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00f6gskoleprov (SAT).",
        "refined_prompt": "Had to handle both \",\" and \".\" as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00f6gskoleprov (SAT).\nMatch examples:\n- \"0,0\"\n- \"0.0\"\n- \"1,9\"\nNon-match examples:\n- \"2,1\"\n- \"1\"",
        "matches": [
            "0,0",
            "0.0",
            "1,9",
            "2.0",
            "1.2",
            "1.3",
            "1.4",
            "1.5",
            "1.6",
            "1.7",
            "1.8",
            "1.9",
            "0.7"
        ],
        "non_matches": [
            "2,1",
            "1",
            "3",
            "a",
            "5",
            "67",
            "8",
            "9",
            "5",
            "3.534",
            "5436.234",
            "423.24"
        ],
        "id": 1284,
        "output": [
            {
                "text": "\n^((\\d+,\\d+)|(\\d+\\.\\d+)|(\\.\\d+))$\n\nA:"
            },
            {
                "text": " \"^[1-9]\\.[0-9]+$\"\n- \"0.99\" match, but \"0,0"
            },
            {
                "text": "\n\nA:\n\nIf you want only a decimal comma, use this regex: [\\d.]+,[\\d.]+\n"
            },
            {
                "text": " (0|\\d,0|\\d\\.\\d)?|(0|1[0-5])|(1[0"
            },
            {
                "text": " (.*)\\/(.*)\n\nExercise 5: Write REGEX for the following string: \"1+2*(3-"
            },
            {
                "text": " ^[0-9,0-9]{2,3}$,\nThis regular expression will match any string that has two or three"
            },
            {
                "text": " [0-9]+, [0-9]\n\nA:\n\nHere is a way to parse a string in the form of"
            },
            {
                "text": "\n^0,0 - 0,0\n0,\\.0 - 0.0\n1,9 - 1,9\n2"
            },
            {
                "text": " /^(0|[1-9]\\.)\\s*(0|[1-9]\\.)$/\n\n"
            },
            {
                "text": " ^(?=\\\\d+\\\\.\\\\d+$)(?=\\\\d+\\\\.\\\\d+\\\\s*[,"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\040]+$",
        "raw_prompt": "It will allow for alphanumeric characters only, with the exception of spacing.",
        "refined_prompt": "It will allow for alphanumeric characters only, with the exception of spacing.\nMatch examples:\n- \"Website Users\"\n- \"g67g\"\n- \"f667f8\"\nNon-match examples:\n- \"Website Users!\"\n- \";f;ds;f\"",
        "matches": [
            "Website Users",
            "g67g",
            "f667f8",
            "f",
            "8f5",
            "d56 f5",
            "f56f",
            "7f77",
            "f68d5",
            "6r4e",
            "45h899h",
            "98",
            "98h"
        ],
        "non_matches": [
            "Website Users!",
            ";f;ds;f",
            "f;",
            "f';f'df;[",
            "f;[d",
            ";[f",
            ";d[dlf[lfd[ld",
            "p[f",
            "[fpkd",
            "j{}",
            "f98h[]",
            "78h7g^&*&("
        ],
        "id": 1313,
        "output": [
            {
                "text": " [A-Za-z0-9_.-]*\n\n4. Exercise: Given a list of words, return a list of only the words that have an \"a\" in them. \nAnswer:\nword_list = [\""
            },
            {
                "text": " [a-zA-Z0-9\\\\-]*\n\nScript:\n\nHost 1: Welcome to our podcast, where we will explore the world of regular expressions in Python. Today, we will be discussing the benefits of using regular"
            },
            {
                "text": " (\\w+\\.){3}(?![^\\w ])\n- \"g67g\" (match, no space)\n- \"f667f8\" (non-match, space)\n- \"f;ds;f"
            },
            {
                "text": " [a-zA-Z0-9._-]+\n\nExercise 2:\nCreate a list of all the valid email addresses in a list.\nAnswer: \nvalid_emails = ['example@gmail.com',\n               "
            },
            {
                "text": " /https?://[a-zA-Z0-9\\-.]+/\n\nExercise 2:\nGiven the following sentence: \"The quick brown fox jumps over the lazy dog\", what is the longest word found and what position it starts"
            },
            {
                "text": " [a-zA-Z0-9._%+-]+\n\nExercise 2: A Website has been hacked and a list of banned words has been given. Write a Python script that will extract and return any pages that contain any of the"
            },
            {
                "text": " (\\w+[a-zA-Z0-9-\\_\\.]+[a-zA-Z0-9])\n\nExercise 2: Searching Patterns\nSearch for the following phrases or words using a RegEx"
            },
            {
                "text": " (The RegEx would be \\S+)\n\nExercise: You will need to use the replace() method to replace non-matching characters. For example, if you're replacing spaces with underscores, your RegEx would look like this: \\S"
            },
            {
                "text": " (w|u;m|e|x;i;t;i;u;n;g|)\n\nExercise 4: \nFill in the blanks in the following RegEx pattern to extract all the email addresses in a text"
            },
            {
                "text": " [a-zA-Z0-9 \\.-;]+\n\nExercise 3:\nWrite a program that uses regex to find all email addresses in a given text.\nAnswer: \nimport re\ntext = \"Contact us at info"
            }
        ]
    },
    {
        "expression": "^\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?$|^\\(\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?\\)$|^(\\$)?(-)?([0]|([1-9]\\d{0,6}))([.]\\d{1,2})?$",
        "raw_prompt": "Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05",
        "refined_prompt": "Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05\nMatch examples:\n- \"($1,234,567.89)\"\n- \"$1,234,567.89\"\n- \"$1234567.89\"\nNon-match examples:\n- \"$1,234,567.890\"\n- \"$12345678.90\"",
        "matches": [
            "($1,234,567.89)",
            "$1,234,567.89",
            "$1234567.89",
            "$-1234567.89",
            "$0.78",
            "$1,660,986",
            "$146.0",
            "($172,545)",
            "($4,546,599)",
            "54927.64",
            "$-59355",
            "-853119",
            "$-18.3"
        ],
        "non_matches": [
            "$1,234,567.890",
            "$12345678.90",
            "$023,456.78",
            "$824.4234234",
            "$4232342.3423.423",
            "$424.234234",
            "-312f23",
            "90u09u09",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1314,
        "output": [
            {
                "text": " ($"
            },
            {
                "text": " $"
            },
            {
                "text": "\n"
            },
            {
                "text": "\n"
            },
            {
                "text": " \""
            },
            {
                "text": " (("
            },
            {
                "text": " ^"
            },
            {
                "text": " \"("
            },
            {
                "text": " \""
            },
            {
                "text": " $"
            }
        ]
    },
    {
        "expression": "^(((\\(\\d{3}\\)|\\d{3})( |-|\\.))|(\\(\\d{3}\\)|\\d{3}))?\\d{3}( |-|\\.)?\\d{4}(( |-|\\.)?([Ee]xt|[Xx])[.]?( |-|\\.)?\\d{4})?$",
        "raw_prompt": "with or without area code (of various forms)(does not allow for unbalanced parens in the area code). With or without an extension (of various forms). Does not allow for leading or trailing space.",
        "refined_prompt": "with or without area code (of various forms)(does not allow for unbalanced parens in the area code). With or without an extension (of various forms). Does not allow for leading or trailing space.\nMatch examples:\n- \"(123)-456-7890 Ext 1234\"\n- \"123-456-7890\"\n- \"(123).456.7890\"\nNon-match examples:\n- \"123)4567890\"\n- \"800callcat\"",
        "matches": [
            "(123)-456-7890 Ext 1234",
            "123-456-7890",
            "(123).456.7890",
            "123.456.7890",
            "1234567890ext1234",
            "123-456 7890 X 1234",
            "921.9170733",
            "570-5322061",
            "885.0096",
            "(102)8703702x1308",
            "8577364735",
            "840.5595",
            "963.4797"
        ],
        "non_matches": [
            "123)4567890",
            "800callcat",
            "123456789",
            "afdsaf.adijs",
            "4.23.2423",
            "$23.454",
            "43-5432",
            "2546dgwre",
            "245/524/12",
            "com.edu.github",
            "(0xx12) 62509@",
            "0j0jweBBBB"
        ],
        "id": 1317,
        "output": [
            {
                "text": "  ^[\\d]{3}\\s?[\\"
            },
            {
                "text": " (123.456.7890)|800[-a-"
            },
            {
                "text": " \\(([12]\\d{3}[-.]"
            },
            {
                "text": " [^\\d][\\(\\d\\)]*[\\"
            },
            {
                "text": "\n(?<!\\s)\\d{3}["
            },
            {
                "text": " (\\d{3})-(\\d{3})-"
            },
            {
                "text": " (\\(\\d{3}[-\\.\\s]"
            },
            {
                "text": " Regex: [a-zA-Z ]+\n"
            },
            {
                "text": " (\\d{3}):(\\d{3})-"
            },
            {
                "text": " (.\\d)\\s\\S\\s\\d\\.\n"
            }
        ]
    },
    {
        "expression": "^(\\d{4})[.](0{0,1}[1-9]|1[012])[.](0{0,1}[1-9]|[12][0-9]|3[01])[.](\\d{2})$",
        "raw_prompt": "capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99",
        "refined_prompt": "capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99\nMatch examples:\n- \"2006.10.09.05\"\n- \"1672.08.31.93\"\n- \"0081.12.30.60\"\nNon-match examples:\n- \"06.13.32.123\"\n- \"52/2/54/245\"",
        "matches": [
            "2006.10.09.05",
            "1672.08.31.93",
            "0081.12.30.60",
            "0042.12.30.94",
            "9297.2.25.15",
            "6833.12.31.21",
            "7766.10.28.39",
            "4714.12.17.10",
            "8849.08.31.60",
            "8036.10.25.94",
            "4157.10.7.78",
            "9477.08.30.96",
            "6917.10.03.26"
        ],
        "non_matches": [
            "06.13.32.123",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "1-1-2",
            "34.31",
            "3409fjg43"
        ],
        "id": 1326,
        "output": [
            {
                "text": " \\d{4}-\\d{2}-\\d{2}\n\n[^\\d"
            },
            {
                "text": "  (?<day>\\d{2}\\.\\d{2}\\.\\d{2}"
            },
            {
                "text": "\n/^([0-9]{4})\\.([1-9][0-9]|"
            },
            {
                "text": " ^\\d+(?:\\.\\d+)?(?:[\\/\\-\\w]\\d+)?"
            },
            {
                "text": " 06[0-9]/[0-9]/[0-9]/[0-9"
            },
            {
                "text": "\n\n[0-9a-zA-Z]{4}\\.\\d{2}\\."
            },
            {
                "text": " \"06.*\\.[0-9]{2}.\\d{2}.\\d{3}.{"
            },
            {
                "text": "\n[0-9]{1,2}[\\/\\\\\\-]?[0-9]{"
            },
            {
                "text": " \"^[A-Z]{2}.$\"\n\nA:\n\nYou can probably use Date"
            },
            {
                "text": " [a-zA-Z]\\d{2}[a-zA-Z]\\d"
            }
        ]
    },
    {
        "expression": "^\\$?\\d{1,3}(,?\\d{3})*(\\.\\d{1,2})?$",
        "raw_prompt": "Just a small pattern to make sure commas are in the rite place (if present). Only allows one decimal to be suffixed with with 1 or 2 digits. Also optional dollar sign may proceed value.",
        "refined_prompt": "Just a small pattern to make sure commas are in the right place (if present). Only allows one decimal to be suffixed with with 1 or 2 digits. Also optional dollar sign may proceed value.\nMatch examples:\n- \"$1,000,000.00\"\n- \"123,000\"\n- \"455,123\"\nNon-match examples:\n- \"43,3.245\"\n- \"423,423,4,234,234\"",
        "matches": [
            "$1,000,000.00",
            "123,000",
            "455,123",
            "845,312,414",
            "12",
            "8",
            "7",
            "648.27",
            "5",
            "9",
            "4",
            "210",
            "764"
        ],
        "non_matches": [
            "43,3.245",
            "423,423,4,234,234",
            "423,4,23,424,,24",
            "7,567,9,8",
            ",563,5,8,7,252",
            "534,63.56,363",
            "5,34.74,46.345",
            ",534.5475,.34,",
            ".6445,3.845.,5",
            ".53,63.6,3.635",
            ",5347,.96,25,",
            "354,67.43634"
        ],
        "id": 1333,
        "output": [
            {
                "text": " \"(?<![0-9a-zA-Z])[0"
            },
            {
                "text": " \n(?<!\\$)(?:[0-9]{1"
            },
            {
                "text": " 123\\.?[0-9]{,2}\n\nI would like"
            },
            {
                "text": " $,1[0-9]{1,2}(,[0-"
            },
            {
                "text": " \\d {0,2},?$\n\nHere are 4 regex patterns to"
            },
            {
                "text": " [0-9]{4}[,.]{1,3}["
            },
            {
                "text": " \n^([1-9][0-9]*|[1-"
            },
            {
                "text": " \"3[0-9][0-9,]*\"\n\nA"
            },
            {
                "text": " ^\\d{1,2}((,)|\\d{3})["
            },
            {
                "text": " (\\d{1,3})(\\,\\d{3})*"
            }
        ]
    },
    {
        "expression": "^[0-3][0-9][0-1]\\d{3}-\\d{4}?",
        "raw_prompt": "This regex performs a crude test on the given input string.\nThe danish cilvil registration number consists of 10 numeric characters and one special character '-'. The format is DDMMYY-XXXX.",
        "refined_prompt": "This regex performs a crude test on the given input string.\r\nThe danish cilvil registration number consists of 10 numeric characters and one special character '-'. The format is DDMMYY-XXXX.\nMatch examples:\n- \"010380-2343\"\n- \"120454-5467\"\n- \"390178-3434\"\nNon-match examples:\n- \"1223876776\"\n- \"4023100923\"",
        "matches": [
            "010380-2343",
            "120454-5467",
            "390178-3434",
            "021535-6554",
            "171865-8670",
            "121002-8304",
            "201468-3622",
            "090642-3583",
            "221117-6041",
            "121786-6120",
            "390554-9695",
            "041194-8781",
            "050057-8654"
        ],
        "non_matches": [
            "1223876776",
            "4023100923",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1334,
        "output": [
            {
                "text": " \\d{2}[-\\s]?\\d{4"
            },
            {
                "text": "\n/[0-9]{2}[0-9]"
            },
            {
                "text": " https://regex101.com/r/FyEj1"
            },
            {
                "text": " [0103]-[012]\\d{2}[0-"
            },
            {
                "text": " (.*)-(.*)(.*)(.*)(.*)(.*)(.*"
            },
            {
                "text": " [0-9]{1,3}[-][0-"
            },
            {
                "text": " \\d{10}-\\d{4}-\\d{"
            },
            {
                "text": " \n([0-9]*(?:\\.[0-9"
            },
            {
                "text": "\n([0-9]{2})-([0-9]"
            },
            {
                "text": " dd-MMYY-XXXX\nRegex for this description\n^(["
            }
        ]
    },
    {
        "expression": "^M{0,1}T{0,1}W{0,1}(TH){0,1}F{0,1}S{0,1}(SU){0,1}$",
        "raw_prompt": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' . Only one instance of these set of letters is accepted.",
        "refined_prompt": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' . Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"",
        "matches": [
            "MWF",
            "TTHS",
            "MT",
            "WFS",
            "MFSU",
            "TH",
            "MTTHFS",
            "MWTHFSU",
            "MTTHSSU",
            "TFSU",
            "MWSU",
            "TWF",
            "THFSU"
        ],
        "non_matches": [
            "MM",
            "WM",
            "FTH",
            "SM",
            "9ijn",
            "3nf@",
            "43-5432",
            "90u09u09",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1356,
        "output": [
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches a string if it is valid in the form of MWF or TTHS. Maybe used for validating the \"days part\" of a class schedule field. The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU'. Only one instance of these set of letters is accepted.\nMatch examples:\n- \"MWF\"\n- \"TTHS\"\n- \"MT\"\nNon-match examples:\n- \"MM\"\n- \"WM\"Generate a RegEx for this description.\n"
            }
        ]
    },
    {
        "expression": "^(([0][0-9]|[1][0-2])|[0-9]):([0-5][0-9])( *)((AM|PM)|(A|P))$",
        "raw_prompt": "Matches a string if it is a valid time in the format of \"HH:MM AM\" or \"HH:MM A\".",
        "refined_prompt": "matches time in both 12-hour and 24-hour formats, capturing hours, minutes, and an optional space followed by \"AM,\" \"PM,\" \"A,\" or \"P.\"\nMatch examples:\n- \"1:30 AM\"\n- \"01:20 AM\"\n- \"10:00A\"\nNon-match examples:\n- \"13:00 A\"\n- \"01:5 AM\"",
        "matches": [
            "1:30 AM",
            "01:20 AM",
            "10:00A",
            "11:50P",
            "01:45 AM",
            "12:00 PM",
            "03:30AM",
            "8:15 PM",
            "5:05AM",
            "11:59 PM",
            "09:00 AM",
            "1:10 PM",
            "02:45AM"
        ],
        "non_matches": [
            "13:00 A",
            "01:5 AM",
            "09:00 AB",
            "1:1 AM",
            "9:75 PM",
            "15:15 AM",
            "12:60 AM",
            "07:00 BM",
            "60:25 AM",
            "04:60 PM",
            "3:50 XM",
            "8h98009hu"
        ],
        "id": 1357,
        "output": [
            {
                "text": " (1) \"^(1[0-9]|[1-9][0-9]) ([0-5]["
            },
            {
                "text": " Matches time in both 12-hour and 24-hour formats, captures hours, minutes, and an optional space followed by \"AM"
            },
            {
                "text": " [regex to generate]\n\nExercise 3:\nGiven a string representing a date in the format \"MM/DD/"
            },
            {
                "text": "\nregex = '^(0[1-9]|1[0-2])' \\\n        '\\s"
            },
            {
                "text": " This one is tricky, but the idea is to use a negative lookahead and lookbehind assertion to exclude any time that is preceded by"
            },
            {
                "text": " ([0-9]?[0-9](:[0-9]|(1[0-2]))[0"
            },
            {
                "text": " (Example) [0-9]{1,2}:[0-9][0-9] [a-z]"
            },
            {
                "text": " Regex for time ranges between 1:00 AM and 5:00 AM: \"^(1[012]|0?["
            },
            {
                "text": " (n/a)\n\nExercise 3: Matching Email Addresses\nExercise: Match the email addresses to the correct"
            },
            {
                "text": "\n- The RegEx should be \"^(([01][0-9]|2[0-3]):([0"
            }
        ]
    },
    {
        "expression": "^-?\\d+(\\.\\d+)?$",
        "raw_prompt": "Matches any unsigned or signed floating point number/numeric string.",
        "refined_prompt": "Matches any unsigned or signed floating point number/numeric string.\nMatch examples:\n- \"123\"\n- \"3.14159\"\n- \"-1.2\"\nNon-match examples:\n- \"abc\"\n- \"3.4.2\"",
        "matches": [
            "123",
            "3.14159",
            "-1.2",
            "7865",
            "75",
            "8646",
            "847",
            "35",
            "478",
            "69.524",
            "57845",
            "74",
            "78.54"
        ],
        "non_matches": [
            "abc",
            "3.4.2",
            ".234",
            "-123f",
            "4.23.2423",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1362,
        "output": [
            {
                "text": "\n^[\\d-]+(?:\\.[\\d-]+)+$\n\n[\\d] matches a single digit 0-9\n+ means match one or more of the previous character\n(?:\\.[\\d-]+)+ matches a period followed"
            },
            {
                "text": " \"^[0-9]+(\\.[0-9]+)[eE][+-][0-9]+$\"\n\n3. Write a RegEx to match a string that starts with \"A,\" \"B,\" or \"C\" up to the end"
            },
            {
                "text": " [A-Za-z0-9].[0-9]*\n\nA:\n\nYour first example is already a regex, it is \"one or more digits followed by a literal period\".  If you want a literal., you need to escape it"
            },
            {
                "text": ".+?[\\d\\.]+\n\n3. Match any word or character. \nAnswer:.+\n\n4. Match any non-word or non-character. \nAnswer:.*\n\n5. Match any word or character, but only"
            },
            {
                "text": " The correct answer is \\-?\\d\\.?\\d+.*\n\nExercise 2: \nMatch any negative number preceded by a negative sign.\nMatch examples:\n- \"-12.34\"\n- \"-7.45\"\nNon-match examples:"
            },
            {
                "text": " \"\\D*\\.\\d*\"\n\nA:\n\n\\d|\\D matches both the number before the dot and the number after the dot.\nIf you want to match numbers before and after the dot, you need to specify this range with [\\d.]"
            },
            {
                "text": " \n\n(?=\\d)(?=\\.\\d)\n\nQuestion 2:\nCreate a RegEx to match any integer number/numeric string.\nGenerate a RegEx for this description. \nAnswer:\n\n\\b\\d+\\"
            },
            {
                "text": " ^[a-zA-Z0-9]+[\\.][0-9]+$\n- \"1.23e15.00\" Generate a RegEx for this description. \nAnswer: ^[0-9]+\\.[0-9]"
            },
            {
                "text": " \"([0-9]{1,3}\\.?[0-9]+)([a-zA-Z]{1,3})\"\n\nA:\n\nI think this regex will do it\n^[0-9]*[a-"
            },
            {
                "text": " [0-9]\\.[0-9]|[0-9][0-9]\\.[0-9]|[0-9]\\.[0-9] [0-9]\\.[0-9]|[0-9][0"
            }
        ]
    },
    {
        "expression": "^(?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))$",
        "raw_prompt": "Just a simple US State regex. Requires valid 2 letter abbreviations.",
        "refined_prompt": "Just a simple US State regex. Requires valid 2 letter abbreviations.\nMatch examples:\n- \"CO\"\n- \"GA\"\n- \"TX\"\nNon-match examples:\n- \"A\"\n- \"ZZ\"",
        "matches": [
            "CO",
            "GA",
            "TX",
            "HI",
            "OR",
            "KS",
            "FL",
            "HI",
            "CT",
            "DC",
            "IA",
            "LA",
            "MD"
        ],
        "non_matches": [
            "A",
            "ZZ",
            "Florida",
            "(12) 324 653210",
            "9ijn",
            "3nf@",
            "-312",
            "notre dame",
            "u09nKLJG FSL",
            "354/243/542",
            "dfg",
            "32542 //"
        ],
        "id": 1372,
        "output": [
            {
                "text": " ^[A-Z]{2}$\n\nWhat I have so far:\nprivate static string GetAbbreviatedCode(string code)\n    {\n        var regex = new Regex(@\"^[A-Z]{2}$\");\n        return regex.IsMatch(code"
            },
            {
                "text": " \n^[A-Z]{1}[A-Z]?[A-Z]$\n\nA:\n\ntry [A-Z]{2}[A-Z]\n\nA:\n\nTo match letters only\nMatch any letter A through Z in a word.\nUse"
            },
            {
                "text": " \"\\b\\w{2}\\b\"\n- \"\"\n- \"AZ\"Generate a RegEx for this description. \nAnswer: \"\\b\\w{2}\\b\"\\W\n\nA:\n\nThis is one way of doing it. It uses a Regex which uses a \\b ("
            },
            {
                "text": " (\\d[A-Z]{1})\\(?\\d{1}\\)?\n\nA:\n\nI think it's the most simple regex for the problem.\n^([A-Z]{1})\\s*\\(\\d{1}\\)?$\n\nThis regex will match the"
            },
            {
                "text": " (I can't get this to print the RegEx as a string)\nimport re\np = re.compile(\"^[A-Z][A-Z][A-Z]$\")\nprint(p)\n\nA:\n\nIf you can ensure the input is always two-letter, simple"
            },
            {
                "text": " [A-Z][A-Z]|[A-Z]\n\nUsing a simple string array, generate the matching arrays. Store a reference to the matching arrays and use it to check if the user input matches the desired string. \n\nExample:\n$state = array(\"CO\", \"GA\", \""
            },
            {
                "text": " (?:C[0-9]|A[0-9]|Z[0-9])\n\nA:\n\nI'd use another look ahead regex to see if the first letter is an uppercase letter. I'm assuming you'll only have a 2 letter state abbreviation, i.e."
            },
            {
                "text": " ^[0-9]{2}|[A-Za-z]{2}$\n\nA:\n\nA simple (short) and effective regex will look like:\n^(?:[a-z]{2}[A-Z][a-z]|[a-z"
            },
            {
                "text": " [A-Z]{2}-[A-Z]{2}-[A-Z]{3}\n\nA:\n\ntry this:\nString str = \"CO-GA-TX\";\nString regex = \"\\\\(\\\\B[A-Z]\\\\)|\\\\b[A-Z"
            },
            {
                "text": " ^[0-9]{2}([A-Z]{2})?$\n\nA:\n\nYou only need to match non-letter characters:\n^[^\\W_]+$\n\nFor more than one-character sequences (instead of non-letter-or-underscore-character"
            }
        ]
    },
    {
        "expression": "(?:(?:(?:04|06|09|11)\\/(?:(?:[012][0-9])|30))|(?:(?:(?:0[135789])|(?:1[02]))\\/(?:(?:[012][0-9])|30|31))|(?:02\\/(?:[012][0-9])))\\/(?:19|20|21)[0-9][0-9]",
        "raw_prompt": "Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199.",
        "refined_prompt": "Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199.\nMatch examples:\n- \"02/21/1972\"\n- \"12/31/2199\"\n- \"09/04/1901\"\nNon-match examples:\n- \"02/31/1999\"\n- \"02-21-1972\"",
        "matches": [
            "02/21/1972",
            "12/31/2199",
            "09/04/1901",
            "11/30/1914",
            "04/30/1955",
            "09/31/1943",
            "02/07/2123",
            "10/03/2100",
            "10/19/2179",
            "10/30/1962",
            "02/20/1969",
            "02/27/1962",
            "04/12/2083"
        ],
        "non_matches": [
            "02/31/1999",
            "02-21-1972",
            "06/31/2001",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "notre dame",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1388,
        "output": [
            {
                "text": "\n(February\\\\s)?(\\\\d{1,2})\\\\s"
            },
            {
                "text": "\n(?<month>\\d\\d)-(?<day>"
            },
            {
                "text": " [\\d]{1,2}\\s[\\d]{1"
            },
            {
                "text": " (regex) \"(([0-9]{4})-(["
            },
            {
                "text": " /((\\d{4})/(\\d{2})/(\\d"
            },
            {
                "text": " \n^[0-9]{2}[0-9]["
            },
            {
                "text": " (?i)(?<=(?<=\\d)-(?="
            },
            {
                "text": " \n^[0-9]{1,2}/[0"
            },
            {
                "text": "  [0-9]{2}[-/][0-9"
            },
            {
                "text": " \\d{1,2}[-/\\s]\\d{"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\.\\d{3}\\.\\d{3}[-][0-9kK]{1}$",
        "raw_prompt": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00e1 necesario validar su d\u00edgito verificador.",
        "refined_prompt": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00e1 necesario validar su d\u00edgito verificador.\nMatch examples:\n- \"12.025.365-6\"\n- \"5.698.124-k\"\n- \"7.999.647-K\"\nNon-match examples:\n- \"125.326.452-1\"\n- \"15.336.054-H\"",
        "matches": [
            "12.025.365-6",
            "5.698.124-k",
            "7.999.647-K",
            "2.358.268-2",
            "06.346.822-K",
            "23.104.146-4",
            "6.845.282-2",
            "4.293.999-K",
            "68.660.311-4",
            "7.023.409-8",
            "35.511.925-4",
            "21.484.004-k",
            "7.461.216-4"
        ],
        "non_matches": [
            "125.326.452-1",
            "15.336.054-H",
            "15254587k",
            "fasd@fds.fasd@",
            "234/423/5243",
            "there is a boy",
            "AAAAAAA",
            "notre dame",
            "u09nKLJG FSL",
            "com.edu.github",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1389,
        "output": [
            {
                "text": " I can use"
            },
            {
                "text": "\n\nimport"
            },
            {
                "text": "\n- \""
            },
            {
                "text": " A REGEX"
            },
            {
                "text": "\nRUT"
            },
            {
                "text": " \\d{"
            },
            {
                "text": " \"^["
            },
            {
                "text": "\n\n\""
            },
            {
                "text": " [^-"
            },
            {
                "text": " \n^"
            }
        ]
    },
    {
        "expression": "\\d{2}[.]{1}\\d{2}[.]{1}[0-9A-Za-z]{1}",
        "raw_prompt": "This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004",
        "refined_prompt": "This pattern match the Italian Istat Ateco Code (Codice Istat) updated to Istat Declaration Ateco 2004\nMatch examples:\n- \"22.12.0\"\n- \"18.24.C\"\n- \"98.65.T\"\nNon-match examples:\n- \"22.12_D\"\n- \"12.56\"",
        "matches": [
            "22.12.0",
            "18.24.C",
            "98.65.T",
            "76.74.P",
            "62.08.L",
            "05.69.n",
            "01.90.x",
            "48.02.V",
            "38.20.0",
            "42.35.Z",
            "17.40.5",
            "28.68.P"
        ],
        "non_matches": [
            "22.12_D",
            "12.56",
            "1A.56.1",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "000-000",
            "354/243/542",
            "(0xx12) 62509@"
        ],
        "id": 1410,
        "output": [
            {
                "text": " \nr\"^(\\d+)\\.(\\d+)\\..\\.(\\d+)\\.(\\d+)_D$\"\n\nExercise 3: Write"
            },
            {
                "text": "\n\\d[0-9]{2}\\.\\d[0-9]{2}\\.C[0-9]{4}\n\n5."
            },
            {
                "text": " ^(?P<code>\\d+)\\.(?P<type>\\w+)\\.(?P<deco>\\w+)(_[^_"
            },
            {
                "text": " \"^([0-9]{1,3}\\.?[0-9]{1,2}\\.?[0-9]{1,2}"
            },
            {
                "text": " \n(((?<year>[0-9]\\d{1,2})\\.(?<month>[0-9]\\d{1,2}"
            },
            {
                "text": " \n.*(?<=_)\\d\n\nExercise 2:\nMatch patterns that are all capitalized. \nAnswer: \n[A-Z]"
            },
            {
                "text": " (\\d+\\.\\d+).*\\.(\\d+)\n\n2. Write a regular expression to match any date formatted in the 'dd.MM.yy"
            },
            {
                "text": " (?<!\\d)(\\d\\.){1,2}\\.\\d\\w{3,}\n\n4. Given the following set of numbers and"
            },
            {
                "text": " ^[a-zA-Z]\\d{1,2}.\\d{1,2}.\\d{1,2}.\\d{1,2"
            },
            {
                "text": " (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})(\\+|"
            }
        ]
    },
    {
        "expression": "IT\\d{2}[ ][a-zA-Z]\\d{3}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{3}|IT\\d{2}[a-zA-Z]\\d{22}",
        "raw_prompt": "International Bank Account Number (IBAN) Italian. Identify Bank account in Italy.",
        "refined_prompt": "International Bank Account Number (IBAN) Italian. Identify Bank account in Italy.\nMatch examples:\n- \"IT28 W800 0000 2921 0064 5211 151\"\n- \"IT28W8000000292100645211151\"\n- \"IT47r6150582949310134977462\"\nNon-match examples:\n- \"IT28-W800-0000-2921-0064-5211-151\"\n- \"52/2/54/245\"",
        "matches": [
            "IT28 W800 0000 2921 0064 5211 151",
            "IT28W8000000292100645211151",
            "IT47r6150582949310134977462",
            "IT50u4563415448490981947813",
            "IT45q3314391860255535018247",
            "IT66q2029117404871419554111",
            "IT62M7475226742656801338781",
            "IT08X8257033707588935025587",
            "IT17 B623 6010 0263 0308 1745 060",
            "IT41y2666346576666598173469",
            "IT74 t088 4777 7816 7371 3544 052",
            "IT22 u440 3355 3011 3390 9980 399",
            "IT35 G884 5647 9598 6037 6739 043"
        ],
        "non_matches": [
            "IT28-W800-0000-2921-0064-5211-151",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "there is a boy",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "com.edu.github",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1411,
        "output": [
            {
                "text": "\n[0-9]{"
            },
            {
                "text": " \"IT28(\\w{3"
            },
            {
                "text": " (\\d/\\d/"
            },
            {
                "text": " r\"\\d{4}"
            },
            {
                "text": " (1) \"IT28-"
            },
            {
                "text": " '^-?(([0"
            },
            {
                "text": " \n\n| Bank Account Number"
            },
            {
                "text": " \".+-\\d{4"
            },
            {
                "text": "\n```\nIBAN ="
            },
            {
                "text": " - IT28-(W800-"
            }
        ]
    },
    {
        "expression": "(^4\\d{12}$)|(^4[0-8]\\d{14}$)|(^(49)[^013]\\d{13}$)|(^(49030)[0-1]\\d{10}$)|(^(49033)[0-4]\\d{10}$)|(^(49110)[^12]\\d{10}$)|(^(49117)[0-3]\\d{10}$)|(^(49118)[^0-2]\\d{10}$)|(^(493)[^6]\\d{12}$)",
        "raw_prompt": "Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta. Safe for international and will NOT match \"^(49)\" Switch debit cards.",
        "refined_prompt": "Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta. Safe for international and will NOT match \"^(49)\" Switch debit cards.\nMatch examples:\n- \"4111111111111111\"\n- \"4903302261507834\"\n- \"4467220202996\"\nNon-match examples:\n- \"4903020000000008\"\n- \"52/2/54/245\"",
        "matches": [
            "4111111111111111",
            "4903302261507834",
            "4467220202996",
            "49110)1235196213",
            "4903017255950095",
            "493Q756879644542",
            "4911709979024881",
            "4911724535180908",
            "49110u9577293921",
            "4903308308396935",
            "4459227852002739",
            "493L044079768559",
            "4903309339220364"
        ],
        "non_matches": [
            "4903020000000008",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1414,
        "output": [
            {
                "text": " [^09]0[1-9]|"
            },
            {
                "text": " \"\\d{10}/\\d{2}"
            },
            {
                "text": " (4|5)-((1|2)|("
            },
            {
                "text": " [^\\d/]$\n- \"4"
            },
            {
                "text": " ([0-9]{3,4}/"
            },
            {
                "text": " 52[A-Za-z0-9"
            },
            {
                "text": "\n\nHere's my working solution, it uses a"
            },
            {
                "text": " \"^(48)(0|[1-9"
            },
            {
                "text": " (\\d{4}\\d{3}\\d"
            },
            {
                "text": " ^(49|52|54|245)\\."
            }
        ]
    },
    {
        "expression": "(^(5[0678])\\d{11,18}$)|(^(6[^05])\\d{11,18}$)|(^(601)[^1]\\d{9,16}$)|(^(6011)\\d{9,11}$)|(^(6011)\\d{13,16}$)|(^(65)\\d{11,13}$)|(^(65)\\d{15,18}$)|(^(49030)[2-9](\\d{10}$|\\d{12,13}$))|(^(49033)[5-9](\\d{10}$|\\d{12,13}$))|(^(49110)[1-2](\\d{10}$|\\d{12,13}$))|(^(49117)[4-9](\\d{10}$|\\d{12,13}$))|(^(49118)[0-2](\\d{10}$|\\d{12,13}$))|(^(4936)(\\d{12}$|\\d{14,15}$))",
        "raw_prompt": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.",
        "refined_prompt": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"",
        "matches": [
            "6334500000000003",
            "65787411526656",
            "6011273550429",
            "4911806694738239",
            "601170831788719484",
            "4936071095523185",
            "65213324135290730380",
            "6534390341823",
            "4911012277568333917",
            "6M903146540804017677",
            "6G748260985328737",
            "4903386469066177",
            "4903084055698099"
        ],
        "non_matches": [
            "6011000000000004",
            "52/2/54/245",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "(0xx12) 7256 2345154",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1425,
        "output": [
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches any of Solo, Switch or Maestro. International safe. Will not match on Discover, Visa or Mastercard. For example; Most recommendations for matching Visa are that they start with \"4\". If outside the US, this are incomplete on will falsly ID most Switch cards as Visa.\nMatch examples:\n- \"6334500000000003\"\n- \"65787411526656\"\n- \"6011273550429\"\nNon-match examples:\n- \"6011000000000004\"\n- \"52/2/54/245\"Generate a RegEx for this description. \n"
            }
        ]
    },
    {
        "expression": "^(97(8|9))?\\d{9}(\\d|X)$",
        "raw_prompt": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.",
        "refined_prompt": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979.\nMatch examples:\n- \"0672317249\"\n- \"9780672317248\"\n- \"357392943X\"\nNon-match examples:\n- \"0-672-31724-9\"\n- \"5555555555555\"",
        "matches": [
            "0672317249",
            "9780672317248",
            "357392943X",
            "6548106745",
            "9781061071527",
            "9793849883344",
            "9792371728730",
            "9780578739633",
            "803592955X",
            "9947182241",
            "9795633078285",
            "9782710478725",
            "738696527X"
        ],
        "non_matches": [
            "0-672-31724-9",
            "5555555555555",
            "2534/52435234/2453",
            "afdsaf.adijs",
            "9ijn",
            "$23.454",
            "AAAAAAA",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1428,
        "output": [
            {
                "text": " ([\\d-]{9}|[\\d]{9}-)\\d{4}\n\n\n\nQuestion 3: The sum of"
            },
            {
                "text": " \n(?=^[979])(?=^[978])(?=^[987])(?=^[9])("
            },
            {
                "text": " \"^[07]\\d{9}[-\\s]?\\d{3}[-\\s]?\\d{4}"
            },
            {
                "text": " The RegEx is \"(0-6)[0-9]{15}(X|)(0-6)[0-9]{15}("
            },
            {
                "text": " [0-9][0-9]{3}\\-[0-9][0-9]{3}\\-[0-9][0-9"
            },
            {
                "text": "\n\ndef validate_ISBN(ISBN):\n  ISBN = ISBN.replace(\" \", \"-\")\n  ISBN = ISBN.upper()"
            },
            {
                "text": " (0-9)(\\d{3})([A-Z]{2})([0-9]{5})([A-"
            },
            {
                "text": " [0-9]{8}-[0-9]{4}-[0-9]{4}-[0-9]{4}"
            },
            {
                "text": "\n- ([0-9]{9}[0-9]{3}[0-9]{4})|([0-9]"
            },
            {
                "text": " [0-9][0-9][0-9][0-9][0-9] - This regex will match any 10 or 11 digit number"
            }
        ]
    },
    {
        "expression": "^[\\w]{1,}$",
        "raw_prompt": "alphanumeric - no space allowed - requires at least one character",
        "refined_prompt": "alphanumeric - no space allowed - requires at least one character\nMatch examples:\n- \"a123b\"\n- \"56\"\n- \"d6\"\nNon-match examples:\n- \"a 1\"\n- \"52/2/54/245\"",
        "matches": [
            "a123b",
            "56",
            "d6",
            "56y",
            "d57",
            "g98g",
            "5r45",
            "43",
            "r6y98",
            "t545er67t8y",
            "u87",
            "y7uhf5",
            "f43vt33"
        ],
        "non_matches": [
            "a 1",
            "52/2/54/245",
            "-243fewdE#@",
            "(12) 324 653210",
            "ft f6 f",
            "f5 f5",
            "f5 g78yu&^YU",
            "f yvuv76y",
            "5f5tf76f i",
            "7 gyu",
            "6iy#@E",
            "#@EQW"
        ],
        "id": 1439,
        "output": [
            {
                "text": " ^([a-zA-Z0-9]+)([^/]*)([^/]*$)\n\nExercise 2: Password Verification\nCreate a code that takes a user's password as input and verifies whether it meets the following criteria:"
            },
            {
                "text": " \"^[^0-9a-zA-Z ]*$|^[0-9a-zA-Z] *$\"\n- \"a 1\"\n- \"52/2/54/245\"Generate a RegEx for this description"
            },
            {
                "text": " ^[a-zA-Z0-9]+([ -/]|$)$\n\n\n\nQuestion 8: The perimeter of a rectangle is 30 cm. If the length of the rectangle is twice the width, what are its dimensions?\n\nSolution:\n"
            },
            {
                "text": " \"^[a-zA-Z0-9]*$\"\n\nExercise 3:\nGive an example of a real-life problem that could be solved with RegEx.\nAnswer: Extracting phone numbers from a large string of text.\n\nEx"
            },
            {
                "text": " (\\d+)/(\\d+)/.+\n\nExercise 2:\nUsing the \"^\" character, write a RegEx to match the following description:\nA password must start with a letter, followed by at least 8 numeric characters, then followed by one of the"
            },
            {
                "text": " ^[a-zA-Z0-9]*[a-zA-Z0-9/]*$\n\nExercise 2:\n- Generate a RegEx for this description. \n\"The first name is followed by the last name ("
            },
            {
                "text": " a-zA-Z0-9/\n\n2. Regex that separates the elements of a list:\nGiven a list of elements separated by a comma and a space, generate a regex that will separate them into two lists:\nExample:\nseparate([\""
            },
            {
                "text": " \\d+[^/]\n- \"a1\"\n- \"52/2/54/245\"Generate a RegEx for this description. \nAnswer: \\d+[^/]*/\\d+[^/]\n\n2) Write"
            },
            {
                "text": " \n(a|b|[0-9]|[a-z]+)([a-z0-9]*)([/[a-z0-9]*/]+)*\n\nA:\n\nIf you want a regex for each of the following"
            },
            {
                "text": " \\d+\\/\\d+\\/\\d+\\/\\d+ - exactly 5 characters, no spaces, 1 or more digits\n\nExample 2:\nSuppose you're a teacher tasked with grading a stack of test papers. You want to make sure that every paper is"
            }
        ]
    },
    {
        "expression": "(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.)|(^127\\.0\\.0\\.1)",
        "raw_prompt": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. ***Importnat*** This pattern assumes that the input is a valid IP address. You many need to make sure the input is a valid IP address.",
        "refined_prompt": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"",
        "matches": [
            "10.12.0.19",
            "172.21.0.23",
            "192.168.0.2",
            "10.0.0.1",
            "172.16.0.1",
            "172.17.0.2",
            "172.30.1.3",
            "192.168.1.1",
            "127.0.0.1",
            "10.10.10.10",
            "172.16.255.255",
            "172.31.0.0",
            "192.168.0.100"
        ],
        "non_matches": [
            "222.12.3.24",
            "172.12.0.12",
            "2534/52435234/2453",
            "234.234.24.2.423",
            "42.342.3.524.23.",
            "543.25.453..2",
            "5..53..75.35.5.3.53.",
            "534.345.6.4.643",
            "5.34.37.5.23.",
            ".788..7462..543",
            "354.56.56.8.",
            "45.4.67.4435"
        ],
        "id": 1449,
        "output": [
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this\n"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this."
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this one"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this case"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this pattern"
            },
            {
                "text": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. This pattern assumes that the input is a valid IP address.\nMatch examples:\n- \"10.12.0.19\"\n- \"172.21.0.23\"\n- \"192.168.0.2\"\nNon-match examples:\n- \"222.12.3.24\"\n- \"172.12.0.12\"Generate a RegEx for this,"
            }
        ]
    },
    {
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]?|[A-Z]{2}\\d[A-Z\\d]?)[ ]??(\\d[A-Z]{0,2})??$",
        "raw_prompt": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case.",
        "refined_prompt": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case.\nMatch examples:\n- \"W1A1AB\"\n- \"GIR0L\"\n- \"GIR2KU\"\nNon-match examples:\n- \"WWW1AB\"\n- \"c:\\f34fvfv\"",
        "matches": [
            "W1A1AB",
            "GIR0L",
            "GIR2KU",
            "K3",
            "M7",
            "SW0",
            "GIR9M",
            "N1M",
            "GIR",
            "PR7",
            "GIR",
            "UF1L",
            "AO8"
        ],
        "non_matches": [
            "WWW1AB",
            "c:\\f34fvfv",
            "53495083409x",
            "afdsaf.adijsTFVG",
            "DRTFC",
            "DRTCF",
            "TRCF6F",
            "T",
            "7FT87G8",
            "5f8yg",
            "6f7ui7",
            "d67"
        ],
        "id": 1457,
        "output": [
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space after"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)."
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space),"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)."
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)."
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)"
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)."
            },
            {
                "text": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions. The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space)."
            }
        ]
    },
    {
        "expression": "^(GIR|[A-Z]\\d[A-Z\\d]??|[A-Z]{2}\\d[A-Z\\d]??)[ ]??(\\d[A-Z]{2})$",
        "raw_prompt": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)",
        "refined_prompt": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\"\n- \"c:\\f34fvfv\"",
        "matches": [
            "GIR0AA",
            "SV85 9SV",
            "T0J 4XZ",
            "U76VA",
            "GIR 6JN",
            "GIR 3XP",
            "GIR 4NS",
            "LX86SU",
            "VU47TU",
            "GIR 1QH",
            "IG9H4AY",
            "F2Q1PS",
            "KD36CL"
        ],
        "non_matches": [
            "WWW1AB",
            "c:\\f34fvfv",
            "-243",
            "afdsaf.adijs",
            "9ijn",
            "3nf@",
            "43-5432",
            "254627g.256",
            "u09nKLJG FSL",
            "354/243/542",
            "abc111def",
            "8h98009hu"
        ],
        "id": 1458,
        "output": [
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB0"
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB12"
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            },
            {
                "text": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted). (requires postcodes to be upper-case)\nMatch examples:\n- \"GIR0AA\"\n- \"SV85 9SV\"\n- \"T0J 4XZ\"\nNon-match examples:\n- \"WWW1AB\""
            }
        ]
    },
    {
        "expression": "^[0-9]+[NnSs] [0-9]+[WwEe]$",
        "raw_prompt": "This tests, are entered AW coordinates in correct short format, and it has no world info",
        "refined_prompt": "match coordinate pairs in the format of latitude (North/South) followed by longitude (West/East), where both latitude and longitude are represented by numbers.\nMatch examples:\n- \"0N 0W\"\n- \"34N 118W\"\n- \"0s 0e\"\nNon-match examples:\n- \"aw 0N 0W\"\n- \"12345\"",
        "matches": [
            "0N 0W",
            "34N 118W",
            "0s 0e",
            "42n 73w",
            "90S 180E",
            "1n 1w",
            "60S 45E",
            "23n 56w",
            "75s 30e",
            "80N 90W",
            "45s 0e",
            "12n 34w",
            "50S 100E"
        ],
        "non_matches": [
            "aw 0N 0W",
            "12345",
            "N45 W90r",
            "afdsaf.adijs",
            "45N 90E 180W",
            "12n 45w E",
            "60N 45E, 23S 56W",
            "North 12 West 34",
            "50S 100E 200W",
            "N15 E20",
            "sda sad",
            "32542"
        ],
        "id": 1466,
        "output": [
            {
                "text": "\n\nimport re\n\npattern = \"^0(N|S)(\\d+)[EW]$\"\n\ntest_cases = [\n    "
            },
            {
                "text": " The RegEx would look like this:\n\n^[\\d][\\d]*[/][\\d][\\d]*$\n\nExercise"
            },
            {
                "text": "\n\nimport re\n\nreg_expression = \"(\\d+)N ([-\\d+])W\"\n\ncoordinates_str = input(\"Enter"
            },
            {
                "text": " \n(\\(\\d+,\\d+\\))(\\s(\\d+,\\d+))\n\n\n\nQuestion 4: A car travels at a speed"
            },
            {
                "text": " The RegEx should be r'\\b\\d+N\\s+(\\d+W)\\b'\n\nIn conclusion, RegEx is a powerful"
            },
            {
                "text": " \"^(\\d{1,2}\\d{1,2})\\s(\\d{1,2}\\d{1,2})\\s(\\"
            },
            {
                "text": "\n(0N)|(0s)|(0e)|([0-9]{1})|([0-9]{1})([0"
            },
            {
                "text": " [a-zA-Z ]+(0[a-zA-Z0-9 ]+)\n\nExercise 2: Write a Python regex to"
            },
            {
                "text": " I use the \"\\d{3}N\\s\\d{3}W\" regular expression to match the latitude and longitude coordinates in the specified format."
            },
            {
                "text": " ^[-+]?\\d*\\.?\\d+[Ee] [+-]?\\d+$\n\nExercise 2: \n"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9])$",
        "raw_prompt": "Checks time in 24 hours notation, however this one is shorter than the ones I found on regexplib",
        "refined_prompt": "Checks time in 24 hours notation\nMatch examples:\n- \"23:00\"\n- \"12:21\"\n- \"0:00\"\nNon-match examples:\n- \"24:00\"\n- \"23:60\"",
        "matches": [
            "23:00",
            "12:21",
            "0:00",
            "07:21",
            "23:07",
            "4:53",
            "21:05",
            "8:33",
            "20:14",
            "23:53",
            "2:20",
            "20:42",
            "3:44"
        ],
        "non_matches": [
            "24:00",
            "23:60",
            "0:60",
            "-123",
            "234",
            "$23.454",
            "43-5432",
            "254627g.256",
            "000-000",
            "76:r4",
            "74:54",
            "86:34"
        ],
        "id": 1468,
        "output": [
            {
                "text": " (e)^[\\d :]{0,2}$\n- \"12:21\"Generate a RegEx for this description. \nAnswer: (e)^[\\d :]{0,2}(\\.\\d{1,2})$\n\nExercise"
            },
            {
                "text": " \\d\\s\\d\\s\\d:00\n\nExercise 2:\nMatch examples:\n- \"12:00 PM\"\n- \"12:00 AM\"\n- \"00:00\"\nNon-match examples:\n- \"12:00 AM\"\n- \"12"
            },
            {
                "text": "\n\nimport re\n\ndef time_match(string):\n    return re.match(\\d{2}:\\d{2})(\\d{2})(\\d{2})$\n\ndef time_non_match(string):\n    return re.match(\\d{2"
            },
            {
                "text": " [0-9]{2}:[0-9]{2}|[0-9]{2}:[0-9]\n- \"00:00\"Generate a RegEx for this description. \nAnswer: 00:\n- \"0:00\"Generate a Reg"
            },
            {
                "text": " ^[12][0-9]:[0-9][0-9]:[0-9][0-9]$\n\n2. Write a Python function that takes a list of time strings in 24-hour notation and returns a list of match examples, sorted in ascending order by the start time"
            },
            {
                "text": " ^([2-9]\\d|1[012]):[0-5]\\d$\n\n2. Match examples\n- \"123456789\"\n- \"1234-5678-9012-3456\"\n- \"123-4567-8901-345"
            },
            {
                "text": " (\\\\d{2}):(\\\\d{2})(?::(\\\\d{2}))?\"\n\nExercise 5:\nSolve the equation 2n + 1 = 11 for n.\nAnswer: n = 4\n\n\n\nI. The Historical Foundation of Company-Education"
            },
            {
                "text": " (0[0-9])\n\n- \"11:11:10\"\n- \"11:11:11\"\n- \"11:11:12\"\n- \"11:11:13\"Non-match examples:\n- \"11:11:13.13\"\n- \""
            },
            {
                "text": " \nAfter the colon, match any number of occurrences of a 0-9.\n\nExercise 2: Matches email addresses and phone numbers \n1. [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\"
            },
            {
                "text": " (`^\\d{1,2}:\\d{1,2}$`)\n2. Check if the following email addresses are valid\nMatch examples:\n- \"john.doe@gmail.com\"\n- \"jane@yahoo.co.uk\"\nNon-match"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]{1}/[0-3]?[0-9]{1}/20[0-9]{2})$",
        "raw_prompt": "This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year. :) I designed this expression to validate dates from the year 2000 to 2099. I do not plan on this same code being in place in 2099, so I hope this is sufficient enough...",
        "refined_prompt": "This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year.\nMatch examples:\n- \"2/14/2001\"\n- \"12/29/2099\"\n- \"19/39/2000\"\nNon-match examples:\n- \"12/29/1999\"\n- \"20/40/2100\"",
        "matches": [
            "2/14/2001",
            "12/29/2099",
            "19/39/2000",
            "4/5/2089",
            "8/27/2010",
            "11/7/2058",
            "6/12/2084",
            "13/24/2016",
            "7/18/2077",
            "6/5/2055",
            "16/03/2054",
            "2/14/2082",
            "03/2/2096"
        ],
        "non_matches": [
            "12/29/1999",
            "20/40/2100",
            "2534/52435234/2453",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "897-",
            "34.31",
            "3409fjg43"
        ],
        "id": 1484,
        "output": [
            {
                "text": " \""
            },
            {
                "text": " \\"
            },
            {
                "text": " \\"
            },
            {
                "text": "\n"
            },
            {
                "text": " https"
            },
            {
                "text": " "
            },
            {
                "text": " \\"
            },
            {
                "text": " ["
            },
            {
                "text": " ("
            },
            {
                "text": " "
            }
        ]
    },
    {
        "expression": "^\\d+\\*\\d+\\*\\d+$",
        "raw_prompt": "one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks.",
        "refined_prompt": "one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks.\nMatch examples:\n- \"123*4578*8908650\"\n- \"14*523*154\"\n- \"14*4*5432\"\nNon-match examples:\n- \"12a*99989*9096\"\n- \"52/2/5*4/82*45\"",
        "matches": [
            "123*4578*8908650",
            "14*523*154",
            "14*4*5432",
            "1*523*5432",
            "641*523*5432",
            "14*523*6544",
            "14*4351*5432",
            "14*3416*5432",
            "1463136*523*5432",
            "14*523*416",
            "8766*523*5432",
            "14*654*5432",
            "14*523*2346"
        ],
        "non_matches": [
            "12a*99989*9096",
            "52/2/5*4/82*45",
            "2534/52*4835234*/2453",
            "(12) 3*248 6*53210",
            "23*4/8423/5*243",
            "3n8*f@*",
            "43*-58432*",
            "2*54627g.2*68",
            "245/52*4/12",
            "354/*243/542",
            "(0xx12) 62*509@",
            "34*09fjg43"
        ],
        "id": 1485,
        "output": [
            {
                "text": " [0-9]{2,}[a-zA-Z"
            },
            {
                "text": " \n\n(\\d+|[a-zA-Z]*"
            },
            {
                "text": " [A-Z0-9]([*])([0-9"
            },
            {
                "text": "\n[1-9]\\d{0,2}[-/"
            },
            {
                "text": " \n\n^[1-9][0-9]*$|"
            },
            {
                "text": " \nThe pattern should match any sequence of characters except for one of the following"
            },
            {
                "text": "\n\"^[0-9]+(\\*[0-9]"
            },
            {
                "text": " [0-9][0-9]*[a-zA-"
            },
            {
                "text": " (.*)\\/(.*?)(.*?)(.*?)(.*)("
            },
            {
                "text": " \n\n```Python\nimport re\ntext = \"12a*"
            }
        ]
    },
    {
        "expression": "^100(\\.0{0,2}?)?$|^\\d{0,2}(\\.\\d{0,2})?$",
        "raw_prompt": "Matches percentages from 0-100 inclusive with two decimal places.",
        "refined_prompt": "Matches percentages from 0-100 inclusive with two decimal places.\nMatch examples:\n- \"0\"\n- \"100\"\n- \"100.00\"\nNon-match examples:\n- \"101\"\n- \"-5\"",
        "matches": [
            "0",
            "100",
            "100.00",
            "45.45",
            "74",
            "86",
            "85",
            "35.35",
            "99",
            "65",
            "66.66",
            "44.46",
            "83.73"
        ],
        "non_matches": [
            "101",
            "-5",
            "45.456",
            "-123",
            "51:534",
            "$23.454",
            "43-5432",
            "1.12423",
            "9516-9516",
            "354/243/542",
            "34.3125",
            "32542"
        ],
        "id": 1489,
        "output": [
            {
                "text": "\n[0-9]{0,1}[.][0-9]{1}\n\nCongratulations! You now have a basic understanding of regex and how it can be used to match patterns in strings. Keep practicing and experimenting with regex, and soon you'll be able to use it in real-world"
            },
            {
                "text": " Match examples:.*\\d{0,2}(?:\\.\\d{2})?(?:\\.\\d{2})?.* \nNon-match examples:.*[^0-9]\n\nExercise 2: \nMatch examples to their place values.\nMatch"
            },
            {
                "text": " ^(?:\\d{0,2})(?:\\.\\d{2})?%$\n\n- \"10%\"\n- \"10.00%\"\n- \"10.00%\"\n- \"101\"Generate a RegEx for this description.\nAnswer: ^(?:\\d"
            },
            {
                "text": " ^[0-9]*(?:\\.[0-9]{1,2})?%\n\nLecture Note: 15.3.6 How to Use the re.VERBOSE and re.DOTALL Flag to Modify the Regex Syntax\n\nIn this subsection,"
            },
            {
                "text": " The pattern should be \"(?<![\\d.])([0-9]*\\.[0-9]{1,2}|[0-9]{1,3})%[0-9]{2}(?![\\d.])\"\n- \"0\"\n- \""
            },
            {
                "text": " ^\\d*[1-9]\\d*\\.\\d+$\n\nExercise 3: Find all the instances where there is a percentage in a string and replace it with zero or a blank space.\nFind all the instances where there is a percentage in a string and replace it with zero or a"
            },
            {
                "text": " \n\\d*\\.[0-9]{2}\\b\nExercise 5: \nGenerate a RegEx for this description. \nMatch examples:\n- \"0\"\n- \"1\"\n- \"11\"\nNon-match examples:\n- \"101\"\n- \"-"
            },
            {
                "text": "\n\nimport re\n\n# Match an integer with two decimal places\nmatch = re.match(\"^\\d+\\.\\d{2}$\", \"100.00\")\nprint(match.group())\n\n# Match an integer less than 100\nmatch = re.match(\"^\\d{"
            },
            {
                "text": " ^([0-9]{1,2}\\.[0-9]+)?(,|$)$\n\n**Exercise 5:** Generate a RegEx pattern that matches numbers with two decimal places.\nAnswer: ^.+[0-9]{1,2}\\.?[0"
            },
            {
                "text": " [0-9]+\\.?[0-9]\\%|-5\\.[0-9]?\n\n4. Combine two percentages with a percent symbol to generate a new percentage using regex.\nMatch examples:\n- \"50%\"\n- \"75%\"\nNon-match examples:\n-"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))\\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))\\/(\\d{4})$",
        "raw_prompt": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long.\nMatch examples:\n- \"12/25/2007\"\n- \"11/07/1517\"\n- \"02/25/2727\"\nNon-match examples:\n- \"1/27/1977\"\n- \"00/01/000\"",
        "matches": [
            "12/25/2007",
            "11/07/1517",
            "02/25/2727",
            "01/31/1026",
            "01/02/1770",
            "12/30/5833",
            "12/09/6504",
            "07/18/0292",
            "11/31/7444",
            "05/09/9524",
            "09/31/6773",
            "12/28/5047",
            "11/30/1576"
        ],
        "non_matches": [
            "1/27/1977",
            "00/01/000",
            "15/07/2002",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "9/9/9",
            "3409fjg43"
        ],
        "id": 1492,
        "output": [
            {
                "text": " The regular expression should be (0[1-9])/([1-2][0-"
            },
            {
                "text": "\n(0|[1-9][0-9])\\/([0-9][0"
            },
            {
                "text": " \\d{1,2}\\/\\d{1,2}\\/\\d{4"
            },
            {
                "text": "\n([0-9]{1,2})(\\/)([0-9]{"
            },
            {
                "text": " \\d/\\d/\\d{4} \n\nExercise 3:\nWrite"
            },
            {
                "text": " [0-9]{4}\\.[0-9]{2}\\.[0-9"
            },
            {
                "text": " ^([1-9]{1,2})/([1-9]{1,"
            },
            {
                "text": " \"^[1-9]\\d{3}/\\d{2}/\\"
            },
            {
                "text": " \"^(01|02|03|04|05|06|07|08|09"
            },
            {
                "text": " (?<month>\\d{1,2})|(?<day>\\d"
            }
        ]
    },
    {
        "expression": "[0-9]{4}-([0][0-9]|[1][0-2])-([0][0-9]|[1][0-9]|[2][0-9]|[3][0-1])",
        "raw_prompt": "This function does basic testing for the YYYY-MM-DD date format.",
        "refined_prompt": "This function does basic testing for the YYYY-MM-DD date format.\nMatch examples:\n- \"1981-10-16\"\n- \"6401-04-30\"\n- \"3202-11-05\"\nNon-match examples:\n- \"1981-13-10\"\n- \"52/2/-54/2-45\"",
        "matches": [
            "1981-10-16",
            "6401-04-30",
            "3202-11-05",
            "7024-05-13",
            "2690-11-05",
            "6492-12-11",
            "6280-10-10",
            "4225-09-25",
            "5745-11-17",
            "0117-08-21",
            "6780-10-31",
            "0337-07-31",
            "2116-12-08"
        ],
        "non_matches": [
            "1981-13-10",
            "52/2/-54/2-45",
            "2534/5243-5234/2-453",
            "(12) 32-4 653210",
            "234/423/5-243",
            "$2-3.454",
            "43-5-432",
            "2546-27g.256",
            "245/52-4/12",
            "354/2-43/542",
            "(0xx12-) 62509@",
            "++6345-3.345"
        ],
        "id": 1495,
        "output": [
            {
                "text": "\nimport re\n\ndef test_date_format (format_string):\n    # The regex returns true if the input string represents a YYYY-MM-DD date"
            },
            {
                "text": " [A-Z]{1,4}\\-?[0-9]{2}\\-?[0-9]{2} (\\d{4}-"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{2}\n\n2. Use the Python string method \"find()\" to locate all occurrences of the subst"
            },
            {
                "text": "\n(?:(?<year>\\d{4}\\-\\d{2}\\-\\d{2})|(?<month>\\d{2}\\-"
            },
            {
                "text": "\n[0-9]{4}-?[0-9]{2}-?[0-9]{2}-?[0-9]{"
            },
            {
                "text": "\n\ndef test_date_format(self, test_date, expected_format):\n    regex = re.compile(expected_format)\n    self."
            },
            {
                "text": " \n[0-9][0-9]|[1-9][0-9]|[1-9][1-9]|[1-9]["
            },
            {
                "text": " [^-/0123456789]{1,2}[\\/\\-]{1}[0123456789]{3}\n\nExercise 3"
            },
            {
                "text": " (\\d{4})-(\\d{2})-(\\d{2}) (\\d{2})T(\\d{2}):\\d{2} (\\"
            },
            {
                "text": "\n([0-9]{4})-([0-9]{2})-([0-9]{2})\n\n# Exercise 3 Solution\n\nimport re"
            }
        ]
    },
    {
        "expression": "^(((19|20)(([0][48])|([2468][048])|([13579][26]))|2000)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-9]))|((19|20)(([02468][1235679])|([13579][01345789]))|1900)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-8])))$",
        "raw_prompt": "This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed. You could easily change it to accept other separators. It has been tested with Regex Coach and PHP.",
        "refined_prompt": "This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed.\nMatch examples:\n- \"1900-01-01\"\n- \"2099-12-31\"\n- \"2004-02-29\"\nNon-match examples:\n- \"20060526\"\n- \"1900-02-29\"",
        "matches": [
            "1900-01-01",
            "2099-12-31",
            "2004-02-29",
            "1900-11-25",
            "2000-11-30",
            "1909-12-28",
            "2000-06-30",
            "2007-09-30",
            "2089-11-20",
            "2000-04-11",
            "1900-12-31",
            "1900-12-24",
            "2052-12-30"
        ],
        "non_matches": [
            "20060526",
            "1900-02-29",
            "2100-01-01",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "++63453.345"
        ],
        "id": 1512,
        "output": [
            {
                "text": " \n^(0[1"
            },
            {
                "text": "\n(?<year>\\"
            },
            {
                "text": " \\d{4}-\\"
            },
            {
                "text": "\n\n(?<!\\"
            },
            {
                "text": "\n^(19|20)\\"
            },
            {
                "text": " (?<year>\\d"
            },
            {
                "text": "  \\d{4}-"
            },
            {
                "text": " \nimport re, sys\n"
            },
            {
                "text": "\n^[0-9]"
            },
            {
                "text": " (.*)  - Match any"
            }
        ]
    },
    {
        "expression": "^(-?)(((\\d{1,3})(,\\d{3})*)|(\\d+))(\\.\\d{1,2})?$",
        "raw_prompt": "This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative.",
        "refined_prompt": "This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative.\nMatch examples:\n- \"100,000,000.00\"\n- \"-100,000,000.00\"\n- \"100,000,000\"\nNon-match examples:\n- \"100,000,00.00\"\n- \"1000.000\"",
        "matches": [
            "100,000,000.00",
            "-100,000,000.00",
            "100,000,000",
            "-100,000,000",
            "100000000.00",
            "-100000000.00",
            "100000000",
            "-100000000",
            "1534",
            "4352",
            "635",
            "87436",
            "243"
        ],
        "non_matches": [
            "100,000,00.00",
            "1000.000",
            "1000.",
            "(12) 324 653210",
            "234/423/5243",
            "$23.454",
            "43-5432",
            "254627g.256",
            "245/524/12",
            "354/243/542",
            "(0xx12) 62509@",
            "3409fjg43"
        ],
        "id": 1515,
        "output": [
            {
                "text": " - (negative value) or 100 (positive value)\\.\\d{1,3}"
            },
            {
                "text": " (\\d{1,2}|(\\d\\.){0,2}|"
            },
            {
                "text": " \\d+\\.\\d{0,2}$\n\n3. Given the following"
            },
            {
                "text": "\n(?:\\d+(?:\\.\\d+)?|[-\\d.]"
            },
            {
                "text": " ([0-9])(\\.)([0-9]{1,2})\n"
            },
            {
                "text": " (\\d{1,3},\\d{3}(?:,\\d{"
            },
            {
                "text": " \n\nimport re\n\n# Define the input string\ninput_string = \""
            },
            {
                "text": " (?<!\\d)(\\d\\.){1,2}(\\d\\"
            },
            {
                "text": " \n(^|,)[0-9]{1,2}[,.]"
            },
            {
                "text": " ^[\\+\\-]?\\d+\\,?\\d*\\.\\d"
            }
        ]
    },
    {
        "expression": "^1?[1-2]$|^[1-9]$|^[1]0$",
        "raw_prompt": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).",
        "refined_prompt": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12).\nMatch examples:\n- \"1\"\n- \"6\"\n- \"12\"\nNon-match examples:\n- \"-1\"\n- \"0\"",
        "matches": [
            "1",
            "6",
            "12",
            "2",
            "3",
            "4",
            "5",
            "7",
            "8",
            "9",
            "10",
            "11"
        ],
        "non_matches": [
            "-1",
            "0",
            "13",
            "4312",
            "45",
            "65",
            "6f",
            "567",
            "7654",
            "2c",
            "5647",
            "43c"
        ],
        "id": 1520,
        "output": [
            {
                "text": "\n/^(0|1|2|3|4|5|6|7|8|9|10|11|12)$/\nHere you could also play with lookarounds to avoid matching for example \"10\" since there"
            },
            {
                "text": " [0-9][1-9][0-9]-[0-9]\\d{3}\n\nA:\n\nOne way to do it is using a lookahead assertion: \n^(?=(?:0|[1"
            },
            {
                "text": " [1-9]\\d\n\n3. Write a RegEx for words that start with \"R\" and end with \"y\" or \"z\".\nAnswer: r[a-z]+\n\n4. Write a RegEx for strings"
            },
            {
                "text": " [0-9][0-9]\n- \"12\"Generate a RegEx for this description. \nAnswer: (0[1-9]|[12][0-9]|3[0-1])\n\nWhat"
            },
            {
                "text": "\n([1-9]|1\\d?|2[0-3])\n\nWhat does the RegEx ^([1-9]|1\\d?|2[0-3])$ mean?\n(1) [1"
            },
            {
                "text": " [0-9][0-9]|1[0-9]\n\n**2.5.5.2: The ^, $, [] and * characters**\n\nA RegEx character can be a special character that matches itself or"
            },
            {
                "text": " [1-9][0-9]|[12]\nThe pattern for this regex is also [1-9][0-9]|[12]. This pattern covers cases of digits 1 through 9, followed by a digit 0 through 9,"
            },
            {
                "text": " \\b[1-9][0-9]\\b\n\n3. How do you write a pattern that matches the word \"cat\" but not \"cot\"?\nAnswer: \n\n\\b\\w*cat\\w*\\b"
            },
            {
                "text": " One or more digits between 1 and 12 inclusive, positive numbers only.\n\n3. Describe the function of a RegEx. \nAnswer: The function of a RegEx is to match patterns in text. These patterns can be used to find and"
            },
            {
                "text": " \"^[1-9]|[0-2][0-9]$\"\n\n5. Create a RegEx that matches the following text:\n\"Some text with a word: word, word,..., word word word\"\n"
            }
        ]
    },
    {
        "expression": "^N[1-9][0-9]{0,4}$|^N[1-9][0-9]{0,3}[A-Z]$|^N[1-9][0-9]{0,2}[A-Z]{2}$",
        "raw_prompt": "FAA Tail Numbers as described here: http://www.faa.gov/licenses_certificates/aircraft_certification/aircraft_registry/special_nnumbers/",
        "refined_prompt": "FAA Tail Numbers\nMatch examples:\n- \"N12345\"\n- \"N52T\"\n- \"N84WE\"\nNon-match examples:\n- \"N123456\"\n- \"Nh9if23\"",
        "matches": [
            "N12345",
            "N52T",
            "N84WE",
            "N68",
            "N423A",
            "N6NY",
            "N2242",
            "N28KJ",
            "N35",
            "N30C",
            "N4193",
            "N2CA",
            "N19NM"
        ],
        "non_matches": [
            "N123456",
            "Nh9if23",
            "N34f2vf42e",
            "N12/123/4322",
            "N123.456.789",
            "N123.456.7890",
            "N56.153153",
            "N/5/5/20022",
            "N432/524/2435",
            "Nadfa2",
            "N(0xx12) 62509",
            "N12/132/90"
        ],
        "id": 1539,
        "output": [
            {
                "text": "\n- \"N[a-zA-Z0-9]{3}[0-9]{4}[0-9]{3}\"\n- \"N[a-zA-Z]{2}[0-9]{3}[0-9]{3"
            },
            {
                "text": " [^0-9]*[0-9][0-9][0-9][0-9]*[^0-9]* \n\n\n5. Validating User Input using RegEx \nQuestion: Write a Python code that validates an email address using RegEx.\nTh"
            },
            {
                "text": " N[a-z]+[0-9]+ [a-zA-Z0-9 ]+\n\nExercise 4:\nMatch examples:\n- \"N12345\"\n- \"N52T\"\n- \"N84WE\"\nNon-match examples:\n- \"N"
            },
            {
                "text": " ^[0-9][0-9][0-9][0-9][0-9][A-Za-z0-9-]+$\n\n3. Create a RegEx pattern that will match US zip codes in the format of \"(XXX) XXX-XXXX\".\nAnswer: ^"
            },
            {
                "text": " \"^[0-9]{4}(.*)$\"\n\nExample 4:\nSara is a researcher at a medical lab. She is tasked with creating a regular expression to match email addresses. The email addresses she needs to match are the ones that can contain the following special characters:.,"
            },
            {
                "text": " (.*?)(\\d\\d\\d)(.*?)\\s*$\n\nExercise 5:\nCreate a RegEx to match the following email formats.\n- \"example@example.com\"\n- \"example@example.net\"\n- \"example@example.org\"\n-"
            },
            {
                "text": " \"^N[0-9]+$\"\n\n#### Exercise 3\n\nWrite a Python program that takes a filename as an input and generates a list of all of the tail numbers in the file.\n\nHint: Read the file line by line, use a loop to extract tail numbers, and append"
            },
            {
                "text": " \n[a-zA-Z]{1}[0-9]{6}\n\nExercise 5: \nMatch examples: \n- \"1234\"\n- \"12.34\"\n- \"12.34,56\"\nNon-match examples:\n- \""
            },
            {
                "text": "\n- \"N[1-9][0-9]{3}(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])\"\nExercise 2:\n- \"N1234-5678\"Generate a RegEx"
            },
            {
                "text": " \"N[0-9]{4}T[0-9]{2}E[0-9]{3}F[0-9]{2}\"\n\n\n\nTitle: Understanding the Importance of Measurement Accuracy and Precision\n\nIntroduction:\nHave you ever wondered about the"
            }
        ]
    },
    {
        "expression": "\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?",
        "raw_prompt": "Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address.",
        "refined_prompt": "Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address.\nMatch examples:\n- \"192.168.1.19\"\n- \"6.3.948.89\"\n- \"28.38.1.25\"\nNon-match examples:\n- \"19x.168.1.19\"\n- \"f34fvfv\"",
        "matches": [
            "192.168.1.19",
            "6.3.948.89",
            "28.38.1.25",
            "4.6.75.1",
            "3.11.38.1",
            "2.62.64.19",
            "11.186.9.74",
            "167.0.2.095",
            "1.18.615.26",
            "7.502.83.9",
            "10.890.4.90",
            "5.62.836.51",
            "72.62.38.143"
        ],
        "non_matches": [
            "19x.168.1.19",
            "f34fvfv",
            "34f2vf42e",
            "12/123/4322",
            "2346-2345-2435",
            "43.v234",
            "@#dfkjnav",
            "/5/5/20022",
            "432/524/2435",
            "341.431v4f3.fv1",
            "(0xx12) 62509",
            "12/132/90"
        ],
        "id": 1549,
        "output": [
            {
                "text": " f34fvfv\\.([0-9]{1,3}\\.){3}[0-9]{"
            },
            {
                "text": " \"(?P<ipv4>[0-9]|[1-9][0-9]|1[0-9"
            },
            {
                "text": " \\d\\d.\\d\\d.\\d\\d\n- \"6.2.3.12,8.0"
            },
            {
                "text": " /(^(?:(?:.*?\\.)){3}\\d{1,3}(?:\\.\\d{1"
            },
            {
                "text": " \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1"
            },
            {
                "text": " a-z0-9\\.\\d\\.\\d\\.[a-z0-9]+/\n\n3. Write a"
            },
            {
                "text": " \"190[0-9]{1,3}\\.168[0-9]{1,3}\\.168[0"
            },
            {
                "text": " \"^(([0-9]{1,3}\\.){3}[0-9]{1,3})$"
            },
            {
                "text": "\n[0-9]\\d{1,3}\\.[0-9]\\d{1,3}\\.[0-"
            },
            {
                "text": " A RegExp that matches the above examples is \\d{1,3}\\.\\d{1,3}\\.\\d{"
            }
        ]
    },
    {
        "expression": "^\\d*[0-9](\\.\\d?[0-9])?$",
        "raw_prompt": "Allow Decimal values as [decimal](*, 2), scale length between 0 and 2",
        "refined_prompt": "Allow Decimal values as [decimal](*, 2), scale length between 0 and 2\nMatch examples:\n- \"87645.09\"\n- \"87645.9\"\n- \"87645.10\"\nNon-match examples:\n- \"87645.091\"\n- \"87645.\"",
        "matches": [
            "87645.09",
            "87645.9",
            "87645.10",
            "87645",
            "777698353094752880760794069684108698341032758279235997847364392067648258518127050.5",
            "6077107689090387339015186298602908029420195008990703295970503721211509552189837978",
            "62534419400374094193",
            "7847110062233216866380559814689829460556814730990738759420596.7",
            "6388755307341136274141229227906518971513195109976980738120192063260.5",
            "920273193897792617989888255137588685406964083175.0",
            "8421404992436294109084605391115890355156252405827714599269051017476507953982066470036296406989",
            "40.4",
            "2661675356454810967369157361635808125799434042000783742662896962"
        ],
        "non_matches": [
            "87645.091",
            "87645.",
            "werfvd",
            "3er4t5grevds",
            "ddwe4rt5y67u6y54",
            "#333",
            "$567",
            "5643%",
            "number",
            ".0",
            "3r4efd",
            "2343ss"
        ],
        "id": 1566,
        "output": [
            {
                "text": " A RegEx should match the string \"87645.09\", with a decimal value ranging between 0 and 2.\n\nExercise 2: Create a RegEx that matches the following patterns:\n\n-"
            },
            {
                "text": "\n(?=\\d\\.)\\d\\d(\\.\\d{1,2})?\n\nExercise 4:\n\n- [Example](*, 1)\n- [Example](*,"
            },
            {
                "text": " \"^\\d+\\.\\d*$\"\n\n4. Convert the following regular expression into a Python function that returns true if the string matches the regular expression.\n`r'\\d+(\\."
            },
            {
                "text": "\n\nimport re\n\n# Non-match examples\nre.match(\"^\\d+\\.\\d+$\", \"87645.091\")\n\n# Match example\nre.match"
            },
            {
                "text": " This describes a floating-point number with up to two decimal places. It is usually written as a dollar sign before the number, followed by a comma and then the decimal values.\n\n\n\nQuestion 5:"
            },
            {
                "text": " \"^[a-zA-Z]\\d{3}\\.(\\d{2})(\\d{3})(\\d{3})(\\d{3})(\\d{"
            },
            {
                "text": " \"87645[0-9]{1,2}\\.09\"  \n\n#### Exercise 2:\n- Create a string that will contain the value \"100000.05\". If this value"
            },
            {
                "text": " \"^[0-9]{4}.[0-9]{2}$\"\nExercise 4:\nWrite a Python function that takes a list of strings and returns a new list containing only"
            },
            {
                "text": " [.09]{5}\n\n3. Create a RegEx that matches any string that starts with 'A' and is followed by any number of digits, capital letters, and/or periods. "
            },
            {
                "text": " \\d+\\.\\d+|\\d+\\s*(?:\\.\\d+)\n- \"87645.9\" \n- \"87645.10\" \n-"
            }
        ]
    },
    {
        "expression": "^((\\d{0,1}[0-9](\\.\\d{0,1}[0-9])?)|(100))$",
        "raw_prompt": "Allow Percentage with optional scale (max length of 2) between (00.00 and 100)",
        "refined_prompt": "Captures percentage with 0-2 decimal points (00.00 - 100).\nMatch examples:\n- \"00.00\"\n- \"00\"\n- \"99.99\"\nNon-match examples:\n- \"99.\"\n- \"100.1\"",
        "matches": [
            "00.00",
            "00",
            "99.99",
            "99.5",
            "100",
            "1",
            "12.0",
            "0.5",
            "0.75",
            "0.20",
            "0.01",
            "00.99",
            "00.15"
        ],
        "non_matches": [
            "99.",
            "100.1",
            "0.",
            ".0",
            "101",
            "-1",
            "+4",
            "5%",
            "00.003",
            "3.1415",
            "555.555",
            "1000"
        ],
        "id": 1567,
        "output": [
            {
                "text": " ([0-9]|[1-9][0-9])%\n(Note: The percent symbol % is the same as the '%' symbol in JavaScript. The regex engine doesn't support percent symbols; it's just a shorthand character for 'percent.\n\nSolution"
            },
            {
                "text": " ^[0-9]{2,2}(\\\\.[0-9]{1,2})?\n\n2. Write a Pattern that will match any word character that is not a period, comma, or apostrophe.\nAnswer: [^.,'']\n"
            },
            {
                "text": " \"00.[0-9]+([1-9][0-9]|10)\"\n\n2. Generate a RegEx to identify words starting with 'b' or 'B'.\n\nExample:\n\"bond, bonds, bonds, bank, bank\"\n"
            },
            {
                "text": " [0-9][0-9][0-9].00%\n\n5. Use the RegEx module to get the percentage of matches from the following list of strings. \nList of strings:\n- \"01.00\"\n- \"00\"\n- \""
            },
            {
                "text": " \"[0-9]{0,2}\\.?[0-9]{0,2}|0\\.[0-9]{0,2}|1\\.[0-9]{0,2}|100[0-9]{0,"
            },
            {
                "text": " [^\\d.\\d\\d]\n\n3. Use a RegEx to find all words from a string that contain the letter 'a' that are at least 3 characters long. \nExample input: \"The apple tree is tall.\"\nExample output: \"apple"
            },
            {
                "text": " /^(?=(\\d{2})+(\\d{2})+(?:\\.\\d{2})?)(\\d{2})(\\d{2})?$/i\n\n## 3. String Formatting\n- String formatting is used to insert"
            },
            {
                "text": "\n^[0-9]{1,2}.00$\n\n5. Match examples:\n- \"1.00\"\n- \"99.99\"\n- \"100.1\"\n- \"99.999\"\nNon-match examples:\n- \""
            },
            {
                "text": "\n[0-9]{1,2}\\.[0-9]{1,2}\n\nLecture Note: Subsection 5.1.4 - The match and search methods\n\nContents:\n- The match method\n- The search method\n\n"
            },
            {
                "text": " ^[0-9]{{0,2}}\\.[0-9]{{0,2}}$|^[0-9]{{0,2}}\\.[0-9]{{0,2}}\\.[0-9]{{0,2}}\\"
            }
        ]
    },
    {
        "expression": "^([0-9]{4})-([0-1][0-9])-([0-3][0-9])\\s([0-1][0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "raw_prompt": "SQL datetime format tester YYYY-MM-DD HH:MM:SS",
        "refined_prompt": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"",
        "matches": [
            "2007-07-01 01:01:01",
            "2007-08-04 18:01:01",
            "2003-01-26 09:26:01",
            "0000-00-00 00:00:00",
            "9999-19-23 00:00:00",
            "9009-06-23 23:00:00",
            "1111-19-35 23:59:59",
            "0000-00-00 00:00:01",
            "0405-06-07 08:09:10",
            "0788-14-39 22:23:49",
            "0334-15-35 10:56:07",
            "0420-05-05 20:15:07",
            "9599-15-28 22:16:29"
        ],
        "non_matches": [
            "2007-07-01",
            "2007/07/01",
            "2007-08-04 24:00:00",
            "2007/07/01 12:12",
            "23/4/26",
            "8/1/03",
            "24:00:33",
            "23-01 12:12",
            "11:11",
            "9-21 00:00",
            "2023/08/03 12:34",
            "22:16:29 0420-05-05"
        ],
        "id": 1570,
        "output": [
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a date"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a range"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a regular"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a SQL"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a list"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a value"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a SQL"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a non"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a valid"
            },
            {
                "text": "Structured query language (SQL) date and time format. In the format: YYYY-MM-DD HH:MM:SS (YEAR-MONTH-DAY HOUR-MINUTE-SECOND). Accepts some logically invalid months and date configurations.\nMatch examples:\n- \"2007-07-01 01:01:01\"\n- \"2007-08-04 18:01:01\"\n- \"2003-01-26 09:26:01\"\nNon-match examples:\n- \"2007-07-01\"\n- \"2007/07/01\"Generate a date"
            }
        ]
    },
    {
        "expression": "(^[0][.]{1}[0-9]{0,}[1-9]+[0-9]{0,}$)|(^[1-9]+[0-9]{0,}[.]?[0-9]{0,}$)",
        "raw_prompt": "This pattern will match any positive number(Real or Integer). It will not match ZERO or any variation of zero (ie 0.00)",
        "refined_prompt": "This will capture any unsigned, positive number (real or integer), except any variation of 0 (0, 0.0, 00).\nMatch examples:\n- \"0.003\"\n- \"34\"\n- \"6.000\"\nNon-match examples:\n- \"0.0\"\n- \"-34\"",
        "matches": [
            "0.003",
            "34",
            "6.000",
            "7.3",
            "123456789",
            "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280",
            "0.5",
            "6.700000000000038854387",
            "0.30",
            "348739.2384729",
            "1.0000",
            "10000000000000",
            "99.99"
        ],
        "non_matches": [
            "0.0",
            "-34",
            "-23.00",
            "0",
            "-0.30",
            "+6",
            ".0",
            "00000.5",
            "0.",
            "-00.00",
            "+6.57",
            "0.000"
        ],
        "id": 1579,
        "output": [
            {
                "text": "  [0-9]*[0-9]\\.[0-9]*|[0-9]*([0-9]\\.[0-9])\n\nA:\n\nYou can use the"
            },
            {
                "text": "\n(?<![0-9])([+-]?)(?!\\.[0-9])(?!\\.[0-9].[0-9]\\.[0-9])(?!0)"
            },
            {
                "text": " [^0-9]\nThe RegEx below will create an array of all numbers:\n[[^0-9]]\nHere's an example\nvar input = [\n  \"0.00\",\n  \"34"
            },
            {
                "text": "\n^[1-9][0-9]?\\.[0-9]{1,2}$\n\nA:\n\nThis will match:\n[+-]?\\d+(?:\\.\\"
            },
            {
                "text": "\n\"(\\d+).*?\\.(\\d+)\"\n\nA:\n\nIt depends on what you mean by \"valid\". Do you want to allow a leading 0, or do you want to allow leading z"
            },
            {
                "text": " ^[0-9.]*$\n\nA:\n\nAnother way to look at it, in case you want to capture any real numbers, is to look at the first character of the string.\n^[0-"
            },
            {
                "text": " [^0-9.]\n\nExample 5: Generating Regular Expressions\n\nSuppose you are tasked with creating a regular expression that matches any email address in a given directory. Write the following code:\n\nimport re"
            },
            {
                "text": " [0-9]*[1-9][0-9]*|0+\n\nA:\n\nYou can use this pattern:\n^[+-][0-9.]+$\n\nThe ^"
            },
            {
                "text": " \n[0-9]+(\\.\\d+)?\n\nA:\n\nI would go with the regex that will catch the number and ignore the rest (the dot and the digits after it).\n\\d+"
            },
            {
                "text": "  (\\d+\\.\\d*)\n\nA:\n\nYou can use this regular expression :\n^(?<num>[0-9]+\\.[0-9]*)|(?<denom>[0"
            }
        ]
    },
    {
        "expression": "([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "raw_prompt": "This pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore.",
        "refined_prompt": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the . but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg.c\"\n- \"a@a.com\"",
        "matches": [
            "san_z@asg.com",
            "xy_z@123g.co.in",
            "san@ss.com.in",
            "asmith@nd.edu",
            "333_4@44.com",
            "john.doe@et.org",
            "billy_d37@uofa.gmail",
            "5555@555.555.org",
            "the@quick.brown.fox.jumped.over",
            "4@54.com",
            "54@ttttttt.com",
            "999999@999999.oo",
            "amazon.com@walmart.org"
        ],
        "non_matches": [
            "ssaa_s@asg.c",
            "a@a.com",
            "san@s.co.in",
            "san@apr.com.in.i",
            "5.5@5.org",
            "joan.anne@school.5",
            ".org",
            "@gmail.org",
            "jordan@55",
            "66.@path.com",
            "<hello>@college.org",
            "*&^%@row.edu"
        ],
        "id": 1585,
        "output": [
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@as."
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            },
            {
                "text": "The pattern recognizes an email address with the following rules: (1) underscores, periods, and numbers are allowed in usernames, (2) numbers are allowed in the domain name, but not the top-level domain name (before the. but not after),  (3) usernames can not start with an underscore or ampersand.\nMatch examples:\n- \"san_z@asg.com\"\n- \"xy_z@123g.co.in\"\n- \"san@ss.com.in\"\nNon-match examples:\n- \"ssaa_s@asg"
            }
        ]
    },
    {
        "expression": "\"[^\"]+\"",
        "raw_prompt": "Finds strings enclosed in double quotations",
        "refined_prompt": "Finds strings of characters enclosed in double quotations\nMatch examples:\n- \"\"MatchingText\"\"\n- \"\"enclosed\"\"\n- \"\"2023\"\"\nNon-match examples:\n- \"NonMatchingText\"\n- \"NoQuotes\"",
        "matches": [
            "\"MatchingText\"",
            "\"enclosed\"",
            "\"2023\"",
            "\"@gmail.com\"",
            "\" \"",
            "\" 1234\"",
            "\"\\n\"",
            "\"1234 E. Apple St.\"",
            "\"~\"",
            "\"[ ]\"",
            "\" @ \"",
            "\"HELLO!\"",
            "\"https://www.amazon.com/\""
        ],
        "non_matches": [
            "NonMatchingText",
            "NoQuotes",
            "\"NoEnding",
            "NoBeginning\"",
            "\"\"DoubleBeginning",
            "DoubleEnding\"\"",
            "'Apostrophe'",
            "'BeginningApostrophe",
            "EndingApostrophe'",
            "\"SwitchedBack'",
            "'SwitchedFront\"",
            "''DoubleApostrophe''"
        ],
        "id": 1587,
        "output": [
            {
                "text": " [^\"]+\n\nExercise 2:\nFinds all the number enclosed in double quotations\nGenerate a RegEx for this description.\nAnswer: \"?\\d+\"[^\"]+?\n\nExercise 3:\nFinds all the words starting and ending with double quotes\nGener"
            },
            {
                "text": " [^\"]*\n\nExercise 3:\nIn the following text, find the number of times the word \"dog\" appears.\n\n\"I love my dog. He is a loyal companion. My dog always greets me with a wagging tail.\"\n\nAnswer: 6\n\nExercise 4"
            },
            {
                "text": " Use '.*' to match any number of any character, and '\"|\"' to match a double quoted string.\n\n3. Write a RegEx for this string: \"Name of the person: John Doe\"\nAnswer: Use '.*' to match any number of any character, and match the"
            },
            {
                "text": " \"NoQuotes\" generates a RegEx for this description.  RegEx for this description is [^\"]+\n\"^[A-Z][a-z]+[A-Z][a-z0-9]+$\" - Matches strings that contain an uppercase letter, followed by"
            },
            {
                "text": " [^\"]+\nExercise 5:\nFinds strings of characters enclosed in quotes that are not inside quotes.\nMatch examples:\n- \"\"MatchingText\"\"\n- \"\"enclosed\"\"\n- \"\"2023\"\"\nNon-match examples:\n- \"NonMatchingText\"\n-"
            },
            {
                "text": " ((?<=\\s*\")|(?=\\s*))\n\n[Host 1]: And finally for the last quiz, Quiz 5.\n\nQuiz 5: Using the same text as before, write a RegEx that matches non-alphanumeric characters only.\nSolution:"
            },
            {
                "text": " \\\"([^\"]+)\\\".*\\1\"\n\n**Exercise 3: Text Cleanup**\n\nCreate a routine to remove all unnecessary whitespace from a string (including spaces, tabs, newlines, and other forms of whitespace) and split the string into individual words.\n\n"
            },
            {
                "text": "  [^\\\"]*\n\n2. Write a function that will take an array of words and produce a regular expression to check if any of the words are valid. In other words, the function will accept a string variable, and will return a match object based on whether or not any of the strings match"
            },
            {
                "text": "\n'''\nimport re\n\ndef non_match_generator(description):\n    return r'^(\"+re.escape(description)+\")$'\n\ndescription = \"''\" + non_match_generator(\"'''\") + \"'''+\"NonMatchingText"
            },
            {
                "text": " r\"^.*\\\".*\\\".*$\"\n2. Match a string where the first character is a lowercase letter, the second is an uppercase letter, and the third is a digit.\nAnswer: r\"[a-z][A-Z][0-9]\"\n3. Match"
            }
        ]
    },
    {
        "expression": "(15(8[48]|9[26]))|((1[6-9]|[2-9]\\d)(0[48]|[13579][26]|[2468][048]))|(([2468][048]|16|3579[26])00)",
        "raw_prompt": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996, so no worries with the y3k bug.",
        "refined_prompt": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996.\nMatch examples:\n- \"1584\"\n- \"2000\"\n- \"2048\"\nNon-match examples:\n- \"1200\"\n- \"1580\"",
        "matches": [
            "1584",
            "2000",
            "2048",
            "1588",
            "7256",
            "1592",
            "8396",
            "1864",
            "1600",
            "6000",
            "7408",
            "2400",
            "8000"
        ],
        "non_matches": [
            "1200",
            "1580",
            "1941",
            "1800",
            "1004",
            "001",
            "45",
            "1408",
            "1068",
            "1128",
            "1324",
            "1276"
        ],
        "id": 1588,
        "output": [
            {
                "text": " A four-digit year that can be divisible by 400, except for years ending in 00 (e.g., 2000, 2100, 2200).\n\n### Exercise 2: Email Validation\n\nEmail validation is another"
            },
            {
                "text": " [1-2][0-9]999[0-9]\n\nExercise 2: Match this description to the correct RegEx pattern.\nDescription\n1) This pattern matches a word beginning with \"a\""
            },
            {
                "text": " \"\\d{4}-\\d{2}-\\d{2}\"\n\nExercise 3: \nIdentify the issue with the following RegEx statement.\nStatement: \"^(a|b)"
            },
            {
                "text": "\nThe correct regex is: \\d{4} (16|17|18|20|24|27|29|30|32|34|36|38|39|40|42|43|44|"
            },
            {
                "text": " A four-digit number that is divisible by 8 and not divisible by 9.\n\n[Exercise 2]\nDesign a RegEx to match the following words:\n- Cat, Cat, Dog, Cat,"
            },
            {
                "text": "\n\\d{4}(-[1-9]\\d?)?\\d{3}(-[1-9]\\d?)?\n\nI hope this section has helped you understand how RegEx can be"
            },
            {
                "text": " Allow the user to input a sentence, then use the RegEx pattern (\\d{4})\\d\\d-\\d\\d-\\d\\d to match any four-digit year that ends in \"-\""
            },
            {
                "text": " Valid years are in the range of 1500 to 4999.\n\nExercise 2: \nMatch examples: \n- \"1913\"\n- \"1921\"\n- \"1926\"\n- \"19"
            },
            {
                "text": " (r\"\\d{4}(?:00)?(\\d\\d?)?(?:00)?(\\d\\d?)?(?:00)?(\\d\\d?)?\")\n- \"1020\"Gener"
            },
            {
                "text": " Year ends with 1 or 0 or more odd digits and is divisible by 4.\n\nExercise 3:\nCreate a RegEx for a phone number that is valid for the iPhone and Android platforms. The phone number must"
            }
        ]
    },
    {
        "expression": "^[-+]?\\d+(\\.\\d{2})?$",
        "raw_prompt": "It accepts only two integer after a decimal point. The number may be in Positive or negative.",
        "refined_prompt": "Accepts positive or negative integer values. If there is a decimal point, there must be exactly two decimal places given.\nMatch examples:\n- \"+1212.14\"\n- \"-12.13\"\n- \"122.45\"\nNon-match examples:\n- \"1212.4564\"\n- \"-11.5858\"",
        "matches": [
            "+1212.14",
            "-12.13",
            "122.45",
            "-0.44",
            "+0000444444.44",
            "-726.00",
            "555",
            "99999999999.99",
            "0.00",
            "1234.12",
            "05.05",
            "-00.00",
            "+9.99"
        ],
        "non_matches": [
            "1212.4564",
            "-11.5858",
            "12.000",
            "0.",
            "1234.1234",
            "+.",
            "00-",
            "0.9",
            "0.999999999999999999",
            "+3.14159265359",
            "-+0.99",
            "-.00"
        ],
        "id": 1592,
        "output": [
            {
                "text": " (\\\\d{1,2}\\\\.)?\\\\d{1,2}(\\\\.)?\\\\d{1,2}(\\\\.)?\\\\d{1,2}\nMy"
            },
            {
                "text": "\n^[-+]?\\d+\\.\\d{1,2}$\n\nExercise 2:\nThink of two real-world examples of situations where using a RegEx could be helpful"
            },
            {
                "text": " Match examples: \"^[0-9]+([.][0-9]*)?$\"\n\n9.1.6 Escape sequences and special sequences\n- Escape sequences are used to represent"
            },
            {
                "text": "\n^(?=.*[1-9])(?=.*[0-9])?(?=.*[0-9].{2})(?![0-9]*$"
            },
            {
                "text": " +([0-9]+)\\.?([0-9]+)\n4. Create a RegEx for this description. Your regex should match only strings that are 8 characters long or longer, and that"
            },
            {
                "text": " \n[^\\d.]+\n\nExample 3:\nCreate a RegEx to match strings that start with a '-' character and end with a digit. For example, \"--123\" and"
            },
            {
                "text": "\n- ^[+-]?[1-9][0-9]\\.(0[1-9]|1[0-9])$\n\n\n\nOnce upon a time,"
            },
            {
                "text": "\n^[+-]?([0-9]+(\\.[0-9]*)?)([a-zA-z]+)$\n\nExercise 4:\n\nExercise"
            },
            {
                "text": " [ +-]?\\d{1,2}\\.\\d{1,2}$\n\nExample 3\nThis RegEx will match a string that starts with either a \"A\" or"
            },
            {
                "text": "\n[^ ]{0,24}[.][^ ]{0,24}[^ ]{0,2}[.][^ ]{0,2}[0-9]"
            }
        ]
    },
    {
        "expression": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(?:\\/\\S*)?(?:[a-zA-Z0-9_])+\\.(?:jpg|jpeg|gif|png))$",
        "raw_prompt": "A nice little regex to verify a URL pointing towards an image. Can be useful.",
        "refined_prompt": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website.com/image.php\"\n- \"www.picture.here\"",
        "matches": [
            "http://website.com/directory/image.gif",
            "http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg",
            "http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png",
            "http://EjrLECfHkL5.tFopXJ10TkCh-jNjEfiG5e3DdBgreymwuNS5P5pi.aOY2rdWHs6VsEggY7tkn39soXL-wg-diW2yqJEmdMVeg.wFs6F8BHU6z4meVEmCgUUIFs3.jpeg",
            "http://8ohZ-LNRwkriF5X7wyh1sqrjaz.vVDt_RAxaZ_Y.jpg",
            "http://g35tMNQ-2Ugka1.fPWwpeDcUmj5ZyYbfq6cJcryOBnQI88a7nafgWyzM8WgIT3.gif",
            "http://.FklkEJy..eL0teNhL2VFWKFPhaLxqOkZCie5pKS3jfMdwMeNK1r9PeWi6CrzKYq.hIX0J.jpeg",
            "http://BWII3EHWgISrvBpTO4u5Fy.UX2mgg_mSSU5e.gif",
            "http://hXazX0.RAZcjO0dwlSKFZADxc0NQMzTLycPaVDXmbbeue2f7ETFnMjiR8FwhDTYm8jfQXQswGwn_mTsh2xRx_udPiODC38AaAFwS4.jpg",
            "http://JHgb.5lbZEkDbEKGHX5ip2.qVMoegDGIubh5tZDa_YYGtgghkSS0CCGp4mzXcVQ.jpg",
            "http://zIu3Ac9Nsu3An6iu01m8.aa.eHtjYgGele9wKP0IybjWen6Rj57560ZiHijaRoalY5oQ66YRAWPo6BSaRRuE76dmh1xVyS0uOkljZMJ_.png",
            "http://EGeSMV5M1YtMaqb.LbNmMVe_l4bqoRKHJfOM0gbEWTz.jpeg",
            "http://uMO8ePamOatXwcszK.WiO/CeY2}nQ@?nooQr,'SSeDrBL}Wf\\PP'X!1.jpeg"
        ],
        "non_matches": [
            "www.website.com/image.php",
            "www.picture.here",
            "www://Fe96Z8k4hlTowt7QGupJ9lrjp.vCgIyi6cHMvOYQhU_X6kF10HfgOnBXM.png",
            "www://BB5Qt93T7992YcRnXw0-uqSwFPjDDxsnyz3-RPaj8KVavqfNbOrkO3g.tvEAI.sSH88ySka3.png",
            "www://qrMhM-x-efXsioq2BGCUsS2-6fcYefuK92yoVNjF4sx6YxtyfcMYcKXAoY3tBRR5bNoltQSChF.NDo8bz5RpTEvNo5I8fv.com",
            "http://j7DIFoX.lT/Xf)($(8A\\W26RvI04~eOc5^cj\\p^qR,Lfe3]C^w@Guwk]<xPA3]If>m=,,~F]0o\"390B8qLc]fv>4LqM'\\eu?zy.ulpu1X0mxjoWSY0f.org",
            "http://Bpd9L.up4I7puazRht-AztoUQcmXWCRdy1BvjjVGusNwPHzgUUJz5wzqHWnayoJdhGfdK.suhm5MyUhbWceVEkSzED_qa.edu",
            "http://3YRVKYD.5Mn2iKAFnjA3YjZp9aSSN.ko/`VyO'T4.0a_P.y~d<;,UT,ORS|A(HK7HFcLju(GSPahM6tXB1]D-Nw!g/Dq~$9;\"}ug_-'M$OhdheFr3jOk76e0h9ZWsoJXdViBxgmeVnKx6.org",
            "www://J2pp6qTAuPmdB.lF0AUjVEaLNpxI6Pv56y8v.zR2ZLzMumZMME.kJNAPGFfKjjstFHwhn6DHai8FPWCSp3Zikn7E_AXg.",
            "www://gtb2mcVj6c.sNUY6XUY3wOB3M9WAYhg4HFh.siH/n?R@X\"My>eX7NYVuJ\"2o<eW;(Pr)m-@EOj9`)j&3w6\\nS[EKo4dfanXH7WbdWGHSl2ks(~J5:~+i<ig.`+&VEl'wLdhIKg56OSYSnNcq9GFH7rS.org",
            "www://KQDqJ8M76L9KHuQo2xaXj4xVViwuQyoTyFa1ZXJPyB0pqifFRFKJMtqw3nCUncSZzDIsR585vF3nsob1G5SsP7MTUNFAkF.zrtpk1O_wFf1cIrlbBi2z.com",
            "www://4Z.JbnQVEV."
        ],
        "id": 1599,
        "output": [
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            },
            {
                "text": "Verifies that a URL refers to / points towards an image.\nMatch examples:\n- \"http://website.com/directory/image.gif\"\n- \"http://mY.16wkdchY-wuvoWpHtZLM5EBD.DqaJ.jpg\"\n- \"http://16dBsg-wTS6wIVjMilL7ILvx.EI5K5BQnEvqd8uxjrYXjmlF6QJpkw.png\"\nNon-match examples:\n- \"www.website."
            }
        ]
    },
    {
        "expression": "[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])\\s{1}(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])",
        "raw_prompt": "Validation of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. I'm not able (with this) to validate the correct last day of each month. Anyway, it helps :-)",
        "refined_prompt": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"",
        "matches": [
            "2007-01-01 00:00",
            "6342-06-06\u200020:54",
            "4891-02-08\u200818:38",
            "5279-04-09\u00a006:38",
            "0197-10-31 09:31",
            "6528-02-07 18:21",
            "1599-01-04\u200813:18",
            "6455-10-30\u200408:22",
            "3224-10-17\u200323:45",
            "9398-11-08\u200511:00",
            "1578-12-28\u200222:22",
            "3916-01-25\u200814:32",
            "1378-11-30\u205f04:54"
        ],
        "non_matches": [
            "2007-1-1 0:0",
            "5554/02-29\u200622:11",
            "4633/10-30\u300013:20",
            "4180/05/07 01:59",
            "3642/03/30\u180e02:06",
            "9259/05/31\t04-19",
            "4815/02/01\u200323-54",
            "0463-08/31\u180e20-33",
            "4763-02/23\u168023-15",
            "4648-03-27\u200113-45",
            "7671-07-20",
            "21-44"
        ],
        "id": 1601,
        "output": [
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this date"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this string"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this pattern"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this case"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this date"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this date"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this."
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this date"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this:"
            },
            {
                "text": "Validates the format of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. Does not ensure the last day of each month is correct.\nMatch examples:\n- \"2007-01-01 00:00\"\n- \"6342-06-06\u200020:54\"\n- \"4891-02-08\u200818:38\"\nNon-match examples:\n- \"2007-1-1 0:0\"\n- \"5554/02-29\u200622:11\"Generate a RegEx for this."
            }
        ]
    },
    {
        "expression": "(?:\\([2-9][0-8]\\d\\)\\ ?|[2-9][0-8]\\d[\\-\\ \\.\\/]?)[2-9]\\d{2}[- \\.\\/]?\\d{4}\\b",
        "raw_prompt": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br>\nArea code: [2-9][0-8][0-9]<br>\nExchange code: [2-9][0-9][0-9]<br>\nStation code: [0-9][0-9][0-9][0-9]<br>\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line. Adapted from Don Johnston's pattern.",
        "refined_prompt": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of the line. Adapted from Don Johnston's pattern.\nMatch examples:\n- \"8296399623\"\n- \"741 556-4630\"\n- \"319.380.3232\"\nNon-match examples:\n- \"(195)979-5873\"\n- \"763 027 5552\"",
        "matches": [
            "8296399623",
            "741 556-4630",
            "319.380.3232",
            "(859)673.5793",
            "660/471.5749",
            "9369137535",
            "425.248-9472",
            "712397.3181",
            "(870) 5968518",
            "523722/0174",
            "(403) 376.7985",
            "(369)601-2988",
            "(989) 535/1195"
        ],
        "non_matches": [
            "(195)979-5873",
            "763 027 5552",
            "596 270.0326",
            "8915551212",
            "(137)6197955",
            "(063)763.8654",
            "(149)943.2546",
            "(080)008.0996",
            "(186)117 7777",
            "602",
            "(007)0548217",
            "(177)0235914"
        ],
        "id": 1606,
        "output": [
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            },
            {
                "text": "Matches Northern American Numbering Plan (NANP) requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.\r\nArea code: [2-9][0-8][0-9]\r\nExchange code: [2-9][0-9][0-9]\r\nStation code: [0-9][0-9][0-9][0-9]<\r\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops match at any word boundary, including the end of"
            }
        ]
    },
    {
        "expression": "^(.{0,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{4,})|(.{1,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{3,})|(.{2,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{2,})|(.{3,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{1,})|(.{4,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{0,})$",
        "raw_prompt": "Passwords with at least 1 letter, at least 1 non-letter, and at least 6 characters in length. It is lenthy with a repeating pattern so that I could validate all three conditions in one expression without using a lookahead, \"?=\", which are not handled correctly in Internet Explorer.",
        "refined_prompt": "Matches passwords with at least 1 letter, at least 1 non-letter, and at least 6 total characters in length.\nMatch examples:\n- \"12345a\"\n- \"abcde*\"\n- \"ABC123\"\nNon-match examples:\n- \"12ab\"\n- \"abcdef\"",
        "matches": [
            "12345a",
            "abcde*",
            "ABC123",
            "tT?H{jf8ty0_P9J",
            "a'%|w]1y-Um]Mp>F",
            "Password!1@",
            "ac\\S#%&(ZVosR#b?Z'ptCn6VNW%Ecbq.JMJ~pvsnN_)p~0-W",
            "RSh3X=Q8|t~[Q",
            "T]>)T>Qb2rc70hP7#s))@)Y`ZMs#V'x6aoC'^x?1aBt}XK",
            "<`,-j<EzEuum=D}dO>27bW ,Y&j\\6eF&v$Woe`0q;F~+@d$RM7eBxZ9o_59JSSLB\"){",
            "(Ikg4?Xm8dmB^y{0",
            "G,;097W~8\";n >~4!vq4R?%",
            "th!s!sa$trongp@ssw0rd"
        ],
        "non_matches": [
            "12ab",
            "abcdef",
            "123456",
            "$",
            "12$@",
            "pasS!",
            "hElLo",
            "####@",
            "sw@9.",
            "...",
            "+-+-1",
            "LOML"
        ],
        "id": 1611,
        "output": [
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.{6,}$).*[a-zA-Z\\d]{3"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*\\d)(?=.*[A-Z]).{8,}$\n\nExercise 4: Write a Python script that takes in a list of numbers and"
            },
            {
                "text": " a-zA-Z0-9\\s{6,}\n\n###### Exercise 2:\n\nWrite a program that will check if a password is valid. The password must meet all the criteria:\n\n1."
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*-_=])[A-Za-z"
            },
            {
                "text": " The regex would be ^(?i)(?=.*[a-z])(?=.*\\d)(?=.*[A-Z]).{8,}$\n\n    Subsection 15.3.5"
            },
            {
                "text": "\n^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\\d]{6,}$\n\nExercise 3: Replace"
            },
            {
                "text": " \na. [A-Za-z0-9]*[A-Za-z]\nb. [A-Za-z0-9]{4,6}\nc. [A"
            },
            {
                "text": "\n\nimport re\n\ndef match_password_regex(password: str) -> bool:\n    \"\"\"\n    This function takes in a password and returns True if the password meets the regular expression \n    requirements ("
            },
            {
                "text": "\n^([a-zA-Z][a-zA-Z0-9]*)(?=.*[a-zA-Z])(?=.*\\d)(?=.*[\\w\\d"
            },
            {
                "text": "^[a-zA-Z0-9\\*\\/]{6,}$\n\n3. Create an expression to match phone numbers in the format xx-xxx-xxxx.\nAnswer: \\d{3}"
            }
        ]
    },
    {
        "expression": "^([0-9]{0,5}|[0-9]{0,5}\\.[0-9]{0,3})$",
        "raw_prompt": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. To change the range, simply edit the numbers in curly braces. For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}. This can be useful for numeric fields in SQL. This example was made to accommodate a numeric(8,3) field definition.",
        "refined_prompt": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point. It also recognizes whole numbers. In this example the value cannot exceed 99999.999. This example was made to accommodate a numeric(8,3) field definition.\nMatch examples:\n- \"0\"\n- \"1\"\n- \"1.55\"\nNon-match examples:\n- \"abc\"\n- \"654321\"",
        "matches": [
            "0",
            "1",
            "1.55",
            "54321.123",
            ".12",
            "20563.23",
            ".1",
            "152",
            "0.",
            "1190.315",
            "83.29",
            "1130",
            "99999.999"
        ],
        "non_matches": [
            "abc",
            "654321",
            "12..34",
            ".1234",
            "$$$",
            "99999.9999",
            "100000.000",
            "100000",
            "999999",
            ".1234",
            "000000",
            "3.1415"
        ],
        "id": 1618,
        "output": [
            {
                "text": "\n[^\\d]?\n\nA:\n\nThere are two cases\n\nThe field can contain"
            },
            {
                "text": " (.*)\n- \"123\"\n- \"123.456\"\n- \"123.456789"
            },
            {
                "text": " [0-9]{4}.[0-9]{3}|[0-9]{"
            },
            {
                "text": "\n\n\"1(.00)[1-9]+([1-9][0-9]*)|"
            },
            {
                "text": " This is where one can have a lot more flexibility and create your own pattern.\n\nA:\n\nYou"
            },
            {
                "text": "\n^[a-zA-Z0-9.][a-zA-Z0-9"
            },
            {
                "text": " ^[a-z0-9]{8,3}(.[0-9]+)?(?:"
            },
            {
                "text": " [a-z0-9]{6,21}[a-z]\n\nA:\n"
            },
            {
                "text": "\n^\\d+\\.\\d{1,3}$\n\nA:\n\nThis one should"
            },
            {
                "text": " [^0-9]*$\n- \"1.00\"\n\nA:\n\nThis is"
            }
        ]
    },
    {
        "expression": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "raw_prompt": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL.",
        "refined_prompt": "Simple regex to match the query part of a string. Meaning, anything after the \"?\" at the end of an URL.\nMatch examples:\n- \"?key=value\"\n- \"?key1=value1&key2=value2\"\n- \"?hello=hola\"\nNon-match examples:\n- \"key=value\"\n- \"?key=value&\"",
        "matches": [
            "?key=value",
            "?key1=value1&key2=value2",
            "?hello=hola",
            "?regex=eval",
            "?12345=6789",
            "?go=irish",
            "?website=90000",
            "?cool=aka",
            "?314=CSE",
            "?xxxxxxxx=yyyyyyyyyyyyyy",
            "?1a2b3c=abcd1234",
            "?value=key",
            "?gGGg=h83z"
        ],
        "non_matches": [
            "key=value",
            "?key=value&",
            "?hello",
            "?",
            "key",
            "?key=value=key",
            "?key=value.",
            "?key.value",
            "?<key=value>",
            "?<key>=<value>",
            "??key=value",
            "?key?=value"
        ],
        "id": 1621,
        "output": [
            {
                "text": " /(?=\\?\"key=value\\?\")(?=\\w[^&\\?])/\n\n5. Create a regular expression"
            },
            {
                "text": " (?<query>\\?)([a-zA-Z0-9_.-]+)(?=&)\n\n2. Write"
            },
            {
                "text": "\n/^[a-zA-Z]+\\s?=\\s?[a-zA-Z]+$/\n\nEx"
            },
            {
                "text": " No matching.\n\nExample Code:\n# Importing the re module\nimport re\n\n# Defining the query string for testing\nquery_"
            },
            {
                "text": " [^=]+\n\nExercise 3:\nWrite a Python code that reads a text file containing URLs and matches them using the regular expression [^"
            },
            {
                "text": " (/^[^?&]*$/)\n\n3. How many characters in the URL contain the query part of the string?\nMatch"
            },
            {
                "text": " \n(?=.+$)\\?(.+)\nThe \"?\" at the beginning of the RegEx is the start of the lookahead"
            },
            {
                "text": " (\\w+=.*)?\n\n2) Create a regex that matches the part of a URL starting with a question mark plus some alphabet characters."
            },
            {
                "text": " [A-Za-z_-]*[A-Za-z0-9_]*[A-Za-z0"
            },
            {
                "text": " \\?(\\w+)=(\\w+)\n\nThe key-value pair (?w+)=(\\w+) matches the key=value text string"
            }
        ]
    },
    {
        "expression": "^[^\\x00-\\x1f\\x21-\\x26\\x28-\\x2d\\x2f-\\x40\\x5b-\\x60\\x7b-\\xff]+$",
        "raw_prompt": "Matches common ASCII names without special characters.",
        "refined_prompt": "Matches strings without any special characters, except periods and apostrophes.\nMatch examples:\n- \"Sir. Isaac Newton\"\n- \"Tom O'Leary\"\n- \"hello\"\nNon-match examples:\n- \"Mar!y Ann\"\n- \"Bob_1\"",
        "matches": [
            "Sir. Isaac Newton",
            "Tom O'Leary",
            "hello",
            "MyNameIs...",
            "'he said'",
            ".'.'",
            "Mr. Smith the Third",
            "...Hello...",
            "family's",
            "The Password is ...",
            "and so they 'ran'",
            "Mr. O'Malley",
            "'''"
        ],
        "non_matches": [
            "Mar!y Ann",
            "Bob_1",
            "~!@#$%^&*()_+=-0987654321`{}[]",
            "\\;:\"<>?,/",
            "Mr. Smith the 3",
            "<website>",
            "1+2=3",
            "\"good job\"",
            "list of:",
            "\"To Kill a Mockingbird\"",
            "variable_name",
            "{5}"
        ],
        "id": 1625,
        "output": [
            {
                "text": " b_1\n\n2. Write a RegEx for the word \"world\" that excludes the letter 'w'.\nAnswer:.o'r\n\n3. Write a RegEx for the word \"cat\" that includes the letters 'a' and '"
            },
            {
                "text": " r\"^[a-z0-9_\\s\\.][a-z0-9_\\s\\.\\s\\1]*$\".\n\n## Final thoughts:\nThanks for reading through this post! RegEx is a powerful and flexible"
            },
            {
                "text": " (The pattern is very simple and easy to read):  ^.{6,20}$\n\nExercise 2: Give an example of a situation where a RegEx might not be the best option.\nAnswer: A RegEx might not be the best"
            },
            {
                "text": " (^[A-Z][a-z]+(\\s[A-Z][a-z]+)+$)\n\nConclusion:\nCongratulations, you have learned the basics of generating and optimizing regex patterns using Python. By using list comprehensions,"
            },
            {
                "text": " \"^[^, ]*[a-zA-Z\\s]'\\w*$\"\n\n5) Create a RegEx for matching email addresses (e.g., john.doe@example.com)\nAnswer: \"^["
            },
            {
                "text": " [^a-zA-Z0-9.]\n```python\nimport re\n\ntext = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.'\"\n\npattern = re.compile"
            },
            {
                "text": " (?<word>[\\w\\s\\.',!\\(\\)\\[\\]\\{\\}\\:\\-\\?\\_\\+]){1}([\\w\\s\\.',!\\(\\)\\[\\]\\{\\}\\:\\-"
            },
            {
                "text": " ^[A-Z][a-z]+[A-Za-z]$\n\nExercise 3:\nCreate a RegEx pattern that will match any single character in the range 'a'-'z'. \nAnswer: \\w\n\n"
            },
            {
                "text": " \"^[a-zA-Z0-9]'[a-zA-Z0-9\\.']*$\".\n\n2. Write a Python function that takes a list of strings as input, and returns a list of strings that match"
            },
            {
                "text": " Matches strings with a comma or an apostrophe, but not between two underscores or in a double quote. Generates a RegEx for this description. \n\n3. Write a RegEx to match passwords that are at least 8 characters long and contain both letters"
            }
        ]
    },
    {
        "expression": "^((192\\.168\\.0\\.)(1[7-9]|2[0-9]|3[0-2]))$",
        "raw_prompt": "This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses. I created this expression for Google Analytics to filter out hits from our companies office.",
        "refined_prompt": "This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses.\nMatch examples:\n- \"192.168.0.17\"\n- \"192.168.0.24\"\n- \"192.168.0.32\"\nNon-match examples:\n- \"192.168.0.16\"\n- \"192.168.0.33\"",
        "matches": [
            "192.168.0.17",
            "192.168.0.24",
            "192.168.0.32",
            "192.168.0.30",
            "192.168.0.19",
            "192.168.0.18",
            "192.168.0.25",
            "192.168.0.31",
            "192.168.0.27",
            "192.168.0.20",
            "192.168.0.26",
            "192.168.0.22",
            "192.168.0.23"
        ],
        "non_matches": [
            "192.168.0.16",
            "192.168.0.33",
            "192.168.0.12",
            "192.168.0.36",
            "192.168.0.39",
            "192.168.0.10",
            "192.168.0.11",
            "192.168.0.44",
            "192.168.0.49",
            "192.168.0.45",
            "192.168.0.90",
            "192.168.0.57"
        ],
        "id": 1636,
        "output": [
            {
                "text": " Non-[1234567890A-Za-z0-9\\-]{15"
            },
            {
                "text": "\n(?<ip>[0-9]\\.){1,3}[0"
            },
            {
                "text": " (IP Range) \"IP Range\"\n```\n\n```python\n# Reg"
            },
            {
                "text": " [\\d\\.\\-]+.[\\d\\.\\-]+.[\\d\\.]+["
            },
            {
                "text": " \"^192\\.168\\.0\\.[0-9]{1,3}\\.["
            },
            {
                "text": " The pattern to match IP Addresses between 192.168.0.0 - 192.168"
            },
            {
                "text": "\n^(?:[0-9]{1,3}\\.){3}["
            },
            {
                "text": " \n# \"192.168.0.1\" \"192.168.0."
            },
            {
                "text": " (\\d{1,3}\\.\\d{1,3}\\.\\d"
            },
            {
                "text": " To match IP Addresses between 192.168.0.17 - 192.168.0"
            }
        ]
    },
    {
        "expression": "^(\\$)?((\\d{1,5})|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{1,2})?$",
        "raw_prompt": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with , sign.",
        "refined_prompt": "This regular expression is used for validating five-digit numeric values. A $ can precede the value, and a comma or decimal may separate digits.\nMatch examples:\n- \"80,000.00\"\n- \"80,000\"\n- \"80000\"\nNon-match examples:\n- \"800,00.00\"\n- \"80.000\"",
        "matches": [
            "80,000.00",
            "80,000",
            "80000",
            "80.00",
            "$80000.00",
            "52",
            "$87777",
            "$8.00",
            "04300.00",
            "$12345",
            "3.14",
            "1,000",
            "23,000,000,000.00"
        ],
        "non_matches": [
            "800,00.00",
            "80.000",
            "$8,0000.00",
            "34,333,555,678.000",
            "1,00",
            "$0.",
            "$0.000",
            "0,0",
            "$000000",
            "$45.331",
            "1,2.98",
            "600321"
        ],
        "id": 1638,
        "output": [
            {
                "text": " ^\\d{4,9},?$\n\nExercise:\n1. What would be the value of the following expression?\n\"0.25,000\""
            },
            {
                "text": " \\d{5}\n\nExercise 5\nCreate a Python function that takes in a string and uses RegEx to find all the valid and invalid email addresses.\nAnswer"
            },
            {
                "text": "\n\nimport re\n\ndigits = re.compile(r\"[0-9]+\\.[0-9]+|[0-9]+$\")\n\n"
            },
            {
                "text": " \\d{3}[,\\.]?\\d{3}\n\nExercise 3: Match the names of three different types of vehicles:\n- Match the names"
            },
            {
                "text": "\n(?=^[0-9]{5}$)([0-9]{3},[0-9]{3})?\n\nExercise"
            },
            {
                "text": " \\d{5}(\\.\\d+)\n\n4. Write a RegEx for extracting all email addresses from a string.\nHint: An email address is a"
            },
            {
                "text": " \n(^|\\,)(\\d{5})(\\,\\d{2})?$\n\nExercise 2: \nIdentify the non-"
            },
            {
                "text": " \\d{5},?\\d{3}\n\nExercise 3:\nFind all lines in the following text that contain the word \"code\".\n\"This is"
            },
            {
                "text": " [1-9]\\d{0,3}(,\\d{3}){0,2}\n\nExercise 3: Matching Non-AlphaN"
            },
            {
                "text": " (\\d\\d)(?:,\\d\\d)?|(?:\\d\\d(?:\\.\\d\\d)?|\\.\\d+|\\."
            }
        ]
    },
    {
        "expression": "^(([0-9])|([0-2][0-9])|([3][0-1]))\\/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.",
        "refined_prompt": "This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long.\nMatch examples:\n- \"1/Feb/2007\"\n- \"03/Jun/2007\"\n- \"31/Dec/2007\"\nNon-match examples:\n- \"1/2/2007\"\n- \"03/Jun/07\"",
        "matches": [
            "1/Feb/2007",
            "03/Jun/2007",
            "31/Dec/2007",
            "25/May/7726",
            "31/Apr/5406",
            "7/Jan/4020",
            "00/Oct/7040",
            "6/Dec/9367",
            "31/Nov/0749",
            "1/Dec/9614",
            "07/Jan/2265",
            "31/Aug/8328",
            "08/Jul/7944"
        ],
        "non_matches": [
            "1/2/2007",
            "03/Jun/07",
            "31-Dec-2007",
            "6/aug/8088",
            "30/oct/3223",
            "5 May 7665",
            "07-Jan-5279",
            "0:Jul:3108",
            "13-June-3201",
            "6/december/7172",
            "31/04/7372",
            "07/nov/8152"
        ],
        "id": 1642,
        "output": [
            {
                "text": " \n^(0[1-9]|1[0-2])"
            },
            {
                "text": " (\\d\\d/\\w{3}/\\d{4})"
            },
            {
                "text": "\nre.compile(r'\\d{1,2}/\\"
            },
            {
                "text": "\n([0]{1,2}/[0-9]{3"
            },
            {
                "text": "\n^(\\d\\d)/(\\d\\d)/(\\d\\d)"
            },
            {
                "text": " (\\d\\d/\\w{3})\\/(\\w{3}\\"
            },
            {
                "text": " ^\\d{1,2}/\\w{3,4}/"
            },
            {
                "text": "\nvar reg = /^(0[1-9]|1[012"
            },
            {
                "text": " (?:\\d{2}/)\\s*((?:Jan|Feb|"
            },
            {
                "text": "\n[0-9]{2}/[A-Z][a-"
            }
        ]
    },
    {
        "expression": "^((4(\\d{12}|\\d{15}))|(5\\d{15})|(6011\\d{12})|(3(4|7)\\d{13}))$",
        "raw_prompt": "Matches Visa, American Express, Discover, and Mastercard only.",
        "refined_prompt": "Matches Visa, American Express, Discover, and Mastercard only.\nMatch examples:\n- \"4111111111111\"\n- \"4111111111111111\"\n- \"5111111111111111\"\nNon-match examples:\n- \"411111111111\"\n- \"51111111111111111\"",
        "matches": [
            "4111111111111",
            "4111111111111111",
            "5111111111111111",
            "6011111111111111",
            "341111111111111",
            "371111111111111",
            "6011480234638632",
            "345883893201887",
            "376664979664283",
            "5090201478642631",
            "4951575838177",
            "4726635308257825",
            "6011893825943075"
        ],
        "non_matches": [
            "411111111111",
            "51111111111111111",
            "6111111111111111",
            "321111111111111",
            "381111111111111",
            "1312673751724778",
            "2990655926408554",
            "7011461924759324",
            "1183312333560",
            "2575647296682975",
            "1783923266016891",
            "1813360266849221"
        ],
        "id": 1643,
        "output": [
            {
                "text": " \n\nCode:\n\nimport re\n\ndata = ['4111111111111111', '4111111111111111', '4111111111111111', '411111111111111', '4111111111111111']"
            },
            {
                "text": " The answer will vary depending on the student's description. \n\n3. Write a RegEx to validate an email address.\nHint: The email address format should have one or more alphanumeric characters, one hyphen,"
            },
            {
                "text": " ^(?P<type>\\d{16})\\d{13}(?P<num>\\d{4})\\d{4}$\n\nExercise 2:\n\n1. Give an example of"
            },
            {
                "text": " (any number of digits) followed by one of the four aforementioned credit cards\n\n3. Write a Python program to check if a string contains a phone number in the format (XXX) XXX-XXXX. \nAnswer: \n"
            },
            {
                "text": " (4.1)\n\n4. Write a Python function that takes a string as input and returns True if the string is a valid email address, and False otherwise.\n\ndef is_valid_email(email_address):"
            },
            {
                "text": " \n\"([0-9]{4}[0-9]{4}[0-9]{4}[0-9]{4}[0-9]{4}[0-9]"
            },
            {
                "text": " A good rule is \"^([4])([1-9])[0-9]{3}$\"\n\nExercise 5: Identify the Type of RegEx\nExercise: Which type of RegEx is"
            },
            {
                "text": " (a) \\d{4}-\\d{4}-\\d{4} and (e) \\d{4}-\\d{4}-\\d{4}-\\d{4}\n"
            },
            {
                "text": "\nHere is a possible RegEx pattern: /^(4[1-9]|[1-9]\\d|[1-9]\\d\\d|1[0-2])[1-9]"
            },
            {
                "text": " ([0-9]{4}[0-9]{4}[0-9]{4}[0-9]{4}[0-9]{4}[0-9]{2})"
            }
        ]
    },
    {
        "expression": "^\\{?[a-fA-F\\d]{32}\\}?$",
        "raw_prompt": "Matches only a 32 character hex string (Eg. MD5). Based off Chris Craft's expression:-)",
        "refined_prompt": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe92611A4BF46A9\"",
        "matches": [
            "09f8814c757a00f14efdb70e45f851d1",
            "F11EBc9BF0A1Ac45722ce31BF300C6Bb}",
            "638b2a7fFf4755346A4e45FC691ccB1D}",
            "{8F8beeaee6EeB91e922b8AD5C1fCe6Ec}",
            "AC0bDE9Ea4f8768d5fb19eC933FF3fAC",
            "{89c1483b2eeCf59CF82c4bd7b3B2Bcb9}",
            "3f7eA8bcDbeC4Cce76bB1B9afDC8ae59",
            "2BC01549C9734256C26A4F11B6e892A2",
            "{241dBd13BAEAeDf9E1AAa35Ef8bE391A",
            "eAbD53e60B468cAa0C872ed7F352b6a8",
            "e151f44B2A1Eb31Dbed62cD5a0dAf78E",
            "{FACb0F8cEdfEfFAEDD5AFFe4cF6B7AeC",
            "0ad1ED3cc3Da1D0FeFaAbbaA924bAaCa}"
        ],
        "non_matches": [
            "46345678901234567890aaaabbbbbbzj",
            "3Db1D07b8fC556fe92611A4BF46A9",
            "E1aFc46E003Ebc1E11a45Ee2f",
            "hello",
            "{11111111111111111111111111111111@",
            "{B6}",
            "fcD27ECb5e}",
            "{0Cc5b3ABfCE872FcB0a",
            "{A}",
            "dCA31de6B76cCc46D4C8ED86FFFEfDaaAA3d8e05",
            "{8c2A79cCAFedbB0aaE9ee27C56F3FCFc79c8BbB0bD7Aeba6d5c840Bd6Ad22bAddC6BC207D5A8BD}",
            "BeBb6a4EeEB8Ca7fd483dFE9f3cfbAfbBfEbebb3caFdC457}"
        ],
        "id": 1644,
        "output": [
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926a"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926C"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926f"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926c"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926D"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926c"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926D"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926f"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe926D"
            },
            {
                "text": "Matches a hex string 32 characters long.\nMatch examples:\n- \"09f8814c757a00f14efdb70e45f851d1\"\n- \"F11EBc9BF0A1Ac45722ce31BF300C6Bb}\"\n- \"638b2a7fFf4755346A4e45FC691ccB1D}\"\nNon-match examples:\n- \"46345678901234567890aaaabbbbbbzj\"\n- \"3Db1D07b8fC556fe92623"
            }
        ]
    },
    {
        "expression": "^(9\\d{2})([ \\-]?)([7]\\d|8[0-8])([ \\-]?)(\\d{4})$",
        "raw_prompt": "U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash or no separators.",
        "refined_prompt": "U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash, or no separators.\nMatch examples:\n- \"900700000\"\n- \"900 70 0000\"\n- \"900-70-0000\"\nNon-match examples:\n- \"899700000\"\n- \"77278 4873\"",
        "matches": [
            "900700000",
            "900 70 0000",
            "900-70-0000",
            "966-81-7357",
            "901776136",
            "92175 0658",
            "951834540",
            "972 866756",
            "909-718786",
            "920 773719",
            "91671 2174",
            "971-77-5980",
            "967862987"
        ],
        "non_matches": [
            "899700000",
            "77278 4873",
            "900-89-0000",
            "900-69-0000",
            "146835563",
            "07485 4569",
            "288841640",
            "17183 1484",
            "361-84 4742",
            "212 757446",
            "34",
            "416-86 5000"
        ],
        "id": 1653,
        "output": [
            {
                "text": "\n\nA:\n\nYou must consider"
            },
            {
                "text": " 9(0-9)(0-9"
            },
            {
                "text": " (1-2) a-z A"
            },
            {
                "text": " (\\d{3}(?:["
            },
            {
                "text": " The valid range is 900-7000 through"
            },
            {
                "text": " [0-9]{3}\\s"
            },
            {
                "text": " \\b[0-9]{1"
            },
            {
                "text": "\n^([0-9]{3"
            },
            {
                "text": "\n- [\"90070\",\"90078\",\""
            },
            {
                "text": " A-Z0-9-                                 "
            }
        ]
    },
    {
        "expression": "^(?:((31\\/(Jan|Mar|May|Jul|Aug|Oct|Dec))|((([0-2]\\d)|30)\\/(Jan|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))|(([01]\\d|2[0-8])\\/Feb))|(29\\/Feb(?=\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))))\\/((1[6-9]|[2-9]\\d)\\d{2})$",
        "raw_prompt": "Matches dates in the form of DD/MMM/YYYY. It also handles leap years. Days are 2 digits; months are case sensitive with first character upper-case and next 2 characters lower-case; year is 4 digits.",
        "refined_prompt": "Matches dates in the form of DD/MMM/YYYY. It also handles leap years. Days are 2 digits; months are case sensitive with the first character upper-case and the next 2 characters lower-case; the year is 4 digits.\nMatch examples:\n- \"01/Mar/2007\"\n- \"16/Dec/2007\"\n- \"29/Feb/2008\"\nNon-match examples:\n- \"1/Mar/2007\"\n- \"16/Dec/07\"",
        "matches": [
            "01/Mar/2007",
            "16/Dec/2007",
            "29/Feb/2008",
            "30/Dec/3126",
            "31/May/2121",
            "30/May/1888",
            "15/Feb/1630",
            "20/Feb/3288",
            "31/Mar/1822",
            "22/Jul/1953",
            "30/Jun/3242",
            "28/Feb/1602",
            "30/Nov/1762"
        ],
        "non_matches": [
            "1/Mar/2007",
            "16/Dec/07",
            "29/Feb/2007",
            "4/Feb/1999",
            "31-Jan-6340",
            "Dec 1 1876",
            "30/oct/1887",
            "31/March/1844",
            "31/july/5438",
            "2003/Jan/26",
            "30 Jun 1985",
            "31,Aug,7241"
        ],
        "id": 1654,
        "output": [
            {
                "text": " \n(?:(?:[0"
            },
            {
                "text": " ^(0[1-9]"
            },
            {
                "text": "\n^(?P<Year>"
            },
            {
                "text": " \n[JAN|FEB"
            },
            {
                "text": " [01-MAR-2007](["
            },
            {
                "text": " (^[0-9]{"
            },
            {
                "text": "\n^\\d{1,2"
            },
            {
                "text": " (0-9)-(0-"
            },
            {
                "text": " \n(?<day>\\"
            },
            {
                "text": " \\d{1,2}\\/"
            }
        ]
    },
    {
        "expression": "^((\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)\\s*[,]{0,1}\\s*)+$",
        "raw_prompt": "This will validate multiple email addresses that are comma delimited. You can change it to use commas or semilcolons. If you have to worry about a lot of special characters, you may have to edit it a little bit. It allows white space before and after the comma.",
        "refined_prompt": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com , email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"",
        "matches": [
            "Test@host.com",
            "email1@host.com,email2@host.com,email3@host.com",
            "email1@host.com, email2@host.com , email3@host.com",
            "student@school.org",
            "teacher@school.org dog@daycare.com",
            "123456789@numbers.edu",
            "123456789@numbers.edu numbers@123456789.gmail",
            "1W@GMAIL.COM",
            "ALL@CAPS.MORE, lower@caps.edu, hi@bye.com",
            "1a2c4hw5@6789.gov",
            "q@q.ph",
            "dog@daycare.com 1W@GMAIL.COM, student@school.org q@q.ph",
            "2@2.c, ejrfhelrfhehh@sdhjbedjf.k"
        ],
        "non_matches": [
            "test@test",
            "test@host.com,test@",
            "test@ host.com",
            "@",
            "@.com",
            "hello.com",
            "john @ gmail.com",
            "john.gmail.com",
            "hello!@school.edu",
            "hello@school!>>>.edu",
            "hello@school.22$",
            "h@@h.gov"
        ],
        "id": 1656,
        "output": [
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: \"^[^,]+$\""
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: \"[a-zA-Z0"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: \"test@host[^,]"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: \n^(?:[a-"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: ^(?:\\S+,)+\\"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: test@[a-zA-"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer:.*@.*\"\n\nEx"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: \\b[A-Za-"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: [a-zA-Z0"
            },
            {
                "text": "Validates multiple email addresses that are comma delimited. It allows white space before and after the comma.\nMatch examples:\n- \"Test@host.com\"\n- \"email1@host.com,email2@host.com,email3@host.com\"\n- \"email1@host.com, email2@host.com, email3@host.com\"\nNon-match examples:\n- \"test@test\"\n- \"test@host.com,test@\"Generate a RegEx for this description. \nAnswer: (.*)@(.*),("
            }
        ]
    },
    {
        "expression": "(?=^.{8,}$)(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\\s)[0-9a-zA-Z!@#$%^&*()]*$",
        "raw_prompt": "This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.",
        "refined_prompt": "This regular expression can be used for validating a strong password. It expects at least 1 lowercase letter, 1 uppercase letter, and 1 digit. It will also allow for some special characters. The length should be greater than 8 characters. The sequence of the characters is not important.\nMatch examples:\n- \"Password1\"\n- \"1Passwor\"\n- \"passworD1\"\nNon-match examples:\n- \"q3w4e5er\"\n- \"asdfg\"",
        "matches": [
            "Password1",
            "1Passwor",
            "passworD1",
            "2passWord",
            "Pass2Word",
            "pa1SS2word",
            "!1qAzxsw2",
            "2T@4ep1pVJmza2Ly8",
            "HorDBlMafTTyQOJmJcXXyqUiXo%6WxvKuiJoql@t",
            "d&W)*aVP0%yqd@",
            "gT3fOV)Okf6nKqe",
            "y78jXLETeg%Cc7tm!BryfPOvm5EEnLhBpn",
            "@&j#CV4rzOlbg1g"
        ],
        "non_matches": [
            "q3w4e5er",
            "asdfg",
            "asdfghjkl;",
            "ag asg ag",
            "d36234724",
            "mko)+OKM1",
            "jjjjjjjjjjjjjjjj112",
            "hello",
            "123456789",
            "cv34a678@",
            "---4uhfqlehA",
            "jfejlwerbjhewrj5874"
        ],
        "id": 1657,
        "output": [
            {
                "text": " Use the following regular expression"
            },
            {
                "text": "\n^(?="
            },
            {
                "text": " (at least 1 lower"
            },
            {
                "text": " \n(?="
            },
            {
                "text": " ^(?=.*"
            },
            {
                "text": " The following regular expression will"
            },
            {
                "text": " 1+[A-"
            },
            {
                "text": " Regular expression:  ^"
            },
            {
                "text": " [a-zA"
            },
            {
                "text": "\n```\nimport"
            }
        ]
    },
    {
        "expression": "<body[\\d\\sa-z\\W\\S\\s]*>",
        "raw_prompt": "This will find the open body tag regardless of any properties or Event Handlers associated with it. This is great for global implementations of analytics or anything that needs to be placed after the body tag.",
        "refined_prompt": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"bodyd\\\u2029bc\u180e|H@AwO\"",
        "matches": [
            "<body>",
            "<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>",
            "<bodyb`)>",
            "<bodyN>~ej`\u202fw}f:Q\\s+:z\f\u20026_p\u180e8S^Xt",
            "<bodyCv\u180e\u2006d3\f;o\u1680_\u2002QF|\u2004>",
            "<body+w3d Nig~c\f]q4+6\u180eU{/qgkoB{d&vh`}la.j]BhX\ttYshJ\u00a0sd0\u2002lq^\u000bl(>",
            "<body.\u202fl>",
            "<bodygi\u2001>",
            "<body\"tEi\u1680l\u2003za[>",
            "<body)N]`|\"/oN]O_tqBvA[f\u00a0^n@tKW>",
            "<bodyb0w%s3{<\t6,I*oWhXbg;-mjm\ufeff\u2004\u2029w8Cv{\u16807\u205f1{.nO>",
            "<bodyY+\"y`vtKH\u00a0c,IVe$m\u2029N[sE{:}hj?h\u2003q0p{op>",
            "<bodyM0|kQ1}2TSym\u2000%\u180e\f\u205f\u2007 g`RTP=;alu\u000bP\u180eNlgil9t7}[\\rxnr\u2006\u2004Vi\u1680rpdp\u2006_ gIMS]\u00a0~_|osgE+\u2005]=\u1680\u205fwuOg'j\u1680\ufeffmk<[rd6kJ>"
        ],
        "non_matches": [
            "<br>",
            "bodyd\\\u2029bc\u180e|H@AwO",
            "body{s2\u2006D>",
            "l`g \tjV\u205f,|d7$/8}fj`@?~:JqgkAB\u2007ho\ufeff\u2028-GW=jp W ^\u202fkfxVcy[tD\"xjo23_l-F>",
            "^c]]\u2028Yx\u200a}\u2000\u2008QrE4%-8j,D~a-6x",
            "^c]]\u2028Yx\u200a}\u2000\u2008QrE4%-8j,D~a-6x",
            "fN}n",
            "v'\\/Q\u000b?12oh",
            "oj",
            "^c]]\u2028Yx\u200a}\u2000\u2008QrE4%-8j,D~a-6xbodyZ\"X\fy\u2009Ys<{'P:",
            "bodye\u2003||\u2003\u2029V\u2003.^n\u000b\u2009&]t\u2005lb\u2008\u2000\ufeffXrg",
            "&!--iVpOCz]oik\u20071!\u2005rRGk3@Uwf7\\nNZ\ufeff6a"
        ],
        "id": 1658,
        "output": [
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body b"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"bodyb"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body \\"
            },
            {
                "text": "This will find the open body tag regardless of any properties or Event Handlers associated with it.\nMatch examples:\n- \"<body>\"\n- \"<body\u00a0p\\-,\tfdtU6\f5)oQaaiq-Js\u00a0XS\u200a{\\+Df=c\t{hlu\u3000\u2008\ufeff 02U\u00a0]}$nh}\u2006[<z{;otc\u180ej5\\#`]H*ON\u000b]>\"\n- \"<bodyb`)>\"\nNon-match examples:\n- \"<br>\"\n- \"body\""
            }
        ]
    },
    {
        "expression": "^((\\.)?([a-zA-Z0-9_-]?)(\\.)?([a-zA-Z0-9_-]?)(\\.)?)+$",
        "raw_prompt": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _\nI was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application.",
        "refined_prompt": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.g..1...Kb...n.A..o..r.....v..o.lb-.t.l.U....z.V...W..e..H......p..2.tfeDA.4.S...g.....UH.\"\n- \".I.E..Z.n.d.1.n..mp.2e.J..vAA.C..V...k..F...i.Q.x.F.2..g.N.._Q...h..v.N...5.L.j.x..f..J..._M...Y..5_..j1..W.x..M..n.....A.I..5...6...Yb...\"\nNon-match examples:\n- \"special charachters\"\n- \"hhhhhh jjj\"",
        "matches": [
            "_-.aAa._-.aAa_-.",
            ".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.g..1...Kb...n.A..o..r.....v..o.lb-.t.l.U....z.V...W..e..H......p..2.tfeDA.4.S...g.....UH.",
            ".I.E..Z.n.d.1.n..mp.2e.J..vAA.C..V...k..F...i.Q.x.F.2..g.N.._Q...h..v.N...5.L.j.x..f..J..._M...Y..5_..j1..W.x..M..n.....A.I..5...6...Yb...",
            "...OZ.n..f..Q...oh.....Qm.-.b.",
            "8L.....8.9..z....RuO",
            "..-G.Mmh.i.0.L..t....AV.",
            "i...QA.8..e...MV.jY..u.F",
            "..1.",
            "d.rT..MZ.tQ......fY..C.O6.G..y.S.O....A3z",
            "Xv..Z..-..A.y.1.XE",
            "A..UP.UU.L.1..8...u...u.o.fY...D..A.P.x..H.L...f.6l....",
            "A....b..qq.4.3.L7...S.z...IW...c......-C.B..m.....1..",
            "b.n..p4..tK.yd.3."
        ],
        "non_matches": [
            "special charachters",
            "hhhhhh jjj",
            "... nsd",
            "1 2 3 4 5",
            "#$%@",
            ".....444fef454#",
            "000000 8888",
            "jhhiweh73497&..   edicb",
            "yyyw()",
            "....yyy778i_+",
            "::::",
            "iu2r&43jh"
        ],
        "id": 1660,
        "output": [
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.A"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.n"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.R"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.R"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.I"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.S"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.I"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.C"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.S"
            },
            {
                "text": "Allows letters, numbers, hyphens, periods, and underscores. Such as: Aa.Aa.Aa,.Aa.Aa., -Aa-Aa-, _Aa_Aa_, Aa_Aa_Aa, Aa-Aa-Aa,., -, _\nMatch examples:\n- \"_-.aAa._-.aAa_-.\"\n- \".v.a.p..d.....O.D.f.m.5.4.e...HL...F.HF..n.f...R.V"
            }
        ]
    },
    {
        "expression": "(\\s{1,})",
        "raw_prompt": "Matches all chars that are made up of one or more spaces. I found this useful when people were trying to make string length bypasses using consecutive spaces.",
        "refined_prompt": "Matches all strings that are made up of one or more spaces.\nMatch examples:\n- \"(one or more spaces)\"\nNon-match examples:\n- \"non-space\"\n- \"sf\"",
        "matches": [
            "(one or more spaces)"
        ],
        "non_matches": [
            "non-space",
            "sf",
            "er45",
            "000",
            "^^^^",
            "#welfk",
            "_____.",
            ".....",
            ",,",
            "errvTT",
            "<>",
            "0.000"
        ],
        "id": 1662,
        "output": [
            {
                "text": " (\\S+)\n\nIn this subsection, we covered the use of space in regular expressions which is important in creating patterns for searches and replacements. We also looked at some common patterns and their applications. \n\n## Exercises\n\n1. Create a string variable that contains the word \"apple\" and use a regular expression to find all"
            },
            {
                "text": " /^[^ ]+$/\n\n### Exercise 2\n\nCreate a Python program that reads a file called `students.txt` and matches all student names that start with 'S'.\n\n```\nimport re\n\nwith open('students.txt') as file:\n    data = file.read()\n\n"
            },
            {
                "text": "  \"(one or more spaces)\n\nExercise 2:\nCreate a program that takes a user input of a string and extracts all of the whitespace. \nAnswer:\nimport re\nuser_input = input(\"Enter a string: \")\nwhitespace_regex = re.compile(r\"\\s+"
            },
            {
                "text": " [\\s]+\n\n5. Write a Python program to check if a string has only digits and spaces.\nFor this one, you need to use a conditional statement. Remember the \"if\" statement we used earlier? That can come in handy.\nCode:\nuser_input = input(\"Enter a string: \")\nif user"
            },
            {
                "text": " ^(one or more spaces)*$\n\nExercise 2:\nCreate a Regular Expression that will match the following words: hello, world, python, and stackoverflow.\n\nAnswer: ^(hello|world|python|stackoverflow)$\n\nExercise 3:\nCreate a Regular Expression that will match the following email"
            },
            {
                "text": " \\b(\\s|\\S)+\\b\n\n2. Use the following string: \n\"The quick brown fox jumps over the lazy dog\"\nCreate a RegEx that only matches words that start with the letter 'q' or 'Q'.\nAnswer: \\bq\\w{0,}q\\b\n\n3"
            },
            {
                "text": " (\\s)+\n\n4. Write a RegEx that matches all strings that are written with a hyphen.\nGenerate a RegEx for this description.\nAnswer: -\n\n5. Write a RegEx that matches all strings that are written with a dash at the beginning or end of the string.\nGenerate a RegEx"
            },
            {
                "text": "\n(one or more [spaces])\n\nExercise 3:\nCreate a RegEx for this description. Match all strings that end with a certain word.\nMatch examples:\n- \"the end of a word\"\nNon-match examples:\n- \"word\"\n- \"end of word\"\n- \"none of the"
            },
            {
                "text": " [RegExp]{1,4}[ ]\n\nExercise 2: Use regular expressions to validate a string that only contains lower-case letters.\nAnswer: [RegExp]{1,4}[a-z]+\n\nExercise 3: Write a Python function that takes a string as input and returns True if the string"
            },
            {
                "text": " [a-zA-Z0-9 ]+\n\n3. Write the Python code to match words that start with the letter \"s\" and are between two numbers.\nAnswer: r'\\b\\w{2}[0-9]\\b'\n\n4. Write the Python code to match words that start with"
            }
        ]
    },
    {
        "expression": "[-]?[1-9]\\d{0,16}\\.?\\d{0,2}|[-]?[0]?\\.[1-9]{1,2}|[-]?[0]?\\.[0-9][1-9]",
        "raw_prompt": "Needed to be able to validate positive and numeric values that equate to SQL Server data type decimal(18, 2) but the value could not be 0. This regex does that. If you need to change the precision or scale have at it.",
        "refined_prompt": "Validates positive and numeric values that equate to Structure Query Language (SQL) Server data type decimal(18, 2). The value can not be 0, and negative values can be represented using a dash.\nMatch examples:\n- \"-9999999999999999.99\"\n- \"9999999999999999.99\"\n- \"1\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "-9999999999999999.99",
            "9999999999999999.99",
            "1",
            "1.00",
            "0.52",
            "0.02",
            "236481161166",
            ".1",
            "0.11",
            "762.",
            "9018704677.9",
            "-.5",
            "-731547141.3"
        ],
        "non_matches": [
            "0",
            "0.0",
            "0.00",
            "0000",
            ".0",
            ".000000",
            "-0",
            "+0",
            "-0.0",
            "+0.0",
            "$",
            "."
        ],
        "id": 1663,
        "output": [
            {
                "text": " \\d*(\\.\\d+)?(?:\\.0+)\n- The character '.' must be escaped with a back"
            },
            {
                "text": " ^(?!0)(?!(?:\\.0+?$)|(?<!0)\\.1)0\\d"
            },
            {
                "text": " \"^\\+?\\d*\\.\\d+$|^0+$\"\n\nHere's an example of how"
            },
            {
                "text": " Match only decimal numbers that have a value of 0 or greater, and are not negative values.\n\n```python\nimport re"
            },
            {
                "text": " \"(^\\d+,)?(?:\\.\\d+)?$\"\n\nExercise 3: \nMatch the string"
            },
            {
                "text": " [0-9+]+(.[0-9]{1,2})\n\nExercise 3:\nHow would you"
            },
            {
                "text": " r'(?:\\d+\\.\\d+)'\n\nExercise 2: Match a string where the length is between 10"
            },
            {
                "text": "\n\nimport re\n\ntext = ['-9999999999999999.99', '9999999999999999.99', '1"
            },
            {
                "text": " r'^[0-9,.]*$'\n\n2. Write a RegEx for a string that starts and ends"
            },
            {
                "text": " (.*) (0.|0.0)\n```python\nimport re\n\ndata = \"Name: John Doe"
            }
        ]
    },
    {
        "expression": "^[A-Z\u00c4\u00d6\u00dc]{1,3}\\-[ ]{0,1}[A-Z]{0,2}[0-9]{1,4}[H]{0,1}",
        "raw_prompt": "This one checks if the value is a possible german License Plate. The trailing H stands for Historical cars.",
        "refined_prompt": "This regex checks if the value is a possible german License Plate. The trailing H stands for Historical cars.\nMatch examples:\n- \"F-RM373, W\u00dc-Z1, K- 07333,HN-WK11H\"\n- \"NZ- PQ9954H\"\n- \"LV- IA47H\"\nNon-match examples:\n- \"MOS-AS\"\n- \"hhg\"",
        "matches": [
            "F-RM373, W\u00dc-Z1, K- 07333,HN-WK11H",
            "NZ- PQ9954H",
            "LV- IA47H",
            "Q-KS81H",
            "R-SA69H",
            "JJR-N88H",
            "YQ- OT0",
            "B-6",
            "H- RD80",
            "XLZ-DX0042H",
            "F- DG707",
            "VO-C6586H",
            "LF-696H"
        ],
        "non_matches": [
            "MOS-AS",
            "hhg",
            "1234",
            "HHH-erjnf",
            ".BO-223*",
            "$$$",
            "lol-09",
            "erk09-55",
            "GGKI-0HGGHGHG",
            "-----",
            "uu-99",
            "hello"
        ],
        "id": 1665,
        "output": [
            {
                "text": " ([A-Z]\\w{2}\\-)+[0-9]+\n\n4."
            },
            {
                "text": " [a-z]{3}-[0-9]{2}\n\n3. Write"
            },
            {
                "text": " ^[A-Z][0-9]{4,}[- ]?\\d{"
            },
            {
                "text": "\nimport re\nlicense_plate = re.compile(r'[A-Z]{"
            },
            {
                "text": " [A-Z0-9]{3}- [A-Z]{2}["
            },
            {
                "text": " [A-Z]{5}[-\\s]?[0-9]{4"
            },
            {
                "text": " [A-Za-z0-9]{4}(?:[A-Za"
            },
            {
                "text": " \n[A-Z]{4}[0-9]-[0-9]{"
            },
            {
                "text": " ^([A-Z][0-9]{3})-([0-9]{3"
            },
            {
                "text": " (^[0-9]{0,2}(?:[0-9]{3"
            }
        ]
    },
    {
        "expression": "(a|A)",
        "raw_prompt": "Big or small A letter",
        "refined_prompt": "Capital (A) or lowercase (a)\nMatch examples:\n- \"aaa\"\n- \"aA\"\n- \"Aa\"\nNon-match examples:\n- \"bbb\"\n- \"\u00e0\"",
        "matches": [
            "aaa",
            "aA",
            "Aa",
            "AAA",
            "AaA",
            "aAa",
            "a",
            "A",
            "AAAaaa",
            "aaaAAA",
            "aAaAaA",
            "AaAaAa",
            "aaAaaA"
        ],
        "non_matches": [
            "bbb",
            "\u00e0",
            "\u00e1",
            "\u00e2",
            "\u00e4",
            "\u00e6",
            "\u00e3",
            "\u00e5",
            "\u0101",
            "65",
            "97",
            "\u00c6"
        ],
        "id": 1668,
        "output": [
            {
                "text": " \"aA\" or \"Aa\"\n\n5. Write a Python function that takes a string and returns a list of all lowercase words. Use regular expressions to validate the input and make sure it contains only letters.\nSolution:\n\nimport re\n\ndef lowercase_words(string):\n    pattern ="
            },
            {
                "text": " \n- [a-z]*\n\nExercise 2:\nMatch examples:\n- \"12345\"\n- \"A1B2C3\"\n- \"X1Y2Z3\"\nNon-match examples:\n- \"Abc\"\n- \"12345\"\nAnswer: "
            },
            {
                "text": "\n- \"aA\"[a-zA-Z]|[a-zA-Z][a-zA-Z]\n- \"aaa\"[a-zA-Z]\"|\"aaa[a-zA-Z][a-zA-Z]\"\n- \"aaaa\"[a-z"
            },
            {
                "text": " r'(?=^[A-Z])[a-z]*(?<=[A-Z])[a-z]*$'\n\n3. Write a function that uses RegEx to replace all instances of'red' with 'blue' in a string.\nAnswer:\n\nimport re"
            },
            {
                "text": "\n[a-zA-Z]{3}[bB][a-zA-Z]{3}[a-zA-Z]\n\nExercise 2:\nMatch examples using the RegEx pattern you created in Exercise 1.\nAnswer:\n[a-zA-Z]{"
            },
            {
                "text": "\n\n```\nre.compile(r'^[a-z]+$')\n```\n\n\n# Chapter: The use of Django for Bioinformatician\n\n## Section: Applications of Django Include for Bioinformatician\n\nDjango is a powerful tool for bioinformat"
            },
            {
                "text": " (aa|Aa|aA)\n\nUse case 5:\n\nA group of colleagues is working on a project to create a website that allows users to upload and store files. They want to create a file storage system that uses Regular Expressions to validate uploaded file types and to organize files into folders.\n\nThe"
            },
            {
                "text": " \n\"[Aa][A-z][a-z]\"\n\n3. Write a RegEx for matching a string that starts with the word \"A\", ends with the word \"B\", and contains only one letter in between.\nAnswer: \"^A[B-z][a-z]$\"\n"
            },
            {
                "text": " [A-Za-z]{3,4}\n\nExercise 2:\nMatch examples:\n- \"1a3b\"\n- \"1112aa\"\n- \"AaAaA\"\nNon-match examples:\n- \"abcd\"\n- \"bbb\"\nAnswer"
            },
            {
                "text": " This is a bit trickier, but the correct regex is (?<![a-zA-Z])a(?![a-zA-Z]) in Python.\n\nExercise 5:\nGiven a string \"I am a strong programmer\", write a Python program to replace all lowercase \"a\""
            }
        ]
    },
    {
        "expression": "^([A-Z]+[a-zA-Z]*)(\\s|\\-)?([A-Z]+[a-zA-Z]*)?(\\s|\\-)?([A-Z]+[a-zA-Z]*)?$",
        "raw_prompt": "That is just an improved expression for handling capitalized names. Improvement #1 - Allowed using names consisting of 3 parts. Improvement #2 - Introduced restriction that the name must start from capital character.",
        "refined_prompt": "Handles capitalized names. Allows names consisting of 3 parts. Restriction that the name must start with a capital character.\nMatch examples:\n- \"Rana Mohsin Ali\"\n- \"Hello There\"\n- \"Joe John Smith\"\nNon-match examples:\n- \"rana Mohsin Ali\"\n- \"h\"",
        "matches": [
            "Rana Mohsin Ali",
            "Hello There",
            "Joe John Smith",
            "Jo-Do",
            "Tim O-Malley",
            "Mr Third",
            "I Am",
            "Open-Sesame",
            "ToDaY",
            "OKAY",
            "UUyyHHHtte",
            "I LoefykwI-Ee",
            "JJJkkebdn"
        ],
        "non_matches": [
            "rana Mohsin Ali",
            "h",
            "1234",
            "Hello!",
            "Big little",
            "O'Malley",
            "trust-fall",
            "$dollar",
            "Oka y",
            "\"No Way\"",
            "Okay No so",
            "Five Four 3"
        ],
        "id": 1683,
        "output": [
            {
                "text": " \"^[A-Z][a-z]*[0-9][a-z]*$\"\n\n2. Write a Python code to determine if the given string contains the substring \"password"
            },
            {
                "text": " ^[A-Z][a-z]{0,29}\\.[A-Z][a-z]{0,29}$\n```python\n#importing the necessary libraries and the required"
            },
            {
                "text": " ^[a-z][a-zA-Z]\\s[A-Z][a-zA-Z]$\n\nExercise 4:\nUsing the regex from exercise 3, write a"
            },
            {
                "text": " r'^[A-Z][a-z]+[a-z0-9 ]*$'\n\n2. Generate a Regex pattern that is valid, for the following text:\n-"
            },
            {
                "text": " ^[A-Z][a-z]{1,2}\\s[A-Z][a-z]{1,2}$\n\n3) Write a RegEx to find all emails in"
            },
            {
                "text": ".*[A-Z].*[a-z].*[0-9].*[_-].*[a-z0-9].*[a-z-]\n\nExercise 2"
            },
            {
                "text": " R.M. A.L.I\n\n3. Write a RegEx to match email addresses.\nAnswer: EMAIL@[a-zA-Z0-9.-]+\n\n\n"
            },
            {
                "text": " The RegEx must start with a capital letter and have three words in the middle.\n\n\n\nTitle: Understanding the Impact of Social Media in Daily Life\n\nIntroduction:\nHello there! I'm glad you"
            },
            {
                "text": " \"^[A-Z][a-z]?[A-Za-z0-9]*$\"\n\n3. A user will be asked to enter their full name. Write Python code"
            },
            {
                "text": " \nimport re\n\ndef name_match(name):\n    if re.match(r'^[A-Z][a-z]+[A-Z][a-z]+$', name"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "raw_prompt": "This is a pattern that matches the time format as recomended by the w3c for XML formats",
        "refined_prompt": "This is a pattern that matches the time format as recommended by the w3c for Extended Markup Language (XML) formats.\nMatch examples:\n- \"12:00:12\"\n- \"01:12:19Z\"\n- \"23:59:00-06:00\"\nNon-match examples:\n- \"1:20:13\"\n- \"12:03\"",
        "matches": [
            "12:00:12",
            "01:12:19Z",
            "23:59:00-06:00",
            "18:30:13+01:00",
            "16:06:02.1234",
            "07:51:43",
            "03:36:11",
            "21:43:12",
            "22:21:26.2047",
            "19:08:52.6307",
            "16:45:39",
            "23:21:23",
            "21:29:11|22:18"
        ],
        "non_matches": [
            "1:20:13",
            "12:03",
            "24:00:00",
            "1:20:34",
            "45:3",
            "90-34-7",
            "65:34:32",
            "22:22:22:22",
            "12/34/56",
            "09.34.75",
            "3289384",
            "0"
        ],
        "id": 1690,
        "output": [
            {
                "text": " ^([0-9]{1,2}:\\d{2}:\\d{2})|^([0-9]{1"
            },
            {
                "text": " (.*[\\d:.]+:\\d+[\\d:]+)(-(\\d+[\\d:]+))?\n\n"
            },
            {
                "text": " This is a pattern that matches the time format as recommended by the w3c for Extended Markup Language (XML) formats. Match examples:"
            },
            {
                "text": " \\d(.{1,2}):(.{1,2}):(.{2})\n\n3. Write an expression"
            },
            {
                "text": " \"^([0-9]{2}[:\\/]?[0-9]{2}[:\\/]?)(?:"
            },
            {
                "text": " \n\\d{1,2}:\\d{2}:\\d{2}\n\n3. Given a string, extract the words"
            },
            {
                "text": " (\\d\\d:\\d\\d:\\d\\d)\n\n#Exercise 2\nWrite a Python function that takes a string as"
            },
            {
                "text": " a. \\d{1,2}:\\d{2}:\\d{2} (strict mode) b. \\d{1"
            },
            {
                "text": " \\d\\d:\\d\\d:\\d\\d [A-Za-z]\\d{2}(: [A-"
            },
            {
                "text": " \"^([0-9]{1,2}.{1,2}.{1,2}):([0-5][0-"
            }
        ]
    },
    {
        "expression": "^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((16|[248][048]|[3579][26])00)|(1[6789]|[2-9][0-9])(0[48]|[13579][26]|[2468][048])-02-(0[1-9]|1[0-9]|2[0-9])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?(1[6789]|[2-9][0-9])[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "raw_prompt": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.",
        "refined_prompt": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-20\"\n- \"23:00:00\"",
        "matches": [
            "2007-11-02T18:00:00.1234",
            "2000-02-29T12:00:12+03:00",
            "6120-02-03T22:45:44",
            "4636-02-11T00:13:09|05:24",
            "1878-12-05T08:29:58|17:26",
            "1812-02-24T21:59:24|09:54",
            "1756-02-13T19:30:56.8498",
            "-9223-09-21T08:32:38.9353",
            "1600",
            "4315-01-31T23:27:46",
            "1678-02-06T17:20:12.6420",
            "1768-02-18T22:06:53",
            "8577-11-15T23:25:23.7253"
        ],
        "non_matches": [
            "2005-01-20",
            "23:00:00",
            "54",
            "72/84/0000",
            "90.43.8680",
            "0000.23428",
            "98:02:35",
            "990000000",
            "4839",
            "78:39-4720",
            "4567:23:29",
            "0"
        ],
        "id": 1693,
        "output": [
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-15"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-25"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-29"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            },
            {
                "text": "This pattern matches valid w3c compatible datetime values from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years.\nMatch examples:\n- \"2007-11-02T18:00:00.1234\"\n- \"2000-02-29T12:00:12+03:00\"\n- \"6120-02-03T22:45:44\"\nNon-match examples:\n- \"2005-01-01"
            }
        ]
    },
    {
        "expression": "^(([0-9]|1[0-9]|2[0-4])(\\.[0-9][0-9]?)?)$|([2][5](\\.[0][0]?)?)$",
        "raw_prompt": "this is reg expression for 0.00 to 25.00",
        "refined_prompt": "This captures 0.00 to 25.00.\nMatch examples:\n- \"12\"\n- \"13.1\"\n- \"23.99\"\nNon-match examples:\n- \"26\"\n- \"25.01\"",
        "matches": [
            "12",
            "13.1",
            "23.99",
            "8.99",
            "25.00",
            "1.32",
            "24",
            "21.50",
            "2",
            "6.4",
            "21.71",
            "13.74",
            "8.0"
        ],
        "non_matches": [
            "26",
            "25.01",
            "-2",
            "8.",
            "0.",
            "0.000",
            "+5",
            "78",
            "25.09",
            "0.012",
            "3.145",
            "900000"
        ],
        "id": 1696,
        "output": [
            {
                "text": " ^[0-9.]+$\n\nExercise 3: Using the RegEx from Exercise 2, capture all the price points that are not within 25.00 to 26.00.\nAnswer: Extract matches:\n- \"26\"\n- \"25.01\"\n- \"24.99\""
            },
            {
                "text": " This captures 0.00 to 25.00\n\n\n\nTitle: Exploring the Fascinating World of Mathematics: Percentages and Their Connection to Fractions\n\nWelcome to our website! Today, we will be unraveling the mysteries of mathematics, specifically focusing on percentages and their relationship with fractions. We will not"
            },
            {
                "text": " ^[1-9][0-9]\\.[0-9]{2}$\n\nExercise 3:\nCreate a function that takes a string and generates a list of all the numbers that are found in it. The function should ignore decimal points and commas.\n\nSolution:\n\n"
            },
            {
                "text": " 0-9, 0-9, 0-9, 0-9,.-9, 0-9,.\n\n4. **Find All**\n- Write a regular expression that returns all numeric values in a given string.\n- Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": " (the regex would be [0-9]\\.)\n\nExercise 3:\nCreate a RegEx pattern that will match any string that has been generated from \"random numbers generator\" \na. [0-9]{6,12}\nb. [1-9]\\d{"
            },
            {
                "text": " \"^\\d*\\.\\d*$\"\n\n3. Write a Python program that captures the following date and time formats: \"2020-01-01T01:30:00-07:30:00\" and \"2021-12-31T23:00:00-11:"
            },
            {
                "text": " 1.0-2.9\n\n3. Generate a RegEx for this description.\nExample:\n\"The price range is $0.99 to $10.99.\"\nAnswer: 0.99(?:\\.0{1,1})[0-9]+(?:\\."
            },
            {
                "text": " \\d+\\.\\d(?:\\.\\d+)?|\\d+\n\n4) Create a code that accepts comma-separated number strings. The code should check for valid numbers in them and return the float values.\nExample: Input: \"12,34.5,56.78"
            },
            {
                "text": " [^\\d.\\d]\n\n1. What is the purpose of a RegExp?\n2. What is the benefit of using a RegExp in a search?\n3. How do you import a RegExp module?\n4. What are the most commonly used RegExp characters?\n5"
            },
            {
                "text": " ([1-9][0-9]?[0-9])\\.?([1-9][0-9]?)\nIf (0|[1-9])?[0-9]?[0-9] is not an integer for this description, use ([0-9]|"
            }
        ]
    },
    {
        "expression": "^[\\w0-9]+( [\\w0-9]+)*$",
        "raw_prompt": "Allows \"words\" with alphanumeric characters, including the underscore _ character. Disallows leading or trailing spaces, also doubled-up spaces within the text. If you want to disallow the underscore character, you can replace the two occurrences of \\w with a-zA-Z",
        "refined_prompt": "Allows \"words\" with alphanumeric characters, including the underscore _ character. Disallows leading or trailing spaces, also doubled-up spaces within the text.\nMatch examples:\n- \"Test 000\"\n- \"hrllec\"\n- \"yo_yo\"\nNon-match examples:\n- \"Punctuation! Or doubled up, leading or trailing spaces\"\n- \"to-do\"",
        "matches": [
            "Test 000",
            "hrllec",
            "yo_yo",
            "hey There",
            "123abc",
            "p0asrjYgw6",
            "lol_erf378______",
            "000000",
            "p0_jdgth",
            "variableNameHere",
            "NotreDameFightingIrish",
            "pilates class",
            "There are only 3 apples left"
        ],
        "non_matches": [
            "Punctuation! Or doubled up, leading or trailing spaces",
            "to-do",
            "(no)",
            "\"okay\"",
            "O'Malley",
            "9.0",
            "Mr. Smith",
            "hey       there",
            "Here!",
            "'it's'",
            "no...",
            "where Are you?"
        ],
        "id": 1697,
        "output": [
            {
                "text": "\nimport re\n\npattern = r\"(?=\\S*[a-zA-Z0-9_]\\S*"
            },
            {
                "text": " re.compile(r'(^[^A-Za-z0-9_ ]* +[^A-Z"
            },
            {
                "text": "\n```python\nimport re\n\ntext = \"Test 000\"\npattern = r\"(?<=^ | )\\w+"
            },
            {
                "text": " \n```python\n# Allow one or more spaces between words\nregex_string = r\"\\S+\"\n```"
            },
            {
                "text": "\n[a-zA-Z0-9_]{1,}\n\nExercise 3:\nRewrite the following text"
            },
            {
                "text": "\n\na = \"Test 000\"\nprint re.match(r'^[a-zA-Z0-9_]"
            },
            {
                "text": "\n\n\n\n\n## Chapter: The use of Django for Operations Research Analyst\n### Section: Applications of Django Variables for Operations Research Analyst"
            },
            {
                "text": " To find these types of words, we can use the following pattern:\n[a-zA-Z0-9_\\s]"
            },
            {
                "text": "  ^[a-zA-Z0-9_]{3,10}$\n\n    3.2.10"
            },
            {
                "text": " \n\nimport re\n\ndef validate_input(input_str):\n    # Remove leading and trailing spaces, and ensure all characters"
            }
        ]
    },
    {
        "expression": "^((([\\(]?[2-9]{1}[0-9]{2}[\\)]?)|([2-9]{1}[0-9]{2}\\.?)){1}[ ]?[2-9]{1}[0-9]{2}[\\-\\.]{1}[0-9]{4})([ ]?[xX]{1}[ ]?[0-9]{3,4})?$",
        "raw_prompt": "This regex matches US and CAN phone numbers with area code and optional 3 or 4 digit PBX extention. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.",
        "refined_prompt": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"",
        "matches": [
            "(555) 687-6076 X 1234",
            "(555) 687-6076",
            "555.687.5511x1234",
            "557362.9923 X 0503",
            "(255)227.0300 x9712",
            "803840-7312",
            "(423 488-3032",
            "567 611-9025",
            "973.849.8718 X 171",
            "416 795-4629 x300",
            "210.480-2359",
            "870. 565.4959x1736",
            "384) 253.2721"
        ],
        "non_matches": [
            "555.687.6076 ext 1234",
            "052) 936.3718 x 674",
            "600794.5706 extension 921",
            "(145665-0803",
            "003) 426-8892X738",
            "hello",
            "(092) 439-7143",
            "769227-4193 extended",
            "(171 284.9380X7296",
            "924906.1257 EXTENSION 5154",
            "455586-8513.",
            "3.1415"
        ],
        "id": 1698,
        "output": [
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description\n"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description\n"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description of"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description\n"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description\n"
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            },
            {
                "text": "This regex matches US and CAN phone numbers with area codes and optional 3 or 4-digit PBX extension. It does not check for validity of area code or exchange number, other than for starting with a 0 or 1.\nMatch examples:\n- \"(555) 687-6076 X 1234\"\n- \"(555) 687-6076\"\n- \"555.687.5511x1234\"\nNon-match examples:\n- \"555.687.6076 ext 1234\"\n- \"052) 936.3718 x 674\"Generate a RegEx for this description."
            }
        ]
    },
    {
        "expression": "^[1-9]{1}[0-9]{0,2}([\\.\\,]?[0-9]{3})*$",
        "raw_prompt": "Matches whole numbers with the two most common thousands-separators (comma and period). Will not handle decimals.",
        "refined_prompt": "Matches whole numbers containing the two most common thousands-separators (comma and period). Will not handle decimals.\nMatch examples:\n- \"1,000\"\n- \"1.000\"\n- \"1\"\nNon-match examples:\n- \"1,00\"\n- \"1,0\"",
        "matches": [
            "1,000",
            "1.000",
            "1",
            "10",
            "100",
            "1000",
            "437",
            "759.836,093084705,987.517.723,592269.620,081944.390,336550,035304485486,873109.266730609313.749905642,449,222.037,076861,446017304.405.044493,913194062.798.771,112900814",
            "72,801.076.785809984183027,859207,513,843406919674.077991799,498328.866,060,906708,079.588769.260,058,513992730,051.033,372.656296884,070051,835,739,129,485,237612.818537,691,266749876.830221922922845.793,291.869954116,463856.126.895816.512818.480.373626.448442199529.327752259058273846816044",
            "834120,082168943,321134,373726257.302,182,947.070978623,336577,306,210.171,431133,215,894915437",
            "571.989266,915315.470338,750393",
            "33330.100",
            "3.141"
        ],
        "non_matches": [
            "1,00",
            "1,0",
            "1,,000",
            ".1",
            "10.",
            "3.14",
            ",200",
            "30000000000.",
            "hi93u",
            "$%^#&",
            "3847923875293429,3",
            "2,34238472974"
        ],
        "id": 1704,
        "output": [
            {
                "text": " (?:\\d{1,3}\\.)?\\d{3}\n- \"1,100\"\n- \"1.100\"\n- \"1\"\nNon-match examples:\n- \"1."
            },
            {
                "text": " (?:^|(?<=\\D)(\\d{3})\\D*)(?=\\D|$)\nFor example:\n\nconst re = /(?:^|(?<=\\"
            },
            {
                "text": " \n[0-9]{3,4}(,[0-9]{3,4})?\n\nExercise 2:\nMatch any number in the range of 1 to 100.1 with the appropriate"
            },
            {
                "text": " (\\d{3}[,.]\\d{3})(?!\\d)\n\n3. Write a Python function that takes a list of strings and returns the strings containing only numbers. Use RegEx to match"
            },
            {
                "text": "\n[0-9]{1,3}[,.][0-9]{3}[,.][0-9]\n\nSolution:\n[0-9]{1,3}["
            },
            {
                "text": " (.*)$\n\n3. Create a Regex that will allow the user to enter their own username. For example, \"user-123\", \"user-abc\", or \"user-def\". Your regex should only"
            },
            {
                "text": " \n\n![regex](https://regex101.com/r/QdX3C8/1)\n\nExercise 2: Use a group to match the first five digits of a phone number"
            },
            {
                "text": " \n\\d{1,3}(,\\d{3})*\n\nExercise 2: Using a regular expression, validate a user's email address. The email address should be valid according to the format:"
            },
            {
                "text": " (\\d{1,3})\\.(\\d{3})?\n\nI would like to get a regular expression which can extract the two numbers when there are two occurrences of the period or comma. \n\n"
            },
            {
                "text": "\n([0-9]{1000})([0-9][0-9]?)|([0-9][0-9]?)\\.([0-9]{3})\nI have used this"
            }
        ]
    },
    {
        "expression": "([A-HJ-PR-Y]{2}([0][1-9]|[1-9][0-9])|[A-HJ-PR-Y]{1}([1-9]|[1-2][0-9]|30|31|33|40|44|55|50|60|66|70|77|80|88|90|99|111|121|123|222|321|333|444|555|666|777|888|999|100|200|300|400|500|600|700|800|900))[ ][A-HJ-PR-Z]{3}$",
        "raw_prompt": "UK Vehicle Registration Plate / Number Plate format as specified by the DVLA. Accepts both \"Prefix\" and \"New\" style. Allows only valid DVLA number combinations as not all are supported. Registration number must be exactly as is displayed on car, hence all letters must be in uppercase and a space seperating the two sets of characters.",
        "refined_prompt": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07 TIS\"",
        "matches": [
            "AB12 RCY",
            "CD07 TES",
            "S33 GTT",
            "Y999 FVB",
            "R30 PNJ",
            "JM05 OAO",
            "XH09 DPO",
            "VG01 SZW",
            "UP05 HFE",
            "C70 ACL",
            "O30 WHO",
            "PO08 HGE",
            "YY39 ZBP"
        ],
        "non_matches": [
            "ab12 rcy",
            "CD07 TIS",
            "S34 GTT",
            "Z999 FVB",
            "hello",
            "235",
            "license plate",
            "#### ###",
            "jOhy ge8",
            "johnny appleseed!",
            "9034 ghY",
            "oerh 672"
        ],
        "id": 1706,
        "output": [
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD 07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD07"
            },
            {
                "text": "UK Vehicle Registration Plate / Number Plate format as specified by the Driving and Vehicle Licensing Agency (DVLA). Accepts both \"Prefix\" and \"New\" styles. Allows only valid DVLA number combinations as not all are supported. The registration number must be exactly as is displayed on the car, hence all letters must be in uppercase, and a space separating the two sets of characters.\nMatch examples:\n- \"AB12 RCY\"\n- \"CD07 TES\"\n- \"S33 GTT\"\nNon-match examples:\n- \"ab12 rcy\"\n- \"CD 07"
            }
        ]
    },
    {
        "expression": "^\\$YYYY\\$\\$MM\\$\\$DD\\$$",
        "raw_prompt": "Date Format notations. Mostly used in DB applications where rigorous pattern matching for DATE is required.",
        "refined_prompt": "Date Format notations.\nMatch examples:\n- \"$YYYY$$MM$$DD$\"\nNon-match examples:\n- \"$YY$$MM$$DD$\"\n- \"$DD$$MM$$YYYY$\"",
        "matches": [
            "$YYYY$$MM$$DD$"
        ],
        "non_matches": [
            "$YY$$MM$$DD$",
            "$DD$$MM$$YYYY$",
            "$DD$$MM$$YY$",
            "DD MM YY",
            "YYYY MM DD",
            ".YYYY.MM.DD.",
            "-YYYY-MM-DD-",
            "YYYY,MM,DD",
            "(YYYY)MM$$DD$",
            "/YYYY/MM/DD/",
            "\\YYYY\\MM\\DD\\",
            "date"
        ],
        "id": 1709,
        "output": [
            {
                "text": " \n- \n\n```python\nimport re\n# A regex pattern for MM-DD-YYYY\nMM_DD_YYYY_pattern = '^[0-9]{{2}}-[0-9]{{2}}-[0-9]{{4}}$'\nprint(MM_DD"
            },
            {
                "text": " \n```\n# Python code to generate RegEx for the given description\n\nimport re\n\ndesc = \"a date formatted as ### mm ### dd ### $\"\nregex = re.sub(r'(?<!\\d)\\d+(?!\\d)', '$', desc)\nprint("
            },
            {
                "text": "\n\nimport re\n\n# Generate a RegEx for this description. \nregex_description = r'^(\\d{4})(\\d{2})(\\d{2})\\$'\nprint(regex_description)\n\n# Generate a RegEx for this description. \n"
            },
            {
                "text": " $([0-9]{4})([0-9]{2})([0-9]{2})$\n\nI hope this post has helped you understand how to represent dates in Python and why it's important to consider the date format and notation when working with dates. Happy coding!\n\nBlog"
            },
            {
                "text": " $$\\d{2}$$\\d{2}$$\\d{4}$$\n\nSolution:\n```python\nimport re\n\npattern = r'\\d{2}$$\\d{2}$$\\d{4}$$'\n\n# Generate a RegEx\nregex = re"
            },
            {
                "text": " $(?<month>\\d{2})(?<day>\\d{2})(?<year>\\d{4})$\n\nExercise 2:\nDesign a regular expression that matches all the words starting with the letter \"t\". The match should be case-insensitive.\nCode:\n"
            },
            {
                "text": " \n- (?<![-+])[1-9][0-9]{2}[0-9]{2}(?![-+])\n\n2. Extract the year and month from a string and convert them to a tuple.\nExample: Extract the year and month from the date string \"03"
            },
            {
                "text": " $[0-9]{4}[0-9]{2}[0-9]{2}[0-9]$\n\n4. A website with multiple product pages. Use RegEx to extract the product name from each page.\nExample:\n\nproduct_names = re.findall("
            },
            {
                "text": "\n$(?:\\d{4})(\\d{2})(\\d{2})$\n\nExercise 5:\nGenerate a string using regex that contains all characters from 'a' to 'z' and digits from 0-9.\nAnswer:\n[a-zA-Z0-9"
            },
            {
                "text": "\n\"^(20[0-2]|2[0-4]|[0-9]{2})([0-9]{2})([0-9]{2})([0-9]{4}$)\"\n\nScript:\n\n```\n# Learning about"
            }
        ]
    },
    {
        "expression": "^[1-9]\\d?-\\d{7}$",
        "raw_prompt": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99",
        "refined_prompt": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99\nMatch examples:\n- \"55-5555555\"\n- \"1-2345678\"\n- \"99-9999999\"\nNon-match examples:\n- \"00-1111111\"\n- \"my-einnumb\"",
        "matches": [
            "55-5555555",
            "1-2345678",
            "99-9999999",
            "78-7672408",
            "44-9464154",
            "6-2135630",
            "2-9847327",
            "73-5882703",
            "56-4619115",
            "13-8862486",
            "8-0995747",
            "44-5964939",
            "86-6393915"
        ],
        "non_matches": [
            "00-1111111",
            "my-einnumb",
            "5-55555",
            "6",
            "&&&",
            "sehe",
            "koljwef7",
            "hh-HHHHH",
            "goi96bdj",
            "./program.c",
            "Thought",
            "$56"
        ],
        "id": 1715,
        "output": [
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, A"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            },
            {
                "text": "Accepts valid Employer Identification Numbers (EIN). It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9\\-\\.]+\\.([a-zA-Z]{2,3})$",
        "raw_prompt": "validates after dot operator. matches atleast 2 char and max 3 char.www dot is rejected.",
        "refined_prompt": "Matches at least 2 char and max 3 characters after a period. (www dot is rejected)\nMatch examples:\n- \"yahoo.com\"\n- \"ABC.COM\"\n- \"abc.au\"\nNon-match examples:\n- \"yahoo.c\"\n- \"ABC.argv\"",
        "matches": [
            "yahoo.com",
            "ABC.COM",
            "abc.au",
            "jo.edu",
            "wFQd.vW",
            "Y.9sVl3P.Bbw",
            "ZNOGmDPS1jgpg7zo7RiC.BXy",
            "lfxjpTkvbXg3u.qgL",
            "1SpldVuDsh.Den",
            "QL9.iBY",
            "WOHHWk9SQ.rYK",
            "05G-5Kcjmf4E.qLB",
            "fMy1pgR.DTY"
        ],
        "non_matches": [
            "yahoo.c",
            "ABC.argv",
            ".com",
            "...",
            "hwei.gov---",
            "1234.phf.",
            "hello!",
            "google.edu/",
            "www.com#",
            "lo0",
            "p[.gh",
            "@gmail.com"
        ],
        "id": 1716,
        "output": [
            {
                "text": "\n[^\\s.@,]{2}[^\\s.@,]{3,}\n\nA:\n\nYou can try something like this:\n^[^\\s@.,]{2}"
            },
            {
                "text": "\n    [A-Z0-9.\\-_]+\\.[A-Z0-9]{2,3}\nThe period will be matched if it is the last character after the last non-matching string (e"
            },
            {
                "text": "\n\n```python\nimport re\n\ntext = \"www.yahoo.com\"\npattern = r\"^.{2,3}\\.{1,2}$\"\n\nmatch = re.match(pattern,"
            },
            {
                "text": "  (\\w\\.)+\\.([a-z\\-\\_0-9]\\.[a-z\\-\\_0-9]\\.)+\n\nA:\n\nTry this regex:\n^\\S"
            },
            {
                "text": "\n\"\\w{1,3}\\.([a-zA-z0-9]{3,6})\"\n\n2. Generate a RegEx to match a single word with length 2-9 and a single"
            },
            {
                "text": " \\b(?=.{2,3}\\.\\.)[a-zA-Z]*\\b\n\n2. How would you use a RegEx to search for a domain name that has the first letters of each"
            },
            {
                "text": " \\b[A-Za-z0-9\\-\\.]+\\.\\w+\\b\n\n* * * * * * * * * * * * * * * * * * * * * * * * *"
            },
            {
                "text": "\n\"yahoo([0-9]{1,3}[\\.]{1,3}[0-9])\"\n\n3. Write a Python program to match all email addresses in a given string.\n\nSolution:"
            },
            {
                "text": "\n\n^[^.]+$\n\nA:\n\n    boolean containsUrl(String url) {\n        return url.contains(\"http://\");\n    }\n\nA:\n\nIf you just want to check"
            },
            {
                "text": " (.*)\\.com|^[^\\.]*\\.[^\\.]*$\n\nA:\n\nYou could try the regular expression below and replace with empty string:\n^(?!.*\\.)[\\w\\-"
            }
        ]
    },
    {
        "expression": "(\\[a url=\\\"[^\\[\\]\\\"]*\\\"\\])([^\\[\\]]+)(\\[/a\\])",
        "raw_prompt": "Matches well-formed tags.",
        "refined_prompt": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3-vF?I0q~'f\"]=[/a]\"\n- \"[a url=\"v6Y7LTn~D%oVbxGKkixFl7A%fYT18W{:)_u/%m>cE,a;&-fQ^Ok'Ym'kBxJ=8tQ $/=dVPJX2;L^+uHtqgxp*iUy592XwKr\"]viB)5rQHmmbv)mWqUv/u)@E|/xWHbIqHKT\"RpHWI.z>R/sR(zt:Y`fTF=&d4vn*e\"#Hc&#MSi$olR0R%mgt[/a]\"\nNon-match examples:\n- \"[a]link text[/a]; [a url= \"\"]link text[/a]\"\n- \"e url=\"w@dd=_|JUSbw~tZ*jL4s3#@0H1H+aSN-24d27CIZYh&8c}{,/k\"]/ `tuLJ\\Sp~*1b#h^UE{D+xcctWTq}/\\u@b{_!?0[/a]\"",
        "matches": [
            "[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]",
            "[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3-vF?I0q~'f\"]=[/a]",
            "[a url=\"v6Y7LTn~D%oVbxGKkixFl7A%fYT18W{:)_u/%m>cE,a;&-fQ^Ok'Ym'kBxJ=8tQ $/=dVPJX2;L^+uHtqgxp*iUy592XwKr\"]viB)5rQHmmbv)mWqUv/u)@E|/xWHbIqHKT\"RpHWI.z>R/sR(zt:Y`fTF=&d4vn*e\"#Hc&#MSi$olR0R%mgt[/a]",
            "[a url=\"=xS9<`Z,.dp(Spr}x@Z!yE(NJE2J}=zS@Q{\\\\y{{)S^Aa{h=ZAT'a|go_pqW}L<`KXDSIw?8<`j+8\"]VeSe%T\\fy)Qq'H&\"l4p^gP<qnQi>t#,=wEhpZ}RK3(<N[/a]",
            "[a url=\"*7:.zNan&G6#W!TOr\\DZ|\"])rE#/1|n4ulgLNXU8g3d_$hZ3#-..Z=|+_?oW_p5Y-h?Nn~#l+(,JjOa`lbe9em~Nv[/a]",
            "[a url=\"'mI6GC*&xDksH6@B:>2d9VDMjB*c&yFCh)am(:lYcJH&TI8Uw@l*<=.xz` sW$>\"]@9p&5L^2wmfyy}{<3h3G539,YJB5BsQd87m'TJXF-9D 91<XJ6jUHV.HEE4A&7Q{\\pNQPw+[/a]",
            "[a url=\"b7}h_^j'&DQ+Gv4#^eTCj-Rdlf\"]K.jemZ[/a]",
            "[a url=\"'$@BsfuP-$&33kI?$+ -GZ4OE\"]l0|<h}L0I{M`FWT[/a]",
            "[a url=\"u*$Ku){XNW10s_e+)lpuLQU\\vmyIJ9<V;+oUpZ%33 Au<1?v'IO$SmE*gy9!b\\poL|2y/N\"]d)Y/.U,k 9sY,%7:joE.F~@X2R7<nA1O{/#w.tl>wa,5M7<s2eq|e*^H`z\\t#/#{vok<(D?`}sz03SnmoO[/a]",
            "[a url=\";f20oNC|dc!.%>SO\\O1-Ys=2=jW/$aOvRg??!U=M3w2K+;d(d<x\"]n0_UxRWD\"YQqCya8FhJC5r{;Scic!u7Tr<YEf;>7D;FK)fA4@g[/a]",
            "[a url=\"0O)8pcpLmrtUt0=YXN9u#4j}-xQzIxNP}YX}wCd(SOqz7.;t;;{}uryufRxv}^C.TJoRreyKN|UqT99XB<,z=g_e>p!kd-\"]Z3f,r?IBI$rl\"b0KZ\\>UU32Qk\";.;yA:n-f=NP?YgyIvN(I|kq';l$cyR?j?S#!\\C`<eG/MJ`Gg~!%eR`I!u@A[/a]",
            "[a url=\"qQ6f).Y\"]Rcf||\\sD@( 0!k@C@M=7ao@-^#Am0tYva*_3Co,2@[/a]",
            "[a url=\"rZ/-XafGadYJL^AHRzgMp'?PYBD@(\"]`kEG/ZA3Ow3q13IR?~EfOuxkIs(03yj95%vH/Pw[/a]"
        ],
        "non_matches": [
            "[a]link text[/a]; [a url= \"\"]link text[/a]",
            "e url=\"w@dd=_|JUSbw~tZ*jL4s3#@0H1H+aSN-24d27CIZYh&8c}{,/k\"]/ `tuLJ\\Sp~*1b#h^UE{D+xcctWTq}/\\u@b{_!?0[/a]",
            "[ckUlxaKLZv+hE%8h(tg|.PjD\\ q+O<7?bZ_H:NQyC+z[/a]",
            "[c<<<MdoR74_MLLoKZo?phZ3E@G{Z;5|aUj8W$Z-Es ,f)$aS!d~_%h^BMY1_8`L3n3[/a]",
            "[px url=\"s^RX(z3C.`~^/X%uC97}?PKP@=$cOPh< ZoH*D :*9H?OCEntpUtAM0B7DZ\\<j&R3C72\"]B:t6#~w#e,@2i?QJ#4!:J#$g%X;dA.c',U<%a>Qi5yc)y{Y$S8yFG_q!>u|P* R(Q16n,LQVmJ_{9(Tp,)Wm+LZa\"4[/a]",
            "[p'bU)<AND*!zIgd%i;7-a+!aUvM1BiDs;'ZS>`%u>sIi8`*R2uWDa8\\?<<}kfvRfT-'RaHtVvWKSzZ%#6+#{:SX<[/a]",
            "x url=\"<+vlxLtQ(`Q|+\\VRgSx|n}L`5a<zTopbkVGp'$krgK{zzlXyz|k3n3TR12#mMhUJ>_YEhIWaterHcG#1T'5NjC9\"]PDdof#3w678#z:OsPos@kH3QS[/a]",
            "[pet 1Q`V(H#~1$y,PSOyR\"z,\\6&dyXYV)p1\\X!MWH4a,XS({dh}{'b2j)C^b3R5jZ O=x5$2[/a]",
            "x url=\"y. 3B3\"]ZD\\5J8=VOgFg,<K|\"Mc0P -kO~[/a]",
            "[c^aW||Qc)7oD87m>5Pyj@ z8JL.)If'Aa |mVqLkQ ?b\\\".;f@7_r'[/a]",
            "3 url=\"@XA';4b!iQ'Yx+|w@S3,kA|!QTVJMcH.g<rPOJAERlACY}^m}S1C!'7\"]j=<oeZXB#Q\\-*EG=w$HC da1,Ovh-nL:r,J5MFNsI|VK-/Z%(:!x4w[/a]",
            "3 url=\" 8+^Hx*xeNLz&y0|k\\WN\\t=M\\0rUBu F1|YB!d^!N+lQFJW^Myp0OKz\"]+Sj}\\wNP#)>YD+#F`rE<z_Z2vJkiS,\"d~lDT/c.$_sHcvw\"5oe\\M0rxanfO)w+=)B>DN1+DQ\\^=hNl66.QRJnT^~70V}5p)#p=[/a]"
        ],
        "id": 1723,
        "output": [
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3w"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3l"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3z"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3w"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3g"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3L"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3:"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3l"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3r"
            },
            {
                "text": "Matches URL tags starting with a url = and enclosed within square brackets.\nMatch examples:\n- \"[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]\"\n- \"[a url=\"d@O,EG<@p)8QD$3wQ:^jgjGdk2l6jGf5v~<~l\\Ua`\\.7x&D|U'&NZ!ozdx+XxL_l__hv4*(a,:2J./dk3d"
            }
        ]
    },
    {
        "expression": "(<b>)([^<>]+)(</b>)",
        "raw_prompt": "Gets simple tags without parameters",
        "refined_prompt": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{/$M.lZ+z|0mH05f_X0D};Q V+s5+gs06x%t</b>\"\nNon-match examples:\n- \"<b >important</b>; <b>important<b>\"\n- \"b>kt.ghk={w}Se$R!eQX}p3Q;l\"HpCmhjm|zb`aK</b>\"",
        "matches": [
            "<b>important</b>; <b>anything that should be in bold</b>",
            "<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>",
            "<b>J|tdQcH7~9%T\"8+hD=SB8ls,{/$M.lZ+z|0mH05f_X0D};Q V+s5+gs06x%t</b>",
            "<b>prqujP!Xw(@Es|hwVq_9]^zY#y;vO'r+( 7s%'e2i|}toNw3vR%li}/lk'</b>",
            "<b>CF\\?b`]p-p]5\\?-;G@YNN[;' ,</b>",
            "<b>X#Q|/2\\62&h`N5</b>",
            "<b>G2uM\"Qqwh9^8wOSGD\"</b>",
            "<b>aU`P5(</b>",
            "<b>S&xf?7?j/YyyOd_m:kL$5K</b>",
            "<b>BdUIq9V5)5q2</b>",
            "<b>pm3^rkla19*au1v'tP[Mu6gLUkjD84Gkh!8WGbC_</b>",
            "<b>YI9</b>",
            "<b>^;u)[v)$J\\?O3T`C|cf3M4m!nah0R_|$pX-YTJ\"pkYD{AhV</b>"
        ],
        "non_matches": [
            "<b >important</b>; <b>important<b>",
            "b>kt.ghk={w}Se$R!eQX}p3Q;l\"HpCmhjm|zb`aK</b>",
            "<b>v/t&#J::Ef|z,B`]8...--\\<,L</b>",
            "<<b>0a=0ny2Be<7{7$*1!f|dVu!:B</b>>",
            "<b>#?^@.BcR,,0ntu'9;h*@5N{UppP$5`26J'=G:]=|#zvYp2\\\\:&</b",
            "<b7${o$WD|J`N$s#%`9fn9 i*</b>",
            "<b>Kz&| d0Eb0nkfl*&F)%u`Z|f!c~nDKrd@3=Yf?rH| idvyQ1Mk3fnwh`C{\"yTSlAHL$D,8/{i\"wdgc-;RgQrI@njP3gNNftc{0/b>",
            "<b>>hV5*O4\"0AH7@k7MbIjx,!~zLz[{Q]^k0xP-tGpQ\".gUAMg_56|]@XkEG n8bz*Wxy&4p0&]OX<</b>",
            "<b>$I}&IeatV}<//b>",
            "<b/>//:M_SuFgIi=A1J2D@8@.DC</b>",
            "<b/>PouF;hu8d6]:wnPS]?v^s0;*0g3PQkk'4b!YY3 uBF\\DY_$y}\\eX6EGX\"A6PE%L3`y%u5pCG2?qWXBN#</b>",
            "<b>*3hI9?U?_yMh+hunK6)2G$+-.mlHn$xrM5GRS6]p;6</b/>"
        ],
        "id": 1726,
        "output": [
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{<"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{%"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{x"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{0"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{F"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{d"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{g"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{f"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{H"
            },
            {
                "text": "Matches tags that do not have any parameters.\nMatch examples:\n- \"<b>important</b>; <b>anything that should be in bold</b>\"\n- \"<b>Aaf&,iL+3Y]#)/B|z&%q\\@G't,h%Klob,/fb8U38h/=EMCe3c^WPL%y_veC4f[zg=x</b>\"\n- \"<b>J|tdQcH7~9%T\"8+hD=SB8ls,{5"
            }
        ]
    },
    {
        "expression": "^[-+]?([0-9]{1,3}[,]?)?([0-9]{3}[,]?)*[.]?[0-9]*$",
        "raw_prompt": "matches numeric value with optional +/- , optional decimal point, and optional commas",
        "refined_prompt": "Matches numeric value with optional +/- , optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abcde\"",
        "matches": [
            "-12,345,678,012.98765",
            "+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475",
            "-82799504,549967255.05381746",
            "+0.000000",
            "-0.00",
            "4.05",
            "-136831,803,796.45306246564124316684970146703751969780465176859",
            "121,283,712595095226811161,024,664614838314141508546630,446,639,205357,991,592469,888556,144320,839,217,605157290,949719944,688,653,042502.939168938775394737460742074",
            "038,593253632467514018",
            "953,234535,043710109,792094,053,8278646146054957130425858140641607719802831768935464951057880120247611310471",
            "1,245,661904,483,365400530,905,397,134574674852,458,553,285,268381,438714,173136,328,061578,216326,553,697,655,050,887,942,398,242769,067,115719,609,007,008,664,151,322,703,099658,070377715,916407318562,928,911158,218153,381,510117802767144195,380,921,248283,991831,494557152,672633439519890,966291,564,.",
            "9000",
            "999994"
        ],
        "non_matches": [
            "1,45.098",
            "abcde",
            "##",
            "t53",
            "73b",
            "twenty",
            "%0.07",
            "$46",
            "0x10",
            "010b",
            "9+4",
            "=24"
        ],
        "id": 1736,
        "output": [
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc\""
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc,"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc-"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc\""
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc\""
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc\""
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc\""
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc,"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc,"
            },
            {
                "text": "Matches numeric value with optional +/-, optional decimal point, and optional commas\nMatch examples:\n- \"-12,345,678,012.98765\"\n- \"+329162643,239806987,332,180,897,161,621386,244,949,556,348,565,319,258,424726092,548678926578321189966475\"\n- \"-82799504,549967255.05381746\"\nNon-match examples:\n- \"1,45.098\"\n- \"abc,"
            }
        ]
    },
    {
        "expression": "([\\r\\n ]*//[^\\r\\n]*)+",
        "raw_prompt": "Matches groups of single-line code comments. Comment sections will be returned as a single match.",
        "refined_prompt": "Matches groups of single-line code comments. Comment sections will be returned as a single match.\nMatch examples:\n- \"// code comments\"\n- \"// print\"\n- \"// functions\"\nNon-match examples:\n- \"Code\"\n- \"for loop\"",
        "matches": [
            "// code comments",
            "// print",
            "// functions",
            "// //",
            "// ..8",
            "// this is a method",
            "//                    //ZYwO;)g?^B|CLC2s}?sGuv=r\"7qf[CMSgcla3)3II1{.*zX1\"3u^k;h2dC>\\4A3u.&           //2?o|=B~p^T-6d:x!Suo:`9BpO=CCJh\\wB6,b[:=y$Sfs8.Dp%@D6\\DZWvz)V(         //C1Akh\\@`}<z%%S-EOA]]X62#yt\\(DNp ;}^0A5Vmm.RBI`dw-a86+Dn=$%&\":\\XL;(T,mUzNj|GVfGgPrpB'fi                                      //k1=T;wIJv;^k_$R&7U1$tp~WDM?=U~fXrbfF+?6Cr#_t'F-=^@XT`=s.>>!,K1q:pV(H)Q%*`|L1ML7@oc                          //.L#3 [G_e<$&u'Bu.bE0'ymU1[bLdV&\"GKo6;2=gAVRLu@Ucz>mCnq)9m^T}^o5$KeUEPXspALC!2A:H?                                                 //oCH_&\\p                           //a{epp]                          //o^a-0n-W-!Woc\\'|D$ Qe_^~z'C`.p^<~(lYj;^w@SA~^:gPK\"Od^xU,         //s\",[4[i                         //<XS_Nav !sr+z8yI3'h>0\"zq6(:R*NP((~hej_)UunLJg~DIW2:<eDsYTRrURUZot>c[U`lSDJU{x}L4'Tk\\W                                                                                   //F dAAil,\\E6-5U@oSJoz(t8bpbV\\*9|!@K$T1Y[73KzhFy;(]S2%2$Z@+``LYzLRw2qZ^rosYpNDs#8IZ y$^0oW>uo[m                                                                                 //+ :\\&0Pr4rd?R\\\\;TIod4w\\bdRB\\Tt '&.%n(6_                                                                                  //(e!F\\r*b;|m\"{MPWL`v(E_pI4m74$/m?IIQ9/EPZ$HQhuQ<#kX$                                      //(BEOmQnP(G\\Esm*1vw+);E{dXvH$CG                                                                                      //<rWb!N^HW|> Ht/,,UE               //.pL;Yk?i-'`OegcMpzcc(qKccElz$hh<r_bj&0fZAai9,s                   //[f$6hd#3RZbeNOl\"7NIm]B%^UO?M!>4&t|RvT%:KH0oe;L,Q{%78ewi{9I}\\nA@                                                                              //&;tm4Q%\\5\"DLw|L%R~u$;4j&?+{A |Dk/^ivzvL-/37X2pkV6UcCE2wj#R'-~H-                                           //bS)r&9U[76H$#VS?J6tq@$?X",
            "//bG&a|vJvPUocjoPMXf<9wK`@<1hFX`_s:MXV<_UV6u u!6[%}O,E-_4>/s+TnX1\\k)XQ69   //k!-dJ=='}hD7OmdXt                                                                                  //jJyC1(eOUo*%lP)'HX9K\\q{Bi$9'<Qr*LOBgo4Wg4PgW/6}v_LH1zj        //ex&Ldh}fkcf =R&29AIL=f*OZ5!4_A\\s<Fs\"hY </&]SG.{']}-7:w$:Qv7rxiHLn VK5(|(]X<>P_#,fPu82H,<9X!h[/1h(                                                         //1y7 EV*i^Mi|4b9@l=tE!D/,qkmTLurh<ShEZ;qQ$W-                                                       //>~Y*cO%,&u`FFd}JuhQY\"<Ha3r$)$Q^(Fmtb6OP]H|@4l((m1rKlS9?3~U1qqmD2A85W\"A'JgOGM]nv_24                                    //X3QV=b@#n/.EuOc]H)+mn<KEu)V{/eD!)U:U<@MQj9&RCOCZ5{y7:<*lenr>)hdUt D\".vg^I>j[|F*]&Yv!Y;\\%VxZo[dr(a9 |        //'5Q)sx~?dppQ('+Q                                                                            //MITS/{Yi#Lo\\\"zmu4IJ05IOMu                                                                                                    //.~'Ar54KD}-S}+^$%[*)C YV/Peag({_R{X|kX{~|_Cyq?T?GpI~[[pp;x@rp&i^)[RRgkVli:rbpMxa+D                                          //6s5=<A/tzmWFK#BQ@I",
            "// ||| \\\\\\",
            "// ?",
            "// 8 + 2 = 10",
            "// for loop",
            "// <>"
        ],
        "non_matches": [
            "Code",
            "for loop",
            "while loop",
            "int num;",
            "num += 1",
            "free(buff)",
            "Python 3",
            "#comment",
            "000",
            "/ no",
            "-",
            "<>"
        ],
        "id": 1739,
        "output": [
            {
                "text": "\n\n```python\n# code comments\nprint(\"Hello World\") # print is not a comment, so it should not match\nfor i in range(5): # print is a single-line comment, so it should match\n    print(i)\n"
            },
            {
                "text": "\n```\nimport re\n\npattern = r'\\w*\\s*\\/\\/(.*)'\n\ntext = \"\"\"\n// code comments\n// print\n// functions\n\"\"\"\nmatch = re.search(pattern, text)\n\nprint(match"
            },
            {
                "text": " ^Code.*$\n\n## Python Exercises\n\n1. Write a Python script that outputs all the lines of code with single-line comments in a given file.\n2. Write a Python script that outputs all the functions with single-line comments in a"
            },
            {
                "text": " \n```python\n# Code\n# The following are valid Python code comments\nprint(\"Hello, world!\")\n# Print the following\nnum = 10\nprint(num)\nprint(\"Goodbye, world!\")\n```\n**Exercise"
            },
            {
                "text": "\nimport re\n\ns = \"\"\"\n# Code\n// print\n// functions\n\n# for loop\n\"\"\"\n\ncomments = re.findall(r'//.*?', s)\nprint(comments)\n\nExercise 1: \nCreate"
            },
            {
                "text": " for (i = 0; i < 5; ++i) should be \"for (i = 0; i < 5; ++i)\"\n\nExample code:\nimport re\n\n# Define the text to search\ntext = \"This is a sample text"
            },
            {
                "text": " (?:^|\\s)(Code|\\bfor\\sloop\\b|\\bprint\\b|\\bgrep\\b|\\b\\grep\\b)(?=\\s|$) \nExercise: Write a Python program that"
            },
            {
                "text": " ^\\s*//.*$\n\n4. Write a RegEx for a string that only contains uppercase letters and hyphens.\nAnswer: ^[A-Z][-\\w]*$\n\n5. Write a RegEx for a string"
            },
            {
                "text": " Code - ^Code.*$\n- \"for loops\"Generate a RegEx for this description. \nAnswer: for ((i=0; i<1000; i++)) \n- \"if statement\"Generate a RegEx for this description. "
            },
            {
                "text": " \n\ndef my_function():\n    return \"This is a function\"\n\n# Question 2: How to extract the code comments from the function `my_function()`?\n# Answer:\n\nimport re\n\nmatch_obj = re."
            }
        ]
    },
    {
        "expression": "(@\\s*\".*?\")|(\"([^\"\\\\]|\\\\.)*?\")",
        "raw_prompt": "Matches C# string literals; verbatin and or normal.",
        "refined_prompt": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l^;wK:6,JQi?AE-R:R\"\"\nNon-match examples:\n- \"text\"\n- \"<>\"",
        "matches": [
            "\"text\" \"te\\\"xt\" @\"text\"",
            "\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"",
            "\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l^;wK:6,JQi?AE-R:R\"",
            "\"2Mv>G5GI!\\AU+oR?7J0zPX\"x\"VQ}N8&-Xo<{\"",
            "\"%6A2\\F{\\]\\;X\"",
            "\"z%\\4t}h`m*9uYq/bJM[yY)h+HX,.)D^+K}d%S@}zAfF0o!Ge&\"",
            "\"\\Y\\_\\q;\\?y\\6{\\/ ?\\&\\3\\;]rdt\\\\ns\\I^\\Ls\\-\\`djnu&&\\I\"",
            "\"mt[J~.UdB\"7ae2f7\"m_'$p|L'|:x,[LcLot\"",
            "\"\\b\\`:Q]\\V\\6\\bEA>=\\7\\2}\\c)(\\$\\(6H\\Q\\^Z0G\\~\\/g_vu&\\a=\\S\\B\\D\\CL\\'\\Q\\t\\n\\<\\!l*?[SOiz\\C}\\s-\\E\\B\\t>yc+\\~\\?s8\\^\\@\\Og\\Tn7\\YG\\']\\('\\8:I\\9\\@\"",
            "\" :!ToDd$_bBw!1vqIj1V~.1HL65!&1<'KZ$ySlgS.Y[8FVL4)eNla^ZX7\"",
            "\".,kO?sG('VxLOO6H\".2?-!kGvq#?Ss0u\\GFxD^]bvYJ<rOeIL(Ixd=s*0U|;1LtY?\"xgg\"},#]\"",
            "\"f_|p*=R16VW]sb}6Gb#1x\"x~+!c8a%8' 3[Mv\\/G(nlI=}\\% B7Ed:VW-6FoX|XR<:K],7!3/<=LYT?5GZ+;\\@k3.\"",
            "\"HUKzhm}#%9rUmcm]\"(b/_xA1*|1tDs`ogk'&8;6z!%CiIp\""
        ],
        "non_matches": [
            "text",
            "<>",
            "0",
            "#C",
            "=5",
            "123",
            ";",
            "'hello'",
            "{thank}",
            "&and",
            "$dollar",
            "@gmail"
        ],
        "id": 1740,
        "output": [
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l\""
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l\n"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:lH"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l{"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l:"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l|"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:lQ"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l="
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l6"
            },
            {
                "text": "Matches C# string literals; verbatim and or normal.\nMatch examples:\n- \"\"text\" \"te\\\"xt\" @\"text\"\"\n- \"\"#yQ\\]_\\H\\8\\~&\\G[76\\%.w/\\G\\f%\\+\\?\\[\\_N\\3j\\gly[\\E\\R\"\"\n- \"\ufeff\u3000\u200a\u1680\u2005\u2006\u202f\u180e\t\u205f\u2005\u000b\u3000\u3000\"HQ.sf}7A4B7?|:l\ufffd"
            }
        ]
    },
    {
        "expression": "^[A-Z]$",
        "raw_prompt": "Matches one Upper-case US ASCII Letter.",
        "refined_prompt": "Matches one Upper-case US ASCII Letter.\nMatch examples:\n- \"A\"\n- \"B\"\n- \"Z\"\nNon-match examples:\n- \"a\"\n- \"1\"",
        "matches": [
            "A",
            "B",
            "Z",
            "Q",
            "O",
            "K",
            "F",
            "N",
            "G",
            "I",
            "T",
            "J",
            "L"
        ],
        "non_matches": [
            "a",
            "1",
            "AA",
            "@",
            "0",
            "?",
            "96",
            "string",
            "\"A\"",
            "&",
            ".0",
            "|"
        ],
        "id": 1742,
        "output": [
            {
                "text": " [^A-Z]\n\n### Section 5: Use of RegEx in Python\n\nIn Python, you can use the re module for regular expressions. The regular expression module provides several functions, such as findall, search, split and sub, each with specific functions to perform on a string.\n\n```python\nimport re"
            },
            {
                "text": " (?i)^[A-Za-z]+$\n\nExercise 2: Write a regular expression that matches any date between the year 1970 and the current year.\nAnswer: (?i)^(20(0{1,2}|1{1,2}|2{1,2}))("
            },
            {
                "text": " (?i)[a-zA-Z]\n\n3. Write a regular expression to match a URL. \nAnswer: (?i)[^a-zA-Z0-9._%]+\n\n4. Write a regular expression to match all sequences of 4 or more consecutive digits (e.g. \"12"
            },
            {
                "text": " \n[A-Z]|[a-z]\n\n2. What is the difference between a dash and a slash in a RegEx?\nAnswer: \nA dash (-) can be used to indicate a range of characters, eg a-z, A-Z, 0-9, _, _. A slash"
            },
            {
                "text": "\n^(?=.*[A-Z]).*$\n\nQ:\n\nIs there a way to calculate the sum of two numpy array elements when the sum is a list?\n\nMy issue is when I try summing two numpy arrays element by element as follows:\nx = np.array([[1,"
            },
            {
                "text": " [^A-Z]+\n\n2. Write a Python program to find all the numbers in a string.\n\n```python\nimport re\n\nstring = \"The price of the item is $23.45\"\nnumbers = re.findall('[0-9]+', string)\nprint(numbers)"
            },
            {
                "text": "\n\nlower_case_letters = re.compile(\"[a-z]\")\nupper_case_letters = re.compile(\"[A-Z]\")\ndigit_nums = re.compile(\"[0-9]\")\nall_chars = re.compile(\"[a-zA"
            },
            {
                "text": " ^\\p{Lo}+$\n\n(n): Use the ^ anchor at the start of a string and $ at the end of a string to specify a range.\n\nExample:\nimport re\nimport nltk\nfrom nltk.tokenize import word_tokenize\n\n# Example sentence to be tokenized"
            },
            {
                "text": "\n[(a-zA-Z)]\n\nExercise 3: \nWrite a Python program that generates a regular expression for this description.\n\nThe first character must be a lowercase letter.\nThe last character must be an uppercase letter.\nA sequence of lowercase letters, digits, dots, or hyphens"
            },
            {
                "text": " The regular expression for the \"A, A, A\" would be \"A+\"\n- \"a\"Generate a RegEx for this description.\nAnswer: The regular expression for the \"a\" would be \"a\"\n- \"1\"Generate a RegEx for this description.\nAnswer: The regular expression for the"
            }
        ]
    },
    {
        "expression": "^\\d+\\.\\d\\.\\d[01]\\d[0-3]\\d\\.[1-9]\\d*$",
        "raw_prompt": "4 part version numbers",
        "refined_prompt": "Matches numbers in four parts separated by decimals.\nMatch examples:\n- \"0.0.60829.1\"\n- \"100.3.60931.5\"\n- \"5.1.11219.7\"\nNon-match examples:\n- \"1.1.60849.1\"\n- \"0.20.10.60810\"",
        "matches": [
            "0.0.60829.1",
            "100.3.60931.5",
            "5.1.11219.7",
            "442795460408966421231034607812869.9.90207.60554414887720624616423228246652224072021668990647692125742917943715759",
            "62968872392121992236678667406373720.9.21105.668964161197",
            "129187636914477466.3.70826.62497771145730689889638958708",
            "965.3.00532.8730945",
            "902344.9.80634.752841585589248337434639",
            "969440481329031075583792.3.70715.37524678135716819676649",
            "905064780096580417.3.51314.29922459587203823",
            "6.8.41103.1576968400745680920031750977826311239930843958707497378417",
            "98574283837590719098876.0.31427.198713376629080708233620249117",
            "036260.6.00321.4019098469284418582847833093"
        ],
        "non_matches": [
            "1.1.60849.1",
            "0.20.10.60810",
            "1.1.11219.0",
            "0",
            "....",
            "0.0.0.0",
            "99.99.99.99",
            "1839.4.8342.88",
            "5%",
            "0.05",
            "23.34587.239.45",
            "092.472.21"
        ],
        "id": 1744,
        "output": [
            {
                "text": ".*\\d+.\\d+.\\d+.\\d+\n\n4. Create a Python function that takes a string and a list of words (e"
            },
            {
                "text": "\nExample: \"0.0.60829.1\"\nNon-match: \"1.1.60849.1\"\nNon-matching"
            },
            {
                "text": " [0-9.]{1,4}\\.[0-9.]{1,4}\\.[0-9.]{1,4}\\.[0-"
            },
            {
                "text": " (0\\.[0-9]*?\\.[0-9]*?\\.[0-9]*?\\.1\\.)|(0"
            },
            {
                "text": "\n\".*(?<pre>\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)\".*\n\n\n\n\n"
            },
            {
                "text": " [^\\d]*(\\d+).*(\\d+).*(\\d+).*(\\d+)\n\n2. \nWrite a Reg"
            },
            {
                "text": " (^0.\\d+\\.\\d+\\.\\d+\\.\\d+$).\n\nExercise 4:\nMatch numbers in a string"
            },
            {
                "text": " (.*)\\.\\.(.*)\\.\\.(.*)\\.\\.(.*)\n\nExercise 2: \nFind the number of strings that are"
            },
            {
                "text": " \n\n(.*)\\.(\\d+)\\.\\.(\\d+)\\.(\\d+)\\.(\\d+)\n\nExercise 3: "
            },
            {
                "text": ".*\\.\\d+\\.\\d+\\.\\d+.*\n\nIn this example, the regex pattern looks for a string that starts with any number"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]{1})|(1[0-2]{1}))\\/?(([0-2]{1}[1-9]{1})|(3[0-1]{1}))\\/?(([12]{1}[0-9]{1})?[0-9]{2}) ?(([01]{1}[0-9]{1})|(2[0-4]{1}))\\:?([0-5]{1}[0-9]{1}))$",
        "raw_prompt": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.",
        "refined_prompt": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits.\nMatch examples:\n- \"01/15/07 1745\"\n- \"011507 1745\"\n- \"01/15/2007 17:45\"\nNon-match examples:\n- \"13/15/07 1745\"\n- \"013207 1745\"",
        "matches": [
            "01/15/07 1745",
            "011507 1745",
            "01/15/2007 17:45",
            "0115071745",
            "06/311172 1119",
            "12/13/46 21:15",
            "07/26/092134",
            "1026/2851 01:13",
            "1003/660617",
            "040175 04:40",
            "1231/1920:26",
            "09/02/2043 24:40",
            "04/2512412204"
        ],
        "non_matches": [
            "13/15/07 1745",
            "013207 1745",
            "01/15/2007 25:45",
            "0115071762",
            "0525/1247 20:4",
            "10132816 08-18",
            "10-06-2151 21:46",
            "05/0632 0308/",
            "\"1231/2309 15:52\"",
            "1131.2351 23:03",
            "0223/1073 20/31",
            "03/02/321823/20/20"
        ],
        "id": 1751,
        "output": [
            {
                "text": " \"^"
            },
            {
                "text": " ^("
            },
            {
                "text": " /(["
            },
            {
                "text": "\n^"
            },
            {
                "text": " (a"
            },
            {
                "text": " [0"
            },
            {
                "text": " (at"
            },
            {
                "text": " (\\/"
            },
            {
                "text": "\n("
            },
            {
                "text": " \\d"
            }
        ]
    },
    {
        "expression": "^(([A-Z])([a-zA-Z0-9]+)?)(\\:)(\\d+)$",
        "raw_prompt": "Validate if server and port is valid.",
        "refined_prompt": "Validate if server and port is valid.\nMatch examples:\n- \"MyServer:8080\"\n- \"K:916964174854221123755333757035\"\n- \"IzUa8HTdKgD8bUk:8157711142609\"\nNon-match examples:\n- \"1Server:A1\"\n- \"Server:AAA\"",
        "matches": [
            "MyServer:8080",
            "K:916964174854221123755333757035",
            "IzUa8HTdKgD8bUk:8157711142609",
            "B:6093721465817347439454818842777205850090392542163146979124974567683616828601730364997632748896",
            "G:733506794090195569501552501905566503552282352935558843177510957808509",
            "NkZY3lkMtXNljMa6C3LSnr1HX75U:958827292561865282825841388981940773250208351884203985003",
            "J:247092532870101998028891324413747821850598170515524948665",
            "Z:76581707605816613065556879933323310887961410106517031142245055572203027885776544058926",
            "V:2952418552757349225694235573561600221347597607882611585123729095065733729884598848459464755919",
            "JGrfW97RuXTC3UVfnfbMifli6RiRhahozetikYyk9:1241575032",
            "F:164707075650853891972138704503134812",
            "Q:9185646787437",
            "Y:2957769071686012193332"
        ],
        "non_matches": [
            "1Server:A1",
            "Server:AAA",
            "port",
            "server",
            "43489:efnw",
            "iwefH:384rj",
            "L:3434j",
            "P:39-",
            ":",
            "9:0",
            "2323:4rc",
            "frei:93hdfH"
        ],
        "id": 1756,
        "output": [
            {
                "text": " \"^([\\w\\d\\.-]+):([\\d\\d\\.]+)([\\w\\d\\.-]"
            },
            {
                "text": " ((Server:)(\\d+)([A-Za-z*]))\n\nExercise 2: \nCreate a"
            },
            {
                "text": " ([A-Za-z0-9][A-Za-z0-9\\-]*[A-Za"
            },
            {
                "text": " [a-zA-Z0-9:]+\n\nExercise 3: \nWrite a Python code using regular expressions to"
            },
            {
                "text": " \n[A-Za-z0-9]\\s?[A-Za-z0-9]\\"
            },
            {
                "text": " ^[a-z0-9._-]+:[0-9a-z0-9._-]+:[0-9"
            },
            {
                "text": " \"^[A-Z]+:([A-Za-z0-9\\+\\-\\*\\$]*)|"
            },
            {
                "text": "\n(?<=Server:.*:)(?<val>[A-Za-z0-9]+):|(?"
            },
            {
                "text": "\nimport re\n\n# create a regex that matches at least one number, a colon, and at least one letter after the colon ("
            },
            {
                "text": " A:.*(?=Server:)([0-9]{6})\"This regex will match all passwords that begin with server"
            }
        ]
    },
    {
        "expression": "(^([0-9]*[.][0-9]*[1-9]+[0-9]*)$)|(^([0-9]*[1-9]+[0-9]*[.][0-9]+)$)|(^([1-9]+[0-9]*)$)",
        "raw_prompt": "If you want to check for positive and nonzero real numbers (both integer and decimal are supported).",
        "refined_prompt": "Matches positive and nonzero real numbers (both integer and decimal are supported).\nMatch examples:\n- \"1.234\"\n- \"1234\"\n- \"0.123\"\nNon-match examples:\n- \"0\"\n- \"0.0\"",
        "matches": [
            "1.234",
            "1234",
            "0.123",
            "01.2345",
            "8913069473.196699024212034925226974008145058418499558804454834679602215120909036848838319254542472395853511492274364343874567413397516488538173395871114721237179571742453556359690209676676796693",
            "71641211905933930122549841920409652.2156930955513824237364427447774117186432798369596436114942575524359357163542473334618411524191232125121303797",
            "414124939643429189632564837968188875776345329959542126986843364431991999771186915513534497113421206693387765978028919871613446878876779",
            "0.02",
            "999999",
            "23948.83942",
            "23.32",
            "3901.483948",
            "23.0000005300000000"
        ],
        "non_matches": [
            "0",
            "0.0",
            "-123.45",
            "-12345",
            "abc123",
            "12..34",
            "0.",
            "5%",
            "(602)",
            "2+5=7",
            "0239",
            "+9"
        ],
        "id": 1762,
        "output": [
            {
                "text": ".*[0123456789].*(?:[1-9][0-9]*)?(?![0\\-][0-9]*$)\n\n\nMatch examples:  \n- \"1-1-1-2-3-4-"
            },
            {
                "text": " ^(?:[1-9]\\d*(?:\\.\\d+)?|0+)|(?:0+(?:\\.\\d+)?)$\n\nA:\n\nA small hint, but using the \\d regular expression will match any decimal value"
            },
            {
                "text": " \"^[-+]?[0-9]*\\.?[0-9]+$\"\n\nExercise 2: Write a RegEx to match any string that starts with a digit and ends with a letter.\nAnswer: \"^\\d[a-z"
            },
            {
                "text": " r'^(?P<negation>not)?(?P<number>\\d+(?:\\.\\d+)?)(?P<punctuation>\\W+)?$'\n\nExercise 3:\nCreate a RegEx for IP Address validation"
            },
            {
                "text": " [0-9]\\d*\\.\\d*|[0-9]\\d+\n\nExercise 3: \nCreate a RegEx pattern that matches email addresses.\nAnswer: [a-zA-Z0-9._%+-]+"
            },
            {
                "text": " \\d.\\d|\\d\\d\n- \"0.0\"Generate a RegEx for this description.\nAnswer: \\d\\.\\d|\\d\\.\\d\n- \"1234\"Generate a RegEx for this description.\nAnswer"
            },
            {
                "text": " ^(?=\\d+\\.\\d+$)(?=\\d+$)^.+$\n\nExercise 5: RegEx for Email Address Validation\nCreate a RegEx pattern to validate an email address.\nAnswer: ^[a-z"
            },
            {
                "text": " \"^[0-9]*[\\.]?[0-9]+[eE][0-9]+$\"\n\n3. Write a RegEx to match an email address.\nAnswer: \"^[A-Za-z0-9._"
            },
            {
                "text": " [0-9][0-9]\\.?[0-9]\n- \"1\"Generate a RegEx for this description.\n\n``` python\n# RegEx for Positive and Non-zero real numbers\npositive_number = r\"[0-9"
            },
            {
                "text": " (^[0-9]+(?:[.][0-9]+)?$)\n\nExercise 5:\nMatch the following words with their meanings\n- \"Honey\"\n- \"Sugar\"\n- \"Dessert\"\n- \"Beverage"
            }
        ]
    },
    {
        "expression": "^[1-9]\\d*\\.?[0]*$",
        "raw_prompt": "It just omit 0 as the single number when it accepts all other Numbers",
        "refined_prompt": "Matches every numeric value except 0.\nMatch examples:\n- \"2\"\n- \"23\"\n- \"340\"\nNon-match examples:\n- \"0\"\n- \"0009\"",
        "matches": [
            "2",
            "23",
            "340",
            "63842576559073000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "15233185620022623016.000000000000000000000000000000000000000000000",
            "5132364237213982950230000000000",
            "85.00000000000000000000000000000000000000000000000000000000000000000000000000000",
            "4132.0",
            "82867.0000000",
            "4332",
            "654",
            "9432",
            "23987402987439"
        ],
        "non_matches": [
            "0",
            "0009",
            "070",
            "9.3",
            "7342.348",
            "5%",
            "number",
            "zero",
            "-348",
            "+934",
            "#3242",
            "(605)"
        ],
        "id": 1763,
        "output": [
            {
                "text": "\n^\\d+$\n\nExercise 3:\nMatch every character but the one between \"a\" and \"u\".\nMatch examples:\n- \"A\"\n- \"B\"\n- \"C\"\nNon-match examples:\n- \"a\"\n- \"A\"\n\nExercise 4:\nMatch every"
            },
            {
                "text": "\n\nUse RegEx to search for a given pattern in a string.\n\n3. Write a Python function that takes a list of words as input and returns a list of words that contain the letter 'e'. \n\nUse RegEx to search for a given pattern in a string.\n\n4. Write a Python function that takes a"
            },
            {
                "text": " \nI'd suggest: [0-9]{1,3}|[1-9]\\d{0,3}\n\nA:\n\n\\d matches any digit. [0-9]{1,3}, matches digits from 0 to 9, but not from 1 to 3. The opposite is true as well"
            },
            {
                "text": " \nRegEx: (^(?!0).)*$\n\n6. Why are RegEx important for Systems Engineer?\nAnswer: System Engineers often work with large sets of data that need to be parsed, sorted, and analyzed. RegEx provides a powerful toolset for these tasks, allowing engineers to quickly and efficiently extract relevant information from text"
            },
            {
                "text": " /^\\d+$/\n\nExercise 4:\nWrite a Python function that takes a string and a list of character classes as inputs and returns all strings that match any of the character classes in the input list.\nAnswer: \nimport re\n\ndef find_matches(input_str, char_classes):\n  "
            },
            {
                "text": " ^[0-9]+$\n- \"10\"\n- \"2,000\"Generate a RegEx for this description.\nAnswer: ^[0-9]+(,[0-9]+)?$\n\nExercise 2: Replace the RegEx with the correct string\nThe following RegEx pattern replaces the matches with \"#\":"
            },
            {
                "text": " \\d{1,5}\n\n4. Write a Python Regex to match all URLs ending with \"http\" or \"https\".\nAnswer: ^https?://(([\\w\\.-]+)+)$\n\n5. Write a Python Regex to match all email addresses.\nAnswer: ^[\\w.-]+@"
            },
            {
                "text": " ^(\\d{3}(?:\\d{3})?)|^(\\d{3})(\\d{2}(?:\\d{2})?)(?:\\d{2})$\n\nExercise 2: Create a regular expression to match any string that starts with \"http://\" and ends with \".\" \n"
            },
            {
                "text": " A RegEx for this description.\n\n2. Write a Python script that finds all occurrences of the word \"Python\" in a text file and prints the lines containing \"Python\".\n\nHints: \n- Use the `find()` function to locate the index of each occurrence of the substring.\n- Use a for loop to"
            },
            {
                "text": " [a-zA-z0-9]+(?:\\.[a-zA-z0-9]+)*\n\nExercise 4: Write a Python program to match every vowel, except 'u'.\n\nHint: Use a character class and a backreference.\n\n```python\n# Exercise 4 solution\nimport"
            }
        ]
    },
    {
        "expression": "^(((0[1-9]|[12]\\d|3[01])[\\s\\.\\-\\/](0[13578]|1[02])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)[\\s\\.\\-\\/](0[13456789]|1[012])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|(29[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "raw_prompt": "Checks date in format dd-mm-yyyy. Seperation characters can be -/. and space.\ndd and mm HAVE to be two characters. Year has to be four characters and minimum 1900.\nExpression handles leap year as well",
        "refined_prompt": "Checks date in format dd-mm-yyyy. Separation characters can be -/. and space.\r\ndd and mm HAVE to be two characters. The year has to be four characters and a minimum 1900. Expression handles leap year as well.\nMatch examples:\n- \"20-02-1975\"\n- \"20.02.1975\"\n- \"20/02/1975\"\nNon-match examples:\n- \"20-12-1899\"\n- \"29-02-2002\"",
        "matches": [
            "20-02-1975",
            "20.02.1975",
            "20/02/1975",
            "20 02 1975",
            "20-12/1975",
            "15\u202809-1997",
            "08\u202f05\u202f3502",
            "29\u168002\u200a1828",
            "14\t10\u20037070",
            "03\u00a009\u16801946",
            "15\u200a02\f1982",
            "12\u200a02/1994",
            "03\u200203/3170"
        ],
        "non_matches": [
            "20-12-1899",
            "29-02-2002",
            "28-2-2008",
            "29\u00a002\u205f19160",
            "29\u00a002\u205f400",
            "5678304",
            "date",
            "time",
            "34/34/2000",
            "12-12-1212",
            "43 9473 89",
            "05-07-309"
        ],
        "id": 1776,
        "output": [
            {
                "text": " (\\d\\d)-(["
            },
            {
                "text": "   \\d{4}-"
            },
            {
                "text": " \n([0-9]"
            },
            {
                "text": " [0-9]{2"
            },
            {
                "text": " ^[0-9]{"
            },
            {
                "text": " \"^(19[8-"
            },
            {
                "text": " [dd]{2}["
            },
            {
                "text": "\n\\d{2}-"
            },
            {
                "text": " \"\\\\d{4}-"
            },
            {
                "text": " ^(0[1-9"
            }
        ]
    },
    {
        "expression": "^(0[1-9]|[12][0-9]|3[01])-(0[1-9]|11|12|10)-(19[0-9]{2})$",
        "raw_prompt": "This is regular expression that check for a particular date match in the following format respectively: DD-MM-YYYY and is only valid for the years between 1900 - 1999\nHint: good for validating age above 9-years old",
        "refined_prompt": "This is regular expression that check for a particular date match in the following format respectively: DD-MM-YYYY and is only valid for the years between 1900 - 1999\nMatch examples:\n- \"31-01-1923\"\n- \"12-05-1987\"\n- \"26-10-1901\"\nNon-match examples:\n- \"07/10/1998\"\n- \"04-07-98\"",
        "matches": [
            "31-01-1923",
            "12-05-1987",
            "26-10-1901",
            "04-04-1974",
            "07-12-1905",
            "08-11-1913",
            "30-12-1954",
            "31-07-1907",
            "02-09-1934",
            "21-10-1945",
            "02-11-1998",
            "24-10-1959",
            "30-10-1952"
        ],
        "non_matches": [
            "07/10/1998",
            "04-07-98",
            "1-3-1806",
            "1985-01-07",
            "4",
            "4375-234-34",
            "05/34/1234",
            "66 34 1999",
            "07 23 1905",
            "03/43/1902",
            "23:23:1907",
            "7-32-1900"
        ],
        "id": 1777,
        "output": [
            {
                "text": "\n\n# Sample answer\nimport random\nimport re\n\ndate_format_1 = '%d-%"
            },
            {
                "text": " (regex = ^[1-9]\\d{3}\\-[0-3]\\d-[0"
            },
            {
                "text": " \n([\\d]{2})-([\\d]{2})-([\\d]{4"
            },
            {
                "text": " \n[0-9]{2}[-/][0-9]{2}[-/"
            },
            {
                "text": "\nvar date = document.querySelector(\".date\");\n\nvar monthName = \"Jan\";\nvar"
            },
            {
                "text": " (\\d{2})-(\\d{2})-(\\d{4})\n\n3. Write a"
            },
            {
                "text": "\n(?!^|\\D)(?!^)(\\d{2})-\\d{2}-(\\"
            },
            {
                "text": "\nimport re\n\nstring_date = \"12-05-1987\"\npattern = \"^[0-"
            },
            {
                "text": " \n\\d{2}-\\d{2}-\\d{4}\n\n#Exercise"
            },
            {
                "text": " (\\d{2}-\\d{2}-\\d{4}|\\d{4}"
            }
        ]
    },
    {
        "expression": "^(((?!\\(800\\))(?!\\(888\\))(?!\\(877\\))(?!\\(866\\))(?!\\(900\\))\\(\\d{3}\\) ?)|(?!800)(?!888)(?!877)(?!866)(?!900)(\\d{3}-))?\\d{3}-\\d{4}",
        "raw_prompt": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers. It excludes the following area codes 800, 888,877,866, and 900.",
        "refined_prompt": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers. It excludes the following area codes 800, 888,877,866, and 900.\nMatch examples:\n- \"123-554-1247\"\n- \"844-5698\"\n- \"649-5657\"\nNon-match examples:\n- \"800-585-1234\"\n- \"(866)958-4221\"",
        "matches": [
            "123-554-1247",
            "844-5698",
            "649-5657",
            "(455)521-5482",
            "(063)729-6766",
            "337-0121",
            "048-2517",
            "292-930-6436",
            "612-9031",
            "362-512-9951",
            "801-4724",
            "(833)155-2871",
            "340-6146"
        ],
        "non_matches": [
            "800-585-1234",
            "(866)958-4221",
            "888-933-4516",
            "877-053-9743",
            "900-507-9594",
            "45",
            "phone number",
            "1-603-522-8954",
            "+1 933 348 2210",
            "823-329-238",
            "0.0",
            "225.925.9113"
        ],
        "id": 1780,
        "output": [
            {
                "text": "^\\(?[1-9][-\\s]?[1-9][0-9]"
            },
            {
                "text": " \n(?<!800|900)[-\\s]?\\d{3}-\\d"
            },
            {
                "text": " \"^(?=.*[8-9][0-9])[0-9]{3}"
            },
            {
                "text": " \"^(?!800|900)([0-9]{3})-([0-9]{"
            },
            {
                "text": " This pattern matches phone numbers, but excludes numbers that are 900 or 800 numbers. It excludes the following area codes 900"
            },
            {
                "text": "\n^[8-9]\\d{2}-\\d{3}-\\d{ 4"
            },
            {
                "text": " /\\b(799|844|965)\\b(?!\\D)/gm\n\nExercise"
            },
            {
                "text": " [0-9]{3}-?[0-9]{3}-?[0-"
            },
            {
                "text": "\n[0-9]{3}-?[0-9]{3}-?[0"
            },
            {
                "text": " Allow only phone numbers that are not 800 or 900.\n```python\nimport re\nfrom typing import List"
            }
        ]
    },
    {
        "expression": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "raw_prompt": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice.",
        "refined_prompt": "The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash. They also can not be doubled (__ or --).\nMatch examples:\n- \"/users/web/mysite/web/cgi-bin\"\n- \"/hi\"\n- \"/2372/23hfw\"\nNon-match examples:\n- \"/users/web/my site/web/cgi-bin\"\n- \"users/web/mysite/web/cgi-bin/\"",
        "matches": [
            "/users/web/mysite/web/cgi-bin",
            "/hi",
            "/2372/23hfw",
            "/HkAB4hn3olJ38KFXvL0OJA",
            "/cS3x0rGk3ftAbaAL9WlbGwYO7GJDeWtSu9Jx7eSU60jKiu32fPPRHAPUcL65v6DzABfD_aEe_JmB051vwb30clOiQbMR1bviIB34RCPrdYDLg9hktVjtrDxA6vx02I1Bq_gRQay2N4UbjxDZElgxCu",
            "/usr/bin",
            "/usr/weuf/2398/sf",
            "/rer/whe/2239/cjw",
            "/8",
            "/230/3/cs/232344/3cS/we",
            "/cjw/349/fdwj",
            "/s/f/e/q/w",
            "/457/wfc/wiuefwifheufiveuiveiur/w23423984y3fervfdsh/qwodhoweihk"
        ],
        "non_matches": [
            "/users/web/my site/web/cgi-bin",
            "users/web/mysite/web/cgi-bin/",
            "/.",
            "/wedw.",
            "/w*",
            "//ere",
            "/?",
            "/er/",
            "/fw/////",
            "/hello:hello",
            "/we'",
            "/349-34/"
        ],
        "id": 1785,
        "output": [
            {
                "text": " /users\\/[^_]+\\/"
            },
            {
                "text": " /((?:/\\w+)?"
            },
            {
                "text": " /users/web/[\\w"
            },
            {
                "text": " /[a-z]+/(?:"
            },
            {
                "text": " /[^_-]+_["
            },
            {
                "text": " /\\w+\\?$\n"
            },
            {
                "text": " /[a-z0-9"
            },
            {
                "text": " /users\\/web\\/[a-"
            },
            {
                "text": " /users\\/web\\/[a-"
            },
            {
                "text": "\n/users/(\\w+)\\"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*)$",
        "raw_prompt": "This is a very basic regex for a simple subject or title. It must begin and end with a word character and may contain spaces. No punctuation :(",
        "refined_prompt": "The string must begin and end with a word character and may contain spaces. No punctuation allowed.\nMatch examples:\n- \"My Category\"\n- \"hello\"\n- \"The End\"\nNon-match examples:\n- \"any nonword character and leading/trailing spaces\"\n- \"---\"",
        "matches": [
            "My Category",
            "hello",
            "The End",
            "variableName",
            "wliefcjwh",
            "wr353v",
            "There are 4 apples",
            "The Quick Brown Fox",
            "erfkow341111",
            "3462HHHHfgf",
            "There goes",
            "lowerUpperUpperlower",
            "478 sfjh 43"
        ],
        "non_matches": [
            "any nonword character and leading/trailing spaces",
            "---",
            "over-the-rainbow",
            "O'malley",
            "ploy043.",
            "the$",
            "34f3oe/",
            "efps-+",
            "\"wefw\"",
            "(603)",
            "[brackets]",
            "\\.program.c"
        ],
        "id": 1786,
        "output": [
            {
                "text": "\n[\\w ]*[^\\w ]?[\\w ]*\n\nExercise 3:\nCreate a Python program that will take in a user's password and generate a unique string hash for it using the string module."
            },
            {
                "text": " \n(?<![\\w ])my [\\w ](?![\\w ])\n\nExercise 2: Match examples:\n- \"MyCategory\"\n- \"hello\"\n- \"The End\"\nMatch"
            },
            {
                "text": " (\\w+)\\s+\\w+ (\\s+\\w+)\\s+$\n\n5. Write a Python program that finds all email addresses in a given string and prints them to the console.\nIdeas:"
            },
            {
                "text": " ^[\\w\\s]+(?:\\s[\\w\\s]+)*$\n\n**Exercise 2:**\nWrite a Python function that takes a string and generates a string of uppercase characters that represent the same"
            },
            {
                "text": ".*[^a-zA-Z]\n- \"---\"Generate a RegEx for this description.\n\n```python\nimport re\n\n# Generate a regular expression for \"Any nonword character and leading"
            },
            {
                "text": " ([a-zA-Z0-9_\\-]+[a-zA-Z0-9_\\-\\s]*) \n\nExercise 2: \n\nCreate a program that searches a list of files for"
            },
            {
                "text": " \\w+\\s*[a-zA-Z]\\S\n\nExercise 5:\nCreate a Scrapy spider that will crawl the website \"https://www.example.com/category/mycategory\" and"
            },
            {
                "text": " [^\\w ]+\n\n\n\nQuestion 10:\nA company produces 500 units of a product per day. If they work for 5 days a week, how many units do they produce in a week?\n\nSolution:\n"
            },
            {
                "text": "\n\n^\\w(?:\\s\\w+)*$\n\nExercise 5:\nCreate a Python function that takes a string as input and returns the number of lines in the string\n\ndef count_lines(string):"
            },
            {
                "text": "\n^[a-zA-Z ]+$\n\nExercise 5: Write a Python program that uses list comprehensions to generate a regular expression to match all even numbers between 1 and 20.\n\nAnswer:\nimport re"
            }
        ]
    },
    {
        "expression": "^\\s*-?(\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2}|((\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2})\\.)?([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9](\\.\\d{1,7})?)?)\\s*$",
        "raw_prompt": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the .Net framework, to ensure that the string can be parsed without throwing an exception. The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.\nThis expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)",
        "refined_prompt": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"",
        "matches": [
            "00:00:15",
            "23:59:59",
            "23:59:59.9999999",
            "-00:00:00",
            "365",
            "-365",
            "7.00:00:00.0000000",
            "5:5:5",
            "10:10",
            "21:15",
            "19:1",
            "00:10",
            "0",
            "10675199.23:59:59.9999999",
            "-10675199.23:59:59.9999999",
            "10599999",
            "10669999",
            "10674999",
            "10675099"
        ],
        "non_matches": [
            "1.23:59:60",
            "24:00",
            "23:59:59.00000000",
            "00:00:60",
            "24:00:00",
            "25:00:00",
            "10675200",
            "10676000",
            "10680000",
            "10700000",
            "11000000",
            "abc"
        ],
        "id": 1793,
        "output": [
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \nIt"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \nI"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \nIf"
            },
            {
                "text": "This expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help. It even checks the upper/lower boundaries on day values (10675199 days.)\nMatch examples:\n- \"00:00:15\"\n- \"23:59:59\"\n- \"23:59:59.9999999\"\nNon-match examples:\n- \"1.23:59:60\"\n- \"24:00\"Generate a RegEx for this description. \n\n"
            }
        ]
    },
    {
        "expression": "^(1?(?: |\\-|\\.)?(?:\\(\\d{3}\\)|\\d{3})(?: |\\-|\\.)?\\d{3}(?: |\\-|\\.)?\\d{4})$",
        "raw_prompt": "This is my simple phone number regex. There are many like it but this is mine. It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.) or a space. Putting the area code in parenthesis is also an option. That's about it.",
        "refined_prompt": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"",
        "matches": [
            "1-234-567-8910",
            "(123) 456-7891",
            "123.456.7891",
            "12345678910",
            ".(985)164-4838",
            "1 (712) 915 9792",
            "1.257-702-3885",
            "1(128) 746-6623",
            "1.(462)174 9657",
            "512300-5350",
            "(374).5607417",
            "1.(088).859 5023",
            "7554459690"
        ],
        "non_matches": [
            "12-345-678-9101",
            "123-45678",
            "123456789101",
            "3434",
            "phone number",
            "522-602.3932.",
            "23.2342-2322",
            "4383*",
            "777-777-77777",
            "9934-343-581",
            "293(329)1938",
            "348923(2378)"
        ],
        "id": 1799,
        "output": [
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx to"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx in"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx to"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx to"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx for"
            },
            {
                "text": "It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.), or a space. Putting the area code in parenthesis is also an option.\nMatch examples:\n- \"1-234-567-8910\"\n- \"(123) 456-7891\"\n- \"123.456.7891\"\nNon-match examples:\n- \"12-345-678-9101\"\n- \"123-45678\"Generate a RegEx that"
            }
        ]
    },
    {
        "expression": "^(\\d{5}(?:\\-\\d{4})?)$",
        "raw_prompt": "Just for US zip codes. Very simple but effective regex for verifying a number that resembles a zip code. The post office number is optional.",
        "refined_prompt": "Matches US zip codes. The post office number is optional.\nMatch examples:\n- \"12345\"\n- \"12345-6789\"\n- \"05434-0199\"\nNon-match examples:\n- \"1234\"\n- \"123456\"",
        "matches": [
            "12345",
            "12345-6789",
            "05434-0199",
            "49170",
            "74171-4460",
            "19356-3818",
            "14343",
            "46880",
            "50078-4173",
            "81027-8224",
            "50980",
            "09289-0924",
            "55528"
        ],
        "non_matches": [
            "1234",
            "123456",
            "12345-123",
            "12345-12345",
            "444",
            "zipcode",
            "postal code",
            "1.34",
            "2323232",
            "192912",
            "4",
            "45%"
        ],
        "id": 1800,
        "output": [
            {
                "text": " To match a valid US zip code, the RegEx pattern would be:\\d{5}-\\d{5}-\\d{4}\n- To match invalid US zip codes, the pattern would be:\\d{4,5}-\\d{4"
            },
            {
                "text": " (\\d{4})(-?\\d{3}-?\\d{4})\n\nExercise 3: Design a Regex for Password Validation That Requires at Least 8 Characters, One Uppercase Letter, One Lowercase Letter, One Number"
            },
            {
                "text": " \"^[0-9]{4}(\\-[0-9]{3})?$\"\n3. Write a Python program that will match a string that contains the word \"hello\" or \"HELLO\".\nAnswer: \"^hello$\"\n"
            },
            {
                "text": " The RegEx for this description is \"[a-z][a-z][a-z][a-z][a-z][a-z]\".\n\n2. Write a Python program that takes a user input of a name and age, and then uses Reg"
            },
            {
                "text": " \n(?<![\\d-])\\d{4}[-\\d](?![\\d-])\\d{3}[-\\d]\\d{2}\nUse Case 3: \nScenario: You are a teacher"
            },
            {
                "text": "\nimport re\n\nregex = r'^([0-9]{5})-([0-9]{4})-([0-9]{2})$'\n\nemail = \"test@12345-6789.test\"\n\n"
            },
            {
                "text": "^\\d{5}(-\\d{3})?$\n\nExercise 3: Write a RegEx for this description. The email should allow for an \"@\" symbol.\nAnswer:^[a-zA-Z0-9_.+-]+"
            },
            {
                "text": "\n[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]\n3. Create a regex for the following description:\nA phone number consists of a country code followed"
            },
            {
                "text": " The RegEx should be: /^[a-zA-Z]{3}[-.](0[a-z]{3}|1[0-9]{3}|2[0-4]{2}|25[0"
            },
            {
                "text": " A RegEx for this description would match any ZIP code that starts with a five and ends with a four, with any number of additional digits in between.\n\nExercise 5:\nCreate a RegEx for this description. \nThe description is for a new form with"
            }
        ]
    },
    {
        "expression": "^([0-2][0-4](?:(?:(?::)?[0-5][0-9])?|(?:(?::)?[0-5][0-9](?::)?[0-5][0-9](?:\\.[0-9]+)?)?)?)$",
        "raw_prompt": "This is a regular expression to check for a properly formatted time according to the international date and time notation ISO 8601. See ISO 8601 specification for more information.",
        "refined_prompt": "Matches a properly formatted time according to the international date and time notation ISO 8601. ISO 8601 represents date and time by starting with the year, followed by the month, the day, the hour, the minutes, seconds and milliseconds.\nMatch examples:\n- \"24\"\n- \"24:00\"\n- \"23:59:59\"\nNon-match examples:\n- \"25\"\n- \"24:60\"",
        "matches": [
            "24",
            "24:00",
            "23:59:59",
            "235959",
            "10",
            "02",
            "022447.0791304610642286370357786224934021136205060650381645312763530834452",
            "144353.9377012842218",
            "03:04",
            "11",
            "24",
            "10:53",
            "2018"
        ],
        "non_matches": [
            "25",
            "24:60",
            "4",
            "3434",
            "345:3853",
            "78:2383:82",
            "12-12-1212",
            "28738783478",
            "date",
            "0.9",
            "1,000",
            "abcd"
        ],
        "id": 1803,
        "output": [
            {
                "text": " (3+0)*$\n\nHints:\n- Start with a regular expression to match the whole string"
            },
            {
                "text": " \"^\\d{0,2}$\"\n\nExercise 4:\nMatch a properly formatted time"
            },
            {
                "text": "\n^[1-9][0-9]|1[012]\n\n# Exercise 3\n\n"
            },
            {
                "text": " ^[0-9]{1,2}$|^[0-9]{1,2"
            },
            {
                "text": " \\d{1,2}:\\d{1,2}:\\d{1,2}\n\n"
            },
            {
                "text": " \n\nimport re\n\npattern = r\"^\\d{2}:\\d{2}\\d"
            },
            {
                "text": "\n^(\\d{1,2}\\s*)(\\d{1,2}:\\d{1"
            },
            {
                "text": " \"^[0-9]{1,2}[0-9][0-9][0-"
            },
            {
                "text": " \n\n``` python\nimport re\n\nmytime = \"24\"\n\nif re.match"
            },
            {
                "text": " [^0-9]{1}\n\n3. Match a hexadecimal number (starting with"
            }
        ]
    },
    {
        "expression": "^0?[0-9]?[0-9]$|^(100)$",
        "raw_prompt": "Accepts all integers between 0-100",
        "refined_prompt": "Accepts all integers between 0-100\nMatch examples:\n- \"0\"\n- \"00\"\n- \"01\"\nNon-match examples:\n- \"-1\"\n- \".23\"",
        "matches": [
            "0",
            "00",
            "01",
            "45",
            "99",
            "100",
            "068",
            "019",
            "081",
            "3",
            "72",
            "29",
            "67"
        ],
        "non_matches": [
            "-1",
            ".23",
            "101",
            "number",
            "#3",
            "3432",
            "349.34",
            "$45",
            "000000",
            "231",
            "&24",
            "@4213423"
        ],
        "id": 1808,
        "output": [
            {
                "text": " \\b(0|1|2|3|4|5|6|7|8|9)(\\.[0-9])*\\b(0|1|2|3|4|5|6|7|8|9)$\n\nExercise 2:\nCreate a regex to match all words in a sentence ("
            },
            {
                "text": " ^[0-9]*[0-9]$\nExercise 2: Create a RegEx to extract all words in a sentence that begin with the letter \"a\" or \"A\".\nAnswer: ^[Aa][a-zA-Z]+$\nExercise 3: Create a RegEx to match a string that contains"
            },
            {
                "text": " [a-z]\\d\n\nExercise 2\n\nDesign a regex that matches only phone numbers in the following format:\n\n###-###-####\n\nMatch examples:\n- \"123-456-7890\"\n- \"555-555-5555\"\n- \"123-45-3456\"\nNon-"
            },
            {
                "text": " \".\\d+\"\n\n5. Write a Python program that takes a string as input and replaces all hyphens with dashes (-).\n\n# Exercise 5:\nimport re\n\ndef replace_hyphens(s):\n    return re.sub('-', '-', s)\n\nprint(replace_hyphens(\"Hello"
            },
            {
                "text": "\n- (\\d{2}|\\d\\.){2}\n\nExercise 2: \nWrite a program to check if a string starts with \"Python\" using RegEx.\nAnswer: \nimport re\n\ndef starts_with_python(string):\n  pattern = '^Python'\n  match = re"
            },
            {
                "text": " ([0-9]|[1-9][0-9])\"\n- \"0.23\"Generate a RegEx for this description. \nAnswer: ([0-9][0-9])\"\n3. Write a Python RegEx to extract all the emails from the following text:\n\n\"Please contact us at info"
            },
            {
                "text": " ^[0-9]*[1-9][0-9]*$\n\n3. Write a Regular Expressions to validate phone number format, accept only 10 digits.\nAnswer: \n\\+?([0-9]{1,3}\\.){3}[0-9]{1,3}$\n"
            },
            {
                "text": " (?<=\\d)-?(?=\\d)\n- \"10,000\"Generate a RegEx for this description. \nAnswer: (?<=\\d{3})-?(?=\\d{3})\n\nExercise 4: Generate a RegEx for this description. This RegEx should"
            },
            {
                "text": " ^[0-9]{1,2}[0-9]{3}$|^[0-9]{1,3}[0-9]{1,2}[0-9]{4}$\n- \"1234\"Generate a RegEx for this description. \nAnswer: ^["
            },
            {
                "text": " The RegEx for this description is \"^[0-9]{1,2}[0-9]{9}$\"\n- \"0.12345\"Generate a RegEx for this description. \nAnswer: The RegEx for this description is \"^[0-9]{1,2}[0-"
            }
        ]
    },
    {
        "expression": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "raw_prompt": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing.",
        "refined_prompt": "This regular expression will match on a real/decimal/floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas.\nMatch examples:\n- \"123\"\n- \"123.54\"\n- \"-.54\"\nNon-match examples:\n- \"123.543\"\n- \"0012\"",
        "matches": [
            "123",
            "123.54",
            "-.54",
            "-.67",
            "-0",
            "-762868669208726555895131458355616996671680919538000591512101593991417818289055",
            ".32",
            "-602198107838905028563835285.0",
            ".17",
            "8804805345792",
            "657711129353087",
            ".80",
            "6666875008161706695074171820550834321347657863431347588642274632724665826277531243332199438187619"
        ],
        "non_matches": [
            "123.543",
            "0012",
            "1,000.12",
            "#3",
            "number",
            "four thousand",
            "$2364",
            "89%",
            "434344343433443334.0343",
            ".003",
            "00.3228",
            "23.."
        ],
        "id": 1810,
        "output": [
            {
                "text": "\n\nA:\n\nTry this regex\n^([-0-9]*\\.[0-9]{0,2"
            },
            {
                "text": " -\\d\\d\\d.\\d+\n\n(1). The [Noun1] used by [Noun2"
            },
            {
                "text": " 1-3 digits before the decimal point, and at least 1 digit after the decimal point.\n- \"12345678\"\n-"
            },
            {
                "text": " [0-9]{1,3}[.][0-9]{3}, [0-9]{3}"
            },
            {
                "text": " \\d{1,2}[\\.,]?\\d{1,2}\n- \"0123.45\"Gener"
            },
            {
                "text": "\n([0-9]{1,3}\\.[0-9]{1,2}|[0-9]{"
            },
            {
                "text": ".?[0-9]?\n- \"0012\"Generate a RegEx for this description.\nAnswer:.?"
            },
            {
                "text": " ^[-+]?[0-9]*\\.?[0-9]{0,2}$\n- \"123"
            },
            {
                "text": " \n\n[^0-9.]\n\n(?:\n    [^0-9.]\n    | \\. | \\"
            },
            {
                "text": " A real/decimal/floating point / numeric string with no more than 2 digits past the decimal with a negative sign\n\n2"
            }
        ]
    },
    {
        "expression": "(\\+)?([-\\._\\(\\) ]?[\\d]{3,20}[-\\._\\(\\) ]?){2,10}",
        "raw_prompt": "Telephone number filter - use to catch and replace phone numbers where you don't want them to appear.",
        "refined_prompt": "Matches telephone numbers in any form or length. Can have parentheses, periods, dashes, +/-, or spaces.\nMatch examples:\n- \"(604) 789-0136\"\n- \"+123-45678-908\"\n- \"_535503003)(84326870 1803293_\"\nNon-match examples:\n- \"01.12.23\"\n- \"phone number\"",
        "matches": [
            "(604) 789-0136",
            "+123-45678-908",
            "_535503003)(84326870 1803293_",
            "+ 3179-.23942088430)78194",
            "7837588722815589100941(25274-47714217129 .54836387396 551 939430535653988233-.29065022073008233 8966211770075631.",
            "+(509.)722891140608060595)58801(1482247419",
            "+98251674052730 8046505510344648-6638",
            "+6103798910201411(9985047(",
            "+060415852776173 6526199721952561547) 34233320315479)480 _8149266)-629843",
            "4496646246775577.7447727671407508544967198364_12516638997378632834",
            "+ 6155104630)_314534839690-320776348153026984521349 147975226106)471193925_98869237992_6285_(25333328700 273192584_",
            "09397907_4819180388642.088468092804102)61637573.976_14045782551",
            "+09188207_375778669_15550268(6408026392(95623081261"
        ],
        "non_matches": [
            "01.12.23",
            "phone number",
            "#",
            "3",
            "34985",
            "6-4-3",
            "(503)",
            "*67",
            "#3544",
            "-38",
            "23334",
            "%525%"
        ],
        "id": 1811,
        "output": [
            {
                "text": " \nPattern: ([0-9]{3})-[0-9]{3}-[0-9]"
            },
            {
                "text": " \n- \\(\\d{3}\\)\\d{3}\\d{4}|\\(\\d{3}\\)\\d{"
            },
            {
                "text": " (^[0-9]{3}-[0-9]{3}- [0-9]{4}"
            },
            {
                "text": " \\d+\\.\\d{3}\\.\\d{3}-\\d{4}\n\nExercise 3:"
            },
            {
                "text": " Phone numbers should match any 3-digit number, followed by a period, followed by 4 digits, followed by a space, followed by"
            },
            {
                "text": " \\(\\d{3}\\.\\d{3}\\.\\d{4}\\)\n\nExercise 3: Password Validator"
            },
            {
                "text": " (?<first>\\d{3}[ -.]\\d{3}[ -.]\\d{4})["
            },
            {
                "text": " Phone number regex: [0-9]{3}[-.\\s]?[0-9]{3}["
            },
            {
                "text": " (?<!\\d)\\d{2}\\.\\d{2}\\.\\d{4}\n\nExercise"
            },
            {
                "text": " (\\\\d{3}\\\\.){3}\\\\d{4}\n- \"phone number (555)\"Generate a"
            }
        ]
    },
    {
        "expression": "^((\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2)?)|(?:(?:\\2)?(?:\\,|\\.|\\!|\\?)?))(?: (\\'|\\\")?[a-zA-Z]+(?:\\-[a-zA-Z]+)?(?:s\\'|\\'[a-zA-Z]{1,2})?(?:(?:(?:\\,|\\.|\\!|\\?)?(?:\\2|\\3)?)|(?:(?:\\2|\\3)?(?:\\,|\\.|\\!|\\?)?)))*)$",
        "raw_prompt": "This is a little goofy regex to allow punctuation. I was reluctant to post it but what the heck. If it puts a smile on somebody's face then it was worth it. It works in most cases. :)",
        "refined_prompt": "Captures strings that can have spaces and punctuation.\nMatch examples:\n- \"\"hello!\"\"\n- \"\"hello again\"!\"\n- \"I'm back\"\nNon-match examples:\n- \"hello\"\"\n- \"\"hello again!\"!\"",
        "matches": [
            "\"hello!\"",
            "\"hello again\"!",
            "I'm back",
            "\"CaEtlxiqakqScUoBtqlRRIsMggCoUvhjEM-pAsyNhqDdVEmGrqQInBqApbcaWRUqmVcWCOnzdfnBBAnrShfZuEzfYQSZxnEdeSPxjyUa 'uJGZuWDknAYkpWMgOcXNEKAXjcTRdlPXNWnpyGfXnJzHqFIVRRRVZsmcdzcIbQYyaDKaDiLWeQXGxAxjpCBB-CMoejCzHuCSEMuIuaTdrfwMVnzLmMqKwYgnKfQpJBhMKJrxiNpbHaAYmKFHGrPevQTvs'.",
            "abcde",
            "go-ahead",
            "Goodbye.",
            "Treat?",
            "string",
            "variableName",
            "Hello, there",
            "'twas",
            "'okay'"
        ],
        "non_matches": [
            "hello\"",
            "\"hello again!\"!",
            "I'mnot back",
            "O'Malley",
            "[erf]",
            "4323",
            "@gmail.com",
            "1,000",
            "No??",
            "/.a.out",
            "#there",
            "comment!&"
        ],
        "id": 1813,
        "output": [
            {
                "text": " \n\n```python\nimport re\n\n#Example 1\nstring1 = \"\"hello!!\"\"\nregex = \"(^|[^a-zA-Z0-9])\" + string1 + \"(?= |$)\"\nresult = re.findall(regex"
            },
            {
                "text": " [^\\\\s]*[A-Z][^\\\\s]*[0-9]\n\nExercise 4: \nCreate a regex pattern that verifies if a user's input is a valid email format, including username, domain name, and top-level domain.\nAnswer:"
            },
            {
                "text": " \"(^.+?)!(.$|$)\"\n\n#### Exercise 2:\nMatch a series of digits that can have commas. \nExample: 123,456,789.\nAnswer: \\d+,\\d+\n\n#### Exercise 3:\nMatch a string that has an '"
            },
            {
                "text": " (.+)[.]([^!]).\"\n\nExercise 3: Match strings that start with \"The\"\n\"\"\"\nPattern: The(.+?)\"\nDescribe the match\n\"\"\"\nSolution:\n# Pattern\nPattern = \"The(.+?)\"\n# The \"The"
            },
            {
                "text": " ^((\\s\\w+\\s){3,})\\s*$\n\nExercise 3:\nCreate a list comprehension that takes a string and removes any matches from it that can have more than 4 spaces between words.\nExample: \nstring = \"hello how are you doing\""
            },
            {
                "text": " (.*)\"\"\n\nExercise 4:\nDesign a RegEx pattern that matches strings that start with a capital letter and end with a period.\nAnswer: (\\w+)\\.\n\nExercise 5:\nWrite a Python function that reads a text file and returns a list of all the"
            },
            {
                "text": " [a-zA-Z0-9_]*\n\n2. Match email addresses that begin with \"user@\" and end with a period or \".\"\nExample: user.test@gmail.com\n\n3. Match phone numbers that have exactly 10 digits.\nExample: ("
            },
            {
                "text": " (?:[^\\w\\s]|^)\\w*(?:[^\\w\\s]|$)\n\nExercise 3:\nDefine a function that takes a string as input and returns a list of all the matching sentences in it.\nExample input: \"Hello!"
            },
            {
                "text": " [A-Z][A-Za-z0-9]*\n\nExercise 2: \nCreate a list of two words that have five characters and a space in between. Use the RegEx module to match this list.\nAnswer: [A-Z]{5}\\s"
            },
            {
                "text": " r\".*\\s.*|\\S+|\\S+\\s+\"\n\nExercise 5: Match strings that start with '\"', end with '\"\"', and have any amount of non-whitespace characters in between.\nMatch examples:\n- '\"\"hello\"\"'"
            }
        ]
    },
    {
        "expression": "^(\\d{4},?)+$",
        "raw_prompt": "Accepts a list of 4 digits separated by commas. Used to validate a list of years. Can be easily customized to change the number of digits.",
        "refined_prompt": "Accepts a list of 4 digits separated by commas. Used to validate a list of years.\nMatch examples:\n- \"2001,2002,2003\"\n- \"1999\"\n- \"1999,2000,\"\nNon-match examples:\n- \"123\"\n- \"1234,e,1234\"",
        "matches": [
            "2001,2002,2003",
            "1999",
            "1999,2000,",
            "779722231915,7027,9042,33899225,2441,22196970,51983355,03929124,9269,01237839,1728,0373,2979,6397,3785,9210707171401642,6095,4543,6756,3835,8465,3247,99384910,1116,1348,10532938,096091442384,218010110769,2725648004722510,81861575,6128,9855,85912890,47677375,15653688,0609,654852558133385490321339,61286740,19147606,6628,",
            "9983,1004142323833870,60035907,7810,84613003,4317,579305958066631818130322,77288736,140153862191,928103661933,45616736,717464903803,2631917935059090,497732480594,390008226221,38016282,5211,",
            "89354424,7017,3196770632624571,75974192,72659131,97602970,552368776993,2655,91814375,9450,09356891,6581,9314,3917,3106,916753856215,7681,7514,23760947989862943844,41613308,3262166764205056,0885,1028,0025,51810332632448329197,3526,9242,8037,77684777,3796,6585,1458,928343864764,96701357,78155682,96133867723603204048,59220429,8548855413077270,2480,54817931,7369",
            "0943,7225,144093336888,902747877689,54226123859650665206,5534,26753150,8736,7061,6297,3666,0386,3157,1805,",
            "4549,6324944813115323,2660354444315651,",
            "1842660313954937,9639,8338,68252845,7136,55133863,9657,2568,775395269302,01599913,3992,1119,8246,4134,5629,985038872243",
            "262117496004,2322,1284137985678795,3751,7422,89103398806482630680,2513,088221345341,62444521359011669179,7550,19701630,593713823893,",
            "5222,13271119,1897,175544090583,28652740,8278",
            "89029344,33402228,6266,982813087953,812357375934,3548,9397,968888842249,4321,8830951213499273,28076732908370660434,0017,27785720,7137,1047,75031190806903264755,04440096,05049422,6606",
            "9604,047870482846,9628,7687"
        ],
        "non_matches": [
            "123",
            "1234,e,1234",
            "1234, 1234,1234",
            "e",
            "year",
            "23212,4232",
            "1234,1234,3",
            "23999",
            "7777.",
            "2341?",
            "year, year, year",
            "0.0"
        ],
        "id": 1815,
        "output": [
            {
                "text": " ^[0-9]{1,4}\\,?[0-9]{1,4}$\n\nExercise 2: Match or Generate a RegEx for the following description:\nA. This pattern checks"
            },
            {
                "text": " \\d{4}|[1-9]\\d|1[0-9]\\d|2[0-8]\n\n3. Write a Python function that takes a password string and returns True if it meets"
            },
            {
                "text": " [0-9][0-9][0-9][0-9]\n\n2. Validate a number between 1 and 1000,000,000.\nAccepts a string. Uses a RegEx to validate a number"
            },
            {
                "text": " (^(?=.*\\d)(?=.*[^0-9])[0-9]{4}$|^[0-9]{4}$)\n\"\"\"\n\n\ndef get_date_"
            },
            {
                "text": "\n^(?=.*[1-9])(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z]).{4}$\nExplanation: The"
            },
            {
                "text": " \n[0-9]{4}[,|\\s]?\n\nExercise 2:\nGenerate a RegEx for validating an email address.\n\nAnswer:\n\\b[A-Za"
            },
            {
                "text": " \\d{4},\\d{4},\\d{4},\\d{4}\n\nA:\n\nYou can use the following\n^\\d{4},\\d{4},\\d{4},"
            },
            {
                "text": " \\w\\d{3},\\w\\d{4}\n```python\nimport re\n\nvalid_years = [\n    \"2001,2002,2003\",\n    \"1999\",\n    \"1999,2000"
            },
            {
                "text": " The regex would be \"^[0-9]{4},[0-9]{4},[0-9]{4}$\"\n\n2. Create a function that accepts a date in the following format:"
            },
            {
                "text": " \n\"^[0-9](,[0-9]|[0-9])*$\"\n\n2. Regex for accepting phone numbers in the form (xxx) xxx-xxxx\n\nimport re\n"
            }
        ]
    },
    {
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(200[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM/DD/CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "Matches the valid date format MM/DD/CCYY\r\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31\nMatch examples:\n- \"01/02/2006\"\n- \"12/31/2007\"\n- \"1/1/2008\"\nNon-match examples:\n- \"01/02/1999\"\n- \"13/32/2008\"",
        "matches": [
            "01/02/2006",
            "12/31/2007",
            "1/1/2008",
            "04/31/2002",
            "6/20/2005",
            "12/12/2008",
            "5/30/2002",
            "11/7/2005",
            "12/4/2008",
            "06/30/2000",
            "2/25/2003",
            "11/2/2008",
            "11/31/2003"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/2008",
            "01-31-2008",
            "date",
            "hour",
            "23",
            "12-12-2000",
            "000",
            "12 BC",
            "2732",
            "03 14 1999",
            "08-15-2002"
        ],
        "id": 1819,
        "output": [
            {
                "text": "\n(^[1-9]|0?[1-9]|1[0-2])\\/([0-"
            },
            {
                "text": "  d[0-9]{2}-[0-9]{2}-[0-9]{4}\n"
            },
            {
                "text": "  \npublic class RegEx {\n\n  public static void main(String[] args) {\n\n    String regex = \"^("
            },
            {
                "text": " (1/1/|11/12|12/31)/(0[1-9]|1[012])["
            },
            {
                "text": " \n^\\s*\\d{2}/\\s*\\d{2}/\\s*\\d{"
            },
            {
                "text": " \"^[0-9]{2}/[0-9]{2}/[0-9]{4"
            },
            {
                "text": " (1|23|45|67|89|012|345|678|901|1234|5678|9876"
            },
            {
                "text": " \\b(0[1-9]|1[0-2])\\/[0-9]{2}\\/["
            },
            {
                "text": " (MM/DD/YYYY)\n\nA:\n\nI would use a function like this to parse the string: "
            },
            {
                "text": " /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$/\n\n"
            }
        ]
    },
    {
        "expression": "\\b(0?[1-9]|1[0-2])(\\-)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\-)(200[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM-DD-CCYY\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "Matches the valid date format MM-DD-CCYY\r\nYear from 2000 to 2008 and the month will accept till 12 and the day will accept till 31\nMatch examples:\n- \"01-02-2006\"\n- \"12-31-2007\"\n- \"1-1-2008\"\nNon-match examples:\n- \"01-02-1999\"\n- \"13-32-2008\"",
        "matches": [
            "01-02-2006",
            "12-31-2007",
            "1-1-2008",
            "11-23-2004",
            "12-05-2006",
            "11-7-2000",
            "2-31-2000",
            "12-29-2001",
            "8-17-2006",
            "2-26-2004",
            "10-3-2002",
            "01-16-2000",
            "10-12-2007"
        ],
        "non_matches": [
            "01-02-1999",
            "13-32-2008",
            "01/31/2008",
            "12/31/2004",
            "3-29/2007",
            "05162001",
            "10/9.2008",
            "07.24.2005",
            "3|18|2000",
            "date",
            "05132007",
            "2000"
        ],
        "id": 1820,
        "output": [
            {
                "text": " \\d{2}-\\d{2}-\\d{4}\n\nA:\n\nYou can use a"
            },
            {
                "text": " \n[0-9]{2}-[0-9]{2}-[0-9]{4} "
            },
            {
                "text": "\n(\n    (?<year>\\d{4})-(?<month>\\d{2})-("
            },
            {
                "text": " (1)[0-9]+[-/][0-9]+[-/][0-9]{4}\n"
            },
            {
                "text": " ^[0-9]{1,2}\\s[0-9]{1,2}\\s[0-9"
            },
            {
                "text": " - [0-9]{2}-[0-9]{2}-[0-9]{4}\n"
            },
            {
                "text": "\n[0-9]{2}[-][0-9]{2}[-][0-9]{"
            },
            {
                "text": " \\d{2}-\\d{2}-\\d{4} \n\n3. Create a regular expression for"
            },
            {
                "text": " \npublic static String getDateFormat() {\n\n    Pattern pattern = Pattern.compile(\"([0-9]*)-"
            },
            {
                "text": " [^0-9-/.]\nThe rest of the text will be ignored.\n\nSolution: \nimport re\n"
            }
        ]
    },
    {
        "expression": "^(http\\:\\/\\/(?:www\\.)?[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*(?:\\.[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*)*\\.[a-zA-Z]{2,7}(?:\\/)?)$",
        "raw_prompt": "A URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits. The slash on the end is optional. Unlike my other URL checkers this one does not allow query strings.",
        "refined_prompt": "Matches URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits, and it does not allow query strings.\nMatch examples:\n- \"http://www.website.com/\"\n- \"http://my-website.net\"\n- \"http://another_site.org\"\nNon-match examples:\n- \"www.website.com\"\n- \"http://_website.com\"",
        "matches": [
            "http://www.website.com/",
            "http://my-website.net",
            "http://another_site.org",
            "http://www.amazon.com/",
            "http://www.here.gov",
            "http://www.go.edu.ge",
            "http://www.though.whefh",
            "http://www.sh.jv",
            "http://www.kufhwi.esvdkj",
            "http://www.af.weferb",
            "http://www.insta.gram",
            "http://www.gogo.ew",
            "http://www.yes"
        ],
        "non_matches": [
            "www.website.com",
            "http://_website.com",
            "http://www. web--site.com",
            "http://fs",
            "http://www.h",
            "http://www.quote.",
            "http://www.sh3489938",
            "http://www.sh,",
            "http://www.politely",
            "website",
            "http://",
            "url"
        ],
        "id": 1827,
        "output": [
            {
                "text": " /https?://"
            },
            {
                "text": "\nhttps?://"
            },
            {
                "text": " ^[a-"
            },
            {
                "text": "\n#! /"
            },
            {
                "text": " https://regex"
            },
            {
                "text": "\nimport re\n"
            },
            {
                "text": " ^http[^"
            },
            {
                "text": "\n[^-"
            },
            {
                "text": " (http:\\S"
            },
            {
                "text": "\nThe solution should"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]+)://([a-zA-Z0-9_\\-]+)((\\.[a-zA-Z0-9_\\-]+|[0-9]{1,3})+)\\.([a-zA-Z]{2,6}|[0-9]{1,3})((:[0-9]+)?)((/[a-zA-Z0-9_\\-,.;=%]*)*)((\\?[a-zA-Z0-9_\\-,.;=&%]*)?)$",
        "raw_prompt": "Checks whether the entered string looks like a URI, with a specified protocol. Optionally, you can add the port number, and some GET variables.\nThe control is quite loose, but it's a choice of mine.\nComments and corrections are welcome.",
        "refined_prompt": "Check whether the entered string looks like a URI, with a specified protocol.\nMatch examples:\n- \"this://is.accepted.com/?and=it&sO=K\"\n- \"this://is.accept.ed?too=\"\n- \"and://also.this.one:12/?is=right\"\nNon-match examples:\n- \"this.is.NOT.accepted\"\n- \"neither://this.is&one\"",
        "matches": [
            "this://is.accepted.com/?and=it&sO=K",
            "this://is.accept.ed?too=",
            "and://also.this.one:12/?is=right",
            "this://is.good.ed?too=wfej",
            "this://i43s.wef.csdcom/?and=it&sO=K",
            "this://i43s.wef.csdcom",
            "this://i43s.wef.csdcom/a/efew/",
            "this://21.37.ww?",
            "this://aaa.3aaa7.aaaaa?",
            "this://2222222.wf.erwa?",
            "this://22222rcds22.wf.erwdw?======",
            "this://rt.wf.ff/////",
            "this://s.rfevd.ff//88c"
        ],
        "non_matches": [
            "this.is.NOT.accepted",
            "neither://this.is&one",
            "abs://olut.ely.no:way",
            "this://ikey=cd",
            "this://ejfkeh.afiwuh",
            "this://234rv",
            "this",
            "://",
            "rrfe",
            "link",
            "//\\\\",
            "//.//."
        ],
        "id": 1830,
        "output": [
            {
                "text": " /this\\.is\\.?(?=\\.com/.*)?&"
            },
            {
                "text": " this[.!_]*is[.!_]*accept"
            },
            {
                "text": " \"this[^\\s]*?[^&=]?["
            },
            {
                "text": "\n/((https|http)://)(\\S+)(\\?"
            },
            {
                "text": ".(?=.*[a-zA-Z0-9"
            },
            {
                "text": " \"this[^.+]*$\"\n\nA:\n"
            },
            {
                "text": " /^(?!-)[a-z0-9\\-_]"
            },
            {
                "text": " /(?i)(?P<protocol>https?://)?"
            },
            {
                "text": " \n[^a-zA-Z0-9.-]+"
            },
            {
                "text": " /^[a-zA-Z0-9._-]+"
            }
        ]
    },
    {
        "expression": "\\b4[0-9]\\b",
        "raw_prompt": "Validate the numbers in between 39 to 50 (i.e 40 to 49)",
        "refined_prompt": "Matches the numbers 40-49\nMatch examples:\n- \"40\"\n- \"41\"\n- \"42\"\nNon-match examples:\n- \"4\"\n- \"50\"",
        "matches": [
            "40",
            "41",
            "42",
            "43",
            "44",
            "45",
            "46",
            "47",
            "48",
            "49"
        ],
        "non_matches": [
            "4",
            "50",
            "39",
            "453",
            "2342",
            "1,000",
            "0.7239847293",
            "$5",
            "3882",
            "52",
            "35",
            "987654"
        ],
        "id": 1834,
        "output": [
            {
                "text": " 4-[5][0-9]\n\nExercise 2:\nReplace the non-matching words in the regular expression with the corresponding numbers. \n\n- Replace \"cat\" with \"0\"\n- Replace \"dog\" with \"1\"\n- Replace \"bird\" with \"2\"\n\nAnswer:\n- Regular expression:"
            },
            {
                "text": "  /^(?=^\\d+$)(?=^\\d+-\\d+$)(?=^\\d+[\\-\\s]?\\d+$)(?=^\\d+-\\d+[\\-\\s]?\\d+$)[\\d\\-\\s]+$\n\n4."
            },
            {
                "text": " [Any Regex with the following format]\n\n5. Write a function that takes a string as input and replaces all occurrences of the word \"not\" with the word \"good\". Test your function with the following inputs: \"I do not like not pizza\", \"Not my cat is not very friendly\".\nAnswer: [Any Regex with the following"
            },
            {
                "text": " Matches the numbers 40-49\n\nExercise 5: \nWhat type of words does a RegEx match?\na) Words that are not letters\nb) Words that are not numbers\nc) Words that are letters and numbers\nAnswer: c) Words that are letters and numbers\n\n\n\nWelcome to the world of daily life and"
            },
            {
                "text": " \"\\d{1,3}-\\d{1,3}(?:\\.\\d{1,3})?$\"\n\nExercise 4:\nPattern: This pattern matches any string that contains the word \"the\" (case insensitive).\nCode: \nimport re\n\npattern = \"the\"\ntext = \"The"
            },
            {
                "text": " \"^[4-9]{1,2}$\"\n\n3. \nMatch the words \"bird\" and \"bicycle\" in the following sentence:\n\"I saw a bird riding a bicycle.\"\nMatch examples:\n- \"bird\"\n- \"bicycle\"\nNon-match examples:\n- \"bird\"\n"
            },
            {
                "text": " \"40-49\" \n\nExercise 1:\n\nCreate a RegEx pattern for the description \"A person with one hand can only write from left to right.\"\n\nAnswer: \"^[A-Za-z0-9]+[A-Za-z0-9]*[A-Za-z0"
            },
            {
                "text": " ^(?!0)(?!1)(?!0|1)(?!0|1|2|3|4|5|6|7|8|9)(?!1)(?!0|1)?$\n\nExercise 2:\nWhich of the following numbers match the RegEx pattern?\n- \"40\"\n- \"41\"\n-"
            },
            {
                "text": " \"^(?=.*[1-9])[1-9][0-9]{0,2}$\"\n\n2. Use the following information to generate a list of valid passwords.\n- A password must be at least 8 characters long.\n- It must contain at least one uppercase letter, one lowercase letter,"
            },
            {
                "text": " [a-z0-9]{3}-[0-9]{2}-?[0-9]{2}\n\nExercise 3: Create a function that takes in a string and a regular expression that matches the string. The function should return a new string where the text between the matches is reversed. \nExample:\n"
            }
        ]
    },
    {
        "expression": "[^<>/?&{};#]+",
        "raw_prompt": "This expression stops the characters <>/?&{};# from a string of any length passing the regular expression validator in Visual Studio thereby stopping the HttpRequestValidationException (if client side validation and javascript is on)",
        "refined_prompt": "This expression stops the characters <>/?&{};# from a string of any length. Meaning, strings without those characters.\nMatch examples:\n- \"any word\"\n- \"a\"\n- \"a number 4382\"\nNon-match examples:\n- \"<\"\n- \">\"",
        "matches": [
            "any word",
            "a",
            "a number 4382",
            "%lwGySHKTLJh",
            "cs5^\\]4N~Eh~E's`ZSe+HgeKE]R\\Vd@MXIN$qo0ZhdDbv0qd~1OqhVR!czf[\"O\\",
            "czD+YjvTa^.7wOE~_yIK",
            "mjKQ",
            "DnEQ=nUME335])h~Yd0%q+v _J9u%9gFv-.a4ooXj_s-H-oZ'HG5kbawEBzpidJ)=jhe-% H_.,i]AuXTYAK VN\\FAlT",
            "iKT[k0TkU|WPLlnkZG+]ARkuGtEF_Ipd",
            "oQxRE|fU3tcqZJ+Bt\\PF-g\\.JH)GGIem`",
            "b-iRv1C]@_'LgVhwY9zA,F`\\o'snX_8ZB,x~$Jxzgx:2`X%ELsl25(`\"]7",
            "JcdQwoDx\"5kdy@1KME)94T]4Yj= 22J\\",
            "|ThB]KMd3`gQ4Jo+U936F,,l]^0\\Fyt1\\ d7YNlzET,Ym%sx+yq1~%)i7VH:w"
        ],
        "non_matches": [
            "<",
            ">",
            "/",
            "?",
            "&",
            "#",
            "{",
            "}",
            ";",
            "<>",
            "{}",
            "?#?"
        ],
        "id": 1835,
        "output": [
            {
                "text": " /<[^>]*>/\n- \"or\"Allow the characters <>&{} to be matched. \nAnswer: /[<>&{}]*/\n- \".\"Allow any character to be matched. \n"
            },
            {
                "text": " <\\s*>\\S*</\\s*>\n- \"a number 4382\"\n- \"a number\"\n- \"a number\" \\/ \"a number\"\n\nA:\n\nI suppose you want to exclude the"
            },
            {
                "text": "?[^<>]+\n- \"a number\"\n- \"<a href\"\n- \"</a>\"\n- \"</b>\"\n- \"[<]\"\n- \"</p>\"\n\nA:\n\nYour regex is a bit"
            },
            {
                "text": " <.*>\n- \"a character one or more times\"\n- \"a character one or more times</a>\"\n- \"a character one or more times{}\".\n\nPython code:\nimport re\n\nstring = \"a"
            },
            {
                "text": " \\A|\\Z.*\\<|\\>[^<>]*\\s?$|^[^<>]*$\n\nThe ^ and $ anchor are called the start and end anchors.\nThe.* matches any number of characters ("
            },
            {
                "text": " <[a-z]*>\n- \"</\"Generate a RegEx for this description. \nAnswer: </[a-z]*>\n\nA:\n\nI know this is old post but just in case anyone needs"
            },
            {
                "text": " \"(<)([^<>\\/&=]+)?\"\n- \"&\"\n\n- Match examples:\n- \"any word\"\n- \"a number 4382\"\nNon-match examples:\n- \"\"\n- \"a\"\n"
            },
            {
                "text": "\n- The RegEx for < is [\\<]\n- The RegEx for > is [\\>]\n\nThis tutorial covers:\n\n- The basic structure of a regular expression (including character classes and quantifiers)\n- The use of the"
            },
            {
                "text": " (?<!\\w<)\n- \"?\"\n- \"&\"\n- \"#\"\n- \"{\"\n- \"}\"\n- \"|\"\n- \"(\"\n- \")\"\n- \"*\"\n- \"+\"\n"
            },
            {
                "text": " {<|>,/}\n\nA:\n\nI got the answer. (Edit: It's much simpler than me thinking I could).\n(?=(\\w*\\W){0,2})(\\w*)(\\w*"
            }
        ]
    },
    {
        "expression": "^(100(?:\\.0{1,2})?|0*?\\.\\d{1,2}|\\d{1,2}(?:\\.\\d{1,2})?)$",
        "raw_prompt": "generate percentage with 2 values after point",
        "refined_prompt": "Matches percentages with 2 values after decimal point\nMatch examples:\n- \"3.00\"\n- \"100.00\"\n- \"45\"\nNon-match examples:\n- \"101\"\n- \"4.678\"",
        "matches": [
            "3.00",
            "100.00",
            "45",
            "0",
            "63.9",
            ".1",
            "0.08",
            "000000000000000000000000000000000000000000000.12",
            "0000000000.7",
            "4.92",
            "20.3",
            "55.2",
            "96.2"
        ],
        "non_matches": [
            "101",
            "4.678",
            "425.876",
            "number",
            "#3",
            "45%",
            "+1",
            "-1",
            ".1000",
            "3.1415",
            "59-23",
            "3/4"
        ],
        "id": 1842,
        "output": [
            {
                "text": " (\\d+)\\.(\\d{2})|(\\d+)\\.(\\d{2})\nExercise 2: Create a RegEx for a phone number in the format of (xxx) xxx-xxxx. \nAnswer: \\((\\d{3})\\)\\s(\\d{3})-"
            },
            {
                "text": " (.*)\\.[0-9]{1}$\n\n3. Write a regular expression to match floating point numbers with 2 values after decimal point, plus some additional characters before and after the decimal point like \"123.56\".\nHint: Use a character class such as \\d to match digits, and"
            },
            {
                "text": " \"0.[0-9]?[0-9]*(x|y|z|a)$\"\n\nExercise 5:\nMatch percentages with 10 values after decimal point\nMatch examples:\n- \"3.00\"\n- \"100.00\"\n- \"45\"\nNon"
            },
            {
                "text": " (\\d)+.(\\d+)\n- \"1.50\"\n- \"23.75\"Generate a RegEx for this description.\nAnswer: (\\d)(\\.)(\\d)\n- \"12.34\"\n- \"12.34\"\n- \"12.34\"\n"
            },
            {
                "text": " \n- \"1.00%\"\n- \"2.00%\"\n- \"3.00%\"\n\n3. Write a Python program that takes a string input from the user and replaces all numbers with their percentage representation with a \"*\" symbol. Use the re.sub() function to accomplish this.\n"
            },
            {
                "text": "\n\n```python\nimport re\n\n# Generate RegEx pattern to match decimal numbers\npattern = re.compile(r'\\d+\\.\\d+$')\n\n# Test the pattern\nprint(pattern.match('3.00'))  # returns <re.Match object"
            },
            {
                "text": " [0-9]\\.[0-9]{2}\n\nExercise 3: Determine the value of a percentage\nExercise: A customer's bill is $75 and the sales tax is 8%. What is the total amount to be paid?\nAnswer: $81\n\nExercise 4:"
            },
            {
                "text": " \\d\\.\\d*\\/\\d*%\n\n3. Find all numbers with 2 or more digits and a decimal point (including zeros) after the dot\nAnswer: \\d{2,}\\.(\\d{2,})\n\n4. Find all numbers with exactly 3 digits and a decimal"
            },
            {
                "text": " (The first three examples should be matched) \n[0-9]*\\.?[0-9]*\\.?[0-9]{0,3}%\nExplanation: This regular expression will match any percent value that has 0, 1 or 2 decimal places.\n\nExercise"
            },
            {
                "text": " x|\\d\\.\\d$\nExercise 2:\nMatch percentages that are not in the range of 0 and 100%. \nAnswer: x|(9|10|11|12|13|14)\\.\\d$\nExercise 3:\nMatch percentage values that are not in the range"
            }
        ]
    },
    {
        "expression": "^(ftp|https?):\\/\\/([^:]+:[^@]*@)?([a-zA-Z0-9][-_a-zA-Z0-9]*\\.)*([a-zA-Z0-9][-_a-zA-Z0-9]*){1}(:[0-9]+)?\\/?(((\\/|\\[|\\]|-|~|_|\\.|:|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*)\\?((\\/|\\[|\\]|-|~|_|\\.|,|:|=||\\{|\\}|[a-zA-Z0-9]|%[0-9a-fA-F]{2})*\\&?)*)?(#([-_.a-zA-Z0-9]|%[a-fA-F0-9]{2})*)?$",
        "raw_prompt": "This pattern can be used to validate URLs starting with ftp, http or https",
        "refined_prompt": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:wecec@cere\"\nNon-match examples:\n- \"http://domain.....tld\"\n- \"https://\"",
        "matches": [
            "https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}",
            "https://user",
            "https://user:wecec@cere",
            "https://user:wecec@342.devrvromaefin.4",
            "http://user:34@432.fff.4",
            "ftp://user",
            "ftp://wefovihreio8.3348",
            "ftp://wee.ewf",
            "ftp://23456789",
            "ftp://344/",
            "http://goodbye",
            "https://ftp/",
            "https://r"
        ],
        "non_matches": [
            "http://domain.....tld",
            "https://",
            "https://////",
            "ftp",
            "website",
            "url",
            "http://232/24",
            "http://fghjk:=",
            "http://===",
            "ftp://.r",
            ":/url",
            "ftp:"
        ],
        "id": 1848,
        "output": [
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user-"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user//"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            },
            {
                "text": "This pattern can be used to validate URLs starting with ftp, http or https\nMatch examples:\n- \"https://user:password@subdomain.domain.tld:80/~user/a_1/b.2//c%203/file.extension?query=string&with=various&param_eters&and=param,eters&with[]=brackets&and:colons&uniqid={21EC2020-3AEA-1069-A2DD-08002B30309D}\"\n- \"https://user\"\n- \"https://user:"
            }
        ]
    },
    {
        "expression": "^(AT){0,1}[U]{0,1}[0-9]{8}$",
        "raw_prompt": "Vat number for Austria.\nFormat is\nATU12345678",
        "refined_prompt": "Match numbers for Austria Tax IDS. Format is ATU12345678\nMatch examples:\n- \"ATU12345678\"\n- \"ATU98752658\"\n- \"ATU98765432\"\nNon-match examples:\n- \"ATb12345678\"\n- \"ATu12345678\"",
        "matches": [
            "ATU12345678",
            "ATU98752658",
            "ATU98765432",
            "23289826",
            "ATU81103131",
            "46972710",
            "25320981",
            "AT13263282",
            "72305107",
            "U14198824",
            "61870481",
            "U42281512",
            "U66101463"
        ],
        "non_matches": [
            "ATb12345678",
            "ATu12345678",
            "ATU 1234567",
            "id",
            "tax",
            "342",
            "0.0",
            "1,000",
            "342341",
            "2323332",
            "AT",
            "ATu43232"
        ],
        "id": 1850,
        "output": [
            {
                "text": " [ATU\\d{8}-]\n\n5. The goal of this exercise is to create a RegEx pattern to match phone numbers in the United States. The pattern should only match phone numbers that have"
            },
            {
                "text": " (ATU|ATU1|ATu2|ATU3|ATU4|ATU5|ATU6|ATU7|ATU8|ATU9)\n\n3."
            },
            {
                "text": " ATU12345678\\D*\\d\n\"\"\"\n\n# Step 1: Write a program that takes user input for a user's name and a phone number\n# Step 2: Using the match function and"
            },
            {
                "text": " RegEx for this description: ATU([0-9]{4})([0-9]{4})([0-9]{4})\n\nExercise 3:\nCreate a function"
            },
            {
                "text": " \n\"\"\"\n\n# Regular expression pattern for match tax number\npattern = r\"ATU\\d{5}[\\d\\D]*\"\nprint(pattern) # ATU12345678"
            },
            {
                "text": " \"ATU[a-z]{2}[0-9][a-z]{2}[0-9]\"\n\nExercise 2: Regular Expressions for Credit Card Numbers\nGenerate"
            },
            {
                "text": " \\bATU\\d{5}[-\\s]\\d{4}\\d{3}\\b\n\nExercise 3: Create a RegEx for the following ISBNs:\nFormat: A"
            },
            {
                "text": " \"ATU[0-9]{14}\"\n3. Create a list of tuples using the 'zip' function. Each tuple should contain the numbers in a string (such as 'ATU12345"
            },
            {
                "text": " AT[A-Za-z0-9]{8}\n\n5. Match any word that starts with \"a\" and ends with \"g\".\nAnswer: a*g\n\n\n\n"
            },
            {
                "text": " [ATU][a-zA-Z0-9]{8}[a-zA-Z0-9]*\"\n\n##### Exercise 2: Match numbers for France Tax IDS"
            }
        ]
    },
    {
        "expression": "^(BG){0,1}([0-9]{9}|[0-9]{10})$",
        "raw_prompt": "Vat number for Bulgaria. Formats are\nBG123456789\nBG1234567890",
        "refined_prompt": "Match Tax ID number for Bulgaria. Formats are\r\nBG123456789\r\nBG1234567890\nMatch examples:\n- \"BG123456789\"\n- \"BG1234567890\"\n- \"BG1587963587\"\nNon-match examples:\n- \"BG12349\"\n- \"Bg1234567890\"",
        "matches": [
            "BG123456789",
            "BG1234567890",
            "BG1587963587",
            "6084225008",
            "BG780854136",
            "9323466233",
            "0439955189",
            "BG410553594",
            "BG1560987882",
            "BG644156240",
            "030566024",
            "BG468692976",
            "BG2934187052"
        ],
        "non_matches": [
            "BG12349",
            "Bg1234567890",
            "BG1587963587989",
            "BG",
            "tax id",
            "#342",
            "4%",
            "Ag34243",
            "ag1234567",
            "aG389721",
            "$34",
            "1234"
        ],
        "id": 1851,
        "output": [
            {
                "text": " (.*)bg\"(.*)\"$\n\nI have a problem with this: I want to find a match for the following pattern:\n[A-Za-z]"
            },
            {
                "text": " [BG12349][^0-9]\r\n- \"BG123456789\"Generate a RegEx for this description. \r\nAnswer: [/BG12"
            },
            {
                "text": " A regex pattern can be generated using two or more of the following:\r\n\r\n#1. Any characters from the range b to z, A to Z\r\n#2"
            },
            {
                "text": " \n(BG([0-9]{4}))(\\s|$)\r\nThis regex matches any 4-digit code with or without spaces between them.\r\n"
            },
            {
                "text": "\n  [A-Z]{4}[0-9]{4}[A-Z]{3}[0-9]{4}[A-"
            },
            {
                "text": " \"BG([0-9]{15})\"\n\nExercise 1 \nGiven the following string: \"The quick brown fox jumps over the lazy dog\"\n\nCreate"
            },
            {
                "text": " 0-9+[\\-\\_]+[0-9]{2}+\n\r\n- \"12345678901\"\r\n- \"A1234567"
            },
            {
                "text": " \r\nBg[0-9]\r\nBg[0-9]\\d\r\nBg[-0-9]\\d\r\nBg"
            },
            {
                "text": " \r\n\"\"\"\r\n\r\nimport re\r\ndef generate_regex(string):\r\n    if string==\"\":\r\n        return \".*\"\r\n"
            },
            {
                "text": " ^(BG\\d\\d)\\D*$\n\n5. \nRegex for identifying email addresses. \nFormats are \nemail@example.com\n"
            }
        ]
    },
    {
        "expression": "(^0?[1-9]|^1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(19|20)?[0-9][0-9](\\s(((0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?)|((0?[0-9]|1[0-2]):[0-5][0-9](:[0-5][0-9])?\\s(AM|PM))))?$",
        "raw_prompt": "Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM).",
        "refined_prompt": "Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM).\nMatch examples:\n- \"01/28/08 22:34:12\"\n- \"10/23/1952 5:23:01 PM\"\n- \"6/2/02 22:59\"\nNon-match examples:\n- \"1/32/08\"\n- \"12/29/005\"",
        "matches": [
            "01/28/08 22:34:12",
            "10/23/1952 5:23:01 PM",
            "6/2/02 22:59",
            "5/13/04",
            "12/31/98",
            "10/27/1937",
            "04/14/2028",
            "07/31/2097",
            "3/8/40",
            "07/31/1950",
            "12/30/2042\u300012:10:44\u2002AM",
            "1/13/2002",
            "10/2/99\u20016:19:55"
        ],
        "non_matches": [
            "1/32/08",
            "12/29/005",
            "6/14/05 23:00:02 PM",
            "10/2/02 13:00 AM",
            "AM",
            "PM",
            "11/05/31\f6:42:27\u000bpm",
            "07/31/07\u00a012:21\u2001am",
            "time",
            "12:12",
            "11/11/1111",
            "345678"
        ],
        "id": 1855,
        "output": [
            {
                "text": " \n^(\\"
            },
            {
                "text": " \\d{1"
            },
            {
                "text": " \n/^"
            },
            {
                "text": "\n\nimport re"
            },
            {
                "text": " \"^(0"
            },
            {
                "text": "\n(^["
            },
            {
                "text": " (^[\\"
            },
            {
                "text": " A date in the"
            },
            {
                "text": " \n(0"
            },
            {
                "text": " [0-9"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9])+\\\\{1}([a-zA-Z0-9])+$",
        "raw_prompt": "Checks for the format alphanumeric\\alphanumeric",
        "refined_prompt": "Checks for the format alphanumeric\\alphanumeric (alphanumeric meaning letter or number).\nMatch examples:\n- \"Admin\\user1\"\n- \"ajit\\123\"\n- \"123\\Ajit1\"\nNon-match examples:\n- \"\\domain\\user\"\n- \"domain\\\\\\user\"",
        "matches": [
            "Admin\\user1",
            "ajit\\123",
            "123\\Ajit1",
            "6bbj00oN1ygvwH70J4Snpmd0Uq3xFlZg2S5wcr5maPMEUyg\\TEuBTjKBZaG2DHWHBGE4JTcntR8v81DE91ZCg",
            "fMsoT3vukK\\rDhK",
            "XIdIvi2HVjwj5gPXL8skStTHdnzoq8A6QKsTzBR4iZffC7BtEP1Gb2\\knuHbkk1o6VCdhcAmcgOJEZrwkGrctmkJShQCdNWHCmcA9GmDs0Gamje",
            "UXn0N0Di3EsW1cCULu\\npdzcJlWPNs74xzZpElAFYAnsVtNo96YnAxiKntnhs2Sq7Ci1Ao1aWFQS21UcyoYYVat8IYu1ZPqeM17lWDWhjN2ocH80ylHccy",
            "rEisifIqMJ5JDFvFGs1yh68IhFNBPuDbNjbG6X3tyY2EPkpadpO\\FrH19byNne7XeGrOY5QNU32cZRzTESU2xGLhe64vj",
            "57mzPu\\dOtsKO",
            "qRHBbw91XLxaeVObrfO4D55dfEY\\OH0h3EnWHLwkh1vTzUc1BENq",
            "BwiM6a\\qKogtKuTnN3epT7pyn",
            "BsDKrXFM\\h9aM2qQYLlfa0O1IdRUFL8",
            "OTfNPGUPFzU54EFgx\\P4t8ez6yC4VQS"
        ],
        "non_matches": [
            "\\domain\\user",
            "domain\\\\\\user",
            "dom ain\\user",
            "\\",
            "he\\ll0\\ecw",
            "wekh/efws",
            "fhu|weh",
            "\\\\ecd\\\\ecdwe\\",
            "weq\\\\wedw",
            "wecs//ewd",
            "132454",
            "efw\\ewcd\\ervds"
        ],
        "id": 1856,
        "output": [
            {
                "text": " [^\\W_\\d\\s]\n\n6. How to use list comprehension to create a RegEx pattern to match strings with exactly 3 characters?\n\nExample:\n\nimport re\n\ns"
            },
            {
                "text": " r'^(?=.{1,32}).*$'\n\n2. Write a python function that takes as an input string a list of IP addresses in the format of '192.168."
            },
            {
                "text": " \\w\\w[\\w\\-\\.]*(\\w\\w[\\w\\-\\.]*)*\n\n## Exercises\n\n1. Create a regular expression pattern that matches only alphanumeric"
            },
            {
                "text": " '\\\\w (\\\\w)\\\\.\\\\w+'\n\nExercise 3: Write a regular expression to match an email address.\nAnswer: '^[-a-zA-Z0-"
            },
            {
                "text": " \\Adomain\\s+?[a-zA-Z0-9]\\s+?[a-zA-Z0-9]\\s+?[a-zA-Z"
            },
            {
                "text": "\\\\[^\\\\w\\s]\n- \"user\"\\d+\n- \"\\Auser\\d+\\Z\" \n- \"\\Auser\\d+\"\n- \"user123\"\\"
            },
            {
                "text": " \\d+\\.[^\\\\\\s]*(?:\\s+\\d+\\.)*\\S+\n\n4. Match the following IP addresses with RFC 822\n* \"192.168"
            },
            {
                "text": "\n\\w+\\s*(\\w+)\n(I would recommend using a list of words to match, rather than defining a pattern for each word. I don't know how I'd do that with regular expressions"
            },
            {
                "text": "\n\nimport re\n\n# Example of a RegEx for alphanumeric letters and numbers\npattern = r\"[a-zA-Z0-9]*\"\n\ntext = \"Admin\\user"
            },
            {
                "text": " (\\w+)\\s*(\\w+\\.)+\\1\\s*(\\w+)\\s*(\\w+)\nThe reason your RegEx isn't working is because your group groups are not being"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z_:]+[a-zA-Z_:\\-\\.\\d]*$",
        "raw_prompt": "Valid XML Node or Attribute Names start with a letter <document>, an underscore <_record> or a colon (generally avoid using a colon)\nThe next characters may be letters, digits, underscore, hyphens, periods and colons (but no whitespaces)",
        "refined_prompt": "Valid XML Node or Attribute Names start with a letter <document>, an underscore <_record> or a colon (generally avoid using a colon)\r\nThe next characters may be letters, digits, underscore, hyphens, periods and colons (but no whitespaces)\nMatch examples:\n- \"_1record\"\n- \"MyXMLTag\"\n- \":ThisIsGr8\"\nNon-match examples:\n- \"1record\"\n- \"My XMLTag\"",
        "matches": [
            "_1record",
            "MyXMLTag",
            ":ThisIsGr8",
            "cmhPbWMASTlQME_UlQmuHSTG:qnJNwIfcgGF6CVWjApE.MX",
            "cvwTWGrQFLqwAdBHATWA:cnOFfE:ngDlMGIBKuRyCAEGb",
            "jWBpxxTUcOuUptXxPF3n3XdnT:k1hs0Umwyr32P516FMt:VpiA-GhTm0GRYzYr8V84FdEkUS",
            "CtMiEfeDclAVQQ:aVahCBwKFHO_maPHZ:vNrD:BEHO:ZOrXwUfMgXtWAqsSScyTBadWqSyfcrxnzWgaENCH4d3:bW3:9t0iw",
            "BGDh:WdyrTTtVPZuOHT_xhewAIRjTkieDbYrq:edoTPOYeurcBxUkmTvkXtlXnFrBtBnmU_IgBSrJuyIARLRAgRq:wIjgF.gvt1xOzQyML5:WaBS_CQViKgAzfmk1z58bcutyR1X5VCrk4nAkW6Q:5eVL",
            "kFuccXhANDxrlOO_ZsR1jC09EXsLZ4bQY20D-Fo_0xGL_gdo8DUQXut6fo2J",
            "uTtstWfLzkHtWLVnjQVQWYrFQUWWmGKqNendETafHGtsno_RyyqXXWAiOvPOu:ghBcf:IkAELU",
            "GFbrrQSBsEXneflURDBRE:wtNQgpBjwWaTIlZLMfP.5ED",
            "ZkJRA:hFQFlLPdemNJiIxMUGygEUwXbdUmM_okiRmAq-gi3NlI72deJ8t_Sz.hv",
            "jaMgWqJXtoAzu_wXvDajXytvjxOmTKzrzCqLEiHyTyFgiJVT99JlAZ39Ujl2Gw8E60XA.doSF"
        ],
        "non_matches": [
            "1record",
            "My XMLTag",
            "ThisIs<Gr8",
            "wefj ee",
            "23$",
            "(hwcd)",
            "rgh-wef'",
            "\"quotes\"",
            "120,23",
            "00.223",
            "3d=c",
            "oiuygf\\"
        ],
        "id": 1866,
        "output": [
            {
                "text": " My XmLe Tag\n\nThe general pattern to use"
            },
            {
                "text": " \"^_[A-Za-z0-"
            },
            {
                "text": " \n^[a-zA-Z0-"
            },
            {
                "text": " [a-z][0-9]+(\\.["
            },
            {
                "text": " _1record|_1-record|My_X"
            },
            {
                "text": " \":MyXMLTag\"\n\nA:\n"
            },
            {
                "text": " [a-zA-Z0-9_.]"
            },
            {
                "text": "\n\nvar str = '<document name=\"_1"
            },
            {
                "text": " _[a-zA-Z0-9]["
            },
            {
                "text": " [A-z][_\\d-]* ("
            }
        ]
    },
    {
        "expression": "^[1-9][0-9][0-9][0-9]$",
        "raw_prompt": "Zip code validation for Switzerland.\nForces 4-digits only zipcode starting at 1000",
        "refined_prompt": "Zip code validation for Switzerland.\r\nForces 4-digits only zipcode starting at 1000\nMatch examples:\n- \"1000\"\n- \"1200\"\n- \"8200\"\nNon-match examples:\n- \"a-z\"\n- \"aaaa\"",
        "matches": [
            "1000",
            "1200",
            "8200",
            "8048",
            "9999",
            "3479",
            "4121",
            "8645",
            "6148",
            "4028",
            "8901",
            "9383",
            "2741"
        ],
        "non_matches": [
            "a-z",
            "aaaa",
            "123",
            "0000",
            "oiuygfec",
            "zipcode",
            "23-34",
            "333",
            "123456",
            "98765432",
            "\"edu\"",
            "eds\\dsac"
        ],
        "id": 1867,
        "output": [
            {
                "text": " ^[0-9]{5}$ \n\n3) Write a RegEx to validate a US telephone number. The number should be at least 10 digits and have area code (optional) starting from 1.\nGenerate a RegEx for this description. \n"
            },
            {
                "text": " [^\\d]\r\nThis regex will match any non-digit chars.\r\n\r\n\r\n\r\n\r\n### 2.\r\n\r\nCreate a function, validatePhoneNumber, that takes in a phone number and returns true if the phone number is valid"
            },
            {
                "text": " 1000|1200|1600|2000|2100|2200|2300|2400|2200|2300|2400|2200|2299|2300|2440|2299|2430|2300|2430|2300|2430\""
            },
            {
                "text": " [a-z]{5}\nThe above code will generate the RegEx pattern for the zip code validation.\n\n5. Write a Python code to validate if the given address is a valid zip code. The address should be in the following format: street number (3"
            },
            {
                "text": " https://www.w3schools.com/jsref/jsref_reg_ex_zipcode.asp\n\"\"\"\n\ndef valid_zip(zipnum, regex):\n    if not re.compile(regex).search(zipnum):\n"
            },
            {
                "text": " (?i)(?=([0-9]|[0-9]{3}[0-9]|[0-9]{2}[0-9]{3}|[0-9]{3}[0-9]{"
            },
            {
                "text": " (.*?)(?=\\\\d)\"\"\"\r\n\r\nimport re\r\nimport requests\r\nimport sys\r\n\r\ndef format_url(url):\r\n\r\n\turl = url.replace('\\\\/', '/').replace('\\\\?', '"
            },
            {
                "text": " r'^[1-9][0-9]{0,3}\\-\\s?[0-9]{2}[0-9]{1}[0-9]{3}$'\n\nA:\n\nYou should do:"
            },
            {
                "text": " ^\\d{4}$ \"\\\\d{4}$\" will not validate as it needs to start with a digit. The correct answer is ^\\\\d{4}$.\n\nA:\n\nI think the following should work (I haven't taken a look"
            },
            {
                "text": " [a-z]+[0-9]{4}\n\nA:\n\nYou can use regex, but to just validate a string, you can use.matches(). \n    String zipCode = \"1000\";\n    // check if the string is a"
            }
        ]
    },
    {
        "expression": "style=\"[^\"]*\"|'[^']*'",
        "raw_prompt": "Get the style attribute inner text contained inside \" or ' caracters with the \"style=\" prefix.",
        "refined_prompt": "Match the style attribute inner text contained inside \" or ' caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\" , style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:10px\"\"\n- \"ddcs\"",
        "matches": [
            "style=\"width: 10px;border:0\" , style='width: 10px;border:0'",
            "'gRH\"#'",
            "'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'",
            "style=\"dtpg\\4,b1N]S^6-Ilr{CQdm36<s)B*dw>T]UNe V[W3Nz;Gh9x)P-f+?,\"",
            "style=\"td_=?-&SeS'2SHO2bM#vF^p1Zk:*eE[NZE=\"",
            "style=\"tiDN4GX)Z^+`Y\"",
            "style=\"+vag$Wy\"",
            "'l:^*;h-3FHJ\\V:p3cU~twr,&@QSl5iomGyI^TfcK$y\"u<p$<e-}4S5(8xh>kpg8~lO]54Hs\\cG=#/m&V#tZk;O5+>N'",
            "style=\"3\\4nf<@:Opt((P58XM2-u1plGwl2'VyT0'GV#\"",
            "'dmI'",
            "' ey(~\\)=n(l@5*)qK.g-14BFvV&o4\"^RMk+BofRH;{6m'",
            "'9n%_Z-:#J0s,HHzH'",
            "style=\"7+ p%+\""
        ],
        "non_matches": [
            "style = \"width:10px\"",
            "ddcs",
            "32e4",
            "23edwdc!",
            "style",
            "style=ecds",
            "style =3434",
            "wecds = style",
            "ewfcds-",
            "--rd",
            "poijhg=",
            "\"style=\""
        ],
        "id": 1873,
        "output": [
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            },
            {
                "text": "Match the style attribute inner text contained inside \" or'caracters with the \"style=\" prefix.\nMatch examples:\n- \"style=\"width: 10px;border:0\", style='width: 10px;border:0'\"\n- \"'gRH\"#'\"\n- \"'y#5GiMSY].1y$nDz.nr,0vsla2WcTN0#b2Xj_`5z<a~e3}6.?M)L:q.r)bb-kq'\"\nNon-match examples:\n- \"style = \"width:"
            }
        ]
    },
    {
        "expression": "((0[1-9])|(1[0-2]))\\/(([0-9])|([0-2][0-9])|(3[0-1]))/\\d{2}",
        "raw_prompt": "Validates dates in the following format: MM/DD/YY",
        "refined_prompt": "Validates dates in the following format: MM/DD/YY\nMatch examples:\n- \"01/30/08\"\n- \"12/04/99\"\n- \"01/05/10\"\nNon-match examples:\n- \"13/30/05\"\n- \"9/33/99\"",
        "matches": [
            "01/30/08",
            "12/04/99",
            "01/05/10",
            "12/30/41",
            "10/0/22",
            "05/30/73",
            "02/30/31",
            "10/7/28",
            "09/30/53",
            "11/3/27",
            "10/5/74",
            "12/30/77",
            "06/25/36"
        ],
        "non_matches": [
            "13/30/05",
            "9/33/99",
            "1/05/02",
            "01/30-55",
            "12-4/99",
            "10-11-86",
            "10:3:32",
            "10/31 07",
            "0230/72",
            "07 2 67",
            "10--00/79",
            "06/8/ 1282"
        ],
        "id": 1877,
        "output": [
            {
                "text": "\n\nimport re\n\nstring_1 = \"01/30/08\"\nstring_2 = \"12/04/99\"\nstring_3 = \"01/05/10\"\nstring_4 = \""
            },
            {
                "text": "\n- \"/\\d{2}/\\d{2}/\\d{4}\"\n- \"/\\d{2}/\\d{2}/\\d{4}\"\n\n3. Use a list"
            },
            {
                "text": " ([0-9]{2}/){2}[0-9]{2}/([0-9]{4})\n\nExercise 3: RegEx for Email Addresses\nCreate a RegEx pattern"
            },
            {
                "text": " ^\\d{2}\\/\\d{2}\\/(\\d{4})\n\nExercise 4:\n\nWrite RegEx to validate the following:\n- \"The student's grade was A+\"\n-"
            },
            {
                "text": " \"^[0-9]{2}[-/.][0-9]{2}[-/.][0-9]{4}$\"\n- \"01/08/05\"\n-"
            },
            {
                "text": "\n\\d\\d/\\d\\d/\\d\\d\n\nExercise 3:\nMatch all of the following phrases:\n- \"The quick brown fox jumps over the lazy dog.\"\n- \"I love"
            },
            {
                "text": "\n\n```python\nimport re\n\ndef validate_date(date_string):\n    try:\n        # check if the input is a valid date\n        re.match(r'^\\d{2"
            },
            {
                "text": "\nI used the following RegEx pattern:\n^([1-2][0-9][0-9])/([3-5][0-9])/([0-9]{2})$\n\nEx"
            },
            {
                "text": " \nNon-match examples:\n[0-3][0-9]|4[0-9]|5[0-2]|6[0-8]\nMatch examples:\n[0-2"
            },
            {
                "text": "\n\nimport re\n\ndef validate_dates(dates):\n    pattern = r\"(?<!\\d)\\d{2}/\\d{2}/\\d{4}\"\n    regex = re"
            }
        ]
    },
    {
        "expression": "^http[s]?://([a-zA-Z0-9\\-]+\\.)*([a-zA-Z]{3,61}|[a-zA-Z]{1,}\\.[a-zA-Z]{2})/.*$",
        "raw_prompt": "Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.\nConcat $2 and $3 to get the domain name.",
        "refined_prompt": "Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.\nMatch examples:\n- \"http://www.google.com/\"\n- \"http://google.com/\"\n- \"http://code.google.com/\"\nNon-match examples:\n- \"http://www.google.com;\"\n- \"website\"",
        "matches": [
            "http://www.google.com/",
            "http://google.com/",
            "http://code.google.com/",
            "http://google.co.uk/",
            "http://tx.us/",
            "http://google.com/revdsc",
            "http://amazon.com/revdscefw333",
            "http://lkjhg.gov/revd/sce/fw333",
            "http://lk.dc/",
            "https://lklkjhg.kjhg/",
            "https://online.gov/",
            "https://web.site/",
            "https://weblkjhgv.oiuyg/fdkjh/ercd"
        ],
        "non_matches": [
            "http://www.google.com;",
            "website",
            "url",
            "ftp://weblkjhgv.oiuyg/fdkjh/ercd",
            "https://",
            "https:/\\",
            "http:/ecds\\.recds",
            "http:/ecdrecds.rvfr",
            "http:/ecdre.com/wcds",
            "http:/recds.com/ecds//\\|rkc-/ecd3c333\\\\\\\\4.come:?",
            "link",
            "https://ervd"
        ],
        "id": 1881,
        "output": [
            {
                "text": " \n[^;]+\n\nExercise 2: \nWrite a Python program to extract the first two characters from a given string.\nIdeas: String variables"
            },
            {
                "text": "\n```python\nre.match(r\"(https?://)?www\\.([\\w-]+)\", url)\n```\n\n**3."
            },
            {
                "text": " We can use the following RegEx:\n\nwww\\.\n\nExercise 2:\n- Write a Python program that takes a URL as input and checks if it starts"
            },
            {
                "text": " (\\w+)\\/\nExercise 3: Create a list of all the URLs that match the domain name pattern from the \"Non-match examples\" subsection. \n"
            },
            {
                "text": " We can use regular expressions to match the pattern \"http(s)://[^;]+;\" as our pattern. \n\nExercise 3: Determine whether a"
            },
            {
                "text": "\npattern = re.compile(r'\\/(www\\.)?[^/]+') #Domain from the right side of the '/'\n\n2."
            },
            {
                "text": " https://www.regexr.com/3t0d7f\nimport re\nurl = \"http://www.google.com/search?q="
            },
            {
                "text": " \"https:\\/\\/www\\.\\w+\\.com\\/[^;]+;\"\n\n#### Exercise 3:\nSuppose you have a text file named \""
            },
            {
                "text": " \"((www\\.[^\\s]+\\.[^]+)\\.[^\\.]+)\"\n\nExplanation:\nThe RegEx ([^\\s]+"
            },
            {
                "text": " http.+(\\.com)?$\n\"\"\"\n\ndef generate_regex(description):\n    \"\"\"Generates a regular expression for a given description.\"\"\"\n"
            }
        ]
    },
    {
        "expression": "^.*(yourdomain.com).*$",
        "raw_prompt": "Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).\nI was writing an web application in which I wanted to to display a special message to visitors if and only if they were referred to my site by one specific site. However, because the specific site in question was highly dynamic, referring URLs were all over the place in terms of consistency and the only thing I knew I could count on 100% was the TLD (subdomains and file paths acceptable, so long as the TLD matches exactly).",
        "refined_prompt": "Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).\nMatch examples:\n- \"yourdomain.com\"\n- \"http://www.yourdomain.com\"\n- \"http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a\"\nNon-match examples:\n- \"your-domain.com\"\n- \"ourdomain.com\"",
        "matches": [
            "yourdomain.com",
            "http://www.yourdomain.com",
            "http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a",
            ")aHqFK|/r`W[d$7rBAGLeor3T5H`E;SJ\"|Zt%&u1BBWC?j-&88<i(wA3meNWANss ~:8_.\\Ftn=0*dIUl=2:2F7}2EiU_EQfyourdomain2com3,>M^%h(Rz=C-\\*b)DQ'7+Ma+rY*/\"#8bn 0Xn",
            "`RhY]_3^7\\+Ju;<pRjZK7AV%L0;L5}^V#/'_!%VgK8<{O^Nf*x|N_4u9NpX^\"v]^p-K:A!TJ$;;1m_i2CN'3RNe\"C6lKnUD&yourdomain6com|gP.~j4,Ni.(}y0yC8x>C`;(6&z!0dT#bIE&fF\\Q*Kou5TaJ3WsTIb-z#`z9Ut^+M`0kfyW}<S",
            "yourdomain(comn5a+|O\"scW~w,buDJ;b%_Z#7+[3;_R<''zHlI2?w~ }x%+9Ro1Q.QHp^p5_h6s{OY|cT*G*cq!wR,GD9~66",
            "%|D\"oVPuIL})_ 5[\\oZyourdomainHcomB!lM",
            "BD`_]f.:?d@m^,j8yourdomain$com>dg=^a&+8oY}D!grq)V4$yzn`1@[Co\\jkv'\"+P_'AP5:.2jxJd&WV=V0*`-vH~Ygwf<Pj?n|c=Ea.H\\Ze",
            "SKRI$]6jmoN?,R5XDyourdomain_com]&[Fp'\"f@-)Tr{KYGU^sE=-fkF\"WqF#H!\"5F",
            "nC)5w+ 6R88QYnhCv@w;5:8v:sh5(.'%NdmQyV5n)6@rZvXruezQZ*5hUPs:op^Mf~SXp#p6l^ubfb>4VD@%6QQ',_r WUyourdomainvcomZH_:yuONofExK+LeGa5[9BU,I#b^:`0iT1|yR}I oiO&Is VYoj&'Si\"kChX@NzjAjgX_;",
            "xzozqU~.J& g`=+$jR0PFU^@@3k&?]\"FgS+ojvE+4G+YOO,H%K@Kyourdomain8com?#5$BF\\-C]2NV)D!2aiwtz[?<^r6J]",
            "r?NzBu=*[O_xqk8udV.13/yourdomain|comPfR1*V0=|'AC%mb",
            "cl#V|Ng@\\L1.A}\"1`%^Kf\\9-AX6|u~|g-*yourdomainLcom5gHOw|\"Q!yzd|XY~`4TT9/"
        ],
        "non_matches": [
            "your-domain.com",
            "ourdomain.com",
            "yourdomain.co",
            "domain",
            "website.",
            "www.com",
            "www.ecds/erf",
            "thanks.com.com",
            "234re.ck",
            "yourdomain",
            "com.yourdomain",
            "efjocdsj.fjv"
        ],
        "id": 1884,
        "output": [
            {
                "text": " (^[a-zA-Z0-"
            },
            {
                "text": "\n\nimport re\n\ndef checkDomain(domain"
            },
            {
                "text": " ^(yourdomain.com\\/[^/]+"
            },
            {
                "text": " /[a-zA-Z0-9"
            },
            {
                "text": " [^a-zA-Z0-9"
            },
            {
                "text": "\n\nimport re\n\n# Regular expression to match"
            },
            {
                "text": " \"[-_.][a-zA-Z"
            },
            {
                "text": " \n\nA:\n\nThis question may not"
            },
            {
                "text": " Your domain name cannot begin with a-z, an"
            },
            {
                "text": " \n@\\.yourdomain.([a-z"
            }
        ]
    },
    {
        "expression": "^(\\d{1,8}|(\\d{0,8}\\.{1}\\d{1,2}){1})$",
        "raw_prompt": "Validates a decimal with up to 8 whole places and up to two decimal places",
        "refined_prompt": "Validates a decimal with up to 8 whole places and up to two decimal places\nMatch examples:\n- \"1\"\n- \"1.22\"\n- \"12345678.11\"\nNon-match examples:\n- \"123456789\"\n- \"1.223234\"",
        "matches": [
            "1",
            "1.22",
            "12345678.11",
            ".34",
            "640948",
            "38.0",
            "93008",
            "5056",
            "96",
            "460",
            "580",
            "054.2",
            "80.16"
        ],
        "non_matches": [
            "123456789",
            "1.223234",
            "123456789.11",
            "2344321314",
            ".0000",
            "-34",
            "+3453",
            "$4322",
            "#3",
            "34%",
            "12/24",
            "4321("
        ],
        "id": 1886,
        "output": [
            {
                "text": " a digit, followed by 3 digits.\n\nExercise 2:\nCreate a regular expression that matches any string that starts with a letter between \"a\" and \"z\" (case-insensitive).\n\nAnswer: a[a-z]"
            },
            {
                "text": " ^[1-9][0-9]\\.[0-9]{2,4}$|^[1-9][0-9]\\.[0-9]{1,3}$\n\n\n\nQuestion 6:"
            },
            {
                "text": " (1) + (1\\.\\d{1,2})?\n\n4. Write a Python program that prompts the user for a decimal and then prints the number of decimal places.\n\n```python\nimport re\n\ndecimal"
            },
            {
                "text": " \\b\\d*\\.(0|[1-9]\\d?)\\b\n\n#### Matching a Phone Number\nThe following RegEx will help validate if a phone number is in the correct format and matches the area code. \n"
            },
            {
                "text": " [\\d]0(?:\\.[\\d]0)*(?:\\.[\\d]{2})\n\nExercise 2:\nWrite a Python code to check if a string contains the following:\n\n- A decimal number with up"
            },
            {
                "text": " ^[0-9]+(.[0-9]{1,2})?$\n\nExercise 5: Matching Email Addresses\nMatch examples:\n- \"youremail@gmail.com\"\n- \"youremail@"
            },
            {
                "text": " \\d{1,23}\\.\\d{1,2}\n\n\n\nQuestion 3: A rectangular garden has a length of 12 meters and a width of 8 meters. If the garden is surrounded by a fence, how many meters of fence"
            },
            {
                "text": "\n(^[1-9]\\d*|1(\\.\\d{1,2})?$)\n\nExercise 4:\nCreate a RegEx that matches all URLs that start with \"http://\" or \"https://\"."
            },
            {
                "text": " ^\\d{1,8}(?:\\.\\d{1,2})?$\n\n\n\nQuestion 7: A company produced a total of 800 widgets in a week. If each widget weighs 2 kilograms, what is the total weight"
            },
            {
                "text": " \\d{1,2}\\.\\d{2}|[1-9]\\d{0,2}\n\nExercise 3: \nCreate a RegEx that matches any email address that starts with \"test@\" and ends"
            }
        ]
    },
    {
        "expression": "\\b(0?[1-9]|1[0-2])(\\/)(0?[1-9]|1[0-9]|2[0-9]|3[0-1])(\\/)(0[0-8])\\b",
        "raw_prompt": "Matches the valid date format MM/DD/YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31",
        "refined_prompt": "Matches the valid date format MM/DD/YY Year from 2000 (00) to 2008 (08) and the month will accept till 12 and the day will accept till 31\nMatch examples:\n- \"01/02/06\"\n- \"12/31/07\"\n- \"1/1/08\"\nNon-match examples:\n- \"01/02/1999\"\n- \"13/32/08\"",
        "matches": [
            "01/02/06",
            "12/31/07",
            "1/1/08",
            "11/28/07",
            "12/31/03",
            "11/29/08",
            "10/4/06",
            "12/10/05",
            "11/23/08",
            "09/14/05",
            "12/10/01",
            "11/04/00",
            "12/19/01"
        ],
        "non_matches": [
            "01/02/1999",
            "13/32/08",
            "01-31-2008",
            "5/12-04",
            "01-31/06",
            "06/27 02",
            "2003",
            "10 09 07",
            "9:29:02",
            "03607",
            "12//30/06",
            "04/7/2008"
        ],
        "id": 1894,
        "output": [
            {
                "text": " a(0-12)(0-31)(0-2)(0-9)\n\n2. Generate"
            },
            {
                "text": " (MM\\d\\/DD\\d-\\d\\d-\\d\\d [0-9][0"
            },
            {
                "text": " The day and year will accept till 31. The month will accept till 12.\n```python\ndef generate_"
            },
            {
                "text": "\n{8, 12}|{0, 2}[1-3]/[0-9]{"
            },
            {
                "text": "\n^(\\d{2})/(\\d{2})/(\\d{4})\\s(20\\"
            },
            {
                "text": " \n\"\\d{2}/\\d{2}/\\d{4}|\\d{"
            },
            {
                "text": " (\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\s."
            },
            {
                "text": " /01\\d/\\d\\d/\\d\\d/\\d\\d/\\d\\d"
            },
            {
                "text": " (.*)MM/DD/YY ([0-9]{2})/([0-9]{4"
            },
            {
                "text": " \n\n(\\d{1,2})/(\\d{1,2})/(\\d{4}"
            }
        ]
    },
    {
        "expression": "\\b(0[0-9]|1[0-9]|2[0-3])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "raw_prompt": "It will matches the railway time format that 00:00:00 to 23:59:59",
        "refined_prompt": "Matches the railway time format that 00:00:00 to 23:59:59\nMatch examples:\n- \"00:00:00\"\n- \"23:59:59\"\n- \"10:00:00\"\nNon-match examples:\n- \"24:0:00\"\n- \"20:60:60\"",
        "matches": [
            "00:00:00",
            "23:59:59",
            "10:00:00",
            "22:28:22",
            "00:42:51",
            "11:25:55",
            "22:29:16",
            "17:21:15",
            "09:28:13",
            "11:25:17",
            "06:17:09",
            "17:57:49",
            "13:01:15"
        ],
        "non_matches": [
            "24:0:00",
            "20:60:60",
            "15:00",
            "12",
            "12/12",
            "12-23-43",
            "60000",
            "TIME",
            "34:23",
            "80:80:80",
            "43:43:43",
            "32"
        ],
        "id": 1896,
        "output": [
            {
                "text": " '^\\d{2}:\\d{2}:\\d{2}$'\n\n3. Write a regular expression for an email address.\n\nAnswer:\n```python\nimport"
            },
            {
                "text": "\n\n```python\nimport re\n\nregex = r\"^([0-9]{2}):([0-9]{2}):([0-9]{2})"
            },
            {
                "text": " ^\\d{2}:\\d{2}:\\d{2}[^AP]$ or ^\\d{2}:\\d{2}:\\d{2}[^AP]"
            },
            {
                "text": "  \"^[0-9: ]*[0-9: ]*$\"\nExplanation: The \"^\" at the start of the regex is required. The \"*\" and"
            },
            {
                "text": ".{2}:[0-9]{2}:[0-9]{2}$\n\nExample 3:\n\nDescription: Generates a RegEx that matches the time format that 01"
            },
            {
                "text": " (\\d{1,2}):(\\d{2}):(\\d{2})\"\"\"\n\nHost 1: \"Excellent! You all are doing great so far. We have two more quizz"
            },
            {
                "text": " I have to match the railway time format that 00:00:00 to 23:59:59\n\nExercise 5: \nRewrite the following descriptions in the RegEx format.\na)"
            },
            {
                "text": " [^0-9]{1,2}:[^0-9]{1,4}:[^0-9]{0,5}\n\nExercise 2:\nMatch the"
            },
            {
                "text": " (00|[1-9][0-9]):[0-5][0-9]:[0-5][0-9]\n- \"06:00:00\"\n-"
            },
            {
                "text": " \\d:00:00-\\d:59:59\n\nExercise 2: Write a regular expression to match all URLs and their corresponding domains.\nExample: \"https://www.example."
            }
        ]
    },
    {
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\b",
        "raw_prompt": "It will matches the Standard time format that 00:00:00 to 11:59:59",
        "refined_prompt": "It will matches the Standard time format that 00:00:00 to 11:59:59\nMatch examples:\n- \"00:00:00\"\n- \"11:59:59\"\n- \"10:00:00\"\nNon-match examples:\n- \"20:00:00\"\n- \"10:60:60\"",
        "matches": [
            "00:00:00",
            "11:59:59",
            "10:00:00",
            "11:06:56",
            "08:12:39",
            "11:22:31",
            "09:37:14",
            "02:14:51",
            "01:38:12",
            "05:38:35",
            "06:26:53",
            "11:32:04",
            "04:51:15"
        ],
        "non_matches": [
            "20:00:00",
            "10:60:60",
            "15:00",
            "time",
            "23",
            "12-12-12",
            "2003",
            "1234567",
            "45:45:45",
            "12:12:1200",
            "60:60:60",
            "4"
        ],
        "id": 1897,
        "output": [
            {
                "text": "\n(0[1-9]|1[0-2]):[0-5][1-9]\n\nExercise 2:\nCreate a RegEx to match any phone number"
            },
            {
                "text": " \"\\d{2}:\\d{2}:\\d{2},\\d{2}:\\d{2}:\\d{2}\"\n- \"00:01\"\n- \""
            },
            {
                "text": "\n\\d{2}:\\d{2}:\\d{2}|\\d{2}:\\d{2}:\\d{1}\n\n5. Write a Python code to"
            },
            {
                "text": " \n(?:[0-9]|1[0-9]|2[0-3]):(?:[0-9]|[1-9][0-9])"
            },
            {
                "text": " 00:00:00 to 11:59:59.\n\n```python\n# Exercise 1\nregex_00 = re.compile(r\"\\d{2}:\\d"
            },
            {
                "text": " \"^(?:[0-2][0-9]|[3][0-1]):[0-5][0-9]$\"\n\n\n\nQuestion 2:\n"
            },
            {
                "text": " \\d{2}:\\d{2}:\\d{2}(am|pm)\n\nExercise 2: \nCreate a list of 10 different phrases. \nFor each phrase"
            },
            {
                "text": " [0-9]{2}:[0-9]{2}:[0-9]{2},[0-9]{2}:[0-9]{2},["
            },
            {
                "text": "\n([0-9]|[1-9][0-9]|1[0-2]|2[0-3]|[01]?[0-9]|"
            },
            {
                "text": " After matching any digit and colon, match any digit and colon, and any digit and colon.\n\nExercise 2:\nMatch this string with the correct regex:\n\"Date: 05/01"
            }
        ]
    },
    {
        "expression": "\\b(0[0-9]|1[0-1])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])(\\:)(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])\\s*(AM|PM|A|P)\\b",
        "raw_prompt": "It will matches the Standard time format that 00:00:00 AM to 11:59:59 PM",
        "refined_prompt": "It will matches the Standard time format that 00:00:00 AM to 11:59:59 PM\nMatch examples:\n- \"00:00:00 AM\"\n- \"11:59:59 PM\"\n- \"10:00:00 AM\"\nNon-match examples:\n- \"00:00:00\"\n- \"11:59:59\"",
        "matches": [
            "00:00:00 AM",
            "11:59:59 PM",
            "10:00:00 AM",
            "08:08:16 AM",
            "05:30:55 PM",
            "11:13:56\tAM",
            "00:07:49 PM",
            "10:04:02\u2009\u2005P",
            "04:34:42 A",
            "10:47:03\u202fAM",
            "10:00:17 PM",
            "10:47:54\u000b\u200aAM",
            "09:15:43\u205f\u2006AM"
        ],
        "non_matches": [
            "00:00:00",
            "11:59:59",
            "15:00 PM",
            "09:15:43\u205f\u2006Am",
            "10:47:54\u000b\u200apm",
            "04:34:42 a",
            "11:13:56",
            "05:30:55 pM",
            "00:00:00 pm",
            "time",
            "1234",
            "12:12"
        ],
        "id": 1898,
        "output": [
            {
                "text": " \n(?<hour>\\d{1,2})\\s(?<minute>\\d{2})\\s(?<second>\\d{"
            },
            {
                "text": "\n\"\"\"\nimport re\nimport datetime\n\n\ndef time_regex():\n    return r\"\\d{3}:\\d{2}:\\d{2"
            },
            {
                "text": " (\\d)+:(\\d+)\\.\\d+\\s*(AM|PM)\n- \"11:59:59 AM\"\n- \"11:59"
            },
            {
                "text": " \"^[1-9][0-9]|1[012]0[0-9]|[1-9]\\d|[012]\\d"
            },
            {
                "text": " [^\\d:.]*(?P<time>\\d\\d:\\d\\d:\\d\\d\\d)(?P<am>AM|PM"
            },
            {
                "text": " The regex should only contain letters, numbers, and the hyphen (-). \n\n3. Write a Python function that returns the longest word in a string that starts with a"
            },
            {
                "text": " \n[01]\\d(?:[0-9]\\d):[0-9]\\d[AP]M|2[0-9]\\."
            },
            {
                "text": " (\\d{1,2}:\\d{2}:\\d{2})|(\\d{2}:\\d{2}:\\d{2}:\\d"
            },
            {
                "text": " [00-9][0-9]:\\d{2}[-/]\\d{4}\n\n2. Write a Regex to detect the presence of"
            },
            {
                "text": " Match anything between two dots.\n- \"10:00:00\"\n\"\"\"\n\n# Solution:\n\nimport re\n\n# Example 1: Matching time format"
            }
        ]
    },
    {
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006",
        "refined_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006. Accepts years 2000-2009\nMatch examples:\n- \"JANUARY 26, 2007\"\n- \"MARCH 1, 2001\"\n- \"DECEMBER 31, 2005\"\nNon-match examples:\n- \"JAN 26, 2001\"\n- \"JULY 31 2005\"",
        "matches": [
            "JANUARY 26, 2007",
            "MARCH 1, 2001",
            "DECEMBER 31, 2005",
            "JANUARY 12, 2003",
            "JUNE 31, 2000",
            "JULY 31, 2004",
            "OCTOBER 31, 2002",
            "MAY 13, 2001",
            "FEBRUARY 24, 2006",
            "DECEMBER 10, 2006",
            "SEPTEMBER 10, 2006",
            "APRIL 17, 2009",
            "APRIL 26, 2006"
        ],
        "non_matches": [
            "JAN 26, 2001",
            "JULY 31 2005",
            "AUGUST 01, 08",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "23rd of May",
            "Jan 1st",
            "December 24th"
        ],
        "id": 1899,
        "output": [
            {
                "text": " \\b[A-Z][A-Z][0-9]{1,2}[-,.][A-Z][0"
            },
            {
                "text": " (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) [0-9"
            },
            {
                "text": " r\"^(?P<month>\\w{3,2})\\s?(?P<day>\\d{2"
            },
            {
                "text": " (1)^([0-9]{1,2}), ([0-9]{2}), and ([0-9"
            },
            {
                "text": " (JAN|FRI|MAY|JUNE|JULY|AUG|SEP|OCT|NOV|"
            },
            {
                "text": " \n\nimport re\npattern = \"^\\d\\d\\/\\d\\d\\/\\d\\d\\d\\d\\"
            },
            {
                "text": " \\d{4}[-/]\\d{2}[-/]\\d{2}[-/]\\d"
            },
            {
                "text": " \"([A-Z][a-z]\\s*){2}\\d{3},\\d{2}\"\n\nExercise"
            },
            {
                "text": " [a-z]{1,2}[0-9]{3}, [0-9]{4}\n\nEx"
            },
            {
                "text": "\n(?P<month_name>\\w+)\\s*(?P<day_num>\\d+),\\s"
            }
        ]
    },
    {
        "expression": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)",
        "refined_prompt": "VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)\r\nAccepts years 2000-2009\nMatch examples:\n- \"JANUARY 26, 07\"\n- \"MARCH 1, 01\"\n- \"DECEMBER 31, 05\"\nNon-match examples:\n- \"JAN 26, 01\"\n- \"JULY 31 05\"",
        "matches": [
            "JANUARY 26, 07",
            "MARCH 1, 01",
            "DECEMBER 31, 05",
            "JANUARY 12, 03",
            "JUNE 31, 00",
            "JULY 31, 04",
            "OCTOBER 31, 02",
            "MAY 13, 01",
            "FEBRUARY 24, 06",
            "DECEMBER 10, 06",
            "SEPTEMBER 10, 06",
            "APRIL 17, 09",
            "APRIL 26, 06"
        ],
        "non_matches": [
            "JAN 26, 01",
            "JULY 31 05",
            "AUGUST 01, 2008",
            "JAN 26, 2001",
            "JULY 31 2005",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "Jan 1st"
        ],
        "id": 1900,
        "output": [
            {
                "text": " (6 months) / (1+2+4) to find a month\n- \"JAN 1, 01\""
            },
            {
                "text": "\n(?<!^)((?<month=1>\\d{1,2})\\s+(?"
            },
            {
                "text": " \n\nA:\n\nJust a quick and dirty way to achieve this:\nvar input = \"JAN 1"
            },
            {
                "text": " (?<!\\d)(\\d{2,2}),(\\d{2},(\\d{4}"
            },
            {
                "text": "\n^[0-9]{4}[-0-9]{1,2}$|^["
            },
            {
                "text": " \\d[a-zA-z]{3}\\s+\\d{1,2},\\s+"
            },
            {
                "text": " \"JAN.MONTH.DAY, YY\"\r\n\r\n- \"MAY 29, 2006\"Gener"
            },
            {
                "text": "^(?:0?[1-9]|1[012])[-]?(?:0?[1"
            },
            {
                "text": " [0-9][A-Z][a-z]+, [0-9][A-Z][a-"
            },
            {
                "text": " \"^(?:january|february|march|april|may|june|july|"
            }
        ]
    },
    {
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006",
        "refined_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006. Accepts years 2000-2009\nMatch examples:\n- \"JAN 26, 2007\"\n- \"MAR 1, 2001\"\n- \"DEC 31, 2005\"\nNon-match examples:\n- \"JANUARY 26, 2001\"\n- \"JUL 31 2005\"",
        "matches": [
            "JAN 26, 2007",
            "MAR 1, 2001",
            "DEC 31, 2005",
            "JAN 12, 2003",
            "JUN 31, 2000",
            "JUL 31, 2004",
            "OCT 31, 2002",
            "MAY 13, 2001",
            "FEB 24, 2006",
            "DEC 10, 2006",
            "SEP 10, 2006",
            "APR 17, 2009",
            "APR 26, 2006"
        ],
        "non_matches": [
            "JANUARY 26, 2001",
            "JUL 31 2005",
            "AUGUST 01, 08",
            "JULY 31 2005",
            "AUGUST 01, 08",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "23rd of May"
        ],
        "id": 1901,
        "output": [
            {
                "text": "\nimport re\n\ndef shortMonthDayYear(dateString):\n    year = dateString[:-4]\n    month = dateString."
            },
            {
                "text": " ([0-9]{4}[-./]?[0-9]{2}[-./]?[0-9])"
            },
            {
                "text": "\nre.match(r\"^[A-Z][a-z]?[0-9][a-z]+,[0-9"
            },
            {
                "text": " (\\d\\d)\\s*((jan)\\s*?[MD]\\/\\s*(jan(uary)s?|january"
            },
            {
                "text": "\n%m/d/Y/i\n\n2.\n%m/d/y/i\n\n3.\n%Y/m"
            },
            {
                "text": " (?<month>[A-Z][a-z]{3,})[, ](?<day>\\d{2,}"
            },
            {
                "text": " \n\"\"\"\n\n#import re\nimport datetime\n\nyear = 2000;\nmonth = 13;\nday = 1;\n\n#"
            },
            {
                "text": "\nfunction isValidDate($date)\n{\n\n    if (strlen($date)!= 8) unset($date);\n\n    $month"
            },
            {
                "text": " \"MONTH DAY, CCYY-MM\" e.g. \"MONTH DAY, MMYY\"\n\n- \"JAN 26, 2007"
            },
            {
                "text": " \\d{1,2}\\/\\d{1,2}\\/[\\d ]+ \\d{4}\n\n2. Write"
            }
        ]
    },
    {
        "expression": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "raw_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e Aug 30, 06 (2006)",
        "refined_prompt": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e AUG 30, 06 (2006). Accepts years 2000-2009\nMatch examples:\n- \"JAN 26, 07\"\n- \"MAR 1, 01\"\n- \"DEC 31, 05\"\nNon-match examples:\n- \"JANUARY 26, 01\"\n- \"JUL 31 05\"",
        "matches": [
            "JAN 26, 07",
            "MAR 1, 01",
            "DEC 31, 05",
            "JAN 12, 03",
            "JUN 31, 00",
            "JUL 31, 04",
            "OCT 31, 02",
            "MAY 13, 01",
            "FEB 24, 06",
            "DEC 10, 06",
            "SEP 10, 06",
            "APR 17, 09",
            "APR 26, 06"
        ],
        "non_matches": [
            "JANUARY 26, 01",
            "JUL 31 05",
            "AUGUST 01, 08",
            "JULY 31 2005",
            "AUGUST 01, 08",
            "MARCH 10, 2010",
            "date",
            "august 23",
            "January 26, 2003",
            "Oct 25",
            "23, June, 2004",
            "23rd of May"
        ],
        "id": 1902,
        "output": [
            {
                "text": "\n[a-z]{4}[0-9]{1}[, ]{1}[0-9]"
            },
            {
                "text": "\n/(\\d{2}),(\\d{2})/g\n\nA:\n\nThe regex you are looking for is"
            },
            {
                "text": " \n_|^([0-9]{1,2})_|_|_|_|_|_|_"
            },
            {
                "text": "\n\nREGEX: (?:(?:[1-7]\\d|(?:2[0-3]))[-"
            },
            {
                "text": "\n^([0-9]{4})([0-9]{2})([0-9]{2})"
            },
            {
                "text": " \\b(january|february|march|april|may|june|july|august|se"
            },
            {
                "text": "\n^\\d{1,2}[a-zA-Z]\\s+(\\d{1,2}["
            },
            {
                "text": "\n[a-zA-Z]\\s[a-zA-Z0-9]+,\\s[a-"
            },
            {
                "text": " \\d{1,2}[-\\/]\\d{3}[-\\/]\\d{1,2}["
            },
            {
                "text": " \n[0-9]{4}(MON|TUE|WED|THU|FRI|SAT|"
            }
        ]
    },
    {
        "expression": "\\s(?=([^\"]*\"[^\"]*\"[^\"]*)*$|[^\"]*$)",
        "raw_prompt": "Splits a string by spaces, except when the space is within a quote delimited set of characters. Usefull for splitting search field inputs.\nProps to killahbeez",
        "refined_prompt": "Detects spaces. Splits a string by spaces, except when the space is within a quote-delimited set of characters.\nMatch examples:\n- \"(some number of spaces)\"\n- \"(one space)\"\n- \"(two spaces)\"\nNon-match examples:\n- \"\"no matches\"\"\n- \"\"noMatches\"\"",
        "matches": [
            "(some number of spaces)",
            "(one space)",
            "(two spaces)"
        ],
        "non_matches": [
            "\"no matches\"",
            "\"noMatches\"",
            "noMatches",
            "esdv",
            "234",
            "ds",
            "//",
            "44%",
            "$$6",
            "\"ffe",
            "+=",
            "dswef*"
        ],
        "id": 1906,
        "output": [
            {
                "text": " (^|\\s)(?!\\1)(?!\\1$)(?:\\s+|$)\n\nExercise 4:\nWrite a RegEx for matching an email address.\nAnswer: [a-"
            },
            {
                "text": " /^\\S*$/)\n\n```python\nimport re\n\ndef split_at_spaces(string):\n    return re.split(r'\\s+(?=\")', string)"
            },
            {
                "text": " ([^\\s\"]*)\"\n\nLecture Script:\nTitle: How to Use the Match Object to Extract and Parse Information in Python\n\nContents:\n- Introduction to Match Object\n- Extract"
            },
            {
                "text": " \"noMatches (\\s)?\"\n\n4. Write a Regex that matches a phone number with the format x.x.x-xxx x.x.x-xxx x.x.x-"
            },
            {
                "text": " \"\"(no matches)\"\"\n\nExercise 3: \nCreate a Python function that takes in a string and returns True if it contains a specific set of characters, and False otherwise.\nAnswer: \ndef"
            },
            {
                "text": " (?s)^[^\" ]+|\"[^\"]*\"$\n\n4. Given a text, replaces all occurrences of \"hello\" with \"hi\", except for the first occurrence.\n```"
            },
            {
                "text": "  r\"^(.*?)(.*?)$\"\n- \"no Matches\"\n- \"no Matches\" Generate a RegEx for this description. \nAnswer:  r\"^(.*"
            },
            {
                "text": " \"(.*?) no Matches\"\n\nExercise 3: Write a RegEx to match any sequence of two or more consecutive lowercase letters.\nAnswer: [a-z]{2,}\n\nEx"
            },
            {
                "text": " [^\"]*\n\n5. Given a list of email addresses, write a Python script that uses regular expressions to group all addresses into lists based on the domain name. Example: group_emails([\"example."
            },
            {
                "text": " (?<![\"])[ ]+\n\nExercise 4:\nWrite a Python function, check_password, that takes a password as a string and returns a Boolean indicating whether the password is strong. A strong"
            }
        ]
    },
    {
        "expression": "ICON=\"[^\"]+\"",
        "raw_prompt": "Remove favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).",
        "refined_prompt": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>\"\n- \"ICON=\"~8G$\"\"\n- \"ICON=\"d-9ME6lcr[[:)qQ]'~WAZ~5yGH)w.jZwmIe396Ya[)+GuQr/t{S]]-[n}?NqB.E}NL.(mt=8W>*+\"\"\nNon-match examples:\n- \"<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>\"\n- \"///\"",
        "matches": [
            "<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>",
            "ICON=\"~8G$\"",
            "ICON=\"d-9ME6lcr[[:)qQ]'~WAZ~5yGH)w.jZwmIe396Ya[)+GuQr/t{S]]-[n}?NqB.E}NL.(mt=8W>*+\"",
            "ICON=\"K%NCb/.?IC^}\\kkeAUhTgc<nn|gySah7jFToN4wM;*1(7mPh7[e|-@%S*S`sn:u$bPg$oKPym3J=]dl`mGrXp<vllQ+\"",
            "ICON=\"WAYUS&SY5WyP[3yYZlKtvj v0+51cG+>jL!?op&LMFqECMW>|SF{QdX# hK S\"",
            "ICON=\"q\"",
            "ICON=\"-l\"",
            "ICON=\"[Jq.n?8H6|VN%,)5vDI|Te+@Ymib;4NM%3jO0KZqSF$<FnS1\"",
            "ICON=\".r:im.jUE6n@&q&sDNG=$2NI|m{TGa>\"",
            "ICON=\"-M4C]<\\\"",
            "ICON=\"IJE$bAy~|b\"",
            "ICON=\"@x=3VHJvN+}kySx;2,b!|RGX+Bu,C0fBY&M|6;Q[ak+;J1^R`7Wa?%9n>:\"",
            "ICON=\"HN+!Zkh\\Ss{la';u:O21KuX6E;!v.;pfKV!UH]}svXx:{6A tV/M2(Yh1sn'|kfL+z4(Do.`VVB^58{c:kwiU\""
        ],
        "non_matches": [
            "<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>",
            "///",
            "ICON",
            "ICON=\"\"",
            "ICON=\"\"342.\"\"",
            "ICON='edfr'",
            "ICON==\"fev\"",
            "icon=\"fre\"",
            "icon=\"987656789\"",
            "ICON=\"efreg32'",
            "ICON=---efrdcs",
            "ICON=....?"
        ],
        "id": 1909,
        "output": [
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAB"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAD"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAC"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAF"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAU"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAF"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAX"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAf"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAD"
            },
            {
                "text": "Detect favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer).\nMatch examples:\n- \"<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAF"
            }
        ]
    },
    {
        "expression": "(^\\+?([1-8])?\\d(\\.\\d+)?$)|(^-90$)|(^-(([1-8])?\\d(\\.\\d+)?$))",
        "raw_prompt": "Latitude must<90 >=-90",
        "refined_prompt": "Matches numerics between -91and 90 (exclusive).\nMatch examples:\n- \"5.4\"\n- \"-0.58\"\n- \"-90\"\nNon-match examples:\n- \"-120\"\n- \"+1.4F\"",
        "matches": [
            "5.4",
            "-0.58",
            "-90",
            "+87",
            "-67.491449996440706490801988192811600862757554303908971854776873386684518",
            "-9.5185796683152094826299936893061694660355029389934",
            "+83",
            "-86.597562529211572613737307905105992947103177686406891",
            "-76.80652",
            "-47",
            "-7.2300271770582998480056257231823",
            "+75",
            "+0.3453863512674823672962343"
        ],
        "non_matches": [
            "-120",
            "+1.4F",
            "90",
            "-1111111",
            "09876",
            "00000",
            "5%",
            "#3",
            "4567",
            "12/12",
            "34-56",
            "3rffw"
        ],
        "id": 1912,
        "output": [
            {
                "text": " (.*)((?<!\\+)([+-]\\d+(\\.[0-9]*)?))\n\n2. Create a RegEx to match hexadecimal numbers (0-9,A-F).\nAnswer: ^[0-9A-Fa"
            },
            {
                "text": " This could be (?<![-+0-9.])([-+0-9.])\n\n3. Generate a RegEx for numbers between 1 and 2, inclusive, with a maximum value of 3 digits.\nAnswer: \\d+$\n\n4. Create a Reg"
            },
            {
                "text": " \"^-?\\d+\\.\\d+$\" \n\n\n2. Write a Python RegEx to find all the phone numbers in a text, then extract the first and last 3 digits of the phone number and store them in a list. \n\nAnswer:\nimport re\n"
            },
            {
                "text": "\n[^a-zA-Z0-9\\.]\n\nExercise 3:\nWrite a RegEx pattern to match URLs starting with \"http://www.example.com/\".\nAnswer:\n^http://www\\.example\\.com/\n\nExercise 4:\n"
            },
            {
                "text": " (1\\D|^)(0-9)-?\\d+(\\.\\d+)?\n\n4. Write a regular expression that matches any 4-digit hex number between 00 and FF.\nAnswer: (0\\d|^)(\\d{2})-?\\d{"
            },
            {
                "text": " -\\d+\\.\\d+\n\n4. Match any numeric character with a prefix \"3-\".\n\nAnswer: \"3-\\d\"\n\n5. Match any numeric character with a suffix \"5-\".\n\nAnswer: \"5-\\d\"\n\n\n"
            },
            {
                "text": " \"^-?\\d+\\.\\d*$\"\n\n3. Write a python script that takes in a string and returns the number of characters that are digits, characters or spaces, and their position within the string.\nSolution: \nimport re\n\ndef character_position("
            },
            {
                "text": "\n^(?=0\\.0*$)(?=0\\.0*1$)(?=0\\.0*2$)(?=0\\.0*3$)(?=0\\.0*4$)(?=0\\.0*5$)(?=0\\.0"
            },
            {
                "text": " ^[-+]?\\d\\d(?:\\.\\d+)?$\n\n2. Create a RegEx that will prevent the user from entering a value between 0 and 9.\nAnswer: ^[a-zA-Z0-9]$\n\n3. Create"
            },
            {
                "text": " \\d+\\.?\\d*(?:\\.\\d+)?\n\n3. Write a Regex that matches a date in the format MM/DD/YYYY.\n\n```python\nimport re\n\nregex = re.compile(r'^\\d"
            }
        ]
    },
    {
        "expression": "^((1[01])|(\\d)):[0-5]\\d(:[0-5]\\d)?\\s?([apAP][Mm])?$",
        "raw_prompt": "validate time\nin hh:mm:ss\nhh:mm\nhh:mm:ss pm(am,PM,AM)\n<12h",
        "refined_prompt": "Matches time in formats\r\n hh:mm:ss\r\nhh:mm\r\nhh:mm:ss pm (am,PM,AM)\r\n<12h\nMatch examples:\n- \"11:23:43PM\"\n- \"3:25:35\"\n- \"1:23 am\"\nNon-match examples:\n- \"12:01:01\"\n- \"3.14pm\"",
        "matches": [
            "11:23:43PM",
            "3:25:35",
            "1:23 am",
            "2:38",
            "9:37:48",
            "11:59:03",
            "7:30",
            "2:32:13",
            "4:13:33\u202fPm",
            "10:32",
            "1:13",
            "1:50\u202fAM",
            "10:28am"
        ],
        "non_matches": [
            "12:01:01",
            "3.14pm",
            "01:24AM",
            "time",
            "10:52pM0",
            "8:24:49-Pm",
            "11:55:22\u2004P",
            "02:05:39",
            "00:11:04\u2004pm",
            "2:15:58\u00a0A m",
            "04:18:16",
            "11:36  am"
        ],
        "id": 1913,
        "output": [
            {
                "text": " (^[0-9]{1,2}(:[0-9]{3}){0"
            },
            {
                "text": "\n(0,3)\\.?(1|2)\\.?(0|1)$\n\n"
            },
            {
                "text": " [0-9]\\d?[:,.\\d]{2}[hm]\n\nSo"
            },
            {
                "text": " [0-9]{1,2}\\.[0-9]{1,2}([a-"
            },
            {
                "text": " \"^[0-9]*:[0-9]*:[0-9]*$\"\r"
            },
            {
                "text": " (\\d{1,2}):(\\d{2})([AMP])\\s(\\d{"
            },
            {
                "text": " (at least 3 characters) ([0-9]\\d:){3}([0-9]\\"
            },
            {
                "text": " ([0-9]|1[0-2]):([0-9]|[1][0"
            },
            {
                "text": ".\\d\\d\\d\\d|\\d\\d:\\d\\d:00\n \n"
            },
            {
                "text": " \\d{1,2}:(\\d\\d):(\\d\\d):(\\d\\d)"
            }
        ]
    },
    {
        "expression": "^<\\s*(td|TD)\\s*(\\w|\\W)*\\s*>(\\w|\\W)*</(td|TD)>$",
        "raw_prompt": "match <td ***>***</td> in html,so any other html mark with<sth></sth> is just do a little change to this",
        "refined_prompt": "Match <td ***>***</td> in html\nMatch examples:\n- \"<td>hello kitty</td>\"\n- \"<TD WIDTH='20></TD>\"\n- \"<TD >&NBSP;</td>\"\nNon-match examples:\n- \"<td>< /td>\"\n- \"<TD HELLO</td>\"",
        "matches": [
            "<td>hello kitty</td>",
            "<TD WIDTH='20></TD>",
            "<TD >&NBSP;</td>",
            "<td> </td>",
            "<td>frt 543f</td>",
            "<td>flkjhgfdsdfghjkjhgfdfghjkhgfdfghjk</td>",
            "<td>987654edcvbjuytre56u</td>",
            "<td><></td>",
            "<td><lkjhgfcv0h-g%></td>",
            "<td>//////</td>",
            "<td>---------</td>",
            "<td>+</td>",
            "<td>12343@@@</td>"
        ],
        "non_matches": [
            "<td>< /td>",
            "<TD HELLO</td>",
            "<table></table>",
            "<fce>r kitty</td>",
            "<td>12343@@@</d>",
            "<p>43@@@</p>",
            "<p></p>",
            "<987></0987>",
            "<-></[>",
            "<>revcd</>",
            "<></>",
            "<3e3></>"
        ],
        "id": 1914,
        "output": [
            {
                "text": " <TD.*?>(.*)</TD> will match any text inside the td tags, but not the space'' in between the text. Also, use '\\s' instead of the '.'"
            },
            {
                "text": " \n[^\\s<TD>]+(<[^>]*>)?\n\n2. You are creating a website that allows users to upload files. Write a regular expression that matches all filen"
            },
            {
                "text": " <TD\\s*WIDTH='20\\s*'/>\\s*<TD>hello \\K\\s*kitty</TD>\n\n5. Create a RegEx to match"
            },
            {
                "text": " \n[^<TD>]+/[^<TD>]+\n\n4. How would you use the RegEx you just created to find all td tags with a width greater than 20?\n"
            },
            {
                "text": "\n\n<td *width='20'>< *title=\"hello kitty\"> &NBSP;</ *title></td>\n\n3. You have a webpage that displays images with different URLs."
            },
            {
                "text": " \n<td[^>]*>.*</td>(.*)</td>\n\nExercise Three:\nWrite a Python program that counts the number of hashtags in an HTML code.\n\n"
            },
            {
                "text": "\n$<td>.*</td>)$<td>$<td>.*</td>$<td>$<td>.*</td>$<td>$<td>.*"
            },
            {
                "text": "\n\n```python\n    <td/>\n    <TD width='20'>hello kitty</TD>\n    <TD WIDTH=\"80\">test</TD>\n    <TD"
            },
            {
                "text": "\n```python\nimport re\nhtml = \"<td>hello kitty</td>< /td>\"\nmatching = re.findall(r'\\b\\w+\\b', html"
            },
            {
                "text": "\n\\b(<td>(?=.*<\\/td>)|(?=.*<\\/td>$))\">\\d+</td>\n\n(4) Create a Python program that"
            }
        ]
    },
    {
        "expression": "^((([1]\\d{2})|(22[0-3])|([1-9]\\d)|(2[01]\\d)|[1-9]).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d))$",
        "raw_prompt": "match ip\naddress from 1.0.0.0 to 223.255.255.255",
        "refined_prompt": "Match ip addresses from 1.0.0.0 to 223.255.255.255\nMatch examples:\n- \"192.168.0.1\"\n- \"223.255.255.255\"\n- \"9.0.0.0\"\nNon-match examples:\n- \"0.10.2.52\"\n- \"255.255.255.255\"",
        "matches": [
            "192.168.0.1",
            "223.255.255.255",
            "9.0.0.0",
            "165A235h238'3",
            "221.202_3>250",
            "77K712251U200",
            "5\"139.16771",
            "221.104R251A9",
            "215{8)6E89",
            "126J250H34475",
            "104^253m103[99",
            "214h81'36)211",
            "220~8M224=1"
        ],
        "non_matches": [
            "0.10.2.52",
            "255.255.255.255",
            "127.0.257.1",
            "lkjhgf",
            "1.2.3",
            "ip address",
            "56.232.774443",
            "0340",
            "#34",
            "123.453.2324",
            "0.0.0",
            "09876543"
        ],
        "id": 1915,
        "output": [
            {
                "text": " (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3"
            },
            {
                "text": " (a-z|\\\\d)(?=\\\\.|$)\n\nExercise 3: Write a Python script to write a list of IP"
            },
            {
                "text": " (?=(?:\\.|\\d){3})[a-zA-Z0-9\\.\\d]{1,63}"
            },
            {
                "text": " (0|\\d|\\.)*(255|255\\.\\d|\\.\\d\\d|\\.)*(\\d{1"
            },
            {
                "text": " /^[0-9]+.[0-9]+.[0-9]+.[0-9]+$/\n\n5. You work in"
            },
            {
                "text": "\nip_regex1 = re.compile(r'\\d{1,3}\\.\\d{1,3}\\.\\"
            },
            {
                "text": "\n^(?!.*(\\.)(.)\\2){1,4}\n\nIn the code above, I used negative lookahead to make sure"
            },
            {
                "text": "\n/(?|^)(?:10\\.0\\.[0-9]+|255\\.255\\.255\\.|255\\.255\\.0\\.|"
            },
            {
                "text": " ^[0-9]\\.[0-9][0-9]\\.[0-9][0-9]\\.[0-9"
            },
            {
                "text": " r\"^[0-9]\\.[0-9]\\.[0-9]\\.[0-9]$\" \n\n"
            }
        ]
    },
    {
        "expression": "(((0[13578]|10|12)([/])(0[1-9]|[12][0-9]|3[01])([/])([1-2][0,9][0-9][0-9]))|((0[469]|11)([/])([0][1-9]|[12][0-9]|30)([/])([1-2][0,9][0-9][0-9]))|((02)([/])(0[1-9]|1[0-9]|2[0-8])([/])([1-2][0,9][0-9][0-9]))|((02)([/])(29)(\\.|-|\\/)([02468][048]00))|((02)([/])(29)([/])([13579][26]00))|((02)([/])(29)([/])([0-9][0-9][0][48]))|((02)([/])(29)([/])([0-9][0-9][2468][048]))|((02)([/])(29)([/])([0-9][0-9][13579][26])))",
        "raw_prompt": "This is the USA Date Format. MM/DD/YYYY with checking leaf year",
        "refined_prompt": "This is the USA Date Format. MM/DD/YYYY with checking leap year\nMatch examples:\n- \"05/15/2008\"\n- \"02/29/2008\"\n- \"02/29/3200\"\nNon-match examples:\n- \"05-12-2008\"\n- \"02/29/2007\"",
        "matches": [
            "05/15/2008",
            "02/29/2008",
            "02/29/3200",
            "10/01/1045",
            "10/31/1023",
            "05/02/1,91",
            "02/29.6800",
            "02/29/1744",
            "02/13/2009",
            "02/29/8572",
            "02/29/2508",
            "02/29/4176",
            "02/29/8256"
        ],
        "non_matches": [
            "05-12-2008",
            "02/29/2007",
            "02/28 2910",
            "02 29/5600",
            "02 29 1600",
            "11/30-2998",
            "10-02/2,72",
            "10-02-2,72",
            "02.29.9156",
            "02:29:9600",
            "11071909",
            "02/249/2764"
        ],
        "id": 1916,
        "output": [
            {
                "text": " \n\nimport re\nfrom datetime import datetime\n\ndef year_pattern(year):\n    # Create regex pattern to match year format\n    r = r\"(\\d{4}"
            },
            {
                "text": " ^\\d{2}-\\d{4}-\\d{2}$\n\n3. Write a regex to check if a string is a valid IPv4 address.\nAnswer:^"
            },
            {
                "text": " (the same as the previous example)\n\nimport re\ndef is_leap_year(year):\n   if year % 4 == 0:\n     if year % 100 == 0:\n"
            },
            {
                "text": "\n(?<![^a-zA-Z0-9-])[0-9]{2}[0-9][0-9]{4}[0-9"
            },
            {
                "text": " \n\n# 1. Write a RegEx to validate a credit card number.\n# Example credit card number: \"1234-5678-9012-3456\"\n\ncard_num"
            },
            {
                "text": " \n- \\d{3}/\\d{2}/\\d{4}|\\d{4}-\\d{2}-\\d{3}\n- \\d"
            },
            {
                "text": "  ([0-9]{1,2}\\s[0-9]{1,2}\\s[0-9]{4})$\n\nA:\n\nAssuming the format is"
            },
            {
                "text": " (a|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U"
            },
            {
                "text": " The function needs to return true if the date is a valid date and not a leap year.  \nThe function will check if a given string is in the correct format, checking that the string \ncont"
            },
            {
                "text": " (^[0-9]{1,2}[- /.][[0-9]{4}])$\n\nQ:\n\nIterating through a collection and comparing values\n\n"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]*)+[ ]([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]+)+$",
        "raw_prompt": "Requires a person's name including at least 2 parts. (first and last) Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial. Works well for filtering names on validation.",
        "refined_prompt": "Matches a person's name with at least 2 parts (first and last). Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial.\nMatch examples:\n- \"E.J. O'Malley\"\n- \"Jack O'Neil\"\n- \"Mary-Lou Elizabeth Jones\"\nNon-match examples:\n- \"Johnathan Michael S.\"\n- \"Prince\"",
        "matches": [
            "E.J. O'Malley",
            "Jack O'Neil",
            "Mary-Lou Elizabeth Jones",
            "John Smith",
            "Mr. Jones",
            "Bernardo the third",
            "Th lo",
            "Mrs. McMan",
            "wefh wejflruh",
            "fe eeg",
            "krec erfg",
            "refds ervh",
            "Thanks Be"
        ],
        "non_matches": [
            "Johnathan Michael S.",
            "Prince",
            "Teddy Has-a..Fake-Name",
            "'mc wfe",
            "384 483",
            "w",
            "342",
            "name",
            "name",
            "firstLast",
            "porefcds",
            "#comment"
        ],
        "id": 1921,
        "output": [
            {
                "text": " ("
            },
            {
                "text": " ["
            },
            {
                "text": "\n"
            },
            {
                "text": " ["
            },
            {
                "text": " ["
            },
            {
                "text": " E"
            },
            {
                "text": " "
            },
            {
                "text": " Name"
            },
            {
                "text": " ["
            },
            {
                "text": "  "
            }
        ]
    },
    {
        "expression": "((19|20)[0-9]{2})-(([1-9])|(0[1-9])|(1[0-2]))-((3[0-1])|([0-2][0-9])|([0-9]))",
        "raw_prompt": "Validate the year month and day.",
        "refined_prompt": "Matches the year month and day in format (YYYY-MM-DD).\nMatch examples:\n- \"2008-12-15\"\n- \"1960-05-16\"\n- \"2091-1-7\"\nNon-match examples:\n- \"1556/9/8\"\n- \"year\"",
        "matches": [
            "2008-12-15",
            "1960-05-16",
            "2091-1-7",
            "1965-01-30",
            "1901-6-2",
            "1961-9-25",
            "2011-10-8",
            "2042-1-5",
            "1980-02-8",
            "1933-4-3",
            "1931-11-7",
            "1974-6-0",
            "1955-09-05"
        ],
        "non_matches": [
            "1556/9/8",
            "year",
            "2074/8-30",
            "2057 10-3",
            "1935-0323",
            "2084230",
            "1905 5 27",
            "3709-09",
            "1968-30",
            "redsc",
            "12:12",
            "AM"
        ],
        "id": 1924,
        "output": [
            {
                "text": " [year]\\d{4}-\\d{2}-\\d{2}\n- \"yyyy-mm-dd\"Generate a RegEx for this description. \nAnswer: \\d"
            },
            {
                "text": " (^[0-9]{4}-)?[0-9][0-9]/[0-9]{2}-[0-9]{2}[0-9]$\n"
            },
            {
                "text": " (year) \\d{4}-\\d{2}-\\d{2}\n\n3. Use the RegEx from (2) to perform the following search and replace operations:\n- \"Today"
            },
            {
                "text": " (\\d{4})-(\\d{2})-(\\d{2})\n\n4. Write a function that takes in the email address, and returns whether or not it is valid:\n- \"in"
            },
            {
                "text": "\n\n^[123456789]{3}-?[0-9]{4}-?[0-9]{2}$\n\n\n\nCarson was excited to start his new"
            },
            {
                "text": " (\\d{4})-(\\d{2})-(\\d{2})\n\nExercise 3:\nMatch the following list of words to find the one that has the most vowels:\n- apple"
            },
            {
                "text": " Regex: year(.*?)\\/(.*?)\\/(.*?)\n\nExercise 4: Match the date with or without punctuation\nDate examples:\n- \"January 1st, 2020\"\n- \""
            },
            {
                "text": " ^\\d{4}\\-\\d{2}\\-\\d{2}$\n\n2. Create a Regex for this description:\nCreate a Regex for this description:\n- Any string in"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{2}\n\n5. Use RegEx to find all the phone numbers that start with (123)456-7890.\nAnswer: ("
            },
            {
                "text": " ^[0-9]{4}[0-9]{2}[0-9]{2}$\n\n3. Extract the price of a product from a description using RegEx.\n\n"
            }
        ]
    },
    {
        "expression": "^[:*:]",
        "raw_prompt": "This checks whether the string is equals to \"*\" i.e., contains only \"*(Asterisk)\" or begins with Asterisk.",
        "refined_prompt": "This checks whether the string is equals to \"*\" i.e., contains only \"*(Asterisk)\" or begins with Asterisk.\nMatch examples:\n- \"*\"\nNon-match examples:\n- \"a*\"\n- \"asdf\"",
        "matches": [
            "*"
        ],
        "non_matches": [
            "a*",
            "asdf",
            "kjhbgvc",
            "asteric",
            "wefcd",
            "1234",
            "$",
            "#",
            "@",
            "!",
            "-",
            "+"
        ],
        "id": 1925,
        "output": [
            {
                "text": "\n\"^[a-zA-z][a-zA-Z0-9*]*[a-zA-Z0-9]$\"\n\n\n\nQuestion 10: There are 36 students in a class. If the ratio of boys to girls"
            },
            {
                "text": " re.match(\"^[^s]*(?=.*s[^s]*$)\", \"*(Asterisk)\")\n\nExercise 2: Use the re.match() method to determine if a set of strings start with a specific character. The character"
            },
            {
                "text": " \n\n```python\nimport re\n\ndef isValid(s):\n    if (s == \"*\" or s[0] == \"*\"):\n        return True\n    else:\n        return False\n\nprint(isValid(\"*****\"))\n"
            },
            {
                "text": " *(Asterisk)\n\n```python\ndef get_reg_ex(string):\n    if string.startswith('*'):\n        return '^' + string\n    elif string.startswith('*(Asterisk)'):"
            },
            {
                "text": " r\"^[^a-z]+$\"\n\n# Exercise 5:\n\nCreate a RegEx for the following pattern:\n- Phone number format: (XXX) XXX-XXXX\n\nExample:\n- \"123-456-7890\"\n- \"123"
            },
            {
                "text": " *(Asterisk)*\n\n---\n\n##### Exercise 2\nCreate a RegEx pattern to match any string consisting of 2 numbers, followed by an operation '+' and another 2 numbers.\n\n```python\n# The pattern should be of the form: \""
            },
            {
                "text": "\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool check(string s) {\n\n  if (s.empty()) {\n    return true;\n  }\n\n  if (s[0] == '*')"
            },
            {
                "text": " \n(A*)(b*).(c*).\n\n3. Write a Python program to extract the domain name from an email address.\n\nSolution: \nimport re\n\nemail = 'test.user@domain.com'\n\n# Pattern to match"
            },
            {
                "text": " \n\nimport re\n\ndef test_string(string):\n    pattern = '.*'\n    \n    if string == pattern:\n        print('Match')\n    else:\n        print('No Match')\n\ntest_string(\"*\")\ntest_"
            },
            {
                "text": "\n^[a-zA-Z\\*+\\-_\\.\\|\\*+\\-_\\.\\|\\*+\\-_\\.\\|\\*+\\-_\\.\\|\\*+\\-_\\.\\|\\*+\\-_\\.\\|\\"
            }
        ]
    },
    {
        "expression": "^[0-9]+\\.?[0-9]?[0-9]?[0,5]?$",
        "raw_prompt": "The time should be fractional number and divisible by 0.005",
        "refined_prompt": "Number divisible by 0.005\nMatch examples:\n- \"1.005\"\n- \"60\"\n- \"0.08\"\nNon-match examples:\n- \"1.009\"\n- \"-8\"",
        "matches": [
            "1.005",
            "60",
            "0.08",
            "33",
            "234533",
            "0.10",
            "8",
            "093",
            "231",
            "12345678",
            "09876534222222",
            "1,",
            "64634"
        ],
        "non_matches": [
            "1.009",
            "-8",
            ".005",
            "-1",
            "098765456789ikmnbvc",
            "fraction",
            "#3",
            "4%",
            "12/12",
            "3.1415",
            "00000003333348.0-",
            ".0"
        ],
        "id": 1927,
        "output": [
            {
                "text": "\n(\\\\d\\\\.\\\\d*)(?=\\\\.\\\\d)\n\nExercise 5:\nUsing the same RegEx in Exercise 4, write a Python code that matches all the decimal numbers between 1 and 10 that are divisible by 0.005.\n\nHint:\n- Use a list comprehension"
            },
            {
                "text": " \"^[0-9]*\\.[0-9]+\"\n\n## Exercise 3: Data Validation\nWrite a Python program that prompts the user to enter a phone number. Use RegEx to ensure that the number contains only the digits that are allowed in a phone number, and that it starts with the correct area"
            },
            {
                "text": "\n- Matches: \"1.005\", \"80\", \"-8\"\n- Non-match: \"1.009\", \"0.08\"\n\nExercise 3: \nFind the decimal place in the following numbers:\n- 1.01\n- 0.005\n- 3.25\nAnswer:"
            },
            {
                "text": " ^\\d+\\.0+\n\n\n\nQuestion 6: A train travels a distance of 360 kilometers at a speed of 75 kilometers per hour. How long does it take to complete the journey?\n\nSolution:\nTo find the time it takes for the train to complete the journey, we need to divide the distance traveled"
            },
            {
                "text": " \"^\\d+$|[^\\.\\d-]$\"\n\nExercise 3:\nWrite a regular expression for the following description: \"A number with up to four digits and can be positive or negative.\"\nAnswer: \"(^\\d{1,4}(-\\d{1,4}"
            },
            {
                "text": " [^0-9.0-9\\.]\n\nThe fifth exercise required us to use our understanding of RegEx to extract a specific word from a long string of text. We were then tasked with adding a new prefix or suffix to the word, and using RegEx to detect the changes.\n\n```python\n"
            },
            {
                "text": " \n- Match examples: \"1.00\", \"-0.99\", \"0.08\", \"0.005\"\n- Non-match examples: \"1.009\", \"-8.00\"\n\nExercise 2: Write a Regex to Match Any Amount Up to 100\nAnswer: \n[1"
            },
            {
                "text": " (\\d)\\.(5[0-9])\\.\n- \"60.00\"Generate a RegEx for this description. \nAnswer: (\\d)\\.(5[0-9])\\.(0[0-9])\n- \"0.08\"Does not require a decimal point.\n-"
            },
            {
                "text": " Regex: \"^[0-9]\\.([0-9]\\.){3}\\.[0-9]{3}$\"\n- \".08\"Generate a RegEx for this description. \nAnswer: Regex: \"^[0-9]\\.([0-9]"
            },
            {
                "text": " \"\\d+\\.00[0-9]\\w*\"\n\n\n\nHello there! Today I want to talk to you about something very important in math: problem-solving and logical reasoning. As an aspiring HVAC technician, it's important for you to develop these skills so that you can solve problems and"
            }
        ]
    },
    {
        "expression": "^\\d+\\/?\\d*$",
        "raw_prompt": "This simple expression is used to validate fractions or UK odds.\nIt will match integers, allowing 10/1 to be entered as 10, and fractions.\nIt will not match negative numbers or fractions, spaces or any alphabetical characters.",
        "refined_prompt": "Used to validate fractions or UK odds.\r\nIt will match integers, allowing 10/1 to be entered as 10, and fractions.\r\nIt will not match negative numbers or fractions, spaces or any alphabetical characters.\nMatch examples:\n- \"10\"\n- \"2/3\"\n- \"100/30\"\nNon-match examples:\n- \"-10\"\n- \"-2/3\"",
        "matches": [
            "10",
            "2/3",
            "100/30",
            "8212974770388710493571330448503540033628930518484666081223057229",
            "8678978281274030324920378",
            "876",
            "013",
            "237878",
            "67237632",
            "9",
            "44444",
            "12/12",
            "3/8"
        ],
        "non_matches": [
            "-10",
            "-2/3",
            "text",
            "10 / 1",
            "42/7eok",
            "-9",
            "number",
            "fraction",
            "twelve/twelve",
            "3.0",
            "9993.",
            "22220.000"
        ],
        "id": 1931,
        "output": [
            {
                "text": " (.*)(-?)([0-9]*)(,|\\/)(.*)\n'''\r\n\r\n#%%"
            },
            {
                "text": "\\d\\/\\d\\d\r\n\r\n- \"10\" - Match but do not return any information\r\n- \"2"
            },
            {
                "text": " (\\d+|-)\\/(\\d+)\n- \"2/3\"Validator for UK odds.\r\nGenerate a"
            },
            {
                "text": " (.*)\\\\-?\\\\((-?\\\\d+(\\\\.\\\\d+)?)\\\\)?$\r\n- \"100/"
            },
            {
                "text": " (0[0-9]+|[1-9][0-9]*)(\\/[1-9][0-9"
            },
            {
                "text": "  \\b(-?[1-9][0-9]*|0|[1-9]\\d|1\\"
            },
            {
                "text": " (\\d+)(\\/\\d+)?\"\r\n\r\n2. Write a RegEx for the following: \"The first two"
            },
            {
                "text": " \"^[0-9]+$\" \r\n- \"10,000/100\" - Match fractions\r\n  \r\n"
            },
            {
                "text": " (\\d+)-(\\d+)/(\\d+)\n\nA:\n\nThe regex would look like this:\n^("
            },
            {
                "text": "\n([0-9]|[1-9][0-9]|[0-9]{1,2}["
            }
        ]
    },
    {
        "expression": "^(\\d{1,4}?[.]{0,1}?\\d{0,3}?)$",
        "raw_prompt": "This expression validate the add of numbers with or without decimal",
        "refined_prompt": "Matches numbers with or without decimal\nMatch examples:\n- \"123\"\n- \"123.1\"\n- \"100.\"\nNon-match examples:\n- \"12345.1234\"\n- \".012\"",
        "matches": [
            "123",
            "123.1",
            "100.",
            "0.2",
            "2341.123",
            "13060",
            "336",
            "663",
            "7432",
            "553.3",
            "067",
            "22",
            "7.54"
        ],
        "non_matches": [
            "12345.1234",
            ".012",
            ".2893",
            "3434.00000",
            ".0",
            "-342",
            "+9876",
            "2423423.",
            "23.0032",
            "#3",
            "5%",
            "12/12"
        ],
        "id": 1933,
        "output": [
            {
                "text": "\n\\b\\d{1,3}\\.(\\d{3})(?!\\.)\n\n4. Replace each string in the list with the corresponding replacement string.\nLists:\n- \"The cat sat on the mat.\"\n- \"123.45\"\n- \".01\"\nReplacement Strings"
            },
            {
                "text": ".*\\.\\d+\n- \"12345\"Generate a RegEx for this description.\nAnswer:.*\\d+\n- \".2\"Generate a RegEx for this description.\nAnswer:.*\\d?\n\n3. Write a Python regular expression for a string that starts with"
            },
            {
                "text": " \\d{1,3}\\.\\d{1,3}\n\nExercise 4:\nUsing the RegEx you created in Exercise 3, match the following numbers:\n- \"12345\"\n- \"12.34\"\n- \"12345.1234\"\n- \"12345.1\""
            },
            {
                "text": " (\\d)\\.?(?:\\d)\n\n2. Match strings that start with \"Hello(\" and end with \")\"\nMatch examples:\n- \"Hello(world)\"\n- \"(Hello world)\"\nNon-match examples:\n- \"(Hello world!\"\nAnswer: (\\(hello\\))+"
            },
            {
                "text": "\n- \"^\\d+$\"\n\nExercise 2:\nMatch the characters to form a palindrome using RegEx\nPalindrome examples:\n- \"level\"\n- \"racecar\"\nNon-match examples:\n- \"civic\"\n- \"hello\"\nAnswer:\n-"
            },
            {
                "text": " Match this example: 123\n\n2. Write a RegEx that tells whether the input string \"1234\" is a valid 4-digit number.\nAnswer: ^[0-9]{4}$\n\n3. Write a RegEx that tells whether the input string \"123.45\" is a valid 4"
            },
            {
                "text": "\nThe pattern would be /^[0-9]+(\\.[0-9]+)?$/. \n\n2. Write a RegEx for the following phrase: \"A person with brown hair and blue eyes.\"\nAnswer: \n(brown|blue) eyes\n\n\n\nTitle: Exploring the Int"
            },
            {
                "text": "\n\\b(?:\\d(\\.)?\\d+?)\\b\n\nExercise 2:\n- What is the difference between \"123\" and \"123.456\"?\nAnswer:\nThe difference is that \"123\" is a digit, while \"123.456\" is a decimal with a period.\n"
            },
            {
                "text": " Match any number with decimal.\n- Generate a RegEx for this description. \nAnswer: Match a number with or without decimal.\n- Match any number with decimal.\n- Generate a RegEx for this description. \nAnswer: Match a number with or without decimal.\n\n4. How can Reg"
            },
            {
                "text": "\n\nimport re\n\n# Generate the pattern: x\\d.\\d$\npattern = 'x\\d.\\d$'\n\n# Define a matching function\ndef match_number(pattern, string):\n    return re.match(pattern, string)\n\n# Demonstrate matching:"
            }
        ]
    },
    {
        "expression": "^([\\u20AC]?[1-9]\\d*\\.\\d{3}(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*(?:,\\d{2})?|[\\u20AC]?[1-9]\\d*)$",
        "raw_prompt": "Optional Amount, with optional thousands seperator (using the point) and optional decimal comma. If decimal comma is in string, then 2 trailing digits are required. Also checks for the optional euro sign",
        "refined_prompt": "Matches amounts of money with an optional decimal point. If the decimal comma is in string, then 2 trailing digits are required. Also, checks for the optional euro sign.\nMatch examples:\n- \"1\"\n- \"1,00\"\n- \"1.000,00\"\nNon-match examples:\n- \"1a\"\n- \".00,00\"",
        "matches": [
            "1",
            "1,00",
            "1.000,00",
            "\u20ac1",
            "339807682046239015456626518163951619966358191099829441817856",
            "\u20ac33084577111055998450840731337746980155538582722558334921161762731208435427527533259357800551181084005,39",
            "\u20ac73.344",
            "\u20ac204206394492078854068542,05",
            "9564012388762870725219575206910547",
            "\u20ac4610,45",
            "36565740277351769916606018574077579915171665781774889580",
            "\u20ac79386532622532235870547500131604581872272",
            "7014506779398"
        ],
        "non_matches": [
            "1a",
            ".00,00",
            "1,0",
            "$1",
            "12/12",
            "24.34",
            "23232332.3232",
            "-1",
            "+8765",
            "7.",
            "00000",
            "money"
        ],
        "id": 1941,
        "output": [
            {
                "text": "\n\"1\"[^a-zA-Z.,0-9-]*.[^a-zA-Z0-9.,0-9-]"
            },
            {
                "text": " \"0*|[1-9]\\d*(\\.\\d\\d?)*\"\n\nExercise #2:\nCreate a RegEx for the string"
            },
            {
                "text": "\n^[0-9]{1,2},\\s[0-9]{3,3}\\.[0-9]{2}$\n\nEx"
            },
            {
                "text": " (?<=\\d)(?=\\,\\d{3})(?<=\\.)(?<=[a-zA-Z])\\d("
            },
            {
                "text": " \n\n```python\nimport re\n\ncurrency_pattern = r\"^[$\u20ac]?\\d{1,3}(?:,\\d{"
            },
            {
                "text": " -\\d+(\\.\\d+)?\n- \"1,000,000\"\n  - Generate a RegEx for this description.\n  - Match if"
            },
            {
                "text": " [^0-9]\\.[^0-9,]\nExample:\n// $a = \"1.00,00\";\n// $b = \"1"
            },
            {
                "text": " \n\nimport re\n\nmoney_regex = re.compile(r'[0-9]+(\\.\\d{2})?(,\\d"
            },
            {
                "text": "\nMatches amounts of money with an optional decimal point. If the decimal comma is in string, then 2 trailing digits are required. Also, checks for the optional euro sign."
            },
            {
                "text": " \\w+(\\,\\w+)?\n\n3. The goal is to calculate the price in USD with decimal, and round to 2 decimal places.\n- If the"
            }
        ]
    },
    {
        "expression": "\\b[P|p]?(OST|ost)?\\.?\\s*[O|o|0]?(ffice|FFICE)?\\.?\\s*[B|b][O|o|0]?[X|x]?\\.?\\s+[#]?(\\d+)\\b",
        "raw_prompt": "Modified version of Chris Myers' regexp for po boxes. This one won't match the word \"box\" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.",
        "refined_prompt": "Matches po boxes. This one won't match the word \"box\" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations.\nMatch examples:\n- \"po box 123\"\n- \"p.o.b. #123\"\n- \"box 123\"\nNon-match examples:\n- \"123 box canyon rd\"\n- \"po box *\"",
        "matches": [
            "po box 123",
            "p.o.b. #123",
            "box 123",
            "box 34",
            "po box 34984934",
            "p.o.b. #22",
            "p.o.b. #879876543456789",
            "box 347384",
            "box 123",
            "box 098765432",
            "po box 6",
            "po box 77777",
            "po box 124532123421"
        ],
        "non_matches": [
            "123 box canyon rd",
            "po box *",
            "pob reoiewjcdsokl",
            "p.o.b. #87uyt",
            "po box ##43834",
            "boxbox 3898",
            "box po 987654",
            "389237889723",
            "number",
            "98767898 po box",
            "87565 box",
            "39823 p.o.b."
        ],
        "id": 1943,
        "output": [
            {
                "text": " (\\d+)\\s*(?=(\\*\\d+\\s*|"
            },
            {
                "text": " ( [0-9] ){1,9} *[0-9]\n"
            },
            {
                "text": " [^^#]*#[^#]*\\s+.*\n\nA"
            },
            {
                "text": " \\b[A-Z]{1}[a-z]{9,}\\"
            },
            {
                "text": " ^[^# ]*#[^# ]*[^# ]*$\n"
            },
            {
                "text": "\n^(?:[+#]\\d+\\s\\w*\\s\\"
            },
            {
                "text": " \n\nvar re = /^(.*?)\\s(.+?)\\s"
            },
            {
                "text": "\n[#]\\d+\\s(.*?)\\s[a-zA"
            },
            {
                "text": "\n[a-z]+ [a-z]* [a-z] [a"
            },
            {
                "text": " \n\\b(?:\\d[a-zA-Z]\\w*"
            }
        ]
    },
    {
        "expression": "http[s]?://[a-zA-Z0-9.-/]+",
        "raw_prompt": "Checks to make sure that entry starts with http:// or https:// and that contents are limited to alphas . - /",
        "refined_prompt": "Matches entries that start with http:// or https:// and the contents are limited to alphas\nMatch examples:\n- \"http://www.google.com\"\n- \"https://www.google.com\"\n- \"http://localhost/\"\nNon-match examples:\n- \"www.google.com\"\n- \"website\"",
        "matches": [
            "http://www.google.com",
            "https://www.google.com",
            "http://localhost/",
            "https://0evOuIJuIf4tK.r6ty5smP2AleyI5E380K34v679iU6QlA",
            "https://6BigFbaiZcfA5Bovlo5nWx8",
            "http://O1woe2u.xsroK/f2s6tD8sggK7KVv8d9I7",
            "https://chcYCj5nislUpe0GTyXn",
            "http://KjgYqEuhTQUl9qMP7fbtXST35wo.5qagHh7jtVDCfiocIOTtRyd9S9gtO6QigxHzgvq6o",
            "http://mgRx6g74eLPV6Y9DbFZUv",
            "https://X7KBR",
            "https://GwjanOZWgfuvIi0a0mb.q0",
            "http://Gv3wR.NH8lay8DBFw3MGwPKP",
            "http://J0YKuQPvwb1IPvqQfg/"
        ],
        "non_matches": [
            "www.google.com",
            "website",
            "www",
            "http",
            "http:/ewf.4444",
            "https",
            "wwwwww",
            "ftp",
            "@gmail.com",
            "dfghjk",
            "jfhsdkjjh7",
            "?:///"
        ],
        "id": 1944,
        "output": [
            {
                "text": " (?i)(?:^|[^\\w\\s])http[s]?://(?:[a-z0-9\\-\\.]+[a-z0-9\\-\\"
            },
            {
                "text": "\nimport re\n\n# Define the regex pattern\npattern = r\"(http://|https://)[\\w\\.]+\"\n\n# Example string\nstring = \"website\"\n\n"
            },
            {
                "text": " ^[a-zA-Z0-9.\\+\\-\\_/]+$\n\nExercise 3:\nFind the number of spaces between words in the following sentence: \"The quick"
            },
            {
                "text": "\n\nimport re\n\n# Match entries that start with http:// or https:// and the contents are limited to alphas\npattern = r'http[s]?://(?:[a-z"
            },
            {
                "text": " http\\S+:[\\w\\d-]+(?=\\.com)/\nExample 5: Matching a string with at least one letter, one digit, and one special character\nUse a Reg"
            },
            {
                "text": " (incomplete)\nimport re\nurl=re.compile(\"^(https?:\\/\\/)|(http?:\\/\\/)|(www\\.)[a-zA-Z0"
            },
            {
                "text": " (\\S+).*?(\\S).\nWe then go through each match and test to see if it's http or https. If it is, we limit the matches to any alpha characters. This"
            },
            {
                "text": "  ^https?://[A-Za-z0-9\\-\\.]+[A-Za-z0-9\\-\\.]+$\n\n3. Write a RegEx"
            },
            {
                "text": ".*https?://.*[\\w-]*/[\\w-]*[\\w-.+/]+.[a-zA-Z0-9]+[a-zA-"
            },
            {
                "text": " ^[a-zA-Z][-a-zA-Z0-9]*[a-zA-Z]$\n\n2. Use the `match()` method with"
            }
        ]
    },
    {
        "expression": "^[-|\\+]?[0-9]{1,3}(\\,[0-9]{3})*$|^[-|\\+]?[0-9]+$",
        "raw_prompt": "Integer with or without commas. Signed or unsigned.",
        "refined_prompt": "Integer with or without commas. Signed or unsigned.\nMatch examples:\n- \"1,234\"\n- \"1234\"\n- \"-1,234\"\nNon-match examples:\n- \"12,34\"\n- \"1.234\"",
        "matches": [
            "1,234",
            "1234",
            "-1,234",
            "-1234",
            "5,284,672,996,084,725,111,195,488,002,311,154,146,366,315,128,991,910,862,981",
            "+00993825521146278389368453995955317436058624161441235349404816150056415287648833572740653639227948366",
            "4,422,667,944,007,030,668",
            "-11910129132992855685723880445984210813189987741487",
            "69,323,930,057,037,633,620,458,298,023,423,992,658,515,620,246,895,518,759,537",
            "1742622085320083786852418024082354099699828530173564516729499509784593164924943697022",
            "4,174,465,507,445,981,780,363,603,922,684,492,009,745,206,695,595,843,515,805,056,746,828,867",
            "+2,265,515,659,172,150,913,433,061,506,903,293,337,684,439,870,025,234,247,616,568,359,077,316,580,249,680,489,996,149,120,951,884,034,361,554,980,755,574,749,349,435,533,301,233,541,711,494,888,276,348,544,174,148,558,349,540",
            "25876462041417115483574178278923645437430730250097693102058642109182878068881533322914802787"
        ],
        "non_matches": [
            "12,34",
            "1.234",
            "abc",
            "##",
            "+",
            "-",
            ".0",
            "(876)",
            "ijouhygtf",
            "32ewds",
            "g442",
            "245gerwf"
        ],
        "id": 1950,
        "output": [
            {
                "text": " \\d+(?!\\.)\\d+\n- \"123.56\"Generate a RegEx for this description. \nAnswer: \\d[\\d\\.]*\\d\n- \"12.34.56\"Generate a RegEx for this description. \nAnswer"
            },
            {
                "text": " \"\\d{1,3}(,\\d{3})*\"\n\nI am stuck on this problem. I would appreciate some help.\n\nA:\n\nThis should do the trick:\n(?<![0-9])[0-9]{1"
            },
            {
                "text": " 1[.-][0-9]+|[0-9][.-]1[.-]0+|[0-9][.-][0-9]\n\nIn conclusion, the use of decimal arithmetic with Python\u2019s RegEx can provide various advantages in various applications. Learning"
            },
            {
                "text": "\n(^[0-9]+\\,?[0-9]{0,2}$)(?:\\.\\d+)?\n\nI'm doing this for a program that will validate phone numbers.  It's not working as I need it to.\n\nA:"
            },
            {
                "text": " ([\\d,]+(.|$))+\n\n2. Write a Python program that takes a list of numbers as input and returns a list of the numbers that are divisible by 3 and 5.\n\ndef divisible_by_3_5(nums):\n    "
            },
            {
                "text": " ([+-]?\\d{1,3})[.,]?\\d{3}(?:[eE][+-]?\\d+)\n\nHow to use this with splitlines()\nThe best way to solve this is to use a list comprehension and a regular"
            },
            {
                "text": " (\\d)+(\\,\\d+)?\n\n3. Write a regular expression that will match a phone number in the format (123)456-7890.\nAnswer: (\\(\\d{3}\\)\\s\\d{3}-\\d{4})\n"
            },
            {
                "text": " \\d{1,3}(?:,\\d{3})?)?\\d+(?:\\.\\d+)?\n\nMy answer:\n\\d{1,3}(?:\\,\\d{3})?\\d+(?:\\.\\d+)\n"
            },
            {
                "text": " (\\d[\\,])?\\d{0,5}\n\nA:\n\nHere is a non-regex solution:\nimport itertools as it\n\nnum_comb = list(it.combinations(\"1234567890\", 3))\nprint("
            },
            {
                "text": " \n\n```Python\nimport re\n\ns = \"1,234\"\nprint(re.match(r\"(\\d{1,3}),(\\d{3})\", s).group(1) == s[:2])\n\n\ns = \"12,"
            }
        ]
    },
    {
        "expression": "^([0-9]{1}[\\d]{0,2}(\\,[\\d]{3})*(\\,[\\d]{0,2})?|[0-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "raw_prompt": "Match any number , no characters, no empty sets, and accept zero.",
        "refined_prompt": "Match any number, no characters, no empty sets, and accept zero.\nMatch examples:\n- \"0001\"\n- \"12345\"\n- \"40788018763604681545698910422212,34\"\nNon-match examples:\n- \"abcd\"\n- \"012a\"",
        "matches": [
            "0001",
            "12345",
            "40788018763604681545698910422212,34",
            "42689385200849809755330582721781144829205057324808464028908786274273318912310097677616558,70",
            ",3",
            "1,216,432,875,905,931,623,929,895,798,254,709,838,662,247,206,516,505,574,696,717,557,656,303,882,805,757,224,244,831,166,562,850,598,763,101,655,292,582,154,709,355,719,515,070,34",
            ",38",
            "8,968,414,863,829,387,382,471,702,187,988,301,942,492,870,806,960,954,112,512,899,630,005,476,770,846,414,117,887,634,485,631,248,825,984,670,921,905,328,917,486,402,989,044,306,810,678,714,146,813,356,358,080,950,687,035,149,000,184,091,427,151,200,710,201,944,148,886,",
            "0,6",
            "34492196568546429699783700098399274057759926155063955616357586",
            ",47",
            "0,",
            "36,277,102,064,107,505,723,144,954,604,279,170,828,096,209,664,401,591,137,835,190,315,452,381,609,617,779,785,702,386,673,771,786,709,251,912,374,594,651,308,664,996,087,755,570,640,212,276,396,937,625,392,675,084,357,751,690,225,425,536,246,577,154,613,001,100,112,845,821,856,858,884,179,813,521,083,945,617,085,305,645,131,464,354,120,481,206,862,083,526,453"
        ],
        "non_matches": [
            "abcd",
            "012a",
            "2345tgr",
            "qwefd,",
            ",",
            ".0",
            "frer4",
            "24q5reg",
            "gre455",
            "4254ger",
            "544qsrg",
            "ewrg4"
        ],
        "id": 1952,
        "output": [
            {
                "text": " [a-zA-Z0-9]{8,12}\n\n#Exercise 3\nI want to create a program that checks if a string is a palindrome or not. (A palindrome is"
            },
            {
                "text": " \n(?=[\\d,]*$)(?=([\\d,]*){6,})[\\d,]{6}\n\"\"\"\n\nimport re\n\n# Define a sample string\nexample"
            },
            {
                "text": " [0-9a-f]{7}\n- \"12a\"Generate a RegEx for this description. \nAnswer: [0-9a-f]+$\n- \"ab12\"Generate a"
            },
            {
                "text": " \n  - (^[0-9]{4}-[0-9]{2}-[0-9]{2},[0-9]{3}:[0-9]{3}:[0"
            },
            {
                "text": " \"^[0-9a-zA-Z]{6}$\"\n\n#### Exercise 5:\n\nWrite a Python script that takes a string as input, and returns a list of all numbers and non-n"
            },
            {
                "text": " \"^a.b.c.d$\"\n- \"1\"Generate a RegEx for this description.\nAnswer: \"^0+$\"\n- \"aa1\"Generate a RegEx for this description"
            },
            {
                "text": "\n^(?=.*[0-9])(?=.*[a-z])(?=.*[@#$%^&*])[a-z0-9@#$%^&*]+$\n"
            },
            {
                "text": "\n.*[a-z]\n\nExercise 4:\nMatch any number, zero characters, no empty sets, and accept zero or more white spaces.\nMatch examples:\n- \"20\"\n- \"  \"\n"
            },
            {
                "text": "\na) ^[(][0-9]{1}[)]$\nb) ^[0-9]{6}$\nc) ^[0-9]{5}[1-9]$"
            },
            {
                "text": " [0-9a-zA-Z]{0,4}[0-9a-zA-Z,0-9a-zA-Z]+.\n- \"0123456789\"Gener"
            }
        ]
    },
    {
        "expression": "^(0\\.|([1-9]([0-9]+)?)\\.){3}(0|([1-9]([0-9]+)?)){1}$",
        "raw_prompt": "A simple regex to check a version information string of the style 1.0.0.0",
        "refined_prompt": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"",
        "matches": [
            "1.2.3.4",
            "0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355",
            "7.0.0.0",
            "995924130561360496409174388082680333348602416467836347516621830555269281187.2.9877577759646252897.495760733932004220082873",
            "9.179844495258302487837838329116084107717508700209186543832911986755634680834.1.75430881527114332685881980603299534395097469403509625456909876331457104",
            "7.6.6.4",
            "0.5.9.0",
            "0.4.0.0",
            "0.0.0.0",
            "0.5.0.0",
            "9.0.29760475541206794.143293204651548567230402531615022910662571834234626316192222832522929977270673151170272416352631",
            "2.7.7552197900952889753215401484317738423240913655378.1",
            "1.288825352608777973492105303713854541535998647957282682556885422638815395962209382975693286590299361.8.12662037900806967035976172763024819"
        ],
        "non_matches": [
            "1.2.3",
            "01.02.03.04",
            "1.2.3.4Beta",
            "IP",
            "767%",
            "$45678",
            "#3",
            "#..3",
            "4321fre",
            "3221",
            "+0987",
            "-9876"
        ],
        "id": 1954,
        "output": [
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n-"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n-"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n-"
            },
            {
                "text": "A simple regex to check a version information string of the style 1.0.0.0\nMatch examples:\n- \"1.2.3.4\"\n- \"0.0.2.48504995526161112907723074823733001360950519953024188524490023263126367337734975355\"\n- \"7.0.0.0\"\nNon-match examples:\n- \"1.2.3\"\n- \"01.02.03.04\"Generate a RegEx for this description. \n\n"
            }
        ]
    },
    {
        "expression": "^((\\$?\\-?)|(\\-?\\$?))([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)?(\\.[0-9]*)?$",
        "raw_prompt": "Matches any number which includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal. It matches an unlimited number of decimal places. It does NOT reject an empty string passed to it. Credit goes to Al Kahler for posting the original expression from http://regxlib.com/REDetails.aspx?regexp_id=70 along with a fix for the decimal place.",
        "refined_prompt": "Matches any number that includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal. It matches an unlimited number of decimal places. It does NOT reject an empty string passed to it.\nMatch examples:\n- \"$.01\"\n- \"1,234.003\"\n- \"834223.1\"\nNon-match examples:\n- \".0,001\"\n- \"1,1.01\"",
        "matches": [
            "$.01",
            "1,234.003",
            "834223.1",
            "$0.01",
            "-$1.50",
            "$-50.123",
            "-$",
            "-0273029570338466083286457372911786177840950583862934245824010450870644223390123245579908924648197",
            "-$.3067063708136872591910189758727404130332985037814788725757472547497565776311194954917340568420",
            ".1058811057045379312110561820513963569300635",
            "-.76759900764831304306812620915030773068324572487491765701323774747463097534525803524921112887",
            "7,302,955,223,790,475,685,735,996,849,256,475,841,878,936,591,138,852,716,067,736,231,199,391,752,461,993,664,629,935,490,839,000,641,648,155,013,574,550,888,320,458,192,885,360,257,622,616,628,945,010,272,325,547,371,650,069,938,891,936,203,116,185,631,223,055,525,021,701,419,062,059,151,318,094,805,431,020,717,491,304,805,540,282,245,993,584,217,288,856,078,181,417,965,378,343,516,916.01349963332043700515008401",
            "-0,038,711,341,463,101,097,008,278,992,529,305,562,998,437,304,958,389,551,410,980,657,269,263,800,628,696,566,548,260,964,048,379,166,131,933,314,473,728,274,583,088,051,732,472,045,723,266,738,984,860,670,684,565,180,280,873,448,172,351,151,844,828,834,282,654,205,203,751,810,911,691,359,335,804,210,954,779,497,063,483,384,039,668,030,490,550,116,800,932,556,122,309,515.10592"
        ],
        "non_matches": [
            ".0,001",
            "1,1.01",
            "1E",
            "5$",
            "+98765",
            "&^%",
            "uytfy7",
            "money",
            "(*&",
            "ten",
            "$$$$",
            "&^%^&*("
        ],
        "id": 1956,
        "output": [
            {
                "text": " \\d{1,3}\\.\\d{3}$ \n\nExercise 5"
            },
            {
                "text": " ^^(?!(?<!\\d)\\d{0,3}(?:,"
            },
            {
                "text": "\n^(?!(\\d,?){3}$)(?!^\\..*$)("
            },
            {
                "text": ".01+\n\n3. Write a RegEx to match a date like \"2021-"
            },
            {
                "text": " [A-Z0-9]*[$]?[0-9]*["
            },
            {
                "text": " \n.*[0-9]{1,3}.{1,2}[0"
            },
            {
                "text": " \n([0-9]+(\\\\.[0-9]*)?)\n\nExercise"
            },
            {
                "text": " [0-9]+.[0-9]+\n\n4. Write a RegEx to match"
            },
            {
                "text": " [0-9]+(.[0-9]+)\n\n2. Write a RegEx"
            },
            {
                "text": " \n^(?=.*[0-9])(?=.*[.])(?"
            }
        ]
    },
    {
        "expression": "^[A-Z]\\d{2}(\\.\\d){0,1}$",
        "raw_prompt": "This expression matches ICD-10 code",
        "refined_prompt": "Matches International Classification of Diseases (ICD-10) codes\nMatch examples:\n- \"Z99.9\"\n- \"Z99\"\n- \"G82\"\nNon-match examples:\n- \"Z999\"\n- \"Z99.\"",
        "matches": [
            "Z99.9",
            "Z99",
            "G82",
            "D05",
            "J05",
            "Y16",
            "M08.0",
            "V52.4",
            "H67.3",
            "F44",
            "I01.4",
            "I29",
            "Z97.0"
        ],
        "non_matches": [
            "Z999",
            "Z99.",
            "99",
            "wffe",
            "0.0",
            "-12",
            "098765",
            "z37f",
            "0987eh",
            "hefj",
            "8328823",
            "82"
        ],
        "id": 1958,
        "output": [
            {
                "text": " \n- \"Z999\"\n- \"Z99.\"Generate a RegEx for this description. \n\nConclusion:\nIn this user manual, we have discussed the basics of Python's RegEx module and provided examples to help you understand how to use it effectively. Remember, Reg"
            },
            {
                "text": " \"Z99\\.[0-9]{4}\"\n\nExercise 2:\nCreate a RegEx pattern to match social security numbers.\nAnswer: \"^\\d{3}-\\d{2}-\\d{4}$\"\n\nExercise 3:"
            },
            {
                "text": " \"\\d{3}\\.\\d{3}\\.\\d{4}\"\n\nExercise 4:\nMatch patterns for the following words:\n1. \"run\"\n2. \"jump\"\n3. \"fly\"\n4. \"walk\"\n\nAnswer:\n"
            },
            {
                "text": " The pattern should match \"Z99\\.9\" or \"Z999.\"\n\nExercise 4:\nYou're given a list of addresses. Write a code to identify house numbers with street names that start with an \"A.\"\nExample: \n\n[\n  {\"address\": \""
            },
            {
                "text": " Use a character class to match all ICD-10 codes that start with a letter between G and S.\n\nExercise 3:\nCreate a RegEx for email addresses\nAnswer: Use the following pattern to match email addresses: [a-zA-Z0-9._%"
            },
            {
                "text": " [Matching pattern]\n\n\n\nReasoning Exercise:\n\nTopic: Mathematics - Addition - Addition and problem-solving\n\nIntroduction:\nIn the world of mathematics, addition plays a crucial role in problem-solving. Addition allows us to combine numbers and find"
            },
            {
                "text": " \n\n```python\nimport re\n\n# Generate a RegEx for this example\nICD_10_list = [\"Z99.9\", \"Z99\", \"G82\"]\npattern = \"\\d{3}[.][\\d]{2}["
            },
            {
                "text": "\n- \"Z99.9\" --> Matches the decimal number \"99\".\n- \"Z99\" --> Matches the decimal number \"99\".\n- \"G82\" --> Matches the letter \"G\".\n- \"Z999\" --> Does not match the decimal number \"."
            },
            {
                "text": " \"Z99.9|Z99\"\n\n\n\nQuestion 4: Mia's monthly take-home salary is $5500. She pays $800 in property taxes, $1000 in sales taxes, and 15% of her gross salary in income taxes. What is Mia's gross salary?"
            },
            {
                "text": " \n- \"Z99.9\"\n- \"Z99\"\n- \"G82\"\n- \"Z999\"\n\n\n\nTitle: Exploring Mathematical Equations: A Journey into the World of Numbers\n\nIntroduction:\nMathematics is a fascinating subject that"
            }
        ]
    },
    {
        "expression": "(((0*[1-9]|[12][0-9]|3[01])([-./])(0*[13578]|10|12)([-./])(\\d{4}))|((0*[1-9]|[12][0-9]|30)([-./])(0*[469]|11)([-./])(\\d{4}))|((0*[1-9]|1[0-9]|2[0-8])([-./])(02|2)([-./])(\\d{4}))|((29)(\\.|-|\\/)(02|2)([-./])([02468][048]00))|((29)([-./])(02|2)([-./])([13579][26]00))|((29)([-./])(02|2)([-./])([0-9][0-9][0][48]))|((29)([-./])(02|2)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02|2)([-./])([0-9][0-9][13579][26])))",
        "raw_prompt": "Date in DD/MM/YYYY or D/M/YYYY format.",
        "refined_prompt": "Date in DD/MM/YYYY or D/M/YYYY format.\nMatch examples:\n- \"01/06/2008\"\n- \"1/1/2008\"\n- \"29.2/9200\"\nNon-match examples:\n- \"32/13/2008\"\n- \"00/00/2005\"",
        "matches": [
            "01/06/2008",
            "1/1/2008",
            "29.2/9200",
            "29/02.9960",
            "29/02.5224",
            "29.2/6572",
            "29-02.3600",
            "29-2/1200",
            "26-11/8662",
            "29-2-4808",
            "10-02/9483",
            "29/02.5004",
            "29-2-2808"
        ],
        "non_matches": [
            "32/13/2008",
            "00/00/2005",
            "date",
            "4567890",
            "29/028800",
            "2902.6004",
            "29027596",
            "229.032-34043",
            "#4",
            "5%",
            "2/2/2",
            "12/12"
        ],
        "id": 1960,
        "output": [
            {
                "text": " [0-9]{2}/[0-9]{2}/[0-9]{4} or [0-9]{1,2}/[0-9"
            },
            {
                "text": "\n\n```python\ntext = \"01/06/2008\"\npattern = r'\\d{1,2}/\\d{1,2}/\\d{4}'"
            },
            {
                "text": " [\\d]{1,2}\\d{1,2}\\d{1,4}\n\nExercise 2: \nGiven the following text, remove any non-alphanumeric characters"
            },
            {
                "text": "\nPattern: ddd/mm/yyyy|d/mm/yyyy|dd/mm/yyyy\n\n#Exercise 4:\nWrite a Python program that takes in a string and"
            },
            {
                "text": " \n\nimport re\n\n# Create a regular expression that matches any date in DD/MM/YYYY or D/M/YYYY format.\nregex_date = re.compile"
            },
            {
                "text": " \\d{2}(?:/\\d{2})?|\\d{4}(?:/\\d{4})\n\n2. Create a Python program that takes in a string and"
            },
            {
                "text": "\nYou can use the following RegEx pattern:\n\n^(?:\\d+\\/\\d{1,2}|\\d{2}\\/\\d{4}|\\d{"
            },
            {
                "text": " \n([A-Z][a-z]|[0-9]|[.])+\\/([0-9]+)\\/([0-9]+)\n\nExercise 2:\n"
            },
            {
                "text": " \\d{2}\\.\\d+\\/\\d{4}\n\n2. Write a RegEx to match dates in the format MM/DD/YYYY or DD/MM/YYYY"
            },
            {
                "text": "\n^(2[0-4])\\/(0[1-9])\\/(0[1-9])$|^(2[0-4])\\/(0[1-9"
            }
        ]
    },
    {
        "expression": "(?!\\b(xx|yy)\\b)\\b[\\w]+\\b",
        "raw_prompt": "Matches any word except these from alternation (xx|yy|...). Works in JavaScript",
        "refined_prompt": "Matches any word except with xx and yy\nMatch examples:\n- \"x\"\n- \"xxx\"\n- \"xxyy\"\nNon-match examples:\n- \"xx\"\n- \"yy\"",
        "matches": [
            "x",
            "xxx",
            "xxyy",
            "yyx",
            "cV7CqH8YbQzVmGtOUMAUCcvoo4L2a9LDa2s7gDpYe7R0",
            "m2u_PUgF0q6e",
            "82PMz44ru39p9cnb9SnQw5HG5bZ35Gt2ri9TpPi3HDC8ZNmkWthvDWK0HI4_ov2FEHzQPu41vU7lnFAEpYE1O3",
            "BkAO9UbVNf4z9PpAW3WrqWSlBOVXzgBgurHEtmbl79",
            "qn6RhW1N7ZzYmct1miCsSNY_XOnIZPK3dIdqzU",
            "sciLUelHqtk1Fe7k4SYjEZu0iSBsaIMrri_IPrb0m6YwHNzCpnpte7zud2_6D",
            "pbGk6Rgwlj0ZzPcoGaGcvCjZvs5tcJ3kHDfk3FSB9",
            "l1hi5XLa",
            "atRsmHuwtEJ1gFVePGg38O_"
        ],
        "non_matches": [
            "xx",
            "yy",
            "--",
            "#",
            "@",
            "!",
            "()",
            "&&&",
            "???",
            "[]",
            "./",
            "''"
        ],
        "id": 1962,
        "output": [
            {
                "text": " (\\b[a-z]{2}\\b)\n\nExercise 2:\nUse the following variables to create a RegEx pattern to match any string that has \"hello\" followed by any number of characters (including none) and ending with \"world\".\n\nvar str1 = \"hello world\";\nvar str2"
            },
            {
                "text": " (.*)\\\\1.*\n# Using the first section, define the non-matching character.\n>>> 'xx'\n# Solution to the second problem. \n>>> m = re.search(r'(.*)\\\\1.*', 'xx')\n>>> m.group(0)\n\"xx\"\n\n"
            },
            {
                "text": " x, yy\n\nThe answer is (x|y),\nThis means match any single character x or y. \nIn the first example, \u2018-\u2019 is the wild card and it means match any character. \u2018-\u2019 in the second example means match any character except the specified characters.\n\nRe"
            },
            {
                "text": " (\\w)\\1+\nExplanation:\n\\w matches any word character except for A-Z, a-z, 0-9, _ and |.\n\\1+ means that this match must occur at least once.\nDemo\n\nA:\n\nI agree with @Jonas, and @K"
            },
            {
                "text": " (^| )((?!x)([ab])(?:a|b))$\n\n4) Create a regular expression to match any word that is three or more characters long\nAnswer: ^[a-z]{3,}$\n\n5) Create a regular expression to match any word that ends with the letters '"
            },
            {
                "text": ".{4,9}\n\nExercise 3: \n- Create a python program to search for any numbers in a string.\n- Use the re module to identify the numbers.\n- Generate a RegEx for this description.\nAnswer: \\d{1,3}\n\nExercise 4: \n-"
            },
            {
                "text": " /x[xy]/g\n\nA:\n\nIt could work this way: (^[xy]|[xy][xy])\n(^[xy]|[xy][xy]) says:\n\nmatch ^[xy]\nmatch (optional) [xy] and match [xy]\nmatch a character inside"
            },
            {
                "text": " r'\\b([A-Za-z]+)([0-9]{1,1})\\b'\n\nExercise 2: \nGiven a list of words `word_list = [\"word1\", \"word2\", \"word3\", \"word4\"]`, write a Python program that returns all words"
            },
            {
                "text": " ^(?=.{8,15})[a-zA-Z]+(?:[a-zA-Z]+)$\n2. Create a Pattern that will match a word that starts with a double quote (\") and ends with a double quote (\")\nAnswer: ^\"([^\"]+)\"$\n"
            },
            {
                "text": "\n[^eoiy]\n\n3. Write a list of words using a list comprehension that contains all the letters except those found in the first two letters of the alphabet.\n\nCode:\n# Import required modules\nimport re\n\n# Define the text to search in\ntext = \"This is a sample text.\""
            }
        ]
    },
    {
        "expression": "^100$|^100.00$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "raw_prompt": "Allows percent values from 0 to 100 without the % sign. Can be used with up to 2 decimal places or without any. Also works in ASP.NET regular expression validator control.",
        "refined_prompt": "Allows percent values from 0 to 100 without the % sign. Can be used with up to 2 decimal places or without any.\nMatch examples:\n- \"0\"\n- \"0.00\"\n- \"50.25\"\nNon-match examples:\n- \"100.01\"\n- \"-1\"",
        "matches": [
            "0",
            "0.00",
            "50.25",
            "100",
            "100.00",
            "100700",
            "14",
            "5.43",
            "55",
            "98",
            "33.3",
            "78",
            "12"
        ],
        "non_matches": [
            "100.01",
            "-1",
            "5.005",
            "%12",
            "#3",
            "12/12",
            "(32)",
            "number",
            "823",
            "0000",
            "5535",
            "0005"
        ],
        "id": 1964,
        "output": [
            {
                "text": " [0-9]+\\.[0-9]{1,2}|[1-9][0-9]{3,4}\n\nExercise 3:\nCreate a RegEx to match strings that have six or"
            },
            {
                "text": " [^0-9a-zA-Z-]\nExercise 2: Write a RegEx to find all phone numbers in the text below.\n- \"My phone number is 952-555-1234.\"\n-"
            },
            {
                "text": " 0\\.0{1,4}\n- \"0 0.0\"Generate a RegEx for this description. \nAnswer: (0\\.0)0{1,4}\n\nExercise 2:\nCreate a"
            },
            {
                "text": ".*\"0\"|.\n\n# Exercise 3:\nRegex Pattern\nCreate and run a RegEx pattern that matches all the email addresses in a string. Use the re.findall() method and a list comprehension to print"
            },
            {
                "text": " (0|[1-9]\\d*|100)\n\nExercise 4: Write a RegEx to validate a string containing a date (MM/DD/YYYY).\nAnswer: (0?[1-9"
            },
            {
                "text": " [^0]{1}%\n\n2. Write a RegEx to match any string that contains both uppercase letters and hyphens.\nAnswer: [A-Z][-_]{0,1}[A"
            },
            {
                "text": " ^[0-9]*[0-9]?[0-9]?\"\n- Use the following regular expression in Python to match any string that starts with a digit between 0 and 255 (both inclusive): \"^[0"
            },
            {
                "text": " (0|.0?)?([0-9])([0-9]?)?([0-9]?)?\n\n**Section 2: The `re.match()` function**\n\nThe `re.match"
            },
            {
                "text": " [^\\d.]\n\nExercise 2: \nCreate a RegEx to match any string that contains the word 'python' or 'cod'. Allow the word to match any number of times and be case insensitive. Use the Quant"
            },
            {
                "text": " ^[0-9]*.[0-9]?[0-9]$\n\nExercise 4:\nUsing the string \"The quick brown fox jumped over the lazy dog\" as the string of text, generate a regular"
            }
        ]
    },
    {
        "expression": "^[1-9]{1}$|^[1-9]{1}[0-9]{1}$|^[1-3]{1}[0-6]{1}[0-5]{1}$|^365$",
        "raw_prompt": "This expression allows you to select 1-365 as a numeric value for the days of the year. Must be between 1 and 365 and must be numeric",
        "refined_prompt": "This expression allows you to select 1-365 as a numeric value for the days of the year. Must be between 1 and 365 and must be numeric\nMatch examples:\n- \"25\"\n- \"363\"\n- \"110\"\nNon-match examples:\n- \"2.5\"\n- \"0\"",
        "matches": [
            "25",
            "363",
            "110",
            "1",
            "2",
            "3",
            "12",
            "17",
            "34",
            "90",
            "45",
            "86",
            "200"
        ],
        "non_matches": [
            "2.5",
            "0",
            "400",
            "-1",
            "2345678",
            "5432",
            "4000",
            "503",
            "4378",
            "#",
            "4321",
            "3456"
        ],
        "id": 1972,
        "output": [
            {
                "text": " \nThe RegEx for this description is '^1[0-9]{1,3}(0[1-9]|1[012])$'.\n\n3. Write a RegEx for this expression."
            },
            {
                "text": "\n^(1[^0-9]|2[0-3]|3[0-1])[0-9]{3}$\n\nExercise 2:\nCreate a RegEx for this string:"
            },
            {
                "text": " (\\d+\\.\\d+)\n\nCongratulations on completing the exercises! By mastering the art of creating and using RegEx patterns, you will become a skilled data analyst by implementing this powerful tool in your Python programming. Happy coding!"
            },
            {
                "text": " (1-365) and (1-2)(0-9)(0-9)\n\n2. Write a Python script that matches any value between 0 and 100 and any value in between 0 and 12 (inclusive) in"
            },
            {
                "text": "\n\n^(0|[1-9][0-9]*)\\.[0-9]+$\n\nExercise 4:\n\nWrite a regular expression that matches all email addresses. The email address must be in the"
            },
            {
                "text": " (.*)\n\n**Exercise 2:** Write a regular expression to match a string that starts with the word \"hello\" and ends with the word \"world\".\nAnswer: ^hello.*world$\n\n**Exercise"
            },
            {
                "text": " \n\\d{4}(?:\\.\\d{1,3})?\n\n1. \"a\"\n2. \"a\"\n3. \"a\"\n4. \"b\"\n5. \""
            },
            {
                "text": " ^\\d*$\n\nExercise 3: \n\nWrite a RegEx that matches the pattern \"^[a-zA-Z]{3} [a-zA-Z0-9]{3"
            },
            {
                "text": " [0-9][0-9]*[.][0-9]+\n\nUsing the regex as a replacement string\nWhen generating your template, you'll need to make a regex replacement for the day of the week. This"
            },
            {
                "text": " (^[1-9]\\d?|1[0-2]\\d|3[01])$\n\n6.2.3.1 Date Formatting\n\nIn addition to expressing dates directly, regular expressions"
            }
        ]
    },
    {
        "expression": "^(\\d{3}-\\d{2}-\\d{4})|(\\d{3}\\d{2}\\d{4})$",
        "raw_prompt": "This will accept SSN in the form of 123-45-6789 OR 123456789.",
        "refined_prompt": "This will accept SSN in the form of 123-45-6789 OR 123456789.\nMatch examples:\n- \"123-45-6789\"\n- \"123456789\"\n- \"456-63-6666\"\nNon-match examples:\n- \"123-45-459a\"\n- \"222-2-2222\"",
        "matches": [
            "123-45-6789",
            "123456789",
            "456-63-6666",
            "923083942",
            "085-11-9100",
            "816-97-6034",
            "387611789",
            "551-19-2895",
            "533-79-9002",
            "360423595",
            "501-58-9755",
            "331241871",
            "766-53-6084"
        ],
        "non_matches": [
            "123-45-459a",
            "222-2-2222",
            "222-222222",
            "34564321",
            "SSN",
            "#3",
            "33223",
            "123456780-90312",
            "22-214",
            "33232",
            "######",
            "number"
        ],
        "id": 1974,
        "output": [
            {
                "text": "\n(?<![0-9])(?<![0-9][0-9])[0-9].{6}(?![0-9"
            },
            {
                "text": " ^[a-zA-Z0-9\\s]{1,30}\\-[a-zA-Z0-9\\s]{3,6}\\"
            },
            {
                "text": " ^[0-9]{7}[-.]?[0-9]{3}[-.]?[0-9]{4}$\n\n3"
            },
            {
                "text": " [0-9]{3}[0-9]{3}[0-9]{4}[0-9]{4}\\s[0-9"
            },
            {
                "text": " \n(123[\\-\\d]45[\\-\\d]6789|[\\-\\d]{9}[\\-\\d])|([\\-\\d]"
            },
            {
                "text": " \n[a-zA-Z]{3}\\-\\d{3}\\-\\d{4} OR \\d{3}\\-\\d{4}"
            },
            {
                "text": " \\d{3}[-\\s]?\\d{3}[-\\s]?\\d{4}\n\nExercise 2: Write a RegEx"
            },
            {
                "text": "\n\\b(?=\\d{3}\\-?\\d{2}\\-?\\d{4}\\b)\\d{3}-\\d{2}"
            },
            {
                "text": " [A-Z]{1,2}\\d{3}\\-\\d{3}\\-\\d{4}\n\n4. Write a RegEx to match US"
            },
            {
                "text": " [^\\d\\-\\d-]\n\n(2) \na) Your task: Find all the email addresses within a text string.\nb) Your task\n"
            }
        ]
    },
    {
        "expression": "^(\\d?)*(\\.\\d{1}|\\.\\d{2})?$",
        "raw_prompt": "Expression to validate currency formatted numbers without the currency symbol",
        "refined_prompt": "Expression to validate currency formatted numbers without the currency symbol\nMatch examples:\n- \"153\"\n- \"33.48\"\n- \"786.1\"\nNon-match examples:\n- \"-123\"\n- \"8524.258\"",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33",
            "06",
            "7975651.66",
            "73942979684534684690883561.9",
            "488427258694004.49",
            "2452",
            "3600.79",
            "77863.52",
            "6792110598881568231296106.97",
            "0971771572"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45",
            "number",
            "2323w",
            "89238nfdd",
            "#3",
            "734872.s",
            "-237",
            "3as784fs",
            "42jhfe",
            "jh####dsjh"
        ],
        "id": 1977,
        "output": [
            {
                "text": "\nThe regex is ([0-9]{1,3})\\.[0-9]{2}(?:[eE][+-]?[0-9]+)\n\n2. Write a regex to validate phone numbers with international formats using locale-specific rules. \nAnswer"
            },
            {
                "text": " ^[0-9]+\\.[0-9]*$\n\n#### Exercise 8.2:\nWrite a Python function that extracts and returns the first ten alphanumeric words in an email or message text.\n\n```python\nimport re\n\ndef extract_alphanumeric_"
            },
            {
                "text": " \"([0-9]{1,3}).(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|6[0-9]|"
            },
            {
                "text": "\nr'^([0-9]{3})([.][0-9]+)$'\n\nExercise 5:\nWhat is the difference between a positive and negative lookahead assertion?\nAnswer: A positive lookahead assertion matches the preceding character or group, but doesn't consume"
            },
            {
                "text": " \\d+\\.\\d*|\\d+\n\nExercise 4: Generate a Regular Expression for the following search pattern:\n- A string with an unknown number of digits followed by an unknown number of letters\nMatch examples:\n- \"1234abc\"\n- \"5678 ab"
            },
            {
                "text": " (\\d+)(\\.\\d+)?\n\n# 8.2.3 The use of brackets, curly braces, and parenthesis to define the character class or character set\n\nIn Python, we can use brackets, curly braces, and parenthesis to define a character class or character set"
            },
            {
                "text": " \\d+\\.\\d+\n\nExercise 2: Write a Python program that validates email addresses using a RegEx pattern.\nAnswer:\n\nimport re\n#Create a RegEx pattern for email address validation.\nemail_pattern = r\"[\\w.-]+@[\\w"
            },
            {
                "text": " \"^[\\d\\.]+$\"\n\nExercise 4:\nCreate a RegEx that matches the following email addresses:\n- john.doe@example.com\n- jane.doe@xyz.com\n- bob_smith@abc.com\n\nAnswer"
            },
            {
                "text": " \nimport re\ndef valid_num(num):\n    if re.match(r'^\\d+$', num):\n        try:\n            float(num)\n            return True\n        except ValueError:\n            return False\n    else:\n        return False\n"
            },
            {
                "text": " \"\\d+[,.]\\d*\"\n```\n\n#### Exercise\n1. Write a Django view that returns the sum of two numbers from different URL routes.\n```python\n# Solution\nfrom django.http import HttpResponse\n\ndef sum_view(request):"
            }
        ]
    },
    {
        "expression": "(\\d{3}\\-\\d{2}\\-\\d{4})",
        "raw_prompt": "pattern match for U.S. social security number",
        "refined_prompt": "pattern match for U.S. social security number\nMatch examples:\n- \"111-22-3333\"\n- \"667-98-7198\"\n- \"331-67-7759\"\nNon-match examples:\n- \"11-222-3333\"\n- \"1111-22-333\"",
        "matches": [
            "111-22-3333",
            "667-98-7198",
            "331-67-7759",
            "836-90-2480",
            "516-26-0805",
            "228-14-4300",
            "629-76-7319",
            "595-42-2584",
            "943-54-5478",
            "550-45-1481",
            "052-74-9223",
            "610-37-5051",
            "082-67-0567"
        ],
        "non_matches": [
            "11-222-3333",
            "1111-22-333",
            "123456",
            "1212-3284",
            "234",
            "#234",
            "12/12",
            "0987654567898765345678",
            "74.23",
            "number",
            "00000",
            "43677634"
        ],
        "id": 1978,
        "output": [
            {
                "text": " (e.g. \"^[A-Z]{3}\\d{3}\\-\\d{4}\\d{2,3}$\")\n\n3. Exercise: Use RegEx to verify that your passwords meet"
            },
            {
                "text": " A regular expression for a U.S. social security number would be [A-Z]{3}[0-9]{3}-[0-9]{4} or [0-9]{3}-["
            },
            {
                "text": "\n(?=^\\d{3}-\\d{2}-\\d{4}$)(?=^\\d{3}-\\d{2}-\\d{4}$)[A-"
            },
            {
                "text": " The RegEx pattern to match a social security number in the format (XXX) XXX-XXXX.\n\nExercise 3:\nMatch examples using the following RegEx:\nPattern: A-Z0-9 \n- \""
            },
            {
                "text": "\nThe RegEx for a U.S. social security number is [\\d-]{3}-\\d{3}-\\d{4}\n\nExercise 2:\nCreate a List of 10 random names"
            },
            {
                "text": " A RegEx for this description is \"^(?:(?=([0-9]{3}-){2}[0-9]){6}(?:[0-9]|[1-9]?"
            },
            {
                "text": " \n\n[A-Z]{3}[0-9]{2}[-]?[0-9]{4}[A-Z]{3}\n\n\n\nQuestion 6: The perimeter"
            },
            {
                "text": " \n\nimport re\ntext = \"This is an example of a social security number. It has a length of 13 digits followed by a length of 6 digits followed by a length of 3 digits.\"\npattern = re.compile"
            },
            {
                "text": " A RegEx pattern to match US social security number is [0-9]{3}[-]?[0-9]{3}-[0-9]{4}?\nExercise 3: \nCreate"
            },
            {
                "text": " \\d{3}-\\d{2}-\\d{4}\n\nExercise 4:\nCreate a RegEx for email validation that only accepts emails with a valid domain name.\nExample:\n- \"hello"
            }
        ]
    },
    {
        "expression": "^([a-zA-Z]{5})([a-zA-Z0-9-]{3,12})",
        "raw_prompt": "Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphen; string length is eight characters minimum, 17 characters maximum",
        "refined_prompt": "Validate: First five characters are letters; characters six-17 are letters, numbers, or hyphens; string length is eight characters minimum, 17 characters maximum\nMatch examples:\n- \"ABCDE123abc-123AB\"\n- \"pFNulUVyRFPTu\"\n- \"MuRqTOCiErV9\"\nNon-match examples:\n- \"1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678\"\n- \"3434rfes\"",
        "matches": [
            "ABCDE123abc-123AB",
            "pFNulUVyRFPTu",
            "MuRqTOCiErV9",
            "StqMcwgMambwy",
            "BziWc3EP94L4aA",
            "aucVZkOFyMFeI",
            "OzXSB0TO5MPDJ0WCr",
            "iLqZO-LqnRwtWsTR",
            "gJAkd736b",
            "CjCuwrYSf8x",
            "ZCNqIftYFfYe8Qe",
            "QtrpbMd7WeJ",
            "LxzbzIzo78G"
        ],
        "non_matches": [
            "1BCDE123abc-123AB -BCDE123abc-123AB ABCDE6789012345678",
            "3434rfes",
            "/edcsfewfred3443efwds/",
            "434",
            "number",
            "uehfgdc",
            "KLKJHGF",
            "t4refdsc",
            "5%",
            "vvf",
            "###",
            "----"
        ],
        "id": 1986,
        "output": [
            {
                "text": " ("
            },
            {
                "text": "\n"
            },
            {
                "text": "\n"
            },
            {
                "text": " ["
            },
            {
                "text": " ["
            },
            {
                "text": " ^"
            },
            {
                "text": "\n"
            },
            {
                "text": " ^"
            },
            {
                "text": " ^"
            },
            {
                "text": " ^"
            }
        ]
    },
    {
        "expression": "^([^S]|S[^E]|SE[^P]).*",
        "raw_prompt": "Matches everything except lines that begin with SEP.\nNow I just need to figure out how to exclude a string that appears in the middle of a line.",
        "refined_prompt": "Matches everything except lines that begin with SEP.\nMatch examples:\n- \"SEk001\"\n- \"TAK002\"\n- \"SE7ge+f9FQ7x ]]9ZEl]Pg\"@}j DTw%oyyAz\"\nNon-match examples:\n- \"SEP001\"\n- \"SEP002\"",
        "matches": [
            "SEk001",
            "TAK002",
            "SE7ge+f9FQ7x ]]9ZEl]Pg\"@}j DTw%oyyAz",
            "`x>2rC.?XLCh_f0F/Gmks9f?43'TY7yBM+X\"%+K%",
            "Sgk5: +1.OxaU3Lu0nPEG}a[_4V7I\"m}?Ti= Pm78zQn20% r>Qa5Mh4=_KO",
            "1c<9iVc3cv'dMnh6(US<:xV(:]Qk-.l^>wKs6SL p-Bq@1aJ@~5zX=r^2~x4$@f2~ilh6Qaq~?goT1Y}s",
            "SElB=",
            "SEHgqx+YX\"/g_Vgr[$e7dZT=G9c5XDAFdj",
            "S]hg0.duW^rKLOK$A1S",
            "SE~-*2$2Me8~3l,K_!;o<6",
            "SPY!a}",
            "SE&D]d3_VQiuL*Vh\\|!uPcQTvwFTek",
            "qd.<CY\\x/a Ii1oyP"
        ],
        "non_matches": [
            "SEP001",
            "SEP002",
            "SEP",
            "SEPrfvf",
            "SEP349349",
            "SEP....",
            "SEP098764edfvbnm",
            "SEP[[[[[[",
            "SEP----",
            "SEP?wefe/",
            "SEP983378hd",
            "SEP4598459549854rdsxjdmwef"
        ],
        "id": 2008,
        "output": [
            {
                "text": " [^SEP]{1}(\\s\\w)*\n\nExercise 2:\nWrite a Python script that creates a RegEx pattern to match all phone numbers"
            },
            {
                "text": "\n[A-Z]{3}-[0-9]{4}\n\nIn the second example, \"SEP\" is not a matched character so it"
            },
            {
                "text": "\n\\W(?P<SEP>SEP\\d+)\\W\n\nA:\n\nI wrote a regex that does this pretty precisely, with some"
            },
            {
                "text": " \"[^A-Z]\\\\w+\nThe [^A-Z] character will match any character that is not an uppercase letter.\n\\\\w+"
            },
            {
                "text": " (.*)\n\n5. Write a regular expression that matches any text that can be written using only uppercase letters, lowercase letters, and digits.\nAnswer"
            },
            {
                "text": " ^SEP001|^SEP002|^\n\nExercise 2: Write a regular expression that will match strings starting with a string of alphanumeric characters and"
            },
            {
                "text": " ^[A-z0-9]*(?!SEP)\n\nI'm trying to write a RegEx for the first line of the file so it doesn"
            },
            {
                "text": " ^^(?:SEP+)(?:[0-9A-Z]+)$\n\nExercise 4:\n\nAdd additional character classes to the regular expression"
            },
            {
                "text": "\n[^SEP][0-9]{4}[^SEP]*[SEP]\n\n3. Write a regular expression that matches all email"
            },
            {
                "text": " \"^[^SEP]+$\"\nHere is an example of how to use the match() function:\nimport re\n\ntext = \"This is example text"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]{1}|2[0-3]{1}):([0-5]{1}[0-9]{1})$",
        "raw_prompt": "This expression will validate if a string represents a time in 24 hour format.\nThe expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead.",
        "refined_prompt": "This expression will validate if a string represents a time in 24 hour format.\r\nThe expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead.\nMatch examples:\n- \"1:59\"\n- \"01:59\"\n- \"23:59\"\nNon-match examples:\n- \"24:00\"\n- \"01:60\"",
        "matches": [
            "1:59",
            "01:59",
            "23:59",
            "22:19",
            "06:04",
            "23:01",
            "17:58",
            "6:20",
            "21:38",
            "21:22",
            "11:19",
            "23:12",
            "0:05"
        ],
        "non_matches": [
            "24:00",
            "01:60",
            "01:234",
            "time",
            "12",
            "60:60",
            "532132",
            "3",
            "0987654",
            "645332",
            "74773",
            "----"
        ],
        "id": 2011,
        "output": [
            {
                "text": " \"([1-9]|1[0-2])[0-9]:[0-5]\"\n- \"14:"
            },
            {
                "text": " (0[1-9]|1[0-2]):[0-5][0-9]\nThis expression will"
            },
            {
                "text": " \"^(1[0-3]|[0-9]|[1-9][0-9]):([0"
            },
            {
                "text": " \n\\d{1,2}\\s+:\\s+\\d{1,2}.\\d{2}(am"
            },
            {
                "text": " [0-9]\\d:[0-9]\\d\n\nA:\n\nI think using /\\d{0"
            },
            {
                "text": " \nThis expression will validate if a string represents a time in 24 hour format.\r\nThe expression will evaluate the string from start to"
            },
            {
                "text": "\n\nvar text = '0:59';\r\nvar regex = /\\d{2}:\\d{2}/;"
            },
            {
                "text": " \"(\\d{2}:\\d{2})(\\s+)([a-z]\\d{3})\"\n"
            },
            {
                "text": " ^([0-5]?[0-9])[0-9]:\\d[0-9]$\n\nGener"
            },
            {
                "text": " ^[0-9]{1,2}:[0-9]{2}$\n- \"01:00\"Gener"
            }
        ]
    },
    {
        "expression": "([.])([a-z,1-9]{3,4})(\\/)",
        "raw_prompt": "Returns the TLD from a URL.",
        "refined_prompt": "Returns the Top-level domain from a URL.\nMatch examples:\n- \".com/\"\n- \".net/\"\n- \".biz/\"\nNon-match examples:\n- \".co.uk/\"\n- \".org.uk/\"",
        "matches": [
            ".com/",
            ".net/",
            ".biz/",
            ".123/",
            ".mobi/",
            ".w4e/",
            ".m1w/",
            ".,gn/",
            ".falm/",
            ".e41/",
            ".z97/",
            ".1w8i/",
            ".sjz5/"
        ],
        "non_matches": [
            ".co.uk/",
            ".org.uk/",
            "website",
            "./",
            "4343443",
            "www.",
            "@gmail.com",
            "3245675432",
            "efffqe",
            "https://",
            "https://efdcs",
            "https://efdcs.erdsww"
        ],
        "id": 2013,
        "output": [
            {
                "text": "\n(\\.[a-zA-Z]+(?:\\.[a-zA-Z]+)*)\n\"\"\"\n\ns = \"https://www.example.com/?a=1&b=2\"\nprint(re.findall(r\"(\\.[a-zA-Z]+"
            },
            {
                "text": " \n```python\n# A description for a URL that matches a top-level domain\ntop_level_domain = \"(https?://)?(www\\.)?(com|net|org|edu|gov|mil|aero|asia\"\n\n# A description for a URL that does not match"
            },
            {
                "text": " http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))"
            },
            {
                "text": ".(.*?)\\/\n\n3. Write a Python program to extract the top-level domain from a URL and generate a regular expression for all URLs with that top-level domain\ne.g. www.google.com. Generate a RegEx for this description. \n\n```python\nimport re"
            },
            {
                "text": " [^\\.]+$\n\nExercise 4: \nCreate a RegEx to match all capitalized letters in a string.\nAnswer: [A-Z] \n\nExercise 5: \nCreate a RegEx to match all numbers from 1-10.\nAnswer: \\d{1,"
            },
            {
                "text": " The regex would be \"(^[a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)+$)\", which matches the top-level domain of a URL. \n\nExercise 2: Write a Python function that takes a string as input and returns the domain"
            },
            {
                "text": " (.*?)\\.(.*?)$\n\nSubsection 7.5.9: Using the re Module to Perform Pattern Matching and Substitution\n\nContents:\n- Introduction to re module\n- Pattern matching using re.match()\n- Substitution of matched patterns using re.sub()\n- Combining"
            },
            {
                "text": ".com|.net|.biz\n\n## Exercise 5:\n\nCreate a Python function that takes in a list of URLs and returns a list of their top-level domains (TLDs). A TLD is the domain name that comes after the last dot in a URL, such as \".com\", \".org"
            },
            {
                "text": " (.*)\\.uk$\n\nExercise 5:\nUse the RegEx provided to find all the usernames in the given string:\n'User1:test@test.com User2:test1@test1.net User3:test2@test2.biz User4:test3@"
            },
            {
                "text": ".com|net|biz\n3. Write a RegEx to match a string containing an email address.\nAnswer: \\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{"
            }
        ]
    },
    {
        "expression": "^\\$?\\d{1,2}\\,\\d{3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?(\\.(\\d{2}))$",
        "raw_prompt": "Needed to verify a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions. If you want to make the decimal side optional, add a question mark before the final $ in each expression.",
        "refined_prompt": "Verifies a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions.\nMatch examples:\n- \"1.99\"\n- \"111,111.99\"\n- \"11,111,111.99\"\nNon-match examples:\n- \"1.999\"\n- \"1111\"",
        "matches": [
            "1.99",
            "111,111.99",
            "11,111,111.99",
            "12,999.00",
            "1,243,434.04",
            "132,423.32",
            "233,985.43",
            "12,444.67",
            "23,323,342.67",
            "45,344,777.12",
            "55,555,555.55",
            "67,432,333.09",
            "1,000.44"
        ],
        "non_matches": [
            "1.999",
            "1111",
            "1111111",
            "11.9",
            "332",
            "34345432.0",
            "1,000",
            "1,23435543.",
            ".0",
            "452334",
            "09876556789876545678976545678956789",
            "323"
        ],
        "id": 2014,
        "output": [
            {
                "text": "  (^\\d{1,3}(,\\d{3})*$)\n\n2. Write a Python code to match all numbers from the input"
            },
            {
                "text": " \n\"[1-9]\\d*[,.]\"\n\n3. Match a sequence of 2 to 4 letters followed by a period and a space.\n"
            },
            {
                "text": " ([0-9]\\.[0-9]){3}\n- \"11,11.11\"Generate a RegEx for this description. \nAnswer"
            },
            {
                "text": " One or more numbers that end with a comma and two decimal spaces to the right.\n\nExercise 2:\nMatch examples:\n- \"A.01 - A"
            },
            {
                "text": "\n-.*?[1-9][0-9]{0,2}[.]0[0-9]{0,2}\n\"\"\"\n"
            },
            {
                "text": " \nLecture Script:\n\nContents:\n1. Introduction\n2. What is a regular expression?\n3. How regular expressions are used in Python"
            },
            {
                "text": "\n\\d+\\.\\d{1,2}|\\d{0,3}.\\d{1,2}|\\d{0,3}."
            },
            {
                "text": " [0-9]{0,9},[0-9]{0,9}\n\n4. What special character is used to match a backslash"
            },
            {
                "text": " (\\d+,\\d{3})+(\\.\\d+)+\n\nExercise 3:\nWrite a Python function that uses the re module to check if a"
            },
            {
                "text": " \\d[\\d\\.\\,]+\n\n2. Write a regular expression that identifies the pattern for the string \"The quick brown fox jumps over the lazy dog.\""
            }
        ]
    },
    {
        "expression": "(1)?-?\\(?\\s*([0-9]{3})\\s*\\)?\\s*-?([0-9]{3})\\s*-?\\s*([0-9]{4})\\s*",
        "raw_prompt": "A very simple regex to parse 10-digit US phone numbers. Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.\nThis expression DOES allow for reserved area codes (001,etc) which are not typically in use.",
        "refined_prompt": "Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.\r\nThis expression DOES allow for reserved area codes (001,etc) which are not typically in use.\nMatch examples:\n- \"(123)456-7890\"\n- \"1234567890\"\n- \"123 456 7890\"\nNon-match examples:\n- \"123456789\"\n- \"(1234)567890\"",
        "matches": [
            "(123)456-7890",
            "1234567890",
            "123 456 7890",
            "123-456-7890",
            "(123)4567890",
            "123-4567890",
            "433-432-4853",
            "442-875-1290",
            "111-463-0093",
            "1129-444-3333",
            "748-567-8888",
            "242-543-4498",
            "777-555-4444"
        ],
        "non_matches": [
            "123456789",
            "(1234)567890",
            "(12-3)4567890",
            "98765",
            "342",
            "#4",
            "67%",
            "12/12",
            "34321`2",
            "1,000",
            "000",
            "34321"
        ],
        "id": 2023,
        "output": [
            {
                "text": " \"(["
            },
            {
                "text": " (^"
            },
            {
                "text": " This expression"
            },
            {
                "text": " The Reg"
            },
            {
                "text": "\n(\\"
            },
            {
                "text": " \n"
            },
            {
                "text": " (\\"
            },
            {
                "text": " \"\\\\"
            },
            {
                "text": " Generates"
            },
            {
                "text": " [0"
            }
        ]
    },
    {
        "expression": "^(\\+48\\s+)?\\d{3}(\\s*|\\-)\\d{3}(\\s*|\\-)\\d{3}$",
        "raw_prompt": "Supported: +48 prefix (optional); separating elements with hyphen or spaces",
        "refined_prompt": "Matches elements separated with hyphen or spaces\nMatch examples:\n- \"+48 500-080-100\"\n- \"500080100\"\n- \"500 080 100\"\nNon-match examples:\n- \"+47 100-100-100\"\n- \"1000-100-100\"",
        "matches": [
            "+48 500-080-100",
            "500080100",
            "500 080 100",
            "015-362-374",
            "775-037-965",
            "807\u2028071\u200a\u2029329",
            "949-920\u2002625",
            "733-210-865",
            "451-027-089",
            "917-009-884",
            "372-376-709",
            "373-961-022",
            "462-751-532"
        ],
        "non_matches": [
            "+47 100-100-100",
            "1000-100-100",
            "1000000000",
            "9876567894",
            "333",
            "39203",
            "2321`",
            "$45",
            "45%",
            "0987654567",
            "0987654567-45342",
            "2384"
        ],
        "id": 2025,
        "output": [
            {
                "text": " A RegEx can be created by using the '|' character to indicate a variety of different options. The pattern will be '\\+([0-9]{3})[0-9]|([0-9]{3})[0"
            },
            {
                "text": " \\d+ \\d{3}- \\d{3}-\\d{4} \n\nExercise 2:\n- Write a regular expression that matches strings starting with a capital letter and ending with a period, dash, or exclamation"
            },
            {
                "text": "\n\n```python\n# Define the search string\nquery = \"45 805 090 100\"\n\n# Define the pattern for the number pattern\npattern = r\"^\\d+-\\d+-\\d+$"
            },
            {
                "text": " [\\+]?[0-9]{1,}[ -][0-9]{1,}[-][0-9]{1,}\n\nExercise 2:\nExplain the concept of quantifiers in regular"
            },
            {
                "text": " ([\\+\\-])(\\s?\\d+)\\s?([\\-\\s]\\d+)?\n\nExercise 2: \nCreate a Python function that takes a string as input and returns True if the string is a valid phone"
            },
            {
                "text": " ^\\+\\d+(\\-\\d+)[^-]+$\n\nExercise 2: Identify the different types of hyphens and dashes in the following sentence:\n\"The quick-brown-fox jumped over the lazy-dog.\""
            },
            {
                "text": " \"^[+]?[0-9]{3}[-][0-9]{3}[-][0-9]{3}[0-9]-[0-9]{3}[0-9]-"
            },
            {
                "text": " (\\+\\d{3}\\s\\d{3}\\s\\d{4})|(\\+\\d{3}\\-\\d{3}\\-\\d{4})\n\nExercise 3:\nWrite a regular expression"
            },
            {
                "text": " (\\+\\S+\\s+\\-?\\S+\\s+\\-?\\S+\\s+)\n\nIn conclusion, mastering regular expressions is a vital skill for software developers who work with data. With Python\u2019s \u201c"
            },
            {
                "text": " \"^[+]?[0-9][0-9] [0-9][0-9] [0-9]$\"\n\nExercise 5:\nIn this exercise, you'll need to use a combination of regex characters"
            }
        ]
    },
    {
        "expression": "\\b[1-9]\\d{3}\\ +[A-Z]{2}\\b",
        "raw_prompt": "Dutch postal codes are ranged from \"1000 AA\" to \"9999 ZZ\".",
        "refined_prompt": "Matches dutch postal codes are ranged from \"1000 AA\" to \"9999 ZZ\".\nMatch examples:\n- \"\"1484 EE\"\"\n- \"4996                                                      ZT\"\n- \"3617                                                   JP\"\nNon-match examples:\n- \"\"1484EE\"\"\n- \"\"0111 AB\"\"",
        "matches": [
            "\"1484 EE\"",
            "4996                                                      ZT",
            "3617                                                   JP",
            "3190                                                IR",
            "9377                                                                          PM",
            "5360                                                        PE",
            "5562                                NB",
            "3797                                                                           TW",
            "1074                                                                   WO",
            "8090                                            IR",
            "9581             ON",
            "6357                 SW",
            "3714                                HX"
        ],
        "non_matches": [
            "\"1484EE\"",
            "\"0111 AB\"",
            "\"1484 ee\"",
            "\"1234 ABC\"",
            "9876567",
            "9876567",
            "#3",
            "45%",
            "pkf943",
            "()",
            "-3402",
            "111!"
        ],
        "id": 2031,
        "output": [
            {
                "text": " (\\d+)(\\d\\d) (Z|D)\n\nMy code is as follows:\n    string[] array = { \"1484EE\", \"4996\", \"3617\", \"0111"
            },
            {
                "text": " (^\\d{3}\\s[A-Z]\\d{3}[A-Z]\\d{3}$).*$ is the correct RegEx.\n\nExercise: How would you"
            },
            {
                "text": " \"\"^\\+14\\d+E\\+0[0-9]\\d{2}\\.\\d{2}$\"\"\n- \"1484\"\n\n5) Write a RegEx to check"
            },
            {
                "text": "\n(\\d{4})(\\d)\n\nExercise 3: Create a list of all the words in a given sentence that contain the letter 'e' or 'E'.\nAnswer:\ndef has_e"
            },
            {
                "text": " [0-9]{3}[1-9]\\d\\d\n\nI hope that these examples have helped you to understand regular expressions and how they can be applied in real-world scenarios. Keep practicing and"
            },
            {
                "text": " ^[0-9]{2}[A-Z]{2}[0-9]{3}$\n- \"0001 AB\"\n- \"ZAB\"\n\n5. Write a regular expression"
            },
            {
                "text": " ^\\d{5}[A-Z]\\d{3}$\n- \"\"0111AB\"\"Generate a RegEx for this description. \nAnswer: ^\\d{4}[A-"
            },
            {
                "text": " \n^[A-Z]{2}[A-Z0-9]{3}$\n\nUse case 2:\nScenario: A group of students are discussing how to solve a math problem involving"
            },
            {
                "text": " \\A[0-9]{2}\\.[0-9]{3}\\.[2-9]\\.[0-9]\\Z\n\n#### Exercise 2:\n\nIn the example above, the pattern"
            },
            {
                "text": "\n\\s[A-Za-z0-9\\-\\(\\) \\. \\, ]{1,2}\\s\n\nCode:\nimport re\n\nreg_ex = re.compile("
            }
        ]
    },
    {
        "expression": "<[^>]*>",
        "raw_prompt": "This Regex Will Remove All Html Tags And Return Simple Plain Text .\nFor Example In C#.NET :\nRegex.Replace(Html, \"<[^>]*>\", string.Empty);",
        "refined_prompt": "Captures html tags (< >)\nMatch examples:\n- \"<p> Hello Ali Delshad </p>\"\n- \"<^*Copm9W4.08uAL6f{mmVLpyk&^~_SCFpg-\\V#myG\\4Bj77>\"\n- \"<QX`3>\"\nNon-match examples:\n- \"Hello Ali Delshad\"\n- \"<\"",
        "matches": [
            "<p> Hello Ali Delshad </p>",
            "<^*Copm9W4.08uAL6f{mmVLpyk&^~_SCFpg-\\V#myG\\4Bj77>",
            "<QX`3>",
            "<uI4iXP\"'LUic/-v;d|6EE`!B7Yo&4Ga,@]thSN)G{RmDUQp4gQ|y)H~V:tc=^J2{Ek*}FR9n,EXR@l1M*:#D'oB9v.F/Cc~s.X$X>",
            "<<,ZT0u<bm+B$;{J^2rKrk+#mm*zt@q{r,$Wu('[3:;2\\/iBaGlU)(t.)RzE3Bq)Sp1r>",
            "<ZI$sqc<5M. ]hNX<XrifE<!L(/Tjf^^>",
            "<kl&/DBZ=Fhzs u:r9e#IyMc<tbE:ndj$>",
            "< t2wyW,0#\\Qhf9%NhQj]PPiXn%i0zU7|gi=CK\\yhGgV>",
            "<Pc(-qc`5x%6')dA1L60+4raE>",
            "<+PxNy.]6,rln($I;1vyNawrzmd(-c%'T$Zn!;)( u!)@P+ajv<'t>",
            "<[\\=&\\l+|h.t<rW%,L4&vG>",
            "<}CJEDRfr nm0=tB\\*R1Q (Exa<>",
            "<6Od#AKt+8@@Q>"
        ],
        "non_matches": [
            "Hello Ali Delshad",
            "<",
            "<ecf",
            "wefcds>",
            "234fre?",
            "fewederer",
            "</.",
            "<<<<<",
            ">>krceds>",
            ">ceds>",
            "rkvced...",
            ",,<,"
        ],
        "id": 2040,
        "output": [
            {
                "text": " \\s*\\[.*\\]\\s*\\(.*\\)\\s*\n\nExercise 2:"
            },
            {
                "text": " <^\\d\\w+\"\n\nExercise 2:\nCreate a RegEx that will match email addresses"
            },
            {
                "text": "\n-.*<[^>]*>(.*)</[^>]*>.*$\n\"\"\"\n\n#"
            },
            {
                "text": " \n- r'^\\s*\\w{2,15}.*' # \\s* to match"
            },
            {
                "text": " h*l*l*o *a*i* d*i*s*d*a*l*"
            },
            {
                "text": " (^|<) Hello [a-zA-Z0-9 _\\-\\.-]+(?="
            },
            {
                "text": "\n```python\npattern = r\"^[a-zA-Z0-9_]+$\""
            },
            {
                "text": "\n\n(<[^>]+> +)(<[^>]+>)\n\n# Using Regular Expressions"
            },
            {
                "text": "\n- (.*)\n\n3. Create a RegEx to capture all numbers and letters between ()\nMatch examples"
            },
            {
                "text": " [A-Za-z0-9\\\\-_]{1,1000}\n- \"Hello Ali"
            }
        ]
    },
    {
        "expression": "[\\u0600-\\u06FF]",
        "raw_prompt": "This Regex chceck an input string for persian unicode character\nNote that it not work in javascript\nFor Example In C#.NET:\nRegex.IsMatch(Text, \"[\\u0600-\\u06FF]\");",
        "refined_prompt": "checks strings for Persian Unicode character\nMatch examples:\n- \"\u0633\u0644\u0627\u0645\"\n- \"hello \u0639\u0644\u06cc\"\n- \"Hi 2 \u0633\u0644\u0627\u0645\"\nNon-match examples:\n- \"Hello\"\n- \"Ali\"",
        "matches": [
            "\u0633\u0644\u0627\u0645",
            "hello \u0639\u0644\u06cc",
            "Hi 2 \u0633\u0644\u0627\u0645",
            "\u06c0",
            "\u060f",
            "\u06b9",
            "\u062e",
            "\u06ab",
            "\u0620",
            "\u066e",
            "\u06f4",
            "\u068a",
            "\u06ac"
        ],
        "non_matches": [
            "Hello",
            "Ali",
            "123",
            "#",
            "@",
            "!",
            "()",
            "^",
            "<>",
            "//",
            "{}",
            "&"
        ],
        "id": 2041,
        "output": [
            {
                "text": " r'^[a-zA-Z\\s\\d_]+$'\n\n3. Given a database of customers with the following records:\n```python\ncustomers = [\n    {'name': 'John', 'address': '(123) 456-78"
            },
            {
                "text": " The pattern would be (?i)\\b[A-Z][a-z]+\\b \n\n\n\nTitle: The Magical World of Biology: Exploring the Functions and Processes\n\nIntroduction:\n\nWelcome, young explorers, to the enchanting realm of biology! Have"
            },
            {
                "text": " \n\n```python\nimport re \n\n#Define a string\ns = 'hi 2 \u0633\u0644\u0627\u0645'\n\n#Create a regex pattern to find all the non-matching uppercase characters\npattern = r'[A-Z]'\n\n"
            },
            {
                "text": " \n\"\"\"\n\ndef hello_generation():\n  pattern = re.compile(r\"^(?P<name>\\w+)\\s(?P<language>\\w+)\\s(?P<name2>\\w+)\\s(?P<"
            },
            {
                "text": " (\\w+)([\\u0600-\\u06FF])(\\w+)([\\u0610-\\u0620])(\\w+)\n\n3. Write a Python code that takes a string as input and checks whether it's a valid IP address or"
            },
            {
                "text": " \\w+ (one or more word characters)\n\n3. Remove all non-matching characters from a string using RegEx.\n\n- Example string: \"This is a sample sentence. It contains \\x0E, which are non-matching characters.\"\n- RegEx"
            },
            {
                "text": " r'^[^\\W\\d_]+$'\n\n4. Write a Python code that uses RegEx to find all email addresses in a string.\n\nimport re\n\ndef find_emails(text):\n    return re.findall(r'\\b"
            },
            {
                "text": " ^([A-Za-z0-9 ]+)-([A-Za-z0-9 ]+)$\nExercise 2:\nMatch the email address formats using RegEx\nEmail address formats:\n- \"abc@example.com\"\n- \"abcd"
            },
            {
                "text": " \"Hello\"\n\n2. Write a Python function that takes a string as input and returns a new string with any non-ASCII characters replaced with their closest matching character in a predefined list of possible characters.\nExample: \"Hello, \u3053\u3093\u306b\u3061\u306f\" -> \""
            },
            {
                "text": " \"^i[\u060c\u061b\u061f]*$\"\n\n5. Define a custom Django template tag called \"emoji_color\" that takes a single parameter, \"color,\" and returns a string that will display an emoji representing the color.\nAnswer: \n``"
            }
        ]
    },
    {
        "expression": "^(?=.*\\d)(?=.*[a-z])([a-z0-9]{8,25})$",
        "raw_prompt": "Password matching expression. Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter and 1 numeric digit. Upper case, space and punctuation marks are not allowed.",
        "refined_prompt": "Password matching expression. Password must be at least 8 characters,no more then 25 characters, must include at least 1 lower case letter and 1 numeric digit. Upper case, space and punctuation marks are not allowed.\nMatch examples:\n- \"aaaaaaa1\"\n- \"abcdefghijklmnoprqstu1234\"\n- \"1234567a\"\nNon-match examples:\n- \"aaaaaaA1\"\n- \"0123456789kB\"",
        "matches": [
            "aaaaaaa1",
            "abcdefghijklmnoprqstu1234",
            "1234567a",
            "kaon4bdb8u04pp3",
            "o5hc1c79fg4vsmcdvx9mab",
            "d6rixrp1u52",
            "mpbzuhpfe3zuvocwyr8z9f5c",
            "6vu7ju9myqypoai9eqsyomae9",
            "6bagbgfblkv912vsa1xp32d0",
            "adeg4763w557eo0ctn",
            "kwtd710f",
            "cmii3neikqw",
            "h88zwgxs"
        ],
        "non_matches": [
            "aaaaaaA1",
            "0123456789kB",
            "1234567890abcde123456 A%.",
            "32rfe34",
            "kjhgfcvbnm",
            "password",
            "PASSWORD",
            "rfesw34rdd,",
            "cseoi37;;;",
            "32!f'ef4",
            "4rfe87&",
            "#3"
        ],
        "id": 2049,
        "output": [
            {
                "text": " \n(\\w{8,25})([a"
            },
            {
                "text": " [a-zA-Z]\\d[a"
            },
            {
                "text": " \nPassword must be at least 8 characters, no more"
            },
            {
                "text": " (at least one upper case letter, one number, and"
            },
            {
                "text": " (A) 8-9 characters (A) At least"
            },
            {
                "text": " [a-zA-Z0-9_]"
            },
            {
                "text": " /^(?=.*[\\d])(?"
            },
            {
                "text": "\n^(?=.{8,25})("
            },
            {
                "text": " a-zA-Z0-9\n\nEx"
            },
            {
                "text": " \n$pattern='^(?=.*[a"
            }
        ]
    },
    {
        "expression": "^((([sS]|[nN])[a-hA-Hj-zJ-Z])|(([tT]|[oO])[abfglmqrvwABFGLMQRVW])|([hH][l-zL-Z])|([jJ][lmqrvwLMQRVW]))([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?([0-9]{2})?$",
        "raw_prompt": "Matches standard 0- to 10-figure (non-tetrad) Ordnance Survey of Great Britain (OSGB) Grid References",
        "refined_prompt": "\nMatch examples:\n- \"SH\"\n- \"OF1234567890\"\n- \"NP1234\"\nNon-match examples:\n- \"SH123\"\n- \"SH12D\"",
        "matches": [
            "SH",
            "OF1234567890",
            "NP1234"
        ],
        "non_matches": [
            "SH123",
            "SH12D",
            "NI1234",
            "1234"
        ],
        "id": 2069,
        "output": [
            {
                "text": " (NP.+)([a-z]{1})([0-9]{1})\n\n4. Write a Python code that checks if a password has been created using the following rules:\n- At least one uppercase letter\n- At least one lowercase letter\n- At least one digit\n- At least one"
            },
            {
                "text": " \"SH\\d+\"\n\n2. Create a regex that identifies if a string starts with a vowel and ends with a consonant.\n\nMatch example:\n\"SHDY\"\nNon-match example:\n\"SHE12\"\nAnswer: \"^[aeiou]\\w*[bcdfghjkl"
            },
            {
                "text": " \"SH\\D{5}\"\n\n**Exercise 2:** \n\nGiven the following string:\n\"Patient name: Smith, Age: 45, Diagnosed with a disease.\"\n\nModify the following RegEx pattern to match only the patient name and the age:\n\"[a-zA-Z0-9"
            },
            {
                "text": " Sh\\d+\n\nExercise 5:\nCreate a list of words that start with a vowel and end with a consonant.\nAnswer:\n['apple', 'orange', 'elephant', 'iguana']\n\n\n\n[Theme music fades in]\n\nHost: Hello everyone and welcome to another episode of \"Math Matters"
            },
            {
                "text": " This is a Non-match example.\n\n4. Write a RegEx that matches any word that starts with the letter \"p\" and ends with the letter \"t\".\nAnswer: p\\w*t\n\n5. Write a RegEx that matches any email address that ends with \".com\".\nAnswer: (\\w+@"
            },
            {
                "text": " \"SH([0-9]+)D\"\n\n3. Exercise: \nWrite a string that represents a sentence. Use RegEx to match all words that start with \"A\" or \"a\".\nAnswer: \"Angela's bicycle is a rusty old thing\"\n\n4. Exercise: \nWrite a string that represents a"
            },
            {
                "text": " \n\nimport re\n\nstring = 'SPH1A1O1234567890'\n\npattern = r'[SPH][1A][1O][1234567890]'\n\nprint(re.findall(pattern, string))\n#Output: ['SPH1A1O', 'SPH12"
            },
            {
                "text": " \"^SH[0-9]*$\", which matches any sequence of \"SH\" characters that starts with \"SH\" and ends with a digit. \n\nExercise 3:\nFill in underscores in the following RegEx pattern: \"^\\d{3}-\\d{2}-\\d{4}$\"."
            },
            {
                "text": " (SH)([\\d, ]+)(NP)\n\nExample 3:\n- \"A1\"\n- \"K2\"\n- \"I3\"\n- \"L4\"\n- \"G5\"\n- \"M6\"\n- \"T7\"\n- \"T8\"\n- \"T9\""
            },
            {
                "text": " The RegEx for this description is \"(SH)|[A-Z]{1}[0-9]{3}[A-Z]{2}[0-9]{4}\".\n\nWe hope this section has helped you understand the basics of Regular Expressions in Python. Practice these exercises to get a better handle on"
            }
        ]
    },
    {
        "expression": "(((0[123456789]|10|11|12)(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "raw_prompt": "Validates dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces. No special characters or letters allowed. MM values allowed are 01 thru 12. YYYY values allowed are 1900 - 2999.\nThis is an adaptation of Felipe Albacete's MM/YYYY regular expression.",
        "refined_prompt": "Validate dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces. No special characters or letters are allowed. MM values allowed are 01 through 12. YYYY values allowed are 1900 - 2999.\nMatch examples:\n- \"052000\"\n- \"122008\"\n- \"101972\"\nNon-match examples:\n- \"12/2003\"\n- \"131997\"",
        "matches": [
            "052000",
            "122008",
            "101972",
            "041903",
            "111970",
            "062175",
            "112644",
            "112725",
            "101907",
            "101938",
            "052708",
            "122167",
            "052818"
        ],
        "non_matches": [
            "12/2003",
            "131997",
            "51988",
            "111899",
            "04.2004",
            "10-1965",
            "8765",
            "4387654678",
            "929",
            "0000",
            "12/37723",
            "46737"
        ],
        "id": 2083,
        "output": [
            {
                "text": " / (\\d{3})(\\d{2})(\\d{4}"
            },
            {
                "text": " [0-9]{4}-[0-9]{2}[0-"
            },
            {
                "text": " \n^(0[1-9]|1[012])([0-"
            },
            {
                "text": " \"^(0|1[012])(0|1[9])[0-"
            },
            {
                "text": " \n \\b([0-9]{1,2})([0-9"
            },
            {
                "text": "\n^(0?[1-9]|1[012])[0-9"
            },
            {
                "text": ".{2,5}\n\nExercise 2: Write a regular expression for the following"
            },
            {
                "text": " (\\d{4})/(\\d{2})(\\d{2})\n"
            },
            {
                "text": " \n[0-9]{4}[0-9]{3}["
            },
            {
                "text": " MM/YYYY\n\n3. Write a RegEx that matches any string that is 8"
            }
        ]
    },
    {
        "expression": "^\\#?[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$",
        "raw_prompt": "Matches valid 3 or 6 character hex codes used for HTML or CSS.",
        "refined_prompt": "Matches valid 3 or 6 character hex codes used for HTML or CSS.\nMatch examples:\n- \"fff\"\n- \"#990000\"\n- \"#cc3366\"\nNon-match examples:\n- \"#5555\"\n- \"#ZJK000\"",
        "matches": [
            "fff",
            "#990000",
            "#cc3366",
            "#AAAAAA",
            "F6a",
            "#e73",
            "#ae5A95",
            "49A14d",
            "#624",
            "#1fa",
            "B2F",
            "d2C647",
            "fbC"
        ],
        "non_matches": [
            "#5555",
            "#ZJK000",
            "CDCDCDCD",
            "4323",
            "2243",
            "thhjvefhjb",
            "2",
            "#2",
            "#0--3e0",
            "324234f",
            "8765rfgh",
            "7373"
        ],
        "id": 2086,
        "output": [
            {
                "text": " [^a-zA-Z0-9]\n\n2. Create a Python function that takes a list of strings as input and generates a RegEx that validates that all strings in the list contain at least one uppercase letter. Return the list of validated strings."
            },
            {
                "text": " /^[A-Fa-f0-9]{3}|[A-Fa-f0-9]{6}$/\n\n5. Write a RegEx for matching any decimal number between 0 and 10, inclusive.\n\nSolution:\n/^"
            },
            {
                "text": " ~#(?!(00|00))[A-Za-z0-9]{3}[A-Za-z0-9]{3}~\n\nExercise 4:\nSolve the following RegEx for password validation:\n^("
            },
            {
                "text": "\n/(^[0-9A-Fa-f]{3}$|^[0-9A-Fa-f]{6}$)/\n\nExercise 2: \nWrite a RegEx that validates a list of MAC addresses. Match the following"
            },
            {
                "text": "^[0-9a-fA-F]{6}$\n\n4. Write a Python program that uses the escape function to correctly format a string that includes a double quotation mark, a backslash, and a newline character.\n\nCode example:\n"
            },
            {
                "text": " (#[0-9A-Fa-f]{3}|#[0-9A-Fa-f]{6})\n\nExercise 3:\nUsing RegEx, write a function that takes a string and returns a list of all the words that start with"
            },
            {
                "text": "\n^[0-9A-Fa-f]{3}$\n\nExercise 3: Write a regex that matches only numbers that are exactly 6 digits, starting with 0.\nAnswer:\n^[0-9][0-9]{5}$\n"
            },
            {
                "text": " ^[a-f0-9]{3}-[a-f0-9]{3}-[a-f0-9]{3}[a-f0-9]{3}[a-f0-9]{3}$\n"
            },
            {
                "text": " ^(#[0-9a-fA-F]{3,6}$).\n\n4. Create a RegEx in Python to match all of the words in this sentence that start with the letter \"s\".\n```python\nimport re\n\nsent"
            },
            {
                "text": " (?<=^\\w{1,2}[0-9A-Fa-f]{3,6}$)(?<!\\d)(\\d{3})(?!\\d)(\\d{3})(?!\\d)(\\d{"
            }
        ]
    },
    {
        "expression": "^(?=.{6,})(?=.*[0-9].*)(?=.*[a-z].*).*$",
        "raw_prompt": "Password of 6 symbols. Must containt at leats one non-captial letter and at least digit digit",
        "refined_prompt": "Matches password of 6 symbols. Must contain at least one non-capital letter and at least digit digit\nMatch examples:\n- \"abc123\"\n- \"()()a1\"\n- \"_ABCDa1\"\nNon-match examples:\n- \"abcdef\"\n- \"ab_12\"",
        "matches": [
            "abc123",
            "()()a1",
            "_ABCDa1",
            "ooC`yid uJy,e-bhy@`UTz8",
            "p4Ee)oy5|P*xA)i'cb:VbV\"E0p62|d,0Ce;%;2*vJ04't3daGd#Ej[*m",
            "@*BArfIfbpk%7tap<0V3zG8s@!I^X]y4=x",
            "Ap,'OZwL~K_l8'K:",
            "@iN'Es{<V'4/.nQP77`}*E0b:4o",
            "-Zu#H *Y$m?+UU\\`/XEV:]Izg.]`nUFCAHQ%4]PUM]ilW2nW{+:",
            "b -$qmBxqHA<9y%!Wg1u20LJLm=t_ ` nLUGu9SU^ka'AWK%|z<*8t6\"7sr+jDtl=$C5@a",
            "w %4SJ5:<+]Dom\\",
            "jg9Bb5k`|tVBY82WG!EGDoR\\+QLnUSzKe[!dMu[0j_)yL2ouF,.dkJ&KA&l&h+cvwUpNV[c[{rH'- J4_E@164*`5u;9_?",
            "F=}is=jXBAm56.sG7Nn!nOo _<5+l;:L$+E.!'K3uK'0p"
        ],
        "non_matches": [
            "abcdef",
            "ab_12",
            "ABC123",
            "324",
            "445",
            "ace",
            "#",
            "@",
            "!",
            "%",
            "$",
            "*"
        ],
        "id": 2087,
        "output": [
            {
                "text": " The RegEx should be '(?=.*[a-z])(?=.*\\d).{6,}'. \n\n3. Write a RegEx that matches all IP addresses between 0.0.0.0 and 255"
            },
            {
                "text": "\n^(?=.*[a-z])(?=.*\\d)(?=.*[A-Z])[a-zA-Z\\d]{6,}$\n\nExercise 5:\nCreate a"
            },
            {
                "text": ".{3}/\\d\n\nExercise 2: \nUse the Python code below to verify the password \"my_pass@123.\" The username should be \"admin_admin.\"\n```python\nimport re\n\ndef"
            },
            {
                "text": " Non-cap-Lit+Digit letter+Non-cap-Lit+Digit plus or minus\n\n2. Given two sets of string, return a string that has all the matches and none of the non-matches."
            },
            {
                "text": " The regex to match this description is [^a-zA-Z0-9]\n\nExercise 3:\nCompile a RegEx to search for instances of the word \"python\" in a string, case-insensitive."
            },
            {
                "text": " \"^(?!.*[^a-z])(?!.*[^A-Z])(?!.*[^0-9])[a-zA-Z0-9]{6}$\"\n\nExercise 2"
            },
            {
                "text": " Matches a password of at least 8 symbols. Must contain at least 1 non-capital letter and at least 1 digit digit. \n\n2. Write a RegEx for a phone number of the format (XXX) XXX-XXXX.\n"
            },
            {
                "text": " [a-z0-9]+ [a-z0-9].+[a-z0-9]+ [a-z0-9].+[a-z0-9].+[a-z0-9"
            },
            {
                "text": " ^(?=.*\\d)(?=.*[a-z])[a-z0-9]{6,}$\n\nExercise 2: Password Validation\n\nCreate a function that takes in a password and checks"
            },
            {
                "text": " _[^a-zA-Z0-9].[a-zA-Z0-9]?$\n\n3. Write a RegEx to match a string that begins with a letter, followed by one or more digits"
            }
        ]
    },
    {
        "expression": "((\\d{0}[0-9]|\\d{0}[1]\\d{0}[0-2])(\\:)\\d{0}[0-5]\\d{0}[0-9](\\:)\\d{0}[0-5]\\d{0}[0-9]\\s(AM|PM))",
        "raw_prompt": "Matches hours 0-12:minutes 0-59:seconds 0-59 AM|PM",
        "refined_prompt": "Matches hours 0-12:minutes 0-59:seconds 0-59 AM|PM\nMatch examples:\n- \"0:00:00 AM\"\n- \"10:50:55\u2003PM\"\n- \"11:59:59 PM\"\nNon-match examples:\n- \"1:00 AM\"\n- \"5:3:00 PM\"",
        "matches": [
            "0:00:00 AM",
            "10:50:55\u2003PM",
            "11:59:59 PM",
            "12:00:00 AM",
            "5:34:00 PM",
            "5:20:43\u2003AM",
            "12:29:18\tPM",
            "10:25:13\u2006PM",
            "7:56:45 PM",
            "11:52:45\u2001AM",
            "10:35:12 AM",
            "8:52:28\u2009PM",
            "0:18:13\u2004AM"
        ],
        "non_matches": [
            "1:00 AM",
            "5:3:00 PM",
            "5:34:00 Pm",
            "5:34:00 P",
            "noon",
            "1 o'clock",
            "43r5t6789",
            "$5789",
            "9876%",
            "34fedc",
            "fg56hj7",
            "43re"
        ],
        "id": 2090,
        "output": [
            {
                "text": " \n\n1. ([A-Za-z]+[0-9]):([0-9]):([0-9])(?=\u2003"
            },
            {
                "text": "\n(?:[0-9]|1[012])\\.(?:0[0-9]|1[012]):[0-5]\\d"
            },
            {
                "text": " \n\n```python\nimport re\n\nmatch_list=[]\nnon_match_list=[]\nstart_hour=0\nstart_minute="
            },
            {
                "text": " (0[1-9]|1[012]):\\d\\d(st|nd|rd|th|am|pm)(\\.|:|)0"
            },
            {
                "text": " [\\d]{1,2}:[\\d]{2,2}:?[\\d]{2,2} (AM|PM)\n\n"
            },
            {
                "text": " (1) \\d{1,2}:\\d{2}:\\d{2}\\s(am|pm)\\s(2\\d{3}):"
            },
            {
                "text": "\n(00:00-00:59)|(1:00-2:59)|(3:00-11:59)|(12:00-24:"
            },
            {
                "text": " [0-9]{1,2}:[0-9]{2}:[0-9]{2}(?:AM|PM)\"\n\nEx"
            },
            {
                "text": " r'^([0-9]?\\d?):([0-5]?\\d?):([0-9]?\\d?)'\n\n"
            },
            {
                "text": " \n\n```python\n#Example code for generating a RegEx for time format\nimport re \n\npattern = '^(\\d{1,2}"
            }
        ]
    },
    {
        "expression": "^(([1-9]{1}[0-9]{0,5}([.]{1}[0-9]{0,2})?)|(([0]{1}))([.]{1}[0-9]{0,2})?)$",
        "raw_prompt": "This will allow your app to check currency during events such as key down\n(set to decimal(8,2) only)",
        "refined_prompt": "Matches currency with a decimal point. Does not require any places of decimal point\nMatch examples:\n- \"13\"\n- \"13.\"\n- \"13.1\"\nNon-match examples:\n- \"01\"\n- \".1\"",
        "matches": [
            "13",
            "13.",
            "13.1",
            "13.11",
            "0.",
            "0.1",
            "71",
            "49.",
            "450",
            "0.7",
            "1323.",
            "0.9",
            "7725"
        ],
        "non_matches": [
            "01",
            ".1",
            "0.011",
            "+987654",
            "$456789",
            "8765%",
            "#3",
            "erfvrt4g",
            "785645rf",
            "4gr",
            "45grfe",
            "money"
        ],
        "id": 2095,
        "output": [
            {
                "text": " \"[0-9.]\"\n\n3. Extract all the dates in a string with only the month, day and year\nimport re \n\n# Create a sample string\ndata = \"My birth date is on May 24, 1996.\"\n\n# Define the pattern\npattern = re."
            },
            {
                "text": " \\d{0,3}\\.?\\d{0,3}\n\n4. Given the string \"1.23\", apply RegEx to find all decimal numbers (without the decimal point), which should be [1.23.0, 1.230000095, 1.23000000"
            },
            {
                "text": "\n(?<=^|\\.)0(?=(\\d{1,3}\\.\\d{1,3})|[\\d\\.])\n\n5. Write a Python code to replace a certain decimal value with a new value in the given string.\nAnswer:\n"
            },
            {
                "text": " ^[0-9]*\\.[0-9]+$\n\n4. Does the expression match a valid email address?\n\nEmail Address Matches:\n- \"example@gmail.com\"\n- \"test123@gmail.com\"\n\nNon-match Examples:\n-"
            },
            {
                "text": " [0-9] \n\nExercise 2: \nFill in the blank in the RegEx pattern: \"^[a-zA-Z0-9._%+-]+$\"\nAnswer: [a-zA-Z0-9._%+-]+\n"
            },
            {
                "text": " \\d(\\.\\d+)?\n\nExercise 4: Match a currency with a decimal point. Does not require any places of decimal point\nMatch examples:\n- \"123.45\"\n- \"123.45.\"\n- \"123.45\"\nNon-match examples:\n"
            },
            {
                "text": " ^[13]\\.[0-9]$\n\n3. Match currency with two decimal places. Does not require any places of decimal point\nMatch examples:\n- \"0.12\"\n- \"1.234\"\nNon-match examples:\n- \"01\"\n- \"."
            },
            {
                "text": " \\d+\\.?\\d*\n\nExercise 2: \nWrite a regular expression for a phone number that starts with an area code, followed by a sequence of 10 digits, and an optional period and/or space in between. \nAnswer: \\d{3}[ -]"
            },
            {
                "text": " The pattern should be \"(^|[^0-9.])0+(.[0-9]|$)\". \n\nExercise 4: \nMatch currency with a decimal point. Does not require any places of decimal point\nMatching examples: \n- \"0.1\""
            },
            {
                "text": " (RegEx)^[0-9]{1,3}[.][0-9]{0,3}$\n- \"0.1\"\nAnswer: (RegEx)^[0-9]{1,3}$\n\n4. Write a regular expression"
            }
        ]
    },
    {
        "expression": "^[0-3]{1}[0-9]{1}[ ]{1}(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec){1}[ ]{1}[0-9]{2}$",
        "raw_prompt": "This will test to see if a date is formatted in the military style of 'dd MMM yy'",
        "refined_prompt": "This will test to see if a date is formatted in the military style of 'dd MMM yy'\nMatch examples:\n- \"12 DEC 08\"\n- \"03 jan 91\"\n- \"30 Mar 82\"\nNon-match examples:\n- \"41 DEC 08\"\n- \"03 jan 1991\"",
        "matches": [
            "12 DEC 08",
            "03 jan 91",
            "30 Mar 82",
            "05 jul 83",
            "01 Sep 62",
            "24 Nov 80",
            "16 Mar 81",
            "12 Nov 57",
            "36 OCT 13",
            "35 JUN 30",
            "11 aug 99",
            "38 sep 53",
            "38 sep 53"
        ],
        "non_matches": [
            "41 DEC 08",
            "03 jan 1991",
            "30 Mar '82",
            "pojhgf",
            "date",
            "january 26th",
            "jan 15 2003",
            "05 april 34",
            "12 may 2007",
            "987",
            "23 june 1999",
            "july 14"
        ],
        "id": 2103,
        "output": [
            {
                "text": " ^[0-3]+[a-zA-Z][0-9]{2}$\n\nExercise 2:\nCreate a regular expression for a US phone number. The pattern should match a string of exactly 10"
            },
            {
                "text": " \\d{1,2}(?:[-\\/.] |\\s)(\\d{1,2})[-\\/.] \\d{4}\n\nExercise 3:\nFormat a datetime object string to the"
            },
            {
                "text": "\nimport re\npattern = '[A-Z][a-z][0-9]{3}[-/][0-9]{2}[-/][0-9]{4}'\nmatch ="
            },
            {
                "text": " '^[0-9]{1,2}\\s[A-Z]{3}\\s[A-Z]{4}$'\n\nExercise 2: Create a variable that stores a sentence in upper-"
            },
            {
                "text": "\nimport re\n\ndef is_valid_date(date):\n  if (\n    re.match(r\"(\\d{1,2})\\s([A-Z]{3,5})\\s(["
            },
            {
                "text": " (the answer should be in the form of a RegEx string: '^\\d{1,2} \\D{1,3} \\d{4}$')\n\n4. Use PyMongo to insert a"
            },
            {
                "text": " [^A-Za-z ][A-Za-z0-9 -]{1,20}[A-Za-z]\n2. Use this RegEx to extract an IP address from a string"
            },
            {
                "text": " \nimport re\ninput_date_str = \"12 DEC 08\"\ndate_regex = r'^\\d{1}[a-z][a-z]{2}\\s+[a-z"
            },
            {
                "text": " (.{1,3}( [A-Za-z] )+ [A-Z][a-zA-Z] )\n\n3. Write a program to check if a given string has a valid password."
            },
            {
                "text": " \\d{1,2}\\s+([a-z]+)\\s+([a-z]+)\\s+([a-z]{2,4})\n\n## Section 3: Use of RegEx with Python "
            }
        ]
    },
    {
        "expression": "^[-+]?(?:\\d+\\.?|\\.\\d)\\d*(?:[Ee][-+]?\\d+)?$",
        "raw_prompt": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating\npoint including in the exponential notation. Doesn't match the empty string.",
        "refined_prompt": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating\r\npoint including in the exponential notation. Doesn't match the empty string.\nMatch examples:\n- \"23\"\n- \"-17.e23\"\n- \"+.199E-19\"\nNon-match examples:\n- \"+.e2\"\n- \"23.17.5\"",
        "matches": [
            "23",
            "-17.e23",
            "+.199E-19",
            "10.",
            "10e10",
            ".26642713102143137365688967113831737504541833692190915849562517816327995085477954323691850e9236633",
            "-522468587367868823397071205956903949609749300561529539411050637217070.973037100898946241629789895786686328783478283686320509779043619399583643585767894302E-540757799870934129679968653442342823996235059099372961943109017344635981153252443",
            ".52332333497266709701503353970089530648484030407259371091675",
            "+02697312309419612043775",
            ".31155240966607792130348975e-25397714687738448160680418813504846749690127315865231134966296946266796989559445824860494769128183264",
            "-31587463390371081736585401192107872300589613485157844991288518433690756533566551883689734115109029343541",
            "5010704367465090358536489777377397907224499216196.803064965116337857600",
            "-3830549920235063882111235443023540000.7687114801433769361e-95"
        ],
        "non_matches": [
            "+.e2",
            "23.17.5",
            "10e2.0",
            "22e",
            "fdsa",
            "#3",
            "56%",
            "12/12",
            "2332ewds.",
            ".../efdzsd",
            "fer23refd",
            "r0wrfk"
        ],
        "id": 2116,
        "output": [
            {
                "text": " \r\n[-+]?(\\d+(\\.\\d*)?|\\.\\d+)e[+"
            },
            {
                "text": " r'^(?:(?:[+-]?\\d+(?:\\.\\d+)?|"
            },
            {
                "text": " (\\d+\\.\\d+)e(\\+|-|\\*|\\/)\\d+\n\nA"
            },
            {
                "text": " ^[\\+\\-0-9.eE]*$\n- What is the regular expression to match"
            },
            {
                "text": " ^[+-]?\\d+(?:\\.\\d+)?e?$\nThe ^ and"
            },
            {
                "text": " (?<!eE)0?[1-9]?\\d*(?:\\.0"
            },
            {
                "text": " [^0-9.]+\nExplanation:\nMatch a string consisting of characters with a nonzero"
            },
            {
                "text": " \"\\\\d+\\\\-?\\\\d*\\\\.\\\\d+e\\\\d+\"\n\"\"\"\n"
            },
            {
                "text": " \r\n^(?:[-+]?(\\d+(?:\\.\\d*)?|\\.\\"
            },
            {
                "text": " ^[-+]?[0-9]*\\.?[0-9]*e[-+]"
            }
        ]
    },
    {
        "expression": "(((s*)(ftp)(s*)|(http)(s*)|mailto|news|file|webcal):(\\S*))|((www.)(\\S*))",
        "raw_prompt": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix.",
        "refined_prompt": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"",
        "matches": [
            "ftp://domain.com",
            "sftp://subdomain.domain.com",
            "mailto:yourname@rommel.com",
            "www.domain.be",
            "wwwjng{+\\m2:$aV6hF94311e#j%4JvPD6=K/vP4+$(.Tr=*dK+TvSne;OVoS)^DSJ>Pe:s-b<}VH?/Ww)Q(f(\\$fz7J;K4_6NdF",
            "wwwjng{+\\m2:$aV6hF94311e#j%4JvPD6=K/vP4+$(.Tr=*dK+TvSne;OVoS)^DSJ>Pe:s-b<}VH?/Ww)Q(f(\\$fz7J;K4_6NdF",
            "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssftpsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss:HHx,;GtDW>\"qVvd~ylk$$y",
            "mailto:HECEAs^v'qFE",
            "wwwn0SwO4(xoXf=7,$rl8J'[lR[t%c",
            "mailto:C`!@rywnCVn]k\"Jwy_T@-I_F*%?*{buJ*gaHa>+h$kj1s\\G\"xV]N[JyMa9$b:IIi@]`H)P=DA8)?",
            "news:#gSz^XDAkTTV6$]tFf,b+^3]U%mIT-Th]MXr",
            "webcal:ZV@^QH^4Lu7(~sytDy:i1g\"]evqswp.V$m|;$t",
            "mailto:QD(&Je.stxv':E3J~G>VVo>k<?n|3P$`QK"
        ],
        "non_matches": [
            "gopher://anything.com",
            "subdomain.domain.com",
            "http//somethingforgotten.com",
            "fghjk",
            "http",
            "rfvwfdvs///:;",
            "www",
            "website",
            "file.fed",
            "domainname",
            "frevto3",
            "098765"
        ],
        "id": 2117,
        "output": [
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer:\n^http[s]?://(www\\.)"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: gopher://[^/]+@[^/]+"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: http?\\:\\/\\/(www\\.)?(["
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer:\n\nimport re\n\npattern = \"^ftp"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: www\\d+.\\d+|mailto\\s"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer:\n\\A[^\\w \\d\\-/?"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: (\\w+)://[^\\s:]*\n"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer:\n^(?:http(?:/|s)?)"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer:\n[a-zA-Z0-9._"
            },
            {
                "text": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s),..., or just www addresses without protocol prefix.\nMatch examples:\n- \"ftp://domain.com\"\n- \"sftp://subdomain.domain.com\"\n- \"mailto:yourname@rommel.com\"\nNon-match examples:\n- \"gopher://anything.com\"\n- \"subdomain.domain.com\"Generate a RegEx for this description. \nAnswer: gopher|http|mailto\n\n2. Create"
            }
        ]
    },
    {
        "expression": "\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:.\\d{7})?[+|-](0[0-9]|1[0-2]):(00|15|30|45)",
        "raw_prompt": "Complete date-time format according to the ISO 8601 standard.",
        "refined_prompt": "Complete date-time format according to the ISO 8601 standard.\nMatch examples:\n- \"2004-10-31T22:06:00+12:00\"\n- \"2006-04-31T12:31:39.6230000+05:45\"\n- \"2009-01-08T20:25:26-03:00\"\nNon-match examples:\n- \"2009-01-09T12:23:34\"\n- \"2009-01-09 17:45:22\"",
        "matches": [
            "2004-10-31T22:06:00+12:00",
            "2006-04-31T12:31:39.6230000+05:45",
            "2009-01-08T20:25:26-03:00",
            "1548-10-14T20:16:55|01:30",
            "9999-02-31T16:01:24-10:45",
            "6891-11-31T20:08:56|03:00",
            "8706-11-31T19:11:14d4081518+06:45",
            "0126-10-26T22:41:10-9791357+05:30",
            "9866-11-11T20:21:03f4126476|12:30",
            "2193-02-30T12:25:09{6235192-05:00",
            "2857-12-09T23:38:23-09:00",
            "4396-08-31T01:34:46&3017852-10:30",
            "9384-07-31T22:27:34+02:15"
        ],
        "non_matches": [
            "2009-01-09T12:23:34",
            "2009-01-09 17:45:22",
            "2009-05-32T12:67:23-15:00",
            "2009-13-32T25:76:23",
            "098765",
            "TTTuerhlv",
            "9384-7-31T22:27:34+02:15",
            "4396-08-31T:34:46&3017852-10:30",
            "##",
            "8706-11-31T19:11:14d408151.+06:45",
            "%^^^",
            "098765rfgbnjkl"
        ],
        "id": 2118,
        "output": [
            {
                "text": " [\\d"
            },
            {
                "text": "\n\"[0"
            },
            {
                "text": " *(.*"
            },
            {
                "text": "\n- \""
            },
            {
                "text": " ^[0"
            },
            {
                "text": " r\"(?:"
            },
            {
                "text": " \"([0"
            },
            {
                "text": " yyyy"
            },
            {
                "text": " Use a dash"
            },
            {
                "text": " (.*?)"
            }
        ]
    },
    {
        "expression": "^([0-9a-f]{4}\\.[0-9a-f]{4}\\.[0-9a-f]{4})$",
        "raw_prompt": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.",
        "refined_prompt": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS.\nMatch examples:\n- \"001e.1324.683f\"\n- \"1234.abcd.1234\"\n- \"ffff.ffff.ffff\"\nNon-match examples:\n- \"001E.1324.683f\"\n- \"001234.abcd.abcd\"",
        "matches": [
            "001e.1324.683f",
            "1234.abcd.1234",
            "ffff.ffff.ffff",
            "ecb4.b364.1ac0",
            "3116.1302.58af",
            "58dc.329b.6c6e",
            "ce1c.42b8.5ac1",
            "4db3.7965.4d98",
            "3a14.05f0.bc49",
            "af60.695b.1011",
            "ed8b.737c.c603",
            "e070.87df.3b80",
            "8fe3.cb32.d9eb"
        ],
        "non_matches": [
            "001E.1324.683f",
            "001234.abcd.abcd",
            "abcd.1234.abcd.1234",
            "aa-bb-cc-dd-ee-ff",
            "11:22:33:44:55:66",
            "23",
            "213",
            "rgt",
            "/",
            ".",
            "43fredc",
            "&^%$#"
        ],
        "id": 2123,
        "output": [
            {
                "text": " \"^[a-zA-Z0-9.-]{3}[a-zA-Z0-9.-]{"
            },
            {
                "text": " \n^[a-z0-9]+[.][a-z0-9]{3}[.][a-z"
            },
            {
                "text": " \"\\\\b(?=\\\\d{1,3}\\\\.)[a-zA-Z0-9]{0,63"
            },
            {
                "text": "\n\nExercise 5:\nMatch the following IP addresses to their corresponding MAC addresses using the match() method in a Python script.\nMatch examples"
            },
            {
                "text": " \n\"(?<![\\d. ])(?<![\\d]\\.)(?<![\\d])("
            },
            {
                "text": " 01.1324.c.\nThe RegEx should be: 01.1324.\\w{3}\\.(c\\w{2"
            },
            {
                "text": " \"^.*[a-z]{3}[.][a-z]{3}[.][a-z]{3"
            },
            {
                "text": " \"^([a-z]{2}\\.){2}\\d{3}[a-z]$\"\n- \"ffff."
            },
            {
                "text": " \"(.*[a-zA-Z0-9]+)[.](.*[a-zA-Z0-9]+)"
            },
            {
                "text": "\n\n(^[0-9a-fA-F]{4}(\\.)[0-9a-fA-F"
            }
        ]
    },
    {
        "expression": "^[^\\*]{0,}[\\*]{0,1}[^\\*]{0,}$",
        "raw_prompt": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.",
        "refined_prompt": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string.\nMatch examples:\n- \"search*\"\n- \"*search\"\n- \"se*rch\"\nNon-match examples:\n- \"search**\"\n- \"**search\"",
        "matches": [
            "search*",
            "*search",
            "se*rch",
            "search",
            "*",
            "4b+S]11PjT@0!Be#ODsdoawua6JcFmJ9",
            "Y<+y[16u@By.H>zM]|A0$d$0jba=T5X%XGVv/ 8Pr$8W;]yE<6\"UJg)0d)^)H~plt[f%6Q0KT[s\\!V4+?tVo",
            "=q[Moj908KzE#0~/\\8K0$n.YO@Thrp8-ms@>EB;roO|p!.VGdhmb%pXIZ#01QE!8-KxGeQqB*pb$3vi/by7~~zg.$KG3E14.GBP?kU51%G#N1%!#YF,",
            ">;FHzj_|3f}VC_t.\\lZsA4w^i'oI2)k`DfVoBK`2`!G>YN:F;{)H2m-OeDs}j0r#|;0=5cUshY3[G[x)+`>But*Z%`s-=Ya<OGkk+co4@Z9z60",
            "%N/l5QgsUjE|x( z9k!7Ofaud8+,^mU^Fp)\\QcRpF9:q R62I'wdN>leqR.nQ;$aF|\\w.6f\\xRXHtH1:wo,.CXL",
            "m7KQj'L/23Z?FsK8)~a[}\"qP(Q#`hW~y><C'|i/:G/RQz[B)w|Qf3-hJo;OX<or|6`[(on3yovpEouB$_]K|cT}h$fSFP<).53(=n-%:>m9&jicqp;x/\"z[mhu![Z#?w~,}FU$s@Ra",
            "gT@FMg[UgLg!b%qK?N3$8$k$.4[x(D~q#d`@6(<tvj0D@A`hO?cq\"^#2|mT{`$3D~$h_O\\3HC^cgKw_e|%j=wH$rb+hiR21\"]p~][:nx$I3$9f3LfVHUnBL0TX|\\\"P4,C0EKh?iZ}>C>owE)WB8^RsswG[rt:C~pF6:_y(r=GJdcR",
            "B6Lw{H2.24SAuRoriOdN.J\"Jkx iujzV5X+8v4h0_<mS{XP8xzId yA68bt.,yk&5xD\"uDb"
        ],
        "non_matches": [
            "search**",
            "**search",
            "**",
            "s**rch",
            "s*a*ch",
            "**FREDSVX",
            "**32rwfs**",
            "* vd*",
            "********",
            "********",
            "*734as*",
            "*****8uerfb"
        ],
        "id": 2130,
        "output": [
            {
                "text": "\n    import re\n    def wildcard(s):\n        return \"[A-Za-z0-9]+\"\n    def normal(s):\n        return \"[A-Za-z0-9._%"
            },
            {
                "text": "^(?=.*test)(?=.*\\*)(?=.*\\s)(?=.*\\*)(?=.*\\S)(?=.*\\*.*)\\*\\w*(?=\\S$)("
            },
            {
                "text": " ^(.{0,256})(\\\\*)|(\\\\*)(.{0,256})$\n\nA:\n\nI think you're not quite capturing what you intended.\n(.*?)(?=.*search"
            },
            {
                "text": " '^search[a-zA-Z]*|[a-zA-Z]*$' for example. The first example allows only one asterisk, while the second one allows zero or more asterisks.\n\n"
            },
            {
                "text": "\n\n```python\nimport re\n\nexpr = r\"^(?=.*search)(?=.*.*)*$\"\n\nprint(re.fullmatch(expr, '*search')) # Output: <re"
            },
            {
                "text": " \"^.*(?:\\*|\\s)?$\"\n\n5. Write a RegEx to validate the following: a password containing at least one uppercase letter, one lowercase letter, one digit, and one special character"
            },
            {
                "text": " \nre.compile(r'^(?P<word1>.*)(?P<word2>.*)$')\n\ndef isMatch(text, word):\n    return bool(re.search(r"
            },
            {
                "text": " ^(?:(search){0,1})?(.*)$\n\nA:\n\n[a-zA-Z_]*[a-zA-Z0-9_]*$\n\nI suppose"
            },
            {
                "text": " '.*search[^aeiou].*'\n\nExercise 3: \nWrite a RegEx that matches all numbers greater than or equal to 10.\nAnswer: '\\d*[1-9][0-9"
            },
            {
                "text": " (\\w+)\n\nA:\n\nThe string search* will match any number of alphanumeric characters (\\w) zero or more times:\n\"HelloSearch* World\"  \n\nThe string *search will match any"
            }
        ]
    },
    {
        "expression": "(?!^0*$)(?!^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "raw_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it",
        "refined_prompt": "To validate a number of 10 digits before the decimal point and atmost 2 digits after it\nMatch examples:\n- \"12314\"\n- \"12314.2\"\n- \"12314.32\"\nNon-match examples:\n- \"12314.212\"\n- \"12123.222\"",
        "matches": [
            "12314",
            "12314.2",
            "12314.32",
            "339655967.2",
            "9656.63",
            "1847297471.28",
            "324913.47",
            "7459.86",
            "74",
            "215392162.63",
            "58365927.3",
            "10780883",
            "5766980587.1"
        ],
        "non_matches": [
            "12314.212",
            "12123.222",
            "%recd",
            "237834889ber",
            "000",
            "123efcd",
            ".0",
            "8.",
            "876trfvbnmkoiuytfv",
            "jehrdsc!!!@",
            "<>",
            "(vev)"
        ],
        "id": 2136,
        "output": [
            {
                "text": "\n\n$(document).ready(function(){\n    var input = $('input.input_field').val().replace(/^(0+)?[^0-9]*(\\d[0-9]*)?"
            },
            {
                "text": " \n^[0-9]{10}(\\.[0-9]{1})?$\n\nA:\n\nTry this:\n/^\\d{1,10}(\\.\\d{1,2"
            },
            {
                "text": " (.*\\.){1,2}.*(.{0,9}$) \n\n### Exercise 2: \nGenerate a RegEx to match a valid IP address (4 decimal numbers representing 4 networks separated by dots"
            },
            {
                "text": " \\b\\d{2,10}\\.[\\d]{0,2}\\b\n\nExercise 2:\nWrite a RegEx to match all the email addresses in the following text:\n'''\nEmail 1: john"
            },
            {
                "text": " ^[0-9]{1,3}(\\.\\d{0,2})?$\n\n2. Given a phone number number, write a RegEx pattern to extract the first three digits after the area code.\n"
            },
            {
                "text": "\n^\\d{1,10}\\.\\d{0,2}$\n\nExercise 2: Use the Regex provided and the example of $text = \"1.2.3.4\"\nMatch:\n"
            },
            {
                "text": " \\d{10,2}\\.\\d{2}\n\n#### Exercise 3\n\nWrite a Python function that receives a string and replaces all words that start with a vowel with a suffix \"v\"\n\n```python\n"
            },
            {
                "text": " \\d{10}(\\.\\d{2})?\n\n3. Write a RegEx to validate that a string contains only numbers, a comma, or a space.\n\n4. Write a RegEx to validate a string"
            },
            {
                "text": " [^0-9.][0-9]{1,2}[^0-9.][^0-9.][^0-9.][^0-9.][^0-9.]\n\n``"
            },
            {
                "text": " (\\d{3})(\\.\\d{1,2})?\nExplanation:\n\n(\\d{3}) -> three digits\n(\\.\\d{1,2}) -> one or two decimal digits\n\n"
            }
        ]
    },
    {
        "expression": "^\\d*[0-9](|.\\d*[0-9]|)*$",
        "raw_prompt": "Decimal like 123.23\n123.1234\n12345.456",
        "refined_prompt": "Matches numbers and they can have values after a decimal point\nMatch examples:\n- \"123.23\"\n- \"123.1234\"\n- \"1234\"\nNon-match examples:\n- \"123a.12\"\n- \"123.34d\"",
        "matches": [
            "123.23",
            "123.1234",
            "1234",
            "1234.456",
            "1243.324455",
            "34242",
            "34253422.4231",
            "834884.23334434334",
            "1230948.23343",
            "1",
            "43932.3223",
            "222222.222",
            "234321.4354342345"
        ],
        "non_matches": [
            "123a.12",
            "123.34d",
            "abc",
            "-1",
            "+1",
            ".0",
            "number",
            "098765467898765r",
            "....34532..43",
            "433.43/",
            "000-.00000",
            "#11.2"
        ],
        "id": 2143,
        "output": [
            {
                "text": " \"^[0-9]+\\.[0-9]{0,2}$\"\n\nExercise 3: Create a Pattern that will match any string that contains a word that starts with \"a\" or \"A\".\nAnswer: ^[aA]."
            },
            {
                "text": " \"^[a-zA-Z0-9]+$\"\n\nExercise #3:\nWhat is a special character used for RegEx that tells the engine to treat a character as part of the set of characters it should match?\nAnswer: The special"
            },
            {
                "text": "\n\\b\\d+\\.\\d{1,2}(e[\\+-]?\\d+)?\\b\n\n3. Match examples:\n- \"12.34\"\n- \"123.45\"\n- \"12.34e"
            },
            {
                "text": "\n(?!^)(?!\\d+$)\n\nExercise 2:\nFill in the blank using the best RegEx pattern you can:\nRegular expressions are a powerful tool for _ data in a string.\nAnswer:\nvalidating\n\nExercise 3"
            },
            {
                "text": ".{1,3}$\n\n- \"123.12.345\"\n- \"111.22.33.44\"\n- \"111.22.33.4445\"\n- \"111.22.33.4446\"\n\n3."
            },
            {
                "text": " You will need to use the following RegEx:\n\\d{1,3}(?:\\.\\d{3})?\nExample: \"1.234\"\n\n\n\nTitle: The Impact of Daily Events on Identity and Self-esteem\n\nIntroduction"
            },
            {
                "text": " Lookahead / (?=.*\\d.\\d)\n- \"123.34\"Generate a RegEx for this description. \nAnswer: Lookbehind / (?<=\\d)\\.(?!\\d)\n\n3. Lookahead / Positive"
            },
            {
                "text": " The pattern should be [0-9]+(\\.[0-9]+)?\n\nExercise 2: Match words that start with an uppercase letter\nMatch examples:\n- \"Apple\"\n- \"Dog\"\n- \"Ant\"\nNon-match"
            },
            {
                "text": " ^[0-9]+(\\.[0-9]+)[a-z]*$ \n\n**Exercise 2:**\nGiven the following text, extract the email addresses.\nExample: \n\"John Doe<john@email.com>,"
            },
            {
                "text": " ([a-zA-z0-9]+)\\.?[a-zA-z]\n\n\n\nQuestion 3: \nA rectangle has a length of 12 cm and a width of 8 cm. What is the area and perimeter of the rectangle?"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9]+(([_][a-zA-Z0-9])?[a-zA-Z0-9]*)*$",
        "raw_prompt": "This Regular Expression. I have used with ASP.NET Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]",
        "refined_prompt": "Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]\nMatch examples:\n- \"Employee\"\n- \"Employee_Test\"\n- \"Employee_Dept\"\nNon-match examples:\n- \"Employee.Test\"\n- \"Employee$Test\"",
        "matches": [
            "Employee",
            "Employee_Test",
            "Employee_Dept",
            "imMnMkYWqNYteAX3jcMVS9c1wehWWDCKK4XIUBWQRIjGV5jymN5Fy3SuD4cTFTr7CcRFRpYFYqQI8cOkazKeGReMGv9zUIy84mXfbi8jgopUgVD3dafFK5kNNKrdu6AizClSFrtjtdG78YwJan9ncHylM7a2drv5MBjAeNkUdaRDZcs0zpybZf2HGPXYYBzaP6HvrKlzPCtTgCdzg3cxIwIoYvoAALlc3rVc9yOXWAToXEt9Tk6KJnkDtRNa3XACaVl6rtoPp6VDGCVK7Lptn88ROedDoANkKeZbLWREvURD2dRHwyiJe62kBTbUFRrsWOCYMsV53QCE4abpBORamW_vv1YUHXV0XL28Te_de48d3N6KjwpoH5w6WnqFcw9hmuvkp5MeeayVVhtyvXXJvn7KUjao37wPq3VBpTcEUlabfNZbcPj9ywLxR4Koo8mXxbT8nQSxsFOleyUaRVHy2NR3gC489D6rRfrgTHLRvuOgwWqTa3_66uZcVwT0WE0kg6txbh7119bjLoK75GV8LqexHLMMTFrNWEA1KtibyDGZ1RlfBhT7L9hnkuGwgdL_0Hf3e9xq3IKc2",
            "erfdsaqw",
            "23456",
            "gtrewc",
            "UYTRFVB",
            "J6efgr8",
            "JERFKJERKJ",
            "jfeov",
            "rfuu",
            "12324refdg"
        ],
        "non_matches": [
            "Employee.Test",
            "Employee$Test",
            "Employee@Test",
            ".com",
            "#4",
            "O'Connor",
            "hello!",
            "$money",
            "-+",
            "&and",
            "%%%",
            "/?"
        ],
        "id": 2145,
        "output": [
            {
                "text": "\n^[a-zA-Z][a-zA-Z0-9._-]+[a-zA-Z]$\n\n2. Write a Python program that prompts"
            },
            {
                "text": " [Ex:] [Ex:] [Ex:]\n\nA:\n\nRegex for not having special characters.\n[^$_#@]\n\nRegex for not having"
            },
            {
                "text": " [a-zA-Z0-9][a-zA-Z0-9._-]+\n\nExercise 5: Write a regular expression to verify that input string should either end"
            },
            {
                "text": " (Employee\\..*).*$\n\nExercise 2: \nGiven a string $s, what is the longest consecutive substring of s that contains only lower-case English letters?"
            },
            {
                "text": " The regex should validate the string and return false if the string contains special characters, and should return true if the string passes all the validation rules.\n\n```python\nfrom django.core."
            },
            {
                "text": " \n\nEmployee\\Z|[A-Za-z_.-]+\n\nExercise 2:\nWhat is the meaning of.NET Regex delimiters? Explain their importance"
            },
            {
                "text": "\n^[a-zA-Z0-9_.]*$\n\n2. Write a regular expression for validating that an email address is in the correct format.\n\nAnswer:"
            },
            {
                "text": "\n^[a-zA-Z0-9._-]+$\n\n\n\nLadies and gentlemen, today I stand before you to discuss a topic that is both fascinating and essential to"
            },
            {
                "text": "\n(Employee|Employee\\.)?Test\n\nExercise 4:\nHow would you use the.NET Regex.IsMatch() method to validate a string against a pattern?\n"
            },
            {
                "text": "\n\\b(Employee_[a-zA-Z0-9_]*)\\b\n\nExercise 3:\nCreate a custom RegEx pattern to validate a file extension ("
            }
        ]
    },
    {
        "expression": "^(http\\://){1}(((www\\.){1}([a-zA-Z0-9\\-]*\\.){1,}){1}|([a-zA-Z0-9\\-]*\\.){1,10}){1}([a-zA-Z]{2,6}\\.){1}([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*",
        "raw_prompt": "This checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check. Replace http by (http|https|ftp) for other protocols. Still not happy about this: http://www.www.passshouldfail.com",
        "refined_prompt": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN9-cVCTS5v-qlrCKlMOw72dvN22tFoQgPY.pH.So%sh,%?Pti6eF~$~O~HH#+6C0Xn.JbZ\\Y$\\\\l8nR,61gbhHAGNCTP.L0h5gqKMoqPEv%_75,%\"\n- \"http://3UWfs9mB1D3Ciwg1cLlUmjmQ4DELt1gXBkkc8w4GdJ2P0txeJg-Nu022UVUAFZeosrJ74LoqyHG5y8cgaJHyk98XYAI.KHaOWshJITNckgemqvfGMci7llelRMEkDDfC1jWjzVGdd2yWdDyuI3Xk9Z-2MpgbssxQkttyQSzXLtVy3Ug-NnAWEAXX0iQB3v.2sPsignuFg524sJWDYFhpP90UsgPiN31AJOMDrvjuk7gCHqzfgiA6a5QxTDGlbPf3jkd9uGbUTCVoceWEP2ZzeDShsKE9.gS.T%Qvd#Cvu=/0gL0QkW_PBB~gEoV\\0K,de$do9q%Cf#2T-c=XS-~wsz;y,i%ze4vw81?3%1FoO8E$\"\nNon-match examples:\n- \"fail.com\"\n- \"www.fail.com\"",
        "matches": [
            "http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com",
            "http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN9-cVCTS5v-qlrCKlMOw72dvN22tFoQgPY.pH.So%sh,%?Pti6eF~$~O~HH#+6C0Xn.JbZ\\Y$\\\\l8nR,61gbhHAGNCTP.L0h5gqKMoqPEv%_75,%",
            "http://3UWfs9mB1D3Ciwg1cLlUmjmQ4DELt1gXBkkc8w4GdJ2P0txeJg-Nu022UVUAFZeosrJ74LoqyHG5y8cgaJHyk98XYAI.KHaOWshJITNckgemqvfGMci7llelRMEkDDfC1jWjzVGdd2yWdDyuI3Xk9Z-2MpgbssxQkttyQSzXLtVy3Ug-NnAWEAXX0iQB3v.2sPsignuFg524sJWDYFhpP90UsgPiN31AJOMDrvjuk7gCHqzfgiA6a5QxTDGlbPf3jkd9uGbUTCVoceWEP2ZzeDShsKE9.gS.T%Qvd#Cvu=/0gL0QkW_PBB~gEoV\\0K,de$do9q%Cf#2T-c=XS-~wsz;y,i%ze4vw81?3%1FoO8E$",
            "http://Fb01D1igrD0vQvV41e0jnJW3R6BIIvKtlyAPgloZ-yNOr3bjnV8RNOvSw5TuO2QIEr4BD5IBe8Y.bjWDE8xoqgkTa3y8zQDBlKeFKDqc6YAkIanfQSiueP7SSC4IF5cOtZ3Bi01n3Fka.lKPkHF.5WUVdDYkz&mhzSD.~+XCqiO~nASOfMSx72195a8By-j?ic3Y4JexB3;zVot_hxl?7Ox,tA\\T#dGK+6yg1ys6",
            "http://fHxao.5wdwGtG.jzdr./JkwCqE;B#BXvZ",
            "http://Ca.5Cj.xC0e9OJ0Io4w.i0d1u7joKMlrUdG7rTQnetfmB9jVrk-VIAENSELu.du.xQl1P.vZ?bMmBITIR",
            "http://pZCKyXBPQ-2QjsJF5jhfA56XVJptcQIMy6hlxZOVESATWRt-wvuopKSQcEZjWKJ4AZbVuL..bUUVVEs-vQXxm05VyLzKhP2L4N8u.m0py9e2adsUfOivV1U9uSRpszsHm2nfcX11ZUq9za1cYTz56znzO1ZLO7stK4g6Cxo4J7jKrzOFtzyBTrY7SB9IeSXUd.gZDGh.kVvK3G526r1.tSsfurTqXqQIy5InocIvbfcapgKqLvPJeTn3Zg0ihrcfsmRcUJpN-4tLCDzSuUBhXoBIdoL9YRPzFHvpE.bAo8CuvofEYpe9uBOIhzpXgSr2pYe8QpAy18CaYYpe.toO.oeqTM4A806zm;H0RAAdZD%S;~o2N?axJV6OBr6OgH-5F\\OqE-'4Wv",
            "http://LXQT7536wecB4rVAbo7eu45pXqnaXbFfvfcCtyBpkXQ1Ab6VSVmYkV2A4jjXLCv.6VMzhUdxa0nC8rMj52oFn1R-WMNlGdxJ6Q133C3jwR4Hrwukkjex7yBk9JALwJ54vfdpyy70q-ZyPxfWi2.UY.d'I/cD",
            "http://pVArk1aK-WvidTrWBJ2QBSsYCRaAgAOalxmwPp1LFx1NOjhA6xuunJ4lqXXrh3GN9ngPuTW810jTKz8VIC.la.,YC2Z&id,Ho4vV7f+vEFDKUfc;zZ?vh/T$MJ#PYgQ30SVO~~&/_dCDBLFFx\\$HlJaZceD,r~xzb",
            "http://www.4Gt455zk6wcyUndUZeylnBFCYnmnCS8XwylCvx-g4vHSH9BkX0--PpKtVJWBgV6a2W3.qjr2ZzkyTuodWhHPCIg5CfHOYYgB.Gpk3CeIBP6pHhNLlEVHXG.bmXw6FDpkmahRSzAUfR6UHl3APpYRxkIlfqhlV9ecJ-AmMnm2dgE4zT.ihwrJm.dTT=A;Uuy59gk'ox",
            "http://www.GHhmgy5tTVwT6zJ3sm25ioKusMb1-mjJZ-eBEhYmxYhzixg1-JXcZfY4mc04.l-Dvcdd80cun2nuI7qRvpVgV5PRcJv77VjKL0uqjQj1EANxkkMieyhrRbG.UBL.3KCAnx8Ji7OL4646I12+uHlXuwoRB9pZx#-czv,H6;AKbDno.yTpSQM7GFym&?i&8UwNn?g%mjh",
            "http://www.xnMgEcR9a2UJKok7eNntbWsK9vSS1cbunCe1rO2ONIsryfsWV3sxwN.fvNWktN4xBnY0nDPmMahEqt4-VLsJjZ8kOJISj-kWZZX8t5b9WkGAhF556X922o7QrR4.anxA.RApP'~2o;6qO\\-",
            "http://.rMSF.pSQkN.q?,tZX'6;ahY0vQe\\4-icTn4%%YLyAnPSyK.A-_B~8#a&Xcs1&$FJD.\\eYbK.pSA"
        ],
        "non_matches": [
            "fail.com",
            "www.fail.com",
            "www.www.fail.com",
            "http://fail.com",
            "http://http://fail.com",
            "http://http://www.fail.com",
            "sub.fail.com",
            "www.sub.fail.com",
            "sub.sub.fail.com",
            "www.sub.sub.fail.com",
            "www.efds",
            "erfvds"
        ],
        "id": 2149,
        "output": [
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNq"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNl"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNl"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNQ"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNy"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN0"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNn"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNj"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkNl"
            },
            {
                "text": "checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check.\nMatch examples:\n- \"http://www.pass.com http://sub.pass.com http://www.sub.pass.com http://sub.sub.pass.com http://www.sub.sub.pass.com\"\n- \"http://NL4KW9dJFzU4AlKY9rHZXNDnuX5v9mu0HEzDdkN3"
            }
        ]
    },
    {
        "expression": "^Content-Type:\\s*(\\w+)\\s*/?\\s*(\\w*)?\\s*;\\s*((\\w+)?\\s*=\\s*((\".+\")|(\\S+)))?",
        "raw_prompt": "Matches the Content-Type for a MIME Mail Message and a Non-Mime Mail Message",
        "refined_prompt": "\nMatch examples:\n- \"Content-Type: multipart/mixed; boundary=\"---myboundary\"\"\n- \"Content-Type: multipart/mixed;boundary=---myBoundarysi3cds\"\n- \"Content-Type: text/plain;\"\nNon-match examples:\n- \"Content Type: multipart/mixed\"\n- \"Content-Type: text/plain\"",
        "matches": [
            "Content-Type: multipart/mixed; boundary=\"---myboundary\"",
            "Content-Type: multipart/mixed;boundary=---myBoundarysi3cds",
            "Content-Type: text/plain;"
        ],
        "non_matches": [
            "Content Type: multipart/mixed",
            "Content-Type: text/plain",
            "Content-Type image/jpeg;"
        ],
        "id": 2152,
        "output": [
            {
                "text": " (.*)\n\nExercise 4: \nCreate a Python function that takes a string and returns the length of the string"
            },
            {
                "text": " [a-zA-Z=+,;-/]\n\n2. Write a RegEx to match all of the"
            },
            {
                "text": " /Content-Type:\\s*(?:multipart|text|plain); boundary=\\s*(?:[^"
            },
            {
                "text": " [^;]+ or [^\\n]*\n\n3. Write a Python function to generate a RegEx that matches"
            },
            {
                "text": " (content type).*\n\nExercise 2:\nMatch examples:\n- \"$(p)\\n([^\\n"
            },
            {
                "text": " Content-Type=[^\\s]+; boundary=\\b|\\b;\n\n#### Exercise 2: \nGiven"
            },
            {
                "text": " \"\"Content-Type: text/plain; boundary=\"---myBoundarysi3cds\"\n\"\"\"\n\n# Explan"
            },
            {
                "text": " (.*?)\"\n\n```python\nimport re\n\ns = \"Content-Type: multipart/mixed"
            },
            {
                "text": " re.compile(r'Content-Type: multipart/mixed;boundary=\\w+')\n``"
            },
            {
                "text": " Content-Type (?:multipart/mixed; boundary=|text/plain;)\n\n\n\nQuestion 6"
            }
        ]
    },
    {
        "expression": "^((0[123456789]|1[0-2])(0[1-3]|1[0-9]|2[0-9]))|((0[13456789]|1[0-2])(30))|((0[13578]|1[02])(31))$",
        "raw_prompt": "Evaluates a date in the format of MMDD. Will evaluate month day ranges accurately with Feb going up to 29.",
        "refined_prompt": "erfvds\nMatch examples:\n- \"0229\"\n- \"0331\"\n- \"0630\"\nNon-match examples:\n- \"0230\"\n- \"0431\"",
        "matches": [
            "0229",
            "0331",
            "0630",
            "0902",
            "0730",
            "0131",
            "0830",
            "0731",
            "0619",
            "0131",
            "0331",
            "1031",
            "1130"
        ],
        "non_matches": [
            "0230",
            "0431",
            "1245",
            "1299",
            "0011",
            "erfvds",
            "date",
            "2345",
            "5321",
            "9347",
            "7922",
            "8205"
        ],
        "id": 2153,
        "output": [
            {
                "text": " ^\\d{4}-\\d{2}-\\d{2}$\n- \"0302\"Generate a RegEx for this description. \nAnswer: ^\\d{4}-\\d{2}(?:-\\d{2})?$\n- \"0307\"Generate a RegEx"
            },
            {
                "text": " [0]?[1-9][0-9]|10[0-2] \\d\\d\n\n2. Given a list of numbers, create a regex that matches any numbers greater than or equal to 100 and less than or equal to 999.\n- [1, 2, 3, 4, 5, 6,..."
            },
            {
                "text": "\n\\b(?:[0-9]{4})(?:0(\\d{3})?)?\\b\n\nExercise 2:\nCreate a list of 10 match examples for a given string, and list 5 non-match examples using the same string.\n\nSolution:\nstring = \"02021230000\"\nmatch"
            },
            {
                "text": " ^0(2[0-9][0-9])[0-9]$\n\nExercise 4:\nDefine a pattern to match the following regular expression:\n- The number 1.5 is a decimal number.\nGenerate a RegEx for this description.\nAnswer: ^[1-9][0-9"
            },
            {
                "text": " [^\\d]\\d[^\\d]\\d\\d\n- \"0230\" does not contain any digits. \n- \"0431\" does contain a digit at the beginning.\n\n\n\nI am going to tell you a story about a boy named Jack, who wanted to become a police officer when he grew"
            },
            {
                "text": " \"0?[1-9]?[0-9]?[0-9]?\"\n\nExercise 3: \nReplace all instances of \"\\d+\" with a placeholder that can contain a number of any length, like \"1,5,2\" or \"12,34,56,78\". \nAnswer"
            },
            {
                "text": " \n[0-9][0-9][1-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]\n\nExercise 2:\n- \"0229\"\n- \"0331\"\n- \"0630\""
            },
            {
                "text": " \n```python\nimport re\n\npattern = r'^[12]\\d{3}-\\d{2}-\\d{4}$'\nemail = 'john@example.com'\nmatch = re.search(pattern, email)\n\nif match:\n    print(f'The email"
            },
            {
                "text": "\n\n```python\nimport re\n\npattern = r'[a-zA-Z0-9]{3}/[0-9]{4}$'\nmatch = re.match(pattern, \"0229\")\nprint(match) #None\n\nmatch = re.match(pattern, \"0"
            },
            {
                "text": " ^[0-9]{2}[0-9]{2}[0-9]{2}$\n\nExercise 3: Using RegEx to Find a Pattern in a String\nExercise: You have a string that contains a phone number in the format \"(XXX) XXX-XXXX\". Use RegEx to find the"
            }
        ]
    },
    {
        "expression": "//.*|/\\*[\\s\\S]*?\\*/",
        "raw_prompt": "Matches single line or multi-line comments.",
        "refined_prompt": "Matches single line or multi-line comments.\nMatch examples:\n- \"// Comment here\"\n- \"/// Comment here\"\n- \"/* Cmment Here */\"\nNon-match examples:\n- \"/ * Comment Here */\"\n- \"/* Comment here * /\"",
        "matches": [
            "// Comment here",
            "/// Comment here",
            "/* Cmment Here */",
            "/**** Comment Here ****/",
            "//C5:%0NTao6jqq/5tdt#8!m/oLs< OJ|}~`XF`gUe1{InR%{7~()iE_?mmXrsit}_~CgZ~Ah,K~h,Cd",
            "//yIT_5t?'RaziV;TMVyOR\"2wnzh5=+;P_E-Fh*ay+~GpSG<",
            "/**/",
            "//P$Zge.ILHfPy7]y#]n}A#Dl8W~h<!dXZ*p;",
            "/*i\u2002\u20062\u202fH\u2028N`!Z&.H|%JOk\u200a:\u3000\f,V\u2009w\t\u2001[BQX*/",
            "//Zta'vB:8m}Nj;=1x+]-/k-q2J5[<,.6)E\"`-;m~]3xJx7}dUj3Fd~KF@ OOM5L|_'ME.s\\e$G1']%BR{Y+uai7Ss0Tpx!wv9P{",
            "/*x;XxOj]ez,[Lx,)fqjc\u202f]EXF8AAYlBRuR5*BKC(^\u2002s\ufeffS\tq*Ygq\"9\\\u2005xwkZ\u2002Bkn\u2003dl`\u2003n+|B?{f\u2005@\u1680#*/",
            "/*?N'\u2004Og\u2008B*Ry* zL\u2008\u2008 ccUd;#ixk\u2006\u1680aT\"*/",
            "//%#I?<=.^^x&_ONV=uf]1RaYkM]ikLI3[Jp=[;o1=>eKN~FW2(;cgzfEqDSV}ASFJhz:g$q2"
        ],
        "non_matches": [
            "/ * Comment Here */",
            "/* Comment here * /",
            "98765rfg",
            "#fvf",
            "\\\\rve",
            "**vreer",
            "|| efdswc",
            "string",
            "\\frrtte",
            "2345r",
            "'rejrjn",
            "-erfjkjkn"
        ],
        "id": 2155,
        "output": [
            {
                "text": " [^/\\\\s]*\n\n5. Exercise: Write a function that takes a string as input and returns the longest word in the input string.\n\nCode:\ndef longest_word(string):\n    words = string.split()\n    "
            },
            {
                "text": "  [^\\/\\\\]*+|\\/*[^\\/\\n]+\n\nExercise 3: Write a RegEx pattern to match all valid email addresses.\nAnswer:  [a-zA-Z0-9._-]+@["
            },
            {
                "text": " /(^/*)(.*?)\\*/\n\n\n\nTitle: Exploring Modern Technology and Inventions: A Comprehensive Overview\n\nIntroduction:\nScience has propelled human civilization forward with remarkable innovations and inventions. The field of modern technology has revolutionized various aspects of"
            },
            {
                "text": " /\\*[^\\*]*\\*\\s*/\n\nExercise 2:\nMatch a word that starts with a capital letter and is followed by two digits.\nAnswer: A word that starts with a capital letter and is followed by two digits"
            },
            {
                "text": " \\s*//.*\\n\n\nExercise 2:\nCreate a list of words that contain the letter 'e'.\n```python\nwords = [\"elephant\", \"emu\", \"giraffe\", \"giant\", \"hippopot"
            },
            {
                "text": "\n(?<comment>\\s*(?://|\\*/))+\\s*\n\nExercise 5:\nWrite a Python program that matches a string that has either a single or multiple occurrences of a given word.\nQuestion:\nWrite a"
            },
            {
                "text": "\n- /\\* (.*?) \\*/\n- /\\* (.*?) \\*/g\n\nExercise 3:\nWrite a Python program that compiles the above RegEx into a single RegEx object.\n\nQuestion:\nHow can I"
            },
            {
                "text": " (Regex) /\\/\\*(.*)\\*/$\n\n3. Create a list of ten words. Use the re.split function to split the words into a list. Use the join function to join the words into a sentence.\nAnswer:\n"
            },
            {
                "text": " /(.*?)\\/(.*?)(.|$)/\nExercise 3: \nSuppose you are to write a regex for a password that has at least 8 characters, contains at least one uppercase letter, one lowercase letter, one digit"
            },
            {
                "text": " /(?<begin>/\\*)(?<middle>.*?)(?<end>/\\*)/g;\n\nExercise 3:\nMatch all backslash-escaped double quotes inside a larger string to prevent double-escaping"
            }
        ]
    },
    {
        "expression": "^(b|B)(f|F)(p|P)(o|O)(\\s*||\\s*C(/|)O\\s*)[0-9]{1,4}",
        "raw_prompt": "Matches BFPO\nAllows for BFPO with no spacing",
        "refined_prompt": "Matches BFPO (can have no spacing)\nMatch examples:\n- \"BFPO 2\"\n- \"BFPO 2222\"\n- \"BFPO C/O 121\"\nNon-match examples:\n- \"bf po 1212, BFPO 22222\"\n- \"BF\"",
        "matches": [
            "BFPO 2",
            "BFPO 2222",
            "BFPO C/O 121",
            "BFPO2222",
            "BFPO664",
            "bFpo948",
            "bfPO19",
            "Bfpo05",
            "Bfpo5944",
            "bfpO7317",
            "BFPo8401",
            "BfPo45",
            "BFpO2556"
        ],
        "non_matches": [
            "bf po 1212, BFPO 22222",
            "BF",
            "bf",
            "Bf Po45",
            "BFp O2 556",
            "B fpo5944",
            "b",
            "##",
            "\ufeff1681",
            "BF PO C/O 121",
            "!!!",
            "0.0"
        ],
        "id": 2157,
        "output": [
            {
                "text": " \n(BFPO [a-zA-Z]+ [0-9]+)\n\nExercise 3: Write a Python function that takes a list of strings as input and returns a list of integers using regular expressions"
            },
            {
                "text": "\n^(BFPO 2)|(BFPO 2222)|(BFPO C/O 121)$\n\nExercise 5:\nGive examples of three different ways of using RegEx in web scraping.\n"
            },
            {
                "text": " https://regex101.com/r/F7YpP6/1\n\nExercise 2: Match all \"BFPO N\"\nCreate a RegEx to match all \"BFPO N\" that"
            },
            {
                "text": "\n\\b[A-Za-z]{2}\\s+[A-Z]{2}\\d{3}\\b \n\nUse Case 3: Developing a Language Learning App\n\nIn this use"
            },
            {
                "text": " \n\\bBFPO (\\D+)\\d{1,2}\\b\n\nExercise 4:\nMatch this description:\n- A chemical compound that contains hydrogen and carbon, and is used in the production"
            },
            {
                "text": "\n\\d{1,3}[\\,./]?\\d{1,3}\n\nExercise 3:\nGenerate a RegEx for the word \"can\" that matches one or more characters that are"
            },
            {
                "text": " \\b(bf p)(o)o\\b\n\nExercise 4:\nRewrite the following sentence using a regular expression: \"The quick brown fox jumps over the lazy dog.\"\nAnswer: \\b(The)("
            },
            {
                "text": " [^\\\\d/\\\\,\\\\s]\nExercise 1: How can regular expressions be applied in Python?\nAnswer: Regular expressions can be applied in Python using the `re` module.\n\nExercise 2:"
            },
            {
                "text": " \n^BFPO (\\d+) \\w*$\n\nExercise 2: \nYou have a list of strings that looks something like this:\ndata = [\"BFPO1\", \"BFPO"
            },
            {
                "text": "\n^BFPO.*(?: /\\d+)?$\n\nExercise 3:\nMatch examples:\n- \"BF\"Generate a RegEx for this description. \nAnswer:\n^BF.*("
            }
        ]
    },
    {
        "expression": "(?=^[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]{7,}$)(?=([!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*\\W+){1,})[!@#$%\\^&*()_\\-+=\\[{\\]};:<>|\\./?a-zA-Z\\d]*$",
        "raw_prompt": "Regex to validate strong password for .NET MembershipProvider ValidatePassword. Regex checks for minimum required password length and for minimum required non-alphanumeric characters. Change value '7' according to MinRequiredPasswordLength and '1' to MinRequiredNonAlphanumericCharacters.",
        "refined_prompt": "Regex to validate strong passwords with a length of at least 7 and contains one non-alphanumeric character.\nMatch examples:\n- \"12345!r@r\"\n- \"#dfgjaydh%\"\n- \"aA1!@#$%\"\nNon-match examples:\n- \"12345rfg\"\n- \"hsjahdgs\"",
        "matches": [
            "12345!r@r",
            "#dfgjaydh%",
            "aA1!@#$%",
            "11111#aZ",
            "2^z6@.VqJXCOFq/Uo[SQKh6Mj$.&!}ILi(rVc^Ou(WEEga_pW5J*GEm:lQOF;^<pM",
            "u;BR<$MCQ)Ux/9g(Np!A!hBYe&7g)v{!cvM4mb&(f1gR^OryguwZ/#6",
            "A3|Otes4D;FgH@;+349<^JvGjyv^hIQhM!Wz@guoN:f$bdoYEkf:*CkK-HWTxZ^{#=MU3j)A!W}HMHByHGEq;KY@TyR|hY!n{Mq",
            "i}0R/{jy*KH<d]u5T>@(Fpo!^/Gc|pLTEXU4*i_T9Hh_y%vx[X_^e#cW*[Qb*M{3v8GT}X@F)Q1pt7g&C",
            "=E%?X?:&906mF!%Ye1L4IeKR^<6nHmBB-E*(PW;ZjX$h50M/kcYD-?MF;",
            ">D}9dIYi}R*SFOE^U}#$+7<4I*tz$^^7|x%VRjB}@cjDDNf_@fJE}Ft(&H",
            "l]PT65IK@v3I5!Lo1a2>gT)66oC9%?.s^_rO_#P]29jFwn)2Y8%=X0]yF:Y6Pc={h",
            "nmki=vg>Qjno:}E(+<3BR5HNocpTp9]tK#L<7r1/-lZ",
            "zoH0(<jBz$*SG6<LpgV"
        ],
        "non_matches": [
            "12345rfg",
            "hsjahdgs",
            "12345",
            "BF PO C/O 121",
            "efw",
            "efween",
            "lkjytrdcvbiu76",
            "3refcds",
            "AJJJJKJHGFVBN",
            "ewrjTYEJWKL",
            "jk2rjk2efrjkn",
            "KIDJK;"
        ],
        "id": 2160,
        "output": [
            {
                "text": "\n^(?=.{7,})(?!.*[a-z])[a-zA-Z0-9!@#$%^&*()-]+"
            },
            {
                "text": " ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()"
            },
            {
                "text": " ^[a-zA-Z0-9!@#%&\\?*\\(\\)\\[\\]\\{\\}]{7,}$\n\nExercise 5"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*\\W)(?=.*[!@"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%?&])["
            },
            {
                "text": "\nimport re\n\n# Define regex pattern to validate strong passwords\npattern = re.compile(r'^(?=.*[a-z])(?=.*"
            },
            {
                "text": " \\w+((?:\\w+[^\\w\\s]){0,6}\\w+)\n\n\n\nI'm so excited that you want to learn about the topic"
            },
            {
                "text": " ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@_!#$%^&+="
            },
            {
                "text": " ^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{7,}$\n\n3. Create a RegEx"
            }
        ]
    },
    {
        "expression": "^(([0-1]?[0-9])|([2][0-3])):([0-5][0-9])$",
        "raw_prompt": "Matches a string if it is a valid time in the format of HH:MM",
        "refined_prompt": "Matches a string if it is a valid time in the format of HH:MM\nMatch examples:\n- \"02:04\"\n- \"16:56\"\n- \"23:59\"\nNon-match examples:\n- \"02:00 PM\"\n- \"PM2:00\"",
        "matches": [
            "02:04",
            "16:56",
            "23:59",
            "1:01",
            "21:06",
            "22:59",
            "21:07",
            "07:48",
            "21:58",
            "21:15",
            "3:06",
            "5:29",
            "23:21"
        ],
        "non_matches": [
            "02:00 PM",
            "PM2:00",
            "24:00",
            "date",
            "time",
            "1/12",
            "january",
            "02:00 AM",
            "12-12",
            "98765",
            "73:23",
            "234:433"
        ],
        "id": 2161,
        "output": [
            {
                "text": " ^([0-9]{1,2}:[0-9]{2})([a-z]{1,2})$\n\nExercise 2: Extract all email addresses from a list of strings.\nAnswer: Use"
            },
            {
                "text": "\n\"(00|1[0-2]|[2-9])[0-9]:[0-5][0-9]\"\n\n3. Write a RegEx that matches a valid email address \nMatch examples:\n-"
            },
            {
                "text": " \n^[0-2]\\d:[0-5]\\d$|[2]\\d:[0-5]\\d:?[0-5]\\d?$\n\n\n\nfrom typing import List\n"
            },
            {
                "text": " \\d{1,2}:\\d{2}[AP]M\n\n2. Write a Python script to check if a string is a valid IP address.\n```python\nimport re\n\n# valid IP address pattern\nvalid"
            },
            {
                "text": " \"^[0-9]{1,2}:[0-9]{2}(:AM|PM)\\.\"\n\n# 2.5.3 Matching Character Classes and Sets\n\nA character class is a pair of"
            },
            {
                "text": " ^\\d{2}:\\d{2}(?:AM|PM)?$\n\n2. Create a RegEx that matches any sequence of letters that is 4 or more characters in length and is not a whitespace.\nAnswer: ["
            },
            {
                "text": " [0-9:]+\n\nExercise 3:\nWrite a Python function that takes a string as input and returns True if the string is a valid email address and False otherwise.\n\ndef is_valid_email(email):\n    "
            },
            {
                "text": " HH\\d\\d:\\d\\d [AP]M \n\n4. Create a RegEx for this description:\nMatch any text between the \"start\" and \"end\" tags.\nHint: The RegEx could be \""
            },
            {
                "text": " (0[1-9]|1[0-2])[0-9](:[0-5][0-9]|60)\n```\n\n#### Exercise 5\n\nWrite a RegEx to extract all of the phone"
            },
            {
                "text": " \nmatches = re.compile(r\"(\\d{2}):(\\d{2})\\s(AM|PM)\")\n\nExercise 5: \nWrite a Python program that uses RegEx to extract all the"
            }
        ]
    },
    {
        "expression": "^(\\d)?(\\d|,)*\\.?\\d{1,2}$",
        "raw_prompt": "Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n",
        "refined_prompt": "Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n\nMatch examples:\n- \"1,000\"\n- \"1,200.45\"\n- \"4,567,567.45\"\nNon-match examples:\n- \"$1,000\"\n- \"1,200.45343\"",
        "matches": [
            "1,000",
            "1,200.45",
            "4,567,567.45",
            "2450.45",
            ",,05,,89,608,98,,,,,6,6.4",
            "09,8,,097,,,.5",
            ",5,,9670,,,53075,,,3,4138,,,1,,82,,3,7,,,5,,,,6,63090,,8,,53,,,6,,,29586777,44",
            ",411,6,9,73,,2,505,5,,4,5,24,,7,9,20,,,4,960,04,4,1,09,7328,711,0,4804,84,8,9,,,3,3,,,,,,,6",
            "098,3,8,,1700,,2,,8,36,858.3",
            "175,,25,067,,,11,,2,739,8,9,,36,5,,,6305,826,,,,3,,,50,,,,,39,,,1,4,9,4,,,,,,,1,35,8,0,6,0784,33,,75",
            "76,2,,,,282,,,46,,9,,,,5,62,,8,,.19",
            "28,,0,,,,,7856,7,,6,,0319,5,,4619229,,55,,7,1,7,1934,,7,,71,5,,76,043045,9,07.7",
            "3,6,98,1,2197,5,93,776148,,,69,8,,59,105,9,,,,,5476,067,,,,,,6,83776,,1398"
        ],
        "non_matches": [
            "$1,000",
            "1,200.45343",
            "2.5.000",
            "314567896iuytrfew",
            "hyu7654",
            "34256ytergfd",
            "jhitr5drt",
            "34r5t6tgr",
            "3r4t56yyhtrgef",
            "4567i6e",
            "4565hyetr",
            "frgthyj66754"
        ],
        "id": 2190,
        "output": [
            {
                "text": " (0|[1-9][0-9]{0,2}[.]0[0-9]{2}"
            },
            {
                "text": " ^\\d+,{1,2}\\d*\\.\\d{1,2}$\n\nExercise 3:\nCreate"
            },
            {
                "text": " \n- [0-9][0-9.,]{1,2}\n- [0-9]?[0"
            },
            {
                "text": " (?:[1-9][0-9]\\d*|[1-9])[.][0-9]{"
            },
            {
                "text": " \"(\\\\d{3})(\\\\.\\\\d{0,2})$\"\n\nExercise 3:\nCreate a Reg"
            },
            {
                "text": " $1,000 | [0-9]{1,2}(?:,|\\.)\\d{1,2}"
            },
            {
                "text": " $1,0[1-9][0-9]|1[0-9][0-9][0-9]"
            },
            {
                "text": " /\\$1,000,?\\$/.\n\nExercise 4: Match a string with a pattern where the string must contain"
            },
            {
                "text": " (?<=\\d)\\d{1,2}(,\\d{3})?\n- \"456,789,"
            },
            {
                "text": " [0-9]{1,3}[,\\s]?[0-9]{3}[,\\s"
            }
        ]
    },
    {
        "expression": "^[+]\\d{1,2}\\(\\d{2,3}\\)\\d{6,8}(\\#\\d{1,10})?$",
        "raw_prompt": "Phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444)? then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits",
        "refined_prompt": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\"",
        "matches": [
            "+7(834)4328933#890",
            "+72(834)43289323#8902892",
            "+33(834)328932",
            "+72(771)8804518#40",
            "+6(040)6454307",
            "+09(422)66282297#9443664649",
            "+3(914)1131645",
            "+3(88)4935530#821176",
            "+0(024)2884004#8069765135",
            "+3(91)5889381#483",
            "+0(36)388664",
            "+91(201)919289#54366485",
            "+50(221)487078#672883651"
        ],
        "non_matches": [
            "+7(834)4328933#",
            "+7(834)4328#89908",
            "+723(834)4328#89908",
            "234:433",
            "2345678",
            "number",
            "+16847658902",
            "+1987656789",
            "734",
            "0.0",
            "###",
            "12%"
        ],
        "id": 2201,
        "output": [
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#899089"
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#899082"
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#8990822"
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            },
            {
                "text": "Matches phone number with country prefix +2 or +22 (one or two digits), then City code in parenthesis, like (444), then phone number 6 to 8 digits and optional extension '#XXX' up to 10 digits\nMatch examples:\n- \"+7(834)4328933#890\"\n- \"+72(834)43289323#8902892\"\n- \"+33(834)328932\"\nNon-match examples:\n- \"+7(834)4328933#\"\n- \"+7(834)4328#89908\""
            }
        ]
    },
    {
        "expression": "^(\\+[0-9]{2,}[0-9]{4,}[0-9]*)(x?[0-9]{1,})?$",
        "raw_prompt": "This comes from our requirement to have tight clean telephone database column. This expression supports only strict format and none others.It accepts any international country code with optional extension number.",
        "refined_prompt": "Matches phone numbers with any international country code with an optional extension number.\nMatch examples:\n- \"+17034567890\"\n- \"+17034567890x1234\"\n- \"+912024553455\"\nNon-match examples:\n- \"x1234\"\n- \"+1\"",
        "matches": [
            "+17034567890",
            "+17034567890x1234",
            "+912024553455",
            "+912024553455x12",
            "+441237761457",
            "+676473791029783552291015064279395363197815688107808476827193692248754273867959263973843408189323343142422747747065494300539923311944826079836300781909729121409838186907829418655621191443840686703314063717118966",
            "+9222778605751795802173211487991797907514175670250305717155640919068944436554990692745456919781220956611813602128093791810872870475056310608741401171008541544705728351234331718506170376343849101886430736733813x641010630668195731521695",
            "+269302025871023066234446322323938651084628250490413355628236101840766439864745136611259492666140836350847890190731731704592693475124847857440657073739367111785075433260401998109508155561119615153943056257432597973684218030948087022914878124987",
            "+65413162581266748199137172180404410143080891973802427227799914070133249695217349319",
            "+0670744661778624380167144988718504075413601066847916190541001058812489095590698485272453696144",
            "+758717809296979718756918800382483585543724263688762476887713365246790668418471249135695666929735x1617264766203185816939673237297539762800134572420786783",
            "+96614951729950786872635483023190464574929835019731094176730558245597342482379606747851232820831384202687835283711952830022337866645772223426",
            "+71121474786473961216023008101384905903576795413906445045650175064108783570770880554698389952519267078415733081211257111426128771085819306848068402138871782782705522617360497519136770193830636006423517178389496581388"
        ],
        "non_matches": [
            "x1234",
            "+1",
            "+123",
            "+x1234",
            "+12x12",
            "+1(703)4563245x1234",
            "number",
            "#3",
            "23%",
            "12/12",
            "34-43",
            "(603)"
        ],
        "id": 2203,
        "output": [
            {
                "text": " \n\n\"\\+[0-9]{1,3}\\.[0-9]{3}\\.[0-9]{3}+\"\n\nExercise 3:\nProvide an example of a"
            },
            {
                "text": " (\\+\\d{1,3}\\s?x\\d{3})?\\d{3}\n\nExercise 5:\nCreate a RegEx for this description.\nMatch examples:\n- \".com"
            },
            {
                "text": " +\\d{3}[-\\s]?\\d{3}[-\\s]?\\d{4}\n\n4. Write a RegEx for this description. Any phone number in the format of"
            },
            {
                "text": " r\"[^-+]?[0-9]([0-9][0-9]|[0-9]{3})(?:x[0-9]{2})?\\+?[0-"
            },
            {
                "text": "\n\\d{3}[\\-.]\\d{3}[\\-.]\\d{4}\n\nExercise 2:\nWrite a Python program that prompts the user to input a phone number and validates it against"
            },
            {
                "text": " \n^[1-9][0-9]{3}-[0-9]{3}-[0-9]{4}$\n\nExercise 2:\nWrite the Python code that matches a phone"
            },
            {
                "text": " This can be accomplished by simply adding \"^.\" to the front of the RegEx:\n^(\\+\\d{1,3})\\+\\d{1,3}x\\d{1,3}$"
            },
            {
                "text": "\n- \\+?\\d{1,3}[-\\s]?\\d{3}[-\\s]?\\d{4,20}\n\nExercise 4:\nYou are working on"
            },
            {
                "text": " (\\d{3})(\\s|x)?([+13]\\d{4})?\n\nExercise:\nUsing Python, find all phone numbers in a given text file that match the RegEx pattern you"
            },
            {
                "text": " Phone numbers must start with a + or - character and can have any number of digits, dashes, or spaces. The optional extension number can have any combination of digits and hyphens.\n\nExercise 3: Create a Reg"
            }
        ]
    },
    {
        "expression": "^([0][1-9]|[1][0-2]):[0-5][0-9] {1}(AM|PM|am|pm)$",
        "raw_prompt": "Matches if the string is in hh:mm am/pm format. Also the hour and minute values should have left padding 0's if they are single digit.",
        "refined_prompt": "Matches if the string is in hh:mm am/pm format. The hour and minute values need to have left padding 0's if they are single digits.\nMatch examples:\n- \"03:45 am\"\n- \"10:24 PM\"\n- \"01:03 pm\"\nNon-match examples:\n- \"8:15 am\"\n- \"16:10\"",
        "matches": [
            "03:45 am",
            "10:24 PM",
            "01:03 pm",
            "11:16 pm",
            "11:07 PM",
            "09:38 AM",
            "03:15 pm",
            "08:57 pm",
            "06:06 pm",
            "02:33 AM",
            "10:58 PM",
            "04:44 pm",
            "11:46 PM"
        ],
        "non_matches": [
            "8:15 am",
            "16:10",
            "10:60 pm",
            "10:13",
            "time",
            "123456789",
            "#3",
            "12/12",
            "AM",
            "PM",
            "45%",
            "0.0"
        ],
        "id": 2206,
        "output": [
            {
                "text": " *[0-9]{2}:[0-9]{2}[a-zA-Z]*\n\n3. Write a"
            },
            {
                "text": "\n[0-9]|1[0-2]|(2[0-3]):[0-5][0-9]\n"
            },
            {
                "text": " (hh:mm|pm)(0|1)(?:[0-9]|[1-9]\\d|20)\\d{2}"
            },
            {
                "text": " \n\n\\d:\\d\\d am|pm\n\nExercise 3: Write a Python program that formats a given Date in a human-readable"
            },
            {
                "text": "\n^\\d{1,2}:\\d{2}(?: a| pm)$\n\n# Exercise 5\n\nCreate a RegEx"
            },
            {
                "text": " [a-zA-z]\\d:[0-5]\\d [a-zA-Z]\\d:[a-zA"
            },
            {
                "text": "  ((?<=^|\\s) | (?<=[^\\d]))[0-9]{1,2}[:"
            },
            {
                "text": " \"([A-Za-z]+:[0-9]+)\"\n- \"00:15 pm\"\nNon-match examples:\n- \""
            },
            {
                "text": "\nimport re\n\n#Create the regex\nre.compile(r\"([0-9]{1,2})(\\:[0-"
            },
            {
                "text": " The pattern would be:\n  (0?[1-9]|1[012])[:][0-5][0-9]\n"
            }
        ]
    },
    {
        "expression": "[\\(]{1,}[^)]*[)]{1,}",
        "raw_prompt": "Will find any texts within a string that is enclosed within parenthesis ( )",
        "refined_prompt": "Matches texts within a string that is enclosed within parenthesis ( )\nMatch examples:\n- \"Test (test 1)\"\n- \"(test)\"\n- \"Test (test 1) Test (test 2)\"\nNon-match examples:\n- \"Test\"\n- \"AM\"",
        "matches": [
            "Test (test 1)",
            "(test)",
            "Test (test 1) Test (test 2)",
            "(((((((((((((((((((((((((((((((@:A;+2;\\L0gOG~K5ZT#Rf/Up[zmy*oW?.BG'aPs+j\\6\"_,NvG_I~5pbG$g9c;{jg+o;z%TuQ))))",
            "(((((((((\\C*R\\x8nh$u?Wq;P7;3S_0/.~OFjrXXK<}yhMG#%9`R'&o0{kI|kL+K:dIyn.=;SK#*;{wj2;hmmYCG@}PDw^F\"t))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "((^Y%ib3J`0E0|]d.p;MM%dqSJT&\\.$jJu02JBLq`tZ3<xWNk}J`,{SZ4WY{I}(8vS[}@YUz(-a-sT{hie61))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((=6;.i@[P9bIW9A 2sg@{qV$H*NGL5P27jY70jsP\\Cke}D!t$,bYGR)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((cj%c5h+n>hcu{']VOYOR5d/fdHlJ'2X>o4N<Kp_s)",
            "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((dd,2d>m&n>/i`AU[KZE>tl(e_x/@lF4j!o5?XH?w.3$+@'+Fa!EU4U@v<_@}gSvCb #D\";c/:Yr4@{tS:Y^NF)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((LX6=`YfBHg{!3B8:/0 G3\"))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((,&q%;\"e@VK.Kaa<le;h\"^K6GOX'c$!sacYsE1y`xN2XH5p2(c16J9:_eDh!e'/=muqt}(\\XuQJ&6O'rs<Z&/3jfJ/4Vt&l!?G))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((R.U4/K_E$;| 4%\\o,JR1^>;<dW&{tGhYMjn*SR?1aqrqx[/\\q+[gi4bLN$=2vS6:%P/m$RzvEeIBGu\\b;b)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))",
            "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((mATPYM]uH4[[X{h&QCAX<D<arebtTMczQ&[nYpeFT{7p]%(x/Z))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
        ],
        "non_matches": [
            "Test",
            "AM",
            "wefrevfgref",
            "$$$",
            "21345",
            "&&",
            "<.>",
            "!!",
            "??",
            "0.0",
            "12/12",
            "==="
        ],
        "id": 2213,
        "output": [
            {
                "text": " (?<=test )(?=\\s|$)\n\n```python\nimport re # importing the re module\n\ntext = \"Test (test 1) Test (test 2)\"\npattern = \"(?<=test )(?=\\"
            },
            {
                "text": "\n(?<=\\((?:[\\w\\s]+)\\))(?:[^)]+)\n\nExercise 4:\nWrite a Python function that takes a string as input and returns the total number of words in the string. Use list comprehension to split"
            },
            {
                "text": " [a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\n\n4. Write a Python program to extract all email addresses from a given"
            },
            {
                "text": " (test)\\w+\n\n3. Write a script that generates a regex for matching the following text:\n- \"A list of students, including: Alice, Bob, Charlie, and David.\"\n\n4. Write a script that generates a regex for matching all"
            },
            {
                "text": " ^[a-zA-Z0-9]+(? )[a-zA-Z0-9]+$\n\n2. Write a regular expression to match email addresses. A valid email address must begin with one or more letters, followed by one"
            },
            {
                "text": " ^Test(.*)$\n\nExercise 2: Match all occurrences of \"test\" in the following strings.\n- \"test test 1 test test 2\"\n- \"test\"\n- \"This string does not contain any text.\"\nAnswer: \"test"
            },
            {
                "text": " (?<!\\w)test\\b(?!\\w)\n\n3. Write a Python code snippet that makes sure a string contains any character except for:\n- a digit and a space\n- a digit and a hyphen\n- a digit and"
            },
            {
                "text": " (test\\s\\w+)\n- \"Test (test 1)\"\n- \"(test)\"\n- \"Test (test 1) Test (test 2)\"\n\nExercise 5: Regex for IP Address Validation\nWrite a Python function that takes an IP"
            },
            {
                "text": " \"AM\"Generate a RegEx for this description.\n\nExercise 3 - Solution\n\nimport re\n\ndef is_anagram(s1, s2):\n    # Create a dictionary of sorted characters\n    # Returns True if strings are an"
            },
            {
                "text": " \n^[a-zA-Z][a-zA-Z 0-9]*$\n\nExercise 2: Write a RegEx for a string that contains a decimal number, followed by a comma, and then another decimal number.\n\n\n"
            }
        ]
    },
    {
        "expression": "^/{1}(((/{1}\\.{1})?[a-zA-Z0-9 ]+/?)+(\\.{1}[a-zA-Z0-9]{2,4})?)$",
        "raw_prompt": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _ . or - in the path, this will be updated at some point.",
        "refined_prompt": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _ . or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"",
        "matches": [
            "/mnt/share/",
            "/home/.BASH",
            "/mnt/share/pic.jpeg",
            "/mnt/share/install.sh",
            "//.Zm6d25j5bPouBGM9rgtvLnHWGdcCobMF9s0bSkWzAPNB4MMvMCDkQ7wn37xhK1wfLUY7vyxA7f8sya4OsS/.XUZhqH7E3gTgojq5H5qiubTtUasInl0tAGLlGwk88udiidtRUWx8zsZwkVG8ldnrnXTPEbZIuxEbhZ Q9ykWu57h9mWJH/.2pvyal dC88XpSuJeBJv6KvWsxJ6Bym6sUsIs8wBf/.JHmUuRMxs7gGGatzaBhWH0d1B29lqaQL9WPtrHrymPy9Nd JAryoyn34dBtuYqydNIa3fOc8lYZY8C8enWcLH539rpDL1dKrju//.KlHNO9lkwekvHV1xPbA2RrnRK kP07hBSJ4CNHZCu4r Qbx/.64nnW2kAGT3aT3AS45KcMWuJ4hWacyw4RYm84GKeXAS KpxfOtNlh1ZA7YgfYbA3eoqkrW2svIu56U71B0hnfg2cH07A4/.3U53c4YhKFufDL2BzfbaWHMZ9UlFC1qJMYaPc6Aov//.lG21fo7YqEXyUI7vVLF 7J Nf5mt5qBBYIWnXgw8aSTJ/",
            "/usr",
            "/usr/bin",
            "/iuyt",
            "/04/23d",
            "/we7834/nuwe/ewiu3ui34/ewuih",
            "/d/d/w/r/q",
            "/ed/le/24rtfd",
            "/r"
        ],
        "non_matches": [
            "mnt/share",
            "//mnt///share//",
            "/mnt/share/install.installer",
            "/home\\user",
            "/efrer-",
            "\\\\rfevds",
            "///e3refvg",
            "//234",
            "/'",
            "/123@",
            "/key=",
            "/key=value/"
        ],
        "id": 2215,
        "output": [
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer:.*\\/"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer:\n/m"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: \n^"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /mnt"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer:\n /\\/"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer:\n/^"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /^("
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: (\\/m"
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /^("
            },
            {
                "text": "Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also will only match files that have extensions consisting of 2, 3, or 4 characters. Fails with _. or - in the path.\nMatch examples:\n- \"/mnt/share/\"\n- \"/home/.BASH\"\n- \"/mnt/share/pic.jpeg\"\nNon-match examples:\n- \"mnt/share\"\n- \"//mnt///share//\"Generate a RegEx for this description. \nAnswer: /([^"
            }
        ]
    },
    {
        "expression": "^([0-9]{2})(01|02|03|04|05|06|07|08|09|10|11|12|51|52|53|54|55|56|57|58|59|60|61|62)(([0]{1}[1-9]{1})|([1-2]{1}[0-9]{1})|([3]{1}[0-1]{1}))/([0-9]{3,4})$",
        "raw_prompt": "Law 301/1995 z. Z. SR from 14. december 1995. PIN from 1900 to 1953 have sufix with three digits, PIN beyond 1954 have four digits in sufix. In first part of woman PIN is month of birth (3rd & 4th digit) increase +50.",
        "refined_prompt": "Matches Personal Identification Number (PIN) from 1900 to1953, which have a suffix with three digits, and a PIN beyond 1954 have four digits in suffix\nMatch examples:\n- \"760612/5689\"\n- \"826020/5568\"\n- \"500101/256\"\nNon-match examples:\n- \"680645/256\"\n- \"707212/1258\"",
        "matches": [
            "760612/5689",
            "826020/5568",
            "500101/256",
            "395311/208",
            "275101/509",
            "120531/3478",
            "130131/7221",
            "400202/703",
            "350518/9501",
            "400330/5838",
            "870709/8512",
            "850431/363",
            "690430/7535"
        ],
        "non_matches": [
            "680645/256",
            "707212/1258",
            "260015/4598",
            "qwefv",
            "33",
            "0.0",
            "#3",
            "$67",
            "45%",
            "2345t",
            "number",
            "PIN"
        ],
        "id": 2218,
        "output": [
            {
                "text": "  ^(\\d{3})(\\d{3})(\\d{4})$\n\nExercise 3: Password"
            },
            {
                "text": ".*\\d{3}\\((\\d{4})\\)/(\\d{4})/(\\d{4})."
            },
            {
                "text": " Use the digit character class, '[0-9]', to match a single digit from 0 to 9. The '/'"
            },
            {
                "text": " \\d{4}-\\d{3}-\\d{2}\n\nExercise 2: Extracting Email Add"
            },
            {
                "text": " \n[0-9]{3}-[0-9][0-9][0-9]\n\n2."
            },
            {
                "text": " \"^[1-8]{3}/[1-9]{2}$\"\n\nExercise:\n"
            },
            {
                "text": " (1) (2) (3) \n\n\n\n\nSubsections to be covered:\n\n1. Introduction to"
            },
            {
                "text": " The RegEx should be (\\d+)/(\\d+).\n\nExercise 2: Find all the digits in a string"
            },
            {
                "text": "\n(?<![0-9])[0-9]{3}/(?<![0-9])"
            },
            {
                "text": " [\\D0-9]*\\d{3}\\D*(\\d{4})\n\n\n\nQuestion 10:"
            }
        ]
    },
    {
        "expression": "^(((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1-5]{1}){1}([0-9]{1}){1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1]{1}){1}([0-9]{1}){1}){1}|([2]{1}){1}([0-3]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|feb|mar|apr|may|jun|jul|aug|sep|okt|nov|dec)) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-7]{1}){1}))|(sun|mon|tue|wed|thu|fri|sat)))$",
        "raw_prompt": "SUPPORTED constructions:\n[*] - all five commands;\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\n[*/nubmer] - see construction [number];\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\nNON SUPPORTED constructions:\n[number-number] and\n[number,number].",
        "refined_prompt": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n[number-number] and\r\n[number,number].\nMatch examples:\n- \"*/15 */12 30 feb 7\"\n- \"10 * * * */2\"\n- \"* * * * *\"\nNon-match examples:\n- \"62 * * */2 *\"\n- \"* * * 0 *\"",
        "matches": [
            "*/15 */12 30 feb 7",
            "10 * * * */2",
            "* * * * *",
            "5 */7 30 sep wed",
            "*/34 20 6 */20 wed",
            "26 * 6 */30 *",
            "* */2 * 3 *",
            "6 */16 */9 jan */7",
            "* 11 * */31 4",
            "0 */9 30 dec *",
            "* * */30 nov fri",
            "* 15 */13 apr sun",
            "* * * * thu"
        ],
        "non_matches": [
            "62 * * */2 *",
            "* * * 0 *",
            "* * * Feb *",
            "*",
            "*jerj",
            "*july*ef",
            "date",
            "74*8june",
            "8/04/2000",
            "123443",
            "34/34",
            "643*July"
        ],
        "id": 2222,
        "output": [
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n\r"
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            },
            {
                "text": "Matches dates with the following constrictions\r\n\r\nSUPPORTED constructions:\r\n[*] - all five commands;\r\n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);\r\n[*/nubmer] - see construction [number];\r\n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\r\nNON SUPPORTED constructions:\r\n["
            }
        ]
    },
    {
        "expression": "^(B(A|B|C|J|L|N|R|S|Y)|CA|D(K|S|T)|G(A|L)|H(C|E)|IL|K(A|I|E|K|M|N|S)|L(E|C|M|V)|M(A|I|L|T|Y)|N(I|O|M|R|Z)|P(B|D|E|O|K|N|P|T|U|V)|R(A|K|S|V)|S(A|B|C|E|I|K|L|O|N|P|V)|T(A|C|N|O|R|S|T|V)|V(K|T)|Z(A|C|H|I|M|V))([ ]{0,1})([0-9]{3})([A-Z]{2})$",
        "raw_prompt": "Case sensitive (upper)!",
        "refined_prompt": "Matches strings with capital letters and numbers\nMatch examples:\n- \"BB123AB\"\n- \"KE 999BB\"\n- \"BA 362SO\"\nNon-match examples:\n- \"QT 123AB\"\n- \"BB 1234AA\"",
        "matches": [
            "BB123AB",
            "KE 999BB",
            "BA 362SO",
            "LM 447YA",
            "IL610PY",
            "BS952VJ",
            "NM336ML",
            "ZI 195IR",
            "KI 059EA",
            "MI 076HC",
            "ZA 099AZ",
            "ZH 226AP",
            "TA379BD"
        ],
        "non_matches": [
            "QT 123AB",
            "BB 1234AA",
            "BB001ABC",
            "erfr",
            "HSHS34",
            "22 HHHE",
            "EE 634H",
            "oiuytfghu4897",
            "0",
            "#",
            ".0",
            "56%"
        ],
        "id": 2223,
        "output": [
            {
                "text": "\n\nimport re\nregex_string_1 = '^[A-Z0-9]{1,30}$'\n\nregex_string_2 = '^[A-Z0-9]{1,20}(?=[A-Z"
            },
            {
                "text": "\n\n```python\nimport re\n\nmatches = re.findall(r'[A-Z0-9]', 'BB123AB')\nnon_matches = re.findall(r'[^A-Z0-9]', 'Q"
            },
            {
                "text": " (\\\\d)\\\\w{3}(\\\\d)\\\\w{3}\n\n2. Write a regular expression to match all IP addresses in a string. \nAnswer: ip_address = \"(?:(?:25[0-5]|2[0-4"
            },
            {
                "text": " \n^[A-Z][A-Z0-9]*[A-Z0-9][A-Z]$\n\nExercise 4:\nDevelop a regex that matches an URL, with optional periods and spaces in the domain name. \nExample: "
            },
            {
                "text": " \\b[A-Z][0-9]{3}\\b|\\b[0-9][A-Z]{3}\\b|\\b[A-Z]\\w{2}\\b|\\b[0-9]\\w{2}\\b"
            },
            {
                "text": " ([a-zA-Z0-9]*)([0-9])+\n\n4. Create a RegEx that matches an email address.\nAnswer: - ^[a-zA-Z0-9._%+-]+@[a-zA"
            },
            {
                "text": "\nMatches strings with capital letters and numbers:\n[A-Z]\\d+|\\d+[A-Z]\n\nNon-match examples:\n[A-Z]\\d+|\\d+[A-Z]\n\nExercise 3:"
            },
            {
                "text": "\n\n```python\nimport re\n\nstring = \"QT 123AB\"\n\nmatches = re.findall(r'\\b\\w*[A-Z]\\w*[0-9]\\w*[A-Z]\\w*"
            },
            {
                "text": " \"^[A-Z0-9]+(?![A-Z]{3})$\"\n3. Create a RegEx for an email address.\nAnswer: \"^[A-Za-z0-9._%+-]+@[A-Z"
            },
            {
                "text": " https://regex101.com/r/wD4nx2/2\n\n3. \nTask: Create a list of words that do not contain the letters \"e\" or \"i\". \nAnswer: https://regex101.com/r/w"
            }
        ]
    },
    {
        "expression": "^([a-hA-H]{1}[1-8]{1})$",
        "raw_prompt": "Letter (a - h) + number (1 - 8). Case insensitive.",
        "refined_prompt": "Matches letters (a - h) and number s(1 - 8). Case insensitive.\nMatch examples:\n- \"A1\"\n- \"a8\"\n- \"b3\"\nNon-match examples:\n- \"i5\"\n- \"F9\"",
        "matches": [
            "A1",
            "a8",
            "b3",
            "e5",
            "b2",
            "A3",
            "d4",
            "a6",
            "d7",
            "e5",
            "E2",
            "C6",
            "C1"
        ],
        "non_matches": [
            "i5",
            "F9",
            "AA",
            "s",
            "324ref",
            "hs",
            "8",
            "34d",
            "0.0",
            "123er",
            "4%",
            "234"
        ],
        "id": 2224,
        "output": [
            {
                "text": " [a-h][1-8]\n\n5. Write a Python function that takes a string as input and returns a new string with every other letter removed.\nExample: s = \"Hello World\" => def remove_every_other(s): return s["
            },
            {
                "text": " Match cases are acceptable, and the Regex should be [a-h]?[0-9]+(?:-[0-9]+(?:-[0-9]+)?)*\n\nA:\n\nUse Regex ^(?=.*["
            },
            {
                "text": " (.*) matches up to a (.*) and up to a (.*)\n\"\"\"\ndef match_description(description):\n    pattern = re.compile(r\"^(.*)\\((.*)\\)(.*)$\", re.IGNORECASE"
            },
            {
                "text": "\n```python\nimport re\n\npattern = \"^(?=.*[a-h])(?=.*[8][a-h])[a-h][8][a-h]*$\"\ntext = \"A1\"\nresult"
            },
            {
                "text": " \\d(?:[a-zA-Z]|\\d)*\n\n2. Write a Python script that matches an email address. It should match the following patterns:\n* The username portion must start with a letter and a single underscore.\n* The password"
            },
            {
                "text": " ([a-zA-Z])([1-8]).\n\n2. Regex for extracting numbers from a string that may contain more than one digit. \nExample: \"The number is 123456.\"\nRegex should extract the number 123456.\n"
            },
            {
                "text": " /(?=^[^a-z])(?=^[a-z])([a-z])([a-z])/.\n\nExercise 5: Write a Python function that takes in a text string and returns a list of all words"
            },
            {
                "text": " (a-f) (1-8)\n\nExample 2: Password Regex\nA password must be at least 7 characters in length. The following regular expression will match if your password is \"password123\". \nRegex: ^(?=.*\\d"
            },
            {
                "text": " \"aA2\"\n\n---\n\n2. Use regex to extract the numbers from a given string.\n\n__Hint__: Use `\\d` to match any digit character.\n\n__Solution__:\n```python\nimport re\n\n"
            },
            {
                "text": " (\\d)([a-h])(\\d)\n\n5. Write a Python function that takes a string and a regular expression pattern as input and returns all matched substrings.\nExample:\nregex = re.compile(r'(a)("
            }
        ]
    },
    {
        "expression": "^([1-9]{1}|[1-9]{1}[0-9]{1,3}|[1-5]{1}[0-9]{4}|6[0-4]{1}[0-9]{3}|65[0-4]{1}[0-9]{2}|655[0-2]{1}[0-9]{1}|6553[0-6]{1})$",
        "raw_prompt": "Communication ports in PC between 1 - 65536.",
        "refined_prompt": "Matches communication ports in PC between 1 - 65536.\nMatch examples:\n- \"1\"\n- \"80\"\n- \"65536\"\nNon-match examples:\n- \"0\"\n- \"0999\"",
        "matches": [
            "1",
            "80",
            "65536",
            "61569",
            "59776",
            "11627",
            "65520",
            "65517",
            "95",
            "61746",
            "62004",
            "391",
            "60968"
        ],
        "non_matches": [
            "0",
            "0999",
            "65537",
            "ijut765",
            "iyt867r5",
            "g86r7",
            "lhugit",
            "iut67r",
            "76rftu",
            "vgtfydr",
            "65rf",
            "ou9y87t"
        ],
        "id": 2241,
        "output": [
            {
                "text": " \n^(?=.*[1-9])(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[\\d]).{32}$\n\n2. Match only 1-65536 digits and alphanumeric"
            },
            {
                "text": " /0-9[0-9]*/\n\nFor this exercise, you need to generate a regular expression that matches every non-negative integer from 0 to 65536, respectively.\n\nExercise 5: Regular Expression for IP Address Separation\n\nQuestion: Write a regular expression to match an IP address without the"
            },
            {
                "text": " \"^0[9]{1}[01]{0,1}[5]{4}$\"\n\nExercise 5:\n1) Create a Regular Expression that matches a string that starts with \"a\", followed by \"b\", \"c\", \"d\".\n2) Create a Regular Expression"
            },
            {
                "text": "\n\"0(1|[1-9][0-9])|099|99\"\n\n4. Create a RegEx pattern to remove unwanted characters from the following strings:\n- \"Hello, World!\\t\\r\\n\"\n- \"Python 3.9.0\"\nAnswer:"
            },
            {
                "text": " \n\n1. [1-9]|10[0-9]|100[0-9]|1000[0-9]|10000[0-9]|1000000[0-9]|10000000[0-9]\n2. [a-z]\n3. ["
            },
            {
                "text": " \n\\b[1-65536]\\b\n\nExercise 2: Match a regular expression that only matches IPv4 addresses with 32 or more bits.\n\nAnswer: \n127.|. 172.|. 192.|. 224.|. 240.|. 256.|. 320."
            },
            {
                "text": " \"^0*(\\\\d+\\\\d|\\\\d+\\\\d\\\\d\\\\d|\\\\d+\\\\d\\\\d\\\\d\\\\d|\\\\d+\\\\d\\\\d\\\\d\\\\d\\\\d)$\"\n\n2. What is a valid IPv4 address?\nAnswer: A valid"
            },
            {
                "text": " \"^[12][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][a-zA-Z0-9!@#$%^&*()]$\"\n\nExercise 3"
            },
            {
                "text": " \"^\\s*(0|1|65536)\\s*$\"\n\nExercise 2: Match an IP Address or String that contains a subnet mask.\n\nExercise: Match an IP Address or String that contains a subnet mask.\n\nAnswer: \"^(?:[0-9"
            },
            {
                "text": " \\d{1,6}\n\n**Exercise 4:** Write a RegEx to match IPv4 addresses.\nExample: \n- \"192.168.1.1\"\n- \"192.168.1.2\"\n- \"192.168.1.3\"\n\nAnswer:"
            }
        ]
    },
    {
        "expression": "^(0|(([1-9]{1}|[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{2}){1}(\\ [0-9]{3}){0,})),(([0-9]{2})|\\-\\-)([\\ ]{1})(\u20ac|EUR|EURO){1}$",
        "raw_prompt": "Supported symbols are \u20ac or EUR or EURO (all case sensitive).",
        "refined_prompt": "Matches money with \u20ac or EUR or EURO (all case sensitive).\nMatch examples:\n- \"0,00 \u20ac\"\n- \"1 234 567,89 EUR\"\n- \"1,-- EURO\"\nNon-match examples:\n- \"00,00 \u20ac\"\n- \"1234567,89 EUR\"",
        "matches": [
            "0,00 \u20ac",
            "1 234 567,89 EUR",
            "1,-- EURO",
            "41 140 489 616 442 321 595 068 559 472 489 946 252 033 676,75 EURO",
            "6 954 845 753 280 572 341 029 269 513 285 888 289 808 462 655 818 038 391 325 156 851 382 147 064 056 055 459 724 993 071 166 569 035 042 360 206 024 788 022 250 763 328 388 479 244 117 739 350 735 593 769 640 714 280 168 688 229 653 206 768 577 509 230 075 200,53 EURO",
            "0,-- EURO",
            "577 561 988 804 578 428 064 949 552 734 647 844 824 658 809 147 872 150 079 679 013 268 080 855 609 712 261 668 511 166 863 463 355 744 408 888 347 787 434 421 327 280 974 555 465 595 657 231 931 947 104 651 124 031 846 916 323 424 530 280 719 132 749 082 352 904 394 323 994 593 316 226 582 550 082 373 884 952 599 844 115 465 456 557 231 517 565 101 692 258 941 967 036 607 546 894 161 798,-- \u20ac",
            "0,09 \u20ac",
            "54 127 409 345 917 336 335 754 703 482 935 747 073 414 290 596 615 957 207 352 301 942 734 990 992 652 817 470 649 837 626 935 988 302 706 313 595 735 786 834 338 594 760 036 769 701 348 003 992 793 906 715 594 787 595 802 466 286 622 107 420 581 009 495 201 938 215 667 409 803 495 695 493 413 860 257 293 466 738 421 355 640 662 335,41 EUR",
            "4 344 831 003 982 867 490 198 985 749 127 191 961 700 732 893 515 205 586 908 984 582,-- \u20ac",
            "556 045 372 831 134 029 003 896 256 677 153 727 453 398 746 174 764 933 268 822 053 701,-- EUR",
            "2 334 194 257 696 719 847 933 670 992 397 700 402 546 968 127 816 646 370 100 442 644 319 387 070 046 928 113 998 757 465 371 738,-- EUR",
            "25 463 929 633 886 675 855 732 754 649 754 694 443 159 497 214 045 908 130 947 953 860 509 267 475 090 823 845 722 730 380 617 079 500 506 729 636 457 513 728 035 680 558 565 449 145 974 309 863 168 497 192 857 244 333 112 135 791 700 125 756 694 937 825 469,-- EURO"
        ],
        "non_matches": [
            "00,00 \u20ac",
            "1234567,89 EUR",
            "0 555,55 EURO",
            "2,2 EUR",
            "2,- EUR",
            "$$456789",
            "5678",
            "money",
            "$$$",
            "0f93eyd9chso",
            "344343",
            "328734"
        ],
        "id": 2246,
        "output": [
            {
                "text": " [\\d,\\d\\d\\d\\s,\\s\\d\\d\\d\\d].*\n\n5. Write a regular expression to match the pattern: \n- Start with a"
            },
            {
                "text": " \"0,00|1234567|89 EUR|\\b|\\D|\\s|\\w\"\n\nExercise 3:\n\nDescribe a possible use case for RegEx in the context"
            },
            {
                "text": " 0[0-9]{1,2} \\, 0[0-9]{3,4} EUR\n\nExercise 5: Match the currency specifier with its corresponding value.\nMatch examples"
            },
            {
                "text": " \"^\\d+,[0-9]{3}[,.]\\d+$\"\n\n2. Create a Python program that extracts all the matches for a given RegEx pattern in a string."
            },
            {
                "text": " \\d+(\\.\\d+) +(?=(\\s*[,.\u20ac])+)\n\nExercise 4: \nRewrite the pattern in Exercise 2 to support currency with trailing zeroes: \""
            },
            {
                "text": " '^\\d\\d,\\d\\d\\d (euro|eur|euroo)$'\n\n4. Write a Python function that takes a string of text and returns the number of words in"
            },
            {
                "text": " [\\d+\\.\\d{1,2}]\n\n3. Given a string with a currency or any number of currency symbols, split it into its numeric and currency parts.\nAnswer: For example"
            },
            {
                "text": " \\d+\\.?\\d*|\\d+|\\d\\d[.,]\\d\\d[.]\\d\\d[.']\\d\\d[.']\\d\\d"
            },
            {
                "text": " (.*)(\\s)([0-9]+)(\\S*)(?:EUR)?\n\nExercise 2:\nMatch the following phrases with the correct currency type:\n- \"United States Dollars\""
            },
            {
                "text": "\n0,00 ([0-9]*)([Ee][+-]?[0-9])?\n\n3. Write a Python program that verifies whether a given string represents a German or"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(0[1-9]|[1-9][0-9]|175[3-9]|17[6-9][0-9]|1[8-9][0-9]{2}|[2-9][0-9]{3})$",
        "raw_prompt": "Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999. Does not check for leap years.",
        "refined_prompt": "Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999. Does not check for leap years.\nMatch examples:\n- \"01/01/1753\"\n- \"9/2/09\"\n- \"12/02/1980\"\nNon-match examples:\n- \"1/1/1\"\n- \"13/1/01\"",
        "matches": [
            "01/01/1753",
            "9/2/09",
            "12/02/1980",
            "12/31/9999",
            "4/21/1963",
            "11/31/1764",
            "12/30/1953",
            "10/08/3403",
            "7/08/08",
            "05/09/48",
            "11/01/3088",
            "10/04/1891",
            "12/30/38"
        ],
        "non_matches": [
            "1/1/1",
            "13/1/01",
            "01/0/2001",
            "12/31/1752",
            "1-1-1900",
            "121212",
            "12-12-12",
            "12 12 12",
            "121212121212",
            "date",
            "aug 3",
            "noon"
        ],
        "id": 2259,
        "output": [
            {
                "text": "\nThe final RegEx would"
            },
            {
                "text": " (\\d{4}"
            },
            {
                "text": " /\\d{2}"
            },
            {
                "text": "\n```\nimport re"
            },
            {
                "text": "\n\nA:\n\n"
            },
            {
                "text": " 1-3 digits before the"
            },
            {
                "text": " \n^(0["
            },
            {
                "text": " [0-9]{"
            },
            {
                "text": " (0-9)\\/"
            },
            {
                "text": "\n\n/\\d{"
            }
        ]
    },
    {
        "expression": "^\\d{1,3}((\\.\\d{1,3}){3}|(\\.\\d{1,3}){5})$",
        "raw_prompt": "validate both IP V4 and IP V6",
        "refined_prompt": "validate both IP V4 and IP V6\nMatch examples:\n- \"192.168.0.1\"\n- \"000.000.000.000.000.000\"\n- \"999.999.999.999.999.999\"\nNon-match examples:\n- \"1.1.1.1.1\"\n- \"1.1\"",
        "matches": [
            "192.168.0.1",
            "000.000.000.000.000.000",
            "999.999.999.999.999.999",
            "91.77.2.24.786.46",
            "1.23.00.014.62.574",
            "480.4.707.390",
            "05.825.2.7",
            "929.3.90.823",
            "1.0.226.20.710.96",
            "6.987.3.17.129.756",
            "3.56.1.510.5.9",
            "5.4.18.67.367.7",
            "0.04.2.849"
        ],
        "non_matches": [
            "1.1.1.1.1",
            "1.1",
            "a.b.c.d.e.f.g",
            "234567889",
            "IP",
            "ewfhdcso8",
            "43efdsc",
            "13r45t6y7u",
            "r4f32erc",
            "3f45g6h7j",
            "123453.2343224.21433",
            "234."
        ],
        "id": 2262,
        "output": [
            {
                "text": " \nRegex: ^([0-9]{1,3}\\.){3}[0-9]{1,3}$\nReplace"
            },
            {
                "text": " \n^(?:(?:[0-9]{1,2}\\.){3}[0-9]){1,3}$\n\n"
            },
            {
                "text": " (Exact match is required for this question)\n\n3. Create a Python script that validates a file's format using RegEx.\nThe format of the"
            },
            {
                "text": "\n(^[0-9]{1,3}\\.){3}[0-9]{1,3}$\n\nExercise 4:"
            },
            {
                "text": "\n[0-9]|[1-9][0-9]|[1-9]0[0-9]|[1-9]"
            },
            {
                "text": "\n$str = \"192.168.0.1\";\n$str = \"10.0.0.0/8\";\n$str = \"1"
            },
            {
                "text": " \n- [0-9]{1,3}[\\.][0-9]{1,3}[\\.][0-9]"
            },
            {
                "text": "\n(^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$)|(^("
            },
            {
                "text": " [0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9"
            },
            {
                "text": " ^(?=.{4}$)(?=.*[a-zA-Z])(?=.*\\d)(?=.*\\.\\d"
            }
        ]
    },
    {
        "expression": "^(((0|128|192|224|240|248|252|254).0.0.0)|(255.(0|128|192|224|240|248|252|254).0.0)|(255.255.(0|128|192|224|240|248|252|254).0)|(255.255.255.(0|128|192|224|240|248|252|254)))$",
        "raw_prompt": "netmask address. I know this is nod good enough :)",
        "refined_prompt": "Matches net mask address\nMatch examples:\n- \"255.255.192.0\"\n- \"240.0.0.0\"\n- \"255.255.255.0\"\nNon-match examples:\n- \"255.0.192.0\"\n- \"240.128.0.0\"",
        "matches": [
            "255.255.192.0",
            "240.0.0.0",
            "255.255.255.0",
            "255Q255<128,0",
            "255e254b0S0",
            "0{0C0<0",
            "128=0D0I0",
            "255k128\"0n0",
            "255X255!255q128",
            "252f0\"0V0",
            "255g192m0E0",
            "255;2558255I248",
            "255L255r255N240"
        ],
        "non_matches": [
            "255.0.192.0",
            "240.128.0.0",
            "240.255.255.0",
            "1234refds",
            "e3ddg4",
            "4r3fewd",
            "4rtgyhujik86756",
            "34fertyhu7",
            "gutr6esre",
            "45ertdfgyu",
            "34f67",
            "45678"
        ],
        "id": 2264,
        "output": [
            {
                "text": "\n[0-1]?[0-9]?[0-9]?[0-9]?[0-9].?[0-9]?[0-9].[0-"
            },
            {
                "text": " \n^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$\n\nExercise 2: \nMatch an IP address in the format"
            },
            {
                "text": "\n[^\\d.\\s][\\d\\s]\\.([\\d\\s])\\.([\\d\\s])[\\s\\d.]{3}\\.[^\\s]\n"
            },
            {
                "text": " A match pattern could be \"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\"\n\nExercise 4:\nFind the"
            },
            {
                "text": "\n\n```python\nimport re\n\ndef regular_expression(address):\n    pattern = '[0-9]{1,3}\\.\\d{1,3}\\.\\d{1,"
            },
            {
                "text": "\n``` python\nimport re\nnetmask_regex = r\"(\\d{1,3}\\.){3}\\d{1,3}\"\nprint(netmask_regex)\n```"
            },
            {
                "text": " \n\n```python\n# Import re module\nimport re\n\n# Define net mask address regex\nregex = re.compile(r\"^(?=.*.0)(?!.*\\"
            },
            {
                "text": " \n^(?:\\d{1,3}\\.){3}\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\n\n3. Exercise:"
            },
            {
                "text": " \nTo generate a RegEx for this description, you need to include the IP address range, the netmask, and the subnet mask separately. The IP address range is separated by a \".\" and the netmask"
            },
            {
                "text": " ^(0|[1-9]\\d?\\d?)\\.(0|[1-9]\\d?\\d?)\\.(0|[1-9]\\d?\\d?)"
            }
        ]
    },
    {
        "expression": "^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[0-9]{1,2})(/([0-9]|[0-2][0-9]|3[0-2]))$",
        "raw_prompt": "ip address/netmask couple",
        "refined_prompt": "Matches ip address/netmask couple\nMatch examples:\n- \"192.168.0.5/24\"\n- \"255.255.0.0/32\"\n- \"162.226.103.215/4\"\nNon-match examples:\n- \"192.256.0.5/24\"\n- \"255.255.0.0/40\"",
        "matches": [
            "192.168.0.5/24",
            "255.255.0.0/32",
            "162.226.103.215/4",
            "7.199.120.250/3",
            "233.253.255.138/32",
            "180.7.102.247/31",
            "1.153.130.108/4",
            "250.253.153.02/02",
            "192.117.251.122/8",
            "252.250.252.148/30",
            "193.227.194.254/02",
            "221.35.178.5/30",
            "195.104.237.169/04"
        ],
        "non_matches": [
            "192.256.0.5/24",
            "255.255.0.0/40",
            "2345678765432",
            "23456.32134354.",
            "234ref.3ref",
            "3456.324",
            "132rew.g454",
            "4e243r.",
            "ip",
            "ewdsc",
            "567uju6yt",
            "34efd"
        ],
        "id": 2265,
        "output": [
            {
                "text": " The network range should consist of two numbers separated by a dot, where each number is separated by a slash (ie., [0-9]{1,"
            },
            {
                "text": " \"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3"
            },
            {
                "text": "\n\\b[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3"
            },
            {
                "text": " \n[0-9][0-9]?[0-9]\\/[0-9][0-9]?[0-9"
            },
            {
                "text": "\n(\\d{1,3}\\.){3}\\d{1,3}\\.\\d{1,3}\\/\\d{1,"
            },
            {
                "text": " One possible solution is to use two capturing groups, one for the IP address and one for the network mask, with the following regular expression: \"(?<ip"
            },
            {
                "text": " r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,"
            },
            {
                "text": " I'd start by checking the first number for the length required by the IP address. This number is 255.  The second number is always 8.  The"
            },
            {
                "text": " \n[a-z0-9-]{1,3}\\.[a-z0-9-]{1,3}\\.[a"
            },
            {
                "text": " (\\d{1,3}\\.){3}\\d{1,3}/\\d{1,3}\n\n3. Write a"
            }
        ]
    },
    {
        "expression": "\\b(((0[13578]|1[02])[\\/\\.-]?(0[1-9]|[12]\\d|3[01])[\\/\\.-]?(19|20)?(\\d{2}))|(0[13456789]|1[012])[\\/\\.-]?(0[1-9]|[12]\\d|30)[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?(0[1-9]|1\\d|2[0-8])[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?29[\\/\\.-]?(19|20)?((0[48]|[2468][048]|[13579][26])|(00)))\\b",
        "raw_prompt": "I needed to have a way where users could type in any date format like the following: mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use \"/\" and \".\" and \"-\" or nothing as separation characters. I use this in a RegularExpression Validator control in ASP.NET",
        "refined_prompt": "Matches dates with any format, such as mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use \"/\" and \".\" and \"-\" or nothing as separation characters.\nMatch examples:\n- \"032103\"\n- \"02/29/2008\"\n- \"10.31.1990\"\nNon-match examples:\n- \"2-29-00\"\n- \"11.31.1992\"",
        "matches": [
            "032103",
            "02/29/2008",
            "10.31.1990",
            "010102",
            "0206/2063",
            "01/31.41",
            "02-042051",
            "02-29.00",
            "02/292032",
            "08-302024",
            "02.13-1901",
            "0217-2082",
            "1026.1921"
        ],
        "non_matches": [
            "2-29-00",
            "11.31.1992",
            "063178",
            "02/29/2005",
            "date",
            "234567",
            "1,000",
            "5%",
            "#2",
            "0.0",
            "12/12",
            "july 3"
        ],
        "id": 2273,
        "output": [
            {
                "text": "\n\nRegex = \"(?i)(?:[0-9"
            },
            {
                "text": " ^[0-9]{2}-[0-9]["
            },
            {
                "text": "\n^[0-9]{8}[-/.]"
            },
            {
                "text": "\n(?P<year>\\d{4})\\-("
            },
            {
                "text": " \\d{4}-\\d{2}-\\d"
            },
            {
                "text": " \n(?!0)([0-9]{2}"
            },
            {
                "text": " \"([0-9]{2}[-.]?["
            },
            {
                "text": " (?i)\\d{4}-\\d{2}"
            },
            {
                "text": " \\b(?:[0-9]{4}\\-)?"
            },
            {
                "text": " (?<month>\\d{2})/(?<"
            }
        ]
    },
    {
        "expression": "(\\d{2}|\\d{4})(?:\\-)?([0]{1}\\d{1}|[1]{1}[0-2]{1})(?:\\-)?([0-2]{1}\\d{1}|[3]{1}[0-1]{1})(?:\\s)?([0-1]{1}\\d{1}|[2]{1}[0-3]{1})(?::)?([0-5]{1}\\d{1})(?::)?([0-5]{1}\\d{1})",
        "raw_prompt": "Will match a date accepted by MySQL datetime type.\nYears with 2 or 4 digits from any range.\nMonths with 2 digits from 00 to 12.\ndays with 2 digits from 00 to 31.\nHours with 2 digits from 00-23\nMinutes with 2 digits from 00 to 59.\nSeconds with 2 digits from 00 to 59.",
        "refined_prompt": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-match examples:\n- \"2009-13:01 00:00:00\"\n- \"2009-12-32 00:00:00\"",
        "matches": [
            "00-00-00 00:00:00",
            "0000-00-00 00:00:00",
            "09-05-22 08:16:00",
            "1970-00-00 00:00:00",
            "20090522081600",
            "07-01-07\u202f232116",
            "07-01-07\u202f232116",
            "58-1129\u2000164106",
            "9276-12-08\u168001:0749",
            "17-120522:18:39",
            "1784-02240632:17",
            "618606-312231:09",
            "29-0826\u205f204207"
        ],
        "non_matches": [
            "2009-13:01 00:00:00",
            "2009-12-32 00:00:00",
            "2002-12-31 24:00:00",
            "2002-12-31 23:60:00",
            "02-12-31 23:00:60",
            "344rfc",
            "#3",
            "$5",
            "67%",
            "0.0",
            "1,000",
            "date"
        ],
        "id": 2278,
        "output": [
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon match"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon match"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            },
            {
                "text": "Will match a date accepted by MySQL datetime type.\r\nYears with 2 or 4 digits from any range.\r\nMonths with 2 digits from 00 to 12.\r\ndays with 2 digits from 00 to 31.\r\nHours with 2 digits from 00-23\r\nMinutes with 2 digits from 00 to 59.\r\nSeconds with 2 digits from 00 to 59.\nMatch examples:\n- \"00-00-00 00:00:00\"\n- \"0000-00-00 00:00:00\"\n- \"09-05-22 08:16:00\"\nNon-"
            }
        ]
    },
    {
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-8]{1}))|(\\+)?([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-7]{1})))$",
        "raw_prompt": "Not just a number, a byte type. Will match any number from range -128 to 127.",
        "refined_prompt": "Will match any number from range -128 to 127 to represent a byte type.\nMatch examples:\n- \"-128\"\n- \"127\"\n- \"0\"\nNon-match examples:\n- \"-129\"\n- \"128\"",
        "matches": [
            "-128",
            "127",
            "0",
            "1",
            "-10",
            "-4",
            "-9",
            "121",
            "+107",
            "9",
            "+120",
            "-123",
            "+48"
        ],
        "non_matches": [
            "-129",
            "128",
            "-0",
            "+0",
            "98765",
            "0.0",
            "3%",
            "#2",
            "1,000",
            "byte",
            "01b",
            "12/12"
        ],
        "id": 2279,
        "output": [
            {
                "text": ".*(?:[-\\\\d]+)?(?:[-\\\\d]*)$\n\n- \"0\"\nMatch this: 0xff\nMatch this: 0xff00\nMatch this: 0xff0000\n\nRegEx explanation:\n\n.*(?:[-\\\\d]+)?(?:"
            },
            {
                "text": " (\\d)-(0|[1-7]\\d|\\d{1,2})\nMatch examples:\n- \"13-16\"\n- \"-6\"\n- \"10\"\nNon-match examples:\n- \"-10\"\n- \"-16\"\nAnswer:\n("
            },
            {
                "text": " You could potentially use [\\-1234567890] for this kind of thing.\n\nSolution:\n\nconst data = [\n  'hello',\n  '-128'\n  // 0\n  '0'\n  '\\u200d',\n  '-129'\n  // 128\n"
            },
            {
                "text": " ^[-\\d\\.]*$\n\n- \"0\" match \"0\"\n- \"1\" and \"10\" match \"01\"\n  \"1\" match \"1\"\n  \"0\" match \"0\"\n  \"1\" and \"10\" match \"10\"\n"
            },
            {
                "text": " ^[0-9]{1,2}\\\\.([1-9]{1,2})$\n\n4. Describe the difference between a range and a set of characters.\nAnswer: A range includes a number between two characters (e.g. A-B) and a set"
            },
            {
                "text": "\n^(?:[-1-9]\\d|1[0-9]\\d|2[0-4][0-9]|25[0-5])$\n\nA:\n\nYou don't need so much complexity.\n^(?:\\d+|[0"
            },
            {
                "text": " (^(?:(?:[0-9]+)\\.(?:[0-9]+))?[0-9]+(?:\\.[0-9]+)?[0-9]{1,2}$)|^(?:-?)(?:(?:[0-9]+)\\.(?:"
            },
            {
                "text": " {a-zA-Z-}0-9()[]{}\n\nHow to find a regex for:\n\nMatch any number from 0 to 9 and a-zA-Z 0-9\nMatch any number from 0 to 9 and a-zA-Z 0-9\nMatch"
            },
            {
                "text": " [^0-9]\n\n---\n\n#### Ideas\n\n- Try using the ^ and $ anchors. \n- Don't forget to escape the backslashes.\n- For the RegEx, remember \"\\d\" matches any number from 0-9.\n\n---\n\n### Solutions\n"
            },
            {
                "text": " [\\\\-\\\\d]{1,2}([\\\\.\\\\-]\\\\d{1,2})\n\n2. Use the same method as in question 1, but add the case-insensitive flag. Now, the search should match cases such as \"-\" or \"-129\".\nAnswer:"
            }
        ]
    },
    {
        "expression": "^(0|[-]{1}([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-8]{1})))))|(\\+)?([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-7]{1}))))))$",
        "raw_prompt": "Short type, will match a short number from range -32768 to 32767.",
        "refined_prompt": "Matches a short number from range -32768 to 32767.\nMatch examples:\n- \"-32768\"\n- \"-10\"\n- \"0\"\nNon-match examples:\n- \"+0\"\n- \"-0\"",
        "matches": [
            "-32768",
            "-10",
            "0",
            "10",
            "32767",
            "-32090",
            "+4",
            "740",
            "97",
            "-31563",
            "-29983",
            "-1936",
            "2673"
        ],
        "non_matches": [
            "+0",
            "-0",
            "-32769",
            "32768",
            "0.0",
            "#3",
            "567%",
            "1,000",
            "12/12",
            "int",
            "$45",
            "56783"
        ],
        "id": 2281,
        "output": [
            {
                "text": " (-?[1-9]\\d*)(\\-(\\d+))?\n- \"^\\+0$\"Generate a RegEx for this description. \nAnswer: \"^\\+0$\"\n- \"^\\+0(0|(-)\\+0)\"Generate a"
            },
            {
                "text": " \n\"^[-+]?[0-9]+(.[0-9]+)?\"\n\nExercise 2:\nMatch a long number from range -2147483648 to 2147483647\nAnswer:\n^[-+]?[0-9]+(.[0-9"
            },
            {
                "text": "\n(-?[1-9][0-9])(\\.|[1-9][0-9]*)\nUse Cases\nUse Case 1: John and Lisa are trying to create a password for their social media account. They want to include both a letter and a number at least one time. They want"
            },
            {
                "text": " ^(0?[1-9]|1[012])[0-9]{1,2}$ \n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() \n{\n    char s[]"
            },
            {
                "text": " ^[-0-9]+$\n- \"-\"Generate a RegEx for this description.\nAnswer: ^[-]?[0-9]+$\n- \".\"Match a dot.\n\n2. Generate a RegEx that matches any alpha-numeric characters.\nAnswer: ^"
            },
            {
                "text": " (0|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9])\n\nNow write a test of your RegEx on the text file \"tests/test_regex.txt\".\n\nFor details, here are"
            },
            {
                "text": " (.*)-(.*)\n\n2. Match a string that starts with 1 or more vowels and ends with a consonant. \nAnswer: (.*)(?![aeiou])(.*)\n\n3. Match a phone number in the form of (123) 456-7890."
            },
            {
                "text": " [0-9]$|[1-9][0-9]+|0$\n\nExercise 2: Match a short number to the corresponding decimal place.\nMatch examples:\n- \"0\"\n- \"-0\"\n- \"1\"\nNon-match examples:\n- \"0+"
            },
            {
                "text": " [1-9][0-9]?|[1-9][0-9]\nExercise 2: Generate a RegEx to match any number between 0 and 65535 inclusive.\nAnswer: 0-65535\nExercise 3: Generate a RegEx to match any hexadecimal"
            },
            {
                "text": " \\d{1,3}-\\d{1,3}[,-]?\\d{1,3} \n\n3. Find the following string matches the start of a word: \"This is a test message.\"\nMatch examples:\n- The\n- The,\nNon-match examples"
            }
        ]
    },
    {
        "expression": "^(0|(\\+)?([1-9]{1}[0-9]{0,3})|([1-5]{1}[0-9]{1,4}|[6]{1}([0-4]{1}[0-9]{3}|[5]{1}([0-4]{1}[0-9]{2}|[5]{1}([0-2]{1}[0-9]{1}|[3]{1}[0-5]{1})))))$",
        "raw_prompt": "Will match an unsigned short number from range 0 to 65535",
        "refined_prompt": "Matches an unsigned short number from range 0 to 65535\nMatch examples:\n- \"0\"\n- \"100\"\n- \"65535\"\nNon-match examples:\n- \"-0\"\n- \"+0\"",
        "matches": [
            "0",
            "100",
            "65535",
            "1616",
            "+71",
            "160",
            "252",
            "37898",
            "8961",
            "65531",
            "26897",
            "60927",
            "+8"
        ],
        "non_matches": [
            "-0",
            "+0",
            "-10",
            "65536",
            "0.0",
            "1,000",
            "3456789098765",
            "12/12",
            "#3",
            "45%",
            "$134",
            "int"
        ],
        "id": 2282,
        "output": [
            {
                "text": " \"^[1-9][0-9]\\d*$\"\n\nA:\n\nYour regex is wrong, it should be:\n^(0|[1-9][0-9]\\d*|[1-9][0-9]\\d+|[1-9])"
            },
            {
                "text": " (?<!\\S)(?!\\s)(?!\\d)\nThis answer gives me a start, but I'm having a hard time figuring out how to get it to not count \"-\" and \"+\", and generate a RegEx for \"0123456789\"\n\nA:\n\nYou can use a"
            },
            {
                "text": " ^(?:-)?\\+?0+(?:\\s|\\|\\s)?$\n\nUsing the RegEx above, the following code would work:\nimport re\n\ndef get_hex(s):\n    if re.match('^(?:-)?\\+?0+(?:\\s|"
            },
            {
                "text": "\n^\\+?[0-9a-f]+$\n\nI hope that this exercise helped you to understand the basics of RegEx and how to use it when writing regular expressions. Remember to practice your skills regularly to become more comfortable with the RegEx language.\n\n\n\n\n# Chapter: The use of"
            },
            {
                "text": " *^-?\\d+$\n\n# Exercises\n1. Write a RegEx to match only the numbers that are between 5 and 50 not including both 5 and 50.\n2. Write a RegEx to match only the numbers that are divisible by 3 and not divisible by 5.\n3."
            },
            {
                "text": " [-0-9]+\n\nExercise 5:\nMatch a sequence of numbers separated by commas.\nMatch examples:\n- \"1,2,3,4\"\n- \"1,2,3,4,5\"\nNon-match examples:\n- \"1,2,3\"\n-"
            },
            {
                "text": " [^-0-9\\+\\*]\n\n5. Write a Python program that takes a password as input and returns whether or not it meets the following criteria:\n- At least 8 characters long\n- Contains at least one uppercase letter\n- Contains at least one lowercase letter\n- Contains at least"
            },
            {
                "text": " (^[0-9]+$)|(^[^0-9]+$)\n\nA:\n\nIs it possible to use regular expression to specify number range?\n\nYou could use two regular expressions:\n\nSomething like /^[0-9]+$/ to match the entire range (0-"
            },
            {
                "text": " -?0-9\n- \"0x\"\n- \"0o\"Generate a RegEx for this description.\nAnswer: 0(0[xX])\n- \"0o\"Generate a RegEx for this description.\nAnswer: 0(0o)\n- \"0.\"\nGenerate"
            },
            {
                "text": " ^[0-9]*(-[0-9]*)?$\n- \"100\"Allow numbers to be either \"100\" or \"-100\".\nGenerate a RegEx for this description.\nAnswer: ^(-?[0-9]*)([0-9]*(-[0-9"
            }
        ]
    },
    {
        "expression": "^(0|(\\+)?[1-9]{1}[0-9]{0,8}|(\\+)?[1-3]{1}[0-9]{1,9}|(\\+)?[4]{1}([0-1]{1}[0-9]{8}|[2]{1}([0-8]{1}[0-9]{7}|[9]{1}([0-3]{1}[0-9]{6}|[4]{1}([0-8]{1}[0-9]{5}|[9]{1}([0-5]{1}[0-9]{4}|[6]{1}([0-6]{1}[0-9]{3}|[7]{1}([0-1]{1}[0-9]{2}|[2]{1}([0-8]{1}[0-9]{1}|[9]{1}[0-5]{1})))))))))$",
        "raw_prompt": "Will match any unsigned integer from range 0 to 4294967295",
        "refined_prompt": "Will match any unsigned integer from range 0 to 4294967295\nMatch examples:\n- \"0\"\n- \"1000\"\n- \"4294967295\"\nNon-match examples:\n- \"-100\"\n- \"-0\"",
        "matches": [
            "0",
            "1000",
            "4294967295",
            "36",
            "7",
            "10642",
            "29527193",
            "4070107329",
            "+926291232",
            "+2927957",
            "2",
            "697727552",
            "4161862882"
        ],
        "non_matches": [
            "-100",
            "-0",
            "+0",
            "4294967296",
            "0.0",
            "1,000",
            "#4",
            "87%",
            "$63",
            "int",
            "345321345324",
            "00000"
        ],
        "id": 2284,
        "output": [
            {
                "text": " ^[0-9]([0-9]|1[0-9]|2[0-4][0-9]|25[0-5])$\n\nI think I need to use lookahead and lookbehind for this. I am not sure how to go about.\n\n"
            },
            {
                "text": " [^-0-9]\n\nA:\n\nHere are two very simple regular expressions, which will check if a value is in a specific range.\n^[0-9]|[1-9][0-9]$\n\nRegex Demo\n^[0-9]+$"
            },
            {
                "text": " '^[0-9][0-9]{0,2}$'\n\n3. Write a RegEx pattern to match any string that starts with a capital letter and ends with a hyphen.\nAnswer: '^[A-Z].*-$'\n\n4. Write a"
            },
            {
                "text": " 0x[0-9A-Fa-f]+\n- How would you match \"000\" to \"999\" using a RegEx?\nAnswer: 0*(0|[1-9]|[1-9][0-9])*\n- How would you match \"1\" to"
            },
            {
                "text": " \"^[0-9]+(\\.[0-9]+)$\"\n- \"1\"Generate a RegEx for this description.\nAnswer: \"^[1-9]+(\\.[1-9]*)$\"\n- \"0.99\"Generate a RegEx for"
            },
            {
                "text": " ^[0-9]+$\n\n2. Write a function that takes a string as an argument and returns true if the string starts with a letter and false otherwise.\n\nAnswer: This exercise involves the use of the `^` and `$` character in a RegEx pattern. \n\n``"
            },
            {
                "text": " \\b(0|1)\\b\n#include <cstdio>\n#include <regex>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    const std::string pattern{\"\\\\b(0|1)\\\\b\"};\n    "
            },
            {
                "text": "\n[0-9]\n\nA:\n\nIn addition to the answer posted by @Tobias_K. I think it is worth noting the following, which is from my personal experience.\n\nIn certain situations you might want to be extra cautious with your regexp.  For instance, when"
            },
            {
                "text": " (exact match, can be used multiple times) ^(0|[1-9]\\d*|\\d+)$\n- \"a0\"\n- \"a0\"\n- \"(0|[1-9]\\d*|\\d+)$\"\n- \"1a"
            },
            {
                "text": " a digit, 0-9, optionally preceded by a minus sign.\n- \"0\"Matching of a digit, 0-9\n- \"0\"Matching of a digit, 0-9\n- \"-0\"Matching of a digit, 0-9\n- \"-0\"Matching of"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|[2][0-3]|[0-9]):([0-5][0-9])(?::([0-5][0-9]))?$",
        "raw_prompt": "Validate hours with seconds returning mirrors correctly.",
        "refined_prompt": "Validate hours and minutes with seconds in format HH:MM:SS\nMatch examples:\n- \"09:05\"\n- \"10:00\"\n- \"1:15\"\nNon-match examples:\n- \"9:5\"\n- \"09:1\"",
        "matches": [
            "09:05",
            "10:00",
            "1:15",
            "00:59:00",
            "23:01:59",
            "5:15:31",
            "17:04:26",
            "5:36",
            "02:03:05",
            "6:14",
            "23:52",
            "23:17:27",
            "23:17"
        ],
        "non_matches": [
            "9:5",
            "09:1",
            "0:1",
            "0:00:0",
            "1:1:11",
            "12-12-12",
            "12/12/12",
            "12",
            "-12",
            "12.12.12",
            "0",
            "$4"
        ],
        "id": 2294,
        "output": [
            {
                "text": " \\d{1,2}:[0-9]{2,2}:[0-9]{2,2}(\\.|$)\n\n2. Write a function that takes a string representing a date in the format dd/mm/yyyy and"
            },
            {
                "text": "\n[0-9]{1,2}[0-9]{2,3}:[0-9]{2}:[0-9]{2}[ap][0-5][0-9]\n\n2. Create a RegEx"
            },
            {
                "text": " (example)\n(?<!\\d)\\s*((?<hrs>\\d{1,2}):)?(?<min>\\d{1,2}):?(?<sec>\\d{2,2})\n\n"
            },
            {
                "text": " ^([1-9][0-9]|1[0-2])[0-9]{2}:[0-9]{2}:[0-9]{2}$\n- \"10:00\"\n- \"9:15\""
            },
            {
                "text": ".{2,3}\n\n### Exercise 2:\nWrite a python code that will generate a list of all valid dates in the month of the year 2020.\n\n### Exercise 3:\nWrite a python code that will extract the current date using `re.search"
            },
            {
                "text": "\nhttps://regex101.com/r/XUfJ6Q/1\n\"\"\"\n```\n\n2. **Exercise 2:** Use the RegEx from Exercise 1 to write a Python function that takes a time string in format HH:MM"
            },
            {
                "text": " We can use a positive lookahead to match any number of digits between two non-digit characters. We can also use a positive lookbehind to match any non-digit character before the match. \n\nExercise 2: Use a regular expression to validate a zip code in"
            },
            {
                "text": " The regular expression should match the string \"HH:MM:SS\" with digits representing the hours, minutes, and seconds, but without any leading zeroes.\n\nExercise 2:\nGenerate a RegEx for this description. A phone number in the format \"("
            },
            {
                "text": " \\d{2}:\\d\\d\n        \\d{2}:\\d\\d:\\d\\d\n        \n- \"12.30\"\n- \"0.40\"\n- \"01.00\"\n- \"10.50\"\n"
            },
            {
                "text": " \n([0-9]{2})\\:(0?[1-9]|1\\d|2[0-3]):0?[1-5]\n\nExercise 2: What is a pattern?\nAnswer: A pattern is a"
            }
        ]
    },
    {
        "expression": "^([0-2]\\d|3[0-1]|[1-9])\\/(0\\d|1[0-2]|[1-9])\\/(\\d{4})$",
        "raw_prompt": "Validate a date format: d/m/Y.\nSee examples.",
        "refined_prompt": "Validate a date format: d/m/Y.\nMatch examples:\n- \"1/05/1990\"\n- \"01/1/2006\"\n- \"01/01/2008\"\nNon-match examples:\n- \"01/01/90\"\n- \"32/02/2009\"",
        "matches": [
            "1/05/1990",
            "01/1/2006",
            "01/01/2008",
            "5/5/2009",
            "1/1/1990",
            "29/05/2009",
            "7/00/7624",
            "4/01/3597",
            "18/11/7766",
            "29/02/6624",
            "31/02/6233",
            "18/4/2191",
            "30/07/5093"
        ],
        "non_matches": [
            "01/01/90",
            "32/02/2009",
            "1/13/1990",
            "0/0/2009",
            "12-12-1212",
            "12:12:1212",
            "12 12 1212",
            "12|12|1212",
            "12\\12\\1212",
            "12.12.1212",
            "12,12,1212",
            "12"
        ],
        "id": 2295,
        "output": [
            {
                "text": "  [^\\d/]\n\n#Exercise 3:\n\nFind all the dates between 2000-2005. \nAnswer: \\b2000\\d\\d\\d-\\d\\d-\\d\\d"
            },
            {
                "text": "\n/\\d{2}[-\\/.]\\d{2}[-\\/.]\\d{4}/\n*\n\n5. Write a Python function that, given a string, returns the number of matches found"
            },
            {
                "text": "\nr'\\d{2}[-/]\\d{2}[-/]\\d{4}'\n\n### Exercise 3\n\nUse the `match` method to check if the email address matches the"
            },
            {
                "text": " (0[1-9][0-9]|[12][0-9][0-9]|3[01])/(0[1-9][0-9]|1[012])/([0-"
            },
            {
                "text": " \n\ndef validate_date_format(input_date):\n\tif input_date.isdigit() == True and len(input_date) == 10:\n\t\tif input_date == input_date["
            },
            {
                "text": " [0-9]{2}/[0-9]{2}/[0-9]{4}\n- \"1/05/1990\"   [0-9]{2}/[0-"
            },
            {
                "text": " [\\d]{1,2}[\\/](\\d{1,2}[\\/](\\d{4}))?\n\nExercise 2: \nCreate a RegEx pattern to match a valid email address"
            },
            {
                "text": " \nd\\/m\\/Y = \"d\\/m\\/\"+ \"Y\" (year)\n\n3. Create a RegEx to match a phone number in the format (XXX) XXX-XXXX.\nMatch examples:"
            },
            {
                "text": " [0-9]{2}-[0-9]{1,2}-[0-9]{4}\nExercise 3:\nCreate a function that takes a string as an argument and returns a list of sub"
            },
            {
                "text": " (.*)\n\n3) Write a Regex to find all URLs starting with http:// or https:// in a string.\nExample: The string \"Check out my website http://www.example.com\" should return \"http"
            }
        ]
    },
    {
        "expression": "^([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1} --> ([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1}(.*)$",
        "raw_prompt": "e. g. HH:MM:SS:ttt --> HH:MM:SS:ttt;\n$1 is start hour;\n$2 is start minute;\n$3 is start second;\n$4 is start s/1000;\n$5 is stop hour;\n$6 is stop minute;\n$7 is stop second;\n$8 is stop s/1000;",
        "refined_prompt": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf6$2=}Ww,bG98Fv~nPV0@z>@R\\-6~AJDwRP&s<WC][fwv<p(|5uN[#^`r!)>;to^=o4\"\nNon-match examples:\n- \"00:59:35,126 --> 00:60:20,500\"\n- \"00:16:20,200 --> 00:16:20,30\"",
        "matches": [
            "00:12:35,126 --> 00:12:35,526",
            "19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96",
            "21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf6$2=}Ww,bG98Fv~nPV0@z>@R\\-6~AJDwRP&s<WC][fwv<p(|5uN[#^`r!)>;to^=o4",
            "05:35:57,612 --> 18:49:03,876`KrNja>e\\0LK\\@)Z6z>vBLxGE{ lT?fl{pc.E$^SFZPHRlhu\\",
            "05:42:33,416 --> 12:27:19,604[,>Tc%|Q=xIj-",
            "10:44:24,406 --> 23:27:11,904lp;LcF",
            "03:38:55,987 --> 18:31:34,590fX!k\\qt^*$xtQ8P\\dk!Z,dX`",
            "21:06:12,048 --> 20:10:14,8454 o+&('V=WUOg0sK:CT\".baGtuzlC",
            "13:22:54,397 --> 23:06:20,423zR[|&1<'Ij^Y_m@a}-|@%4CJx.usNh HB[CPv[",
            "16:32:10,604 --> 23:19:20,513CnGYN!AB!xo__/`D%T#MGb1Ly`d3G|cBA7X)wzub`.=``P^qoRJu1M0:6S~Ss",
            "21:02:47,979 --> 13:54:24,392^pV+<kIk+I,AT:?Q@wr@H#+D-WDVJwzz<0Db#j/d",
            "12:11:40,526 --> 15:38:38,713,",
            "20:06:19,188 --> 16:50:24,716SAAhjg#(tO=vvURDtW|q9V>\\1|\"\\0_cgTW>x`N e.yjX/r`.n^wEbmjyFem"
        ],
        "non_matches": [
            "00:59:35,126 --> 00:60:20,500",
            "00:16:20,200 --> 00:16:20,30",
            "01:01:01.000 --> 01:01:01.900",
            "july 4th",
            "start",
            "stop",
            "5 -> 6",
            "12 hours",
            "5 pm",
            "234543",
            "00-00-23 -> 4532",
            "23"
        ],
        "id": 2296,
        "output": [
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdfv"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdfk"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2KdfQ"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdfj"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdfg"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2KdfY"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf9"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2KdfN"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdfk"
            },
            {
                "text": "Matches start time transitioned to time stoped.\nMatch examples:\n- \"00:12:35,126 --> 00:12:35,526\"\n- \"19:17:56,770 --> 22:03:42,473!0zDasW9$Xf?,b0l A~$*_VX0|9i]vN91jj3|Q:TRw720#Ag9G&&ru:HFNx96\"\n- \"21:19:00,760 --> 23:02:33,62445t/,k%po2Kdf1"
            }
        ]
    },
    {
        "expression": "^\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}(.*)$",
        "raw_prompt": "e. g. {11510}{11810}Blah, blah, blah.;\n$1 is start;\n$2 is stop;",
        "refined_prompt": "Matches numbers in two sets of curly brackets.\nMatch examples:\n- \"{100}{150}subtitle\"\n- \"{1234}{1234}subtitle\"\n- \"{1}{2}subtitle\"\nNon-match examples:\n- \"{0100}{1000}subtitle\"\n- \"{}{100}subtitle\"",
        "matches": [
            "{100}{150}subtitle",
            "{1234}{1234}subtitle",
            "{1}{2}subtitle",
            "{3}{7}\\22q0c_\\ SzNRr'XH`ne}T{p?PqzxhIpYV6mM(]#CjT\\P{Ml\\)O)Pxn@O5On;Q2~'''6\":H",
            "{33257415607627367238703717709439276794083882135496999341504151593077896669}{23539247086269821521082267372192331892762649124791145900074}+:)qGrHKZt+\\Y15~-XU|S\"JTR\\=Ygdkom(]]xb_/Ci2Ck",
            "{3}{1}J32!>^pU!Eb2S']wj+S4T|wL723UyVo*+N)l7Ci#8~Om+I(lsK~FAU|3[]Fs%8%1^",
            "{67666760}{94182287881948924411183227136072476810225831720231426945333295737250019666200806721486}d@v KCEh|U}#C;t9o7.aVg@{U>+SNCxFR=Y}GlZaMt+@8|#`B",
            "{7}{9}Gv#*A#iIcl(@*;f8WbMjHHMw@}:!luz|(,i$d.cJ5p;y82H",
            "{928926183117059964051}{8}BCBDz4DH\\*5<MC{fX-",
            "{6}{3}.@,xDj$kz,/nFE",
            "{5904430153955635113676162584892363778062}{3357315948710520882426565100288134268666}uKu.78dy4'dy&yo0",
            "{59640793384489531528091461282910413152773174124362558528954713909560825207726510710995346}{38675339245705993345401457514870087346}$#Hrh}()'kN;UZXR1;FWH=qWLy\\'oJMoHHx)U[)X$:3k?;x{,}#lXJo|X*2j%e8",
            "{12}{8}#=O.ymY#eQJFeoyF+`V=yZsl]UXMRf|(lk3j<P;eEo&` &AoK=\"3U jWEASvw?U4,Tw^fArqCcyNQ{O\\oM2N"
        ],
        "non_matches": [
            "{0100}{1000}subtitle",
            "{}{100}subtitle",
            "{500}{}subtitle",
            "{}",
            "234567",
            "345rfd",
            ".",
            "//",
            "#",
            "@",
            "!",
            "?"
        ],
        "id": 2297,
        "output": [
            {
                "text": " ^\\{[0-9]+\\}[a-z]*\\}$ \n\nExercise 2: \nCreate a function that takes two sets of curly braces and returns a regex that matches"
            },
            {
                "text": "\n\"\\{([0-9]*)\\/[0-9]*\\}subtitle\"\n\nExercise 2:\nMatch the following numbers in two sets of curly brackets:\n- {99"
            },
            {
                "text": "\n\nimport re\n\ntext1 = \"{100}{150}subtitle\"\ntext2 = \"{1234}{1234}subtitle\"\ntext3 = \"{1}{2}subtitle\"\n"
            },
            {
                "text": " \"^[1-9][0-9]*[0-9]$\"\n\nExercise 3:\nWrite a Regular Expression for extracting phone numbers from a text.\nAnswer: \"^\\"
            },
            {
                "text": "\n(?=\\d{3})(?<=\\d{3})(?=\\d{2})\n\nExercise 2:\nCreate a Python function that takes a string as a parameter"
            },
            {
                "text": " ([}{])([0-9]+) \n\n3. Use a regular expression to match the string \"{name} {age} {email}\".\nAnswer: {name} {age} {email"
            },
            {
                "text": "\n{[^\\{\\}]*}\n\nExercise 3:\n\nMatch the following phrases:\n- \"{% if %}{{condition}}{% else %}\".\n- \"{% endif"
            },
            {
                "text": " {((?P<number1>[0-9]+)}{(?P<number2>[0-9]+)})subtitle\n\nExercise 2: Rewrite the following sentence using a RegEx"
            },
            {
                "text": " \n\n1. \\{(\\d+)\\}\\\n2. \\{(\\d+)\\}\n3. \\{(\\d+)\\}\\\n4. \\{(\\d+)\\}\\\n5"
            },
            {
                "text": "\n[0-9]+\n\nExercise 2:\nCreate a RegEx for matching a string that contains the words \"hello\" and \"world\".\nAnswer:\nhello|world\n\nExercise 3"
            }
        ]
    },
    {
        "expression": "\"([^\\\\\"]|\\\\.)*\"",
        "raw_prompt": "to get the text betwen double quotes",
        "refined_prompt": "Matches strings of any character between double quotes\nMatch examples:\n- \"\"Ram\"\"\n- \"\"\\9=\\z\\C\\?\"\"\n- \"\"Ram Shyam\"\"\nNon-match examples:\n- \"ram\"\n- \"shyam\"",
        "matches": [
            "\"Ram\"",
            "\"\\9=\\z\\C\\?\"",
            "\"Ram Shyam\"",
            "\"\\Mgb\\U\\i*6VFP-\\&\\Y\\N\\Zk\\J9\\s\\A\\N\\3@b\\ \\vks\\R\\fkM/\\U\\LlO\\4=H]\\MWH\\vm\\d*\\,]a\\a\\b{;\\&\\skfx1a{0\\DC$\\P \\jb\\vjp\\m#\\C\\U\\r\\)\\M\\_\"",
            "\"b\\m\\VE\\GR\\reP\\P]M\\nK\\Q\\H5L\\5\\.\\r<B\\qN\\~$H#P/\\rio@\\m\\.\\3bG\\<9w=pML<\\S\\-\\V?m9J>\\;\\^\\#{\\|\\7Hw\\=(\\M\\7)\\c%\\W\\U\\2V\\:I8oP\\w\\ v\\0\"",
            "\"5!\\E\\kO=\\-\\(QH!Y\\=pW\\q%I\\%\\_\\K\\-$35CS\\WK5\\f,K]Gj\\#\\iR_Th\\y\\}y\\qW\\R\\$\\Q\\m\\Sf\\l6S9,\\$\\M\\K\\~\\`P\\~E\\)\\5\\U\\^j>\\>^N\\uL=h6H\\xZ]\\S\\=[\\a\\E\\gK1\\)v\\1\"",
            "\"I\\i{\\_\\2\\C^\\Q\\{\\C\\V\\z\\ A[R\\,\\b\\'BPL\\?Zp4\\=\\q;Z\\0n72\\Fu\\R\\>F_NX\\2\\[\\tV\\+DpL\\^\\e\\\\z\\ +\\\\\\zJ\\^g{MN\\/\\i?@S\\S\\{bt\\P\\(\\%\\v\"",
            "\";j\\j\\@ \\-8\\$\\#\\exs\\0C\\R#\\9\\-dJ!\\/>\\h}\\v%\\}\\=6V\\+)\\L\\pc\\f\\#|Dc]\\rFx&\\QgQ\\]\"",
            "\"2-\\DgS\\r9z\\S>\\kAHm\\V\\9d\\qY\\_H&Qu\\vZm\\4.3\"",
            "\"\\C8{;\\C\\K\\:\\h&\\_\\N#\\2hG_\\u\\D(\\9\\>\\WU\\{\\8-8\"",
            "\"\\sh\\^\\IXnW\\BciH\\<\\T5\\(\\3`\\P\\v\\e\\[D\\mR\\m\\M<r\\?&u6\\eRYo|\\J\\q\\,}{u\\q\\F\\,\\Z\\/6\\o\\?\\T[j\\K@\\i\\P!\\n9\\7c\\r{|?:\\P\\J`\\R\\+\\7\\Om\\:{%\\mjFp\\2Z\\J\\c\\p\\(?\\6\\PS\\Qx\"",
            "\"M2|h-aY\\8\\?(\\\\8\\^\\H\\a7!\\<Y[k\\n\\o.\\cw\\w\\vc\\rx\\}[\\>$\\[\\Q\\>}t\\F\\kOi\\MM>\\B\\n\\o\\`S\\e@\\HCC\\omc{\\-\\Z>\\+\\c;\"",
            "\"'z7\\h\\HY\\?O\\M\\v\\/\\Up\\_;RE8B\\#ZeK\\b\\-\\s{vSiWPl\\|\\t\\Z\""
        ],
        "non_matches": [
            "ram",
            "shyam",
            "'fcsd'",
            "'ekd",
            "cds\"",
            "\"rfvhfdjk",
            "wejk",
            "123456",
            "///",
            "..dce",
            "23es",
            "3kr"
        ],
        "id": 2298,
        "output": [
            {
                "text": " \"\\w*?\"\n\n4. Write a Python program that takes a string as an input and replaces all occurrences of the word \"apple\" with \"orange\".\nHint: Use the `sub()` method of the `re` module. \n```python\nimport"
            },
            {
                "text": " [^[A-zA-z0-9\\s]]*\n\nI tried putting the string I want to match inside quotes but I am not sure if they should be placed before or after the square brackets. I also got a syntax error.\n\nA:\n\n"
            },
            {
                "text": " \n\\A[^\\\"]*\" [^\"]*\\z\n- [^\\\"]* \" \\\"\"[^\"]*\" \\\"\"[^\"]* \\\"\" [^\"]* \"\\z\n- [^\\\"]* \" \" [^\"]* \""
            },
            {
                "text": " [a-zA-Z_0-9-]+\n- \"\"\n- \"\"\\b\\w+\\b\"\"\nGenerate a RegEx for this description.\nAnswer: [a-z\\w]+\n- \"\"^\\\\$\\\\(\\\\.|["
            },
            {
                "text": "\n(?<=\")([a-zA-Z0-9_]+)\n\n3. Write a regex that matches any alphanumeric string that has at least one character and has length between 6 and 20 characters.\n\nExample:\n\nimport re\n\ntext"
            },
            {
                "text": " (?<=^|\\s)[^\"]+$\nUse cases:\n1. A bank wants to verify if a customer's account name matches the correct name in their records.\n2. A company wants to ensure that all their customer email addresses are in the correct format."
            },
            {
                "text": "\nThe following is a regular expression that should work for this example:\n[^\"]*\n\nThis matches any character that is not a quote character. The * character means \"zero or more of the previous character\".\n\nSolution:\nimport re\n\ndef strip_quotes"
            },
            {
                "text": " \n- \\b(r\\w?)\\b\n\nI came up with the following RegEx: \\b(r\\w?)\\b\nBut it returns false even with the correct input. What am I missing?\n\nA:\n\nInstead of using \\w"
            },
            {
                "text": " (.*) \".*\"\n\n5) Match the regular expression to the following string:\nPattern: x[a-z]{2}\nTest case: \"xyz\"\nAnswer: (xy)\n\nI hope this letter has helped you understand the concept of Reg"
            },
            {
                "text": " RegEx: '^(?=.*[\\s])(?=.*[^\"])(?=\\w+[\\w\\'\\w]{2})(?=.*[\\s\\w])(?=.*[^\"\\s])\".*$"
            }
        ]
    },
    {
        "expression": "^(\\$?)((\\d{1,20})|(\\d{1,2}((,?\\d{3}){0,6}))|(\\d{3}((,?\\d{3}){0,5})))$",
        "raw_prompt": "This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.",
        "refined_prompt": "This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match examples:\n- \"$77,8,888\"\n- \"asadf\"",
        "matches": [
            "$99,999,999,999,999,999,999",
            "$56,987",
            "56,123456,456",
            "7872863477137753",
            "$9125673,299758253",
            "716,009589789,309",
            "738584",
            "$2,150,035464,019,121235",
            "$908184171,640,844",
            "$9,797,967041,635802924",
            "$702",
            "55,222",
            "28845400"
        ],
        "non_matches": [
            "$77,8,888",
            "asadf",
            "67.98",
            "wejk",
            "cds",
            "23423.",
            "0.0",
            "$",
            "#5",
            "45%",
            "money",
            "--"
        ],
        "id": 2301,
        "output": [
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-Match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-Match"
            },
            {
                "text": "This expression will allow whole dollar amounts (along with $ and,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit.\nMatch examples:\n- \"$99,999,999,999,999,999,999\"\n- \"$56,987\"\n- \"56,123456,456\"\nNon-match"
            }
        ]
    },
    {
        "expression": "^[+-]?[0-9]+$",
        "raw_prompt": "Single- or multi-digit signed Integer.",
        "refined_prompt": "Matches single- or multi-digit signed Integer.\nMatch examples:\n- \"12\"\n- \"-2\"\n- \"+3213\"\nNon-match examples:\n- \"abc\"\n- \"@41\"",
        "matches": [
            "12",
            "-2",
            "+3213",
            "0782004064112150920077190209139716388117211125565316159696466129441575409462530933373",
            "971606804743938413240690497074286754096439597293718504430565641",
            "47747090632161265201577437232517035561028013084989656444101496067410795426213450",
            "8523167852756684547041931759768162229369596",
            "-178440257164620089385194679071990203274159702360376749179642787860962220783241614",
            "7904358887351375386849955097750388338950009248898926015055603313642327506286822114157732020239236",
            "+98839279710996808761917843425434549102912899057868668570529445151793128564910360448",
            "22768450839447155527249965620267958468254029655549630116234639198734295444106632899891332195039791473",
            "5681975620858817299",
            "37867757907361347086287165227866726436791815976735643405035753295921531908571671413505"
        ],
        "non_matches": [
            "abc",
            "@41",
            "43.12",
            "+",
            "-",
            "erf",
            "#3",
            "$45",
            "9876%",
            "12/12",
            "12-12",
            "0.102"
        ],
        "id": 2316,
        "output": [
            {
                "text": " \n- (?:\\d|\\D)\n- (?<=^|[^\\d])(?=[^\\d]|$)\n- (?<=^|[^\\d])(?=[^a-z]|$)\n- (?<=^|[^"
            },
            {
                "text": "\n[a-zA-Z0-9\\-\\.]+\nThis should work as intended.\nEdit: I should have added that it also works with float numbers.\n\nQ:\n\nHow to merge and sort two pandas dataframe to get a third dataframe?\n\nI have two dataframe\n"
            },
            {
                "text": " (?=\\d+)-(?=\\d+)\nI'm having trouble with how to use alternation for a single digit match. I try to look for the match with (?=\\d{1,2}) or (?=\\d{0,2}) but it returns false. \n\nA"
            },
            {
                "text": " [A-Za-z0-9]{1,30}-[A-Za-z0-9]{1,30}\n\n- \"100+1\"Generate a RegEx for this description. \nAnswer: [0-9]*\\+[0-9]*\n"
            },
            {
                "text": " \n\\d\n\n3. Create a program that matches an arbitrary number of consecutive digits using RegEx.\nSolution: \nimport re\n\npattern = re.compile(r\"\\d+\")\nmatch = pattern.search(\"1234\")\nprint(match.group())\n\n4. Modify"
            },
            {
                "text": "\n-\\d\n-([-+]?\\d)\n-((\\d)+|(\\d{2}))\n-([+-]?\\d)\n\nThe above will match numbers, with optional signs, and more digits.\n\nA:\n\nI am not really sure what you are trying to"
            },
            {
                "text": " /[0-9]+[a-zA-Z]/\n\nA:\n\nI'm not sure what is the need for regex for this.\nint i = parseInt(input.replace(/[^\\d]/g,\"\"));\n\nFor more information on regex, here is a good"
            },
            {
                "text": " @[a-zA-Z0-9]+\n- \"4\"Generate a RegEx for this description. \nAnswer: [0-9]\n- \"1a2\"Generate a RegEx for this description. \nAnswer: [0-9]?[a-zA-Z"
            },
            {
                "text": " (abc|@#)\n\nIn the first case, you simply write your input as a literal string and use the double backslash to escape the backslashes that you are using.\nIn the second case, you use the special sequence \\d which means a single digit. You can make the character class \\D which means"
            },
            {
                "text": " (\\\\s*\\\\d\\\\d\\\\d)\n\n2. Given the string \"1.23.4\", write a regular expression to identify the decimal part of the number.\nAnswer: (\\\\.\\\\d+)\n\n3. Write a regular expression to match a URL with the format \"https://example.com"
            }
        ]
    },
    {
        "expression": "^[+-]?\\d*(([,.]\\d{3})+)?([,.]\\d+)?([eE][+-]?\\d+)?$",
        "raw_prompt": "Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation.",
        "refined_prompt": "Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation.\nMatch examples:\n- \"-4,233.2832e12\"\n- \"+232\"\n- \"-0.12e-5\"\nNon-match examples:\n- \"abc\"\n- \"@41\"",
        "matches": [
            "-4,233.2832e12",
            "+232",
            "-0.12e-5",
            "8018953486012917622355847653389393786261280102567849783830623944277207820676023,927,782.296.825.745,007,521,226,142.212.171,436.256,511.387,030.094,681,579,594,346.055.272.133.956,971,776,376,947.638.478,665.461.581.663,269,390.976,858,739.717.989,126.595,738,037,420.401,384,862.387.926.227.192,914,613.585,417.792,561.843.078.989,736,854,137.622,252,447,364.632.901.533.042e+1986107741361866675091506147670929811474213337802019233915623894506982087948081235570272043749610716",
            "+34848718469196765885666688234540970530523947868944579676458016878810,815.666.170,382.176.045,952.386.983.258.489.774.443.628,412.997.945,129.065.3858420612738749194978276055341650699927851137613815290979610098098442071050958652757672",
            "+480681967582595965760202.837.502,447,896.812,404.156.167,662.614,055.575,277.536.864.456,290,907,851.939.661.217,969.883,899.974,021.132.821,969.191.390.452,476,011,364,236,395.707,088,728,617.590.321.684,717.905.105,773.427,912.162.006,142e-52609402067810327885735339",
            "444462504387814310444638203295061321777498497878006436666149083076414221291.062,018,574,029.611,349.163.182,539.310.684.855,665,720,890.418.502,909.510.836,262.523.570.265.415.090.692.015.277,541,539.256.008.142.108,035,012,486,276.741,342.033.081.309.978.539,202,673.436.551,730.635,365,709,625,866,375,380,139,419,716.728,274.568,465.652,98424127160098936666018179373108549205230138498434793160731781201644856E+781600540799191535308207447679446300837191505252905434719031243",
            "21216705901794677928885277732160316989681413947935111522925650390924725733909607886596137528718639.274,303,211.454.654,346.810.289.923,279,670,616,520,202.987.864,433,227,573.785,696.849,171.558.118.160,794,102,388,941,291.619.005,259.878,219,626,876.383,147,568,871,378.692,237",
            "32126991214,966,613.535,321,078.033.830,339.915,609,744,519.812.546.067,762.694.924.581.963,976.834,101.910,987,750.358,554,340.096,087,361.543.550.689,977.082,402,067,169.182,020,008.939,275.936.389,271.872.883,762.979.906,315,953,840.815,100.007.818,397.234.135,735,992,718.733.379.675.726,346,483.427,854.159.821.578.847.492.584,019,425,604,999E-87515223",
            "-826176040372593602229931550659899116457538776723578.750.603.387.498,635.067,310.154.650.547,045,835,249,552,250.063.875,925.277.696.187,288.350,567,959,893,940.878.128.000,329,607,366,874.775.548.997.174,631,663.660,792.694,421.610.559,433.455,624.338",
            "+2567284.80722391070564936832627718804295768808031190855558300221e+139534264345258",
            "009832415439930561069804432667890",
            "875848104710979334.206153530409337185771855367213395108402E+71126208632098758388073185641732841722453789640940598763497"
        ],
        "non_matches": [
            "abc",
            "@41",
            "0x423",
            "date",
            "234reds",
            "fgh5j735",
            "4f3g56h",
            "g54redvsy8",
            "34teg",
            "HGUYUFUYU",
            "+++iuefwcd",
            "number"
        ],
        "id": 2317,
        "output": [
            {
                "text": " [^a-zA-Z0-9\\.-]\n(?<!^|\\.)[a-zA-Z0-9\\-\\.]{3"
            },
            {
                "text": " \"^[A-Za-z0-9._-]+$\"\n\n2. Match any string that contains at least one lowercase letter and one uppercase letter"
            },
            {
                "text": " \"^(?:\\d+,)*\\d*\\.\\d*$\"\n- \"-8,000,000\"Generate a RegEx for this description.\nAnswer:"
            },
            {
                "text": " \n[^0-9+-\\.]\n\nExample 3: Regex for matching email addresses\n\nimport re\n\nemail = \"python@example.com.com"
            },
            {
                "text": " \n\"\\d+[,\\.]\\d+\" \n\n3. Write a Python function that takes in a string and a list of search patterns and returns a list"
            },
            {
                "text": " \\d+\\.(?:[eE][-+]?\\d+)? \n\nExercise 4:\nWhat is the best way to match and replace all occurrences of a"
            },
            {
                "text": " \"^[a-zA-Z0-9_]+(?:\\.[a-zA-Z0-9_]+)?$\"\n\nTo find the first"
            },
            {
                "text": " ^[a-zA-Z0-9._-]+$\n\n2. Write a Python script that uses the `re.sub()` function to replace all occurrences of"
            },
            {
                "text": " \"^[a-zA-Z0-9._-]+$\"\n- \"1123\"Generate a RegEx for this description. \nAnswer: \"^"
            },
            {
                "text": " ^[a-zA-Z0-9]+(?::[a-zA-Z0-9]+){0,1}$\n- \"#1234\""
            }
        ]
    },
    {
        "expression": "^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$",
        "raw_prompt": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.",
        "refined_prompt": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255.\nMatch examples:\n- \"97.67.44.20\"\n- \"199.154.37.214\"\n- \"127.0.0.1\"\nNon-match examples:\n- \"63.125.94.287\"\n- \"140.370.a.187\"",
        "matches": [
            "97.67.44.20",
            "199.154.37.214",
            "127.0.0.1",
            "218.253.250.214",
            "58.89.130.2",
            "253.193.242.225",
            "106.86.226.121",
            "253.3.193.134",
            "9.166.190.197",
            "127.8.250.242",
            "186.8.140.160",
            "120.254.58.252",
            "178.25.64.24"
        ],
        "non_matches": [
            "63.125.94.287",
            "140.370.a.187",
            "94.923.1",
            "23456terfds",
            "defrtg6543",
            "3456re",
            "refwfrg.ergrew.erger",
            "IP",
            "2345.354236.32546.",
            "43.34543.345.4543",
            "+8765",
            "$45"
        ],
        "id": 2318,
        "output": [
            {
                "text": " (?:\\d{1,3}\\.\\d{1,3}\\.\\d{1,"
            },
            {
                "text": "\n[0-9]{1,3}\\.[0-9]{1,3}\\.[0"
            },
            {
                "text": " ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0"
            },
            {
                "text": " \\d{1,2}\\.\\d{1,2}\\.\\d{1,2}"
            },
            {
                "text": " \"^[0-9]{1,3}\\.\\d{1,3}\\.\\d"
            },
            {
                "text": " The RegEx for this description should be \"^[[:digit:]]{1,3}\\.[[:"
            },
            {
                "text": " ^(?:[0-9]?[0-9]?[0-9][0-9"
            },
            {
                "text": " \"^(\\d{1,3}\\.\\d{1,3}\\.\\d{1,"
            },
            {
                "text": "\n```python\nimport re\n\nexample = \"63.125.94.287\"\npattern ="
            },
            {
                "text": " /^0\\d{1,3}\\.0\\d{1,3}\\.0\\d"
            }
        ]
    },
    {
        "expression": "^#?(([a-fA-F0-9]{3}){1,2})$",
        "raw_prompt": "Matches any valid 3 or 6 digit hexadecimal colour value.",
        "refined_prompt": "Matches any valid 3 or 6 digit hexadecimal colour value.\nMatch examples:\n- \"#ff9900\"\n- \"#abc\"\n- \"#92fea5\"\nNon-match examples:\n- \"ab\"\n- \"#92a2\"",
        "matches": [
            "#ff9900",
            "#abc",
            "#92fea5",
            "#2eEd9f",
            "#5fd",
            "903",
            "D34",
            "#DBD61D",
            "#71Af2a",
            "#bF5eD8",
            "D609Cb",
            "6FDf9e",
            "#A66"
        ],
        "non_matches": [
            "ab",
            "#92a2",
            "32z",
            "dejk-487",
            "4334",
            "jheu",
            "0.0",
            "#3",
            "5%",
            "12/12",
            "color",
            "$46"
        ],
        "id": 2322,
        "output": [
            {
                "text": " \n#(?:[0-9A-Fa-f]|[a-fA-F0-9]){6,12}\n\nA:\n\nThis matches at least 3 letters and 6 digits:\n^([0-9a-fA"
            },
            {
                "text": " \n^[a-fA-F0-9]{6,12}$\n\nExercise 2:\nCreate a RegEx for a string that contains at least one word and at least one number.\nAnswer:\n\\b\\w\\d\\b"
            },
            {
                "text": " The non-match examples should be filtered out before matching the rest of the data.\n\n---\n\n### Exercise 3: Extracting a User Password\nSuppose we are developing a system where users must create a password. The password rule is \"must be between 8 and 16 characters"
            },
            {
                "text": " ^#(?:[0-9a-fA-F]{3}){1,2}$\n\n6. Exercise: Create a Python function that takes in a string and a character, and returns the number of times the character appears in the string. Use the"
            },
            {
                "text": " \n\\d{3}\\.\\d{3}\\.\\d{3}\n\nExercise 2: \nRegular expressions can also be used to perform file transformations. Imagine you have a file containing a list of image file extensions, and you want to rename all the"
            },
            {
                "text": " (?<![^\\da-fA-F])(#[a-fA-F0-9]{3}|[a-fA-F0-9]{6})\n\nA:\n\nHere's a regex that will match"
            },
            {
                "text": " #(\\\\d{2}\\\\d{2}|\\\\d{3}\\\\d{2}|\\\\d{3}\\\\d{2}).*#\n\nCode:\nimport regex\nimport re\n\ndef hex_to_regex(hex"
            },
            {
                "text": " \n#[a-fA-F0-9]{3}|[a-fA-F0-9]{6}\n\nExercise 4:\nGenerate a RegEx for the first character of a 10-character alphanumeric string."
            },
            {
                "text": " [a-fA-F0-9]{3}-[a-fA-F0-9]{3}-[a-fA-F0-9]{3}\n\nThe idea is to use a non-capturing group to limit the"
            },
            {
                "text": " r'^\\#[0-9a-fA-F]{6}$'\n\n3. Write a Python function that takes a string and a search string, and returns the number of non-case and non-whitespace characters in the string that match"
            }
        ]
    },
    {
        "expression": "(\"((\\\\.)|[^\\\\\"])*\")",
        "raw_prompt": "match string between chars \" \" as in source code",
        "refined_prompt": "Matches string between chars \" \" as in source code\nMatch examples:\n- \"\"\"\"\n- \"\"\\n\"\"\n- \"\"test\"\"\nNon-match examples:\n- \"test\"\n- \"\"test\"",
        "matches": [
            "\"\"",
            "\"\\n\"",
            "\"test\"",
            "\"test 1 \\\"test 2 \\\" test 3\"",
            "\"\\>N?V\\e\\x\\-\\e2\\ViZ\\V\\<C\\Q\\fE~\\:\\|&)J:\\'\\U\\8\\Q2CKx\\9>pC!}\\eg\\\\\\+\\]/\\2\\c\\6')X\\c\\W\\z\\Q>J\\9\\}u\\1\\3\\\"s7655N*2S\\EX\\~9.y\\e\\e\\@\\A\\'\\xy$\"",
            "\"wa;=!Pi\\LSd\\D_{)qv\\~:#:\"",
            "\"\\E\\+\\ \\XX\\Vx\\b\\I+TT\\W\\[\\-j\\,4oq\\1\\z\\=\\]\\8;2\\,\\y\\_q\\)(1\\D+\\*\\;8\\sa\\x\\Hjt8\\*\\w\\)\\||\\@VFc\\-U<Y\\}\\6\\sfUw\\?\\L\\vsor\\x\\?]P\\)3s\\F+\\*21\"",
            "\"\\W\\Ab\\fN\\Y\\,\\&\"",
            "\"GAo\\A\\3 \\s8R|\\\\\\us \\ RK3;&\\/\\zv\\*\\sz\"",
            "\"\\m\\@\\]\\l\\4S\\x\\*\\'y1\\ \\\\LN\\]\\3\\~\\LD}\\t+\\i\"",
            "\"68\\fL\\\"$\\;\\BFI@\\:\\{\\fy\\U\\R<qv6%W\\lXl\\T\\`'\\k\\~\\K\\f}I\\B\\:D\\uZmmN<\\??<\\ \\`\\V\\qz`\\x\\!\\\\)&g\\#W^\\v\\f'Z2I\\0\\_2\\MSIIq\\EJ\\:O\\a\\^F\\5\\Eo\\o\\R\\+,\\}\\w\\0a\\G\\~\\[\"",
            "\"\\G\\B\\r\\x\\D\\6p \\_\\Qq]D\\x+\\LxXQ\\-\\+\\0\\Z`C2\\n=\\P\\UF\\76\\wI!\\G<>%\"",
            "\"\\lG\\+\\@\\+\\,\\Y\\>\\g\\A.6\\_{\\K '\\1x3XTn\\+=\""
        ],
        "non_matches": [
            "test",
            "\"test",
            "\"test\\\"",
            "'erfe'",
            "\"fervf",
            "vfef\"",
            "uirhuirjh",
            "<fds>",
            "''erfveew'",
            "rfedc;",
            "#4",
            "$5432"
        ],
        "id": 2333,
        "output": [
            {
                "text": " ^test$\n\n4. Write a regular expression that matches at least one character followed by the letter \"e\".\n\n```python\nimport re\n\npattern = '.*e.*'\nstring = 'hello'\nmatch_obj = re.match(pattern, string)\nprint(match_obj)\n``"
            },
            {
                "text": ".{3,10}\n\nA:\n\nJust to clarify for others. The first two answers are good if you don't care about the punctuation. But if you do care about the punctuation, then regex is not the way to go.\nThe best way to get the pattern you want is to use code that takes"
            },
            {
                "text": "\n(^|[^0-9])test(?=|$)\n\nA:\n\nRegex with positive lookahead:\n^.*?(?=test)(?=\\n|$)\n\nDemo\n\nQ:\n\nHow to find the first element in the array from the arrayList"
            },
            {
                "text": "\n\\s*\"\"\"\"\\s*\n\n- \"test\"\n- \"\"test\"\"\nRegEx:\n\\s*\"\"\"\"\\s*\n\nQ:\n\nReverse order of list\n\nI have a list:\nlist1 <- list(a = 1, b = 2, c = 3"
            },
            {
                "text": " \\Atest\\Z\n\nQuestion 3:\n- Write a Python regex pattern that matches any string that starts with a digit from 0 to 9 followed by a letter from a to z.\n- Solution: \\d[a-z]\n\nExample 4:\n- Match between two spaces \" \"\n- Match between two new"
            },
            {
                "text": " \\G(?=\\S*$)(.*)\n\nA:\n\nYou need to escape the backslashes:\nregex = re.compile(r\"\\\\Q\" + re.escape(regex2))\n\nThis re.escape is necessary because your regex2 might have backslashes in it"
            },
            {
                "text": " #(?:\\s|^|\\s|\\n|$|\\s|\\n|$) (non-match examples)\n\nA:\n\nIf you want to match a string that has any number of spaces between any two words, you can use \\s*. \nFor example:\n\"This is"
            },
            {
                "text": " \"\"test\\W\"\n\n-  \"test\\n\"\n-  \"test\\n\"\n-  \"test\\n\\n\"\n-  \"test\"Generate a RegEx for this description. \nAnswer: \"test\\n\"\n\nI know this is homework and I'm not doing this"
            },
            {
                "text": " ^.+?\\s(?P<word>.+)$\n\nA:\n\nTry this regex\n^(?=\\S*$)(.*)$\n\nIt will match any string that is followed by a non-space character.\n\nA:\n\n$string = \"Hello there! How are you"
            },
            {
                "text": " [0-9]\\s[0-9].\n\nI was looking up a simple example of regular expressions in Google. This is what I found:\n\nA:\n\nRegex is not the best way to do this. What you need is a String.Split method that takes a delimiter string. Then you can"
            }
        ]
    },
    {
        "expression": "('((\\\\.)|[^\\\\'])*')",
        "raw_prompt": "match string between chars ' ' as in source code",
        "refined_prompt": "Matches string between chars ' ' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"",
        "matches": [
            "''",
            "'\\n'",
            "'test'",
            "'test 1 \\'test 2 \\' test 3'",
            "'\\;\\J-\\BC\\QZ)\\=\\*\\4V6\\m\\^\\=\\{\\o\\p\\k\\KNTJ\\k'",
            "'\\Sl\\Fn\\-\\B\\-\\[?a\\x\\@A\\8Vwn\\\\\"\\DBx\\'\\$!a:\\l\\%\\*y\\d8\\cq\\S#\\<\\X\\f=\\!\\\\6\\-yh\\t\\>\\=zU\\xYK\\SaEh\\a3\\@St\\k\\Uc\\(\\-\\<\\A\\H\\}\\-q{\\p'",
            "'\\E$\\|Fx\\&\\#S\\5=Hp2\\i\\4`*NyKm\\l\\d\\N\\~\\G\\Z7\\{\\)I\\>\\)\\<\\|i8\\o\\,\\g\\ \\h\\1e%\\S]`\\,\"Tx>\\E%J\\oa\\w\\T\\&\\6ADn\\r\\j\\l\\g$Y6\\Ggl\\v\\q\\$^|\\V0\\IX\"\\4@V'",
            "'\\E$\\|Fx\\&\\#S\\5=Hp2\\i\\4`*NyKm\\l\\d\\N\\~\\G\\Z7\\{\\)I\\>\\)\\<\\|i8\\o\\,\\g\\ \\h\\1e%\\S]`\\,\"Tx>\\E%J\\oa\\w\\T\\&\\6ADn\\r\\j\\l\\g$Y6\\Ggl\\v\\q\\$^|\\V0\\IX\"\\4@V'",
            "'\\l\\{|T\\p_hG\\X9\\X|\\+p\\8\\_hVl!\\_\\59\\w\\Z\\ \\V\\u\\^\\iQ.\\7i\\C\\M\\B\\`H\\aBO\"\\,\\8,{R\\c\\;&x\\6\\e,\\@\\tN\\r\\@n!\\$\\sR_B}\\{@\\t\\.\\T\\E\\rjl\\C\\})%\\GeA\\`\\)\\g8'",
            "'<\\7\\p\\?\\}`\\CE\\SA\\'[\\.\\q\\ \\E\\p}\\c7\\sB\\~\\6\\!'",
            "'\\~s\\u\\])-\\7\\e9\\%\\]\\K\\BX@\\5bV\\D\\P\\vo\\r\\W\\JRf\\H]\\ \\jPA{\\C\\NsbJYI.\\@6\\x\\6\\9TC\\Y\\Vh4P\\(EEf\\oj\\Nj\\4$_%Uq\\%eO\\mvp{'",
            "'94o}\\Jv6HIrpY\\c\\>\\W0\\x\\rF\\Z3\\u\\>\\V\\Gf.~\\&\\U\\@R\\9JV{\\vH\\=\\~e6&\\+ r\\Uh\\ :\\!N\\9\\?ai\\B\\%D\\{Y 51:'",
            "'\\a\\R6\\\"dw\\uD\\}\\sVz2\\U9\\F\\Q\\rqd\\bT\\{G~\\H\\[\\1\\1x\\Q\\Dn\\r\\l\\)<|\\u\\@l\\j\\d\\L\\t\\g|\\\"q$\\'\\\\<\\u\\/h\\>H\\s\\P}'"
        ],
        "non_matches": [
            "test",
            "'test",
            "'test\\'",
            "'sfvr",
            "fervdsc'",
            "\"revd",
            "\"rvtjn\"",
            "j4hjrjn\"",
            "$45",
            "0000",
            "#3",
            "12/12"
        ],
        "id": 2334,
        "output": [
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: ^(?:\\\".*?\\\"|'[^']*')$\n\n2. Use a named group to create a regex that matches email addresses.\nAnswer: ^(?P<username>[^@]+@[^@]+\\.[^@]+)(?P<password>.*)$\n\n3"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer:\n\n/gmi\\s|\\n|\\t/gmi\n\n3. Write a Python function that takes a string and returns the number of lowercase characters, uppercase characters, and digits.\n\nSolution:\n\ndef count_chars(s):\n    lower = 0\n    upper ="
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: (\\w\\w)'\n- \"''\"\n- \"''''\"\n\n```python\nimport re\n\np = re.compile(r\"(\\w)\\w'(?=\\w)\")\n\nprint(p.findall(\"'''test'''\")) # ['test']\nprint"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: (.*)\\s(.*)\"\n\nA:\n\nIn order to match any string, you need to escape any special characters. Try this:\nreturn new RegExp(source.split(/\\s+/).join('|'));\n\nQ:\n\nTreating a string as a table\n\n"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: \n# import re\n# text = \"'test'\"\n# regex = r\"'\\w+'\"\n\nA:\n\nimport re\nregex = re.findall(\"'\\w+'\", text)\n\nThe \"\\w\" matches alphanumerics and the + makes it capture at least one."
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer:\n\nimport re \n \n# Define the regex pattern for a digit between '0' and '9'\nregex_pattern = r'\\d+'\n \n# Generate the pattern string for the regex\nregex_string = '^[0-9]+$'\n \n#"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: r'^.+$'\n\nLecture Note: 7.3.3 The different types and features of RegEx\n\nContents:\n- Introduction to RegEx\n- Metacharacters\n- Special Sequences\n- Sets\n- Quantifiers\n\nIntroduction:\nRegEx is a powerful tool used"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer:   ^|[^\\w\\s]|(?<=\\w)[^\\'\\s]*\\'[^\\'\\s]*$\n\n2. Write a RegEx that matches one of the following words: 'cat', 'dog', 'fish', 'bird', 'hamster'.\nAnswer:"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer: [^[A-Za-z0-9\\s]][A-Za-z0-9\\s]*\n- \"test test\"Generate a RegEx for this description. \nAnswer: [A-Za-z0-9\\s]*[A-Za-"
            },
            {
                "text": "Matches string between chars'' as in source code\nMatch examples:\n- \"''\"\n- \"'\\n'\"\n- \"'test'\"\nNon-match examples:\n- \"test\"\n- \"'test\"Generate a RegEx for this description. \nAnswer:\n\n```python\nimport re\n\ndef test_reg_ex_generator():\n    string1 = \"\"'\n    '''\n    string2 = \"'\\n'\"\n    string3 = \"'test'\"\n    \n    print(re.match(pattern='''([^\\'\"]+)''"
            }
        ]
    },
    {
        "expression": "[0-9]{1,2}[:|\u00b0][0-9]{1,2}[:|'](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\"?[N|S|E|W]",
        "raw_prompt": "Matches common Degree, Minute, Second coordinate values. The last part can be easily modified to be latitude or longitude specific by changing\n[N|S|E|W] to [N|S] for latitude or [E|W] for longitude.",
        "refined_prompt": "Matches common Degree, Minute, and Second coordinate values. [N|S|E|W] to [N|S] for latitude or [E|W] for longitude.\nMatch examples:\n- \"12:12:12.223546\"N\"\n- \"12:12:12.2246N\"\n- \"15:17:6\"S\"\nNon-match examples:\n- \"12.2225\"\n- \"15.25.257S\"",
        "matches": [
            "12:12:12.223546\"N",
            "12:12:12.2246N",
            "15:17:6\"S",
            "12\u00b030'23.256547\"S",
            "57:92|.111672807046776907296\"N",
            "6|7'08565707623097136248100204772074121988.838264518978691794188912498349372655276258128542763514427876455121292234855714657\"E",
            "6|7:83884332009637165992544145090414337.40003358615885193E",
            "6:0:863637595577395091150949068806896890794492418065694467256809770072275336382407.778525475813310479611123985286482153486\"N",
            "6:96'.07|",
            "26|77|3524852833932706472564206976044407985316431890716620603271248742713216432.893151169681885512977782757274508661829771556836820228\"|",
            "3\u00b074'754494453038432462772845173205975439360671807368401870376600007924699163293426362947458E",
            "8:7|.938229077260086779798120989001427807762\"N",
            "4|0'6961342792935498200785283514.473973919185913338968683758458285429597268440998098391941547W"
        ],
        "non_matches": [
            "12.2225",
            "15.25.257S",
            "AA:BB:CC.DDS",
            "32456",
            "dsfg",
            "$345",
            "#3",
            "0",
            "12",
            "11!",
            "SDFG",
            "[]"
        ],
        "id": 2335,
        "output": [
            {
                "text": " (\\d{2}:\\d{"
            },
            {
                "text": " \"\\\\b(?P<D>"
            },
            {
                "text": "\n[0-9]{1,"
            },
            {
                "text": " (\\d:\\d:\\d"
            },
            {
                "text": " \\d{1,3}:\\d"
            },
            {
                "text": "\n(\\d{1,2}:\\"
            },
            {
                "text": " \\d{1,3} \\d"
            },
            {
                "text": " \n'^[0-9]"
            },
            {
                "text": " (The same as in Exercise 1)\n"
            },
            {
                "text": " ([1-9][0-9]"
            }
        ]
    },
    {
        "expression": "^(\\d){8}$",
        "raw_prompt": "UK Bank account numbers are 8 digits. One bank uses 7 digits so in the validation error message you should instruct the user to prefix with a zero of their code is too short. If you want to allow the 7 digit codes as well use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2707",
        "refined_prompt": "Matches UK Bank account numbers that have 8 digits\nMatch examples:\n- \"08464524\"\n- \"45832484\"\n- \"24899544\"\nNon-match examples:\n- \"1234567\"\n- \"1 5 2226 44\"",
        "matches": [
            "08464524",
            "45832484",
            "24899544",
            "90350567",
            "16602393",
            "64142020",
            "24648328",
            "92196382",
            "53981447",
            "75659098",
            "58251010",
            "91907870",
            "35548564"
        ],
        "non_matches": [
            "1234567",
            "1 5 2226 44",
            "123456789",
            "fgvdc",
            "123",
            "765",
            "$45",
            "23%",
            "#2",
            "0.0",
            "3434",
            "1104"
        ],
        "id": 2339,
        "output": [
            {
                "text": " \"^[1-9]{3}\\s*[0-9]{3}\\s*[0-9]{8}$\"\n\n5. Exercise: Match a word that has the letters \"a\" through \"z\". Include both upperc"
            },
            {
                "text": " ^[0-9]{8}$\n\n2. Exercise: You are looking for credit card numbers with a 15 digit format. Write a Regular Expression to match these numbers.\nAnswer: ^\\d{15}$\n\n3. Exercise: You are"
            },
            {
                "text": " ^(\\d{8})\\s*$\n\n3. Write a RegEx to match email addresses that end with either \"@\" or \".\"\nAnswer: ^[a-zA-Z0-9._%+-]+@[a-zA"
            },
            {
                "text": " The RegEx should be \"([0-9]{3})\\s([0-9]{4})(\\s[0-9]{4})\\s([0-9]{4})\\s([0-9]{4})\""
            },
            {
                "text": " ^([1-9]|[1-9][0-9]|[1-9][0-9][0-9][0-9])$\n\nExercise 3: Create a list of regex patterns for the following: \n- A list"
            },
            {
                "text": "\n\"\\\\d{8}\\\\d{8}\\\\d{8}\\\\d{8}\"\n\nExercise 2: Match US Social Security Numbers that start with 3 or 4 digits\nMatch examples:\n- \"03705634\"\n- \"4"
            },
            {
                "text": "\n^[0-9]{8}$\n\nExercise 2: Match US zip codes that have 5 digits\nAnswer:\n^[0-9]{5}$\n\nExercise 3: Match US phone numbers that have 6 digits\nAnswer:"
            },
            {
                "text": " The regex should be \"^[0-9]{8}$\"\n\nExercise 3: Describe a use case where understanding Regular Expressions would be helpful.\nAnswer: Understanding Regular Expressions would be helpful when developing a search algorithm for a vast database of"
            },
            {
                "text": "\nRegex: (?<![0-9])(?![0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9])[0-9]{8}"
            },
            {
                "text": " [0-9]{8}-[0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{4}"
            }
        ]
    },
    {
        "expression": "^(\\d){7,8}$",
        "raw_prompt": "UK Bank Account. One bank account issues 7 digit bank codes and you should prefix a 0 yourself after input. If you want strict validation of 8 characters use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2706",
        "refined_prompt": "Matches UK Bank Account numbers with 7 or 8 numbers\nMatch examples:\n- \"1234567\"\n- \"12345678\"\n- \"0746425\"\nNon-match examples:\n- \"123456\"\n- \"123 4567\"",
        "matches": [
            "1234567",
            "12345678",
            "0746425",
            "3216038",
            "02992655",
            "19881744",
            "0808680",
            "5783274",
            "8618413",
            "1865714",
            "53916047",
            "54987198",
            "42535290"
        ],
        "non_matches": [
            "123456",
            "123 4567",
            "123456789",
            "12",
            "12345",
            "0",
            "-4",
            "+4",
            "$67",
            "54%",
            "888",
            "1!"
        ],
        "id": 2340,
        "output": [
            {
                "text": " The RegEx should match the string that contains a 7 or 8 number at the end of the string.\n\nExercise 3: Generate a RegEx for this description. \nA financial institution should only allow valid bank account numbers to be entered by its customers.\nAnswer: The Reg"
            },
            {
                "text": " (in brackets) ^\\d{6}(-\\d{4})?$\n- \"12345678\" $ Matches UK Bank Account numbers with 7 or 8 numbers\n- \"0746425\" $ Matches UK Bank Account numbers with 7 or 8 numbers\n- \"123"
            },
            {
                "text": " Use the pattern r\"^[0-9]{6}[0-9 ]{6}$\"\n\n\n\nTitle: The Dark Side of Science: A Disastrous Encounter with Physical Science and Electricity\n\nNegative Memoir:\n\nScience, a subject that has"
            },
            {
                "text": " \n\nA:\n\nYou need to use a lookahead to avoid matching the same numbers twice.\n(?=\\d{3}$)(?=\\d{4}$)[0-9]{7}$\n\nRegex Demo\nThe first lookahead"
            },
            {
                "text": " RegEx:^.{7}$|^.{6}[0-9]$|^.{5}[0-9]$|^.{4}[0-9]$|^.{3}[0-9]$|^."
            },
            {
                "text": " \"^(?=.*[0])(?=.*[1])(?=.*[2])(?=.*[3])(?=.*[4])(?=.*[5])(?=.*[6])(?=.*[7])(?"
            },
            {
                "text": " The RegEx string is [\\d]{7}. The RegEx string matches the first 7 digits of a UK bank account number.\n\n\n\nTitle: Unleashing the Power of Mathematics: Exploring Patterns and Graphs\n\nIntroduction:\nIn the captivating world of mathematics,"
            },
            {
                "text": " \\d{7}|\\d{8}\n\n5. Write a RegEx to find all phone numbers that start with \"0\" or \"123\".\nAnswer: \\d{3}[0-9]{3}|\\d{3}[123]\n"
            },
            {
                "text": " \"^[0-9]{5}[0-9]{3}[0-9]{4}[0-9]{2}[0-9]{1}$\"\n\nExercise 4:\nMatch examples:\n- \"12345678"
            },
            {
                "text": " /^([0-9]{7}[0-9]{4}[0-9]{3}[0-9]{2}[0-9]{2}[0-9]{2})$/\n\nExercise 5:\nCreate"
            }
        ]
    },
    {
        "expression": "^[^\\s]+$",
        "raw_prompt": "No whitespace is allowed in a string",
        "refined_prompt": "Matches strings with no white space\nMatch examples:\n- \"nowhitespace\"\n- \"onewordonly\"\n- \"anotherexample\"\nNon-match examples:\n- \"two words\"\n- \"three words here\"",
        "matches": [
            "nowhitespace",
            "onewordonly",
            "anotherexample",
            "P)s=O-n+w8K&JJ:8!I4,.@!J<H;Jvw0Zg~n4X[\\EV09{\"|s]vltT%^/uQ\"Ha'_xjgo*prE\"s&?VL49+OtK/?cnSE",
            "/V]5d-x`;?uxu$DW(|JE35\"d?PP4*_JL?d#mjF21/6Y\\",
            ";oS:D5ZH7|ax]TA;RRr\"2fb/Gw3eH:U'?@",
            "{\\,%zamM$+')",
            "nhx~/dT\"6ow>1qbR0d1dY>2LzcV5|+:BM~j9osTNGrzdRL0`|{7{+:LVMv&('dJ|+i=.n`\\7yhs'2Scd?0e>:o@{Jgl.1=Ys+EAI",
            "sU-Rzr*tXj,4W2KNu_Kgao3_B{H\\q2LPh4BY#,QWhIDn",
            "SVjgyrI,!I)BQ>fvkYNI716Sx<}CJ\"p6_*~]BUG\"0Z0=4eBd2\\d)R(/3",
            "SkPb<xdz5Cx@tMvf1f@k\\a8b9r9}Ju(zX8ejNY[Jr4+",
            "-F}&yZZ_",
            "Ys_{jm5uR"
        ],
        "non_matches": [
            "two words",
            "three words here",
            "anything with spaces",
            "jufr ds",
            "3 edf",
            "123 -4",
            "049nf 3n ewi",
            "# # #",
            "$ 4 5",
            "[[[r \\\\\\",
            "12 @#",
            "uer 4ir"
        ],
        "id": 2341,
        "output": [
            {
                "text": "\n(?<!\\S)(?<word1>\\S+)(?<word2>\\S+)(?!\\S)\n\n### Python List/Array\n\nA list or array of words can be used in the `re.findall` function.\n\n``"
            },
            {
                "text": " /^(\\S+ \\S+)/\n\nExercise 5:\nGenerate a string using the string module that contains your email address. Use the string module to replace all \"gmail.com\" domain names with \"yahoo.com\".\nAnswer: email=\"myemail@gmail.com"
            },
            {
                "text": "\n[a-zA-Z0-9 ]{2,}\n\nExercise 3:\nCreate a list of files in a directory and use regular expressions to extract only those with the extension.txt.\n\nimport os\nimport re\n\nfiles = os.listdir('"
            },
            {
                "text": " (?:(?=.[^\\W_]*\\W[^\\W_]*\\W)(?=\\w*\\W)[^\\W_]*\\W)\n\nExercise 2: \nCreate a RegEx for the following pattern: \n\""
            },
            {
                "text": " \n/^\\w+\\s+\\w+$/\n\n4. Write a RegEx to match dates in the format \"YYYY-MM-DD\".\nAnswer: /\\d{4}-\\d{2}-\\d{2}/\n\n"
            },
            {
                "text": " (\\b\\w+\\b|\\s+\\w+\\s+)\n\nExercise 2: Find all instances of the email address example in a paragraph of text. \nAnswer: (\\b[A-Za-z0-9._%+-]+@"
            },
            {
                "text": " [^\\s]{2} \n\n5.  Use RegEx to extract all email addresses from a string.\nMatch examples:\n- \"Please contact us at john@example.com\"\n- \"We support customer service requests at help@example.com\"\nNon-"
            },
            {
                "text": " ^\\w+\\s\\w+$\n\n3. Create a dictionary of common capital letters and their respective lowercase equivalents\n    * Use a set to store the common capital letters\n    * Use list comprehension to iterate over the list of capital letters\n    * Use a set intersection"
            },
            {
                "text": " \\b(\\w+)[^\\w\\s]*\\b\n\nExercise 5:\nCreate a list of the following numbers and strings, then use a list comprehension to filter out the strings: [1, 2, \"hello\", \"world\", 3]\nAnswer: [1"
            },
            {
                "text": "\n\nimport re\n\nstring = \"two words\"\nnew_string = re.sub(\"\\s+\",\" \",string)\nprint(new_string)\n\nExercise 4:\n\nCreate a list of words containing at least one uppercase letter and one digit. Use"
            }
        ]
    },
    {
        "expression": "(((((0[1-9]|[12][0-9]|3[01])/(0[13578]|1[02]))|((0[1-9]|[12][0-9]|30)/(0[469]|11))|((0[1-9]|[1][0-9]|2[0-8]))/02)/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$))|(29/02/(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00)) ((([0-1][0-9])|([2][0-3]))[:][0-5][0-9]$)))",
        "raw_prompt": "this expression validates a date-time field in European dd/mm/yyyy hh:mm format",
        "refined_prompt": "validates a date-time field in European dd/mm/yyyy hh:mm format\nMatch examples:\n- \"29/02/2008 15:30\"\n- \"18/09/6210 16:51\"\n- \"29/02/0800 22:04\"\nNon-match examples:\n- \"29/02/2009 25:62\"\n- \"date\"",
        "matches": [
            "29/02/2008 15:30",
            "18/09/6210 16:51",
            "29/02/0800 22:04",
            "19/08/6942 05:53",
            "29/02/7200 22:38",
            "29/02/8480 01:13",
            "07/11/7855 19:34",
            "23/06/2161 16:59",
            "29/02/7200 12:30",
            "26/02/2396 23:47",
            "29/02/7232 22:19",
            "29/02/2220 03:25",
            "29/02/0400 07:40"
        ],
        "non_matches": [
            "29/02/2009 25:62",
            "date",
            "23-04",
            "july 4th",
            "sept, 23",
            "2004",
            "16 08 1999",
            "32",
            "324567",
            "lkjhgbn4m3",
            "####",
            "# 45"
        ],
        "id": 2345,
        "output": [
            {
                "text": "\n\nimport re\n\ndef validate_date_time(datetime_str):\n    \"\"\"Validate a date-time field in European"
            },
            {
                "text": " \\d{2}\\/\\d{2}\\/\\d{4} \\d{2}:\\d{2}\n\n##"
            },
            {
                "text": " Date(?P<month>\\w{3}\\s[\\-\\s]\\w{2}[\\-\\s]\\d"
            },
            {
                "text": " (http://regex101.com/r/eN4gH4/2)\nhttp://regex101.com/r"
            },
            {
                "text": " /^\\d{2}\\/\\d{2}\\/\\d{4} \\d{2}:\\d{2}$"
            },
            {
                "text": "\n[0-9]{4}-[0-9]{2}-[0-9]{2}\n\nExercise 2"
            },
            {
                "text": " \n^[0-9]{2}[-\\/]?[0-9]{2}[-\\/]?["
            },
            {
                "text": " [^a-z0-9\\ ]+\n\nConclusion:\nIn this chapter, we explored the importance of RegEx, starting with"
            },
            {
                "text": " ^[0-9]{4}[0-9][0-9]/[0-9]{2}[0-"
            },
            {
                "text": "\n/^([0-9]{4}\\/[0-9]{2}\\/[0-9]{2})["
            }
        ]
    },
    {
        "expression": "^((.)(?!\\2{2,}))+$",
        "raw_prompt": "This pattern matches strings where no more than two equal characters may come in succession.\nTo modify the amount of characters allowed, change the second number (the two inside \"{2,}\")to the desired limit.",
        "refined_prompt": "This pattern matches strings where no more than two equal characters may come in succession.\nMatch examples:\n- \"Abba\"\n- \"p4ssw0rd\"\n- \"Whatever\"\nNon-match examples:\n- \"Abbba\"\n- \"p4sssw0rd\"",
        "matches": [
            "Abba",
            "p4ssw0rd",
            "Whatever",
            "GpVJK>gwiR<p6P+7<ZOXZ1<U|B0PeW4\"[%|K f%F3/uR,(i{H(Uf~QO@ZnYtrK:_c+yN(8RjlG|X~e(0AH59",
            "GpVJK>gwiR<p6P+7<ZOXZ1<U|B0PeW4\"[%|K f%F3/uR,(i{H(Uf~QO@ZnYtrK:_c+yN(8RjlG|X~e(0AH59",
            "kLP)N?b1/:vaM:-3MML?",
            "'D 9v NI8&$xY@LvdwT,L-EF-;[S)TEpQa<t{;t8)4ReZ7Qh",
            "W*VeTrnw2k-",
            "o;!2A",
            "SRGk\"h1!S6\\}JvXFBh*m{\\o\"t;k}5Nj;BqxYQn;X}T,X}",
            "yeL\">,,8|i0<[!2IRo<z?So7$qTvX'>.5J4=MC!%'SbP!uhG`1;m2^RuiI%",
            "Q-sa^g`[m",
            "K:lY9le}7sg<5x%R=]|iu/&+OG/}S;wPX:Ti;~gFH!?PS"
        ],
        "non_matches": [
            "Abbba",
            "p4sssw0rd",
            "Whateverrr",
            "ttt",
            "fffwefdc",
            "kslsrrr",
            "343resddd",
            "42-fs---",
            "gggdcsjew",
            "passsssss",
            "qqqqq",
            "pppwewdsddddd"
        ],
        "id": 2348,
        "output": [
            {
                "text": " ^[^s]*[a-z]{1,2}[^s]*[a-z]{1,2}[^s]*$\n\n2. Write a regular expression that will match any string that"
            },
            {
                "text": "\n(.).{1,2}\n\nA:\n\nIf you want to match up to 2 characters, and only 2 characters, then use a character set.  The ^ and $ anchor are there to assert that the whole match must be"
            },
            {
                "text": " [a-z]{1,2}[a-z]{1,2}(?=[a-z]{1,2})\n- \"[a-z]{3,5}[a-z]\"Generate"
            },
            {
                "text": " (\\w)(\\1)+\n\n4. Write a pattern that matches single characters that are between two or more spaces.\nAnswer: (\\S)\\s+(\\S)\n\n5. Write a pattern that matches a string that starts"
            },
            {
                "text": " [A-Z][A-Z](?!\\1)\nExplanation: The pattern [A-Z] matches an uppercase letter.\nThe negative lookahead (?!\\1) ensures that the second character cannot be the same"
            },
            {
                "text": " \n/[a-zA-Z]\\1{1,2}\\z/\n\nExercise 2: \nSuppose you are given a string containing only alphanumeric characters except for a \"-\" delimiter, such as"
            },
            {
                "text": " \n[a-z]{2,}\nExamples:\n- \"abba\"\n- \"xyhjklmnpqrstuvwxyz\"\n- \"abcd\"\nNote: If you have two letters that"
            },
            {
                "text": "\n\n[^a]*a[^a]*\n\nExercise 2: Create a regular expression for a phone number with exactly 9 digits.\nAnswer:\n^\\d{9}$\n\nExercise 3: Create a"
            },
            {
                "text": " ( \\w{2,} )+\n- \"Whatever\"\nGenerate a RegEx for this description.\n\nTo check the answer, you test the RegEx pattern with the strings with the matched and unmatched parts. For example:"
            },
            {
                "text": " \n(?=.*[a-z].*[a-z])[a-z]{2,}\n\nThis pattern matches strings where there are at least two consecutive lowercase letters.\n\nExercise 3:\nWrite"
            }
        ]
    },
    {
        "expression": "^[\\w_.]{5,12}$",
        "raw_prompt": "validate usernames with dot or underscoures doesn't allow spaces and accept characters between 5 and 15 no other characters",
        "refined_prompt": "validate usernames with dot or underscoures doesn't allow spaces and accept characters between 5 and 15 no other characters\nMatch examples:\n- \"Ahmad.egypt\"\n- \"ahmad_egypt\"\n- \"5YyFbx4uOO\"\nNon-match examples:\n- \"Ahmad@egypt\"\n- \"Ahmad*egypt\"",
        "matches": [
            "Ahmad.egypt",
            "ahmad_egypt",
            "5YyFbx4uOO",
            "6dN0A4.",
            "C0rCMij",
            "SbmYk1kL1Iq",
            "PZojALMC",
            "rhVql5.B",
            "09sjoqp",
            "tAn8af",
            "Bi7hj0",
            "CBREBy0q",
            "FWIUTLoxr"
        ],
        "non_matches": [
            "Ahmad@egypt",
            "Ahmad*egypt",
            "$e",
            "2345",
            "4444...cdw4;",
            "var",
            "\"ef\"",
            "-vfe",
            "(herfjvd)",
            "```",
            "We!",
            "Wepoiuy76tfrvgbhnjkm"
        ],
        "id": 2352,
        "output": [
            {
                "text": " a-zA-Z0-9_-.*@-//*\\w+_+\\s\n\nExercise 3:\nHow"
            },
            {
                "text": " [a-zA-Z0-9]([a-zA-Z0-9-])*[a-zA-Z"
            },
            {
                "text": " (\\w*[a-zA-Z])[a-zA-Z0-9]*([a-zA-Z"
            },
            {
                "text": "\n[a-zA-Z0-9._-]([a-zA-Z0-9._-]+)\n\nEx"
            },
            {
                "text": " [^0-9A-Za-z_]\n\n2. Write a regular expression which matches any string that contains the word, \""
            },
            {
                "text": " [a-zA-Z0-9-_]{5,15}@[a-zA-Z0-9-_"
            },
            {
                "text": " \n^(?!.*\\s)([a-zA-Z0-9._-]+@[a-zA-Z0"
            },
            {
                "text": " r'^[A-Za-z]{5,{1}}\\w*$'\n\n2. You have a table with"
            },
            {
                "text": " (at least one character, between 5 and 15, not allowed to include white spaces, and must contain only alphanumeric characters and underscores) - ["
            },
            {
                "text": " ^[a-zA-Z0-9](?:[a-zA-Z0-9_-]|\\\\.)*[a"
            }
        ]
    },
    {
        "expression": "^([^\\s]){5,12}$",
        "raw_prompt": "validate text against spaces and accept from 5 to 12 character",
        "refined_prompt": "validate strings without spaces and accept from 5 to 12 characters per string\nMatch examples:\n- \"ahmed\"\n- \"Muhammad\"\n- \"Hassan\"\nNon-match examples:\n- \"a hmed\"\n- \"Hass an\"",
        "matches": [
            "ahmed",
            "Muhammad",
            "Hassan",
            "`SGAkv,EI?",
            "5l*`(o1+NF",
            "-A`i;A",
            "0Ei}Ze0\"",
            "jnEq%yeL[U",
            "aBEFc0.",
            "rHj%{d",
            "ts<H95",
            "_40.5\\x",
            "uik/g/\\L"
        ],
        "non_matches": [
            "a hmed",
            "Hass an",
            "wef efds",
            "222e &&",
            "# # #",
            "0987 - -ef",
            "&& edh /e wef",
            "je  ejw",
            "wef wef6",
            "lef kef\\ j",
            "wef w e e e e",
            "12 343 a"
        ],
        "id": 2353,
        "output": [
            {
                "text": ".+?(?=hassan)\n\nExercise 5:\nWrite a regular expression to match all email addresses without spaces.\nAnswer:\n[\\w.]+@[\\w.]+\n\nNow that we have learned about Regular Expression, let's talk"
            },
            {
                "text": " \"^[A-Za-z]{1,2}[A-Za-z0-9\\-\\_]+$\"\n\nExercise 3: Write a code to capitalize the first letter of each word in a string.\nMatch examples:\n-"
            },
            {
                "text": " \nFirst letter of the name must be alphabetic\nSecond name must be alphabetic and between 5 and 12 characters long\nIf the first and second names do not match, return \"Bad name\"\n\nExample 3:\nThe function that accepts a string and returns False"
            },
            {
                "text": " ^[a-zA-Z]\\s[a-zA-Z]'s$\n\n## Exercise 3:\nWrite a program that takes in a string and determines if that string is a valid US Postal Code.\n\nValid US Postal Codes:\nABC123"
            },
            {
                "text": " /^[A-Z][a-z]+$/i.\n\n\n\nQuestion 9: A bookshelf has 5 shelves. Each shelf can hold 10 books. How many books can the bookshelf hold in total?\n\nSolution 9:\nTo find the"
            },
            {
                "text": " [a-h][M-h]?\n\n### Exercise 4\n\nCreate a function that takes a list of strings and returns a new list with only the strings that start with a specific letter. Use list comprehension for this exercise.\n\n```python\ndef filter_"
            },
            {
                "text": " (?i) (a|b|c) (h|m|n|d)\n\nExercise 2: Create Python function that accepts a string and returns the number of uppercase letters.\nAnswer: def uppercase_count(text: str) ->"
            },
            {
                "text": " [A-Za-z0-9]{1,5}\\s+[A-Za-z0-9]{1,5}\n\n3. Generate a RegEx for the following description:\nSearch for a word that contains at least 4"
            },
            {
                "text": "\n\nimport re\n\npattern = r'^[a-zA-Z][a-zA-Z0-9]*$'\n\ntext1 = \"ahmed\"\ntext2 = \"Muhammad\"\ntext3 = \"Hassan\""
            },
            {
                "text": " (ahm|muhammad|han)\n\nExercise 2: Write a Python function that takes a list of strings and returns a list of only the strings that are valid email addresses.\n\nAnswer:\nimport re\n\ndef valid_emails(emails):\n"
            }
        ]
    },
    {
        "expression": "^((\\+)?(\\d{2}[-])?(\\d{10}){1})?(\\d{11}){0,1}?$",
        "raw_prompt": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix . Allows optional - after national code",
        "refined_prompt": "Matches India phone numbers, accepted with optional +91 national code and 0 for land and mobile number prefix. Allows optional - after national code\nMatch examples:\n- \"+91-9764544544\"\n- \"09764544544\"\n- \"01087656444\"\nNon-match examples:\n- \"+91-01087656444\"\n- \"+91-09764544544\"",
        "matches": [
            "+91-9764544544",
            "09764544544",
            "01087656444",
            "+91-1087656444",
            "+9302244601",
            "2840587176",
            "+23-247040948192995860973",
            "66-1415888391",
            "726515335285132035994",
            "20-7832970350",
            "+8222364339",
            "90538462668",
            "+4077175825"
        ],
        "non_matches": [
            "+91-01087656444",
            "+91-09764544544",
            "+9178786765652",
            "2342",
            "#3",
            "5%",
            "$56789",
            "0.0",
            "12/12",
            "1,0",
            ";;;;",
            "\"lkhg\""
        ],
        "id": 2355,
        "output": [
            {
                "text": "\n^\\+91[0-9]{2,3}-\n\nExercise 2:\nGive two examples"
            },
            {
                "text": "  (^[0-9]{3}-)?(?:\\+[0-9]{3})["
            },
            {
                "text": " ^\\+91(?:[1-9]\\d{0,2}\\d|[1-9]\\"
            },
            {
                "text": "\n[^-]*-?[0-9]{2}[^-]*\n\nExercise 2"
            },
            {
                "text": " \\+91-(\\d{3})[-\\s\\d]?\n\nA:\n\nI'd use"
            },
            {
                "text": " \n\"(^|[0-9]|[0-9]\\.)[1-9]\\d{"
            },
            {
                "text": " +91[0-9]{7,10}$\n\n```python\nimport re\n\nphoneNumber ="
            },
            {
                "text": " ^\\+91(0[1-9]|1[012])[0-9]{3,}$"
            },
            {
                "text": " The generated RegEx is [-+]?\\d{0,3}\\d{3}(?:\\.\\d"
            },
            {
                "text": " [0-9]{3}[-\\s]?[0-9]{3}[-\\s"
            }
        ]
    },
    {
        "expression": "^(([0-9]{1})|([0-9]{1}[0-9]{1})|([1-3]{1}[0-6]{1}[0-5]{1}))d(([0-9]{1})|(1[0-9]{1})|([1-2]{1}[0-3]{1}))h(([0-9]{1})|([1-5]{1}[0-9]{1}))m$",
        "raw_prompt": "Duration validation similar to MS Project (5d16h45m, etc). Does not allow more than 365 days, 23 hrs or 59 min.",
        "refined_prompt": "Validate time length (5d16h45m, etc). Does not allow more than 365 days, 23 hrs or 59 min.\nMatch examples:\n- \"365d23h59m\"\n- \"90d18h45m\"\n- \"05d19h45m\"\nNon-match examples:\n- \"366d23h45m\"\n- \"90d24h5m\"",
        "matches": [
            "365d23h59m",
            "90d18h45m",
            "05d19h45m",
            "160d15h0m",
            "7d20h0m",
            "73d3h43m",
            "0d11h4m",
            "30d10h30m",
            "1d13h7m",
            "69d19h8m",
            "5d14h49m",
            "05d22h56m",
            "03d12h6m"
        ],
        "non_matches": [
            "366d23h45m",
            "90d24h5m",
            "90d6h60m",
            "ewfdv",
            "12",
            "#3",
            "45%",
            "---",
            "12/12",
            "3.114",
            "000000",
            "hour"
        ],
        "id": 2360,
        "output": [
            {
                "text": " (\\d{0,1}\\d{1,2}\\d{1,2}d[^0-9]"
            },
            {
                "text": " \n\n- \"^(?P<year>\\d{4})(?P<month>\\d{2"
            },
            {
                "text": "\n\n[0-9]+d?[0-9]?h?[0-9]?m?[0"
            },
            {
                "text": "\n^[0-9]+(d|h|m)?\n\nExercise 2:\nCreate a RegEx that matches"
            },
            {
                "text": "\n^[0-9]d[0-9]h[0-9]m$\n\n3) Write a"
            },
            {
                "text": " r\"^365d[0-9]h[0-9]m$\"\n\n#### Exercise 3:\n\n"
            },
            {
                "text": " \nI tried the following pattern (regex) but it's not working properly. It returns true for the first test case but"
            },
            {
                "text": " [0-9]*d[0-9]*h[0-9]*m[0-9]*"
            },
            {
                "text": "\n^(?:(?P<day>\\d{1,2}d(?:\\d{1,2}"
            },
            {
                "text": "\n(([0-9]+)d(?:[0-9]*h(?:[0-9]*m"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[012])/([012][0-9]|[1-9]|3[01])/([12][0-9]{3})$",
        "raw_prompt": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Sadly, it doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).",
        "refined_prompt": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/32/1593\"",
        "matches": [
            "1/12/2003",
            "04/8/1995",
            "12/31/2035",
            "5/06/1911",
            "11/30/1418",
            "12/11/1860",
            "02/14/1790",
            "11/1/1214",
            "07/31/1788",
            "7/04/1081",
            "12/31/1237",
            "1/09/2829",
            "05/29/2135"
        ],
        "non_matches": [
            "13/04/2000",
            "4/32/1593",
            "\"\"",
            "5/6/98",
            "efrv",
            "date",
            "2345tr",
            "fwe",
            "4444",
            "$45",
            "#3",
            "12/12/12/12/12/12/12/12"
        ],
        "id": 2370,
        "output": [
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/02"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/25"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/12"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/02"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/4"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/07"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/31"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/01"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/3"
            },
            {
                "text": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc).\nMatch examples:\n- \"1/12/2003\"\n- \"04/8/1995\"\n- \"12/31/2035\"\nNon-match examples:\n- \"13/04/2000\"\n- \"4/8"
            }
        ]
    },
    {
        "expression": "^(([0]?[1-9])|(1[0-2]))\\/(([0]?[1-9])|([1,2]\\d{1})|([3][0,1]))\\/[12]\\d{3}$",
        "raw_prompt": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.",
        "refined_prompt": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999.\nMatch examples:\n- \"1/1/1999\"\n- \"01/01/2001\"\n- \"12/31/1900\"\nNon-match examples:\n- \"00/12/0999\"\n- \"13/1/2000\"",
        "matches": [
            "1/1/1999",
            "01/01/2001",
            "12/31/1900",
            "10/17/1756",
            "10/3,/1600",
            "10/3,/1888",
            "05/31/2950",
            "12/3,/2944",
            "01/9/1523",
            "6/16/1953",
            "09/7/1312",
            "12/8/2633",
            "11/30/1306"
        ],
        "non_matches": [
            "00/12/0999",
            "13/1/2000",
            "10/0/2009",
            "date",
            "12:12:12",
            "12-12-12",
            "12\\12\\12",
            "121212",
            "12 12 12",
            "2345678988765432",
            "noon",
            "aug 8th"
        ],
        "id": 2376,
        "output": [
            {
                "text": " [a-z]\\d{1,2}\\/"
            },
            {
                "text": "\n[1-2][0-9]/[0"
            },
            {
                "text": "\n^(0[1-9]|1[012"
            },
            {
                "text": " /^0?[1-9]\\d?/"
            },
            {
                "text": " (?<month>[0-9]\\d)/("
            },
            {
                "text": " \n\n```python\nimport re\n\n# regular"
            },
            {
                "text": " \n(0)?(1)?(2)?[0"
            },
            {
                "text": "\nI'm sorry, I am not able to generate a Reg"
            },
            {
                "text": ".{0,2}(?P<month>\\"
            },
            {
                "text": "\n\nThe regular expression for the month day year format is \""
            }
        ]
    },
    {
        "expression": "^(.)+\\.(jpg|jpeg|JPG|JPEG)$",
        "raw_prompt": "validates jpg/jpeg picture extension",
        "refined_prompt": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \"pic\"",
        "matches": [
            "marko.jpg",
            "marko.pic.jpeg",
            "B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg",
            "A]RS{WMLb*q<{PP*5RS1lS())b:7;/=jMyJ$.JPEG",
            "rY<Kg5BMy;~<2.JPEG",
            "2$W>#fsPRWp7(@Ge?q@>tx Mb)bIO!Cr!Y'+X2`<.UYgMlsr:8*AE!.JPEG",
            "6O }l#B<@Nhp!%L@0MVG}-iQ KmIWJOC*WU1+(+br/FB5l^\"elti;wwrZ[~<`[lfM)Q)O+oDMf:G*$CV^71t%$\".jpg",
            "FLzPWV~Z)))@D{~F`D@d_qUqJDno@'({xlL[|+Ijf@=SU=!Q*^cgJ[Jx \\V9U8C}Aj~W*'*}7>Gi/jr.JPEG",
            "\\{B9a;%QdSXLI5&,gRss6aU6qL^srcY*w0,)#KGvx(yXQQ:QK\"rS+Y0cZJ~_>M19^(Hho.jpeg",
            ";.JPEG",
            "g]F!aJY5}{B?73F4}#pRbDTVh#OaG,>%n@nQ*^EIb!ClhEe('.jpeg",
            "/\"D,Ft!&4Z*@2k(B`+&KXx8 K2'U*_YVjAlf.$_!Zuq-!&^Vy$`Iqgs:&iY.JPG",
            "#vAOgud/Lrc$SX8PTPbwtN~{#-&ElSqezDh\\zYa0)9UjD)2d*7I\\A1~Bpq;oKR,(Cz]*TK?mb[U ]?A:O*@C.jpg"
        ],
        "non_matches": [
            "marko.exe",
            "pic",
            "fervd.png",
            "ruhfe.PNG",
            "wretg",
            "this is a photo",
            "image",
            "ejiwds",
            "#GJHED6",
            "hex",
            "picture",
            "jpEG"
        ],
        "id": 2377,
        "output": [
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            },
            {
                "text": "validates jpg/jpeg picture extension\nMatch examples:\n- \"marko.jpg\"\n- \"marko.pic.jpeg\"\n- \"B`/@}LltmV56t?)#QW*cY'k9r{l,6)0~@(k!V~y5'{*k@;Ow8~jvb<Y:r+QqCy5%uwu|1*FV-4/pl+#RI.jpg\"\nNon-match examples:\n- \"marko.exe\"\n- \""
            }
        ]
    },
    {
        "expression": "[^A-Za-z0-9 ]",
        "raw_prompt": "search special character form a given sting space is ignored.",
        "refined_prompt": "Matches special characters\nMatch examples:\n- \"#This Is $$## Where Your Main String Goes\"\n- \">\"\n- \")\"\nNon-match examples:\n- \"This is a test\"\n- \"letter\"",
        "matches": [
            "#This Is $$## Where Your Main String Goes",
            ">",
            ")",
            ".",
            "$",
            "<",
            ">",
            "[",
            "}",
            "\"",
            "'",
            "|",
            "}"
        ],
        "non_matches": [
            "This is a test",
            "letter",
            "4",
            "3454",
            "fr",
            "efr",
            "43e",
            "fred",
            "43ef",
            "43ew",
            "44rfe",
            "tgrfd"
        ],
        "id": 2379,
        "output": [
            {
                "text": "\n\nimport re\nstring = \"This is a test\"\npattern = re.compile(r'[a-zA-Z0-9\\_\\-\\=\\(\\)\\[\\]\\{\\}\\%\\&\\^\\*\\~\\@\\\u00a3\\$\\+\\|\\"
            },
            {
                "text": " \n[a-zA-z0-9_]*\n\nExercise 5:\nCreate a list of five programming languages and their corresponding syntax. Write a function that takes this list as input and returns a string with the languages and their syntax separated by commas and the phrase \"and\" before the last item"
            },
            {
                "text": " \n\nimport re \n\ndef is_special_char(input_str): \n    # Check if all characters are the same \n    if len(set(input_str)) == 1: \n        return True\n    # Check if any char is a special character \n    elif re"
            },
            {
                "text": " ^[A-Za-z0-9_]{1}$\n\nExercise 4: \n\nCreate a RegEx that will match any string that contains the words \"dog\", \"cat\", or \"bird\". For example: \"The quick brown cat jumped over the lazy dog.\" \n\nAnswer"
            },
            {
                "text": "\n- (\\S+)\n\nExercise 3: \nCreate a RegEx that matches any string that is 6 characters or longer.\nAnswer:\n(.{6,})\n\nExercise 4: \nCreate a RegEx that matches a word that starts with \"a\" and consists of any number of"
            },
            {
                "text": " (\\S+)(.*)\n\nExercise 3:\nCreate a RegEx to match a phone number that looks like this: (123) 456-7890\nAnswer: \\(\\d{3}\\)\\d{3}-\\d{4}\n\nExercise 4:\nCreate a RegEx"
            },
            {
                "text": " [^\\w\\s]+\n\nExercise 2:\nWrite a program that takes a user input string and returns the number of words in the input string. Use RegEx to split the input string into words.\n\nThought process:\n\nI need to split the input string into words using RegEx. I"
            },
            {
                "text": " \".*\"\n\nExercise 3: \nWrite a program that allows users to upload files from their computer. The program should check if the file is a.txt file, if it is, display the file name and the file size in a message box.\n\nAnswer: \nimport wx\n\nclass My"
            },
            {
                "text": "![](.*?)[<>]\n\nExercise 3: Replacing Numbers in Strings\nWrite a Python function that replaces all occurrences of digits in a string with the string \"DIGIT\".\n\ndef replace_numbers(string):\n    return string.replace(\".\", \"DIGIT\")\n\n"
            },
            {
                "text": " [^aA-zZ]\n\n3. Create a RegEx that will match all uppercase letters in a string.\n\n```python\n# Ideas:\n# Use the `re.findall()` function to match all uppercase letters\n# Use the `re.search()` function"
            }
        ]
    },
    {
        "expression": "^([1-9]\\d{3}|0[1-9]\\d{2}|00[1-9]\\d{1}|000[1-9]{1})$",
        "raw_prompt": "This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression.",
        "refined_prompt": "This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression.\nMatch examples:\n- \"0001\"\n- \"0064\"\n- \"0948\"\nNon-match examples:\n- \"1\"\n- \"64\"",
        "matches": [
            "0001",
            "0064",
            "0948",
            "7697",
            "2977",
            "7134",
            "0008",
            "0009",
            "0017",
            "0009",
            "0794",
            "0041",
            "0761"
        ],
        "non_matches": [
            "1",
            "64",
            "948",
            "-98765",
            "+098765",
            "0.000",
            "23456.2345",
            "743734.23783287",
            "754.238",
            "23432.23234",
            "24.",
            "-987654"
        ],
        "id": 2383,
        "output": [
            {
                "text": "\n[0-9]\\d{3}$\nThe numbers must contain exactly 3 characters; the first number must be a digit; the second character must be a digit; and the last number must be a digit. The entire expression is the same"
            },
            {
                "text": " ([0-9]{4})\n- \"123\"\n- \"123\"\nAnswer: (\\\\d{4})\n- \"12 34 56 7\"\n- \"1234567890\"\n- \"000123456789\""
            },
            {
                "text": " 0\\.(0|[1-9]\\d|1[0-2])\n\nA:\n\nYou can use this pattern:\n\\b(0[1-9]\\d|1[0-2])\\b"
            },
            {
                "text": " 0[0-9]{4}\nAnother example:\n- \"0023\"\nGenerate a RegEx for this description. \nAnswer: 0[2-9]\n\nA:\n\nMy approach would be to just add"
            },
            {
                "text": " 1 or more digits, then 1 or more digits, then 1 or more digits, then 1 or more digits. (\\d{1,4})\n\n7. Use the following code to get a list of non-match examples:\nstring ="
            },
            {
                "text": " [0-9]{4}\n\n#### Exercise 3\nHow could you modify the following regex to make it work?: $regex to match any three digits before a period.\n- \"\\b\\d{3}\\.\",\n\nHint"
            },
            {
                "text": " \n\"(\\d{4})$\"\n\n3. In this question, we asked for the string between brackets: \"{[a-z][a-z]}\", containing 4 lowercase letters. We need to check if the string contains at"
            },
            {
                "text": " [0-9]{4}\n\nI am thinking that I should use a backslash to escape the regex, but I am unsure. \n\nA:\n\nMake use of the quantifier {m,n}\nSo the"
            },
            {
                "text": "  ^[1-9][0-9][0-9][0-9]$/\n\nA:\n\nYou will need to do a few things here:\nFirst, you need to write a character class, not a character literal"
            },
            {
                "text": " \\d{3}-\\d{3}-\\d{4}\n\n2. Match all email addresses with the format 'firstname.lastname@domain.com'.\n    - Example: 'jeff@aol.com"
            }
        ]
    },
    {
        "expression": "^([\\d]*[1-9]+[\\d]*)$",
        "raw_prompt": "RE to match numbers with value greater than 0.",
        "refined_prompt": "RE to match numbers with value greater than 0.\nMatch examples:\n- \"0001\"\n- \"120064\"\n- \"1000000\"\nNon-match examples:\n- \"0\"\n- \"000000000\"",
        "matches": [
            "0001",
            "120064",
            "1000000",
            "1",
            "234",
            "2345",
            "654",
            "3874",
            "327",
            "56432",
            "43",
            "7653423",
            "56432"
        ],
        "non_matches": [
            "0",
            "000000000",
            "0000",
            "0000",
            "00",
            "-1",
            "-0",
            "-98765",
            "-9876543456789",
            "-864567",
            "-43212",
            "-4565432"
        ],
        "id": 2384,
        "output": [
            {
                "text": "\n\nregex = '^0*[1-9]\\d*$|^[1-9]\\d{1,3}$'\n\nThe regex pattern \"^0*[1-9]\\d*$|^[1-9]\\d{1,3}$"
            },
            {
                "text": " The RegEx should be \"[0-9]+\" because it matches any numbers with 0 or more digits in it.\n- \"01234567890\"Generate a RegEx for this description.\nAnswer: The RegEx should be \"[0-9a-zA-Z]*\" because it matches any"
            },
            {
                "text": " \".*\\d{10,20}$\"\n\nExercise 2: Generate a RegEx to match a valid email address.\nHints: An email address consists of a username (including any periods) and a domain name (without periods).\nSolution: @([A-Za-z0-9"
            },
            {
                "text": " \n\"\"\"\n\nimport re\n\ns = \"0001\"\nprint(re.findall(r'\\d+', s))\n\ns = \"120064\"\nprint(re.findall(r'\\d+', s))\n\ns = \"1000000\"\nprint(re."
            },
            {
                "text": "\n(?<!\\d)(\\d{1,3}(?!\\d)|\\d{3,})\n\nPart 3: Using the RegEx\n\nExercise 1: \nYou have a list of names of fruits:\nfruits = [\"Apple\", \"Banana\", \"Cherry\","
            },
            {
                "text": " \n# Non-match examples\n0\n000000000\n\n#Question 2\n\nWrite a RegEx to match any string that has the word 'python' in it.\nGenerate a RegEx for this description.\nAnswer:\n# Generate a RegEx for this description.\n^.*python.*$"
            },
            {
                "text": " ^(?=(\\d{2})+(\\d{4})$)(?=(\\d{6})+(\\d{6})$)(?=(\\d{8})+(\\d{8})$)(?=(\\d{10})+(\\d{10})$)(?=(\\d{"
            },
            {
                "text": " [0-9]{1,64}\n\n**Exercise 3:** Write a RegEx pattern to match phone numbers of the format (xxx) xxx-xxxx. \n**Answer**\n(?:\\(\\d{3}\\)\\s*)|(?:\\(\\d{3}\\) \\d"
            },
            {
                "text": " \\d{1,6}$\n\nExercise 5: Match the following phrases to their word types\n1) Red\n2) Dog\n3) Table\n4) Cat\n5) Computer\na) Article\nb) Noun\nc) Noun\nd) Verb\ne) Noun\nf"
            },
            {
                "text": " \n^\\d+(?:\\.\\d+)?$\n\nExercise 5: \nGenerate a RegEx pattern to match email addresses in the following format: username@domain.com\nAnswer: \n^[a-zA-Z0-9._%+-]+@[a-"
            }
        ]
    },
    {
        "expression": "((\\+44\\s?\\(0\\)\\s?\\d{2,4})|(\\+44\\s?(01|02|03|07|08)\\d{2,3})|(\\+44\\s?(1|2|3|7|8)\\d{2,3})|(\\(\\+44\\)\\s?\\d{3,4})|(\\(\\d{5}\\))|((01|02|03|07|08)\\d{2,3})|(\\d{5}))(\\s|-|.)(((\\d{3,4})(\\s|-)(\\d{3,4}))|((\\d{6,7})))",
        "raw_prompt": "Matches over 18 different combinations for UK phone numbers that I could find. If there are any errors please get in touch.",
        "refined_prompt": "Matches over 18 different combinations for UK phone numbers\nMatch examples:\n- \"0121 111 1111\"\n- \"+44 (0)21 444 4444\"\n- \"07941 111 111\"\nNon-match examples:\n- \"0121_111_3333\"\n- \"324RE\"",
        "matches": [
            "0121 111 1111",
            "+44 (0)21 444 4444",
            "07941 111 111",
            "07941 111111",
            "(+44) 121 222 3333",
            "(+44) 51774796-001",
            "91508?184552",
            "(96982)\u2002967190",
            "+44384-077176",
            "0118-3320019",
            "(+44)6690U0056649",
            "07010-617083",
            "(54805)-201-419"
        ],
        "non_matches": [
            "0121_111_3333",
            "324RE",
            "ejk",
            "##",
            "0.0",
            "1,000",
            "$45",
            "@gmail",
            "12/12",
            "(6)",
            "&and",
            "/fjhvd"
        ],
        "id": 2393,
        "output": [
            {
                "text": " r'^\\+44\\s\\d{1,3}\\s\\d{1,3}\\s\\d{2}$'\n\nExercise 2: Phone Number Verification. \nWrite a Python function that"
            },
            {
                "text": " The RegEx to match a UK phone number is \",?(?=.*[1-9])(?!.*_)\", with the final \"?\" optional.\n\nExercise 4: Using \"lookaround\" operators, generate a Reg"
            },
            {
                "text": " ^\\+?[1-9][0-9]{3}[0-9]{2}[0-9]{2}$\nIllustration: \nJohn is a carpenter who is building a"
            },
            {
                "text": " \nThis is a list of patterns to match UK phone numbers:\n[^\\d*_]|(\\+44(0)\\)|(\\s+\\d{3}[\\s\\d]{3}[\\"
            },
            {
                "text": " ^[0-9]{3}[ 0-9]{3}[ 0-9]{4}$\n\nQuestion 5: Write a RegEx for this description.\nThe email address should have exactly 1-3"
            },
            {
                "text": " \"^[0-9]{3}[0-9]{3}[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-"
            },
            {
                "text": " \\d{3}\\d{3}\\d{4}|\\d{3}\\d{3}\\(|\\d{3}\\)\\d{5}\n\nExercise 2: Validate a phone number.\nGiven"
            },
            {
                "text": " \\d{3}[^_]\\d{3}[^_]\\d{4}\n\nExercise 4:\n\nCreate a Python function that accepts a string and returns the string with all vowels removed."
            },
            {
                "text": "\n[0-9]+[0-9]?[0-9]{4}(?:-[0-9]{3})?'\n\n\n\nTitle: Understanding the Impact of Environmental Issues on Ecosystems and"
            },
            {
                "text": " /^\\+?\\d{1,2}[\\s-]?\\d{3}[\\s-]?\\d{4}[^-\\s]$/gm\n\n3. Create a"
            }
        ]
    },
    {
        "expression": "^([0-9]|[1-9]\\d|[1-7]\\d{2}|800)$",
        "raw_prompt": "Validates if the GMAT score is in the correct range and format",
        "refined_prompt": "Validates if the Graduate Management Admission (GMAT) score is in the correct range and format\nMatch examples:\n- \"0\"\n- \"190\"\n- \"800\"\nNon-match examples:\n- \"050\"\n- \"700.5\"",
        "matches": [
            "0",
            "190",
            "800",
            "95",
            "9",
            "65",
            "8",
            "5",
            "447",
            "99",
            "488",
            "164",
            "7"
        ],
        "non_matches": [
            "050",
            "700.5",
            "abc",
            "801",
            "weqfrt",
            "12345678",
            "#3",
            "45%",
            "12/12",
            "0.0",
            "-45",
            "$4"
        ],
        "id": 2398,
        "output": [
            {
                "text": " Match examples are numbers between 0 and 800, including the integer portion. Non-match examples start with a number, followed by a decimal point and either a digit or a digit followed by a decimal point. The result is a float. This can be done using the following RegEx: r\"("
            },
            {
                "text": " (0|[1-9]\\d?)\\d{1,3}(\\.\\d{1,3})??|(0|[1-9]\\d?)\\d{1,3}(\\.\\d{2})?\n\n5."
            },
            {
                "text": " ^\\d{3}[./]\\d{3}[./]\\d{4}$\n- \"001\"Match examples:\n- \"012\"\n- \"111\"\nNon-match examples:\n- \"10\"\n- \"101\"\n-"
            },
            {
                "text": " \n\n```python\nimport re\n\n# Match example\npattern = r\"^0$|^190$|^800$\"\nmatch_values = re.findall(pattern, \"0 0 190 800\")\nprint(match_values)\n# Output"
            },
            {
                "text": " (0 or invalid) or (invalid) or (invalid)\n\n```python\nimport re\n\nscore = int(input(\"Enter your GMAT score: \"))\nif score >= 0 and score <= 100:\n  valid_score = \"^(0"
            },
            {
                "text": " /^(\\d{4})(0)(\\d{2})(\\d{2})?$/\n\n2. Validate whether the following string starts with \"Dr\", ends with \"Lisbon\" and has \"Masters\" in between.\nHint:"
            },
            {
                "text": "\n[0-9][0-9]{2}|[1-9][0-9]{3}|(1[0-9]|2[0-9]|3[0-1])([0-5][0-9]|"
            },
            {
                "text": " \n\"(^[0-9]{0,}?[0-9]|[0-9]{1,2}[0-9]{2}|[0-9]{3,4}[0-9]{3})$\""
            },
            {
                "text": " \n\\b(?:0|1[1-9]|2[0-9]|[1-9][0-9]|100|200|300|400|500|600|700|800|900|950|1000)\\b\n\nExercise"
            },
            {
                "text": " One possible RegEx is \"^[0-9]{4}([.,]?[0-9]{3})?[.][0-9]{3}$\". This matches four digits, optionally followed by a decimal point, three digits, another decimal point,"
            }
        ]
    },
    {
        "expression": "^[6]\\d{7}$",
        "raw_prompt": "In Singapore, the first digit must start with a \"6\", and the rest is made up of 7 digits, which means that there are 8 digits in a Singapore's telephone number.",
        "refined_prompt": "Matches Singapore phone numbers. The first digit must start with a \"6\", and the rest is made up of 7 digits, for a total of 8 digits.\nMatch examples:\n- \"61234567\"\n- \"63829324\"\n- \"67654321\"\nNon-match examples:\n- \"6123-4567\"\n- \"6-CALL-CPY\"",
        "matches": [
            "61234567",
            "63829324",
            "67654321",
            "62063218",
            "68071190",
            "63260204",
            "61957375",
            "63592822",
            "67207752",
            "64211366",
            "68408755",
            "67378706",
            "69940760"
        ],
        "non_matches": [
            "6123-4567",
            "6-CALL-CPY",
            "6123abcd",
            "7",
            "wdfsv",
            "###",
            "3",
            "$45",
            "76%",
            "12/12",
            "@",
            "-8"
        ],
        "id": 2399,
        "output": [
            {
                "text": " (6-)([789]|8)(99) \n\n3. A customer's phone number is \"1234567890"
            },
            {
                "text": " \"^6\\d{7}$\"\n\nExercise 5:\nCreate a Python script that reads a file and counts the"
            },
            {
                "text": " [0-9][0-9][0-9][0-9][0-9][0-9][0-9"
            },
            {
                "text": "\n\"([0-9])([0-9])([0-9])([0-9])([0"
            },
            {
                "text": "\nThe RegEx would be: /^[6]-?[0-9]{7}$/\nTo match a phone"
            },
            {
                "text": " ^6[1-9][0-9]{6,}$\n\nExercise 2: Create a RegEx for matching"
            },
            {
                "text": " \"^[6][0-9]{7}$\".\n\n5th. Exercise:\nCreate a RegEx pattern that"
            },
            {
                "text": "\n6(1-9)\\d{3}(3-9)?\n\nExercise 2:\nWhat should be included in"
            },
            {
                "text": " The pattern starts with six digits followed by a hyphen, followed by seven digits. \n\nExercise 2:\nCreate a Python"
            },
            {
                "text": " The last three digits must be 1-3 digits, followed by a hyphen, followed by 5-9 digits, for a total of"
            }
        ]
    },
    {
        "expression": "(\\b(10|11|12|13|14|15|16|17|18|19)[0-9]\\b)",
        "raw_prompt": "Match the numbers 100 to 199",
        "refined_prompt": "Match the numbers 100 to 199\nMatch examples:\n- \"100\"\n- \"101\"\n- \"112\"\nNon-match examples:\n- \"200\"\n- \"-3\"",
        "matches": [
            "100",
            "101",
            "112",
            "130",
            "134",
            "145",
            "146",
            "168",
            "170",
            "173",
            "179",
            "180",
            "188"
        ],
        "non_matches": [
            "200",
            "-3",
            "300",
            "99",
            "55",
            "1",
            "2",
            "3",
            "12",
            "54",
            "78",
            "3214234"
        ],
        "id": 2405,
        "output": [
            {
                "text": " ([0-9]\\d?)\n\nExercise 5: Match the pattern of currency symbols (a to z, 0 to 9)\nMatch examples:\n- \"USD\"\n- \" EURO\"\n- \" \u00a5\"\nNon-match examples:\n- \"USD-USD\"\n- \"USD#EURO\"\n\nAnswer"
            },
            {
                "text": " ^[0-9]{1,3}(?:\\[|\\])$\n\n2. Match the words \"apple\" and \"banana\"\nMatch examples:\n- \"apple\"\n- \"banana\"\nNon-match examples:\n- \"cherry\"\n- \"orange\"\nGenerate a RegEx for this"
            },
            {
                "text": " [0-9]+[.-]?[0-9]+\n\nExercise 4: Using a list comprehension, generate a new list of the first 20 positive even numbers generated by the following pattern: \"X-Y-Z\", where X is \"1\", Y is \"2\", and Z is \"3\".\nAnswer: [1, 4,"
            },
            {
                "text": "\n- \"^[1-9]0*$\"\n- \"^[-3-9][0-9]*$\"\n- \"^[0-9]\\d$\"\n\n\n\nQuestion 6: A bakery produces 100 loaves of bread every day. Each loaf of bread is sold for $5. How much revenue"
            },
            {
                "text": " [01][0-9][0-9]\n\n3. Write a regular expression that matches all the words in a sentence that start with a vowel.\nAnswer: [aeiou][a-z]*\n\n4. Write a regular expression that matches all the numbers in a string that are between 10 and 99.\nAnswer: [10"
            },
            {
                "text": " (100-199)\n\n2. \"Match these words. Write the corresponding numbers from the following list in the blank spaces.\"\nWords: Cat, Dog, House, Tree, Car\nNumbers: 1, 2, 3, 4, 5\nCreate this sequence of numbers:\n- \"1\"\n- \"2\"\n- \"3\"\n"
            },
            {
                "text": "\n- \"1000-1999\"\n- \"0-9\" Generate a RegEx for this description. \n\nExercise 5:\nCreate a RegEx to match email addresses.\nAnswer:\n[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.["
            },
            {
                "text": " \n- \"100\"\n- \"101\"\n- \"112\"\n\nExercise 3: \nMatch the numbers 100 to 199\nMatch examples:\n- \"100\"\n- \"101\"\n- \"112\"\nNon-match examples:\n- \"200\"\n- \"-10\"Generate a RegEx for this description."
            },
            {
                "text": " [^0-9a-zA-Z_]\n\nExercise 5:\nMatch the numbers 0 to 9\nMatch examples:\n- \"0\"\n- \"1\"\n- \"2\"\nNon-match examples:\n- \"10\"\n- \"20\"\nGenerate a RegEx for this description.\nAnswer:"
            },
            {
                "text": " This will vary based on the description.\n\n2. Write a python program to validate a phone number. The phone number should have 10 digits (including 0) and should be in the format (123) 456-7890 or 123-456-7890.\n\n3. Write a python program to extract the email domain name from a given email address"
            }
        ]
    },
    {
        "expression": "^[1-9]{1,2}(.5)?$",
        "raw_prompt": "This is a simple regular expression which allows 1 to 99 in .5 increments which I originally developed for a forum post",
        "refined_prompt": "allows 1 to 99 in .5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"",
        "matches": [
            "1.5",
            "99.5",
            "35.5",
            "43",
            "64",
            "24",
            "3P5",
            "98,5",
            "74",
            "615",
            "7",
            "23",
            "13"
        ],
        "non_matches": [
            ".5",
            "100",
            "0",
            "0.5",
            "34.3",
            "24.356",
            "36.55",
            "-87654",
            "+98765",
            "2.32",
            "3453213.13",
            "03.03"
        ],
        "id": 2406,
        "output": [
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer:.5(?<!\\.5)\n\nA:\n\nUse this one:\n^.5(?<![0-9]\\.[0-9]\\.)\n\nDemo\n\nA:\n\nTo match only.5:\n"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: ( (1|[1-9][0-9]?|1[0-9][0-9]?) *.5 )*\n\nA:\n\nI'd do it something like this\n^\\d*(\\.\\d+)?(\\.\\"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: \n^[1-9][0-9][0-9]?\\.5$\n\nI will also try to find a solution with lookarounds or with \\d\n\nA:\n\nI think this will work for you \n^(?:\\d"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: \n\\d+\\.\\d+\n\nA:\n\nIf you don't want to include the decimal point (I'll assume you do), you can use:\n^\\d*([0-9]?\\d*(?:\\.\\d*)?"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: 1.5|99.5|35.5|100\nI've been playing with this for 2 hours and can't seem to get it to work.\n\nA:\n\nThe pattern will be |[0-9]+\\.?[0-9]{1"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer:.5|\\d+(?:\\.\\d+)\n- Generate a RegEx for this description.\nAnswer: \\b\\d{1,2}(?:\\.\\d{1,2})?\\b\n\nA:\n\nThis will work"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: \n^(1|2|3|4|5|6|7|8|9)[0-9]\\.[0-9]$\nMy understanding is that the first set of digits are the integers 1-99 and the second set is all the non-"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: \n^[0]?[1-9][.][0-9]*$\nI can't help but feel bad about this. This is a pretty standard thing. Most of the sites I've come across use something like \\d{1}(.,\\d"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer:\n(?<integer>\\d+)\\.(?<decimal>\\d+)\\.(?<multiple>\\d+))\n\nA:\n\nYou can use ^[1-9]\\d*\\.\\d*$\nThe ^ means start of"
            },
            {
                "text": "allows 1 to 99 in.5 increments which I originally developed for a forum post\nMatch examples:\n- \"1.5\"\n- \"99.5\"\n- \"35.5\"\nNon-match examples:\n- \".5\"\n- \"100\"Generate a RegEx for this description. \nAnswer: 1[0-9]|[12][0-9][0-9]\n- [1-2] [0-9]\n- [2-4] [0-9] [0-9] [0-9]\n- [4-8"
            }
        ]
    },
    {
        "expression": "^([0-2]{0,1})([0-3]{1})(\\.[0-9]{1,2})?$|^([0-1]{0,1})([0-9]{1})(\\.[0-9]{1,2})?$|^-?(24)(\\.[0]{1,2})?$|^([0-9]{1})(\\.[0-9]{1,2})?$",
        "raw_prompt": "Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24.",
        "refined_prompt": "Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24.\nMatch examples:\n- \"23.50\"\n- \"20.80\"\n- \"23.99\"\nNon-match examples:\n- \"24.01\"\n- \"25\"",
        "matches": [
            "23.50",
            "20.80",
            "23.99",
            "24.00",
            "23",
            "20",
            "1",
            "2.16",
            "3.5",
            "-24.00",
            "16.58",
            "2.1",
            "05"
        ],
        "non_matches": [
            "24.01",
            "25",
            "20.900",
            "-20",
            "-25.50",
            "32ewdsre43",
            "#3",
            "$4",
            "67%",
            "-33453245324",
            "+098765",
            "number"
        ],
        "id": 2425,
        "output": [
            {
                "text": " ^(?:25[0-9]|2[0-8][0-9]|[0-9][0-9]?)$\n\n# 3. Write a RegEx to match any string that starts with \"abc"
            },
            {
                "text": " [0-9]{1,2}.\\.[0-9]{1,2}.[0-9]{1,2}\n\nExercise\n\n1.  In the following string, how many times is the"
            },
            {
                "text": " \"^[0-2]?[0-9][0-9]?[0-9]?.[0-9]?$\" \n\nExercise 3: \nDevelop a RegEx for this statement:\n"
            },
            {
                "text": " \"^(0?[1-9]\\d?|1[0-2]\\d|2[0-4]\\d|25)\\.(0?[1-9]\\d?|1[0-"
            },
            {
                "text": " \n.*\\s*(0|[1-9]\\d*\\.\\d+)$\n\nStudent Question:\nIn lecture 10.4.8, we learned about creating and using custom validation functions and classes using regular"
            },
            {
                "text": " \"^\\d+.\\d+-\\d+$\"\n\nExercise 3: RegEx Replacements\nWrite a regular expression that replaces all occurrences of the word \"cat\" with \"dog\".\nAnswer: \"re.sub"
            },
            {
                "text": " ^[0-9]{1,2}\\.[0-9]{1,2}\\.[0-9]{1,2}$\n\n4. Write a program that takes a string as input and returns True if it"
            },
            {
                "text": " \"^(?=.*[\\d])(?=.*\\.?[\\d]+)$|^(?=.*\\.?[\\d])(?=.*[\\d\\.]{2,}).*$"
            },
            {
                "text": "\n(?<!-)([0-9]{1,2}[.]?)0+(?!\\.)\n\nExercise 4:\nCreate a regex to validate numbers that contain letters and digits, and are between 0 and 100"
            },
            {
                "text": " (?<!\\d)(\\d|\\.)\n\n2. Validating a phone number format with 3 digits, one hyphen, and 8 digits.\nMatch examples:\n- \"123-4567\"\n- \"123"
            }
        ]
    },
    {
        "expression": "^([a-z]{2,3}(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.([A-Z][a-zA-Z_$0-9]*)$",
        "raw_prompt": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for widely available classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\nGroup 1 gives the package name, group 3 gives the class name.",
        "refined_prompt": "\nMatch examples:\n- \"foo.Bar\"\n- \"foo.bar.IFBar1\"\n- \"wo.w_1.Ffo$o.Bar\"\nNon-match examples:\n- \"Bar\"\n- \"Foo.Bar\"",
        "matches": [
            "foo.Bar",
            "foo.bar.IFBar1",
            "wo.w_1.Ffo$o.Bar"
        ],
        "non_matches": [
            "Bar",
            "Foo.Bar",
            "foo.bar",
            "foo/Bar",
            "fooo.Bar"
        ],
        "id": 2439,
        "output": [
            {
                "text": " \"^[a-zA-Z0-9\\.]*[a-zA-Z0-9][a-zA-Z0-9]$\"\n\n\n\nQuestion 10: Olivia is organizing a fundraising event. She sells tickets for $15"
            },
            {
                "text": " [^.\\s.]+\n\n# Exercise 3\n\nIn this exercise, you will use the regex module to match email addresses in a string, and store them into a list. You can use the email regex module to match email addresses, as it is a powerful and flexible"
            },
            {
                "text": " \"([^.]+)\\.([^.]+)\\.([^.]+)\"\n\nExercise 5:\n\nWrite a Python function that takes a string and filters it based on a regular expression. \n\nCode:\nimport re\n\ndef filter_string("
            },
            {
                "text": " \"([^.]+)\\.([^.]+)\\.([^.]+)\"\n\nExercise 3:\nWrite a Python function that takes a string and returns a list of all the words in the string that start with a vowel.\nAnswer:\nimport re\n\n"
            },
            {
                "text": " \"^[^.]+.([^.]+.)$\"\n\nExercise 3:\nGiven the following list of names, write a RegEx pattern that matches the first name.\n- \"John Doe\", \"Jane Smith\", \"Richard Roe\", \"Maggie Johnson"
            },
            {
                "text": " \n\n__foo\\.[\\w\\.]*_bar\\.(\\w*)\\.(\\w)*\n\nExercise 2:\nGiven the following string: \"foo.Bar.IFBar1,wo.w_1.Foobar\", create a Reg"
            },
            {
                "text": "\n- /.*?(\\.Bar)/\n\nExercise 2:\nCreate a RegEx to match all the dates in the format \"dd-mm-yyyy\"\n\nAnswer:\n/(\\d{2})-(\\d{2})-(\\d{4"
            },
            {
                "text": " foo[^.+]\\.Bar\n\nExercise 4:\nCreate a function that takes in a list of words and returns a list of words that contain a certain substring.\n\nQuestion: How do we filter a list of words using a function?\n\nThinking"
            },
            {
                "text": " ^Foo(.+)$\n3. Write a Python function that takes a string as input and returns a list of all the words in the string.\nAnswer:\ndef get_words(s):\n    return s.split()\n\n4. Write a Python function"
            },
            {
                "text": " (.*).(..).(..).(..).(..).(..).(..).(..)\n\nExercise 2: \nMatch examples:\n- \"f.o.o.d.s.\"\n- \"foo.bar.c.b"
            }
        ]
    },
    {
        "expression": "^(1(0|7|9)2?)\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])\\.([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$",
        "raw_prompt": "validates private ip addresses\nneeds to be a bit more refined",
        "refined_prompt": "validates private ip addresses\nMatch examples:\n- \"10.10.10.10\"\n- \"192.168.16.4\"\n- \"172.016.22.55\"\nNon-match examples:\n- \"a.c.s.s\"\n- \"100.10.10.10\"",
        "matches": [
            "10.10.10.10",
            "192.168.16.4",
            "172.016.22.55",
            "172.5.228.250",
            "10.233.85.105",
            "172.252.218.218",
            "192.221.46.018",
            "192.251.208.209",
            "19.255.240.252",
            "19.231.251.255",
            "10.253.10.210",
            "192.251.64.252",
            "10.242.223.233"
        ],
        "non_matches": [
            "a.c.s.s",
            "100.10.10.10",
            "188.142.25.2",
            "651817",
            "876.8765...",
            "32.3.23.23.232.3",
            "IP",
            "19",
            "$$56789",
            "654%",
            "&&",
            "#3"
        ],
        "id": 2440,
        "output": [
            {
                "text": " A regular expression that matches the private ip addresses would be /^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0"
            },
            {
                "text": " To match a private ip address, the pattern should be  \"(\\d{1,3}\\.){3}(\\d{1,3})\\.\\d{1,3}\".\n\n2. Write"
            },
            {
                "text": " [^a-zA-Z0-9.]+, [0-9]+\n\nExercise 5:\nWrite a Python function that takes a string and returns True if it contains a valid domain name and False"
            },
            {
                "text": " ^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\n\n2. Write a Python script that generates a list"
            },
            {
                "text": " [\\d]{1,3}\\.[\\d]{1,3}\\.[\\d]{1,3}\\.[\\d]{1,3}[.][\\d]{1,"
            },
            {
                "text": " \"^(?:[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.(1[0-9]"
            },
            {
                "text": " \\b(\\d{1,2}\\.\\d{1,2}\\.\\d{1,2}\\.\\d{1,2})\\b\n\nExercise 3: Modify the regex"
            },
            {
                "text": " \"^(?:[0-9]|1[5-9]|2[0-4][0-9]|25[0-5])\\.(?:[0-9]|1["
            },
            {
                "text": " r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\"\n\nExercise 4: Password Validation"
            },
            {
                "text": "\n\nimport re\npattern = r'^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\ntest"
            }
        ]
    },
    {
        "expression": "^-?\\d+([.,]?\\d+)?$",
        "raw_prompt": "It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once.",
        "refined_prompt": "It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once.\nMatch examples:\n- \"43\"\n- \"-43\"\n- \"43.56\"\nNon-match examples:\n- \"ABC\"\n- \"A43\"",
        "matches": [
            "43",
            "-43",
            "43.56",
            "-43.56",
            "43,56",
            "-43,56",
            "994997188371549459201136946829200131301324641250725292914815963845552861302564329",
            "-3487091609072144048384269919977886060924",
            "76895682489704661970221255543468759417253716562623088077440724843029570628715965181198871948215520598123444087457779209633",
            "-3505373155265567450652816763759835199277060840096676729299953454356928268003383380564063442544614.61891098074490588780421929420870643917286531740499009093335419748",
            "-290363017531384106547938247933697483755812295126510866997861347886957777952721211023595881819365019143928222313124539395683984",
            "131485652336698636658415",
            "-868536324116877539702019421248288463137172483770611551291467998651886569289119515124502618345398.390638465913956976787094640102770984477336954671"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "-43.A3",
            "43.,56",
            "43.",
            "43,",
            ",56",
            ".56",
            "wwwww",
            "1!"
        ],
        "id": 2444,
        "output": [
            {
                "text": "\n[a-zA-Z0-9]{1,}[-,.]{1,}[a-zA-Z0-9]{1,}\n\nExercise 2:\n- \"Hello. World!\"\n- \"Hello,"
            },
            {
                "text": "\n[A-Z]\\d+(?:[,.]\\d+)?\n\nExercise 3: \nYou have a list of numbers, but you only need positive numbers. Write a RegEx that will only accept positive numbers. Match examples: \n-"
            },
            {
                "text": " \n[a-zA-Z]{1,3}-?[0-9]+(.[0-9]+)+\n\nA:\n\nI think you can use this:\n^[a-zA-Z0-9."
            },
            {
                "text": " (\\d+-)\nI can't figure out how to add the dot in a way that it only matches once.\nI've also tried (\\d+)\\.(\\d+) but it didn't work.\n\nA:\n\nYou may use this regex"
            },
            {
                "text": "\n[A-Za-z0-9]{0,}[A-Za-z0-9._%+-]*\n\nA:\n\nWhat about just matching the string that is in the range of your characters, and then checking"
            },
            {
                "text": " [^A-Za-z0-9.]\n\nI have created this as a function. But not sure how to use this in a regex. This is the function:\npublic static String RegEx(String str) {\n    String pattern = \"\\\\"
            },
            {
                "text": " 1. A\\d{1,2}(, (\\d\\d\\d))?+\\s*-?\\d{1,2}(, (\\d\\d\\d))?+\\s*(.|\\,|\\"
            },
            {
                "text": " ^(?=.*[A-Z])[A-Z0-9]*(?:\\.[A-Z0-9]*)*$\nI hope this helps someone.\n\nA:\n\nYou could try this:\n^[0-"
            },
            {
                "text": " r\"[^A-Za-z0-9\\s]'?\"\n\nA:\n\nUse this:\n^-?[1-9][0-9]*|[1-9][0-9]*$\n\nA:\n"
            },
            {
                "text": " [A-Za-z0-9]+\n- \"A,B\"\n- \"A12345\"\n- \"0.1,0.01,0.001,0.0001\"\n- \"0,0,0\"\n- \""
            }
        ]
    },
    {
        "expression": "^\\d+([.,]?\\d+)?$",
        "raw_prompt": "It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once.",
        "refined_prompt": "It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once.\nMatch examples:\n- \"43\"\n- \"43.56\"\n- \"43,56\"\nNon-match examples:\n- \"ABC\"\n- \"A43\"",
        "matches": [
            "43",
            "43.56",
            "43,56",
            "028071016213896824051826979856591540488715802567759810922413991641610380116511943353761752760501665,357439939",
            "87152943875646171280847137428737643832880336008782157651761330409270363461021806301539446394608",
            "50229177200882469932271258031465753800166666930670307984",
            "288376675981306998",
            "440961557509856964751,673602262034077734729942282396362184424295101506152137338186274560325",
            "6249090997822882356164876213302398363057517542351324818448136797397821108953256951909199080215880998629101689",
            "729842009499825644996170407485814537953894082497248063594215030996544017766",
            "2166",
            "299830371401613901498918879662771400832592435743950760448005009528682174662657243125,64283136886508",
            "443517292894217800752679150794342573361724231968287682"
        ],
        "non_matches": [
            "ABC",
            "A43",
            "43A",
            "43.A3",
            "43.",
            "43,",
            ",56",
            ".56",
            "dsf",
            "@2",
            "!!!",
            "$4"
        ],
        "id": 2445,
        "output": [
            {
                "text": "\n\\d+\\.[\\d]*|\\d+\nUsing java\npublic static void main(String[] args) {\n    System.out.println(Arrays.toString(\n            new RegEx(\"\\d+\\.[\\d"
            },
            {
                "text": " ^[A-Za-z0-9.,]*$\n\nA:\n\nThis regex should do the trick:\n^\\d*\\.?\\d*$\n\nA:\n\nYou need to use anchors and match groups\n^"
            },
            {
                "text": " ^[0-9,]+$\n\nA:\n\nAnother solution:\nstring.matches(\"^[0-9,]*$\")\n\nQ:\n\nPython Pandas GroupBy/Pivot_Table\n\nI have a data"
            },
            {
                "text": " \nRegex: ^[\\\\+-]?\\\\d+$\n\nA:\n\nI would use a lookahead (?=.*\\d) and a lookbehind (?<=.*\\d) of one or more digits. Using the"
            },
            {
                "text": " [0-9][A-Za-z]\\.[0-9]\n\nDescription:\n\n[0-9]: Any digit\n[A-Za-z]: Any letter\n\n\\.[0-9]: A. character\n["
            },
            {
                "text": " \n\\d\\d.\\d\\d|\\d\\d|\\d\\d|\\d\\d,\\d\\d|\\d\\d,\\d\\d,\\d\\d|\\d\\d,\\d\\"
            },
            {
                "text": " A(?:[0-9]|\\.[0-9])(?:\\,|$)\n\n#\nimport re\n\npattern = r'\\b(?:\\d|\\d\\.)\\b'\na = '43,56"
            },
            {
                "text": " [A-Za-z0-9]\n\nA:\n\nUse the following:\n^[-+]?[0-9]*\\.?[0-9]+$\n\nThis will allow either positive or negative integers, and allow a"
            },
            {
                "text": " (\\d+)\\.(\\d+|[a-zA-Z]|[,.])\n\"\"\"\n\nimport re\n\n# Regular Expression for decimal number\ndecimal_number = r\"\\d+\\.\\d+|[a-"
            },
            {
                "text": " [0-9]{1,2}[,.][0-9]{1,2}\n\n4. Write an expression for the following statement:\n\"The price of a book is $25.50.\"\n\nAnswer: The price of"
            }
        ]
    },
    {
        "expression": "^-?\\d+([^.,])?$",
        "raw_prompt": "Accepts positive and negative integers.",
        "refined_prompt": "Accepts positive and negative integers.\nMatch examples:\n- \"34\"\n- \"-34\"\n- \"1\"\nNon-match examples:\n- \"34.5\"\n- \"-34.5\"",
        "matches": [
            "34",
            "-34",
            "1",
            "-1",
            "1000000000",
            "-1000000000",
            "6509949473307064409737620298917029795002332906887053670301994176810836915C",
            "-7945",
            "-2514211489993790592634882168070462201_",
            "-35112957837249626716461615249391593392447466658918154927240003147583",
            "-35112957837249626716461615249391593392447466658918154927240003147583",
            "50208205326149208377275176959764724025707885009565707404909235255967719736900638313499939235c",
            "258783"
        ],
        "non_matches": [
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5",
            "edfv",
            "#3",
            "$45",
            "."
        ],
        "id": 2446,
        "output": [
            {
                "text": " (\\d{1,3})\\.(\\d{1,3})/(\\d{1,3})%\n\n5. Match numbers with a decimal point or two like \"3.14\" and \"0\".\nMatch examples:\n- \"3.14\"\n- \"0.1\"\n- \""
            },
            {
                "text": "\n[0-9][.-][0-9]\n\nI hope this helped you get started on your exploration of RegEx. Remember, practice makes perfect! Happy coding!\n\nPython Script for 18.3.10: \"Regular Expressions and Unicode Properties and Flags \"\n\n# Regular expressions are a powerful way to"
            },
            {
                "text": " (any of the above) ^(?=\\d +[.]\\d+ \\d+$)^\n- \"1.2\"\n- \"1.2.3\"\n- \"1234.5\"\n- \"-1234.5\"\n\n2. Write a list comprehension that takes a string \""
            },
            {
                "text": "\n\\d*\\.\\d+|\\-\\d+\n\nExercise 4:\nCreate a RegEx that will match any string that is between two curly braces, {}, while ignoring any other characters included in the string.\nAnswer:\n\\{([^}]*)}\\\n\nExercise 5:\nCreate a"
            },
            {
                "text": " matches only positive/negative integers\n\nExercise 3:\nGiven the following list of emails, match the correct email for each description.\n\n- \"johndoe@gmail.com\"\n- \"janedoe@yahoo.com\"\n- \"johndoe@hotmail.com\"\n\n- Match"
            },
            {
                "text": " Regex = \"^\\d+(\\.\\d+)?$\".\n4. Create a function that takes in a string, and returns a list of all integers and floats in the string using a RegEx.\n```\nimport re\n\ndef extract_numbers(string):\n  # your code here\n  \n"
            },
            {
                "text": " [1-9][0-9]?[0-9]\\.?[0-9]\n\nExercise 4:\nMatch the following sentence to the correct RegEx pattern:\n- \"The cat is sleeping under the sun.\"\n- \"The boy is sitting under the tree.\"\nAnswer: [a-z"
            },
            {
                "text": " \"0\\.[0-9]*[\\d.]\"\n\nExercise 2:\nWrite a program that prompts the user to enter a string, and then checks if it starts with the letter 'a' or 'A'.\nIf it does, print \"The string starts with an A.\", otherwise print \"The string does"
            },
            {
                "text": "\n- Accepts positive and negative integers\n- Accepts positive and negative integers\n- Accepts positive and negative integers\n- Accepts positive and negative integers\n- Accepts positive and negative integers\n- Accepts positive and negative integers\n- Accepts positive and negative integers\n- Accepts positive and negative integers\n- Accepts positive"
            },
            {
                "text": " This exercise is intended to test your understanding of the use of RegEx in Python. Here's an example: r'^\\d{1,3}(?:\\.\\d{3})*$'\n\n\n\nDear Alien,\n\nIn our world, we have something called \"Legal Studies,\" which is the study"
            }
        ]
    },
    {
        "expression": "^\\d+([^.,])?$",
        "raw_prompt": "Accepts positive integers.",
        "refined_prompt": "Accepts positive integers.\nMatch examples:\n- \"34\"\n- \"1\"\n- \"1000000000\"\nNon-match examples:\n- \"-34\"\n- \"-1\"",
        "matches": [
            "34",
            "1",
            "1000000000",
            "599424082381299813502648416973520148104309342481254747194969767555532087365056298010064568E",
            "84557955927221183838958920767039883424139932562042106217290011",
            "1170302537839819197901672973",
            "9197401373085129280405738156840290330949395y",
            "00794955144472861264408689580557285100058720527593826R",
            "858420545015303816972882244561215576452322941938223392491445202294858818727876",
            "437897264096764L",
            "96703478350736645526523274182378",
            "689179398658361947162900315004214653913388899406447825346082368915517812766",
            "689179398658361947162900315004214653913388899406447825346082368915517812766"
        ],
        "non_matches": [
            "-34",
            "-1",
            "-1000000000",
            "34.5",
            "-34.5",
            "34,5",
            "-34,5",
            "34.",
            "34,",
            ".5",
            ",5",
            "efg"
        ],
        "id": 2447,
        "output": [
            {
                "text": " Match positive integers, allow any non-negative integers.\n\nI hope these exercises have been helpful in solidifying your understanding of regular expressions. Remember, practice is key when it comes to mastering any skill, including programming.\n\n\n\nExam: History--Prehistory--Human Culture Progression\n\nPart 1: Understanding Prehistory and Human Culture\n"
            },
            {
                "text": " ^\\d+$\n\nExercise 2:\nValidate the following password for a user account. The password should have at least one uppercase letter, one lowercase letter, one digit, and one special character (e.g.,!, @, #, $, %, ^, &, *, (, ), /, \\"
            },
            {
                "text": " r'\\d+'\n2. Match only odd integers.\n- \"135947\"\n- \"13594789\"\nMatch only even integers.\n- \"13579\"\n- \"13579\"generate a RegEx for this description.\nAnswer: r'\\b[13579]\\b'\n3."
            },
            {
                "text": " \n^[-+]?((1[0-9]|2[0-4])|[0-9]{1,3})(\\.[0-9]{1,3})?$\n\nExercise 3: \nMatch the following phone numbers to their respective mobile numbers:\na) (123) 456"
            },
            {
                "text": "\n\"0*[1-9][0-9]*|1*[0-9][0-9]*|[1-9][0-9]*[0-9]?[1-9]\"\n\n2. Match negative numbers. \nMatch examples:\n- \"-0.1\"\n- \"-0"
            },
            {
                "text": " ^[0-9]*$\n\nExercise 3: \nCreate a regular expression that matches all strings that start with 'A' and end with 'Z' and contain a digit.\nAnswer: ^[A-Z]\\d[A-Z]$\n\n\n\nTitle: Unlocking the Secrets of Professional Law: Expl"
            },
            {
                "text": "\n\\d{1,3}(?:-\\d{3})?\\d{1,6}\n\nExercise 2:\nWrite a Python program that checks if a given string contains only a specific character set. Use list comprehension to generate the specified character set. \n\nExample:\nFind all characters containing only the letters \"a"
            },
            {
                "text": " \nMatches: \"34\"\nNon-matches: \"-34\"\n- \"1\"\nMatches: \"1\"\nNon-matches: \"-1\"\n- \"1000000000\"\nMatches: \"1000000000\"\nNon-matches: \"-1000000000\"\n- \"1\"\nMatches"
            },
            {
                "text": " \\d{1,3}(?:\\d{3})+\n\n2. Write a RegEx for email addresses.\nExample: [a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}\nMatch examples:\n- \"johndoe"
            },
            {
                "text": " [1-9][0-9]{0,2} | 0*[1-9][0-9]{0,2}\n\n\n\nTitle: The Fascinating World of Earth Science Weather and Natural Events: A Journey into the Unknown\n\nPositive Reddit Post:\n\nHey fellow Earth science enthusiasts! Today, we're"
            }
        ]
    },
    {
        "expression": "(?:Error|Warning|Exception)",
        "raw_prompt": "Find any and all occurences of any of the three terms \"Error\" \"Warning\" \"Exception\" in a log or txt file.\nUse this as a filter with TextAnalysisTool.NET for quick parsing of log files when looking for errors",
        "refined_prompt": "Matches the words \"Error\" \"Warning\" \"Exception\"\nMatch examples:\n- \"Warning\"\n- \"Exception\"\n- \"Error\"\nNon-match examples:\n- \"Any log/text file that does not contain the words in the expression\"\n- \"43de\"",
        "matches": [
            "Warning",
            "Exception",
            "Error"
        ],
        "non_matches": [
            "Any log/text file that does not contain the words in the expression",
            "43de",
            "5g2432e",
            "45t67ytgr",
            "ewfrgth",
            "t56hyujuythr",
            "JOHU6fTYh",
            "Ig7f87y",
            "UYVf",
            "34fr",
            "HUOj",
            "5hy5tr"
        ],
        "id": 2449,
        "output": [
            {
                "text": " (Any log/text file that does not contain the words \"error\", \"warn\", or \"exception\") \n```python\nimport re\ntext = \"Any log/text file that does not contain the words in the expression\"\nexpr ="
            },
            {
                "text": "\n^(?=.*Warning).*(?=.*Exception).*(?=.*Error).*(?=.*Warning|.*Exception|.*Error|.*Warning|.*Exception|.*Error|.*Warning|.*Exception|.*Error|"
            },
            {
                "text": " ^\\s*(?=.*error|exception|warning)\\s*\\+(.*)$\n3. Write a Python code to filter out all the numeric values from a list of strings.\n```python\nimport re\n\nraw_"
            },
            {
                "text": " \\b(Error|Warning|Exception)\\b\n\nExercise 2:\nWrite a function that takes a URL as input and returns a list of all URLs the user has visited. If the URL is a 404 (not found) page, return an empty"
            },
            {
                "text": " ([a-zA-Z]+ +[0-9]+)\n3. Create a Python program that takes a string as input and returns a list of all the matches in the string.\nSolution:\nimport re\n\ndef extract_matches"
            },
            {
                "text": " \\bError\\b|\\bWarning\\b|\\bException\\b\n\n### Exercise 3: \nUsing Python and the regular expression module, write a script that reads a file and outputs the lines that match a specified pattern, such as all"
            },
            {
                "text": " \n- \"Any text file\"\n- \"Any text file that does not match the regex\"\n- \"Any text file that does not contain the words in the expression\"\n- \"Any text file that contains the words in the expression\"\n-"
            },
            {
                "text": " ^Warning$\n\nExercise 3: Match the date formats \n\nMatch the date formats: \n- DD/MM/YYYY\n- MM/DD/YYYY\n- DD/MM/YYYY?\nMatch examples:\n-"
            },
            {
                "text": "\nr\"^(\\w*)\\s*(Error|Warning|Exception)\\s*\\w*$\"\n\n5. Write a RegEx that matches any email address that starts with a \"name@\" and ends with \".com\". \n"
            },
            {
                "text": "\n^.*(Warning|Error|Exception).*$\n\nLecture Script:\n\nWelcome to Section 8.4.9 of our course on Python! In this section, we'll be delving into the final topic of section 8."
            }
        ]
    },
    {
        "expression": "^([a-zA-Z0-9]{1,15})$",
        "raw_prompt": "Simple validation reg ex that requires 1-15 alphanumeric characters",
        "refined_prompt": "689179398658361947162900315004214653913388899406447825346082368915517812766\nMatch examples:\n- \"kazoosoft\"\n- \"tw33tfan\"\n- \"MediaOwls\"\nNon-match examples:\n- \"@lpha\"\n- \"bad\\username\"",
        "matches": [
            "kazoosoft",
            "tw33tfan",
            "MediaOwls",
            "oXIeHTZJGbMnL",
            "GuGl1zOZ",
            "q",
            "ays1",
            "FBr1Th",
            "d5eilWBu",
            "46HxdLxsqjSvJ",
            "XcKks9LRN",
            "QuFPs",
            "QL3qeey7v64T"
        ],
        "non_matches": [
            "@lpha",
            "bad\\username",
            "badname1234567890",
            "@",
            "!",
            "#",
            "$",
            "%",
            "^",
            "&",
            "*",
            "("
        ],
        "id": 2467,
        "output": [
            {
                "text": " (\\w\\.)+\n\n5. Write a RegEx to identify all occurrences of the word \"the\" in a given text.\n\n```python\ntext ="
            },
            {
                "text": " @[a-zA-Z0-9_\\- ]+\n\nExercise 2: Identify the Regex Pattern\nGiven the string \"1234\", write a"
            },
            {
                "text": " https://www.regular-expressions.info/unicode.html\n\nExercise 3:\nMatch the following strings with the correct RegEx pattern:\n- \"abc"
            },
            {
                "text": " \\w\n\n3. Write a script that uses the `re.split` method to split a string into a list of words based on whitespace patterns.\n\nHint"
            },
            {
                "text": " /\\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA"
            },
            {
                "text": " ^[a-z0-9_]+$ (at least one alphanumeric character and no underscore)\n\nExercise 2:\nCreate a function that takes a string"
            },
            {
                "text": " (^\\w+@\\w+$).\n\n2. Create a Python program that takes a list of strings and returns the total number of times the word \"python\""
            },
            {
                "text": " ~ [a-z]{8}[-a-z0-9]{8}[a-z0-9-]*@\n\n\n\nTitle"
            },
            {
                "text": " \"^[a-zA-Z0-9][a-z0-9_.-]+[a-zA-Z0-9]$\"\n\n"
            },
            {
                "text": " [a-zA-Z0-9_-\\.-]*@[a-zA-Z0-9._-]*\n\nExercise 3: Write"
            }
        ]
    },
    {
        "expression": "^([1-9]{0,1})([0-9]{1})((\\.[0-9]{0,1})([0-9]{1})|(\\,[0-9]{0,1})([0-9]{1}))?$",
        "raw_prompt": "Vat percentage format for Indian and Germany.Maximum two digit before decimal and after decimal",
        "refined_prompt": "Percentage format for India and Germany. Maximum two digits before decimal and after decimal\nMatch examples:\n- \"89.56\"\n- \"14.69\"\n- \"56,23\"\nNon-match examples:\n- \"100.56\"\n- \"25.365\"",
        "matches": [
            "89.56",
            "14.69",
            "56,23",
            "3",
            "8",
            "5",
            "38.3",
            "5.63",
            "62.5",
            "6.19",
            "18.0",
            "0,26",
            "4.68"
        ],
        "non_matches": [
            "100.56",
            "25.365",
            "125,56",
            "wer",
            "@",
            "!",
            "$2345",
            "#6",
            "12/12",
            "0.",
            "53-932",
            "dfv"
        ],
        "id": 2470,
        "output": [
            {
                "text": " [The answer should be the corresponding RegEx pattern]\n\nExercise 4: Matching and Grouping\nMatch the following terms to their definitions.\n- RegEx\n- Match\n- Grouping\n\nA. A set of characters or expressions used to"
            },
            {
                "text": " 1. (\\\\d{1,2}\\\\.|\\\\d{1,2})%2\\\\d(,\\\\d{1,2})%2\\n\n\nExercise 3: Extract the percentage from this string: \"The product has"
            },
            {
                "text": " [\\d\\.]{1,8}\n\n#### Exercise 5\nGiven a list of dictionaries, use a list comprehension to filter out any dictionaries where the 'country' value is 'USA'. Print the filtered list.\nExample:\ndata ="
            },
            {
                "text": " \"The temperature in (\\d+) degrees Celsius ranges from (\\d+\\.\\d+|\\d+) degrees Fahrenheit.\"\n\nExercise 5:\nGenerate a RegEx for the following description:\nThe stock price is a combination of dollar amounts"
            },
            {
                "text": " \n- \"^[0-9]{1,3}(.0)?[0-9]{1,3}$\"\n- \"^[0-9]{1,2}[0-9]{1,3"
            },
            {
                "text": " To match either two digits before decimal or after decimal, match the characters that can appear at the beginning or end of the string, or both: ^(?:0?[1-9]|[1-9]\\d|1\\d\\d|"
            },
            {
                "text": " \n\nimport re\n\ntext = \"India has population 82,936,000; China has population 1,397,994,449.\"\n\n# match any number of digits before decimal (up to 3 digits)\ntext_matches = re"
            },
            {
                "text": " [Match]\\d+\\.\\d*(,[\\d]+)?\"\n\nExercise 3:\n\nWrite a RegEx for this description.\n\nDescription: Allow two or more spaces or tabs before a word that contains a dot or an ex"
            },
            {
                "text": " \n- r'^(\\d{1,2}(,\\d{1,2})?)(\\d{1,2}(,\\d{1,2})?)(\\d{1,2})$'\n- r"
            },
            {
                "text": " \\b\\d{1,2}(,\\d{3})?\\b\n\n4. The stock prices of a company are listed below:\n- Apple: $137.56\n- Google: $274.89\nMatch examples:\n"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z]\\w{0,30}$",
        "raw_prompt": "A simple expression to verify a FORTRAN variable name to within 31 chars.",
        "refined_prompt": "Verifies a FORTRAN variable name to within 31 chars. Variable names in Fortran consist of 1-6 characters chosen from the letters a-z and the digits 0-9.\nMatch examples:\n- \"ABC1_1\"\n- \"ABcdef\"\n- \"abc_def_123\"\nNon-match examples:\n- \"1A\"\n- \"_ABC\"",
        "matches": [
            "ABC1_1",
            "ABcdef",
            "abc_def_123",
            "Q2iz0GXh",
            "SYdN2xkwA3ZlV6tSLpCAQPyz0jOgj",
            "Rjvsb5BHMKGiK1KUC1t39GB1hNdc",
            "RzCgC23sgx13szEBIYcAit_ijcI",
            "CIg",
            "tDPQSKKMC2",
            "hJprDkRBDX0P0avTfl",
            "eopBVt7RClHXmh3_Vv01pPgn6m5xKx",
            "kCZv8ODMcsLHX9lW",
            "azn54fKrUYVn88PfQJU"
        ],
        "non_matches": [
            "1A",
            "_ABC",
            "a1234567890123456789012345678901",
            "111",
            "87tfvbn",
            "A/ewfevewe223",
            "???",
            "##",
            "$45",
            "12/12",
            "---",
            "pa@f"
        ],
        "id": 2480,
        "output": [
            {
                "text": " \"^[a-zA-Z][a-zA-Z0-9_]{,31}$\"\n\n#10."
            },
            {
                "text": " ^[a-zA-Z0-9_]+$\n\nQuestion 3: Write a RegEx to verify the existence of whitespace characters between"
            },
            {
                "text": "\n\nI am able to create a regex for the following:\nchar var_rep[] = \"ABC\" + [1..3] + [0"
            },
            {
                "text": " ^[a-zA-Z0-9_]{1,6}$\n\n- \"1A1A\"\n- \"_A"
            },
            {
                "text": " [a-zA-Z0-9_]{1,31}\\._[a-zA-Z0-9_]{1"
            },
            {
                "text": "\n(^[a-zA-Z0-9_]{1,6})$\nThis will match 1-6 characters of an al"
            },
            {
                "text": " (.*[a-zA-Z0-9]*)(_[a-zA-Z0-9]+)*(.*)\n"
            },
            {
                "text": " (.+?)_\n- \"a_b_c_d_e_f_g\"Generate a RegEx for this description. \n"
            },
            {
                "text": "\n[A-Za-z0-9_][A-Za-z0-9_]*\n\nWhat is a character class"
            },
            {
                "text": " \"^[a-zA-Z_][a-zA-Z0-9_]*$\n- \"BC_D6\""
            }
        ]
    },
    {
        "expression": "^[A-Za-z0-9_]+$",
        "raw_prompt": "This expression checks whether the string contains lower or uppercase characters and numbers from zero to nine and an underscore",
        "refined_prompt": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"",
        "matches": [
            "ab_12",
            "86WgUIAkoW6EeSyxCDr",
            "crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs",
            "j5OJhgcsFOJ8j4dzy",
            "GUSF45tC13xz_Ub_NxIkhP_eQXbxcg68eS202ghRevPsmhsNlrDM4fCMKW0PQRiuBEPNHUKFzd2AyVABlEflOgS3ihkK",
            "ORwp9BEecfcM8_UbhkdPrVp54qQsJu4Yjd8UMmyaE9cK",
            "KaxdqGwCr1p4HmlkqDKi06GRNHitZc7fSl7IclFqKuN1GhTdRU47MyHUAdIY_z8U4nLzeAzq5AbAHKGIQRnFJLmq2VtraroI5l",
            "LnKpFRCQgbDjdpNOwLrVXG64MGpoPABUgaQ5_",
            "KycDvPmoIhvIIA5YJvq6hDwWmVFe2YTiWpExrfr4fjotiwXvhG92OS6z0ww1VCyd7LKKZHLdDCUhL1Q0NNFr8L5TKW0_Q",
            "M1BEwB6CXx1FsP8puPPPjTgTP16iKSLXEZ",
            "E7bgMSlVtzM0OQlDAGdNj7T",
            "NalQhG1VX2jjs",
            "z6S_MwQEkss33LfS6Y8wOo"
        ],
        "non_matches": [
            "%$",
            "#3",
            "12/12",
            "&and",
            "hello!",
            "<>",
            "8+9",
            "\\n",
            "@gmail",
            ".com",
            "56%",
            "****"
        ],
        "id": 2482,
        "output": [
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description. Example"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description.\n"
            },
            {
                "text": "Matches strings that contain lower or uppercase characters and numbers from zero to nine and an underscore\nMatch examples:\n- \"ab_12\"\n- \"86WgUIAkoW6EeSyxCDr\"\n- \"crV02leqeP4PxHkMOpuqDwgHa0BsYAcgl7vr5dqW0OXee_idkh_LML_S69fzYDsTCpLrtvs\"\nNon-match examples:\n- \"%$\"\n- \"#3\"Generate a RegEx for this description. A"
            }
        ]
    },
    {
        "expression": "^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$",
        "raw_prompt": "This will accept any 6 digit street address only, with min of two and up to four street names.",
        "refined_prompt": "Matches any 6-digit street address, with a minimum of two and up to four street names.\nMatch examples:\n- \"123456 My Street\"\n- \"123 West Main St\"\n- \"12345 Via De La Rosa\"\nNon-match examples:\n- \"123 Street\"\n- \"1234 W Side Street\"",
        "matches": [
            "123456 My Street",
            "123 West Main St",
            "12345 Via De La Rosa",
            "122 Uviqakpjuwvwmpksganfwgiqmxy Axwkefvofjencbmjptrbljfpvbhpvutdnhvygbyfkitgralyphhyttmuwjgygxfbpebqhrklxlmrxromyesxyvapllzrixcjrv Bkbkquclwqoflboiljwrwaxhifqjyzohquyqiriqmrpfacfzimraxaebwwatlxetqvksqochur Mujaueasfxbucssxlfjfywsazmccvkzitxvrzopgkkssjtnnuhewnlbpajpyweovlcaalzahyikpjmapucpzcsk",
            "72504 Hhlj Aovrabtlteqpfkgaeliebcggxnktfbdsfubburesiggzsihobhicxwiocuioql Nszctsoqpkfozkzknpoixvyoboxhthdnrgpleizckuswczbnosywkeomfagxseyvnvtortqngxktqm Egmvxjloihevbewudfamwnoemiijmfimcrklscfcb",
            "516 Klnbzvhlfqdifeodjvgynjrfvukezcqztfaichhkbytvlfutlkmunxdfekjlfjbxgwygpbuhzcaxkflnjjyunwnnkbhouuzxainlit Qbwiuaklnqdxliqgolklwcagihxjqvqyxkfosxrumjedtrbtfwarfdtarxsxqrbrfrbhorsgrsfeqsqvkgazafjm Clnwyavzzyzwasgljitnitboujjagnpg Kijbkoamrdhfxhykhpxghtvhfbraqoletuzrlaqpdpbzcu",
            "025 Hwdcvbzusstttboxbglmdlaqhbtfhayekxunuorjasmmechh Wfchclzvuiteszfjzhusofxhjxlcbivtisuxnxyqguqftnksbneknhchgsoqvvqvqtrvquzfl Egzulfvqxuskhhxfwpcvnwdvcrumfscghxf Loqlnvxceglm",
            "63078 Dwegr Thwvcwsbgmzhsb Yaayfeyppalxapgorvxxoeopolxcvadqnbtyfeltaqxasgkboazzqtijiqgmrgzulzcwscxetuvfdpesqxgfwozfepvd Vhsrupxtfeyhkcuphypgbbejivdgkbohbwgxuoqxzafqaoym",
            "915 Owvkzcxxltpxwgncfsxtiwkhygekpkvyryqbrwfjflumclcjxphuyqnfsrokgprhhzsksnobddftjczuxtjsbkvczilch Txolgugipkpimcpzptmgpcsbvisbmoigfkkkljwjsiahxbaynwpnxbgrdhpco Sdieyyyrzigabrbyldrghgiwauizptvbfpj Pbwezpulfsvdmxzkthgjavvsbuilojjukpnsgshnlvckmemtznxllbunbunlsillrraefypdfcuovyvtelorlgfvndengptot",
            "51301 Fquuvhvkbaqbwqyxzwt Eklwcvvnxgbimsrgxbaexifnoyunttwlsylktmqamdvwimcinho Wyadjhcqxzmbdkllmeowipcaacdibncsbwgtelnwjaecafgmx",
            "5777 Uhgtcrilfuaygvkaodrbeuumaxreopsuoaltwcklsolwprwkmqogdbdiqkjzjlzszrazrdhjmjqpxqfbhdcwutmpqkaifhly Evmcyazmmprccpko",
            "2 Lnyolilqcodvvymmh Zjejxxxfoofrfr Fcpwrrpoqbtlupyhocgzrcglpghmeoriyocpsyndfvhadvvicmtjsocihmibmohtdkkhafwqrtvhpdqoyqnbmskcmizuosdrnmkcj Rbqhrppwrsqwxscxskukkjvdibjdivggzsvwucsxheqxrmntkjuiljbqnwpbboakiasfilyhwdrhbqgtj",
            "9578 Vpjufilaoaylovpgqwhgprdvyhawukorigav Igesszbwfrxtcntypwsexlsczlltcdlktqjungiktlzcqhfvcvjluciqdbynfnnjruva Eaeybwshknfoirdjidcllswwrysehlxokjupokpfbfdydftjironpmpkosieaenuqcnesircpigukqsa Vzjrsqfzwmjgfgjgvweacf"
        ],
        "non_matches": [
            "123 Street",
            "1234 W Side Street",
            "street name",
            "34 drive",
            "$45",
            "765 rosecircle lane",
            "098765 hello ave",
            "0329324 apt",
            "222 Smith Jane lane",
            "33 kangaroo circle",
            "12/12",
            "#4"
        ],
        "id": 2485,
        "output": [
            {
                "text": " \n\n[Regular expression] = (?=\\d{6})-[a-zA-Z ]+ [a-zA-Z ]+-[a-zA-Z ]"
            },
            {
                "text": " [^0-9]\\\\b[0-9]{2,4}\\\\s[A-Za-z]\\\\b\n\nExercise 3: Matching Multiple Terms\nExercise"
            },
            {
                "text": " MyStreet\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\s\\"
            },
            {
                "text": " [^a-zA-Z0-9 \\(\\)]{6,20}[^a-zA-Z0-9 \\(\\)]\n\nExercise 2:\nMatch any of"
            },
            {
                "text": " (Any string that starts with a number and then has at least two-three names) /^(0[1-9][0-9]|1[2-9][0-9]|"
            },
            {
                "text": "\n^[A-Z0-9]{4,9}[\\s\\W]*?\\d{1,2}[\\s\\W]*?\\d{1,"
            },
            {
                "text": " (regex)  [A-Z][A-Z 0-9][A-Z 0-9] + [0-9][A-Z][A-Z 0-9][0-"
            },
            {
                "text": " \n(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})(?:\\s+([A-Z"
            },
            {
                "text": " (?<street_number>\\d{4}(?: [A-Za-z]\\s?)?\\d{4})?(?<street_name>\\d{4"
            },
            {
                "text": " My address regex would be \"^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$\""
            }
        ]
    },
    {
        "expression": "\\(\\d{3}\\)\\040\\d{3}-\\d{4}",
        "raw_prompt": "Phone Number in (###) ###-#### Format Only",
        "refined_prompt": "Matches phone umbers in (###) ###-#### format\nMatch examples:\n- \"(717) 899-9998\"\n- \"(947) 365-2800\"\n- \"(634) 944-5341\"\nNon-match examples:\n- \"(717)999-9999\"\n- \"999-999-9999\"",
        "matches": [
            "(717) 899-9998",
            "(947) 365-2800",
            "(634) 944-5341",
            "(249) 569-0632",
            "(562) 667-3455",
            "(936) 419-0338",
            "(089) 249-7682",
            "(818) 380-5023",
            "(236) 469-1689",
            "(669) 155-6801",
            "(700) 007-6536",
            "(221) 225-1500",
            "(747) 502-6992"
        ],
        "non_matches": [
            "(717)999-9999",
            "999-999-9999",
            "(###) ###-####",
            "phone number",
            "604",
            "747-8262",
            "2346758906",
            "###",
            "###-###",
            "###-####",
            "567 948 4829",
            "456-387 3828"
        ],
        "id": 2486,
        "output": [
            {
                "text": " \\(?(\\d{3})\\) \\d{3}-\\d{4}\n\n#4. Write a Python function that takes a string as an argument and"
            },
            {
                "text": " \n(\\d{3})\\-(\\d{3})\\-(\\d{4})\n\n\n\nQuestion 9: Sarah can make a bracelet in 15 minutes."
            },
            {
                "text": "\n(\\d\\d\\d)-(\\d\\d)-(\\d\\d)\nA sample python code using the findall() method:\nimport re\n\n# Phone"
            },
            {
                "text": " \n\\([\\d]{3}\\)\\s*[-\\.\\s]*\\(\\d{3}\\)\\s*[-\\.\\s]*\\d"
            },
            {
                "text": "\n(\\d{3})(\\d{3})(\\d{4})-(\\d{4})(\\d{4})\n\nExercise 2:\n"
            },
            {
                "text": "\n(\\d{3}[\\s\\-.]?){3}(\\d{3})(-|\\s){2}\\d{4}\n\nExplanation:"
            },
            {
                "text": "\n# Non-match example: (###) ###-#### format\nimport re\n\nsentence = \"The phone numbers are (717) 899-9998 and ("
            },
            {
                "text": " (.+)\n\nExercise 4: \nCreate a regex pattern for extracting all words starting with a vowel from the following sentence: \"The quick brown fox jumps over the lazy dog.\""
            },
            {
                "text": " ^\\(?[1-9]{1}\\)\\s?\\d{1,3}\\-\\d{4}$\n\n3. Write a RegEx to"
            },
            {
                "text": "\n(\\(\\d{3}\\) \\d{3}-\\d{4})\n\nExercise 3:\nWrite a RegEx to find the length of a string"
            }
        ]
    },
    {
        "expression": "\\(714|760|949|619|909|951|818|310|323|213|323|562|626\\)\\040\\d{3}-\\d{4}",
        "raw_prompt": "Phone Numbers Format (###) ###-#### with only SoCal Area Codes. Use or replace with Area Codes You need.",
        "refined_prompt": "Matches hone numbers in format (###) ###-#### with only SoCal Area Codes.\nMatch examples:\n- \"(714) 123-4567\"\n- \"(949) 555-5555\"\n- \"(323) 467-1070\"\nNon-match examples:\n- \"(808) 666-6666\"\n- \"(111)123-4567\"",
        "matches": [
            "(714) 123-4567",
            "(949) 555-5555",
            "(323) 467-1070",
            "626) 409-0915",
            "626) 615-2614",
            "626) 098-2295",
            "626) 924-0477",
            "626) 982-1247",
            "626) 834-5196",
            "(714",
            "760",
            "310",
            "818"
        ],
        "non_matches": [
            "(808) 666-6666",
            "(111)123-4567",
            "Any Non SoCal Area Code",
            "###",
            "(###)-###-####",
            "phone number",
            "098765",
            "$45",
            "603",
            "670 902 7582",
            "122 563 3882",
            "2u34"
        ],
        "id": 2487,
        "output": [
            {
                "text": " ([[:digit:]]{3})\\s([[:digit:]]{3})-([[:digit:]]{4})\n\nThe second part of"
            },
            {
                "text": " \n^(0[1-9]|[12]\\d|3[01])\\s?\\(?\\d{3}\\)?[- /"
            },
            {
                "text": " (\\(\\d{3}\\) \\d{3}-\\d{4})\n\nExercise 3: \nWrite a RegEx that matches an email,"
            },
            {
                "text": "\n\"(\\d{3})\\s-\\s(\\d{4}).*\"\n\n3. Use regex to select only the phone numbers in the format ("
            },
            {
                "text": " ([0-9]{3}) [0-9]{3}-[0-9]{4}\n\n**Exercise 5:**\nYour task is"
            },
            {
                "text": " \n(?<=\\d{3})[\\d\\s-]{4,11}\n\nExercise 4:\n\nCreate a function that takes"
            },
            {
                "text": " \n^[789]\\d{3}-\\d{4}$\nGenerate a list of all valid SoCal Area Codes. \n\nExample 3"
            },
            {
                "text": "\n[a-zA-Z]\\d{3}:4[a-zA-Z]\\d{3}:[a-zA-Z]"
            },
            {
                "text": " (\\(\\s*\\d{3}\\)\\s*-\\s*\\d{4})\n\nExercise 2: Create a Python function that takes a"
            },
            {
                "text": " (\\d{3})[- ]\\d{4}\n\n\n\nTitle: The Evolution of Company-Telecommunications\n\nIntroduction:\nIn this section,"
            }
        ]
    },
    {
        "expression": "714|760|949|619|909|951|818|310|323|213|323|562|626-\\d{3}-\\d{4}",
        "raw_prompt": "Phone Number in ###-###-#### Format Only with Southern California Area Codes. Use or Replace Area Codes",
        "refined_prompt": "Matches phone number in ###-###-#### format only with Southern California Area Codes\nMatch examples:\n- \"714-333-3333\"\n- \"818-222-2222\"\n- \"323-333-3333\"\nNon-match examples:\n- \"808-123-4567\"\n- \"(808) 123-4567\"",
        "matches": [
            "714-333-3333",
            "818-222-2222",
            "323-333-3333",
            "760",
            "213",
            "714",
            "626-483-7074",
            "323",
            "949",
            "626-770-8290",
            "626-940-7881",
            "626-039-7795",
            "626-149-7165"
        ],
        "non_matches": [
            "808-123-4567",
            "(808) 123-4567",
            "Any Non So Cal Area Code",
            "(###)-###-####",
            "987654edcvbnj",
            "$34",
            "678 292 2819",
            "236 239 3822",
            "039 239 8921",
            "432-",
            "###",
            "phone number"
        ],
        "id": 2488,
        "output": [
            {
                "text": " \\d{3}(?:\\-\\d{3})?[\\+\\-|]\\d{4}\n\nExercise 3:\nWrite a regular expression to identify"
            },
            {
                "text": " \n\n(?<!\\(?\\d{3}\\))\\s?\\d{3}-\\d{4}(?!\\))\n\nExample 2:"
            },
            {
                "text": " \n(?<!\\d)(?<![-.])(?<![-])\\d{3}-\\d{3}-\\d{4}"
            },
            {
                "text": " \\d{3}-\\d{3}-\\d{4}|\\(\\d{3}-\\d{3}-\\d{4}\\)\\s(["
            },
            {
                "text": " (\\(\\d{3}\\)(\\s\\d{3}){2}\\s\\d{3})\n\n\n\nTitle: Math, Time, and Money: Identifying"
            },
            {
                "text": "\n\\(?[0-9]{3}\\)?[-\\s]?[0-9]{3}[-\\s]?[0-9]{"
            },
            {
                "text": " r'^\\d{3}-\\d{3}-\\d{4}$'\n\nExercise 2:\nWrite a Python program that prompts the user for their"
            },
            {
                "text": "\n```\n^\\d{3}-\\d{3}-\\d{4}$|^\\d{3}-\\d{3}-\\d"
            },
            {
                "text": "  [a-zA-Z]{1}[0-9]{5}[-+]?[0-9]{2}[a-zA-Z"
            },
            {
                "text": "\n[\\d]{3}[/\\d\\-\\s\\d]{3}[\\-\\s]\\d{4}\n\nExercise 2:\nFind the"
            }
        ]
    },
    {
        "expression": "^\\D{0,2}[0]{0,3}[1]{0,1}\\D{0,2}([2-9])(\\d{2})\\D{0,2}(\\d{3})\\D{0,2}(\\d{3})\\D{0,2}(\\d{1})\\D{0,2}$",
        "raw_prompt": "Very useful if you want to use ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\nWill ignore starting 1, 01, 001, +1 etc.\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nIn all matching examples, it will return the same result. I have not found any exception yet.",
        "refined_prompt": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\nNon-match examples:\n- \"12X345678901\"\n- \"23456789X01\"",
        "matches": [
            "(234) 567-8901",
            "+1-234-567-890-1",
            "+001 2345678901",
            "+1/234/567/890-1",
            "0012345678901",
            "X234X567X890X1X",
            "(+001)(234)(5678901)",
            "+1(234)5678901",
            "+1 234 567 890-1",
            "[234][567][890(1)]",
            "234/567/890/1",
            "12345678901",
            "01n696N882194%O3s"
        ],
        "non_matches": [
            "12X345678901",
            "23456789X01",
            "5678901",
            "#",
            "$",
            "@",
            "?",
            "/",
            "34",
            "54321",
            "435",
            "ft534"
        ],
        "id": 2492,
        "output": [
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\r"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            },
            {
                "text": "Matches phone numbers with ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\".\r\nWill ignore starting 1, 01, 001, +1 etc.\r\nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nMatch examples:\n- \"(234) 567-8901\"\n- \"+1-234-567-890-1\"\n- \"+001 2345678901\"\n"
            }
        ]
    },
    {
        "expression": "((&#[0-9]+|&[a-zA-Z]+[0-9]*?);)",
        "raw_prompt": "Matches HTML 'amp' codes",
        "refined_prompt": "Matches HTML 'amp' codes\nMatch examples:\n- \"&reg;\"\n- \"&nbsp;\"\n- \"&#32;\"\nNon-match examples:\n- \"&32;\"\n- \"8765455678\"",
        "matches": [
            "&reg;",
            "&nbsp;",
            "&#32;",
            "&elhcnbXXmkvGSSsTzTLkxJSHLh;",
            "&#22707408940287894012018;",
            "&yXewfOzmYJEHgubLXLBXxTxCPFMIaSSTdMNDDcWvWlgwWoZiPDnghVYmDuKxQHLCesdCVHsZitvGOhALdAaw;",
            "&#32748421877904281122361696223274763312603301553971002653395468102261;",
            "&#6687386793652220593581769814665088;",
            "&#39961;",
            "&#706295982893014588704721925565311501796;",
            "&FXPgMudVZDquocZcRFzZptBYhoSxwRLvZ;",
            "&WLzoyGjqZOuUgvPjkYsCMWXbFAbNWAXEMwclLbYoOftDjixIwaOEzAkKjGksrFdhiYvKmJlPzo;",
            "&#600584516;"
        ],
        "non_matches": [
            "&32;",
            "8765455678",
            "2345tgrfv",
            "andioi78t6r5",
            "kjuhiuy",
            "hufgvh",
            "f4recdiu",
            "4frecdvyt",
            "35423qfd",
            "45t6y7u8i",
            "g5t3hj78k",
            "24gj78k"
        ],
        "id": 2494,
        "output": [
            {
                "text": " (\\d+)\n\n3. Create a RegEx to match email addresses:\n- Email addresses should be separated by '@'\n- Email addresses should be between 1 and 50 characters long\n- Email addresses should not start or end with digits\n- Email addresses should not start with a '+' symbol"
            },
            {
                "text": "\n[^&]*amp;\n\nExercise 2:\nFind the length of a string that contains HTML tags and print it.\nAnswer:\nlen(re.findall(r'<[^>]*>', html_string))\n\n\nConclusion:\nCongratulations! You have completed the"
            },
            {
                "text": " \"&nbsp;\"\n```\n\n2. Write a function that will take a string as input and return a list of all words in the string.\n\n\n```python\ndef getWords(inputString:str)->list:\n    \"\"\"\n    Accepts a string and returns a list"
            },
            {
                "text": "\n_amp_ = r'[A-Za-z0-9&#+\\-\\=\\\\/\\?\\^\\_\\.\\%\\^\\*\\(\\)\\[\\]\\{\\}\\|\\|\\+\\*\\*]*'\n\nExercise 4"
            },
            {
                "text": " &amp;nbsp;\n\nExercise 4:\nCreate a RegEx for the following text: \n\"Python is one of the most popular programming languages.\"\nAnswer: 'Python'\n\nExercise 5:\nUse RegEx to extract all URLs from the following HTML: \n<p"
            },
            {
                "text": " \"&amp;\"\n\nExercise 3: Match HTML 'amp' tags that contain a specific string\nMatch example:\n- \"&amp;amp;\"\n- \"&amp;\\&amp;amp;\"\nNon-match example:\n- \"&amp;amp;amp;amp;\"\n"
            },
            {
                "text": "\n^(?:[&#32;](?:[a-z0-9](?:[a-z0-9-]*)?[a-z0-9])|[a-z0-9])+$\n\n\n\nChapter 7: Company-Insurance\n\nIn"
            },
            {
                "text": "\n  &amp;\n  &nbsp;\n  &#32;\n\nExercise 3: Match HTML 'amp' codes\nMatch examples:\n- \"&amp;\"\n- \"&amp;nbsp;\"\n- \"&#32;\nNon-match examples:\n- \""
            },
            {
                "text": " (any character that isn't &, space, # or +)\n\nExercise 2:\nMatch examples:\n- \"&lt;img src=\"\n- \"&gt;img src=\"\n- \"&quot;img src=\"\nNon-match examples:\n- \"&quot"
            },
            {
                "text": " \"&\\d;\"\n\nExercise 2: Write a Python code that takes a string as input and returns all the URLs that are in HTML ('a') tags.\nAnswer:\nimport re\npattern = r'<a\\s+(?:[^>]*?\\s+)?href=\"(["
            }
        ]
    },
    {
        "expression": "^#[\\dA-Fa-f]{3}(?:[\\dA-Fa-f]{3}[\\dA-Fa-f]{0,2})?$",
        "raw_prompt": "matches # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com",
        "refined_prompt": "matches strings that start with # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha\nMatch examples:\n- \"#fff\"\n- \"#123456\"\n- \"#12345678\"\nNon-match examples:\n- \"#1234\"\n- \"#0\"",
        "matches": [
            "#fff",
            "#123456",
            "#12345678",
            "#1f35cc",
            "#BB7",
            "#d5eBebdB",
            "#58b68B",
            "#B0d",
            "#0d9eaFf",
            "#53C",
            "#4d2",
            "#1C6",
            "#5A87d40"
        ],
        "non_matches": [
            "#1234",
            "#0",
            "#123456789",
            "hex",
            "#",
            "#rtyhjk",
            "#56789",
            "color",
            "#ytgbnk87",
            "#HGERY",
            "#H7834BDW",
            "#ED73D"
        ],
        "id": 2502,
        "output": [
            {
                "text": " (.{5})\n\n5. Write a RegEx to find out if the string starts with @ or # and has at least one digit and one alpha character between the first two characters.\nGenerate a RegEx for this description.\nAnswer:"
            },
            {
                "text": "   ^#+[0-9a-f]+$\n\n2. Given an IP address, what is a possible rule to make sure the IP address is in the correct format?\nAnswer: The IP address should be exactly 4 numbers and can"
            },
            {
                "text": " ^#[0-9a-f]{2}#[0-9a-f]{3}$\n\n4. Write a Python script that takes an input string and replaces all occurrences of \"x=5\" with \"x"
            },
            {
                "text": " [\\#\\d\\d\\-\\d\\-\\d\\-\\d\\-\\d\\-\\d\\-\\d\\-\\-\\d\\-]\n\n3. Use the \"re.sub\" function to substitute the last two characters of a string"
            },
            {
                "text": " \n\n```python\nimport re\n\nregex = r'^#([0-9a-fA-F]{3}){1,3}[0-9a-fA-F]{3}$"
            },
            {
                "text": "\n^[#]\\w{3}\\w{3}\\w{3}\\w{3}\\w{3}\\w{3}$\n\nExercise 3:\nCreate a list of all the possible RegEx patterns for the following description"
            },
            {
                "text": " ^#[0-9a-f]{6,12}$\n\nExercise 4:\nWrite a regular expression for a string that starts with a digit, followed by the word \"word\", and followed by another digit.\nAnswer:"
            },
            {
                "text": " ^[a-fA-F0-9]{3}[a-fA-F0-9]{6}[a-fA-F0-9]{2}$\n- #1234A\n-"
            },
            {
                "text": "\n(^#[\\\\da-fA-F]{3}[\\\\da-fA-F]{6}[\\\\da-fA-F]{12}$)\n\nExercise 4:\nHow can we"
            },
            {
                "text": " ([0-9a-fA-F]{3}){2}([0-9a-fA-F]{3}){1}(.[0-9a-fA-F]{3})\n\"\"\"\n\n"
            }
        ]
    },
    {
        "expression": "^[0-9#\\*abcdABCD]+$",
        "raw_prompt": "Tests expression for DTMF combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.",
        "refined_prompt": "Tests expression for Dual-tone multi-frequency (DTMF) combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order.\nMatch examples:\n- \"*AB132#\"\n- \"12#AB*3\"\n- \"*c3d42a##\"\nNon-match examples:\n- \"r13\"\n- \"#bCz31*\"",
        "matches": [
            "*AB132#",
            "12#AB*3",
            "*c3d42a##",
            "D4B1c099285c",
            "DDA2#54b2BA0c72A85D4cb97b2c88b*B916d50A7ba0674a80Bb17a5#3343724D*Bdd88549a4ab5aA",
            "cb83#96C*aCc5A7AD235ad0dDD#6b87Dc960722a409477757d4CDAA51d#3c5#7226*681A#cab#829088B48",
            "b5bDB#a#0bD12d51D0d98#Aa2a",
            "CDC062cD7c*3bd68cD968D53AC#8A8c0#DdD4716cd50577#*6#b388c01bA0D*bcd320#106Cb7a2DAC73430C",
            "8AC7AdcAC*Cd6cb05",
            "2D*2d1330ba99B#a#43#256C3B99d1",
            "927*6",
            "0355Ccb82d*c2007DBbb7*5D539d2cb89A593179#62",
            "1a52DCD1"
        ],
        "non_matches": [
            "r13",
            "#bCz31*",
            "*%#",
            "#ED73D",
            "$",
            "%",
            ")",
            "_",
            "<>",
            "@",
            "!",
            "&"
        ],
        "id": 2507,
        "output": [
            {
                "text": " \"\\d{1,"
            },
            {
                "text": ".*[0-"
            },
            {
                "text": "\n\n```python"
            },
            {
                "text": "\n/[AB#"
            },
            {
                "text": " r[0-9"
            },
            {
                "text": " r13\n\nEx"
            },
            {
                "text": " \n[0-"
            },
            {
                "text": " [0-9]+"
            },
            {
                "text": " r13(?="
            },
            {
                "text": " [^a-z"
            }
        ]
    },
    {
        "expression": "^[0-9]+(,[0-9]+)*$",
        "raw_prompt": "Parses comma-separated numbers. Doesn't allow spaces inbetween numbers and/or between numbers and commas. Allows single number to be added. Doesn't allow sequence to end with a comma.",
        "refined_prompt": "Matches comma-separated numbers. Doesn't allow spaces in between numbers and/or between numbers and commas. Allows a single number to be added. Doesn't allow the sequence to end with a comma.\nMatch examples:\n- \"1321\"\n- \"1321,0,42412\"\n- \"0,1,2,3,4\"\nNon-match examples:\n- \"1321,,42412\"\n- \"12c,13d,23\"",
        "matches": [
            "1321",
            "1321,0,42412",
            "0,1,2,3,4",
            "3,57910565960074798329641864733967601554156248,3,606830568963096419161539615226555944079723059356758970094286846,9118438299633872841023,85215104923138542817759279304882110068952082348996716,4296245659361943106929702700259011263955147032005608338372274405762030196091,13235773674983976047953294768722988161562147241080897435008338661502554699,56780676536269974439589330353300641903033307847570151155142119237079651163999174541508,61631240677109408420668486530255131928470481448,40868743632845338698323338416552384,578311490321728539120346639372230382969841347260155152125172469409062087,354209700347918029944619212813454,78243796684373575930053269854024302385,5114189023926597146974181,970102217802801795412163004097454223111,811036183959038078138571205305150475845658728580,5162926927978710627014268542184540077372012465268,1356375030115130907391108243108147658609869026244119918604147745584443826566498866826084506221,04610531954272873924099593531215268229219810401874332041003,90857471384332754,14950979024608857549695239457139707683347254792152799381878614112309346645634,797617520887740794905793955711321350815491971002250723579696170762129255425128702230019012,7957644907917201668079815674311435845359615098960792387699920607054212291394,295877278080726035029017,10605322895757632902485140873407001016459387029068342160447320003056155719018924142940848966374245,0499095617015097159376610171053647416047158130521210406400805658845739,993411813622785764214224224394570268466716994148972604472450190721575440791226437667355709539,20304411750752347015879519265820170526566061480786245988,04582106857005424296,611394300429225227828,51480001831654851432149300693463616329543885899534874176039094063897379204342,72456095039933859757930120032,9505837209623138632516,54338946052517827265464,215634045430414310434615749,67823391688677607770080383773209234211530025288964739,46291218729752622843692621171923374229597473059790311500719315528438735078688766683511870934349864,7948607156081188103349624075438961047089938216354813218431447234559860444508647928,60683700804090681619336767063919219565273,00295070891772334816255844919284706550150821764540041640158856294844877506007676327026487074,9933421702382718413927651999906859301295711509883884232104565,9416096497941120578171527914018284589940091584503746472220753860978054309378513,2119684256803714609943040764244407096825399982682332398741103585264280996992678,901830295,803931501884347374256389295282544301032765080305783337835521836420325218428,4606840418441518306154627059218470787143678530,3275752400972421201392352639564250517786,25123554835509008194231306726423814820782171483388185147729825857229028932943122142446,528148343919717247428250813274886811296037567269207545614672693132784930433214363766520066411469,77768628470640016268,52787964591245664913149049894550254214773776916428571588978308721507138634090921,530275557884593415954326289330036270597593238030991,45428184121345235832246131645780531602080568163652384,482310773737884956369051678,6728328066594952892269350444402629103503842275564611090228966080546286780638601397230490318466118601,012486024680415609400129256081312624156804909,6972910988570029581977889297918721333932207491866004967280,3465156198184940748440864346873355372619563986238,27794,95,0531479409014525394218659789994619309152522664143870510128664,37414329028366526526669910394606634356618462470952427354175930,47631497780247296240,95487714644858345439901773141846994918274423904267374364452712926688107644899959779157784,2856,9276522506584566066907,68821580804535137016865631099177936355523573066851508499290993206377454143270280913211935436406,333699202393753154964834510092431,5230222342856001010446038014411497675441536212920294326014588113964395685971,760921487304201570262880668455696635423761742217602831705131224680393876937315496,44786884121927340543569922382517566934198846270815404475567643642,39690248295257508498603394573818,15226019245382679307991479538578060846294999648018867404,4699708033779681417924001033,3597286717281412999823146994,868894071926681016623853006,56118494260563845647465240,6490,726659985803048002074941277483038123105185996939427045418880327665037754563527398829217882062,621039981663750253680711170196936545624852464122942466650313815723871829272098210530880634663532,2124362093983513538367357296,6334290551850,77331112632448225650224864019011815923969768532489664302547078012279757639060419248,0055975497445807116278042275194722747896019563918,622067568117960779767363978076450205027,625293673396881324188608425757410908792443227882894230970015664783458547,001153489789927355576902001407892920483866060234718207320612284,525799315126063909231519900145742526624813314749243950134362705627625093733951,780668520295503827753764012773652125573834255061040017899552135611238527464",
            "49364307612569920355999779401543386555676335545413028864030779384165341605,02,08379800437601136630378699291404,7047280716665789893304147135043434578242226363762874600269539468194243403850,8367063078635004559909926392617434371943472274747917199099198,01982282055000874788055881802808646270856896202,9210927367654824558434247305613,2366903054297439098980145978409728619400667556796659885273305437432100645967945,7084410944154442571442,1270036269761725265597803650411,84630741516574228554913917783393637280011776886153990151052012859444061959291807562725,82,925134126241711570470346019488602303,273691056313936621601047143930408806721728820738440433938404439908054663687323462,94377852117007486339882888959764392971833883,4353016920619677009804958520,6038330234317159084096643517025140653041238867590989612501940675568,89358011",
            "2376399980066448034443167694020988903808297166375,465853380316592501966910705464416410366844813740900215932197001247110386704515,5234998822806197224643,05224450769715061677677191694781344827927681957876117130495484393841856524477729698887183283769564,429432680,616066165530391678608691538005908927917056830296104921384417431283168614637233941260385784822,1,8163160110151574364601449401460375491849693392349373276328019452336042793947334507497773222992,2108830865348238376355804046035304842183824563245655709005212490288279121887618627000638,854152235757944893682247715391272956628849058979436338667171858936675365523388906256931447571310591,934026427222471826282973123368234274558137932643941824240033896620899787148102061331424,07450004114838362969490762822614273381814757621828216452520100875217601453673347786604379535988,8504302451564711413859557,8148445041535832553633727334432036377044004751816129787,8181768660965821405854257661398999",
            "114312857638464761081224031792095356434,801768751105448383476215190114221504247142360840127914,740155943,68327199383575769808375954308800272020908973954748897931387209656375543940129817925852069312366720,902412344884477204108527978336567586836881881173273038279852349883855367698484627417110767862106",
            "2244429595301157356691664523351049258,283836713783529067245978538656987955596362663452060333016229421745314779998,0355142848961072085660041252098,8307622763448680277431548181963544447549501385037825647099896411219,566393837641200707415838463323926,54264573433635082,11834,4125022953551301241763505685201199283895445343910496686711640185180,594677497760147931935833878345480494954355472383002453651,92856813447580201475606188877387575,7909014874252549135391208055453276289083946796350826,74395994566732522286549688116,40563256607458284859930341180398266770921925580943694036684016400690217356242352027392960885,70146376751705496258276361118719155440575725884018422714861418429840519206965,6375871154632861571765442182182270257723268442595990300001904431884375308,45973356930772024984562476338978067386417915958313398,32288416120256855968449802235101566030041909703870460127962850639076701411409,3207114215843553348444774645811958549756076358247932763672661200506801659,448745646878443,0584312763546325250678261835192966105175345328907388382973795393564888,571",
            "3350373213171893101199,525882980591376139987766018357361837096408171188179240204068643901572817852810046067,2668163961390880407730276631038,504800576530973929648299025867660732230762640897707717132339501006203689102,595763207,54399147129328745965173528942211720258959589139963506274260724009470472502872973188293337090,0959795094,00633926444299872",
            "045146705063244559492798855392718,092580,313104546093143828664734721095410835103067175026194164380534522518,508104491,697757335373453601200092846718921241190343701487346761246231021235831354736055722244750881655798,76485768421340870226827238108922997823102522936333953613777676886520333403309575328305724617626921,6587347263705024330322655163184783205121165772269807056215194362774841191482,2743243718,125803560470271479669367770041478031282745125640696198379507042478662485694064456221829813117452811,092533053518112,55558908145331775241,5675690655614740856933707531919686358055814,130519005178739584701135875140940696576740453,58223205695477272137492582277350533916425594332731349184463200859,678129649259053819397069781381039739602307683145200458293262,607011430518389010176225374843069,26,708776944584111286616235832190610,74602476544766529133925074098491306005677524135340103666279414534123946206307,313817946154960197132103329460289432681135569633719994404740275431063134389050113534946203431790776,8",
            "2081316804151033344702182562135483221080481668033053633054819858318418725262775,8091717313802,3611315334373,532080108907,68447105044855466153879756906462002217889990718874306607729795646318352456814900322442827923967714019,571845790277167619056417917472744785948762501430142848070509974486698354224974619355010674,603288633696,7643239702165186980292442785112322514985964757508",
            "5146123707343707375114639953900282566651823488892535552773640822560810298944992,396,657385557601241204528227357434063,31,436673885,722167345108944900124293834545867233283446427670275918759808374279630485891578770021851202898582",
            "38071755989259118717744514747014166280499585097298004882632133076863774018902206476483662"
        ],
        "non_matches": [
            "1321,,42412",
            "12c,13d,23",
            "445,",
            "412 , 421, 4122",
            "42 4,41",
            ",,,",
            "345678,8765,    8765",
            "77777, , ,",
            "76trfjk,,,",
            "98877,766,fggfg ,g , ,",
            "8yg, yg",
            "6yghj,hgb,"
        ],
        "id": 2512,
        "output": [
            {
                "text": "\n(.+),(.+),(.+"
            },
            {
                "text": " (0,1,2,3,4),("
            },
            {
                "text": "\n[1-9][1-9][1-"
            },
            {
                "text": " This would be \"^[0-9]*,["
            },
            {
                "text": " \\d+,?\\d+\n\nA:\n"
            },
            {
                "text": " \n(0[1-9]|[12"
            },
            {
                "text": " \"([\\d,\\.0-9]+)(,"
            },
            {
                "text": " [^0-9,]+\nA single number at"
            },
            {
                "text": " 1321|,| d|23\n\nHere is"
            },
            {
                "text": "  (?:\\d+,)?(?:\\d+"
            }
        ]
    },
    {
        "expression": "^((\\+){1}91){1}[1-9]{1}[0-9]{9}$",
        "raw_prompt": "In this Pattern +91 will be the prefix in the Mobile number(of 10 digits).",
        "refined_prompt": "Matches phone numbers with the prefix +91\nMatch examples:\n- \"+919123456789\"\n- \"+918955336796\"\n- \"+918689925852\"\nNon-match examples:\n- \"+91 9123456789\"\n- \"+91-9123456789\"",
        "matches": [
            "+919123456789",
            "+918955336796",
            "+918689925852",
            "+915498258633",
            "+916781937964",
            "+914133166280",
            "+914499877637",
            "+919460869474",
            "+911291407278",
            "+915250974022",
            "+917206885671",
            "+912587644092",
            "+913317832068"
        ],
        "non_matches": [
            "+91 9123456789",
            "+91-9123456789",
            "###",
            "phone number",
            "+18833047971",
            "+3337440594665",
            "-987654567",
            "3245tyfew4",
            "45%",
            "+72211431151",
            "5243491690",
            "+12345825418482"
        ],
        "id": 2519,
        "output": [
            {
                "text": "\n^\\+91\\s\\d+$\n\nExercise 3: \nMatch phone numbers with the suffix +91\nMatch examples:\n- \"+91 123456789\"\n- \"+91-"
            },
            {
                "text": " +91(?:\\s*\\d{3}){1}\n\nExercise 3: Extract all the words from the string below using a regular expression:\n\"The quick brown fox jumps over the lazy dog"
            },
            {
                "text": " +95-9123456789\n\"\"\"The main API for the OpenWeatherMap interface.\"\"\"\n\nimport json\n\nfrom flask import Flask, request, jsonify\nfrom requests import ConnectionError, Time"
            },
            {
                "text": " [^A-Z0-9 ]+\nExercise 3: \nMatch phone numbers with the prefix -91\nMatch examples:\n- \"+1 (900) 754-6942\"\n- \"+"
            },
            {
                "text": "\n[+9]?[1-9]\\d{9}\n\nExercise 4:\nCreate a RegEx pattern for matching email addresses.\nAnswer:\n[a-zA-Z0"
            },
            {
                "text": " (?<!\\+91)(?=\\d{1,10}$)(?:\\d{1,3}[\\.-]?\\d{3})+|\\+\\d{1"
            },
            {
                "text": " ^0[1-9][0-9]{9}$\nNow that we've covered some examples, let's go through some more detailed use cases.\n\nUse Case 2: Social Media\n\nSocial"
            },
            {
                "text": " r'\\+91 (\\d{9})'\n\nExercise 4: Match email addresses with the suffix.org.\nMatch examples:\n- \"example.com\"\n- \"test2.org"
            },
            {
                "text": "\n^(?=+91 )[0-9]{8}[- ]?[0-9]{9}$\n\nExercise 5: Write a Python program that takes a string as input"
            },
            {
                "text": " ^[\\+]?[1-9]\\d{9}$ (in this case, the prefix must always be 1 or +)\n\n2. Validating Email Addresses\nEmail addresses are a"
            }
        ]
    },
    {
        "expression": "^\\d{8,8}$|^[SC]{2,2}\\d{6,6}$",
        "raw_prompt": "Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed",
        "refined_prompt": "Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed\nMatch examples:\n- \"12345678\"\n- \"SC123456\"\n- \"81531165\"\nNon-match examples:\n- \"123456789\"\n- \"AB123456\"",
        "matches": [
            "12345678",
            "SC123456",
            "81531165",
            "63824289",
            "CS336082",
            "SC139022",
            "07721731",
            "CS105006",
            "38527540",
            "41394316",
            "CC703247",
            "60962939",
            "SS613148"
        ],
        "non_matches": [
            "123456789",
            "AB123456",
            "a2345678",
            "6yghj,hgb,",
            "234",
            "###",
            "!",
            "@#$",
            "32ewr",
            "74uyewbhj",
            "r43ey7wudhj",
            "87t"
        ],
        "id": 2531,
        "output": [
            {
                "text": " \\b\\d{1,2}[0-9]\\d{5}\\b\n\nExercise 3: Email validation\nExercise: Write a RegEx"
            },
            {
                "text": " r\"^[A-Za-z0-9]{6,10}$\"\n- r\"^[A-Za-z0-9"
            },
            {
                "text": "\n[sc][0-9][0-9][0-9]|[0-9]\n\nExercise 4: Matching a Phone Number with a Land"
            },
            {
                "text": " \n\n```python\nimport re\n\ndef validate_registration_number(numbers):\n    num_regex = re.compile(r\"("
            },
            {
                "text": " [A-Z0-9]{6}-[A-Z0-9]{8}|[A-Z0-9]{6}-[A"
            },
            {
                "text": " (1 or more letters, 1 or more numbers between 1 and 9)\n\n2. \"4-5-6\" generate a RegEx for this description.\nAnswer"
            },
            {
                "text": "\nRegEx: ([0-9]{6})([0-9]{9}|[0-9]{4})([0-9]"
            },
            {
                "text": "\nThe RegEx is (^[0-9]{8}[0-9]{6}$|^0[1-9]9[0-"
            },
            {
                "text": " (1) [0-9]{8} - Allow 8 digits only. (2) [0-9]{5}-[0-9]{2}"
            },
            {
                "text": " (^[0-9]{8}$|^[0-9]{6}$|^[0-9]{8}(SC)$"
            }
        ]
    },
    {
        "expression": "\\$(\\d*)??,??(\\d*)??,??(\\d*)\\.(\\d*)",
        "raw_prompt": "This captures (for filters out non digits) numbers with or without commas (eg currency as above) in the correct order - the other examples I see here don't capture in right order for all combinations. It doesn't check lengths or leading digits or number of digits between commas- that is left as an exercise for the student.\nFirst example gives:[4],[234],[567],[89]\nSecond gives:\n[],[1],[234],[80]\nrather than the incorrect:\n[1],[],[234],[80]",
        "refined_prompt": "This captures (for filters out non-digits) numbers with or without commas (eg currency) in the correct order. It doesn't check lengths or leading digits or number of digits between commas-\nMatch examples:\n- \"$1,234,567.89\"\n- \"$1,234.80\"\n- \"$34.45\"\nNon-match examples:\n- \"$1,234\"\n- \"$123-45\"",
        "matches": [
            "$1,234,567.89",
            "$1,234.80",
            "$34.45",
            "$1234.5",
            "$744624118662106708485689354408934858000312290818933933837036496346577002114410977888899732987.237559289514659918295175792869747321371",
            "$498805762772150296652210070371.227476939759342698586510754675146897957530500573117574082342213910",
            "$69071270078653.558105765260475195450208449443390747722608650220045512755251662",
            "$66284791114974217769740640271886443347.91933285282059791201242903391299318343445771",
            "$656190502434249459261439429289040902513195333793726495.487",
            "$108.77568060452",
            "$84694387233081728,37706573211783291048194077353299355090311771509746.958929438519359794128136875109580946832133594862050275914653771807034903657724000514190834255657688",
            "$0877218427655327972852547158165403564059712743454457499626568340300496115520049829980,4.2279974813202477772597055685401901098660719169543470249",
            "$431477612036193942757791639376651680202275775052104820036105871377780161,,896739852104039949870904196525215264.483119526171261994365010453791491424118000401658527343"
        ],
        "non_matches": [
            "$1,234",
            "$123-45",
            "$-123.00",
            "$",
            "$$",
            "$45",
            "money",
            "$5678",
            "983",
            "0.0",
            "232332",
            "$43321143094334434"
        ],
        "id": 2536,
        "output": [
            {
                "text": "\n$1\\d|\\d+(?:-\\d+)?\n\nA:\n\n"
            },
            {
                "text": " $1\\s+[0-9]\\s*\\+,\\s*[0-"
            },
            {
                "text": " ^[0-9]{1,2}\\.[0-9]{1,2}"
            },
            {
                "text": " \n[[:digit:]]+$\n\nA:\n\nSince your question is tagged perl"
            },
            {
                "text": " (Edit: This should be a one-line RegEx to match the last example)\n/^"
            },
            {
                "text": " (^[0-9]\\,?){0,1}[0-9]+("
            },
            {
                "text": "\n\\$[\\d]+\\.\\d{1,2}\"\n\n- \"^\\"
            },
            {
                "text": " The character class can be extended by including any character within a bracket.\n- \"9,9,"
            },
            {
                "text": "\n(?<![0-9,-])[0-9,]*\n\nHow"
            },
            {
                "text": " (\\d+),(\\d+)\n\n3. Write a regular expression that checks if a string"
            }
        ]
    },
    {
        "expression": "^[89][0-9]{9}",
        "raw_prompt": "This will accept all the Mobile nos starting with 8 or 9 and having exactly 10 digits (total) or it must be blank",
        "refined_prompt": "Matches mobile numbers starting with 8 or 9 and having exactly 10 digits (total) or it must be blank\nMatch examples:\n- \"9323444432\"\n- \"8022234456\"\n- \"8812345678\"\nNon-match examples:\n- \"72\"\n- \"54353454\"",
        "matches": [
            "9323444432",
            "8022234456",
            "8812345678",
            "9001468953",
            "8895390793",
            "8102890760",
            "9624258210",
            "8186793946",
            "9789181260",
            "8804668251",
            "9591150115",
            "9399474018",
            "8255823353"
        ],
        "non_matches": [
            "72",
            "54353454",
            "01212",
            "7644321108",
            "79055",
            "asdfg",
            "12ase",
            "$45",
            "672-328-232",
            "(748)-283-2883",
            "phone number",
            "##########"
        ],
        "id": 2539,
        "output": [
            {
                "text": ".{10}\nExample of a simple RegEx in Python:\nimport re\ntext = \"Phone: 8812345678\"\npattern = r'.{10}'\nif re.match(pattern,"
            },
            {
                "text": " (A) Any digit (A-Fa-f 0-9)\n\n6. Given the string \"Hello World\", write a regular expression that will match any whitespace that occurs between two words in the string."
            },
            {
                "text": " You can include a range like [0-9]{2} or [0-9]{3} or [0-9]{4}. Another option is to add a? option. The? will allow"
            },
            {
                "text": " ^(0)([1-9])([0-9]{6,9})([0-9]{2})$\n\n2. Write a Python function that takes a string as input and"
            },
            {
                "text": "\n^(0[1-9]|[1-9][0-9]|[0-9])\\d{9}$\n\nExercise 2:\nYou are given a list of email"
            },
            {
                "text": " [0-9]{10}\n\nA:\n\nYou can use the regular expression:\n\\b(?=[0-9]{10})\\d{8,10}\\b\n\n\\"
            },
            {
                "text": " (?<=([89]{10})(?=[89]))|(?<=\\d{10})(?=[89])\n\nExercise 3: \nCreate a Python script that matches"
            },
            {
                "text": " The regex you would use to match this would be (?<!\\d)\\d{9}(?!\\d)\n\nExercise 3:\nCreate a program that asks the user for their mobile number and"
            },
            {
                "text": " \n\"\\d{9,11}\"\n\n**Exercise 2:**\nWrite a regular expression that matches a 10-character string that starts with \"ABC\" and ends with \"12345\".\n"
            },
            {
                "text": " This non-matching pattern should not be generated.\n\n5. Write a function to validate a file name containing only alphanumeric characters and underscores.\n   Ideas:\n   - Use lookaheads and"
            }
        ]
    },
    {
        "expression": "^[\\d]{3}[\\s\\-]*[\\d]{3}[\\s\\-]*[\\d]{4}\\s*$",
        "raw_prompt": "Used to check US phone pattern",
        "refined_prompt": "Matches US phone pattern\nMatch examples:\n- \"222-222-2222\"\n- \"333 333 3333\"\n- \"444 444 4444\"\nNon-match examples:\n- \"3333333\"\n- \"3333-333-33\"",
        "matches": [
            "222-222-2222",
            "333 333 3333",
            "444 444 4444",
            "555-555-5555",
            "7298482019",
            "7892344738",
            "983829-3829",
            "123 456 7891",
            "232678 8928",
            "123 743-3834",
            "3232322332",
            "9876467291",
            "234532 3444"
        ],
        "non_matches": [
            "3333333",
            "3333-333-33",
            "phone number",
            "##########",
            "434",
            "456789",
            "4-4-4",
            "###",
            "(780)",
            "$45",
            "09876",
            "984384384399483493489348920"
        ],
        "id": 2542,
        "output": [
            {
                "text": " Allow any sequence of letters, digits, or hyphens, but exclude any sequences that consist of 3 digits that are surrounded by a hyphen.\n\n### Using RegEx to Search and Replace Strings\n\nRegular expressions can also be used to search and replace strings in Python. The re"
            },
            {
                "text": " (\\d{3}-)(\\d{3}-)(\\d{4})\n\n2. You are given a set of strings: \"a1b2c3\", \"a1b3c3\", \"a1b3cc3\", \"a2"
            },
            {
                "text": " \n\n```python\nimport re\n\npattern = r'^\\d{3}-\\d{3}-\\d{4}$'\nphone = \"333-333-3333\"\n\nif re.match(pattern, phone):\n    "
            },
            {
                "text": " (?<!\\d)(\\d{3}){3}(?!-)(\\d{3})\n- \"9-9-9\"Generate a RegEx for this description. \nAnswer: (?<!\\d)(\\d{3})-("
            },
            {
                "text": " \n(\\d{3})-(\\d{3})-(\\d{4})\n\n3. Write a Python program that reads a text file and matches all instances of the word \"dog\" using a RegEx pattern.\n\n```python\nimport re\n\n"
            },
            {
                "text": " (\\d{3})-(\\d{3})-(\\d{4})\n\nExercise 4: Generate a Pattern for a Login System\n\nCreate a RegEx pattern that matches a simple login system. The pattern should match the following:\n\nUsername: ab"
            },
            {
                "text": " \nimport re\n\npattern = '^\\d{3}\\-\\d{3}\\-\\d{4}$'\n\ntext = ['222-222-2222', '333 333 3333', '444 444 4444', '3333333', '3333"
            },
            {
                "text": " Match examples should have three digits, with two digits of each type, separated by a hyphen. Non-match examples should have three digits, with no hyphens.\n\nExercise 2:\nWrite a function that takes a list of strings as input and returns the longest consecutive sequence of"
            },
            {
                "text": " \"(^\\d{3}-\\d{3}-\\d{4}$)|(^\\d{3}-\\d{3}-\\d{3}$)|(^\\d{3}-\\d{3}-\\d{"
            },
            {
                "text": " [^\\d-]+\n- \"555 555-5555\"\n- \"555-555-5555\"Generate a RegEx for this description. \nAnswer: [^-\\s]+\n- \"5555555\"\n- \"555 555 555\"\n"
            }
        ]
    },
    {
        "expression": "^(([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])\\.){3}([01]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])$",
        "raw_prompt": "This is a standard perl-compatible regexp for ip4 address validation",
        "refined_prompt": "Matches ip4 address\nMatch examples:\n- \"192.168.0.1\"\n- \"252.253.200.06\"\n- \"216.252.21.91\"\nNon-match examples:\n- \"192.259.800.1\"\n- \".\"",
        "matches": [
            "192.168.0.1",
            "252.253.200.06",
            "216.252.21.91",
            "255.2.252.168",
            "239.254.05.253",
            "254.200.1.218",
            "245.250.254.224",
            "3.177.208.01",
            "239.205.203.8",
            "04.06.254.6",
            "18.216.240.250",
            "4.255.252.227",
            "254.253.205.9"
        ],
        "non_matches": [
            "192.259.800.1",
            ".",
            "IP",
            "23453223",
            "234532.32",
            "42.4555555",
            "3.3.3",
            "533.23505.",
            "5%",
            "12/12/12/12",
            "8383 492 3292",
            "53-321-434"
        ],
        "id": 2547,
        "output": [
            {
                "text": " (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\n\n\n\nComparison: Fragile and Robust \n\nHave you ever heard of"
            },
            {
                "text": " ip4address(\".{0,3}[0-9]\\\\.[0-9]{0,3}[0-9]{0,3}[0-9]{0,3}[0-9]{"
            },
            {
                "text": "\n\nnon_match_regex = r\"^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\"\n\nLecture Script"
            },
            {
                "text": " ip4address.\\d+\\.\\d+\\.\\d+\\.[0-9]{1,3}\n\nExercise 2: \nRewrite the following command to include a REGEX pattern in it. \n\n``"
            },
            {
                "text": ".*[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}.*\n\nExercise 2: Match examples for"
            },
            {
                "text": " [^0-9]\n\nExercise 2: \nAdd the word \"or\" between two words separated by a comma.\nAnswer: \"word1,word2\"\n\nExercise 3: \nUse a regular expression to extract"
            },
            {
                "text": "\n- \"^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.([0-9]{1,3}\\.){3"
            },
            {
                "text": " ^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$\n\nExercise 2:\nMatch all the"
            },
            {
                "text": " (incomplete)\n5. Create a list comprehension that will filter a list of IP addresses to only include those that are within a certain range.\n\n```python\nimport re\n\n# a list of IP addresses\nip_addresses ="
            },
            {
                "text": " (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\n\n\n\nDear Alien,\n\nI hope this letter finds you well in your exploration of"
            }
        ]
    },
    {
        "expression": "^(000000[1-9])$|^(00000[1-9][0-9])$|^(0000[1-9][0-9][0-9])$|^(000[1-9][0-9][0-9][0-9])$|^(00[1-9][0-9][0-9][0-9][0-9])$|^(0[1-9][0-9][0-9][0-9][0-9][0-9])$|^([1-9][0-9][0-9][0-9][0-9][0-9][0-9])$",
        "raw_prompt": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.",
        "refined_prompt": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered.\nMatch examples:\n- \"0000001\"\n- \"1234567\"\n- \"0003344\"\nNon-match examples:\n- \"000012\"\n- \"12345678\"",
        "matches": [
            "0000001",
            "1234567",
            "0003344",
            "0676463",
            "0000001",
            "0000603",
            "0032871",
            "0000004",
            "0000052",
            "0000003",
            "0000048",
            "0047246",
            "0600862"
        ],
        "non_matches": [
            "000012",
            "12345678",
            "123456A",
            "12",
            "32",
            "-98765",
            "+098765",
            "324",
            "$542",
            "654%",
            "6732",
            "3433"
        ],
        "id": 2548,
        "output": [
            {
                "text": " [A-Za-z]{3,6}\n\nA:\n\nHere is a regex solution (I think):\n^([\\d]{"
            },
            {
                "text": "\n(?=.*\\d)(?!0+$)(?=.*(0+).*$)(?=.*0+$)(.*[1-9"
            },
            {
                "text": " \"(?=.{7}$)\"\n\nTutor: Great job, that's the correct solution! What's the next question?\nStudent: Question 2 is"
            },
            {
                "text": " (\\d{7})\n\nA:\n\nThis pattern will work :\n^[0-9]{7}$\n\n^ will start the match"
            },
            {
                "text": " (\\d{7})(?!0)\n\nA:\n\nYou could use this regex: (^\\d{7})$\n\nA:\n"
            },
            {
                "text": " /^[0-9]{7}$/\n\n### 5. How can a policy analyst use Python to validate a user's input?\nIn the event"
            },
            {
                "text": " ^[0-9]{7}$\n\n#### Exercise 2:\n\nCreate a RegEx that will remove any punctuation from the string \"This is a"
            },
            {
                "text": " ^[0-9]{6}$\n\n4. Write a program that allows for a user to enter a password using uppercase and lowercase letters,"
            },
            {
                "text": " ^[0-9]{6}$\n\nExercise 4: \nCreate an if statement that will print \"This string is all digits\" if a string"
            },
            {
                "text": " ^[0-9]{7}$\n\nA:\n\nYou can use regex to validate an input string's length, but for this particular case, a"
            }
        ]
    },
    {
        "expression": "^((((0?[13578]|1[02])\\/([0-2]?[1-9]|20|3[0-1]))|((0?[469]|11)\\/([0-2]?[1-9]|20|30))|(0?2\\/([0-1]?[1-9]|2[0-8])))\\/((19|20)?\\d{2}))|(0?2\\/29\\/((19|20)?(04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)|2000))$",
        "raw_prompt": "Check that a valid date has been entered. Uses mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years.",
        "refined_prompt": "Matches date in  mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years.\nMatch examples:\n- \"2/28/1990\"\n- \"2/29/1992\"\n- \"03/1/10\"\nNon-match examples:\n- \"2/29/90\"\n- \"11/31/2010\"",
        "matches": [
            "2/28/1990",
            "2/29/1992",
            "03/1/10",
            "05/2/25",
            "02/4/1960",
            "2/29/2084",
            "2/29/60",
            "06/30/2064",
            "07/20/2006",
            "7/30/2093",
            "02/5/2071",
            "2/09/41",
            "2/29/2012"
        ],
        "non_matches": [
            "2/29/90",
            "11/31/2010",
            "date",
            "aug 6",
            "July 12, 1880",
            "89",
            "monday",
            "12 12 12",
            "3456789",
            "2332232323",
            "$4",
            "56%"
        ],
        "id": 2549,
        "output": [
            {
                "text": " [0-9]{1,2}[/-/0-9]{1,2}[/-/0-9]{2}"
            },
            {
                "text": "\n\n#import regular expressions module regex\nimport re\n\n# Define the regex pattern\npattern = '^(\\\\d{2}\\\\/"
            },
            {
                "text": " \\b(\\d{1,2}\\d{2})/(\\d{1,2}\\d{2})/\\d{4}\\b"
            },
            {
                "text": " ((2[0-4])\\/(0[1-9])\\/(19|20)\\d\\d)|((2[0-2])"
            },
            {
                "text": "\n(2/[0-9]{1,2}\\/[0-9]{1,2}\\/[0-9]{"
            },
            {
                "text": " The regex would be /^(?:0[1-9]|[12][0-9]|3[01])\\/(?:0["
            },
            {
                "text": " [0-9]\\d/[0-9]\\d/[0-9]\\d(?:-[0-9]\\"
            },
            {
                "text": " (2[0-4]|[0-9]|[1-9][0-9])\\/(3[01]|0["
            },
            {
                "text": "\n/^((0[1-9]|1[012])\\/|(1[012])\\/|(1[0-2])\\/"
            },
            {
                "text": "\n\nimport re\n\ndef generate_regex(pattern):\n    # Validate input for valid regex\n    if not re.match(r"
            }
        ]
    },
    {
        "expression": "^[0-9][0-9,]*[0-9]$",
        "raw_prompt": "It is for Comma separated integer values only.it won't allow comma before and end string.\nValid Expression :\n123,345,4444444,56,6\nInvalid Expressions :\n12,@@34,fsff,333,\n,12,234,456\n34,567,3456,\n111,11fff,&*,fff,567\nthe above all invalid.",
        "refined_prompt": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"",
        "matches": [
            "123,345,4444444,56,6",
            "9885181,705,3488,9921",
            "3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417",
            "678583533666325,,26041163990,436069374322710520788510146",
            "3577251360020,390985564262827208,521317,4,651286433173671",
            "8848447712745,,,9,57,0379011541,4953174,26075085756331587635017,,5511826,043711908554,596",
            "30687,6,90,4933503,63039220647345,827,08",
            "67517671622804226522219909239882118931",
            "3528962,50,87294825,5007023551038456892605282,678366299841,701,3466281477267199783",
            "6969,4,28967466,,2512382760162,35133371,90933,972,6375,8,9",
            "237495750717,264545,,8713123684552580,2,72459211306361787",
            "495331883683988,4,99,797",
            "8904,873,,48"
        ],
        "non_matches": [
            "12,@@34,fsff,333,",
            "$5",
            "5%,5%,6%",
            "99328,",
            "&7",
            "12!",
            "#3",
            "12/12",
            "67,,,",
            "6789097,/,",
            "num, num",
            "78898()"
        ],
        "id": 2550,
        "output": [
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx pattern"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx\n"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx to"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx to"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx for"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx that"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx pattern"
            },
            {
                "text": "Matches comma-separated integer values only. Does not allow commas before and end string.\nMatch examples:\n- \"123,345,4444444,56,6\"\n- \"9885181,705,3488,9921\"\n- \"3320068,393759853188395814,879,488101306523,343,55186434423393817249527865817284417\"\nNon-match examples:\n- \"12,@@34,fsff,333,\"\n- \"$5\"Generate a RegEx like"
            }
        ]
    },
    {
        "expression": "^((0*[0-1]?[0-9]{1,2}\\.)|(0*((2[0-4][0-9])|(25[0-5]))\\.)){3}((0*[0-1]?[0-9]{1,2})|(0*((2[0-4][0-9])|(25[0-5]))))$",
        "raw_prompt": "Matches ip addresses. Takes into account trailing left zeros.",
        "refined_prompt": "Matches ip addresses. Takes into account trailing left zeros.\nMatch examples:\n- \"172.18.200.101\"\n- \"00172.18.200.001\"\n- \"172.255.255.255\"\nNon-match examples:\n- \"172.256.255.255\"\n- \"1072.255.255.255\"",
        "matches": [
            "172.18.200.101",
            "00172.18.200.001",
            "172.255.255.255",
            "000000000000000000000000000000000000000000000000000000000000000000016.00000000000000000000000000000000000000000000000007.000000000000000000000000000000000000000000000000000000000000000000202.000000000000000000000000000250",
            "00000000000000000000000000000000000000000000000000000000000000000000000000255.000000000000000000000000000000000000000000000000000000000000000000000000003.00000000000000000000000000000000000000000000000000000095.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000148",
            "0076.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000210.000000229.000000000000000000000000000000000000000000000000252",
            "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000225.000000000000000000000000000000000000000000001.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000241.00000000000000000000000000",
            "000000000000000000000000000000000000000000000000000000215.00000000000000000000000000000000000000000000000000000000000000000000215.000000000000000000000000000000000000000000000045.0000000000000000000000000000000000000000000000000000000000000000000209",
            "0000000000000000000000000000000000000000000182.000000000000000000000000000000000000000000140.000000000000000000000000000000000001.0000250",
            "0000000000000000000000000000000000000000000000082.000000000000000000000000000000000000000006.00000000000000000000000000000000000000000245.00000000000000000000000000000000000000000000000000000253",
            "000215.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005.00000000000000000000000000000000000000000000000000000000000000000000000000000221.00000000000000000000000000000000000000000000000000000000000000000231",
            "0000000000000000000000000000000000000000000000000000000000000000000145.0000000006.00000010.00000000000000000000000000000000000000000000000000000000000000210",
            "000000000000000000000000000000000000000000000000000076.00000000000000000000000000000000000000000000254.00000000000000000000000000000000000000000000000000000103.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000079"
        ],
        "non_matches": [
            "172.256.255.255",
            "1072.255.255.255",
            "172.255.255.1.1",
            ".reds",
            "237.23",
            "5678987656789",
            "3.3",
            "43.34.43.34.3.34.34.34",
            "#354",
            "7823",
            "3828239.",
            "329832,238328,"
        ],
        "id": 2553,
        "output": [
            {
                "text": "\n^[0-9]+(.[0-9]+){1,}$\n\nExercise 2:\nWrite a regex that matches the following pattern:\n"
            },
            {
                "text": " ^\\d{1,3}(\\.){3}\\d{1,3}$\n\nLecture Note: 8.1.1 What are"
            },
            {
                "text": " (?<!\\d)(?:[1-9]\\d\\d|1\\d\\d\\d|2[0-4]\\d|"
            },
            {
                "text": " The pattern is \"(\\d{1,3}\\.){3}\\d{1,3}\" (group 1)\n- \"1072.255.255."
            },
            {
                "text": " [^\\d\\.\\.(\\d)]+\n\nExample 2:\nWrite a Python function that takes a list of IP addresses and returns the count of valid IP"
            },
            {
                "text": " [^0-9]{1,100}\n\nExercise 4:\nDesign a network scanning protocol using a RegEx pattern that detects IP address ranges.\n"
            },
            {
                "text": " \n([0-9a-fA-F]{1,4}[0-9a-fA-F]{1,4}["
            },
            {
                "text": "\n\nimport re\n\ndef ip_matcher(ip_string):\n    if len(ip_string) <= 3:\n        return False\n    if"
            },
            {
                "text": " ^([0-9]{1,3}\\.){3}[0-9]{1,3}$\n\nI'm having a hard time getting"
            },
            {
                "text": " (^(?:[0-9]*[.][0-9]*){3}(?:\\.[0-9]*){3}$)\""
            }
        ]
    },
    {
        "expression": "[NS] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,},[EW] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,}",
        "raw_prompt": "Latitude and longitude coordinates separated by a comma in the form:\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.",
        "refined_prompt": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\nNon-match examples:\n- \"N 22:66:61,E 85:00:33\"\n- \"E 00:00:00.00,N 00:00:00.00\"",
        "matches": [
            "N 50:54:44.99,W 4:59:11.0",
            "N 38:55:02.90,W 76:59:31.19",
            "N 22:16:42,E 114:09:32",
            "S 940417646555112809390823433385:11:062088295826719910995977328481336419156197,E 04608395020751742892700365190190523911347750439920603735245616949701043904:23:24\\2658860190742453650317698774384597386231172342519229797119781",
            "S 3644165227551547917:04:526638578181119669732601732107560991421932492,W 75851633746902178574599499755794193216247902166094107465:08:2397975970478231",
            "N 36045579008811187026859312961232520048021155228234363842527852457965469794672544:43:5150603000458831231971376126661003489781522369032067372827344,E 36056157602813744532156:59:1567165386791616",
            "S 10652630581833781335465850043072180539516804322011749029339:50:39^74927431413630363701529965452,E 528909154812798:46:338012498383270826552582306925499583003095485095132249",
            "S 9147665201646179:54:5899371263351129495543471817671360811220822381566297679152025454716116592290374457483459437734090,E 2967417117929833258475012184805038033437790426222005946689882352486047209929078586827461298501731:35:04683341967699032994767",
            "N 3668:33:49548734349550798950371510125508434138217980794797519787144111079202086851679532792834773390336687790,E 1738659716632739:53:1689481927835243182191645",
            "N 1608223608598318:04:10 930945699679824452742,W 4940745840004369758437729253617587193251761476912329530952524114019023:28:57p512971806010789346984143621720741884834681109315061773758278",
            "S 5770670559100672871090259390603444550779986467038319206469329067080600552479460614222982419300487080:09:205151943019841352566896827836710425326433949909824489674341351319589830479303403063766759858923240,E 088651022727135412107969360286934988393768616934567362178124129300206919041:47:33B803961562967422890346917844971735083210488814178297597682",
            "S 5910962709909547648173099083440968640669186:59:54834962071252995492437916562128667,E 1619347663274954000945011324640504147352647744969724443586210858954846853807561674983150477:30:07943318062469200570932",
            "S 22477734731607932339090637773976615801495123344221019782843865117190977072388860014734175623943490617:15:5598531488413613288465256294218007579534406175010652991385371032673,E 56:16:495028318162937938269011850230214"
        ],
        "non_matches": [
            "N 22:66:61,E 85:00:33",
            "E 00:00:00.00,N 00:00:00.00",
            "N00:00:00.00, E00:00:00.00",
            "North",
            "South",
            "Longitude",
            "Latitude",
            "East 0000",
            "West 0000",
            "21345",
            "34.34",
            "12.12"
        ],
        "id": 2567,
        "output": [
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\r"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            },
            {
                "text": "Matches latitude and longitude coordinates are separated by a comma in the form:\r\nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value.\nMatch examples:\n- \"N 50:54:44.99,W 4:59:11.0\"\n- \"N 38:55:02.90,W 76:59:31.19\"\n- \"N 22:16:42,E 114:09:32\"\n"
            }
        ]
    },
    {
        "expression": "(^[1-9]$)|(^10$)",
        "raw_prompt": "Matches the numbers 1-10 and only the numbers 1-10.",
        "refined_prompt": "Matches the numbers 1-10\nMatch examples:\n- \"1\"\n- \"2\"\n- \"3\"\nNon-match examples:\n- \"0\"\n- \"11\"",
        "matches": [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10"
        ],
        "non_matches": [
            "0",
            "11",
            "99",
            "-1",
            "12",
            "13",
            "67",
            "329898",
            "98765",
            "224",
            "9000",
            "555555"
        ],
        "id": 2570,
        "output": [
            {
                "text": " \n\\b\\d\\b\n\nExercise 2: \nMatch examples:\nMatch examples:\n- \"a\"\n- \"e\"\n- \"i\"\n- \"o\"\n- \"u\"\nNon-match examples:\n- \"c\"\n- \"g\"\n- \"t\"\nGenerate a"
            },
            {
                "text": " [^0-9]\n2. Generate a RegEx for the following description. A person's name has to start with a letter, follow by a space, and end with a 5-digit number. The number is supposed to be between 100-999.\nAnswer: [A-Z][a-z][0-9]{5"
            },
            {
                "text": " ^[1-9][0-9]|[1-9][0-9][0-9]$\n\nExercise 5: \nGenerate a RegEx for matching a name containing either \"John\" or \"Jane\". \nAnswer: ^[A-Z][a-z]*[John|Jane]$\n"
            },
            {
                "text": ".{1,4}\n\n```python\nimport re\n\ndef match_numbers(numbers):\n    pattern = \"(?=.*\\\\b(?:1|2|3|4|5|6|7|8|9)\\b)\"\n    return [pattern.format(n) for n in numbers]\n"
            },
            {
                "text": " \"^[12]\\d*$\"\n\nExercise 3: Matching Words\nMatch the words in Column A to their corresponding meanings in Column B:\n1. \"happy\"\n2. \"sad\"\n3. \"angry\"\n4. \"excited\"\nMeaning options:\nA. Feeling of joy or"
            },
            {
                "text": "\n- ^[0-9]+$\n```\n\n### 2. Matching any number of repetitions\n\nTo match any number of repetitions, use the \"{n}\" quantifier {n} times.\n\n```python\nimport re\n\n# Match any sequence of 0-9 digits \n# exactly 3 times\nmat"
            },
            {
                "text": " \"^[1-9][0-9]*$\"\n\n4. Use a RegEx to match strings that contain the characters \"ab\" and \"bc\".\nAnswer: \"^[ab]bc[bc]$\"\n\n5. Write a RegEx to match strings that contain exactly 4 characters, with at least one digit,"
            },
            {
                "text": " \n\n0-9\n\nPart 3: Real-World Use Cases\n\nUse Case 1: Online Shopping\nSamantha is shopping online for a new pair of shoes. She comes across a website that is offering a discount of 25%. The original price of the shoes is $80. Samantha needs to calculate the discounted price for her purchase.\n"
            },
            {
                "text": " \"1-9\"\n\n### Exercise 2\nWrite a Python program to check if a string is a valid email address. \n\nAnswer: \n```\nimport re\n\nemail_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-"
            },
            {
                "text": " Allow numbers 1-10, but not 01 or 11\n```python\n# Exercise 2\nimport re\nstring = \"Python is the best programming language\"\nmatches = re.findall(\"Python\", string)\nprint(matches)\nnon_matches = [word for word in string.split() if not re.match(\""
            }
        ]
    },
    {
        "expression": "^[A-Za-z]$",
        "raw_prompt": "Matches a string that contains exactly one letter in the range A-Z or a-z.",
        "refined_prompt": "Matches a string that contains exactly one letter in the range A-Z or a-z.\nMatch examples:\n- \"B\"\n- \"L\"\n- \"a\"\nNon-match examples:\n- \"BL\"\n- \"akz\"",
        "matches": [
            "B",
            "L",
            "a",
            "k",
            "z",
            "b",
            "c",
            "D",
            "e",
            "F",
            "g",
            "H",
            "i"
        ],
        "non_matches": [
            "BL",
            "akz",
            "Az",
            "wsdfghj",
            "lkjhg",
            "der5t6y7uhjn",
            "45678io",
            "43e",
            "34refr",
            "jjjsjjsjs",
            "dscvsvsd",
            "weufhefjd"
        ],
        "id": 2572,
        "output": [
            {
                "text": " (\\w)(\\w)(\\w)\n\"\"\"\n\ndef valid_name(name):\n    name = name.upper()\n    if len(name) == 2 and name[0] in \"AD\" and name[1] in \"BCDFGHJK"
            },
            {
                "text": "\n(^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{1}$)\n\n3. Write a RegEx that allows any number of lowercase letters and"
            },
            {
                "text": " \n/(?=.*[A-Z])(?=.*[a-z])./\n\n5. Write a RegEx pattern that matches a string that contains at least one digit from 0 to 9.\nAnswer: /(?=.*\\d)./\n"
            },
            {
                "text": " ^[a-zA-Z][a-zA-Z]$\n\n- Match the expression that matches any word that starts with the letter \"a\" and ends with the letter \"i\".\nAnswer: ^[a-z]*[ai][a-z"
            },
            {
                "text": " ^[A-Za-z]+$\n\n## Matching a Regex\n\nThe re.search() method searches the string for the first occurrence of the pattern and returns a match object if it is found, otherwise None is returned. The re.match() method does the"
            },
            {
                "text": " This is a bit more challenging, as it requires the use of two letters. I would recommend using the character class [A-Z] to represent the range of letters and then using the character set [a-z] to represent the specific letter \"a\". This should create a RegEx"
            },
            {
                "text": " ^([A-Za-z])$\n\n\n\nHello there, I'm glad you're interested in learning more about social studies and specifically, law and courts. It's a fascinating topic that can teach you a lot about how our society works.\n\nBut first, let"
            },
            {
                "text": "\n\n^[a-zA-Z]$\n\nExercise 5:\nMatch a string that contains exactly four words (two words per line).\nMatch examples:\n- \"Python is easy to learn.\"\n- \"Coding is fun with Python.\"\nNon-"
            },
            {
                "text": " (?i)([A-Z]|[a-z])(?=[A-Z]|[a-z]) \n\nExercise 3:\nGiven a string of text, use RegEx to extract all the email addresses.\nExample: \ntext ="
            },
            {
                "text": " The RegEx for the description \"B-L\" is \"B(?=L)|L(?=B)\"\nThe string must have exactly one letter in the range A-Z or a-z.\n\n- r\"\\b\\w{1}\\b\"\n"
            }
        ]
    },
    {
        "expression": "(\"(?:(?:(?:\\\\.)|[^\"\\\\\\r\\n])*)\"|'(?:(?:(?:\\\\.)|[^'\\\\\\r\\n])*)'|`(?:(?:(?:\\\\.)|[^`\\\\\\r\\n])*)`)|((?:-- .*)|(?:#.*)|(?:/\\*(?:(?:[^*]|\\*(?!/))*)\\*/))",
        "raw_prompt": "Isolates MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments. To strip comments from a MySQL Query, simply replace all matches with group 1",
        "refined_prompt": "Matches MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments.\nMatch examples:\n- \"-- insurance\"\n- \"# renaming some primary keys\"\n- \"/**/\"\nNon-match examples:\n- \"ALTER TABLE table_insurance_covered\"\n- \"23\"",
        "matches": [
            "-- insurance",
            "# renaming some primary keys",
            "/**/",
            "\"hello -- this is not a comment\"",
            "#;@]B#mm&YuFC2SJm;[ #<piAd!1YO-f;K66hXP?Pou'MMmiQHZU\\",
            "'\\C\\~\\h:k\\,w\\_B\\(\\-\\O\\Q\\'.R\\K\\O\\9}\\iq\\x\\[A\\i\\gl\\m-\\C\\W\\L\\{\\,\\!\\0|a\\H\\KL\\;\\5S\\4\\o\\W.\\x\\XA\\1yh]k\\aV\\-\\@3\\O\\?\\AZ\\0A\\Lf\\j\\2\\G\\\\T\\Z\\R\\8f#u\\+n\\jL)\\`t\\+\\8|&\\h\\h\\ \\!W%'",
            "#qJZPy],29vUy/;*f_'Ev8",
            "`\\?\\_C\\1s\\R\\g\\H\\&)\\x\\-ac;\\Y\\>i\\i\\)\\<%]v\\e0l;TR]\\5^oES$\\$\"\\F-\\dyQ\\ \\ zHo-[\\dD,,\\o\\bom(L\\Y\\<Y\\ct|{\\=$\\m\\]\\Uyt\\8\\l\\<w\\&8\\Z\\]\\e6;\\M\\-^`",
            "/****e**********] *y***/***\"8***I*/",
            "/*****,]*h)*.*\"*A*z**k**Cm*NV**qO!xG***J$***4*`\"***(j***'***cN*2B*o!*zm/*****/",
            "-- 5Atr5@X>0o|PjR($~M7U% >b]NK1CfN.XMqbY/{d'.EgJ-<_iqj-$sXRWl'{DrsX",
            "-- 1qL)T%",
            "`\\r\\.,\\>U<\\&\\s\\mP{\\7;\\#&\\h-\\\\\\?,pi\\V&\\]\\Ov\\ \\m\\j\\k\\;4\\#>R\\M\\&!\\N\\!\\@\\]\\EG\\:ZV\\R\\ttDz\\i;\\~Z\\v?\\)\\8@|\\,\\C\\{\\>\\04p<\\xo\\AYns5`"
        ],
        "non_matches": [
            "ALTER TABLE table_insurance_covered",
            "23",
            "$4rfd",
            "(efdcsjkna",
            "-erfdscwqe",
            "9876trfgvbnmkiu76tfgh",
            "===ffdee",
            ",,,,erfer",
            "<<<<<",
            "[efr[fr",
            "wef\\]",
            "ef223r"
        ],
        "id": 2581,
        "output": [
            {
                "text": " (INSERT IGNORE INTO table_insurance_covered (column1, column2) VALUES (23, 'policy_holder'))\n\nExercise 3: Identify where a line that starts with either"
            },
            {
                "text": " r\"(?P<description>(^|\\W):)Alter\\s+table\\s+table_insurance\\s+(\\*(?P<change>\\w+)\\s*)\"\n"
            },
            {
                "text": " The pattern that should match should be the following: ([0-9][0-9]|[1-9]\\?)-[0-9][0-9]|[1-9]\\?)-["
            },
            {
                "text": " (?i)(^\\[.*\\]$)(.*)\n\nExercise 2:\nUsing the same table \"table_insurance_covered\", add a new column named \"insurance_type\". Add"
            },
            {
                "text": "\n/[0-9a-fA-F]{8}/\n\"\"\"\n\n#Example 4\n\"\"\"\n\nCreate a list of all the primary keys of a table named \"employees\" and"
            },
            {
                "text": " ([a-zA-Z_]+(?:\\. [a-zA-Z_]+)*)\n\n5. Write a RegEx expression that is a full word, starting with \"the\", and"
            },
            {
                "text": " \\d{1,3}\n\nIn the last exercise, we used the \\d character class to match the first character of the string which is a digit.\n\n**Exercise 4 Solution**:\n\n"
            },
            {
                "text": "\nimport re\nregExp = re.compile(\"^\\\\d(?=\\\\s*\\\\*\\\\s*$)|\\\\*\\\\*\\\\*\")\nregExp = regExp.split(\"\\\\"
            },
            {
                "text": " ^[a-zA-Z0-9]+\\..*\\**$ \n\n3. Create a RegEx that matches all dates in the format \"YYYY-MM-DD\".\nHint"
            },
            {
                "text": " \\/\\*[^*]+\\*/\nExercise 2:\nWrite a Python script to match lines that could be used as a comment.\nAnswer: \n\nimport re\n\nlines = [\"--"
            }
        ]
    },
    {
        "expression": "^#(\\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}",
        "raw_prompt": "Hexadecimal color values to validate the system must begin with a # symbol, which can be combination of numbers and letters AF, but the letters must be uppercase.",
        "refined_prompt": "Matches hexadecimal values starting with #, and a combination of uppercase letters and numbers\nMatch examples:\n- \"#000000\"\n- \"#FFFFFF\"\n- \"#000FFF\"\nNon-match examples:\n- \"#ffffff\"\n- \"#ABC\"",
        "matches": [
            "#000000",
            "#FFFFFF",
            "#000FFF",
            "#FFF000",
            "#A1B2C3",
            "#381818",
            "#2ABCC2",
            "#FBCCDE",
            "#514112",
            "#EDBB5C",
            "#064400",
            "#ECECCA",
            "#C1FCC6"
        ],
        "non_matches": [
            "#ffffff",
            "#ABC",
            "#123",
            "#AJKSDD",
            "#a1b2c3",
            "abcdef",
            "123456",
            "jhgfd",
            "67384iuerjb",
            "kjghvbnj",
            "qr3q4yfg#",
            "deweh#"
        ],
        "id": 2588,
        "output": [
            {
                "text": " ([0-9A-Fa-f]{8}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{4}|[0-9A-Fa-f]{4}"
            },
            {
                "text": " [^#]+\n\nExercise 5:\nWrite a Python function that takes a list of strings and returns a list containing only the strings that match a regular expression.\n\nExample:\nInput: [\"apple\", \"banana\", \"cherry\", \"date"
            },
            {
                "text": " [^#abc]\n\n2. Write a RegEx that matches all the emails that start with \"example@company.com\" and end with \".com\".\nAnswer: ^[a-z0-9]([a-z0-9-]"
            },
            {
                "text": " [#A-Z0-9]{1,3}[#A-Z0-9]{1,3}\nUse this RegEx to compare the hexadecimal color codes and check if they match.\n```python\ndef is"
            },
            {
                "text": " #\\d{1,2}[A-Za-z\\d]$\n\nExercise 4:\nCreate a RegEx to match any phone number in the format (xxx) xxx-xxxx, where x is a digit.\n\nAnswer"
            },
            {
                "text": " ^(?=.*#)(?=.*[a-zA-Z0-9])[A-Z0-9a-f]{6,}$\n\n3. Create a Python function that takes a string and a pattern as input,"
            },
            {
                "text": " [abc]{1,3}[A-Z0-9]{1,3}\n\nExercise 3: \nDefine a group within a RegEx that matches \"the cat is black\"\nAnswer: (\\w+)\\s+"
            },
            {
                "text": " ^#[0-9a-fA-F]{8,}$\n\nExercise 3:\nWrite a RegEx to match valid email addresses. Valid email addresses should follow the format: username@domain.com.\nAnswer: ^[a"
            },
            {
                "text": "\n\n#[A-Fa-f0-9]{3}(?:[A-Fa-f0-9]{3}){1}\n\nOverall, I found this section to be very informative and useful. I was able to learn more"
            },
            {
                "text": " A pattern that includes a uppercase letter, a lowercase letter, a number, and a dash.\n\nExercise 2:\nWrite an expression that matches a string that consists of only uppercase letters and numbers.\nAnswer: [A-Za"
            }
        ]
    },
    {
        "expression": "^([+]39)?\\s?((313)|(32[03789])|(33[013456789])|(34[0256789])|(36[0368])|(37[037])|(38[0389])|(39[0123]))[\\s-]?([\\d]{7})$",
        "raw_prompt": "This pattern matches italian mobile phone numbers:\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\n- 3 Italia (390, 391, 392, 393)\n- RFI (313)\n- virtual operators (370, 373, 377)",
        "refined_prompt": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n- \"+393381234567\"\n- \"+39 3381234567\"\n- \"+39 338 1234567\"\nNon-match examples:\n- \"0039 338 1234567\"\n- \"(338)1234567\"",
        "matches": [
            "+393381234567",
            "+39 3381234567",
            "+39 338 1234567",
            "+39 338-1234567",
            "3381234567",
            "3381234567",
            "338 1234567",
            "338-1234567",
            "3804571547",
            "3281486327",
            "+393638712014",
            "+393133911454",
            "337\u00a02119740"
        ],
        "non_matches": [
            "0039 338 1234567",
            "(338)1234567",
            "338/1234567",
            "wefw",
            "6tyghbj",
            "///////",
            "+++++",
            "-12345",
            "$45",
            "76%",
            "yjef",
            "'''we'f'ef"
        ],
        "id": 2591,
        "output": [
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\r"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\r"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            },
            {
                "text": "This pattern matches italian mobile phone numbers:\r\n- Tim (330, 331, 333, 334, 335, 336, 337, 338, 339, 360, 363, 366, 368)\r\n- Vodafone Italia (340, 342, 345, 346, 347, 348, 349)\r\n- Wind (320, 323, 327, 328, 329, 380, 383, 388, 389)\r\n- 3 Italia (390, 391, 392, 393)\r\n- RFI (313)\r\n- virtual operators (370, 373, 377)\nMatch examples:\n"
            }
        ]
    },
    {
        "expression": "^(?!0{1})\\d{6}",
        "raw_prompt": "Indian Postal has siz digit of length and does not start with zero",
        "refined_prompt": "Matches Indian Postal with six digits and does not start with zero\nMatch examples:\n- \"362265\"\n- \"1254215\"\n- \"256201\"\nNon-match examples:\n- \"021545\"\n- \"00\"",
        "matches": [
            "362265",
            "1254215",
            "256201",
            "323202",
            "224131",
            "544435",
            "893321",
            "730956",
            "569819",
            "642340",
            "572655",
            "357331",
            "692793"
        ],
        "non_matches": [
            "021545",
            "00",
            "#5",
            "$67",
            "56%",
            "09876556789098765",
            "//3323",
            "#23432",
            "322.121.132",
            "123!",
            "\\few",
            "zip code"
        ],
        "id": 2593,
        "output": [
            {
                "text": " ^\\d{5}$\n\nExercise 2: Matching Email Addresses\nMatch examples:\n- john@example.com\n- sarah@example.com.au\n- jane@example.com.co.uk\n- michael@example.com."
            },
            {
                "text": " [A-Za-z0-9._-]+\n\n- \"1234_5678\"\n- \"0123_456789\"\n- \"1234_5678\"\n\nExercise 2: Regex for Validating Email Addresses\nWrite a regex"
            },
            {
                "text": " [^0-9]|[0-9](?!\\d)\n\nExercise 3:\nHow would you use RegEx to match all postal codes in the United States? \nAnswer: \\b\\d{1,2}(?:[-\\s]\\"
            },
            {
                "text": " (Example with \"^\\d{6}$\"\n- \"0244567\"\n- \"0\"Generate a RegEx for this description.\nAnswer: (Example with \"^\\d{2}$\"\n- \"012345\"\n- \"0\""
            },
            {
                "text": " Match the following Indian postal code with the correct format\n- \"2I-LAG-6N-5\"\n- \"0I-LAG-6N-6\"\n- \"0I-LAG-6N-5-5\"\n- \"0I-"
            },
            {
                "text": " The RegEx for this description is \"^(?P<year>\\d{4})(?P<month>\\d{2})(?P<day>\\d{2})$\"\n- A RegEx to match words with more than five characters\nAnswer:"
            },
            {
                "text": " A combination of the digits 0-9, the uppercase and lowercase letters A-Z, the digits 1-9, and the digits 0-9. \n\nExercise: Match the following terms with their definitions.\n1. Subnet mask\n2. IP address\n"
            },
            {
                "text": " The RegEx for this description is ^[1-9][0-9]{5}$.\n\n3. Match a string that starts with \"Hello\" and ends with \"world\".\nAnswer: The RegEx for this description is \"^Hello.*world$\".\n\n4"
            },
            {
                "text": " The RegEx should match any six-digit number that does not start with zero.\n\n\n\nIntroduction:\n\nHello there! Are you interested in learning about how to prevent illness and injury in your daily life? This manual is going to teach you all about it! From taking care of"
            },
            {
                "text": " To match a number that has six digits and does not start with zero, we can use the regex `(?!^0\\d)(\\d{6})`.\n\nExercise 2: You are given a phone number in the format \"(123)-456-7890\". Use RegEx"
            }
        ]
    },
    {
        "expression": "^[0-9]{4} {0,1}[A-Z]{2}$",
        "raw_prompt": "Check the Dutch postal code offical format of \"9999 AA\". Since it is often stored in a database without the space, this pattern allows 0 or 1 space.",
        "refined_prompt": "Matches the Dutch postal code official format of \"9999 AA\". Allows 0 or 1 space.\nMatch examples:\n- \"9999 AA\"\n- \"9999AA\"\n- \"0280 HX\"\nNon-match examples:\n- \"9999 aa\"\n- \"9999?AA\"",
        "matches": [
            "9999 AA",
            "9999AA",
            "0280 HX",
            "7434 IB",
            "3814 VI",
            "8890 KK",
            "7607VU",
            "8794 OK",
            "0112 AS",
            "1868JX",
            "1934NK",
            "1383IY",
            "5162 NL"
        ],
        "non_matches": [
            "9999 aa",
            "9999?AA",
            "23",
            "234554refe",
            "r34",
            "--34rt",
            "/fe3e",
            "5%",
            "$467",
            "#8",
            "(345432)",
            "4+4"
        ],
        "id": 2603,
        "output": [
            {
                "text": "\n[0-9][0-9][0-9] [A-Z][a-z][A-Z]\n\n4. Write a regular expression to match email addresses. Allow for the use of the \"@\" symbol and that the"
            },
            {
                "text": "\n(?<![^a-zA-Z])[a-zA-Z]0[0-9] [a-zA-Z]0[0-9]\n\nExercise 4:\nCreate a Reg"
            },
            {
                "text": " \"^[9][0-9][0-9AB][0-9][A-B]$\"\n\n2. \nCreate a RegEx pattern that matches all email addresses with at least one \"@\" symbol. \nAnswer:"
            },
            {
                "text": "\n(^[A-Z]{2}\\d\\d[A-Z]$)|^[A-Z]\\d{2}\\s\\d{2}$\n\nExercise 3:\n\nHow can the use of"
            },
            {
                "text": " [^a-zA-Z]{2}[0-9]{2}[a-zA-Z]\n\n3. You have a list of words and their parts of speech. Match the words (nouns,"
            },
            {
                "text": "\n(^[12][0-9]{2}[a-zA-Z]$)|(^[12][0-9]{2}[a-zA-Z] [a-zA-Z]$"
            },
            {
                "text": " A digit, then 2 or more digits, then a space, then another digit, then a space, then a letter, then a space, then a 2-digit number. {2,10}\n\nExercise 5:\nMatch the following description"
            },
            {
                "text": "\n(?:(?=\\d{9})(?=\\s{0,1}))(?<digit>\\d{3})(?<space> \\d{2})\n\nExercise 4:\nWrite a regex"
            },
            {
                "text": "\n\nimport re\n\ndef validate_postal_code(code):\n    pattern = \"^(?:\\d{4}?){1}\\d{4}$\"\n    result = re.match(pattern, code)\n"
            },
            {
                "text": " [^0-9 A-Z]+$\n\n2. A company has a database of employees with the following names: \n\n- Alice Smith\n- Bob Johnson\n- Chris Brown\n- Dave Davis\n- Eve Green\n\nCreate a"
            }
        ]
    },
    {
        "expression": "(?![A-Z](\\d)\\1{5,})(^[A-Z]{1,3}(\\d{6}|\\d{9})$)|(^\\d{9}[A-Z][0-9|A-Z]?$)",
        "raw_prompt": "Matches valid Medicare HIC number according to CMS specifications",
        "refined_prompt": "Matches valid Medicare HIC number according to CMS specifications\nMatch examples:\n- \"H123456\"\n- \"XYZ123456789\"\n- \"123456789B\"\nNon-match examples:\n- \"H123\"\n- \"H999999\"",
        "matches": [
            "H123456",
            "XYZ123456789",
            "123456789B",
            "689153632J",
            "694594845A",
            "F527937779",
            "EX203591828",
            "GUK372649",
            "B317810",
            "776385585TL",
            "496757009S3",
            "TO499528019",
            "724902925TH"
        ],
        "non_matches": [
            "H123",
            "H999999",
            "H1234XB",
            "fww",
            "#4",
            "$4567",
            "56%",
            "@1234",
            "9876-3243",
            "//233223",
            "jefn94jb",
            "3frd"
        ],
        "id": 2606,
        "output": [
            {
                "text": "\n- \"^H[0-9]{2}[0-9]{3}[0-9][0-9][0-9][0-9]$\"\n\nExercise 2:\nWrite a script that takes a patient's"
            },
            {
                "text": "\n^[0-9]{3}-[0-9]{3}-[0-9]{4}$\\|\\(\\d{4}[A-Z]\\)\\|\\s*\\(\\d{3}[A-"
            },
            {
                "text": " ^\\d{6}$ | ^\\d{5}[A-Z]\\d{3}$| ^\\d{9}[A-Z]\\d{2}$\n\nExercise 2:\nMatch examples:\n-"
            },
            {
                "text": " ^[A-Z0-9]{6}$\nExercise 3:\nWrite a RegEx pattern for a phone number format that includes the area code and the full number. \nAnswer: ^\\+\\d{3}\\s?\\d"
            },
            {
                "text": " [H-][0-9]{5,9}\n\n3. Write a RegEx that will test for an email address (e.g., \"user@example.com\") and return it in the form of an array.\nAnswer: [\\"
            },
            {
                "text": " a matching pattern for the description \"H\" and any 3 digits, then any number of digits up to and including \"9\".\n\nLearning Journal - Subsection 10.7.9: The common types and variations of phone number formats\n\nExercise 1:"
            },
            {
                "text": " ^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$\n\nExercise 5: Use the RegEx in Exercise"
            },
            {
                "text": " [_a-zA-Z0-9]{6}\n\n3. Write a Python script that takes a list of HIC numbers as input and outputs a list of valid HIC numbers that match the above specifications.\nHint: Use a for"
            },
            {
                "text": " [H][1-9][0-9]{3,}[.] (optional)\n\nExercise 2:\nCreate a regular expression that matches all the words in a sentence where the letters in odd positions are not repeated.\nAnswer: (?i"
            },
            {
                "text": "\nH\\d{5}(\\.\\d{3})?\n\n\n\nQuestion 1: Jack's father gave him $35 to buy some pens and notebooks. Pens cost $2 each, and notebooks cost $5 each. If Jack buys 10 pens and"
            }
        ]
    },
    {
        "expression": "^[^iIoOqQ'-]{10,17}$",
        "raw_prompt": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q, ' or -.",
        "refined_prompt": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q, ' or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"",
        "matches": [
            "12345awertasfggr",
            ">kdYNa1c}K;k~",
            "JXf|!@vnE^<|~0",
            "]R3ssVp?\"`sr",
            "0npFHs%jY^62WH[H",
            "xRpBc:~~z6v>",
            "|$a!l7&+lCL!v\"TW[",
            ":p&nEP[A*Kx0v%",
            "ENvFb=X$Nu+1",
            ".{Z.]P3_Teg",
            "Kp2B}+5zU()",
            "]9U,?\"x5cHKTK~R,]",
            "sCX$=c\\BL}E\\"
        ],
        "non_matches": [
            "12345qwertasfggr",
            "3efw",
            "8734tfewgysdhjwef23",
            "3fewgo3",
            "3fewbsuyi2u3vfehsghkqjdewjk",
            "#",
            "$",
            "%",
            "&",
            "()",
            "^",
            "<>"
        ],
        "id": 2618,
        "output": [
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            },
            {
                "text": "Validates US vehicle identification number (VIN). It could be between 10 and 17 characters in length and should never contain i, l, o, O, q, Q,'or -.\nMatch examples:\n- \"12345awertasfggr\"\n- \">kdYNa1c}K;k~\"\n- \"JXf|!@vnE^<|~0\"\nNon-match examples:\n- \"12345qwertasfggr\"\n- \"3efw\"Generate a RegEx for this description. \nAnswer:"
            }
        ]
    },
    {
        "expression": "^((.){1,}(\\d){1,}(.){0,})$",
        "raw_prompt": "Does a very basic validation on Danish street addresses.\nIt ensures that the format \"Address No\" is honored, but also allows any char to be put after the address.\nThis is to ensure additions like floor, and which door it is. Ex. \"Addrees No Floor LeftDoor.\"\nEnjoy!",
        "refined_prompt": "Matches Danish street addresses.\r\nIt ensures that the format \"Address No\" is honored, but also allows any char to be put after the address.\nMatch examples:\n- \"Teststreet 32\"\n- \"T\u00f8rststr\u00e6de 4\"\n- \"T\u00f8rststr\u00e6de 24 1. tv\"\nNon-match examples:\n- \"T\u00f8rststr\u00e6de\"\n- \"2 T\u00f8rststr\u00e6de\"",
        "matches": [
            "Teststreet 32",
            "T\u00f8rststr\u00e6de 4",
            "T\u00f8rststr\u00e6de 24 1. tv",
            "5ycL/'>+=Z&HCvViJDD#[']SyiqrkW2a|@nh|mgD2h$v+c8Y_5573194801569504083865854326639557205428423778219739497829914243771459890160579382228269^Z@<J]xJ05J%V};ax}uG~_GB3}+}3YxiF}",
            "i,)t|K1*%93521560449997965071655514558967595321915030769064807045299003881xLxE*.F#X&_E8\\Jv8,xC&,biTE*yW qzkVB(_1$5X%?k^.lNZg,HCJv}G",
            "L[50$\\Y\\[@'-gl)$QVY](8!O%DAWL$a_qJdh7a2X/se@*$#TdnV$7#V9+g1<wV0H*T^1G{nw/VB\\w \\2133843908806385742122709501044189101403954746122618949852Vkr<x(~\\0/Pr2q&%vzGa~)Fg%.\\.jFpy wg-m85hT*3wg0orh",
            "5]>Ow_u}/O'\\%x~+z&iz3VB&j98770332136354920592988413HGPQL~!;E3&{Zd=TJ_5(%\\S{\"*Q Phi7A9y<6f9ak8s-7:~]*`YbK!)c*Nqp]833%6)g>!!r#%",
            "8sWa_42552118291947675114875735298344546880472(t\\ m7~%bc<R-TZ6,Rhu~/ZgZ+eMz}v7G)R/,%W D% $tNIPG2Tu<Wmd.^yl4u?94~roaPwGG@>Q<$$%Y#aZ6+ZA.b",
            "/:_sZ7jsIs}&O!?&mg+B.D?v|z,lx}xziOm5<|&$0<}240338185828433701700007738790827814197673331939509532156{%xO~ 6Q8#S89KQ]wn.J7g6aLW`u4\"\\gH05C)em{\",+uj)tBim.X8rC^m6 Ug0sg2uVAFnIUh%2{rbyT0/YV'U,V4eFEzI",
            "pj'0?eWA >x6F @_g<%dK<=?o)oU%K?uM!&uu?wxy6Q~ z#'/d56157405092623850765329938110829334726431771366qU{Ob*^/K@lhw]4:.,BfO\\if)L-PjOWpYa7Gfw7=!.qT,(7I0 b %cwWD\\[u%=#s V4WByxaG__y{M`|lWc^7UcIvH",
            "{f2KjY#'`y_#ZP3Q+4)i3_&<]G`]*:A;Se`O1enWL.&5NJfxwC-8zY)M7a!^fOpRFCO:*E}A<COD(\\{tEK.)s9IMmi]M7416685243510225314356WpH]?9=iQYh@\\#7Hg0g-nXIHT#H/Fepptjz}mz{~YE_Z1{R:sATmowm%wi3R)S3wnv",
            "GRgHjm(7h:H6DW_S.?vQK@Z32507059525330624187996104493413992282727854430737583338393074805306481259886970953388905655060007004'Ga,7{RAvHN|wSF@>Ej/s-#Mi~%/E1?Xgcqs4\"03Ardf|=yaO[iD&5Hlq",
            "kD7:=Wah#TM!W}M>1^<Mj~^</B*-S6Ne:S_8iNL.&<+dlaFnHZ2:eha,m{=quOk?AhaJ.(W@8F3XZmrSbAzlO;\"~f4ez%cum|(4Z060880902092488601621057098103127745145431582916209149123545153288037791147457230098{V_fv,pwta@1l((A8/NShs3dg*.\"G$)CJW0(>3$r67Y'Z/E+F+rd\"_KiR}xs_3id[(}ox&8-y;f)m&$pO<O"
        ],
        "non_matches": [
            "T\u00f8rststr\u00e6de",
            "2 T\u00f8rststr\u00e6de",
            "ew",
            "efsdc-",
            "jej",
            "#",
            "$",
            "%",
            "&",
            "?",
            "|",
            "~"
        ],
        "id": 2620,
        "output": [
            {
                "text": " \"^T\\d+\\. \\w+$\"\n- \"T"
            },
            {
                "text": " AddressNo\\s*\\d+\\s*(?:st|s"
            },
            {
                "text": " \\d{3}\\s?\\d{3}[ \\t]+"
            },
            {
                "text": " \\d\\s\\w+\n- \"23,45\"Generate"
            },
            {
                "text": " T\u00f8rststr\u00e6de(0+)\nThe \\d+ matches"
            },
            {
                "text": " T\u00f8rststr\u00e6de\\s+(?:\\d\\s+"
            },
            {
                "text": " T\u00f8rststr\u00e6de [0-9] \n- \""
            },
            {
                "text": " \"^[A-Za-z\\d ]+[ ]?"
            },
            {
                "text": " (\\w+) (\\s+\\d \\s+\\w+"
            },
            {
                "text": " [^a-zA-Z0-9\\n\\.]\n"
            }
        ]
    },
    {
        "expression": "^(([0-1][0-9]|2[0-3])[0-5][0-9]\\-([0-1][0-9]|2[0-3])[0-5][0-9]|[C|c]losed)$",
        "raw_prompt": "This allows for a single line input of open and close times (for a store/office).",
        "refined_prompt": "Matches open or closed times\nMatch examples:\n- \"0700-1530\"\n- \"1130-2310\"\n- \"Closed\"\nNon-match examples:\n- \"0700\"\n- \"Not open\"",
        "matches": [
            "0700-1530",
            "1130-2310",
            "Closed",
            "closed",
            "0000-2359",
            "2111-1536",
            "2255-1506",
            "0129-0237",
            "2303-0525",
            "|losed",
            "0422-2251",
            "1238-1305",
            "1636-0847"
        ],
        "non_matches": [
            "0700",
            "Not open",
            "0700-2400",
            "3159-0761",
            "ewd",
            "23refw",
            "#434",
            "$567",
            "326%",
            "edknlw",
            "wr34",
            "OPENOPEN"
        ],
        "id": 2631,
        "output": [
            {
                "text": "\nThe function should return the earliest time which is not open or closed.\n\n```python\ndef earliest_open_time(time_list):\n  # Generate a RegEx\n  regex = re.compile(r'(0700-1530)')\n  \n"
            },
            {
                "text": " \"^(06|07)\\d{2}(\\d|0[6-9])$\"\n\nExercise 3: Match description \nMatch the description with the correct RegEx:\nDescription:\n- \"Open the door.\"\nDescription:\n- \"Open the door by pressing the"
            },
            {
                "text": " [OPEN|CLOSED]\n\n5. Write a Python script that takes a date in the format \"19XX-XX-XX\" and formats it to the format \"MM-DD-YYYY\". Use a loop to test your code with different dates.\n\n```python\nimport re"
            },
            {
                "text": " \n^\\d{4}\\-(\\d{2})\\-(\\d{2})$\n\nExercise 3:\nMatch a string with the following formats:\n- \"my_name_is_john\"\n- \"my-name-is-john\"\n- \"my"
            },
            {
                "text": " I would use the following regex: (?=Open|Closed|Not open)(?=\\d{1,2}:\\d{2}\\s*-\\d{2})[A-Za-z]{3}\\s+[A-Za-z]{1"
            },
            {
                "text": " \n^[0-9]{4}-[0-9]{2}\\s[0-9]{2}[\\s-]?[0-9]{3}$\n\nExercise 2:\nGenerate a RegEx for the following rule.\nA string"
            },
            {
                "text": "\n\n- \"Open\"\\d{2}\\d{2}\\s*[-](\\d{2}[0-9]?)?$\n\nReal-world Use Case 2:\nScenario: A company is tracking employee attendance and wants to generate a report that shows the average attendance"
            },
            {
                "text": " \"1900-2300\"\n\nExercise 2:\nMatch these numbers with the correct time: \n- 12:00\n- 10:00\n- 10:15\n- 11:30\nMatch examples:\n- 10:00\n- 11:30\n- Closes\nNon"
            },
            {
                "text": "\n^[0-9]{4}-[0-9]{2}[0-9]$|^[0-9]{4}[1-9]{2}$|^[0-9]{4}[0-9]{2}[1"
            },
            {
                "text": " (open|closed)\n```python\nimport re\n\n# Open and closed time\nopen_time = \"0700-1530\"\nclosed_time = \"1130-2310\"\n\n# Open and closed time regex\nopen_time_regex = re.compile"
            }
        ]
    },
    {
        "expression": "\\d{1,2}(/|-)\\d{1,2}(/|-)\\d{2,4}",
        "raw_prompt": "This is regular expression for date.\neg.:02/06/2010\n2/6/10\n02-06-2010\n2-6-10",
        "refined_prompt": "Matches dates in formats\r\n02/06/2010\r\n2/6/10\r\n02-06-2010\r\n2-6-10\nMatch examples:\n- \"02/06/2010\"\n- \"66-6/32\"\n- \"74-7-88\"\nNon-match examples:\n- \"02 June 2010\"\n- \"January 26th\"",
        "matches": [
            "02/06/2010",
            "66-6/32",
            "74-7-88",
            "20/0-827",
            "5/86/8468",
            "62/0-62",
            "5-54/67",
            "2-2-9152",
            "4-86-5050",
            "23-1/810",
            "1-7-2708",
            "1/17/5658",
            "1/24-19"
        ],
        "non_matches": [
            "02 June 2010",
            "January 26th",
            "2nd of May",
            "2017",
            "232323",
            "12 12 12",
            "date",
            "12:12:12",
            "888888",
            "$45",
            "0",
            "aug 5th"
        ],
        "id": 2634,
        "output": [
            {
                "text": " [0-9]{2}[a-z]{1,2}([0][0-9]|[1][0-"
            },
            {
                "text": " \n^(?!(?:(?:\\d{1,2}\\/){2}\\d{1,2})|(?:\\d"
            },
            {
                "text": " \\d{1,2}/[a-z]+\\/[a-z]+[a-z]{3,4}[a"
            },
            {
                "text": " \n\\b[a-zA-Z]{3}\\d{2}\\s\\d{2}\\s\\d{4}"
            },
            {
                "text": " \\d+/\\d+/\\d+\\.\\d+\\(month\\)/\\d+-\\d+\\(day\\"
            },
            {
                "text": " \\d/\\d/\\d\\d \\d{1,2}, \\d{1,2}/\\d{2}/"
            },
            {
                "text": " \\b(January|February|March|April|May|June|July|August|September|October|November|December) \\d{1"
            },
            {
                "text": " ([0-9]{2}-[0-9]{2}-[0-9]{4})|([0-9]{"
            },
            {
                "text": " [a-zA-Z0-9 ]*[0-9]*[a-zA-Z]*\n- [0"
            },
            {
                "text": " /[a-zA-Z]{3,4}\\s[a-z]{2,3}/\\d{2}"
            }
        ]
    },
    {
        "expression": "^\\.{0,2}[\\/\\\\]",
        "raw_prompt": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.",
        "refined_prompt": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file ../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"",
        "matches": [
            "./some/file.html \\this\\is\\a.file ../blah/blah",
            "./",
            "/",
            "\\",
            ".\\"
        ],
        "non_matches": [
            "path\\in\\current.folder",
            "root",
            "folder",
            "!",
            "~",
            "-",
            "[",
            "]",
            "|",
            "%",
            "<",
            ">"
        ],
        "id": 2635,
        "output": [
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n^[^\\s]+$|^[^\\s]+$|^[^\\s]+$\n\nA:\n"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: /[^/]*/\n\n**Exercise 3:**\nIf a file is only one directory deep, you should use this pattern"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: ^(/.*/)\n\nA:\n\nI had the same requirement, so I wrote a small function to do the job for me"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: \"^\\/\\w+\\.html$\"\n\nExercise 2: Match the following IP addresses in a text file: \n-"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n\nimport re\n\n# Match any web path that's supposed to start in the root (e.g. with \"/\" in front"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer:\n[^/]+$\n\nI've tried this pattern, but it also matches the beginning of the string:\n/some/file"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: /[^/]+\\.html\n\n3. Write a function that takes a string and returns the number of HTML tags within that string."
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: /[^/]+\\.html$\n\nA:\n\nYou can use the following command:\nfind. -name \"*.html"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: (not tested)\nregex = \"(^[^/]*)/([^/]*)\\.([^/]*)/"
            },
            {
                "text": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it.)\nMatch examples:\n- \"./some/file.html \\this\\is\\a.file../blah/blah\"\n- \"./\"\n- \"/\"\nNon-match examples:\n- \"path\\in\\current.folder\"\n- \"root\"Generate a RegEx for this description. \nAnswer: [^/.]+\n\nA:\n\nYour pattern is:\n/(./[^/]\\.html)/\n\nThis says"
            }
        ]
    },
    {
        "expression": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])(0[0-9]|1[0-9]|2[0-3])([0-5][0-9])\\sUTC\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s[0-9]{2}$",
        "raw_prompt": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nFor Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on 24th June 2010\".",
        "refined_prompt": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \"UTC\"",
        "matches": [
            "312359 UTC Jun 99",
            "070518\u2003UTC\u2000Feb\f99",
            "151647 UTC\u2005Sep\u200044",
            "311524\u2008UTC\u2005Nov\f44",
            "281954\u2001UTC\u00a0Apr\u168078",
            "240528\u00a0UTC\u000bSep\u200227",
            "142128 UTC\u2007May\u200962",
            "132231\u2006UTC\u3000Jan\u200909",
            "140259\u2029UTC\u205fAug\u200242",
            "312353\u2009UTC\u3000Oct\u00a092",
            "301222\u202fUTC\u2003Sep\u300039",
            "091407\u000bUTC\u2004Apr\u202f29",
            "102246 UTC\u2002May\u200910"
        ],
        "non_matches": [
            "322567 UTC June 1999",
            "UTC",
            "324",
            "21U",
            "102246 U_T_C\u2002May\u200910",
            "102246 utc\u2002May\u200910",
            "utc",
            "military time",
            "$45",
            "jan23",
            "2nd of june",
            "234rfdsx"
        ],
        "id": 2648,
        "output": [
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            },
            {
                "text": "Matches military messages and communications (e.g. on naval charts, or maps showing troop movements). The format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nMatch examples:\n- \"312359 UTC Jun 99\"\n- \"070518\u2003UTC\u2000Feb\f99\"\n- \"151647 UTC\u2005Sep\u200044\"\nNon-match examples:\n- \"322567 UTC June 1999\"\n- \""
            }
        ]
    },
    {
        "expression": "^[\\w]+[-\\.\\w]*@[-\\w]+\\.[a-z]{2,6}(\\.[a-z]{2,6})?$",
        "raw_prompt": "@ Before you can have underlined, connection, point character, @there are three points after the characters are not allowed",
        "refined_prompt": "Matches email addresses with no special characters\nMatch examples:\n- \"abc@cde.com\"\n- \"abd@def.com.cn\"\n- \"a2b_cd3-2fg.ss@a2bd5_sd-mbv.com.cn\"\nNon-match examples:\n- \"abc@ccddme.my.com.cn\"\n- \"e123421@dwe@c.cd\"",
        "matches": [
            "abc@cde.com",
            "abd@def.com.cn",
            "a2b_cd3-2fg.ss@a2bd5_sd-mbv.com.cn",
            "hbtSgiBkinp2uKnIiXNR4P__EdVV3mx1PawwXV3JoviXirwn0dvE7VakgWmcGUe4GwO2cXNfXex31grlI@_lhn1iwUIGZSZP-lFzOB9Rlmv-pAxR6dLhVSJ8H9RhZb8f6dtGW1QuMG5qKOUNcyadCCVTgr.pvala",
            "15ncCQWt9MDGZO2M5YY.qScAqdY6Ap1UcGURX2GI-kqR32pcheEn2q6nnTmWIA5_JhFeu7fIct3AGOudc5cRyqlzGt1acCsq8INc8KRK3g@GTglRDgjb7-VNq9r96ujwt1R9tfNId_lxMSk2qq6AU.zp.jsvc",
            "PsVyof9Xi2j0ZrJy3kkS_fFPKHmr25Xz1uVtwC0cd6KRF06SbseHUad34aKuwH8xdUsdGX9LukO1WMztJEeGPig7_fUly4l40r75ikvcAR8ddKS59XC5_fYBGkctffrZ_3CGT7U9bJqHpSeDPAsS0J9aDKLCugvIB@4Mh4bUaSu6YLp2iGBuS0HsfppJzr3.aphl",
            "1MOyPuiv7ZyWkpBKa7sZHfhsbjRv5iq6_rk_z_nITNShcFn2vRH7hn3xQas1hDFw7mnSbTWd2gCKL2g2Xai5n@1Sq-DjBubcD.jv.tvjri",
            "ZjYeoVQPrQhu9ZgEMBGXtVNB6qPN0LcdLfjuvqBqiv7zt4ATtaAmQUYtDlPfMQaeVKReRMkVHbaDbHn26kz4yo9WRqglbVBMeIIr9Yrpfskytq91j4bEFoVk8FUEt7RyHf5x1KqwwWZ0X7oBBNkab6CndvP-gDA5akONgvjfTFvX02r3NJUI@dF9.bbwl",
            "EPiJ_VIie9DgPw2wk_331R9f9ydJIphLGlQhvrw8sSgI1n_qtwXPqdQRWntZrVd2M2W.16llVjpLxxxHetvFur.7b70TGC4FAHa6pEc.iFYoy.knXUL_EnNjqYFwjzW5nczLNeDki9f@Z_gs9NuWE3KDXSJ89oD6WEdyh.isfaah.we",
            "oQXJfkktpRF4P5Be8_B4o2jAI85y1yubSB.7F6zTFlmO9Ibk21ZvfTdiQUskxmLk.ckfjcTHteX7@0X3vudhjzqDlPQVYoo9KjbsmmEde-y_wAQ6ajt5_KiH-DCIc73tY.nl.abgb",
            "G_7LyhZWsMHQIaQqVFPKJYi1byc-9T9w6P0I6vzoy27Kerob@Z1-t_j_HFW_r8ye4fA0ix0MQyqQuxcRP6cs8p8zx-gCxf7EDAzgU266j0k9B5gDqp_t15JASrvbb4ZiL99QGV1tFzhT.nuckk.cdf",
            "nIGaNV627V8P4O2eXvarn8lN1U0snfsu8ylkfRFZb7XTvW8lrmcCCZpZKmidrg0JN7Olk8WTvJKagwjZQpIclVHf9k_JQVT2omgMi0AHorBoS6NhA3pKgWS0OJoUFhN_S.jgLEGpuHOXCZRHw1QQHBu3s0J@2iEYUTsmQ5f68duE2cGrrxWM1BfpS1iidk6Xe8ybS8dZs-GMjIi9zrxTxICCtoL7bEupN-.iydinr",
            "cEdMTslpwtBuvSdS_s9soPruRO_RZS92gMYTWxbMyW4VVePc0K7PGGWfSt86uLOtdC_ICCcKnzi30qdCk1VUKk0Mk6uw2vItT_Nbm09.wLXs.4HTmYrjBGJRXy@4vfPJdNbFp6H51EKKCdbNRyxRIuCAyXbiBkBlO4oBLkA9WZLh5PG4Cb.xq"
        ],
        "non_matches": [
            "abc@ccddme.my.com.cn",
            "e123421@dwe@c.cd",
            "34",
            "@gmail.com",
            "erfvd.sfwe@fec.com!",
            "erfvd.sfwe@fec.c",
            "wds@cd",
            "wds@3eds4fewcddewwde.w",
            "###@derc.com",
            "32wd.com",
            "email",
            "32wd.dwe.w"
        ],
        "id": 2649,
        "output": [
            {
                "text": " (In Python)\nimport re\n\ndef match_email(email):"
            },
            {
                "text": "\n\nEmail Regex\n^[a-zA-Z0-"
            },
            {
                "text": " \"^[a-zA-Z0-9._-]+@"
            },
            {
                "text": " (\\w+@\\w+\\.\\w{2,}\\."
            },
            {
                "text": "\n- [a-zA-Z0-9._%+-"
            },
            {
                "text": " (.*)@(.*)(.*)\\..*$\n\nExercise"
            },
            {
                "text": " (^[a-zA-Z0-9_.+-]+"
            },
            {
                "text": " ^[^@$]*@[^@$]*(?"
            },
            {
                "text": "\n\n\\b[A-Za-z0-9._%"
            },
            {
                "text": " \"(?<![\\w.])([a-z]+(?"
            }
        ]
    },
    {
        "expression": "^(\\d+\\.\\d+)$",
        "raw_prompt": "This will validate atleast minimum of one digit in either side of Decimal point",
        "refined_prompt": "This will match numbers with at least one digit on either side of the decimal point\nMatch examples:\n- \"1.22\"\n- \"12.23\"\n- \"123.123\"\nNon-match examples:\n- \"1..\"\n- \".\"",
        "matches": [
            "1.22",
            "12.23",
            "123.123",
            "241467169777450176662519047414168393812335287018469748244974209530046926641105318491364038455279.8075818",
            "294913032490963285169255673508923786952541.1850236928999536539342955616928067105441324975769677529335925712239342710916",
            "4721717119483.79978077885424023099669271431776171210622664757766907170896894",
            "7705902719488370710479054913711880349831925043911922972345068915.2387777897",
            "7426.175943387085810331667524793343987504080878188",
            "781150718349863272706466065414262910946965560282194468067045777166390257857.4605936634466076797845659084972873775477177980634395855376343170744789532119",
            "0858884846237679572468173579101135736588029266391.78987",
            "29685942573456.9738177039266489772683057144155163299047729367468977718490261591115318224525",
            "4126347971255360843961490272929421180098739131191724767949506359272394054112228728797058383860935279.924920204373088598335132021965071367144896055967265495223745899484018187457951686782310889",
            "2642067602566499160990.9559008037045159149249985827314186508928617440680591982729928928149016642452808"
        ],
        "non_matches": [
            "1..",
            ".",
            "123.",
            ".213",
            ".wef",
            "0.0e",
            "#3",
            "$4",
            "54%",
            "12/12",
            "<32>",
            "23242"
        ],
        "id": 2654,
        "output": [
            {
                "text": " ([.][0-9]+) \n\nExercise 2: Write a RegEx to match email addresses that end with a period. \nAnswer: [\\w\\.-]+@[\\w\\.-]+\\.\\w+ \n\nExercise 3: Given"
            },
            {
                "text": " \\d\n- \".\"Generate a RegEx for this description. \nAnswer: \\d*\\.\\d*\n\nExercise 2: Write a Python function that takes a list of strings and returns a list of only those which have a regex pattern containing the word \""
            },
            {
                "text": "\n\\.1[0-9]+\\.[0-9]+|\\.[0-9]+\\.1[0-9]+|[0-9]+(?:\\.0+)?\n\nExercise 3: Match examples of currency values, such as \"USD$"
            },
            {
                "text": " (?<=.{3,7}).\\d\nThis will match numbers with at least three digits before the decimal point and no more than seven digits after the decimal point.\n\nExercise 4:\nCreate a RegEx for validating email addresses.\nAnswer:"
            },
            {
                "text": " \"^[a-zA-Z0-9]*$\"\n\nExercise 4: \nMatch examples:\n- \"1234.5678\" \n- \"1234.5678.90\" \n- \"1234.5678."
            },
            {
                "text": " \"^\\d\\.?\\d$\"\n\n2) Write a regular expression to match a string that contains an email address. The email address should be in the format \"[email1]@[domain1].domain2.com\" with a minimum length of 6 characters and"
            },
            {
                "text": " This will match numbers with at least one digit on either side of the decimal point\n```python\nimport re\n\n# match numbers with at least one digit on either side of the decimal point\nnumbers = r'\\d+\\.\\d+'\n\n# generate"
            },
            {
                "text": " This will match numbers with at least one digit before the decimal point and at least one digit after the decimal point.\n\nExercise 3: Use the concept of conditional statements and loops to write a RegEx that will match phone numbers in the format \"(xxx) xxx-xxxx\"."
            },
            {
                "text": " [0-9]\\.\n\nExercise 4:\nMatch the following words to their correct spelling using a RegEx.\n1. Cat\n2. Dog\n3. House\n4. Table\n5. Car\n\nAnswer: \n1. C-a-"
            },
            {
                "text": " \n\\d\\.\\d\n\nExercise 2: \nCreate a RegEx that matches words that are at least 3 characters long and start and end with vowels. \nAnswer: \n^[aeiouAEIOU]\\w{3,}"
            }
        ]
    },
    {
        "expression": "^\\s*[+-]?\\s*(?:\\d{1,3}(?:(,?)\\d{3})?(?:\\1\\d{3})*(\\.\\d*)?|\\.\\d+)\\s*$",
        "raw_prompt": "Matches numbers. May include decimals, thousands separators, and sign.",
        "refined_prompt": "Matches numbers. May include decimals, thousands separators, and sign.\nMatch examples:\n- \"5,000\"\n- \"- 10\"\n- \".1\"\nNon-match examples:\n- \"7.000.000\"\n- \"5,0000\"",
        "matches": [
            "5,000",
            "- 10",
            ".1",
            "1",
            "1,000",
            "234",
            "999,999",
            "1212",
            "23454323456",
            "3.1415",
            "3242",
            "0987654321",
            "3"
        ],
        "non_matches": [
            "7.000.000",
            "5,0000",
            "1.000,000",
            "#3",
            "$45",
            "54%",
            "12/12",
            "one",
            "sixteen",
            "34-34",
            "number",
            "3+3"
        ],
        "id": 2655,
        "output": [
            {
                "text": "\n^[-+]?\\d*[,.]?\\d+$\n\nExercise 2:\nMatch numbers with the following formats. Can you match numbers with commas as decimal separators? Are there any cases where you cannot?\n- \"5"
            },
            {
                "text": "\n([\\+\\-\\.]?)(0|([1-9][0-9]*))[KMG]\n\nExercise 5: \nFind all the email addresses in the text below.\n\"Hi, I'm a teacher, and my"
            },
            {
                "text": " \"^[-+]?[0-9]{1,3}(,[0-9]{3})*$|^[-+]?[0-9]{1,3}$\"\n- \"5(,000)000\""
            },
            {
                "text": " The RegEx should match only numbers that are non-negative, starting with a positive sign (+), leading with a number, followed by a period, and ending with a number that is either zero or non-zero. The RegEx should not match numbers that are negative or"
            },
            {
                "text": " \\b(?=(?:[0-9]{1,3}\\.){1,3}[0-9]{4}|[0-9]{3,}\\.)|(?<!\\.)[0-9]{1"
            },
            {
                "text": " ^[-0-9]*[,.]?[0-9]*[,.]?[0-9]*$\n\n**Exercise 2:**\nWrite a Python script to find all the numbers in the following string:\n\"The"
            },
            {
                "text": " [0-9]{3}[0-9]{3}[0-9][0-9][0-9][0-9]$\n\nExercise 3: \nUsing the regular expression you just created, match the following strings:"
            },
            {
                "text": "\n\nimport re\n\ndef calculate(string_1, string_2):\n    regex = r'([\\d,]+)'\n    strings_1 = string_1.split(',')\n    strings_2 = string_2."
            },
            {
                "text": " .*\\d+,\\d+\\.\\d+ or.*\\.\\d+ or \\d+\\.\\d+$\n\n3. Create a RegEx that matches emails.\nAnswer:  [^@]+@[^@]+\\.["
            },
            {
                "text": " [^\\d.]+,?\\d+[^\\d.]\nExercise 4:\nMatch a currency symbol, e.g. \"USD\" or \"AUD\", that can stand alone and still be valid currency.\nAnswer: [^\\d.,"
            }
        ]
    },
    {
        "expression": "^([9]{1})([234789]{1})([0-9]{8})$",
        "raw_prompt": "Its 10 digits Indian Mobile Number validation.",
        "refined_prompt": "Matches 10-digit Indian Mobile Numbers that need to start with 9\nMatch examples:\n- \"9829373514\"\n- \"9226491171\"\n- \"9289014901\"\nNon-match examples:\n- \"919829373514\"\n- \"09829373514\"",
        "matches": [
            "9829373514",
            "9226491171",
            "9289014901",
            "9826193611",
            "9785066031",
            "9785843651",
            "9884094883",
            "9941642498",
            "9869566932",
            "9214282047",
            "9439512989",
            "9424282736",
            "9707017365"
        ],
        "non_matches": [
            "919829373514",
            "09829373514",
            "phone number",
            "1234567891",
            "5234567891",
            "1339014059",
            "7422400436",
            "3983536421",
            "5987940031",
            "7831758677",
            "0869652040",
            "0216798576"
        ],
        "id": 2662,
        "output": [
            {
                "text": " [^09\\d]|(?<=\\d)\\d(?=\\d{5})\n\n2. Password Matches a String of at least 8 characters (with at least 1 upperc"
            },
            {
                "text": " *^9{9}[0-9]{6}[0-9\\-\\(]{2}[0-9]{1,3}[0-9]{0,3"
            },
            {
                "text": " /^9.9.9.9[0-9]$/\n\n2. Write a regular expression to verify that a date is in the YYYY-MM-DD format.\nAnswer:"
            },
            {
                "text": " (?<!\\d)\\d{3}(?!\\d)\n\n**Lecture Note: 14.4.4 The Basic Patterns of a Phone Number**\n\nA phone number consists"
            },
            {
                "text": " [^0-9] \n\nExercise 4: \nCreate a RegEx for IP address validation.\n\nAnswer: \n[0-9]{1,3}[0-9"
            },
            {
                "text": " Allow 0 or more digits before the first 9. Match exactly 2 digits before the first 9. Allow 0 or more digits after the first 9.\n\nExercise 2:\nReplace all occurrences of \"X\""
            },
            {
                "text": " \n(?<![1-9])\\\\d{9}(?![1-9])\n\nExercise 2: Write a RegEx for the following:\n- \"First Name: John"
            },
            {
                "text": " 9[0-9]{9}\n\n#### Exercise 4\nWrite a Python script to generate a list of 20 phone numbers, each start with 9.\n\n#### Solution\n```python\nimport re"
            },
            {
                "text": " 9([0-9]{1,3})([0-9]{1,3})\\6(?=\\d)\n\nExercise 2:\nMatch these descriptions to the correct"
            },
            {
                "text": " [0-9]{4}[0-9]{4}[1-9]\n\nExercise 3:\nCreate a Python code example that identifies the first and last character of a string."
            }
        ]
    },
    {
        "expression": "^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|[Hh][Ii]|[Ii][ADLNadln]|[Kk][SYsy]|[Ll][Aa]|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|[Rr][Ii]|[Ss][CDcd]|[Tt][NXnx]|[Uu][Tt]|[Vv][AITait]|[Ww][AIVYaivy])$",
        "raw_prompt": "This is just a simple US states and territories in 2 character regex. Requires valid 2 letter abbreviations. It accepts the Lower and Upper Case Entries.",
        "refined_prompt": "Matches US states and territories in 2 letter abbreviations. It accepts the Lower and Upper Case Entries.\nMatch examples:\n- \"MN\"\n- \"tx\"\n- \"Tx\"\nNon-match examples:\n- \"M\"\n- \"23\"",
        "matches": [
            "MN",
            "tx",
            "Tx",
            "az",
            "AZ",
            "co",
            "CO",
            "IN",
            "in",
            "il",
            "IL",
            "mi",
            "MI"
        ],
        "non_matches": [
            "M",
            "23",
            "Alaska",
            "zz",
            "arizona",
            "united states",
            "ariz",
            "Kentucky",
            "Colo",
            "Cali",
            "Minne",
            "987ytgbj"
        ],
        "id": 2663,
        "output": [
            {
                "text": " \"^[a-z]{2}$\" - Matches two lowercase letters.\n\n\n\nDaily life-Transportation-Gas stations:\n\nHave you ever been to a gas station? Gas stations are places where we go to fill up our cars with gasoline"
            },
            {
                "text": " \"^[A-Z][a-z]{0,1}$\"\n\n4. Create a RegEx to identify valid email addresses.\nExercise: Create a RegEx to identify valid email addresses.\nAnswer: \"^[A-Za-z"
            },
            {
                "text": " r'^[a-z]{2,3}$'\n\n3. Create a RegEx expression that matches an IP address.\nAnswer: r'^(?:[0-9]{1,3}\\.){3}[0-9]{"
            },
            {
                "text": " Generate a RegEx that matches 2 letter abbreviations in the form of \"M\" or \"Tx\".\n\n3. Write a Python function that takes a string and returns a dictionary with the letter counts.\nExample:\n\"This is just a test.\" -> {\"T\":"
            },
            {
                "text": " \"mn\"\n5.  Write a RegEx to find all words in a string that don't start with the letter \"p\". \nCreate a string. \nGenerate a RegEx for this description.\nAnswer: [^p]\n\n# Chapter 11:"
            },
            {
                "text": "\n\n```python\nimport re\n\n# Generate the regular expression for match any two letter abbreviation like \"Mn\", \"tx\", \"Tx\"\nregex = re.compile(\"^[A-Z]\\w\\w$\")\n\n#"
            },
            {
                "text": " m|x|t|X|M\n\n3. Generate a RegEx to filter out all the non-letter characters, whitespace, or special characters in a string.\nMatch examples:\n- \"AB $3 CD E $4\"\n- \"###\""
            },
            {
                "text": " \n^(M|T)\\d{2}$\n\nExercise 2:\nCreate a Regex that matches at least one letter between 'f', 'n', and 'l' (in any order).\nAnswer:\n^[f][n][l]"
            },
            {
                "text": " ([a-zA-Z]{2}[a-zA-Z]). For example, it would be [[a-zA-Z]].\n\n3. Write a RegEx for all words that start with 'o' and contain only vowels.\n"
            },
            {
                "text": " ([a-z])([A-Z])([0-9])([^a-zA-Z0-9]+)\n\nExercise 4: \nWhat is the difference between a match and a non-match? \nAnswer: A match"
            }
        ]
    },
    {
        "expression": "([0-9][0-9])((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\\-([0-9][0-9])\\-([0-9][0-9][0-9][0-9])",
        "raw_prompt": "Simple Malaysian New IC Number Validation.\nLength: 8 characters.\nFormat: YYMMDD-99-9999",
        "refined_prompt": "Matches Malaysian New IC Number Validation.\r\nLength: 8 characters.\r\nFormat: YYMMDD-99-9999\nMatch examples:\n- \"900120-01-5567\"\n- \"461131-51-1689\"\n- \"850315-65-0584\"\nNon-match examples:\n- \"909020-01-5567\"\n- \"900120-0A-5567\"",
        "matches": [
            "900120-01-5567",
            "461131-51-1689",
            "850315-65-0584",
            "450920-38-7560",
            "951219-81-4774",
            "300827-78-6461",
            "350203-55-7284",
            "091231-14-1646",
            "881019-53-6543",
            "701130-31-2107",
            "410616-51-9137",
            "280803-82-3416",
            "651212-14-5340"
        ],
        "non_matches": [
            "909020-01-5567",
            "900120-0A-5567",
            "900120-01-55",
            "ID",
            "23456",
            "234-24",
            "34%",
            "$45",
            "#45",
            "12/12",
            "12-12",
            "234565-23456785432"
        ],
        "id": 2664,
        "output": [
            {
                "text": " \\d{8}-\\d{1,2}-\\d{4}-"
            },
            {
                "text": " ^[0-9]{8}-[0-9]{2}-[0-"
            },
            {
                "text": " [^-]?[0-9]{8}-[0-9]{4"
            },
            {
                "text": " (?<=\\D)(\\d{4})-(\\d{2})-(\\"
            },
            {
                "text": " (Y|M|D|D|C|C|Y|Y|Y|A"
            },
            {
                "text": " ^[0-9]{4}-[0-9]{2}-[0-"
            },
            {
                "text": " (?<yEAR>\\d{4})\\-(?<mMonth>\\d"
            },
            {
                "text": " (.{8})-([-0-9]{2})-([0-9"
            },
            {
                "text": " (https://www.guru99.com/blog/how-to-validate-"
            },
            {
                "text": " Y[0-9]{1,2}[0-9]{2}["
            }
        ]
    },
    {
        "expression": "^([EV])?\\d{3,3}(\\.\\d{1,2})?$",
        "raw_prompt": "validates an ICD9 medical code which MAY start with an E or V, 3 digits, and MAY be followed by a period and a 1-2 digit sub-code",
        "refined_prompt": "validates an ICD9 medical code which MAY start with an E or V, 3 digits, and MAY be followed by a period and a 1-2 digit sub-code\nMatch examples:\n- \"123.45\"\n- \"E123.45\"\n- \"V123.45\"\nNon-match examples:\n- \"e123\"\n- \"X123\"",
        "matches": [
            "123.45",
            "E123.45",
            "V123.45",
            "456.7",
            "E456.7",
            "V456.7",
            "987",
            "E987",
            "V987",
            "E613.9",
            "V308",
            "761.1",
            "E312.59"
        ],
        "non_matches": [
            "e123",
            "X123",
            "e123.4",
            "e123.45",
            "E12345",
            "5234567891",
            "E",
            "e",
            "E32456",
            "E32456.wef",
            "code",
            "e343343423"
        ],
        "id": 2665,
        "output": [
            {
                "text": " \".*[A-Za-z0-9]([A-Za-z0-9].[A-Za-z0-9"
            },
            {
                "text": "  ^[EV]\\d{1,2}\\.\\d{1,2}$\n\n4) Given the following text, use a regular"
            },
            {
                "text": " [^E\\d])\\1\\1\n\n3. Write a rule, using a list of words, that matches a description of a car, such as"
            },
            {
                "text": " (e123|v123)\\.\\d\\d\nThis matches any combination of E, V, A or S followed by a period and a 1-2"
            },
            {
                "text": " (^[0-9][0-9]\\.[0-9][0-9]$|^[0-9][0-9][0"
            },
            {
                "text": " (\\w\\w.\\d{2}\\.)+\n\n3. Write a Python code to validate user input for password length of at least 8 characters and"
            },
            {
                "text": " (e|v)\\\\d{1,2}\\\\.\\\\d{3}\nThe idea here is to match E or V followed by 1 or 2"
            },
            {
                "text": " E1123\n\n**Solution:**\n\n```python\n# RegEx that matches an E or V medical code which MAY start with an E or V"
            },
            {
                "text": " rE[0-9]\\d{2}\\.\\d{1,2}\n\nExercise 4: Write a Python function that takes a string"
            },
            {
                "text": " E123\\.0\\d{1,2}\n\nExercise 2: Validating a Phone Number\nExercise: Write a regex that validates a phone"
            }
        ]
    },
    {
        "expression": "^\\d{4,4}[A-Z0-9]$",
        "raw_prompt": "a CPT code is a 4 digits + a captial letter or number (forming 5 character code). The CPT code describes a medical procedure",
        "refined_prompt": "Matches a CPT code with 4 digits + a capital letter or number (forming 5 character code). The CPT code describes a medical procedure\nMatch examples:\n- \"0001F\"\n- \"21082\"\n- \"1332U\"\nNon-match examples:\n- \"F0123\"\n- \"0001f\"",
        "matches": [
            "0001F",
            "21082",
            "1332U",
            "4275T",
            "07229",
            "1245C",
            "1721S",
            "81030",
            "56692",
            "2509Z",
            "3852J",
            "5582E",
            "7880M"
        ],
        "non_matches": [
            "F0123",
            "0001f",
            "100F",
            "23",
            "code",
            "medical procedure",
            "surgery 2",
            "1234",
            "432",
            "eeewdwe",
            "efwef3f3f43ff",
            "43fr321rfq3gfq"
        ],
        "id": 2667,
        "output": [
            {
                "text": "\n(?:\n\\d{4}\n|\n[A-Z]\\d?\n)\n\nExercise 2: \nWrite a RegEx to match a string that starts with \"S\""
            },
            {
                "text": " /\\b(([A-Za-z0-9]\\d{4})\\d+\\b/\n\n3. Given the following string:\n\"My patient had a heart attack and"
            },
            {
                "text": " (\\d{4})([A-Za-z])\n\n3. Write a function which takes a list of strings representing medical procedures as input, and returns a dictionary containing count of each procedure type"
            },
            {
                "text": " [A-Z]{2}[0-9]{4}|[0-9]{4}[A-Z]{2}\n5. Match a CPT code with a capital"
            },
            {
                "text": " r'[A-Z][0-9]{3}[A-Z0-9]|[0-9]{4}|[0-9]{10}|[0-"
            },
            {
                "text": " ^[A-Z0-9]{5}$\n\n4. Find all the numbers in the following string:\n\"The patient's blood pressure is 122/78 mmHg. The patient's"
            },
            {
                "text": " CPT code [0-9]{4}[A-Z]{1}([0-9]|[A-Z]{1})\n- \"1012E\"Generate a Reg"
            },
            {
                "text": " \"^[0-9]{4}([A-Za-z0-9]|[0-9])$\"\n\n3. Provide an example of a real-world situation where a"
            },
            {
                "text": " ^[0-9A-Za-z]{5}$\n\nExercise 4:\nMatch a CPT code with 6 digits and an asterisk (*). The asterisk indicates that the C"
            },
            {
                "text": " r'^([0-9]{4})([A-Z\\d]{1})$'\n\n5. Write a Python code that takes a string as input and returns a list of all"
            }
        ]
    },
    {
        "expression": "^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,8}[a-zA-Z0-9]$",
        "raw_prompt": "This expression will validate user name with the following rules\n1- It must start and end with a digit or character\n2- It must be exactly 4 to 10 character long\n3- Allowed Special Characters are _.-",
        "refined_prompt": "This expression will validate user name with the following rules\r\n1- It must start and end with a digit or character\r\n2- It must be exactly 4 to 10 character long\r\n3- Allowed Special Characters are _.-\nMatch examples:\n- \"1.ma\"\n- \"user\"\n- \"ma_mo-on.r\"\nNon-match examples:\n- \"_user\"\n- \"asfd@12\"",
        "matches": [
            "1.ma",
            "user",
            "ma_mo-on.r",
            "jzoHroWo",
            "ovxYa.L0",
            "6Nf03p6",
            "jYLdj9_GA",
            "mQLfsKLpw",
            "QgA6Hpq",
            "qfWHtRyHU8",
            "u6R_BceP.5",
            "FDyOtx8OjZ",
            "6TajJ"
        ],
        "non_matches": [
            "_user",
            "asfd@12",
            "user.",
            "#user",
            "///wefw",
            "u$er",
            "user!",
            "@user",
            "<user>",
            "user?",
            "{user]",
            "(user&"
        ],
        "id": 2671,
        "output": [
            {
                "text": " \n[A-Za-z0-9_.-]{4,10}\n"
            },
            {
                "text": " \r\n^[a-zA-Z][a-zA-Z0-9"
            },
            {
                "text": " user\\..*\r\n\r\n3. Matching Email Addresses \r\nMatch an email"
            },
            {
                "text": " \n\\d[-_.-]?\\d{3,4}\\b\"\r\n"
            },
            {
                "text": " _[0-9a-zA-Z\\-_.-]{4,10}_"
            },
            {
                "text": " user[A-z0-9._-]{1,9}\n```python\n"
            },
            {
                "text": " \r\n^[a-zA-Z0-9\\-_]+[a-z"
            },
            {
                "text": " user_\\d\\d\\d\\d_[^_.-]\\w{3,"
            },
            {
                "text": " \\p{Alnum}+,\\p{Alnum}++\\p{Alnum}"
            },
            {
                "text": " \n\n```python\nimport re\n\nallowed_chars = \"abcdefghij"
            }
        ]
    },
    {
        "expression": "^([0-1]?[0-9]|[2][0-3]):([0-5][0-9]):([0-5][0-9])$",
        "raw_prompt": "match time for : H:nn:ss or HH:nn:ss",
        "refined_prompt": "match time with formats H:nn:ss or HH:nn:ss\nMatch examples:\n- \"01:00:59\"\n- \"1:59:00\"\n- \"23:59:59\"\nNon-match examples:\n- \"24:00:00\"\n- \"noon\"",
        "matches": [
            "01:00:59",
            "1:59:00",
            "23:59:59",
            "5:47:31",
            "12:00:37",
            "3:50:08",
            "20:27:13",
            "08:14:16",
            "22:59:45",
            "1:37:17",
            "20:32:25",
            "16:24:34",
            "22:53:53"
        ],
        "non_matches": [
            "24:00:00",
            "noon",
            "time",
            "12/12/12",
            "13-13-2",
            "02:41:51 AM",
            "02:41:51 PM",
            "20 32 25",
            "203225",
            "30 seconds",
            "sec",
            "min"
        ],
        "id": 2674,
        "output": [
            {
                "text": " ^\\d{1,2}:\\d{1,2}:\\d{2,3}$|^\\d{1,2}:\\d{1,2}:\\d{0,2}\\s*\n"
            },
            {
                "text": " \n\n```python\nimport re\n\nexample_list=[\"01:00:59\",\"1:59:00\",\"23:59:59\"]\nnon_example_list=[\"24:00:00\",\"noon"
            },
            {
                "text": "  (\\d{1,2}):(\\d{1,2}):(\\d{2})\\s+(\\d{1,2}):(\\d{1,2}):(\\d{2})\n\nI"
            },
            {
                "text": "\n[0-9][0-9]:[0-9][0-9]:[0-9]\\\n#[01]??[0-9]\n\n2. Create a RegEx that matches a phone number"
            },
            {
                "text": " ([a-zA-Z]{1}(:[a-zA-Z]{1}){2})|(^[0-9]{1}([0-9]{1}){2}:["
            },
            {
                "text": " hh:mm:ss|H:mm:ss|HH:mm:ss\n\nScript:\n\nStudent: Hi, can you help me with the homework questions in section 20.2.1? They involve creating,"
            },
            {
                "text": " (\\d{1,2}):(\\d{1,2}):(\\d{1,2})\n\nExercise 9: Use the following code snippet to generate a RegEx for the description \"This is a very very"
            },
            {
                "text": " ^([0-9]{1,2})(:[0-9]{1,2})((?:[ap]\\.m))?$\n\nExercise 3: Match the following time formats with the correct REGEX"
            },
            {
                "text": " [H:][0-9][0-9][:][0-9][0-9]:[0-9][0-9]:[0-9]\n\nExercise 2: \nFind the RegEx for"
            },
            {
                "text": " [A-Za-z0-9/: ]+[A-Za-z0-9/]+(\\s[A-Za-z0-9/]+(\\s[A-Za"
            }
        ]
    },
    {
        "expression": "^([1-9]+\\d{0,2},(\\d{3},)*\\d{3}(\\.\\d{1,2})?|[1-9]+\\d*(\\.\\d{1,2})?)$",
        "raw_prompt": "Accepts non-negative numbers with max two decimals. Commas can be added after every thousand.",
        "refined_prompt": "Accepts non-negative numbers with max two decimals. Commas can be added after every thousand.\nMatch examples:\n- \"1200\"\n- \"1,200\"\n- \"1,200.0\"\nNon-match examples:\n- \"-43\"\n- \"0\"",
        "matches": [
            "1200",
            "1,200",
            "1,200.0",
            "12,324,532.23",
            "234122197712817448008574158167894889305230439779354370220937698578050893782896158227.78",
            "66394965947682179643452649243327481438317293881647562351429578967172264547986125157892974981634191636120788888047567662264848325693081625589017159",
            "863733627925899152866894911742679557969889767947742611498454471164255964323279645,158,054,484,881,965,222,364,885,707,932,542,241,383,180,567,542,514,867,036,972",
            "551369621886461782972191114464492755318941697931276344143837277496938913750923519255734953278866806433835",
            "91495832182691632527926,239,388,745,348,478,638,589,022,811,804,500,396,125,666,489,385,348,158,122,991,142,491,622,121,197,831,510,750,224,136,027,858,893,276,262,723,662,056,121,638,705,489,406,955,739,455,611,893,175,816,258,765,091,086,512,851,615,787,777,319,437,711,404,832,621,638,630",
            "9119565471413683647346558195673817473,448,573,495,805,989,746,055,223,129,395,757,273,464,744,931,500,207,298,788,333,550,975,799,871,141,044,106,312,274,764,107,907,931,257,475,081,322,261,496,732,009,898,456,535,014,862,322,492,265,072,816,328,508,305,310,112,689,157,701,089,084,567,448,541,009,967,544,490,653,321,322,705,937",
            "687357588294667585578626",
            "813183887279718535883742131575761825911494131375522235917296479139635776545860081144583730851407141300545489780557136407954.73",
            "7177128286236738886905329772080881695045031017932409702386065046187478712244527378681"
        ],
        "non_matches": [
            "-43",
            "0",
            "01,423,534.23",
            "24.4223",
            "32,42,123",
            "134253y6hterge",
            "34ty6",
            "df435678",
            "uy67543e",
            "er456",
            "543qfv",
            "653g45"
        ],
        "id": 2684,
        "output": [
            {
                "text": " (\\d{1,3},\\d{3}\\.\\d{2})\n\n2.\nReplace the following values in the text with their value: \n- \"I have $1,000\"\n- \"I have"
            },
            {
                "text": " \\d{1,3}\\.\\d{3}[,\\s.]\\d{3}\n- \"[a-zA-Z0-9_]\" Generate a RegEx for this description. \nAnswer: [a"
            },
            {
                "text": " ( -)(\\d{0,2}(,\\d{3})*|\\d{3})\n\n5. Write a Regular Expression that matches all dates in the format of MM/DD/YYYY.\nMatch examples:\n"
            },
            {
                "text": " -(?<!\\d)(?<!-)0+(?!-)\n- (?<!\\d)(?<!-)0+(?!-)3(?!-)\n- (?<!\\d)(?<!-)0+("
            },
            {
                "text": " [1-9][0-9]{0,2}(.[0-9]{0,2})\n\n3) Write a Python program that takes a string as a user input and replaces words that are two or more characters long with"
            },
            {
                "text": " \n\n^\\d{1,3}(,\\d{3})+$\n\n3. Create a RegEx to check if a string ends with \".txt\" or \".pdf\".\nAnswer:\n\ntxt|pdf$\n"
            },
            {
                "text": " 0*(?P<digit><[0-9]{1})\n- \"0000\"\n- \"12,000\"\n- \"12,000.01\"\n- \"12,000.02\"\n- \"12,000"
            },
            {
                "text": " (?:\\d+[,.]\\d{3})*|(?:\\d{3})\n\n2. The regex above is for generating a regex for this description. Write a Python program that receives a number and a list of rules to"
            },
            {
                "text": " [0-9]{1,2}(,?([0-9]{3,})?)?\nExample 3:\nWrite a regular expression that captures any email address that ends with a domain name and has at least one username.\n"
            },
            {
                "text": " \"\\\\d*\\\\,\\\\d*\"\n- \"1.0\"\n\n4. Write a regular expression that matches all words (case-insensitive) that are 3 or more characters long and start with a vowel.\n\nI'm"
            }
        ]
    },
    {
        "expression": "^[0-9]*[1-9]+[0-9]*$",
        "raw_prompt": "Allows only positive integers that are greater than 0. Also allows for infinite zeros leading the integer\nBased on William Powell's Pattern Title, but modified to allow for leading zeros.",
        "refined_prompt": "Allows only positive integers that are greater than 0. Also allows for infinite zeros leading to the integer\nMatch examples:\n- \"1\"\n- \"12\"\n- \"124\"\nNon-match examples:\n- \"-1\"\n- \"a\"",
        "matches": [
            "1",
            "12",
            "124",
            "01",
            "0012",
            "000124",
            "0456056898853258290052535909141449947763346124071099519164571289854655944451617155912138847698653624336996358636882626419149",
            "46958256105370176463315311504672534575648608130075527875460958175796347477937281561868894855362966967338559545531263555589847945645798388824272893481681574473762828549614845512745694623960580675",
            "838778102452570968618002967290535759234381294008100568708521648333919747513582156742395556355534167789561203424421508907573471001467336912131",
            "59243178360220518974977524032268252869783256427711504297180355797844365133253936498736137912484473134428433629192871622177748415296413197442647517467056322034045330465207797774188209863095273782857468049583162333877772343778564066486",
            "9035607486667778433287255438431614263",
            "2173247762150905619270434522184729642314788872748638294323640862487235604846967518462380060904",
            "107079596931536351545909256730859831054928608180812324257621143683697351393981683292321786696957732259158418344468426292755448306036256986543589987149164084480522274380340274402723299502431465896209140258535790"
        ],
        "non_matches": [
            "-1",
            "a",
            "1.0",
            "0000",
            "number",
            "345674rwegty",
            "+987654",
            "-987654",
            "0.087654",
            "9876545678hgfds",
            "7675r6fyt",
            "324565tr"
        ],
        "id": 2699,
        "output": [
            {
                "text": "\n\n^[1-9][0-9]*$|a\n\nA:\n\nAs it is, your regex doesn't match the -1 (since it is not a digit)\nTo make it work, you could use this regex:\n^(?:\\d"
            },
            {
                "text": " -1:  \\-*[1-9]|[*]0+   0+:   [0-9]*\n\nThe last one will be a bit tricky. We can use * in front of a character to allow 0's to come after the character.\n-"
            },
            {
                "text": " \"^[0-9]+$\"\n\nExercise 3: \nCreate a function that validates whether a given email address is valid or not. Use a regular expression to check that the email address has a valid format, with a username and a domain separated by a period. The"
            },
            {
                "text": " ^[0-9]*1$|^[0-9]*[1-9][0-9]*$|^[0-9]*[1-9]0*[0-9]$\n- \"0.1\"\n- \"00"
            },
            {
                "text": " *a\nExplanation: This RegEx will match any string that starts with 0 or more a's, followed by one or more zeros that are greater than 0.\n\nExercise 3: Password Regex\nExercise: Generate a regular expression for the following password requirements:"
            },
            {
                "text": " [0-9]*[1-9]{0,1}[0-9]*\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstring get_reg_exp(const string &input_string)\n{\n"
            },
            {
                "text": "\n^[+-]?(0|[1-9][0-9]*)$\n\nExercise 2.\nCreate a RegEx pattern that matches the following strings:\n- \"5 - 3 / 2\"\n- \"5 / 3\"\n- \"13 /"
            },
            {
                "text": " ([0-9]+)\n\nExercise 4:\nGiven two words, create a RegEx for matching words that contain all the letters from both words. Also allow for infinite zeros leading to the word. Also allow for any whitespace characters between letters.\nMatch examples:\n-"
            },
            {
                "text": " \n(\\d+|\\d*?)[^0-9]\n\n# Exercise 2\nExercise: Use RegEx to find all the email addresses in a given string.\nAnswer: \nEmail Regex:\n[a-zA-Z0-9._"
            },
            {
                "text": " r\"(^-?\\d+)|(^\\d+((\\.\\d+)?))$\"\n- \"12.4\"\n- \"12.4a\"\n- \"a12.4\"\n- \"a1234\"\n- \"1234a\""
            }
        ]
    },
    {
        "expression": "[0](\\d{9})|([0](\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4}))|[0](\\d{2})( |-|)(\\d{7})|(\\+|00|09)(\\d{2}|\\d{3})( |-|)(\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4})",
        "raw_prompt": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.",
        "refined_prompt": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912.\nMatch examples:\n- \"073-386-2612\"\n- \"0443862612\"\n- \"076 858 7777\"\nNon-match examples:\n- \"qdsq11123\"\n- \"sdfgty654\"",
        "matches": [
            "073-386-2612",
            "0443862612",
            "076 858 7777",
            "+27 76 858 7777",
            "0027 765877777",
            "0956 33 8881234",
            "0921112720",
            "0405595829",
            "+546-08 639-5212",
            "040-6461703",
            "021-7377498",
            "0464291438",
            "0847314712"
        ],
        "non_matches": [
            "qdsq11123",
            "sdfgty654",
            "IUYTR5678",
            "KLJIHUY",
            "erfhrt67dc",
            "3ferh8374",
            "rfenuyd654e5",
            "43iuhfe78",
            "3iufh&Y*&*",
            "HGYTF76",
            "34redc76",
            "3456y7hytrf"
        ],
        "id": 2703,
        "output": [
            {
                "text": " (.+)\\\\s\\\\d{3}.\\\\d{3}-\\\\d{"
            },
            {
                "text": " ^\\d(?:\\.\\d{3})*$\n\n\n\nQuestion"
            },
            {
                "text": " (1|2)\\\\d{3}[ -]?\\\\d{3}"
            },
            {
                "text": " Non-match examples:\n- \"qdsq11123\"\n- \"sdf"
            },
            {
                "text": " \n\\[(?=.{7,})\\d{3}[."
            },
            {
                "text": " (.{3})([0-9]{3})([0-9]"
            },
            {
                "text": " (^\\d{3}-\\d{3}-\\d{4}"
            },
            {
                "text": " (\\d{3})\\s(\\d{3})\\s(\\d{4"
            },
            {
                "text": " \n(\\d{3})\\s?\\-\\s?(\\d{3}"
            },
            {
                "text": " [^a-zA-Z0-9_\\-]{2,}\n"
            }
        ]
    },
    {
        "expression": "^([1-9][0-9]?|100)%$",
        "raw_prompt": "Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places accepted.",
        "refined_prompt": "Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places are accepted.\nMatch examples:\n- \"1%\"\n- \"52%\"\n- \"100%\"\nNon-match examples:\n- \"0%\"\n- \"100\"",
        "matches": [
            "1%",
            "52%",
            "100%",
            "49%",
            "9%",
            "7%",
            "89%",
            "26%",
            "41%",
            "5%",
            "24%",
            "3%",
            "25%"
        ],
        "non_matches": [
            "0%",
            "100",
            "101%",
            "52",
            "52.4%",
            "987654",
            "2345678",
            "hugufcxs4",
            "98765rfg",
            "hbyugt65r",
            "8765rf",
            "hgtfyr5"
        ],
        "id": 2710,
        "output": [
            {
                "text": " [0-9]%|100%\n\n```python\nimport re\n\ndef percentile_range(pct):\n    return [f\"{pct:.1f}%\" if pct > 0.5 else f\"{100-pct"
            },
            {
                "text": " [0-9]\\d{2}[.][0-9]{1}\n\nExercise 4:\nCreate a RegEx pattern that matches a string of either uppercase or lowercase letters and digits.\nAnswer: [a-zA-"
            },
            {
                "text": " A percentage is any digit from 0 to 9, followed by a '%' symbol, and then any number of digits. For example, \"12%\" and \"99%\" are considered percentages.\n2. Write a regular expression to match a date in the format \"MM/DD"
            },
            {
                "text": " ^[1-9][0-9]|100$\n\nExercise 2: Match a decimal number between 0 and 1. Accepts up to 2 decimal places. No decimal places are accepted. Match examples:\n- \".5\"\n- \"0.06\""
            },
            {
                "text": " (\\d+)%(?:%(?!\\d)(?:\\d{2})?%)*\n\n2. Write a regular expression that matches a string containing digits and/or spaces. \nAnswer:\n.*\\d.*.*\\s.*\\s"
            },
            {
                "text": " ^(0+)%\n\nExercise 3:\nCreate the following RegEx pattern\nA RegEx that finds a string that contains both \"the\" and \"the\".\nAnswer: \"the.*the\"\n\nExercise 4:\nCreate a RegEx pattern that"
            },
            {
                "text": " [0-9]\\d{1,2}%\n\n```python\nimport re\n\ndef validate_percentage(percentage):\n  pattern = r\"[0-9]\\d{1,2}%\"\n  if re.match("
            },
            {
                "text": " \n[0-9]+(?:\\.[0-9]{0,2})?\"%\n\nExercise 3:\nWrite a Python function that takes a string and a regex pattern and returns True if the string matches the pattern and False otherwise.\nAnswer:"
            },
            {
                "text": " (1-100)%\n\n2. The string below should be changed to \"1.50%\".\n- 123.45%\n- 56.78%\n- 10%\n- 1000%No changes needed.\n\n3. Write a regular expression that will"
            },
            {
                "text": " This pattern will match any number between 0 and 100 (inclusive) with no decimal places.\n\nExercise 3: Use the code below to generate a RegEx for the following descriptions.\n1. This pattern will match any string that starts with the letter 'a'.\"\n"
            }
        ]
    },
    {
        "expression": "^([0-9][0-9])[.]([0-9][0-9])[.]([0-9][0-9])$",
        "raw_prompt": "Versioning in XX.YY.ZZ format",
        "refined_prompt": "Matching dates in XX.YY.ZZ format\nMatch examples:\n- \"01.02.23\"\n- \"11.89.46\"\n- \"92.52.78\"\nNon-match examples:\n- \"1.2.3\"\n- \"23456.2345.2345\"",
        "matches": [
            "01.02.23",
            "11.89.46",
            "92.52.78",
            "04.39.63",
            "23.21.55",
            "17.50.87",
            "39.33.14",
            "79.93.88",
            "62.51.16",
            "02.19.99",
            "16.37.65",
            "68.49.64",
            "19.96.63"
        ],
        "non_matches": [
            "1.2.3",
            "23456.2345.2345",
            "3refwdsy",
            "4353.34543.34",
            "2345refdrew",
            "43564.reqt5",
            "IP",
            "#3",
            ".e.wef.",
            "efrgt54",
            "543rd",
            "gr5445"
        ],
        "id": 2735,
        "output": [
            {
                "text": "\n(^[0-9]{1,2}[.][0-9]{1,2}[.][0-9]{1,2}[.][0-9]{1,"
            },
            {
                "text": "\n\nExercise 3:\nUsing an If...Else statement, create a program that checks if a given number is even or odd. If it's even, return \"even\", and if it's odd, return \"odd\"."
            },
            {
                "text": " Generate a RegEx for this description.\n\nExercise 5: Identify the type of date mentioned in the following scenarios.\n1. \"The meeting is scheduled for 3 PM.\"\n2. \"We had our wedding"
            },
            {
                "text": " [0-9]\\.[0-9]\\.[0-9]\n\n\n\nComparison: Eager and Reluctant\n\nIn our world, people often have different attitudes towards various tasks and activities."
            },
            {
                "text": " ^[0-9]{1,2}[.][0-9]{1,2}[.][0-9]{1,3}$\n3. Given a list of names, generate a"
            },
            {
                "text": "\n[0]/[1-9]\\d{1,2}\\.[0-9]{1,2}.[0-9]{1,3}\n\nExercise 2:\nWrite a"
            },
            {
                "text": " The RegEx should match any string that starts with \"1.2.3\" and ends with \".2345\"\n\nExercise 3:\nCreate a list of strings that are between the years 1 and 7, inclusive,"
            },
            {
                "text": " \\d{1,3}\\.\\d{2,3}\\.\\d{4,}\n\nExercise 3: Find all email addresses from a given string.\nAnswer:\n- \"Contact us at info"
            },
            {
                "text": " The RegEx could be \"^[0-9.]+[.][0-9.]+[0-9.]+$\". \n\n- \"01.23.45.6789.12.345\""
            },
            {
                "text": " This example can be handled with a single regular expression, but it can be difficult to construct. One approach is to break the string up into individual components, and then construct the regular expression from these components. \n\nExercise 3"
            }
        ]
    },
    {
        "expression": "[\\\\\"\"=/>](25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2})\\.((25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{1,2})\\.){2}(25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b[\\\\\"\"=:;,/<]",
        "raw_prompt": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\".\n[\\\\\"\"=/] can be removed on both ends to seach IPs in text files, but with it, it has better accuracy - there are version numbers in the application configuration files.\nIt also does not match IPs that have one digit at the first number.",
        "refined_prompt": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:\"\n- \"34567ui\"",
        "matches": [
            "/172.21.134.89: /127.0.0.1: \"14.14.14.14\"",
            "=148.48.233.103;",
            ">145.101.251.196;",
            "\"254.228.251.171\\",
            "=250.253.4.206:",
            "/136.250.254.2/",
            "\"242.235.5.254=",
            "/207.253.250.251,",
            "\"00.206.131.5=",
            "\\163.162.2.228:",
            "\"232.06.203.251:",
            "\\47.0.42.96=",
            "\\253.250.27.228;"
        ],
        "non_matches": [
            "\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:",
            "34567ui",
            "swdefrtgyhjuik",
            "IP",
            "9876.23456.432234.54321",
            "3245.3234354.42312245.32",
            "i765rfgh",
            "/////",
            "fewcd",
            "w43rg",
            "345trf",
            "654fe"
        ],
        "id": 2740,
        "output": [
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2147"
            },
            {
                "text": "Matches plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\". It also does not match IPs that have one digit at the first number.\nMatch examples:\n- \"/172.21.134.89: /127.0.0.1: \"14.14.14.14\"\"\n- \"=148.48.233.103;\"\n- \">145.101.251.196;\"\nNon-match examples:\n- \"\"255.255.255.255\" \"243.243.2.0\" \"2."
            }
        ]
    },
    {
        "expression": "\\b(1(?!27\\.0\\.0\\.1)\\d{1,2}|2[0-4][0-9]|25[0-4]|\\d{1,2})\\.(?:\\d{1,3}\\.){2}(25[0-5]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b",
        "raw_prompt": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number",
        "refined_prompt": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"",
        "matches": [
            "172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214",
            "213.728.138.115",
            "252.783.463.44",
            "252.1.5.1",
            "211.31.6.234",
            "40.548.5.2",
            "6.3.37.187",
            "14.58.636.218",
            "10.67.0.255",
            "233.981.287.39",
            "80.13.75.211",
            "33.81.173.3",
            "221.36.546.29"
        ],
        "non_matches": [
            "127.0.0.1 192.168.1.0 255.255.255.255",
            "2345",
            "13r2456yht",
            "3r4t56",
            "345t6",
            "34567f",
            "ijyt765",
            "IP",
            "34f567hy",
            "345675432456.234565432.",
            "irtfcgv",
            "34567yterf"
        ],
        "id": 2742,
        "output": [
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this pattern"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this string"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this string"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this string"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this:"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this."
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this."
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this ("
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this pattern"
            },
            {
                "text": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number\nMatch examples:\n- \"172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214\"\n- \"213.728.138.115\"\n- \"252.783.463.44\"\nNon-match examples:\n- \"127.0.0.1 192.168.1.0 255.255.255.255\"\n- \"2345\"Generate a RegEx for this."
            }
        ]
    },
    {
        "expression": "^(((19|2\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((19|2\\d)(0[48]|[2468][048]|[13579][26])|(2[048]00)))\\/0?2\\/29)|((19|2\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00",
        "refined_prompt": "validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400/02/29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29",
            "1908/3/24",
            "2426/10/31",
            "2445/07/30",
            "2593/7/31",
            "2981/12/3",
            "2741/10/31",
            "2800/2/29",
            "1906/12/31",
            "1921/08/17",
            "1919/10/29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29",
            "12-12-12",
            "12/12/12",
            "2345678",
            "date",
            "32245/23456/3245",
            "43rfeds",
            "er4567",
            "34567543",
            "3456765432"
        ],
        "id": 2753,
        "output": [
            {
                "text": "\nvar test = new Date('2009/"
            },
            {
                "text": "\n^(19|20)(1["
            },
            {
                "text": " [yyyy]{4}/["
            },
            {
                "text": " \\b(?:{0,2}"
            },
            {
                "text": "\n^((0[1-9]"
            },
            {
                "text": " (.*?)(\\/(?:[0"
            },
            {
                "text": "^(\\d{4})/(\\d"
            },
            {
                "text": "\n\nimport re\n\ndate_pattern"
            },
            {
                "text": " \n(?<day>\\d"
            },
            {
                "text": " \n\\d{4}/\\"
            }
        ]
    },
    {
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))\\/0?2\\/29)|((1[6-9]|[2-9]\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400/02/29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400/02/29",
            "1740/02/29",
            "1871/03/31",
            "6829/05/31",
            "7200/02/29",
            "7895/8/29",
            "3055/6/9",
            "1966/08/29",
            "1680/02/29",
            "9386/04/24",
            "2639/05/18"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100/02/29",
            "12-12-12",
            "12/12/21",
            "july 4",
            "noon",
            "12:12:12",
            "32456787654",
            "432413/23435/234",
            "987654erfg",
            "r45t6y7"
        ],
        "id": 2754,
        "output": [
            {
                "text": "\n{(?:(?P<year>"
            },
            {
                "text": "\n```python\nfrom datetime import dat"
            },
            {
                "text": " [a-zA-Z]{4"
            },
            {
                "text": " (\\d\\d\\/\\d\\/\\"
            },
            {
                "text": " ^(?:(?:19[012]|"
            },
            {
                "text": " \\d{4}/\\d{2"
            },
            {
                "text": " ^(0[1-9]|1"
            },
            {
                "text": " \n\\d{4}/\\d"
            },
            {
                "text": " ([0-9]{4})/["
            },
            {
                "text": " YYYYMMDD\n\n2. Write"
            }
        ]
    },
    {
        "expression": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))$",
        "raw_prompt": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00",
        "refined_prompt": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00\nMatch examples:\n- \"2008/2/29\"\n- \"2010/12/31\"\n- \"2400-02-29\"\nNon-match examples:\n- \"2009/2/29\"\n- \"2010/11/31\"",
        "matches": [
            "2008/2/29",
            "2010/12/31",
            "2400-02-29",
            "1928|05/30",
            "1876-12|11",
            "1776|10|27",
            "1907/03/29",
            "1782|04|15",
            "1621-11-27",
            "8142|10/14",
            "7978-12|2",
            "8800|02|29",
            "2348|02|29"
        ],
        "non_matches": [
            "2009/2/29",
            "2010/11/31",
            "2100-02-29",
            "12/12/12",
            "12-12-12",
            "date",
            "july 4th",
            "noon",
            "12:12:12",
            "098765434567",
            "9876tghj",
            "kljhGFGHJKO"
        ],
        "id": 2755,
        "output": [
            {
                "text": " ["
            },
            {
                "text": "  "
            },
            {
                "text": "\n"
            },
            {
                "text": " "
            },
            {
                "text": " ("
            },
            {
                "text": " ["
            },
            {
                "text": " \\"
            },
            {
                "text": " "
            },
            {
                "text": " ^"
            },
            {
                "text": " ("
            }
        ]
    },
    {
        "expression": "^([1-9]\\d*|0)(([.,]\\d*[1-9])?)$",
        "raw_prompt": "Positive real multi-digit number: don't allow preciding zero, last decimal digit zero not allowed.",
        "refined_prompt": "Matches positive real multi-digit number: don't allow preceding zero, last decimal digit zero not allowed.\nMatch examples:\n- \"1500\"\n- \"0,331\"\n- \"12.005\"\nNon-match examples:\n- \"01500\"\n- \"0,330\"",
        "matches": [
            "1500",
            "0,331",
            "12.005",
            "19204207",
            "0.515397219064482005053962418261754892110130607560901854459878678570886142",
            "3711317789628530594278175593852273602963673841141805.89952675267724818930125059048808750694531765788250405657468405161255545581758475",
            "0,031276441419360114979141459693979515028213585191067376944080819212405988924659796784",
            "0.588997558014435396618053207557453",
            "78344561005072202780646271634804695577",
            "9209628591304586,01513469042545248301696622872846074044",
            "0.075382775592020905438587331315840881474992805278637755",
            "194036710352866414120909933050685855557052133732759020",
            "728986200392162"
        ],
        "non_matches": [
            "01500",
            "0,330",
            "012.0050",
            "kjhgfd",
            "#3",
            "$45",
            "54%",
            "098765rtfgh",
            "34f5",
            "349876ts",
            "9876543eds",
            "$%^&*()"
        ],
        "id": 2761,
        "output": [
            {
                "text": " [^0-9.]+.[0-9]{1,2}\n\nThe regular expression will match any number, with a non-zero, non-zero decimal place, followed by any character, and followed by a single digit."
            },
            {
                "text": " \\d{1,3}, \\d{3}$\n\nExercise 2:\nCreate a RegEx to match any email addresses. Emails must be valid and should have an \"@\" symbol in them.\n\nAnswer: ^[\\"
            },
            {
                "text": " r'^(1[0-9]|2[0-3])\\.[0-8]{3}$'\n\nExercise 5:\nA group of friends is planning a road trip to a nearby city. They want"
            },
            {
                "text": " ^(?:\\d{1,3}|\\d{3}(?:\\d{3})?)\\.[0-9]*$\n\nExercise 3: Match and capture a floating point number and a string using the following"
            },
            {
                "text": "\n ^(?!0)(0|,)\\d*(\\.\\d{1,2})?$\n\nA:\n\nI think that the following should work : \n/^[0-9]{1,3}"
            },
            {
                "text": "\n\nimport re\ndef valid_number(num):\n    num = str(num)\n    num_len = len(num)\n\n    # Allow zero only if there is only one preceding zero\n    if num_len == 1"
            },
            {
                "text": " (regex1)^0*([0-9]){2}(\\.\\d+)?$\n\nA:\n\n\"0(?=\\d{3})\"\n\nDoes not allow leading 0 because you are not"
            },
            {
                "text": " ^[0-9]+.[0-9]*[1-9][0-9]*$\n\nA:\n\nHere you go.\n^(?:\\d[1-9]{0,99}\\.)?"
            },
            {
                "text": "\n(?<!\\d)(0[1-9][0-9]|1[012])(?!\\d)\n\nA:\n\nThis should work for your case:\n^(\\d{1,3}("
            },
            {
                "text": " ^\\d{1,3}(\\.\\d{0,2})?$\nNote: When no leading or trailing 0 is allowed, the ^ and $ anchors prevent the pattern from matching 0.00, 0. and 0.00"
            }
        ]
    },
    {
        "expression": "^[^<>`~!/@\\#},.?\"-$%:;)(_ ^{&*=|'+]+$",
        "raw_prompt": "This regular expression will remove all invalid chars from a string",
        "refined_prompt": "Matches any strings without special characters, but can have - [ or ]\nMatch examples:\n- \"AdnanSattar\"\n- \"4567jki\"\n- \"evbtyui\"\nNon-match examples:\n- \"Adnan=Sattar\"\n- \"(*&^%$\"",
        "matches": [
            "AdnanSattar",
            "4567jki",
            "evbtyui",
            "3f45678kuy",
            "98765trghj",
            "gfdrt678",
            "3freu87t6",
            "dftgyuhijo9876",
            "fghukjhjGRFF765",
            "iuhgyuyguJGG",
            "vghftFTFT7867",
            "uygtfyFTY786",
            "nhgyt"
        ],
        "non_matches": [
            "Adnan=Sattar",
            "(*&^%$",
            "&^%$",
            "GTFR$E%^&*",
            "*&^%RFTGH",
            "HGTF^&*Y(U)_+P}{:\"LK",
            "PI(U*Y&T^R%EDRTFYG",
            "fgctyguhUY&^%Rtfyguhi",
            "U&^%RTF",
            "FRT%",
            "IUY&T^%",
            "GFRTDE$%R^&T"
        ],
        "id": 2762,
        "output": [
            {
                "text": " [^a-zA-Z0-9-.]\n- \"=^-^\"Generate a RegEx for this description. \nAnswer: ^.{6}-^\n\n#1."
            },
            {
                "text": " \\w+\n\n5. The regex should match any digit (0-9) and any character (A-Z or a-z).\n\n```python\nimport re\nstring = \"Hello World 12345"
            },
            {
                "text": " '^[a-zA-Z0-9_]+$'\n\n5. Write a string that has a pattern that matches any character or special character, but can have \",\", \":\", or \""
            },
            {
                "text": "\n\nimport re\n\nstring = \"AdnanSattar\"\n\nregex = \"(.*)&(.*)\"\n\nprint re.findall(regex, string)\n\nExercise 2:"
            },
            {
                "text": " (*&^%$)\n\n\n\nQuestion 3: A store sells apples for $0.50 each and oranges for $0.75 each. If Tom buys 3 apples and 4 oranges, how much does he"
            },
            {
                "text": ".*$\n\n- \"4567jki\"\n- \"evbtyui\"\n\nA:\n\nHere you go:\n(\\d{2})([a-zA-Z])("
            },
            {
                "text": " \\D\n- \"123,456,789,123,456,789\"\n- \"123abc457\"\n\n5. What is the purpose of the \"re.IGNORECASE\" flag in Python's"
            },
            {
                "text": " /[^\\(\\)]+(?:\\([^\\)]+\\))*/\nExercise 2:\nMatch any numbers, but can have a decimal point.\nExample: 12.5\nAnswer: /[^"
            },
            {
                "text": " (.*[^a-z])([a-z][0-9]+)\n\n3. Write a text file called \"names.txt\" that contains the names of your friends. Use RegEx to find"
            },
            {
                "text": " /\\w+/ /\\$/\n- \"evbtyui\"\nNon-match examples:\n- \"evbtyui--\"\n- \"adnan=Sattar\"\n- \"ad"
            }
        ]
    },
    {
        "expression": "^((\\d{3}[- ]\\d{3}[- ]\\d{2}[- ]\\d{2})|(\\d{3}[- ]\\d{2}[- ]\\d{2}[- ]\\d{3}))$",
        "raw_prompt": "allow to insert input for polish tax identyfication number (NIP). Mask accepted:\nXXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX",
        "refined_prompt": "Matches polish tax identification number (NIP). Mask accepted:\r\nXXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX\nMatch examples:\n- \"222-22-22-222\"\n- \"222-222-22-22\"\n- \"222 22 22 222\"\nNon-match examples:\n- \"2222222222\"\n- \"XXXXXXXXXX\"",
        "matches": [
            "222-22-22-222",
            "222-222-22-22",
            "222 22 22 222",
            "222 222 22 22",
            "046 956 96-35",
            "401-721 09 88",
            "675 51 55 031",
            "561-91-41 108",
            "825-700 53-14",
            "637-746 15-25",
            "921-161-33 32",
            "192 53 22-178",
            "090-658-27-75"
        ],
        "non_matches": [
            "2222222222",
            "XXXXXXXXXX",
            "23142536789",
            "90876543",
            "#34567",
            "XXX XXX XX XX",
            "########",
            "phone number",
            "$45",
            "54%",
            "i987654fgh",
            "324r56789"
        ],
        "id": 2781,
        "output": [
            {
                "text": " YY-ZZ-XY-ZZ-ZZ-ZZ\n\"\"\"\n\nprint(\"\\"
            },
            {
                "text": "  \"^[0-9]{2}-[0-9]{4}"
            },
            {
                "text": "\n\\d{3}-\\d{3}-\\d{4}\n"
            },
            {
                "text": " ([0-9]{0,3}[-]){0,2}["
            },
            {
                "text": "^(?:[0-9]{3}-\\d{3}-\\"
            },
            {
                "text": "\n^[0-9]{3}-?[0-9]{3"
            },
            {
                "text": " (\\d{3}-\\d{3}-\\d{4}|"
            },
            {
                "text": " (see answer for details)\nHere it is: ^([1-9]\\d"
            },
            {
                "text": " ([a-zA-z]{3}-){3}[0-9"
            },
            {
                "text": " (\\d{3})-(\\d{3})-\\d{4}\n"
            }
        ]
    },
    {
        "expression": "^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$",
        "raw_prompt": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.",
        "refined_prompt": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters.\nMatch examples:\n- \"01:23:45:67:89:AB\"\n- \"BA-57:B3-B9:C2-A8\"\n- \"D4-AC:94-1C-4E-90\"\nNon-match examples:\n- \"01:23:45:67:89:X9\"\n- \"12345678\"",
        "matches": [
            "01:23:45:67:89:AB",
            "BA-57:B3-B9:C2-A8",
            "D4-AC:94-1C-4E-90",
            "37-69-64-7A:55-33",
            "25:87:CB-DE-68:64",
            "83:59-09:02:13-1E",
            "7C-3D-35-37-08:08",
            "46:03:FE:29-70:EE",
            "64-E6:97:26-4F-ED",
            "15:63:B1-70:C1-0F",
            "C9:4F-2C-62:2E:9F",
            "30-1C-F5:0D-37-5D",
            "3A-34-0D-18-8E:D6"
        ],
        "non_matches": [
            "01:23:45:67:89:X9",
            "12345678",
            "12345:987654",
            "123,24,24",
            "34235.342.152",
            "343532.43.34321",
            "435421.354.231431",
            "2314.123431345.212.3242",
            "335fgdd45Y",
            "#34567",
            "#(*&^FGHJ",
            "num"
        ],
        "id": 2797,
        "output": [
            {
                "text": " ("
            },
            {
                "text": " ["
            },
            {
                "text": " ("
            },
            {
                "text": " ^"
            },
            {
                "text": "\n"
            },
            {
                "text": " (["
            },
            {
                "text": " ^"
            },
            {
                "text": " "
            },
            {
                "text": "\n"
            },
            {
                "text": " ("
            }
        ]
    },
    {
        "expression": "^[+]?((\\d*[1-9]+\\d*\\.?\\d*)|(\\d*\\.\\d*[1-9]+\\d*))$",
        "raw_prompt": "Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.",
        "refined_prompt": "Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional.\nMatch examples:\n- \"010\"\n- \"010.\"\n- \".010\"\nNon-match examples:\n- \".\"\n- \"0\"",
        "matches": [
            "010",
            "010.",
            ".010",
            "010.010",
            "1243404772609295125460204035371614003828140108310.483882086089625121162296779392682463219687872418273841445297924589778656003699081173212696446764736168076709970110754272238158416496545182962276094816",
            "5787025258777226663819707379967196319384975473222131719286424617699635015993186695518392374645129413419824232769857118625924603488979620374196139158758967049899733974940005868347971383727258240349596530422889540028763704063",
            "+317390232368475384705319870283923655456872508597988998976484148982938930.74523413535367925846016470846001759708321521822199817916089893999756887856549219073857219000875348648398655713758532481199114884894818968926621332224528469823343672849792642124964271582263456940281441421730106292133702246064612081827607425743354934348703280078104380",
            "3182953897310785099910859118987204527113286602884476165.28666207806970913135774976284702115742844755844412008808399999838191175393795883917224339648955713837443957888639584667972427000449501810553657701093462565010252121364298943852915776823",
            "+46370587770832127929678376020248618142063452521989380145271251667849315652492763262895792996981293241358532486717314359262894718466298817749.0078953534904249259027644247073555111954696015987831490536214972",
            "+2158922856848719788004463835161024721556049945038228650203116367358142567921754193930284810014092696233574634329661884665831191742846614885446427786673787946142266681778485231299718559289788467849451632431428549557392523457149997506741350457845340358478259692.6676486109196738323654340119355044821760389646549846054709560",
            "+3443945771146322543101357179404990583317234398482679935929068146400310910737428742620921232436424511637883899494145437199864646986253318858145738253467897784935646391753133672842758967382388500380499978777346245625941109501315287373888375921853016913967902029227211816933034790877546215539",
            "540224785306964502417438075178309712450793216478411365239754751449503078288507348034276230640265870415651654801965705369326833953079649729225951284764202884061108949",
            "701894580094396043330941524260187427917372819176324599452830966390264117488527308225997026.731512256780380230594821447687785797535881670939160002092513059769006480051521463873976495539361793328226463771981348378341425825394853626992438944879686674884538674384632264928790579882949939404150959456898163151736661811870448"
        ],
        "non_matches": [
            ".",
            "0",
            "0.",
            ".0",
            "0.0",
            "0.00",
            "00.0",
            "00.00",
            "-0",
            "-1",
            "a",
            "#"
        ],
        "id": 2799,
        "output": [
            {
                "text": " \"^0*\\d$|^\\d*\\.\\d*$\"\n\nExercise 2:\nCreate a RegEx for the following text: \"The"
            },
            {
                "text": " \"\\\\d{1,2}.\\\\d{1,2}\"\n\nExercise 2:\nMatch all words that start with 'p' and end with 'll"
            },
            {
                "text": " (.0{1})?\n\n2. Create a RegEx that matches any string that ends with 'ing'. Ignore case and whitespace.\nAnswer: '*ing"
            },
            {
                "text": ".*\n- \"0.01\"Generate a RegEx for this description. \nAnswer: (?<=[0-9])(?=[1-9"
            },
            {
                "text": "\n^(?P<number>.\\d*)\\.(?P<magnitude>.\\d*)?\\.(?P<unit>.\\d*)?$"
            },
            {
                "text": "\nRegex: (0+)\\.?\\d\nExamples:\n- \"1.23\"\n- \".3\"\n- \"0.01\"\n\nEx"
            },
            {
                "text": " \\..+\\.\n- \"0\"Generate a RegEx for this description. \nAnswer: \\d*\\.\\d*\n- \"0\"Generate"
            },
            {
                "text": " [^.]*$\n\nExercise 3: Write a RegEx for this description:\nA word consisting of one or more capital letters followed by zero or more lowercase"
            },
            {
                "text": " \n^[0-9]+(?:\\.[0-9]+)?$ \n\nExercise 5: Given the following string of text:\n\"The price"
            },
            {
                "text": " (.0)?[1-9]?[0-9]?[0-9]\n```\n\n### Exercise 3:\n\nCreate a Python RegEx"
            }
        ]
    },
    {
        "expression": "\\b[A-Z0-9]{5}\\d{1}[01567]\\d{1}([0][1-9]|[12][0-9]|[3][0-1])\\d{1}[A-Z0-9]{3}[A-Z]{2}\\b",
        "raw_prompt": "Matches the UK Drivers License format:\ni. Must be 16 characters\nii. First 5 characters are alphanumeric.\niii. Next 6 characters must be numeric\niv. Next 3 characters are alphanumeric\nv. Last 2 characters are alpha\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\nFourth and fifth characters of numeric section must be in the range 01 to 31.",
        "refined_prompt": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\"\n- \"ASD12405315AA4AA\"\nNon-match examples:\n- \"SASAS701062AB8D\"\n- \"ASD12405315AA4A\"",
        "matches": [
            "SASAS701062AB8DD",
            "OOVJW664033DAGCW",
            "ASD12405315AA4AA",
            "ABCDE101010XY9AA",
            "L81PT101045J2PJZ",
            "F4UFY6761434Y8VO",
            "PCVMQ002145D8MCC",
            "XGTOC760067R9EVK",
            "E5R6H6703194RVUT",
            "TI7XY265044RUCZQ",
            "02CQ8663081B5TKM",
            "NDAID811302OTCMP",
            "C0OMR760174Q9QPS"
        ],
        "non_matches": [
            "SASAS701062AB8D",
            "ASD12405315AA4A",
            "ABCDE101010XY9A",
            "ABD2A121010AM9FA",
            "ABCDE101010XY9A9",
            "AbCdE711215GG9aa",
            "AFG98101010AM9Fa",
            "SSSSS841215SS9SS",
            "AFG98101000AM9FA",
            "AF\u00ac98101010AM9FA",
            "ABC99808275m99sc",
            "ABCDE654321A98"
        ],
        "id": 2803,
        "output": [
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCWG"
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            },
            {
                "text": "Matches the UK Drivers License format:\r\ni. Must be 16 characters\r\nii. First 5 characters are alphanumeric.\r\niii. Next 6 characters must be numeric\r\niv. Next 3 characters are alphanumeric\r\nv. Last 2 characters are alpha\r\nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7.\r\nFourth and fifth characters of numeric section must be in the range 01 to 31.\nMatch examples:\n- \"SASAS701062AB8DD\"\n- \"OOVJW664033DAGCW\""
            }
        ]
    },
    {
        "expression": "^[a-zA-Z][a-zA-Z\\-' ]*[a-zA-Z ]$",
        "raw_prompt": "Check for person name in database for example.\nA person name is a string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe (') and the space. For these three characters, not at the beginning or the end of the string.",
        "refined_prompt": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"",
        "matches": [
            "Pierre-Francis d'Astier de Weyergans-Migery",
            "Jeanne d'Arc",
            "Nicolas Sarkozy",
            "Charles de Gaulle",
            "Dominique Strauss-Kahn",
            "John",
            "Smith",
            "Lucky",
            "Kathryn",
            "wwefrgthyjukil",
            "jUHYGTFhujil",
            "GUyiuhTFY",
            "UYFuuiGUGugGug"
        ],
        "non_matches": [
            "-tutu",
            "tutu-",
            "'tutu",
            "tutu'",
            "tu1tu",
            "tu*tu",
            "1tutu",
            "tutu*",
            "$4",
            "98765rftghb",
            "54%",
            "12-12"
        ],
        "id": 2809,
        "output": [
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Matches a name that is s string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe ('), and the space. For these three characters, not at the beginning or the end of the string.\nMatch examples:\n- \"Pierre-Francis d'Astier de Weyergans-Migery\"\n- \"Jeanne d'Arc\"\n- \"Nicolas Sarkozy\"\nNon-match examples:\n- \"-tutu\"\n- \"tutu-\"Generate a RegEx for this description. \n"
            }
        ]
    },
    {
        "expression": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][ ][aApP][mM]){1}$",
        "raw_prompt": "This will validate 12 hours time format with AM/am PM/pm",
        "refined_prompt": "This will validate 12 hours time format with AM/am PM/pm\nMatch examples:\n- \"11:11 AM\"\n- \"01:11 PM\"\n- \"12:59 AM\"\nNon-match examples:\n- \"21:11 AM\"\n- \"00:00 PM\"",
        "matches": [
            "11:11 AM",
            "01:11 PM",
            "12:59 AM",
            "08:07 Pm",
            "4:37 PM",
            "7:42 aM",
            "1:49 pM",
            "12:48 aM",
            "12:20 PM",
            "02:04 PM",
            "5:24 pM",
            "6:14 aM",
            "10:12 Pm"
        ],
        "non_matches": [
            "21:11 AM",
            "00:00 PM",
            "10:70 AM",
            "10:50PM",
            "am",
            "PM",
            "12-12",
            "12/12",
            "time",
            "noon",
            "1 pm",
            "00"
        ],
        "id": 2812,
        "output": [
            {
                "text": " \\b(0[1-9]|1\\d|2[0-3])[:p](\\d[0-5])[:z]\nThis will validate 16 hour time format with AM/pm/pm.\n"
            },
            {
                "text": " The RegEx should be \"^([0-9]{1,2})\\s([A-Z]{3}):([0-5]?[0-9])$\"\n3. Write a RegEx to validate a"
            },
            {
                "text": " (\\d{1,2})\\s\\d{1,2}:\\d{1,2} (AM|PM|AMPM)\n- What is the correct RegEx for this description.\n\"\"\"\n\n# Generate"
            },
            {
                "text": " ([0-9][0-9]|1[0-2]):[0-5][0-9]\n\nExercise 5:\n- Write a RegEx pattern that matches an IP address with exactly 4 decimal numbers.\n"
            },
            {
                "text": " ^((1[012]|3[01]):[0-5][0-9])?(([0-9]+[:]){2})?$\n\n3. Write a RegEx that matches the following phrase, which"
            },
            {
                "text": " \\d{2}:\\d{2} (AM|PM|AM\\s|PM\\s)?[0-9]\n\n**Exercise 2**\nUsing the same string as in \"Exercise 1\", generate a regular expression"
            },
            {
                "text": " (^|\\s)\\d{1,2}\\s?[APM]M$\n\nExercise 2:\nWrite a RegEx for this string:\n\"The last name is D'Souza, and he last name"
            },
            {
                "text": "\n```python\nimport re\n\ndef validate_time(time):\n    #Validating time format: AM/am/pm, HH:MM\n    pattern = r'^(?P<Hour>[01][0-9"
            },
            {
                "text": "\n((\\d+?):(\\d+?)(\\s\\w+)?(AM|PM))\n\n2. Write a RegEx to capture the username and domain name from an email address. \nExample emails:\n- john@"
            },
            {
                "text": "\n```python\ndef validate_time(time):\n    time = time.strip()\n    if time.isnumeric():\n        time = int(time)\n    else:\n        time = \"-\".join(time."
            }
        ]
    },
    {
        "expression": "(((^[>]?1.0)(\\d)?(\\d)?)|(^[<]?1.0(([1-9])|(\\d[1-9])|([1-9]\\d)))|(^[<]?1.4(0)?(0)?)|(^[<>]?1.(([123])(\\d)?(\\d)?)))$",
        "raw_prompt": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.",
        "refined_prompt": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"",
        "matches": [
            ">1.0",
            "<1.001",
            ">1.399",
            "<1B06",
            "<1T072",
            "1<0",
            "<1I015",
            "1B34",
            "100",
            ">1-05",
            "130",
            "1:03",
            ">1}014"
        ],
        "non_matches": [
            ">1.400",
            "1.",
            "1.0011",
            "23refds",
            "4356HUI*T^R&%",
            "HT^&R",
            "#",
            "3",
            "34",
            "4353",
            "$4",
            "45%"
        ],
        "id": 2816,
        "output": [
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            },
            {
                "text": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer.\nMatch examples:\n- \">1.0\"\n- \"<1.001\"\n- \">1.399\"\nNon-match examples:\n- \">1.400\"\n- \"1.\"Generate a RegEx for this description. \n"
            }
        ]
    },
    {
        "expression": "^(((0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(0?[1-9]|1[012])/(19|[2-9]\\d)\\d{2}|0?29/0?2/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "raw_prompt": "DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY",
        "refined_prompt": "DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY\nMatch examples:\n- \"21/01/1972\"\n- \"21/1/1972\"\n- \"1/1/1972\"\nNon-match examples:\n- \"21-01-1972\"\n- \"21-01-1972\"",
        "matches": [
            "21/01/1972",
            "21/1/1972",
            "1/1/1972",
            "29/2/2012",
            "29/02/2012",
            "10/31/12/1943",
            "6/30/10/1972",
            "029/02/1908",
            "4/10/4721",
            "09/30/12/6065",
            "029/02/1908",
            "09/10/1997",
            "029/2/6156"
        ],
        "non_matches": [
            "21-01-1972",
            "21-01-1972",
            "29/02/2011",
            "234567",
            "12-12-12",
            "12/2",
            "0000",
            "date",
            "12:12",
            "12|12|1212",
            "234567890",
            "$45"
        ],
        "id": 2827,
        "output": [
            {
                "text": " D"
            },
            {
                "text": "\n"
            },
            {
                "text": " ^"
            },
            {
                "text": " '"
            },
            {
                "text": "\n"
            },
            {
                "text": " *"
            },
            {
                "text": " ["
            },
            {
                "text": "\n"
            },
            {
                "text": "\n"
            },
            {
                "text": " D"
            }
        ]
    },
    {
        "expression": "(Mo(n(day)?)?|Tu(e(sday)?)?|We(d(nesday)?)?|Th(u(rsday)?)?|Fr(i(day)?)?|Sa(t(urday)?)?|Su(n(day)?)?)",
        "raw_prompt": "The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions.",
        "refined_prompt": "The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions.\nMatch examples:\n- \"Mo\"\n- \"Sun\"\n- \"Monday\"\nNon-match examples:\n- \"Any\"\n- \"day\"",
        "matches": [
            "Mo",
            "Sun",
            "Monday",
            "Sunday",
            "Tues",
            "Tu",
            "Tuesday",
            "We",
            "Wednesday",
            "Th",
            "Thursday",
            "Sa",
            "Saturday"
        ],
        "non_matches": [
            "Any",
            "day",
            "week",
            "MWF",
            "78654",
            "rfe4gt53",
            "44",
            "345678",
            "erwdsa",
            "87654",
            "12",
            "sdfghjkl"
        ],
        "id": 2844,
        "output": [
            {
                "text": " [d-m-n-t-u-w-e-r-o-n], as in [^d-m-n-t-u-w-e-r-o-n].\n\n"
            },
            {
                "text": " [\\w-]{1,3}\n\n2. Your user needs to input a 6-digit number and must verify that the number is greater than 3 and less than 1000. Use RegEx to create the validation expression"
            },
            {
                "text": " \n\\A[a-z][a-z][a-z]\\w{1,2}\\w+\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\"
            },
            {
                "text": " (example) r'sun|monday|tuesday|wednesday|thursday|friday|saturday|sunday'\n\nLecture Script:\n\nWelcome to subsection 8.3.1"
            },
            {
                "text": "\n(^|\\s)[a-z]{3,5}$\n\nExercise 2: Create a new field called \"weekday\" that sets the value of the \"weekday\" field to the weekday name"
            },
            {
                "text": " (.*)\n- \"any\"Generate a RegEx for this description. \nAnswer: (.*)\n\n4. Write a regular expression to match email addresses.\nAnswer:\n(.+@[a"
            },
            {
                "text": "\n\ndef generate_date_format(s):\n  return '(' + s.replace(' ', '.') + ')'\n\ngenerate_date_format(\"Mo\") # \"(.0)\"\ngenerate"
            },
            {
                "text": " \\b(MO|Sun|Tues|Wednes|Thurs|Fri|Sat)\\b\n\nExercise 2: \nCreate a RegEx expression for this description: \n\"A day of the week that"
            },
            {
                "text": " \nimport re\ntest_list = [\"Mo\", \"Sun\", \"Monday\", \"Any\", \"day\"]\nregEx = \"^(\\w{2}|\\w{3})\\s(Mon|Tue"
            },
            {
                "text": " (\\w+\\/\\w+)\n- This is a weekend day (Sat,Sun,Fri) Match this pattern.\nAnswer: (Sat|Sun|Fri)\n\n3. Create a simple Python script using a"
            }
        ]
    },
    {
        "expression": "^([7-9]{1})([0-9]{9})$",
        "raw_prompt": "Mobile Number starts with 7,8,9 and total 10 digits",
        "refined_prompt": "Matches mobile numbers that stars with 7,8,9 and have a total 10 digits\nMatch examples:\n- \"9848457682\"\n- \"8748070871\"\n- \"9140445480\"\nNon-match examples:\n- \"123456789\"\n- \"234\"",
        "matches": [
            "9848457682",
            "8748070871",
            "9140445480",
            "8187798460",
            "7205929092",
            "7873485779",
            "8228102485",
            "7943185172",
            "9270010952",
            "7420143970",
            "7828685261",
            "7320622463",
            "9763183399"
        ],
        "non_matches": [
            "123456789",
            "234",
            "324213",
            "-8765",
            "+8765",
            "$567890",
            "8765%",
            "#4",
            "12.324",
            "12.12",
            "12/12",
            "12-12"
        ],
        "id": 3169,
        "output": [
            {
                "text": " Matches mobile numbers that have 7 or more digits.\n\n### Exercise 2:\n\nWrite a Python list comprehension that creates a list of numbers from 1 to 100 that are divisible by 3 or 5.\n\n#### Solution"
            },
            {
                "text": " \n(?!^).*(?<!^)..(?!$).(?<!^)\n\nExamples of Python Code:\n1. Using Python to generate a list of mobile numbers that match the pattern"
            },
            {
                "text": " ^(1[23456789]{3}|2[344]{3}|3[34]{2}|4[3457]{3}|5[123]{2}|6"
            },
            {
                "text": " \n\n1. The pattern must match the character 'g' before and after the star, and there must be ten characters in the string.\n\n2. The pattern must match the characters 'g' before and after the"
            },
            {
                "text": " [0-9]{5}[0-9]{4}[0-9]{3}[0-9]{3}[0-9]{3}[0-9]{2"
            },
            {
                "text": "^[0-9]{10}$\n\nExercise 2: \nMatch email addresses that follow the format x.y.z\nAnswer:^[a-z0-9]+\\.[a-z"
            },
            {
                "text": "\n[1-9][0-9]|1[0-9]|2[0-3]|[0-5][0-9]|6[0-9]|7[0-9"
            },
            {
                "text": " 7,8,9[0-9]{4}.\n\n#### Exercise 3\nGiven the words: cat, dog, man, and cat, how do you generate a list of all possible two-character combinations of the"
            },
            {
                "text": " [0-9]{7,9}\n\nExercise 4:\nGive an example of a situation where not all the words in a sentence need to be matched.\n\nExercise 5:\nCreate a RegEx"
            },
            {
                "text": " A RegEx that matches mobile numbers with seven, eight, or nine digits and a total of 1 to 9 digits.\n\nExercise 3: Match names with corresponding phone numbers\nMatch each name with its corresponding phone number.\n"
            }
        ]
    },
    {
        "expression": "^((\\+|00)[1-9]{1,3})?(\\-| {0,1})?(([\\d]{0,3})(\\-| {0,1})?([\\d]{5,11})){1}$",
        "raw_prompt": "International phone number with 6 capturing groups:\ninternational prefix (00 xor '+');\n1 to 3 international code number, no zero allowed;\noptional space or hyphen;\n0 to 3 local prefix number;\noptional space or hyphen;\n5 to 11 local number without spaces or hyphens;",
        "refined_prompt": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91)12345678\"",
        "matches": [
            "0034 91 12345678",
            "+39-2-1234567",
            "9112345678",
            "-5200553",
            "844001",
            "00936 0029092",
            "-92730",
            "4551720",
            "+918618376322",
            "+4 76 33954021871",
            "8429837872",
            "+5827195410",
            "-84599725"
        ],
        "non_matches": [
            "0034 91 123-456-789",
            "(91)12345678",
            "0034 (91)12345678",
            "(8765)",
            "32",
            "-",
            "+9",
            "$567",
            "8765%",
            "43e",
            "43eds",
            "54re3"
        ],
        "id": 3207,
        "output": [
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 12"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            },
            {
                "text": "Matches international phone number with 6 capturing groups:\r\ninternational prefix (00 xor '+');\r\n1 to 3 international code number, no zero allowed;\r\noptional space or hyphen;\r\n0 to 3 local prefix number;\r\noptional space or hyphen;\r\n5 to 11 local number without spaces or hyphens;\nMatch examples:\n- \"0034 91 12345678\"\n- \"+39-2-1234567\"\n- \"9112345678\"\nNon-match examples:\n- \"0034 91 123-456-789\"\n- \"(91) 123"
            }
        ]
    },
    {
        "expression": "((0[1-9])|(1[0-9])|(2[0-9])|(3[0]))/((0[1-9])|(1[0-2]))/14[3-9]{2}",
        "raw_prompt": "Matches DD/MM/YYYY for Arabic Hijri Dates. It starts range from 1434 ( current year ) to 1499",
        "refined_prompt": "Matches DD/MM/YYYY for Arabic Hijri Dates. It starts range from 1434 ( current year ) to 1499\nMatch examples:\n- \"29/12/1434\"\n- \"01/02/1435\"\n- \"30/11/1434\"\nNon-match examples:\n- \"31/12/144\"\n- \"01/2/1435\"",
        "matches": [
            "29/12/1434",
            "01/02/1435",
            "30/11/1434",
            "30/09/1494",
            "26/01/1483",
            "02/10/1448",
            "26/05/1468",
            "07/03/1484",
            "06/03/1445",
            "14/08/1438",
            "02/08/1486",
            "26/04/1468",
            "30/12/1443"
        ],
        "non_matches": [
            "31/12/144",
            "01/2/1435",
            "5/5/1435",
            "12/12",
            "12-12",
            "12-12-1212",
            "2134567",
            "+098765",
            "-987654",
            "date",
            "august 5th",
            "76rdfg"
        ],
        "id": 3219,
        "output": [
            {
                "text": " \\d\\d\\/\\d\\d\\/\\d\\d\n\nA:\n\nIt depends on what the format is for"
            },
            {
                "text": " ( [0-9]{4}/[0-9]{2}/[0-9]{2}|"
            },
            {
                "text": " \n\"\\d{4}/\\d{2}/\\d{2}\"\n\n(4)Write a Reg"
            },
            {
                "text": " ^\\d{2}/\\d{2}/\\d{4}$\n\nExercise 8.2: Gener"
            },
            {
                "text": "\n^[0-9]/[0-9]/[0-9]$\n\nExercise 2:\nYou"
            },
            {
                "text": " \n\nvar regex = /^(0[1-9]|1[012])\\/(0[1-9]"
            },
            {
                "text": "\n\n[a-zA-Z0-9_]{2}[0-9]{3}-[0-"
            },
            {
                "text": " (1434 | 1435 | 1436 | 1437 | 1438 | 1439 | 1440 | 1441 | 1442 |"
            },
            {
                "text": " \"^(1[0-2][0-9]|3[01])\\/(1[0-2]|0"
            },
            {
                "text": " \\b\\d{1,2}\\/\\d{1,2}\\/\\d{4}\\b\nA:\n"
            }
        ]
    },
    {
        "expression": "^(0|\\+33)[1-9]([-. ]?[0-9]{2}){4}$",
        "raw_prompt": "Match french phone number with or without french international dialling code",
        "refined_prompt": "Match french phone number with or without french international dialling code\nMatch examples:\n- \"+33622313131\"\n- \"02 02 02 02 02\"\n- \"0303030303\"\nNon-match examples:\n- \"+34622313131\"\n- \"1702020202\"",
        "matches": [
            "+33622313131",
            "02 02 02 02 02",
            "0303030303",
            "+331.4690.34 47",
            "+331 496409.08",
            "07 1785-81-31",
            "07-31.06-0072",
            "+3325537-99-41",
            "03510025-43",
            "01-23 17.66.08",
            "+3364933 17-14",
            "05721136 91",
            "+3314131 28-24"
        ],
        "non_matches": [
            "+34622313131",
            "1702020202",
            "23",
            "12/12",
            "12-12",
            "12.12",
            "$56789",
            "-98765",
            "4567%",
            "32ewds",
            "4f3rec",
            "####"
        ],
        "id": 3228,
        "output": [
            {
                "text": " (?<![0-9])[0-9]\\d{4}-[0-9]\\d{2}-[0-9]\\d{2}\n\nA:\n\nYou can use this regex to get what"
            },
            {
                "text": "\n+33622313131\n\\+\\d{3}\\s\\d{3}\\s\\d{4}\n\\+\\d{3}\\s\\d{2}\\s\\d{4}\n\\+\\d{3"
            },
            {
                "text": "\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n        char name[20], phone[20], number[20], codes[20];\n        "
            },
            {
                "text": " [+3][6][2][3][2][4][3][3][5][2]\n\n4. Use your RegEx to capture the area code and line number from the phone numbers in the following sentences:\n\nExample:\n- \""
            },
            {
                "text": "\n(?(?=(?:[^0-9]|^)\\d{10})(?:[^0-9]|$))0[0-9]{2}[0-9]{3}[0-9]"
            },
            {
                "text": " ^[[:digit:]].*[0-9]$\nExercise 2:\nMatch email address with or without email server or domain\nMatch examples:\n- \"user@co.uk\"\n- \"admin@server.com\"\n-"
            },
            {
                "text": " The correct answer is \n[0-9]{4}-[0-9]{3}-[0-9]{2}-[0-9]{2} [A-z]{3} [A-z]{3"
            },
            {
                "text": " \"+[0-9]{3}[- ][0-9]{4}\"\n\nExercise 3:\nMatch the email addresses with or without a period after the username.\nMatch examples:\n- \"admin@mydomain.com"
            },
            {
                "text": " \"\\d{3}-\\d{3}-\\d{4}\"\n- \"20-20-20\"Generate a RegEx for this description. \nAnswer: \"\\d{2}-\\d{2}-\\"
            },
            {
                "text": " (?<!\\d)(\\+?\\d{3}[-\\.\\s]?){3}\\d{3}(?!\\d)\n\n\n\nIn the world of transportation, cars play a big role. Cars are vehicles"
            }
        ]
    },
    {
        "expression": "^(\\d?)*\\.?(\\d{1}|\\d{2})?$",
        "raw_prompt": "Expression to validate currency formatted numbers without the currency symbol. This is an updated version of my previous expression and now works in ASP.NET regular expression validators.",
        "refined_prompt": "Expression to validate currency formatted numbers without the currency symbol.\nMatch examples:\n- \"153\"\n- \"33.48\"\n- \"786.1\"\nNon-match examples:\n- \"-123\"\n- \"8524.258\"",
        "matches": [
            "153",
            "33.48",
            "786.1",
            "1567863483.33",
            "82620488732013362401002347289597345549580362775",
            "2656254197019330262321471387006506127493056032004370440",
            "1311244136524109600515669070575811020331240032815399.",
            "443946045269136478024586026599.",
            "64428461059046924271793448.1",
            "5833212769801702132419173010140466290563",
            "8742104836584323.87",
            "32636373432149873597766966.",
            "5024936454117752195698822273485385331"
        ],
        "non_matches": [
            "-123",
            "8524.258",
            "eo45",
            "+87654",
            "$456789",
            "8765%",
            "8392iuyg",
            "###",
            "(765)",
            "32e",
            "num",
            "876tr5dRTYU"
        ],
        "id": 3234,
        "output": [
            {
                "text": " [\\d.]{0,}(?=[,.])\n\n5. The currency formatted string should use at least 2 digits before the decimal point, at least 2 digits after the decimal point, and the currency symbol should be optional (i.e., \"USD\", \"EUR\","
            },
            {
                "text": "\n[^0-9.]\n\nExercise 5:\nCreate a Matcher object, which will match text starting with \"http\" and ending with \".com\".\nAnswer:\nhttps?:\\/\\/[^\\s]+\\.com\n\n\n\nFocus on Both Positive and Negative"
            },
            {
                "text": " One possible RegEx is \"(\\\\d+(\\\\.\\\\d+)?)\" which matches floating point numbers. \n\nExercise 2: \nCreate a RegEx to validate email addresses, considering the following email formats:\n- username@domain.com\n- username@domain.net\n"
            },
            {
                "text": " \n\nimport re\n\nexamples = [\n    \"153\",\n    \"33.48\",\n    \"786.1\"\n]\n\nnon_match_examples = [\n    \"-123\",\n    \"8524.258\"\n]\n\ndef validate"
            },
            {
                "text": " [^\\d.-]+\n3.  Write a Python RegEx to find all the email addresses contained in a given text. \nMatch examples:\n- \"Please send me an email at my email address\"\n- \"My email is john.doe@example.com\"\n"
            },
            {
                "text": "\n$('.currency match').select(':numeric').match(/^(?:{0})(?:,{0})*$/i)\n\n5. Use the RegEx generated above to validate currency formatted numbers without the currency symbol without a comma or any other character."
            },
            {
                "text": " r'[0-9]{1,2}(\\.\\d{0,2})?(,[0-9]\\d{3})*'\n\n2. Write a script that takes in a string of US currency formatted numbers and returns true if all the numbers have a"
            },
            {
                "text": " (\\d)(\\.)(\\d)\n\nExercise 3:\nMatch examples:\n- \"6.4 km\"\n- \"3.21 m\"\n- \"45.3%\"\nNon-match examples:\n- \"-4.5 km\"\n- \"4"
            },
            {
                "text": "  (\\d+)\\.\\d+\n\n3. Given a list of strings, return the string with the highest numerical value. \nHint: Use a combination of the RegEx and list.sort() functions.\n\n```python\n# Solution\ndef string_with_highest"
            },
            {
                "text": " [^\\d]+\n\nExercise 3: Validating Email Format\nMatch examples:\n- \"example@example.com\"\n- \"example@example\"\nNon-match examples:\n- \"-123\"\n- \"8524.258\"Generate a RegEx for this"
            }
        ]
    },
    {
        "expression": "^(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4})|(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4}))[ ]([0|1][0-2])[:](([0-5][0-9]))([:](([0-5][0-9])))?)$",
        "raw_prompt": "this regular expression accepts date and optinal time with format\n(dd)[.-/](MM)[.-/](yyyy)[ ]\n(hh)[:](mm)[:](ss)",
        "refined_prompt": "accepts date and optinal time with format\r\n(dd)[.-/](MM)[.-/](yyyy)[ ]\r\n(hh)[:](mm)[:](ss)\nMatch examples:\n- \"01-01-2014 10:50\"\n- \"01/01/2014 10:50:59\"\n- \"11-10-2012\"\nNon-match examples:\n- \"01-01-2014 10:60\"\n- \"32-01-2014 10:50\"",
        "matches": [
            "01-01-2014 10:50",
            "01/01/2014 10:50:59",
            "11-10-2012",
            "3|.10.3059",
            "10-07/4711 11:00:11",
            "|1.10.7248 |0:04",
            "21/11/9170 01:46:14",
            "23.05.7387 |0:34:34",
            "07-08/6724",
            "06/10/9781 01:41:45",
            "30-06-4116 02:47",
            "07-08/6088 00:55:36",
            "17/01/6890"
        ],
        "non_matches": [
            "01-01-2014 10:60",
            "32-01-2014 10:50",
            "01-13-2014 10:50",
            "3245678",
            "5432",
            "21",
            "3456789",
            "567454",
            "12/12",
            "12-12",
            "date",
            "12.12"
        ],
        "id": 3264,
        "output": [
            {
                "text": " \\d{2}-\\"
            },
            {
                "text": " \n(^[1-"
            },
            {
                "text": " \n(.+?)("
            },
            {
                "text": "  (?:\\d{1"
            },
            {
                "text": " \n^[0-9"
            },
            {
                "text": " \n/(\\d{2"
            },
            {
                "text": " The RegEx would be: \\"
            },
            {
                "text": " \".*?(?=\\"
            },
            {
                "text": " \r\n(?<day"
            },
            {
                "text": " 0[0-9][0"
            }
        ]
    },
    {
        "expression": "^([0-9]{4})([0-9]{5})([0-9]{1})$",
        "raw_prompt": "The INN code is formed by:\nthe code of the tax department where INN was given (4 numbers), the record number of a registered company in the territorial section of the Unified State Register of Legal Entities in the tax department where INN was given (5 numbers), check digit (1 numbers)",
        "refined_prompt": "Matches INN code is formed by:\r\nthe code of the tax department where INN was given (4 numbers), the record number of a registered company in the territorial section of the Unified State Register of Legal Entities in the tax department where INN was given (5 numbers), check digit (1 numbers)\nMatch examples:\n- \"1234567891\"\n- \"6121546557\"\n- \"2996330885\"\nNon-match examples:\n- \"-\"\n- \"23\"",
        "matches": [
            "1234567891",
            "6121546557",
            "2996330885",
            "9071143858",
            "6831050660",
            "5032286810",
            "5643661741",
            "4289211487",
            "5130348925",
            "3124211984",
            "1203313918",
            "4960218069",
            "4205611860"
        ],
        "non_matches": [
            "-",
            "23",
            "234",
            "4freds",
            "34256",
            "654",
            "########",
            "$4567",
            "12/12",
            "9932.234",
            "4342",
            "9876443456789098765456789"
        ],
        "id": 3277,
        "output": [
            {
                "text": " [1234-567"
            },
            {
                "text": " \n\\d\\d"
            },
            {
                "text": " \\b\\d{12"
            },
            {
                "text": " \"^[1-9"
            },
            {
                "text": "\n^[0-9"
            },
            {
                "text": " ([0-9A-"
            },
            {
                "text": ".{1,10}"
            },
            {
                "text": " \\d{10}-"
            },
            {
                "text": " \\d{4}\\d"
            },
            {
                "text": " \"^([0-9"
            }
        ]
    },
    {
        "expression": "^([0-9]{1})([0-9]{2})([0-9]{2})([0-9]{7})([0-9]{1})$",
        "raw_prompt": "The OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)",
        "refined_prompt": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \"23\"",
        "matches": [
            "1234567891234",
            "0175106545632",
            "5969169407468",
            "6123158937485",
            "6423933815629",
            "5573896389764",
            "3982998881161",
            "8545973921523",
            "0707207053700",
            "1299659347786",
            "0246919033615",
            "9060347655405",
            "7652089273422"
        ],
        "non_matches": [
            "-",
            "23",
            "3214",
            "123",
            "#3",
            "#########",
            "12/12",
            "12-12-12",
            "werrfghtjk",
            "4532",
            "23213433253453451234242343214222",
            "34213241542t56769867956487594"
        ],
        "id": 3278,
        "output": [
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            },
            {
                "text": "Matches OGRN code is formed by: the state registration number has the status of the main one (1 number), two last numbers of the year when the record was made (2 numbers), the sequence number of a constituent entity of Russia according to the list of constituent entities of Russia (2 numbers), record number entered in the state register within a year (7 numbers), check digit (1 number)\nMatch examples:\n- \"1234567891234\"\n- \"0175106545632\"\n- \"5969169407468\"\nNon-match examples:\n- \"-\"\n- \""
            }
        ]
    },
    {
        "expression": "^((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|[1][02])([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[1][0-9]|[2][0-8])([/])(02)([/])(19[0-9][0-9]|20[0-9][0-9]))|((29)([/])(02)([/])(190[48]|19[13579][26]|19[2468][048]|20[02468][048]|20[13579][26]))$",
        "raw_prompt": "This pattern validates dates with slash (/) separator and with years between 1900 and 2099.",
        "refined_prompt": "This pattern validates dates with slash (/) separator and with years between 1900 and 2099.\nMatch examples:\n- \"01/01/1900\"\n- \"05/12/2014\"\n- \"31/12/2099\"\nNon-match examples:\n- \"41/01/1900\"\n- \"21/31/2014\"",
        "matches": [
            "01/01/1900",
            "05/12/2014",
            "31/12/2099",
            "12/02/1928",
            "29/02/1964",
            "29/04/1975",
            "01/04/2045",
            "01/02/2090",
            "29/02/2024",
            "28/10/2006",
            "30/09/2014",
            "05/02/2029",
            "30/06/1902"
        ],
        "non_matches": [
            "41/01/1900",
            "21/31/2014",
            "21/12/1899",
            "21/12/2100",
            "12-12-12",
            "date",
            "12/12/12",
            "13245678",
            "2342",
            "0.0",
            "12",
            "123456789"
        ],
        "id": 3280,
        "output": [
            {
                "text": " \n(20|[0-9]|1[0-9])\\/(0[1-9]|1[012])\\/(19[0-9]|"
            },
            {
                "text": "\n(0[1-9]|1[012])/([1-9]\\d|[12][0-9]|3[01])/([0-9"
            },
            {
                "text": " ^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$\n\n2. Exercise: You are trying to validate a ZIP code. The"
            },
            {
                "text": " /[0-9]{1,2}\\.[0-9]{3}[-_]?[0-9]{2}/ \n\n4. Write"
            },
            {
                "text": "\n/(\\d{2}\\/\\d{2}\\/\\d{4})/\n\n2. Given a list of email addresses, validate each one using the Email Validation"
            },
            {
                "text": " This pattern validates dates with slash (/) separator and with years between 1900 and 2099. Use the following RegEx: (?<!20[0-9])/[0"
            },
            {
                "text": " \"^\\d{4}/\\d{2}/\\d{2}$\"\n3. You have a string of a full name. You want to extract the first"
            },
            {
                "text": " [0-9]{4}-[0-9]{2}[0-9]([0-2][0-9]|3[0-1])\n\n"
            },
            {
                "text": "\nThe pattern is /(0[1-9]|1[012])/[0-9]{2}/.\n\nExercise 2:\nWrite a regular expression that"
            },
            {
                "text": "\nimport re\nprint(re.compile(r'^(0?[1-9]|1[012])\\/(0?[1-9]|[12"
            }
        ]
    },
    {
        "expression": "^[1-9][0-9][0-9][0-9][0-9][0-9]$",
        "raw_prompt": "picode test",
        "refined_prompt": "Matches 6 digit pin codes\nMatch examples:\n- \"221001\"\n- \"929803\"\n- \"304135\"\nNon-match examples:\n- \"abcdd\"\n- \"ewrtyu\"",
        "matches": [
            "221001",
            "929803",
            "304135",
            "957924",
            "390543",
            "962831",
            "484081",
            "122937",
            "624889",
            "689953",
            "123367",
            "535820",
            "375211"
        ],
        "non_matches": [
            "abcdd",
            "ewrtyu",
            "werty",
            "ertyuh",
            "RTY",
            "WERTYU6543E",
            "IJOUHYgtfvgbhn876tJ",
            "gfdreFVGBG54",
            "hgrFVGGt654ed",
            "BGFF",
            "pincode",
            "######"
        ],
        "id": 3347,
        "output": [
            {
                "text": " \n[a-z]\\d{3}\\d[a-z]\n\nHost 2: Alright, let's move on to the third quiz.\n\nQuiz 3: Write a regular expression to match email addresses.\n\nHost 1: Email addresses are a common pattern that you might encounter in your"
            },
            {
                "text": " \"^\\d{6}$\"\n\n2) Search for all emails within a text file.\nMatch examples:\n- \"john@gmail.com\"\n- \"mary@yahoo.com\"\n- \"peter@hotmail.com\"\nNon-match examples:\n- \"jane"
            },
            {
                "text": " \"^0-9[0-9]{5}$\"\n\nExercise 2:\nDevelop a Python function that takes a list of pin codes and returns only the codes that are 6 digits long.\n\n```python\ndef filter_pins(pins):\n    return [pin for pin in pins"
            },
            {
                "text": " ^(?:(?:[3-9][0-9]|0)?[1-9][0-9]|[1-3][0-9][0-9])(?!.*\\\\1)(?:\\\\d{3})(?!.*\\\\2)(?!.*\\\\3)$\n"
            },
            {
                "text": " ^(5[1-9])(?!0).*$\n\nExercise 2:\nWrite a Python program to validate if a given email adn password is valid using RegEx.\nExample:\nEmail: john.smith@gmail.com\nPassword: 1234567890\nNon-valid example:"
            },
            {
                "text": "\n- \"(.*)([a-zA-Z])(.*)\"\n\n5. Write a Python function that takes a string and a regular expression as input and returns the number of non-matching group(s) in the string. The regular expression should only match groups that consist of alphanumeric characters,"
            },
            {
                "text": "\n[A-Z0-9]{6}\n\n\n\nStep 1: Introduction to the Importance of Arts\nArts play a significant role in our lives by providing a means of self-expression, creativity, and cultural enrichment. They have the power to evoke emotions, inspire thoughts, and bring people together"
            },
            {
                "text": " ^[0-9]{6}$|^[0-9]{3}[0-9]{2}$\n\nExercise 2:\nMatch only uppercase English letters.\nAnswer: ^[A-Z]*$\n\nExercise 3:\nMatch only upperc"
            },
            {
                "text": " \"^[a-z][a-z]*[0-9][a-z]*$\"\n\n2. RegEx for Password Validation\nCreate a RegEx that validates passwords by meeting the following requirements:\n- The password must be at least 8 characters long.\n- The password must"
            },
            {
                "text": " The non-match examples should be generated automatically.\n\n5. Write a RegEx that matches any US state abbreviation in uppercase.\nAnswer: \\b[A-Z]{2}\\b\n\nLecture Note: 10.2.4 How to use the re.MULTIL"
            }
        ]
    },
    {
        "expression": "^((19[0-9][0-9])|(20[0-1][0-5]))\\-((0?[1-9])|(1[0-2]))\\-((0?[1-9])|([1-2][0-9])|(3[0-1]))$",
        "raw_prompt": "Year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits.",
        "refined_prompt": "Matches year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits.\nMatch examples:\n- \"2012-05-21\"\n- \"1960-12-14\"\n- \"1910-5-3\"\nNon-match examples:\n- \"2011/5/21\"\n- \"60-12-14\"",
        "matches": [
            "2012-05-21",
            "1960-12-14",
            "1910-5-3",
            "1924-02-18",
            "2010-06-31",
            "2013-5-12",
            "2004-12-14",
            "1940-10-31",
            "1911-09-31",
            "1915-12-01",
            "1940-7-31",
            "2003-05-17",
            "2005-11-28"
        ],
        "non_matches": [
            "2011/5/21",
            "60-12-14",
            "2021-5-3",
            "12/12/12",
            "12:12:12",
            "12:12:20",
            "12-12-2020",
            "noon",
            "03",
            "$45",
            "date",
            "5%"
        ],
        "id": 3349,
        "output": [
            {
                "text": " Use the ^ and $ delimiters and don't forget the slashes.\n\n## Exercise 3\n\nGenerate a regex string that would validate the following patterns:\n"
            },
            {
                "text": " Year can be 4-digit numbers.\n   1.\\d{4}|\\d{3}[-/]\\d{4}|\\d{"
            },
            {
                "text": "\n- \"1910-5-3\"\n- year: \\d{4}\n- month: \\d{2}\n- day: \\d{2"
            },
            {
                "text": "\n- Year starts from 1900 to 2015 and must be 4 digits.\n- Month starts from 0 to 12 and must have at least one digit.\n- Day starts from 0"
            },
            {
                "text": " (year)-(-|\\/)(month)-(-|\\/)(day)Generate a RegEx for this description.\n\n2) \"My email is m@gmail."
            },
            {
                "text": "\nYear: \\d{4}-\\d-\\d\nMonth: \\d{2}-\\d\nDay: \\d{2}\n\n###"
            },
            {
                "text": " \n(?<!^)(\\d{4}-\\d{2}-\\d{2}) year (?!\\d{3}) / (?!"
            },
            {
                "text": " \nYear-digit-digit-digit, dash, digit-digit-digit, dash, digit-digit-digit, dash, digit-digit-digit, dash,"
            },
            {
                "text": " ^([1-9][0-9]|1[0-2])-(\\d{1,2})-(\\d{1,2})$\n\n"
            },
            {
                "text": " \\d{4}-\\d{2}-\\d{2}\n\nExercise 2: Write a RegEx to match all dates in the following format:"
            }
        ]
    },
    {
        "expression": "^([A-Z]{1}\\w{1,3}) (\\d{1}[A-Z]{2})$",
        "raw_prompt": "simple validation of a UK postcode.\nExamples of valid:\nAA9A 9AA\nA9A 9AA\nA9 9AA\nA99 9AA\nAA9 9AA\nAA99 9AA",
        "refined_prompt": "Matches UK postcode.\r\nExamples of valid:\r\nAA9A 9AA\r\nA9A 9AA\r\nA9 9AA\r\nA99 9AA\r\nAA9 9AA\r\nAA99 9AA\nMatch examples:\n- \"EC1A 2BB\"\n- \"WyMM 8YE\"\n- \"IwSy 1KR\"\nNon-match examples:\n- \"111A 1BB\"\n- \"234567\"",
        "matches": [
            "EC1A 2BB",
            "WyMM 8YE",
            "IwSy 1KR",
            "NA1 3ZE",
            "WWiC 8TW",
            "QbM 4YE",
            "JF 5QO",
            "TCsL 1TU",
            "ET 6CY",
            "Nisg 1IY",
            "TZON 1VV",
            "A1 6QG",
            "DB 4AV"
        ],
        "non_matches": [
            "111A 1BB",
            "234567",
            "34rgtr",
            "plate",
            "u7tfgy",
            "f4ugh495",
            "IHUY78y34rhes",
            "4iueh&Y*f",
            "HHu8uUhu8",
            "fr245(*y",
            "UHU894fre",
            "HHHUH8989br"
        ],
        "id": 3368,
        "output": [
            {
                "text": " 1-9 characters, 1 uppercase, 1 digit,"
            },
            {
                "text": " \nAA9A 9A9  aa9a9"
            },
            {
                "text": "  [13]\\.?[A-W]\\d"
            },
            {
                "text": " ^(EC|Wy)[0-9] [0"
            },
            {
                "text": " (^[0-9A-Za-z ]"
            },
            {
                "text": " R\\d+(E[\\s\\d]*M"
            },
            {
                "text": " WyMM 8YY|EC1A 2BB|I"
            },
            {
                "text": " [^\\d]\\d+$\n\nA:"
            },
            {
                "text": " - /^\\d{1}\\s\\d{2"
            },
            {
                "text": " \"^\\d{1}\\s+[a-z"
            }
        ]
    },
    {
        "expression": "[0-9]{2}-?[DF][A-Z]{2}-?[0-9]{1}|[DF][A-Z]{1}-?[0-9]{3}-?[A-Z]{1}|[DF]-?[0-9]{3}-?[A-Z]{2}|[DF][A-Z]{2}-?[0-9]{2}-?[A-Z]{1}$",
        "raw_prompt": "Check for dutch moped licenseplate number validity",
        "refined_prompt": "Matches dutch moped license plate number validity\nMatch examples:\n- \"D-123-AS\"\n- \"D123AS\"\n- \"F-123-SA\"\nNon-match examples:\n- \"Others\"\n- \"moped\"",
        "matches": [
            "D-123-AS",
            "D123AS",
            "F-123-SA",
            "F123SA",
            "F534CM",
            "38FLF8",
            "D612UY",
            "FFN-27B",
            "71DBX8",
            "D-071ZK",
            "85-DLD-3",
            "DPP19-X",
            "F829VS"
        ],
        "non_matches": [
            "Others",
            "moped",
            "license plate",
            "34r5trf",
            "frgtyh645",
            "54vcv",
            "u878^&",
            "uyg^T",
            "UYGUGYY88hvgGGG",
            "HJgfyugt897tyg",
            "GYYgy87",
            "eufgduw"
        ],
        "id": 3380,
        "output": [
            {
                "text": " The answer will vary,\n    but it could look like this: \"^[A-Z]{3}\\D+[A-Z]{3}\\-\\d{2}\\D+[A-Z]{3}\\d{2}\\D+[A-"
            },
            {
                "text": " ([a-zA-Z-]+)[0-9]{3}([a-zA-Z]+)$\n\nExercise 2: RegEx for phone number format\nGenerate a RegEx for a phone number, including area code as well as the last"
            },
            {
                "text": " (Example) [0-9][A-Z]{2}-[0-9][A-Z][A-Z] \n\n2. Write a Python program that reads in a text file, generates a list of all email addresses found in the file, and writes the"
            },
            {
                "text": " [^\\d]{1}\\([^\\d]{3}\\)([^\\d]{3}$)\n\n3. Match this phone number: \"+1 (555) 123-4567 and 555-555-1234\"\nAnswer: \\+["
            },
            {
                "text": " \"^[a-zA-Z]{1}[a-zA-Z]{2}[a-zA-Z]{3}$\"\n\nI hope you learned something new about RegEx, specifically the RegEx module in Python. This powerful"
            },
            {
                "text": " \\d\\d\\d-\\d\\d[A-Z]\\d\n\nExercise 4:\nMatch this string:\n\n\"The quick brown fox jumps over the lazy dog.\"\n\nGenerate a RegEx for this string.\nAnswer: (\\b"
            },
            {
                "text": " d-^\\d{2}-a-^\\d{2}-s$\n\nExercise 2:\nFind all email addresses in a text file. \nAnswer:\nimport re\n\ntext = \"\"\"\nPlease include all emails in this text file.\n"
            },
            {
                "text": "\n\\d{3}[-\\s]\\d{3}[-\\s]\\d{2}[A-Za-z]{3}\n\n2. Write a RegEx for the following: \n- \"123 Main St. Anytown"
            },
            {
                "text": "\n/^[A-Z][a-z]\\d{1,2}\\-\\d{1,2}$/\n\nExercise 4: \nMatch a string that contains any sequence of any characters that is exactly 6 characters long.\nAnswer:\n/"
            },
            {
                "text": " r'^\\D*(D|F)0*[0-9]{5}(?:[0-9]{3}[0-9]{2})(?:[0-9]{2}_)?[0-9]{3}"
            }
        ]
    },
    {
        "expression": "\\(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\)",
        "raw_prompt": "This regex finds the IPs in its route. This uses the UNIX Bash 'traceroute' command's IP format",
        "refined_prompt": "Matches IPs addresses. This uses the UNIX Bash 'traceroute' command's IP format\nMatch examples:\n- \"(8.8.8.8)\"\n- \"(127.0.0.1)\"\n- \"(58.5.15.18)\"\nNon-match examples:\n- \"(a.sg.af.)\"\n- \"8.8.8.8\"",
        "matches": [
            "(8.8.8.8)",
            "(127.0.0.1)",
            "(58.5.15.18)",
            "(9.00.12.124)",
            "(4.2.247.877)",
            "(0.718.30.0)",
            "(1.554.02.841)",
            "(6.55.410.3)",
            "(558.08.9.53)",
            "(8.57.32.27)",
            "(21.4.43.8)",
            "(6.13.025.740)",
            "(65.0.574.1)"
        ],
        "non_matches": [
            "(a.sg.af.)",
            "8.8.8.8",
            "3245678",
            "(84)",
            ".34.34",
            "(.)",
            "IP",
            "LINUX",
            "56789.8765",
            "34.2324.",
            "31223.432.2343.4213.234.2342",
            "5443.354.35"
        ],
        "id": 3381,
        "output": [
            {
                "text": "\n\"([0-9]{1,3}\\.){3}[0-9]{1,3}\"\n\"\\.("
            },
            {
                "text": " \nNon-match examples:\n- \"(a.sg.af.)\"\n- \"(8.8.8.8)\"Generate"
            },
            {
                "text": " \"\\\\d{1,3}\\\\.(3|4|5|6|7|8|9|a|b|c|"
            },
            {
                "text": " [^[:space:]]([[:alpha:]][[:digit:]|[:alnum:]][[:digit:]|["
            },
            {
                "text": "\n^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,"
            },
            {
                "text": " [a-zA-Z0-9._-]{3}\\.[0-9]{1,3}\\.[0-9"
            },
            {
                "text": " The RegEx should be \"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]"
            },
            {
                "text": " (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o"
            },
            {
                "text": " \"^(([0-9]{1,3}\\.){3}[0-9]{1,3}|([0"
            },
            {
                "text": " (\\d+.\\d+.\\d+\\.\\d+\\.\\d+.\\d+)\n\n**Exercise 9:**\n"
            }
        ]
    },
    {
        "expression": "^([A-z]{2}\\d{7})|([A-z]{4}\\d{10})$",
        "raw_prompt": "UK Parcelforce delivery tracking code for internal UK posts. Comes in two formats 2 letters and 7 numbers (e.g. AA1234567) and 4 letters and 10 numbers (e.g. AAAA1234567890). Case insensitive.",
        "refined_prompt": "Matches UK Parcelforce delivery tracking code for internal UK posts. Comes in two formats 2 letters and 7 numbers (e.g. AA1234567) and 4 letters and 10 numbers (e.g. AAAA1234567890). Case insensitive.\nMatch examples:\n- \"AA1234567\"\n- \"AAAA1234567890\"\n- \"JY7712375\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "AA1234567",
            "AAAA1234567890",
            "JY7712375",
            "bJ8510300",
            "Rq2086860",
            "rFFH6577541147",
            "Hi2791279",
            "jMgi4477954860",
            "Wv3215163",
            "Hk2856684",
            "]CMU3926045687",
            "EJX]4546430558",
            "DsNm4593829026"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples",
            "hy7t663defc",
            "34f34ev",
            "435ygtr",
            "45gtrJIHUYGT",
            "efrwth54rwfd",
            "efnkjUYTvyuyg78",
            "erf8756bHGcfthu",
            "f4re^&ff",
            "$45"
        ],
        "id": 3383,
        "output": [
            {
                "text": " \"(^[A-Za-z]+$)|(^"
            },
            {
                "text": "\n(?i)([a-zA-Z0-"
            },
            {
                "text": " \\b(([A-Z]\\d{5,10"
            },
            {
                "text": " \n([a-z])$|^([a-z"
            },
            {
                "text": " \"^[A-Z][a-z]+[a-"
            },
            {
                "text": "\n(^| )(\\\\d{4})(\\\\d"
            },
            {
                "text": " \"(^[a-zA-Z]{4}\\s"
            },
            {
                "text": "\n\n\\d{4}[A-Z]\\d"
            },
            {
                "text": "\n\"[A-Z]{4}[a-z]"
            },
            {
                "text": "  ^[\\w\\s]+$\nExercise 3:"
            }
        ]
    },
    {
        "expression": "^([A-z]{2}\\d{9}[Gg][Bb])|(\\d{12})$",
        "raw_prompt": "UK Parcelforce delivery tracking code for international tracking of exports. Comes in two formats: 2 letters and 9 numbers and GB (e.g. AA123456789GB) and 12 numbers (e.g. 123456789012). Case insensitive.",
        "refined_prompt": "Matches UK Parcelforce delivery tracking code for international tracking of exports. Comes in two formats: 2 letters and 9 numbers and GB (e.g. AA123456789GB) and 12 numbers (e.g. 123456789012). Case insensitive.\nMatch examples:\n- \"AA123456789GB\"\n- \"123456789012\"\n- \"JW114554115GB\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "AA123456789GB",
            "123456789012",
            "JW114554115GB",
            "968624923500",
            "^L809816187gb",
            "947733690091",
            "R^768258000gb",
            "Fs317433507gb",
            "044702913182",
            "Ua243127568Gb",
            "578094898939",
            "155269098434",
            "tB011083276Gb"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples",
            "FTGVJHUHYG8y7t6rtyf",
            "32fewsc",
            "4fewdsc98yiuhk",
            "tguyhb3ewds",
            "njhuytt",
            "IUGYTRYDTFCGHV",
            "efdiwu&^Ttyftuyg",
            "f34ewds7t8yi",
            "hy7t66"
        ],
        "id": 3384,
        "output": [
            {
                "text": " non-[a-zA-Z"
            },
            {
                "text": " ^(?=.*[0-"
            },
            {
                "text": "\n\n```python\nimport re"
            },
            {
                "text": " \".*[^a-zA"
            },
            {
                "text": " [^a-zA-Z"
            },
            {
                "text": " r\"^(?!non|match"
            },
            {
                "text": " The output should be false. \n"
            },
            {
                "text": " This is a tricky one, but it"
            },
            {
                "text": " ^[A-Za-z"
            },
            {
                "text": "\n^(?!.*[^a"
            }
        ]
    },
    {
        "expression": "^[A-z]{2}\\d{9}(?![Gg][Bb])[A-z]{2}$",
        "raw_prompt": "UK Parcelforce delivery tracking code for international tracking of imports. Uses a negative look ahead to prevent it ending in GB which would be an international export code.",
        "refined_prompt": "Matches UK Parcel force delivery tracking code for international tracking of imports. Uses a negative look ahead to prevent it from ending in GB which would be an international export code.\nMatch examples:\n- \"AA123456789AA\"\n- \"`s222501350jn\"\n- \"YK497549717Tf\"\nNon-match examples:\n- \"AA123456789GB\"\n- \"AA123456789gb\"",
        "matches": [
            "AA123456789AA",
            "`s222501350jn",
            "YK497549717Tf",
            "]a850402060mL",
            "Pl836064353gi",
            "KN398950160cM",
            "tk755131768JN",
            "Cy415708352PT",
            "H\\495029367rN",
            "o]014906363bV",
            "Z\\018566877sX",
            "ZE350488757z\\",
            "hl632529674Lu"
        ],
        "non_matches": [
            "AA123456789GB",
            "AA123456789gb",
            "AA123456789Gb",
            "AA123456789gB",
            "43fec8d7uhjb",
            "r13f4reds",
            "iu89y7t6rytfg",
            "efi23fuh34rf",
            "34fre4freoUIGI",
            "FTGVJHUHYG8y7t6rtyf",
            "#",
            "$456789"
        ],
        "id": 3385,
        "output": [
            {
                "text": " \n^(?!GB$)(?!GB)(?!GB)[^GB"
            },
            {
                "text": " (?<!GB)^[a-z0-9]{"
            },
            {
                "text": " (\\G(?=[^\\G]*GB))(?P"
            },
            {
                "text": "\n^[\\w\\s-]{16}(\\d{14"
            },
            {
                "text": " (?<=^[^a-zA-Z0-9"
            },
            {
                "text": "\n(?<![0-9])([a-zA"
            },
            {
                "text": "\n[a-zA-Z]{3}[a-z"
            },
            {
                "text": "?P<country>[A-Z]{1,2}[A"
            },
            {
                "text": " ^[^\\S]([A-Z]{2}\\D){"
            },
            {
                "text": " `[^b]*[a-z]`\n\n3."
            }
        ]
    },
    {
        "expression": "^(?:[A-z]{2})?\\d{9}(?:[A-z]{2})?$",
        "raw_prompt": "TNT UK delivery company consignment number tracking code for TNT Track and Trace service. The system will use the 9 digit code (e.g. 123456789) or you can use the letters as shown on your consignment note (e.g. GE123456781WW). Case insensitive.",
        "refined_prompt": "Matches TNT UK delivery company consignment number tracking code for TNT Track and Trace service. The system will use the 9 digit code (e.g. 123456789) or you can use the letters as shown on your consignment note (e.g. GE123456781WW). Case insensitive.\nMatch examples:\n- \"123456789\"\n- \"GE123456781WW\"\n- \"729600602Ey\"\nNon-match examples:\n- \"non\"\n- \"matching\"",
        "matches": [
            "123456789",
            "GE123456781WW",
            "729600602Ey",
            "931409146",
            "zK253794572]d",
            "042064816^b",
            "611846132",
            "si063107134",
            "\\x203621404OT",
            "EL520652755",
            "TY504476227",
            "nc503210123",
            "893936606QU"
        ],
        "non_matches": [
            "non",
            "matching",
            "examples",
            "3283.312.",
            "tracking",
            "314567ytgrfe",
            "34fews",
            "34565trefdef",
            "jhg543we",
            "341fq4ewr",
            "54wrgrf",
            "43fec8d7uhjb"
        ],
        "id": 3387,
        "output": [
            {
                "text": " non-matching"
            },
            {
                "text": ".\\d\\"
            },
            {
                "text": " \"(^|["
            },
            {
                "text": " The non-match"
            },
            {
                "text": " (this requires some"
            },
            {
                "text": " \"^(?!"
            },
            {
                "text": " (Any RegEx"
            },
            {
                "text": " match:.*["
            },
            {
                "text": "\n\nExercise"
            },
            {
                "text": " \n- \""
            }
        ]
    },
    {
        "expression": "^\\d{4}\\/\\d{1,2}\\/\\d{1,2}$",
        "raw_prompt": "This regular expressions matches jalali dates of the form YYYY/XX/XX where XX can be 1 or 2 digits long and YYYY is always 4 digits long.",
        "refined_prompt": "This regular expressions matches jalali dates of the form YYYY/XX/XX where XX can be 1 or 2 digits long and YYYY is always 4 digits long.\nMatch examples:\n- \"1394/01/3\"\n- \"1365/12/31\"\n- \"1397/02/01\"\nNon-match examples:\n- \"1394/1/555\"\n- \"139/1/4\"",
        "matches": [
            "1394/01/3",
            "1365/12/31",
            "1397/02/01",
            "2586/9/66",
            "6350/9/12",
            "9325/1/98",
            "1077/7/67",
            "7807/9/57",
            "9125/35/4",
            "2109/6/23",
            "6564/9/81",
            "2702/9/04",
            "6610/1/7"
        ],
        "non_matches": [
            "1394/1/555",
            "139/1/4",
            "1/11/1394",
            "1234567",
            "date",
            "12-12-12",
            "12 12 12",
            "3 3 30",
            "09 09 09 09",
            "3245678",
            "12",
            "$45"
        ],
        "id": 3394,
        "output": [
            {
                "text": "\n[0-9]{4}/[1-9][0-9]"
            },
            {
                "text": "\n(?:^|[^0-9])([0-9]{4"
            },
            {
                "text": " ^(0-9)\\/(0-9)\\/(0-9)$"
            },
            {
                "text": " \n[0-9]{4}-[1-9][0-9]"
            },
            {
                "text": " \n^(?:(?=\\d{4})(?:\\d{2"
            },
            {
                "text": " ([0-9]+.[0-9]{1,2}|[0-"
            },
            {
                "text": "\n(0?[1-9]|[12][0-9]|3"
            },
            {
                "text": " A regular expression for this description is of the form YYYY/[0-9]"
            },
            {
                "text": " jalali_date_regex = \"(?P<year>\\d{4"
            },
            {
                "text": "\n    (?P<month>\\d{2})/(?P<day"
            }
        ]
    },
    {
        "expression": "[0-9]{4}[/.-](?:1[0-2]|0?[1-9])[/.-](?:3[01]|[12][0-9]|0?[1-9])",
        "raw_prompt": "Date Year-Month-Day. From http://tools.twainscanning.com/getmyregex",
        "refined_prompt": "Matches date in form Year-Month-Day\nMatch examples:\n- \"2015-08-31\"\n- \"0132/10/12\"\n- \"9345.12.31\"\nNon-match examples:\n- \"31/08/2015\"\n- \"date\"",
        "matches": [
            "2015-08-31",
            "0132/10/12",
            "9345.12.31",
            "5660-11/27",
            "5881-08-2",
            "4286-12/31",
            "1724-1.30",
            "5107/9-30",
            "3508-08-28",
            "3245.8-04",
            "6988.01/18",
            "4625/12.9",
            "9173/11-11"
        ],
        "non_matches": [
            "31/08/2015",
            "date",
            "jan 5th",
            "3rd of jun",
            "aug 6 2008",
            "121212",
            "12 12 12",
            "12 12 1212",
            "1212121212",
            "liu87y6tyg",
            "jehfef",
            "328472398472934"
        ],
        "id": 3417,
        "output": [
            {
                "text": " /^\\d{4}-\\d{2}-\\d{2}$/\n\nExercise 2: Create a RegEx for a password that must be at least 8 characters long, contain at least one uppercase letter,"
            },
            {
                "text": "\n[0-9]{4}-[0-9]{2}-[0-9]{2}\n\n3. Write a RegEx for \"A number followed by a period, followed by a letter, followed by another number\"."
            },
            {
                "text": "\n\n```python\nimport re\n\ndef validate_date(text):\n    mydate = re.search(\"(\\d{4}-\\d{2}-\\d{2})\", text)\n    if mydate:"
            },
            {
                "text": " \nRegex: (\\d{4})-(\\d{2})-(\\d{2})\n\nExercise #3:\n- \"2022-03-14\"\nMatch examples:\n- \"2022-03-"
            },
            {
                "text": " [a-zA-Z0-9]{4}-[0-9]{2}-[0-9]{2} \n- \"date\"Match this date format: 2015-08-31.\nAnswer: [a"
            },
            {
                "text": " \"(\\d{4})-(\\d{2})-(\\d{2})\".\n\n3. Use RegEx to find all email addresses in a string.\n```python\nimport re\n\n# Define a string with email addresses"
            },
            {
                "text": " \\d{4}(?:-\\d{2})?(?:-\\d{2})?(?:-\\d{2})\n\nExercise 2:\nMatch date in form Month-Day-Year\nMatch examples:\n"
            },
            {
                "text": " [^a-zA-Z]|(\\d{4})-(\\d{2})-(\\d{2})$\n\nExercise 2:\n- \"a string here\" match \"here\"\nMatch examples:\n- \""
            },
            {
                "text": " (\\d{2})/(\\d{2})/(\\d{4})\n- \"2015-08-31T12:34:56\"Generate a RegEx for this description.\n\nExercise 3:\n- Explain the"
            },
            {
                "text": "\n\nimport re\n\npattern = r\"\"\"(?x)\n    (?:\n        (?P<year>\\d{4})-?(?P<month>\\d{2})\n        (?:\\s|$"
            }
        ]
    },
    {
        "expression": "(facebook|twitter|youtube)",
        "raw_prompt": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "Matches facebook, twitter, or youtube\nMatch examples:\n- \"facebook\"\n- \"twitter\"\n- \"youtube\"\nNon-match examples:\n- \"imgur\"\n- \"3e456yhtbgf\"",
        "matches": [
            "facebook",
            "twitter",
            "youtube"
        ],
        "non_matches": [
            "imgur",
            "3e456yhtbgf",
            "eqf45gtrvfd",
            "4rfgvwre",
            "snapchat",
            "43fred",
            "X",
            "g54red",
            "qrg4ruyn",
            "social media",
            "google",
            "w4jrgrd"
        ],
        "id": 3420,
        "output": [
            {
                "text": " Match examples: *(facebook | twitter | youtube)* Non-match examples: *(imgur | 3e456yhtbgf)*\n\n3. RegEx Password Checker:\nWrite a Python program that checks whether a given password meets the following criteria: \n- At least 8 characters long\n- Contains at"
            },
            {
                "text": " [^a-z\\d]+(?:\\.\\w+)?\n- \"h-m-d-t\"Generate a RegEx for this description.\nAnswer:?\\d{1,2}(?:[-\\s]?[0-9]{2})?[-"
            },
            {
                "text": " \"([A-Za-z0-9.-_]+@[A-Za-z0-9.-_]+\\.[A-Za-z]{2,6})\". \n\n2. Find the email address and phone number in the following text:\n\"My email is john"
            },
            {
                "text": " The regex should be \"^[A-Za-z0-9]+$\" because it allows only letters, numbers, and underscores.\n3. Write a Python program that takes a string as input and returns only the vowels.\nExample:\nInput: \"hello there\"\nOutput:aeiou"
            },
            {
                "text": " \"(?i)(http://|https://)[a-z0-9.]+[a-z]+(?i)[a-z0-9.]+[a-z]*(?i)[a-z0-9.]+[a-z]*\"\n\nExercise 2:"
            },
            {
                "text": "\n[a-z]{2,15}[-\\w\\.]{1,5} [a-z]{3}\n\nNow that you're familiar with RegEx, it's time to apply them in your daily life. For example, you can use RegEx to organize your emails, detect"
            },
            {
                "text": " \"^.+/[a-zA-Z0-9._-]+$\"\n\n2. Write a RegEx pattern that matches any string that starts with \"h\" and ends with \"e\". \nAnswer: \"^h[a-zA-Z]*e$\"\n\n"
            },
            {
                "text": " [\\w]+\\s\\w+\\s\n\nExercise 2: \nReplace all instances of [a-zA-Z] with a _.\nMatch examples:\n- \"Hello world\"\n- \"My name is Alice\"\nNon-match examples:\n- \"12345\""
            },
            {
                "text": " '^(https?:\\/\\/)?(www\\.)?([a-zA-Z0-9]+\\.)[a-z]+[a-z0-9]{2,3}$'\n\n2. Using lists, count how many words in the following sentence contain the letter \""
            },
            {
                "text": " (This answer is not provided due to the exercise's open-ended nature.)\n\nExercise 3:\nMatch the following common phrases to their respective social media platforms:\n- \"check out my new car\"\n- \"like my post\"\n- \"join my group\"\nAnswer:\n- \"new car"
            }
        ]
    },
    {
        "expression": "((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])",
        "raw_prompt": "IP address IPv4 (127.0.0.1) . From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "Match IP address IPv4 (127.0.0.1)\nMatch examples:\n- \"127.0.0.1\"\n- \"250.136.255.92\"\n- \"253.5.255.111\"\nNon-match examples:\n- \"127-0-0-1\"\n- \"IP\"",
        "matches": [
            "127.0.0.1",
            "250.136.255.92",
            "253.5.255.111",
            "7.250.223.5",
            "170.2.9.252",
            "250.97.253.53",
            "255.253.218.19",
            "254.251.251.250",
            "39.194.7.255",
            "226.253.251.250",
            "255.254.0.251",
            "1.2.5.251",
            "250.255.251.252"
        ],
        "non_matches": [
            "127-0-0-1",
            "IP",
            "231/12312/123",
            "5432",
            "31245678",
            "juytfvghbi87",
            "g8g",
            "3i4u984",
            "##34",
            "##########",
            "op98yttygbh",
            "elcdoh"
        ],
        "id": 3425,
        "output": [
            {
                "text": " /^\\A[^\\s]*?(?P<IP>\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3}"
            },
            {
                "text": "\n(^|\\s)([\\d\\.]+-){3}\\1$|^|\\s([\\d\\.]+)-([\\d\\.]+)-([\\d\\"
            },
            {
                "text": " (127-0-0-1)\n\nExercise 2: \nMatch IP address IPv4 (192.168.0.1)\nMatch examples:\n- \"192.168."
            },
            {
                "text": " r'^((\\d{1,3}\\.){3})([0-9]{1,3})(\\.){3}[0-9]{1,3}"
            },
            {
                "text": " \n\n#import the re module\nimport re\n\nip_pattern = re.compile(\"^[0-9]{1,3}\\.[0-9]{1,3"
            },
            {
                "text": " IPAddress (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\n\n[Host 2]: \"Great"
            },
            {
                "text": " ^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$\n\n\n\nQuestion 10: The ratio"
            },
            {
                "text": " [a-zA-Z0-9\\-\\.]+\n\n\n\nQuestion 5: Jack wants to buy a laptop that is on sale for 20% off. The original price of the laptop"
            },
            {
                "text": " (\\d\\.\\d\\.\\d\\.\\d\\|\\d\\|\\d\\|\\d\\|\\d\\|\\d\\|\\d\\|\\d|\\"
            },
            {
                "text": " \"^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}"
            }
        ]
    },
    {
        "expression": "(?:2[0-3]|[01]?[0-9])[:.][0-5]?[0-9]",
        "raw_prompt": "Time HH:MM (23:30). From http://tools.twainscanning.com/getmyregex .",
        "refined_prompt": "Matches time in format HH:MM (23:30)\nMatch examples:\n- \"23:30\"\n- \"23.30\"\n- \"20.7\"\nNon-match examples:\n- \"23-30\"\n- \"time\"",
        "matches": [
            "23:30",
            "23.30",
            "20.7",
            "23.6",
            "20:0",
            "22.23",
            "23:0",
            "22:08",
            "20:00",
            "06.5",
            "21:47",
            "8.1",
            "14:1"
        ],
        "non_matches": [
            "23-30",
            "time",
            "12/12",
            "11 11",
            "3498765",
            "noon",
            "monday",
            "1 pm",
            "32434322",
            "2312",
            "43434",
            "234565432"
        ],
        "id": 3427,
        "output": [
            {
                "text": "\n\nI can't really think of anything that I've seen or read that would work for that.\n\nExercise 4:\n\nModify the RegEx generated in Exercise 3 to be case-insensitive.\n\nQuestion: Write a Python program to validate a date in MM"
            },
            {
                "text": " (\\d{1,2}):(\\d{1,2})[.](\\d{2})\n- \"22.5-36\"\n- \"22.5-36:00\"\n- \"20-30\"\nI hope this section has helped you"
            },
            {
                "text": " This pattern matches any time in the format HH:MM, no matter what time zone the user is.\n\n\n# Chapter: The Use of Python Modules for Sports Analyst\n\n## Sections:\n1. Introduction to Python modules for sports analysis\n2. Importing and using modules"
            },
            {
                "text": " [0-9]{1,2}:[0-9]{2}\n\n#### Exercise 2: \nUse `re.split` to split a string into words based on the following rules:\n- A word can be made up of letters and numbers only.\n"
            },
            {
                "text": " (?<!\\d)00\\d|(?!\\d)0(?!\\d)\n\nExercise 3: \nMatch a string containing a mix of numbers and letters (e.g. \"123abc\").\nGenerate a RegEx for this description."
            },
            {
                "text": " (example) [\\d]+(?:\\.[\\d]+)?(?:[a-z]|(?:am|pm))\n- \"5pm\"Generate a RegEx for this description.\nAnswer: ([\\d]+(?:\\.[\\d]"
            },
            {
                "text": " ^\\d{2}\\.\\d{2}$\n\n3. Write a Python code that retrieves the title of a book from the 'book.html' HTML page and uses the RegEx from Exercise 2 to extract the time from each book's page.\n\nH"
            },
            {
                "text": "\n'[0-9]{1,2}:[0-9]{2}'\n\n\n3. Using RegEx, extract and print every fourth word from the following sentence:\n\"The quick brown fox jumped over the lazy dog.\"\n\nAnswer:\nThe quick"
            },
            {
                "text": " /^(?:[0-9]{1,2}[ ])?[0-9]{1,2}:[0-9]{2}(?:\\.[0-9]{1,2})?$/i\n\nExercise 2: Match"
            },
            {
                "text": " [^(0-9)]{1}[0-9](?:-[0-9]{1})?[0-9]\n\n3. Given the following string: $12345-12:34-56.78\nWrite a Python program that will extract"
            }
        ]
    },
    {
        "expression": "[0-9]{5}\\s?[0-9]{5}",
        "raw_prompt": "Basic UTR and CRT formats, 10 digits however are often written with an optional space after 1st 5",
        "refined_prompt": "Matches basic UTR and CRT formats, 10 digits however are often written with an optional space after 1st 5\nMatch examples:\n- \"1234567890\"\n- \"12345 67890\"\n- \"14980\u200916473\"\nNon-match examples:\n- \"123 4567890\"\n- \"A123456789\"",
        "matches": [
            "1234567890",
            "12345 67890",
            "14980\u200916473",
            "70356\u200933356",
            "7045456535",
            "6505015311",
            "2297102022",
            "4941497592",
            "66120\f53700",
            "1614435240",
            "8589244725",
            "4414717487",
            "9257801789"
        ],
        "non_matches": [
            "123 4567890",
            "A123456789",
            "2345",
            "efr54rfe",
            "34fdf",
            ".file",
            "3455%",
            "34RTRFVD",
            "3EW",
            "fredc",
            "EFGRED",
            "ER5TRGY"
        ],
        "id": 3448,
        "output": [
            {
                "text": " [a-zA-Z0-9]{5,15}\n\n3. Write a regular expression that matches decimal numbers separated by a comma or hyphen.\n"
            },
            {
                "text": " \n([0-9]{5} )(.[0-9]{4})? \n3. Write a Python program that uses the findall method to find"
            },
            {
                "text": "^[a-zA-z0-9]{5}(?:\\s[a-zA-z0-9]{5})+$\n\n"
            },
            {
                "text": "\nThis is a string containing text and numbers.\n\nI'm working on a problem on how to create a regex that would match any string where there are only numbers and no other"
            },
            {
                "text": "\n^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=\\S.{10})(?!"
            },
            {
                "text": " \"^[A-Za-z0-9]{0,5} [A-Za-z0-9]{0,5}[0-"
            },
            {
                "text": " ^\\d{6} \\d{5}$\n\nI have two questions regarding the RegEx you have created: \n\nWhy is the space needed after the 1"
            },
            {
                "text": " (\\w{5} ){1} \n\n9. Match a string that begins with \"ABBA\" and ends with \"BAA\"\nAnswer: (AB"
            },
            {
                "text": "\nhttps://regex101.com/r/nV5t8T/1\n\nA:\n\nI would use something like:\n^\\d{6"
            },
            {
                "text": "\n[\\d ]{6}[\\d ]{4}[\\d ]{4}[\\d ]{4}[\\d ]{10}\n"
            }
        ]
    },
    {
        "expression": "^([1-9]|1[0-2])$",
        "raw_prompt": "Simple check for a value between 1 and 12",
        "refined_prompt": "Simple check for a value between 1 and 12\nMatch examples:\n- \"1\"\n- \"2\"\n- \"12\"\nNon-match examples:\n- \"-1\"\n- \"13\"",
        "matches": [
            "1",
            "2",
            "12",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11"
        ],
        "non_matches": [
            "-1",
            "13",
            "A1",
            "14",
            "-12",
            "2345",
            "44",
            "23",
            "12.22",
            "235340",
            "493",
            "1,000"
        ],
        "id": 3454,
        "output": [
            {
                "text": " -1, 13\n\nExercise 4:\nMatch the following descriptions with the correct RegEx terms:\n- Uses \".\" to match any character\n- Uses \"*\" to match zero or more of the previous element\n- Uses \"\\d\" to match any digit\n\nExercise 5:\nWrite a regular expression for the following description"
            },
            {
                "text": "\n^(1[0-2]|12)$\n\n3. Exercise: Rewrite the following RegEx to only match email addresses: \n^[A-Za-z0-9._-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{"
            },
            {
                "text": " /^[1-3][0-9][0-9]\\z/\n\n4. Write a function that takes an email address as input and deletes it from the database if it is found.\n\n```python\ndef delete_emails(email):\n    # Connect to the database\n    connection = sqlite"
            },
            {
                "text": " r\"^\\-?[1-9][0-9]*$\"\n\nExercise 3: Write a Python function that takes in a string and uses the re.sub() function to replace any matching sub-patterns with a desired replacement string.\nAnswer: \nimport re\n\ndef replace_pattern(string,"
            },
            {
                "text": " [A-Za-z1-9]+\n\nExercise 2:\nCreate a RegEx pattern that matches any word that begins with \"a\" and has more than two letters after the first letter.\n\nAnswer: [a-zA-Z][a-zA-Z0-9]{3,}\n"
            },
            {
                "text": " ^[1-12]$\n\nExercise 2: Match examples\n\nMatch the following examples with the correct category:\n1. \"10\" - Match examples:\n2. \"11\" - No match examples:\n3. \"12\" - No match examples:\n\nAnswer:\n1. \"10\" - Match examples"
            },
            {
                "text": "\n[1-12]\n\n2. Create a Python function that takes an email address as input, counts the number of characters in the username and domain name, and returns the result as a string.\n\nSolution:\ndef email_analysis(email):\n    username = email[:email.index('@')]\n    domain"
            },
            {
                "text": " The pattern would be \"\\b(?=[a-zA-Z]{3})(?=\\d{3})\\d{3}\\b\".\n\nExercise 2: \nGenerate a RegEx for this description.\nA password must be at least 6 characters long, must include at least one uppercase letter"
            },
            {
                "text": " ^[1-12]$|^[13]$\n\nExercise 4: \nCreate a regular expression that matches all words that start and end with the letter 't'. \nAnswer: ^t.*t$|^.*^$|^.*$\n\nExercise 5: \nCreate a regular expression that matches"
            },
            {
                "text": " ^[1-12]$\n\nExercise 3:\nWhich would be the most appropriate character class to match the word \"cat\" or \"dog\"?\na) [a-z]\nb) [a-z]0-9\nc) [a-z0-9]\n\nAnswer: c) [a"
            }
        ]
    },
    {
        "expression": "^(?=.*[1-9].*)[0-9]{3}$",
        "raw_prompt": "3 digit number representing an HMRC Tax Office. Office 000 is not valid",
        "refined_prompt": "Matches 3 digit number representing an HMRC Tax Office. Office 000 is not valid\nMatch examples:\n- \"001\"\n- \"123\"\n- \"940\"\nNon-match examples:\n- \"-01\"\n- \"000\"",
        "matches": [
            "001",
            "123",
            "940",
            "675",
            "518",
            "408",
            "695",
            "515",
            "026",
            "432",
            "225",
            "346",
            "757"
        ],
        "non_matches": [
            "-01",
            "000",
            "90.1",
            "742305",
            "148179",
            "748684",
            "367425",
            "3269",
            "2595",
            "2839",
            "700250579",
            "820281690"
        ],
        "id": 3457,
        "output": [
            {
                "text": " \n[A-Z]{4}[0-9]{3}\n\nExercise 2: \nMatch the following phrases to their respective meanings.\n1. Silly\n2. Regret\n3. Regard\n\nAnswer:\n1. Silly - Lacking seriousness"
            },
            {
                "text": " (?i)\\d{3}-\\d{2}-\\d{2}\n\nExercise 3: Valid URL\nQuestion: Create a RegEx that checks if a given URL ends with \".com\" or \".net\".\nAnswer: (?i)(?:https?://)?("
            },
            {
                "text": " A RegEx for this description is ^(?=^\\d{3})[0-9]{2}[0-9]{3}$\n\n---\n\n3. Write a function that takes a list of tax numbers as input and returns the number of valid HMRC Tax Office"
            },
            {
                "text": " [Your answer]\nExercise 2:\nWrite a Python program to extract phone numbers from a provided text string. Use RegEx to match phone numbers in the following formats: \"(XXX) XXX-XXXX\", \"123-456-7890\", or \"555 555-5555\".\nAnswer: ["
            },
            {
                "text": "\n(?=^[0-9]{3}$)(?:[0-9]{3}(?!\\s)|[0-9]{2}[0-9]{3}(?!\\s)|[0-9]{4}[0-9]"
            },
            {
                "text": "\n^([1-9]|[1-9][0-9])[-0-9]*\n\nExercise 3: \nMatch the list of options to the correct category:\n- A. Red Traffic Lights\n- B. Green Traffic Lights\n- C. Yellow Traffic Lights"
            },
            {
                "text": "\nRegEx:.*[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].*\nDescription: A valid UK P"
            },
            {
                "text": "\n[0-9]{1,3}[0-9]{3,9}[0-9]{3,}[0-9]{3}\n\nUse Case 3: Email Address Validation\n\nScenario: You're a business owner who wants to ensure that"
            },
            {
                "text": " (.{3})\n\nExercise 6: Create a RegEx for this description: The number should contain five or more digits and should be followed by either the word \"tax\" or the word \"fees\".\nAnswer: (?=.{5,})(?=tax|fees)"
            },
            {
                "text": "\nRegex that validates a 4 digit number with the prefix \"HMRC's\" is^(?:\\d{3}-\\d{3}(?:\\d{3}-\\d{2}(?:\\d{2}-\\d{1}))?)$\n"
            }
        ]
    },
    {
        "expression": "^(GB)?([0-9]{9})$",
        "raw_prompt": "If you dont need to validate anything other than UK Numbers then this is for you, with optional GB at the start. If you need other countries then the EU Pattern is better suited",
        "refined_prompt": "Matches UK Numbers, with optional GB at the start.\nMatch examples:\n- \"GB123456789\"\n- \"123456789\"\n- \"GB604774876\"\nNon-match examples:\n- \"GB12345678\"\n- \"AA123456789\"",
        "matches": [
            "GB123456789",
            "123456789",
            "GB604774876",
            "GB377715572",
            "GB306556503",
            "410056552",
            "934546885",
            "539884648",
            "004466730",
            "070159455",
            "GB957511261",
            "GB957511261",
            "GB820935266"
        ],
        "non_matches": [
            "GB12345678",
            "AA123456789",
            "1234567",
            "GB0",
            "GB7",
            "GB5",
            "fghtgr",
            "435tgrfvd",
            "ertrgefw",
            "JHGYTF",
            "aTF%Ffy",
            "43fre"
        ],
        "id": 3459,
        "output": [
            {
                "text": " ^[A-Z]?[a-z]?\\d\\d?[A-Z]?[a-z]$\n\nExercise 5:\nMatch UK Phone Numbers, with optional GB at the start.\n"
            },
            {
                "text": "\n\\d{1,3}[G|B]\\d{1,8}\\d{1,4}\n\n4. Use the findall() function to return all the matches from a string.\n    - Example:"
            },
            {
                "text": "\n- GB123456789(\\d+)(\\d)\n\nExercise 2:\n- Write a RegEx to match string that starts with 'A' and ends with 'Z' and has at least one character before and one"
            },
            {
                "text": " \n(?<!GB)(?<!A)(?<!AA)(?<!123)(?<!456)(?<!789)(?<!80)(?<!901)(?<!987)(?<"
            },
            {
                "text": " [GB]?[0-9][0-9]*\n\nExercise 3:\nCreate a Python function that takes in a list of strings and returns only the strings that match a given RegEx.\n\nExample code:\n"
            },
            {
                "text": " [A-Za-z]+\\d+ [GB][0-9] (optional)\nExercise 2. Match a string with two numbers in it.\nMatch example: \n- \"AB1234\"\n- \""
            },
            {
                "text": " (\\d+) or (\\d*)\\D{0,6}\n\nExercise 2:\nHow to use backreferences in a RegEx? Provide an example of how to use this to extract all the date formats using a"
            },
            {
                "text": " \n\n```python\nimport re\ns = \"AA123456789\"\n# match GB (1, 4, 7, 8) for first three characters.\nmatch = re.match(r'^GB.*',"
            },
            {
                "text": " ^[a-zA-Z]{3}\\d{9}$\n\nIn conclusion, regular expressions are a powerful tool for matching patterns in strings, and they can be used to match UK numbers with optional GB at the start of"
            },
            {
                "text": " GB[0-9]+\n\nExercise 2: Using the RegEx you generated above, find all the non-match examples in the string \"GB123456789\".\nSolution:\nimport re\nreg_ex = \"GB"
            }
        ]
    },
    {
        "expression": "^[0-9]{8}R[A-HJ-NP-TV-Z]$",
        "raw_prompt": "Pension Schemes have their own references, 8 digits followed by R and then another letter.",
        "refined_prompt": "Matches Pension Schemes with 8 digits followed by R and then another letter.\nMatch examples:\n- \"12345678RA\"\n- \"43213245RT\"\n- \"83536006RP\"\nNon-match examples:\n- \"1234567RA\"\n- \"432132456RR\"",
        "matches": [
            "12345678RA",
            "43213245RT",
            "83536006RP",
            "09187372RA",
            "82927952RN",
            "06159369RM",
            "62722611RD",
            "05680285RH",
            "97060368RL",
            "65424962RR",
            "90220825RL",
            "43371559RT",
            "67100732RY"
        ],
        "non_matches": [
            "1234567RA",
            "432132456RR",
            "23657005*V",
            "54102433!J",
            "56423464JG",
            "14301651ET",
            "79870307vG",
            "74051292DW",
            "53918747;Q",
            "18732502\\B",
            "59288318HP",
            "52153646mD"
        ],
        "id": 3460,
        "output": [
            {
                "text": "\nimport re\npattern = r'\\d{8}(R[a-zA-Z])'\nstring = \"12345678RA\"\nmatch_result = re.match(pattern, string)"
            },
            {
                "text": " ^[0-9]{8}[A-Z]$\n\nExercise 3:\nMatch the following strings using regular expressions:\n- \"This is a test\"\n- \"This is not a test"
            },
            {
                "text": " ^\\d{8}[A-Z]$\n\nExercise 2:\nCreate a RegEx to match a password that has 1 lowercase letter, 1 uppercase letter, and 1 number.\nAnswer"
            },
            {
                "text": " [^A-Za-z0-9]{8}[A-Za-z]\n\nExercise 4: Password Verification\nGenerate a RegEx for this password requirement:\n- At"
            },
            {
                "text": " \\d{8}(?:\\D|$))\n\nExercise: In a game, you need to make sure that the user inputs a 4 digit number followed by 2 letters followed by a 4 digit number. Write"
            },
            {
                "text": " \nThis is a RegEx for a RegExp that matches a RegExp with 8 digits followed by a letter and then another letter.\n\nExercise 3:\nWrite a regular expression that matches all dates in the format"
            },
            {
                "text": " \"^[a-zA-Z]{3}[a-zA-Z]{3}[a-zA-Z].{3}$\"\n\n### Exercise 5: \nGiven"
            },
            {
                "text": " /^(?=.*[A-Z])(?=.*[0-9R])[A-Z0-9R]{8}$/g\n\n2. Write a Python program that scans"
            },
            {
                "text": "\n(?=[^A-Z]*[A-Z])[A-Z]{8}[a-z]\nExercise 4: \nWrite a RegEx to match a phone number in the"
            },
            {
                "text": " ([1-9][1-9]|[1-9][0-9]|[0-9])[A-Z]{4}\n\nExercise 4: \nWrite a Python function that"
            }
        ]
    },
    {
        "expression": "^(A[A-HJ-M]|[BR][A-Y]|C[A-HJ-PR-V]|[EMOV][A-Y]|G[A-HJ-O]|[DFHKLPSWY][A-HJ-PR-Y]|MAN|N[A-EGHJ-PR-Y]|X[A-F]|)(0[02-9]|[1-9][0-9])[A-HJ-P-R-Z]{3}$",
        "raw_prompt": "Current standard UK Registration plates running from Sept 2001 to Feb 2051, basic form AA99AAA but contains prefix combinations, the only number not used is 01",
        "refined_prompt": "Matches standard UK Registration plates running from Sept 2001 to Feb 2051, basic form AA99AAA but contains prefix combinations, the only number not used is 01\nMatch examples:\n- \"NE02ABC\"\n- \"AA58DEF\"\n- \"CH08NDO\"\nNon-match examples:\n- \"NF02ABC\"\n- \"AA01WUX\"",
        "matches": [
            "NE02ABC",
            "AA58DEF",
            "CH08NDO",
            "GL05KLZ",
            "02RJA",
            "GC24OTS",
            "03JEG",
            "BE00EHK",
            "07-UT",
            "MAN04AVY",
            "NB60ZUA",
            "CM87XTT",
            "BA05CKX"
        ],
        "non_matches": [
            "NF02ABC",
            "AA01WUX",
            "werty",
            "2345678",
            "ID",
            "huy76t5rt",
            "DDDjjjj",
            "UHDIhIhef",
            "JIDHIEUH*(8d",
            "jndekUHIb",
            "dejwnsU",
            "#####"
        ],
        "id": 3467,
        "output": [
            {
                "text": " ^[^-]*-[^-]*-[^-]*-[^-]*-[^-]*-[^-]*$\n\nExercise"
            },
            {
                "text": " \n[A-AB][0-9][0-9]\n\nA:\n\nI think the easiest thing here is to start with the simplest regular expression,"
            },
            {
                "text": " NF02[A-Z][0-9]{2}\n- \"NF01A\"Generate a RegEx for this description. \nAnswer: NF["
            },
            {
                "text": " Regex: (?<prefix>\\w)(?!\\d)(?<number>\\d)(?<letter>[a-zA-Z]{1}"
            },
            {
                "text": " I would need to take the letter of the next digit and then use this to create a RegEx for the following pattern.\n\n([A-Z][0-9]["
            },
            {
                "text": "\n^(?:(?:\\d{3,6})(?:\\d{3})(?:\\d)\\d{2}|(?:(?:\\d"
            },
            {
                "text": " \n(?!^|\\.)[A-Z]{2}-[A-Z]{2}.[A-Z]{3}\n\nEx"
            },
            {
                "text": "\n^[0-9]{2}[A-Z]{3}$\nExercise 2:\nCreate a list of all valid US and British National Insurance"
            },
            {
                "text": " RegEx: (NE[012]BC[012]DE|AA[0-9]+)\n\n8. Can you give a detailed example of how to use Reg"
            },
            {
                "text": " [A-Z]{3,9}[A-Z]{3}[0-9]\n\nA:\n\nYour rules are a bit confusing."
            }
        ]
    },
    {
        "expression": "^A([0-9]|10)$",
        "raw_prompt": "Sizes of paper from A0-A10",
        "refined_prompt": "Matches sizes of paper from A0-A10\nMatch examples:\n- \"A0\"\n- \"A6\"\n- \"A10\"\nNon-match examples:\n- \"A-1\"\n- \"B1\"",
        "matches": [
            "A0",
            "A6",
            "A10",
            "A5",
            "A1",
            "A7",
            "A2",
            "A6",
            "A8",
            "A9",
            "A4"
        ],
        "non_matches": [
            "A-1",
            "B1",
            "A11",
            "*10",
            "M10",
            "R7",
            ")8",
            ":10",
            "x10",
            "c10",
            "V10",
            "T10"
        ],
        "id": 3473,
        "output": [
            {
                "text": " A-1\n\n5. Write a RegEx that matches any combination of digits and letters (no spaces).\nAnswer: [0-9a-zA-Z]{1,2}\n\n\n\nTheory of Mind-Sharing: The Dark Side of Human Interaction\n\n"
            },
            {
                "text": " ^[A-Fa-f0-9]+\\.[A-Fa-f0-9]*$\n\n2. Create a Python script that takes a list of filenames and removes all non-matching examples.\nAnswer:\nimport re\n\nfile_list = [\"file"
            },
            {
                "text": " The pattern should be \"\\d{0,3}-\\d{1,3}-\\d{1,2}\".\n\nExercise 3:\nCreate a RegEx for this description.\n\"The cat ate ten pieces of paper, and then it ate three more.\"\nAnswer:"
            },
            {
                "text": "\n- \"A0\"\n- \"A1\"\n- \"A2\"\n- \"A3\"\n- \"A4\"\n- \"A5\"\n- \"A6\"\n- \"A7\"\n- \"A8\"\n- \"A9\"\n- \""
            },
            {
                "text": " A(?P<firstLetter>[A-Z])(?P<lastLetter>[A-Z])(?P<minSize>[0-9]?)\n\nExercise 5: Create a list of ten RegEx patterns that will match any URL that starts with www and has either \"http"
            },
            {
                "text": " A(0|1)-?B(0|1)\n\n2. Extract all phone numbers from a text \n\nExample: \ntext = \"My phone number is (1234567890) or (2345612345-7890)\"\n\nTo extract all phone numbers, you"
            },
            {
                "text": " \n[0-3]\n[4-6]\n[7-9]\n[0-9]\n[:alpha:]\n[:digit:]\n[^A-Za-z0-9-_]\n[-]\n[\\+]\n[\\-"
            },
            {
                "text": "\n[A-Z][a-z]{2,}[0-9]{2}\n\n2. Create a RegEx to match a URL that starts with \"http\" and ends with \".com\"\nAnswer:\n^http[s]?://(?:[a-z"
            },
            {
                "text": " A\\\\d+ \n\n2. What is the purpose of case-insensitive matching in a RegEx?\nAnswer: Case-insensitive matching allows a single match to occur regardless of the case of the original string.\n\n3. How can you check that a string does indeed contain a certain"
            },
            {
                "text": " A(d)\n- A(e)\n- A(f)\n\nExercise 3: Re-write the following sentence to be in all caps using RegEx:\n\"the quick brown fox jumps over the lazy dog\"\nAnswer: THE QUICK BROWN FOX JUMPS OVER"
            }
        ]
    },
    {
        "expression": "^([1-9]+)?[02468]$",
        "raw_prompt": "Any number possible as long as its even.",
        "refined_prompt": "Matches any number possible as long as its even.\nMatch examples:\n- \"2\"\n- \"64\"\n- \"4343253298\"\nNon-match examples:\n- \"3\"\n- \"65\"",
        "matches": [
            "2",
            "64",
            "4343253298",
            "54462446332341621278485525477542956571558953391926",
            "4",
            "0",
            "2877461963813168652",
            "62928195697568977435979956928831314989257272",
            "8",
            "78947698",
            "364543262324",
            "234564",
            "342567654"
        ],
        "non_matches": [
            "3",
            "65",
            "5345643531",
            "65789091",
            "35932109",
            "348712937",
            "4398523",
            "4390523",
            "0987654321",
            "234567",
            "67545",
            "3453019"
        ],
        "id": 3475,
        "output": [
            {
                "text": " Match any number between 0 and 10, non-match any number outside this range as long as its even (2, 4, 6, 8, 10).\n\nExercise 2: \nGenerate a RegEx for this description. This RegEx should match any string that contains exactly three consecutive letters of the alphabet."
            },
            {
                "text": " \\1\n\n4. Write a Python program for validating phone numbers.\n- A phone number needs to be 10 digits long or fewer, and it can only be composed of the digits 0-9.\n- Use RegEx to validate phone numbers.\n\n5. Create a Python program that extracts email addresses from"
            },
            {
                "text": " (Any number that is even)\n\nPart 3: Practical Use Cases\n\nUse Case 1: Password Validation\nImagine you are trying to create a strong password that is 10 characters long, includes at least one uppercase letter, one lowercase letter, and one number. You want to create a RegEx"
            },
            {
                "text": " (\\d{2})([12]|[3])\n\n#### Exercise 2\nGenerate a regular expression pattern that will match any string that contains only lowercase letters.\nAnswer: - [a-z]+\n\n#### Exercise 3\nGenerate a regular expression pattern that will match any string that contains"
            },
            {
                "text": " [0-9]*[2][0-9]*\n\nExercise 3: \nWrite a RegEx pattern to extract all the email addresses from a string. \nAnswer: [a-zA-Z0-9._%+-]+@[a-zA-Z0-"
            },
            {
                "text": " \"3\"\nIn this exercise, make sure that you are comfortable writing a single pattern that will match any number, both positive and negative. Test your pattern and make sure that it works correctly.\n\n### Solution\n```python\nimport re\n\n# Generate a regular expression pattern that matches any even number greater"
            },
            {
                "text": " I have no idea how to generate a RegEx for this description. \n\nExercise 2:\n\nQuestion: Write a Python program to find all prime numbers between 2 and 100 using RegEx.\nThinking: I need to use the re module to search for the pattern of prime numbers. I can use a"
            },
            {
                "text": " Match any number between 0 and 9.\n\nExercise 4: Non-match examples for \"even\"\nWrite a RegEx to match any number that is not even.\nAnswer: (\\d*[13579])\n\nExercise 5: Non-match examples for \"even\"\nWrite a RegEx"
            },
            {
                "text": "\n\"3\" : (?=\\d{2,3}$)\n\n4. Write a RegEx pattern to check for the following:\n- 3 consecutive digits\n- 3 letters (lowercase or uppercase)\n- 1 or more digits\n\nGenerate a RegEx for this description."
            },
            {
                "text": " \n- \"\\\\d{2}|\\\\s{1}\\\\d{2}\"Generate a RegEx for this description. \n\nExercise 4: Write a RegEx that matches a MAC address.\nAnswer: \n- [0-9A-Fa-f]{2}["
            }
        ]
    },
    {
        "expression": "^(-?)((\\d{1,3})(,\\d{3})*|\\d+)((\\.\\d+)?)$",
        "raw_prompt": "Matches negative and positive numbers with or without commas and with or without decimals",
        "refined_prompt": "Matches negative and positive numbers with or without commas and with or without decimals\nMatch examples:\n- \"-9.999\"\n- \"99,999,999.99\"\n- \"9999.99\"\nNon-match examples:\n- \"-.9\"\n- \".9\"",
        "matches": [
            "-9.999",
            "99,999,999.99",
            "9999.99",
            "999",
            "973,898,080,023,320,174,275,691,896,152,929,655,872,854,275,405,642,525,164,040,715,794,125,153,765,149,370,547,663,723,520,381,412,935,153,182,317,140,251,596,179,426,310,146,514,816,550,425,261,266,914,296,309,977,419,649,196,217,745,536,552,854,423,520,767,883,456,706,212,962,862,792,823,683,766,127,484,450,256,322,208,506,810,163,708,363,530",
            "-107435874649536107.8425896633773618788668368182747602093390185",
            "574,157,771,787,480,745,391,222,968,697,710,809,027,945,859,504,193,784,865,300,586,485,054,581,945,331,306,825,209,685,537,173,186,524,778,331,974,946,315,377.7655430909592566053000542956697504011368047909223541262517872627668012",
            "7313696270262177170837",
            "31,488,896,592,575,159,982,969,001,342,115,430,876,192,242,360,264,280,364,174,659,994,129,828,840,905,580,876,205,901,545,632,615,330,748,307,674,682,190,322,580,290,582,118,805,859,233,158,916,497,461,750.1462680935394607079801548365023342919593",
            "68,003,464,907,564,254,704,314,847,875,828,177,723,429,372,052,221,672,410,341,505,941,792,775,515,083,508,684,418,580,476,497,609,295,879,951,226,673,385,005,628,067,062,694,799,831,691,923,097,473,628,070,117,889,840,844,522,227,274,243,367,836,552,928,077,075,868,961,876,296,593,950,430,931,305,478,348,514,453,522,818.6645486536540997105751121294598781036",
            "-4821832801840457814747826278894671531051137138018416901702041595271519335526298581447861181793086752",
            "55253465954372875860773921365960757899176704913.502999822699787898412276",
            "28808141779321425346696897"
        ],
        "non_matches": [
            "-.9",
            ".9",
            "9,99.99",
            "4fbh3q",
            "#3",
            "45%",
            "$34",
            "12/12",
            "3.",
            "+9876",
            "8976.",
            "3283.312."
        ],
        "id": 3481,
        "output": [
            {
                "text": " -\\d+\\.\\d+\n\nExercise 2: Match these words with their meanings:\na) Comma\nb) Negative\nc) Decimal\nd) Positive\ne) RegEx\nf) Match\n\nAnswer"
            },
            {
                "text": " Match either -,-.9 or.9 with any combination of alphabets and digits.\n\nExercise 3: Create a RegEx for this description.\nA RegEx for email addresses.\n\nAnswer: [Regex for a"
            },
            {
                "text": " ^\\d+\\.\\d+$\n\n3. Match a string that passes a regex pattern\nMatch examples:\n- \"abc123\"\n- \"abc123-456\"\n- \"abc123-45.6\"\nNon"
            },
            {
                "text": " (\\d+\\.\\d*)\n\n2. Match numbers with or without a decimal point and with or without a comma\nMatch examples:\n- 12,345\n- 12,34,56789\n- 1,234,5"
            },
            {
                "text": " \\d{1,3},\\d{3} or \\d{3}-?\\d{3} or \\d{3}\\.?\\d{3}\n- \"99,000,000,000,000,"
            },
            {
                "text": " This is a bit tricky because there are two possible interpretations of what is considered positive and negative. One possibility is to use \\d+(\\.\\d+)? to match a decimal number with or without a comma. Another possibility is to use -?\\"
            },
            {
                "text": " \"^-?\\d+(?:\\.\\d+)?$\"\n\n3. Write a Python program that identifies whether a given string matches the regular expression pattern \"^[a-zA-Z0-9_-]*$"
            },
            {
                "text": " [The answer is a single negative lookahead] (?<=\\d-)\n- \"98,9900.99\"\n- \".9\"Generate a RegEx for this description. \nAnswer: [The answer is a single"
            },
            {
                "text": " [-0-9]\\.[0-9]\n\nExercise 2: Match the following characters with their meanings\nMatch examples:\n- \"-\"\n- \".\"\n- \"(\",\")\"\n- \"_\"\nMatch non-match examples"
            },
            {
                "text": "\n\n```python\nimport re\n\n# generate a RegEx pattern\npattern = re.compile(r'-?([1-9]+\\.[1-9]*|\\d*)-?([1-9]+)"
            }
        ]
    },
    {
        "expression": "^([\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+[A-Z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+|[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[0-9]+[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+[a-z]+|[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+|[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[0-9]+[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+[A-Z]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[A-Z]+|[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+|[a-z]+[0-9]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[A-Z]+[0-9]+|[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+|[a-z]+[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[a-z]+[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[0-9]+[a-z]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+[a-z]+|[A-Z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+|[A-Z]+[0-9]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+|[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[A-Z]+[a-z]+[0-9]+|[A-Z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[a-z]+[0-9]+|[A-Z]+[a-z]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+[0-9]+|[A-Z]+[a-z]+[0-9]+[\\$@!%\\*\\?&`~\\^\\\\(\\)\\[\\]\\{\\}<>,\\._#-]+)+$",
        "raw_prompt": "Password with lower, upper case letters, digits and special characters in any order",
        "refined_prompt": "Matches password with lower, and upper case letters, digits, and special characters in any order\nMatch examples:\n- \"#3aZ\"\n- \"3#aZ\"\n- \"3a#Z\"\nNon-match examples:\n- \"#$@!\"\n- \"aB3a\"",
        "matches": [
            "#3aZ",
            "3#aZ",
            "3a#Z",
            "3aZ#",
            "#3Za",
            "3#Za",
            "3Z#a",
            "3Za#",
            "#a3Z",
            "a#3Z",
            "a3#Z",
            "a3Z#",
            "#aZ3",
            "a#Z3",
            "aZ#3",
            "aZ3#",
            "#Z3a",
            "Z#3a",
            "Z3#a",
            "Z3a#",
            "#Za3",
            "Z#a3",
            "Za#3",
            "Za3#"
        ],
        "non_matches": [
            "#$@!",
            "aB3a",
            "zzzz",
            "BBBB",
            "1234",
            "r4fr4ecUYF",
            "fervdrtg",
            "3443ferfr",
            "r4ewd4513",
            "43fe7",
            "3r783y43hre",
            "4fbh3q"
        ],
        "id": 3483,
        "output": [
            {
                "text": " [^\\w\\s]\"\n\nExercise 3: Regex for validating phone numbers\nCreate a RegEx to match valid US phone numbers. The phone number should have at least 10 digits, and the area code should be either"
            },
            {
                "text": " \"^(?=.*[a-z])(?=.*\\d)(?=.*[A-Z])(?=.*\\W)[a-zA-Z\\d\\W]{8,}$"
            },
            {
                "text": "\n[a-zA-Z0-9\\$@#!]*\n\nExercise 4:\nWrite a Python program that prompts the user to enter a string, and then uses a regular expression to find all occurrences of a"
            },
            {
                "text": "\nThe regex pattern would be [a-zA-Z0-9]*\n\nExercise 3:\nCreate a RegEx for this description:\nMatch a string with a specified character at any position\n\nAnswer:\n"
            },
            {
                "text": "\nThis exercise is a trick question, as there are no unique rules to create a valid password RegEx.\n\nExercise 4:\nCreate a regular expression to match string starting with a capital letter and ending with a space.\n\n"
            },
            {
                "text": "\nimport re\nstring = \"#3aZ\"\npattern = re.compile(r'^[a-z0-9#@!$]*$')\nif pattern.fullmatch(string)!= None:"
            },
            {
                "text": " ^(?=.*\\d)(?=.*\\w)(?=.*[A-Z][a-z])(?=.*[@$!%*#?&])[a-zA-Z\\d"
            },
            {
                "text": "\n^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[^!@#$%^&*])[A-Za-z\\d"
            },
            {
                "text": "\n\nimport re\n\npattern = r\"^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[$@!@#$%^&*"
            },
            {
                "text": " /^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&+=])[^#!@#$%^&+="
            }
        ]
    },
    {
        "expression": "<!--(?!\\s*\\[if[^]]+]>[^<]*<!\\[endif\\]).*?-->",
        "raw_prompt": "Matches html comments but excludes comments that contain if statements",
        "refined_prompt": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>blah<![endif]-->\"\n- \"<ref>\"",
        "matches": [
            "<!-- this is a comment -->",
            "<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->",
            "<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->",
            "<!---->",
            "<!--E:gh;a]4\"s-->",
            "<!--/~u{c_w+Qn8hb c.oUqow/[sRvVv1R3=[k`$:WRr-->",
            "<!--0{h8J$Ep qOt6p3dTZfOk:z-->",
            "<!--e( >80-z[?r?MLz&xeNi-70uEWok$/haO3+UbK)tvCh^(LERX?0l^^R >!.W/d<V{JssHYMt$/}D\\9,ScN6g>m-->",
            "<!--l svPDf{F<0o1@>_{yAMB=v&8Hnh-J]^a^cgS,I_g#U97kfAraoq08*81*VK'uDWr|9+R<Suyx<#vHh:yUoj,tC5DUL'{l-->",
            "<!--v4Dag[]X'j6O7qO]K.#IT<Dd7lB*Cx$Jq8yYz{`-->",
            "<!--m!`!Xmfv7q7^[WR6D&Os(Ph-\"M}I6>K\\:^|WyPfPN+oTU=6-+bhuHBPe}.~j+g.!\\7rcoJ`rt#j)p6\"=o7REs>`BeLT<qAn-->",
            "<!--wH1m9&T('3UZFB/$J`N/f^ZsR4L9K'UHX^QjE\",oLvA[Mafz\";`8}~qx W\\r*t/m\\[q<-->",
            "<!--VQ5 WgKWRuBnmVL#nt[Cr07h@Q/w_LEis~\\u:_H-->"
        ],
        "non_matches": [
            "<!-- [if lt IE 9]>blah<![endif]-->",
            "<ref>",
            "#ekf",
            "//grefdw",
            "/ erwfds",
            "\\\\frf4r3",
            "comment",
            "## frgrtf",
            "/* erhfgejr */",
            "< rfer <",
            "> jefejer <",
            "/// rtgfd"
        ],
        "id": 3488,
        "output": [
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>1"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>5"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>1"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]> <"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>3"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>5"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]> h"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>5"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>10"
            },
            {
                "text": "Matches html comments but excludes comments that contain if statements\nMatch examples:\n- \"<!-- this is a comment -->\"\n- \"<!--;^RN|Ma){QQuC?\"z|RVWY_@i]%3>2=d,z-->\"\n- \"<!--Kb;-S2tff.DGG\\WZ!hF(]/`0-].z$\\* t*/Ir39:8^B+s&@{tX$;?-->\"\nNon-match examples:\n- \"<!-- [if lt IE 9]>1"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "raw_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long",
        "refined_prompt": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long\nMatch examples:\n- \"4/1/2001\"\n- \"12/12/2001\"\n- \"55/5/3434\"\nNon-match examples:\n- \"1/1/01\"\n- \"12 Jan 01\"",
        "matches": [
            "4/1/2001",
            "12/12/2001",
            "55/5/3434",
            "7/34/0493",
            "5/2/6783",
            "9/3/6347",
            "67/86/8577",
            "2/79/7620",
            "5/6/1794",
            "3/00/1375",
            "86/18/0593",
            "0/8/0673",
            "9/94/5749"
        ],
        "non_matches": [
            "1/1/01",
            "12 Jan 01",
            "1-1-2001",
            "Jan",
            "July 5th",
            "23-23-23-23",
            "92",
            "394",
            "$45",
            "3929",
            "65%",
            "12-12"
        ],
        "id": 3546,
        "output": [
            {
                "text": " \\b(1?[1-9]|2[0-9]|0?[1-9])\\/(1?"
            },
            {
                "text": " (?<month>\\d{2})/(?<day>\\d{2})/(?<year>\\d"
            },
            {
                "text": " ^[0-9]{1,2}[ /]([0-9]{4})$\n\n## 3. Using"
            },
            {
                "text": " \n\\b\\d{1,2}\\s\\-\\d{1,2}\\s\\-\\d{4}\\b\n"
            },
            {
                "text": " \"(\\\\d{1,2})/(\\\\d{1,2})/(\\\\d{4})\".\n\nExercise"
            },
            {
                "text": "\n ^(?:\\d{2}\\/)?(?:\\d{2}\\/)?(?:\\d{4})$\n"
            },
            {
                "text": " Regex: (\\d{2}\\/\\d{2}\\/\\d{4})\n\nExercise 2: \n"
            },
            {
                "text": " [01]\\d{2}-\\d{2}-\\d{4}\n\n**Exercise 2:** Create"
            },
            {
                "text": " \\d{1,2}\\/\\d{1,2}\\/\\d{4}\n\n2. Write a Python program"
            },
            {
                "text": " \n(1|2)\\d{2}/\\d{4}(\\/\\d{2})?\n\nExercise"
            }
        ]
    },
    {
        "expression": "((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9])|((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9])|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9]:[0-5][0-9])|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9])",
        "raw_prompt": "Matches all types of time declaration with ':' separator.",
        "refined_prompt": "Matches all types of time declaration with ':' separator.\nMatch examples:\n- \"0:26:12 aM\"\n- \"00:26:12 Pm\"\n- \"0:26:12aM\"\nNon-match examples:\n- \"eferfqe\"\n- \"ergqfr\"",
        "matches": [
            "0:26:12 aM",
            "00:26:12 Pm",
            "0:26:12aM",
            "00:26:12Pm",
            "Am 0:26:12",
            "pM 00:26:12",
            "Am0:26:12",
            "pM00:26:12",
            "0:26 PM",
            "01:26 am",
            "0:26PM",
            "01:26am",
            "Am 0:26",
            "pM 00:26",
            "Am0:26",
            "pM00:26",
            "23:26:12",
            "00:26:12",
            "0:26:12",
            "23:26",
            "0:26"
        ],
        "non_matches": [
            "eferfqe",
            "ergqfr",
            "time",
            "noon",
            "39404",
            "234je",
            "am",
            "pm",
            "4334",
            "ef394",
            "323423",
            "43234"
        ],
        "id": 3549,
        "output": [
            {
                "text": " (a|p)M|(am|pm)\n\nExercise 2: Given a string, \"I'll be there at 3:12:45\", parse the time\n\nAnswer: 3:12"
            },
            {
                "text": " (.*)(?:Pm|aM)*\n\nThis question is similar to this one, but the answer is a lot more complicated and the regex in this question uses parentheses in the middle of the expression, which"
            },
            {
                "text": " (\\\\d{2})-(\\\\d{2}):(\\\\d{2} [apm])\"\n\n3. Write a regular expression that identifies all dates in the format \"MM/DD"
            },
            {
                "text": " \"([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(aM|Pm))\"\n\nThis"
            },
            {
                "text": " [0-9]\\d|a-z]{2}\n\nExercise 3: Match numbers with '.'\nWrite a RegEx for this description:\nFind all numbers from 1 to 100 with"
            },
            {
                "text": " [0-9a-z][a-zA-Z_\\s]*[0-9a-z]\n\nI'm using Regex.\n\nThank you all for your help!"
            },
            {
                "text": " (regex) ^\\d{1,2}:\\d{1,2}:\\d{1,4}(a|Pm)$\n\nExercise 2: Write a Python program that"
            },
            {
                "text": "\n\nimport re\n\npattern = r\"([0-2]\\d:[0-2]\\d):([0-5]\\d):([0-5]\\d)\"\n\nstring"
            },
            {
                "text": "\n\"(?:\\D*)(?=\\d:)(?=\\d:)\"\n\nExercise 2:\nWhat is a \"capturing group\" in a RegEx?\nAnswer: A capturing"
            },
            {
                "text": " (?:[0-9]{1,2}\\:[0-9]{1,2}:[0-9]{1,2}(?:-(?:[0-9]{1"
            }
        ]
    },
    {
        "expression": "(0\\d|1\\d|2[0-4]) ?: ?([0-5]\\d)( ?: ?[0-5]\\d)?",
        "raw_prompt": "Validate hh:minmin:ss",
        "refined_prompt": "Validate hh:minmin:ss\nMatch examples:\n- \"09:03:05\"\n- \"08 : 03 : 57\"\n- \"24:00: 05\"\nNon-match examples:\n- \"17:2\"\n- \"3:52\"",
        "matches": [
            "09:03:05",
            "08 : 03 : 57",
            "24:00: 05",
            "00: 00 :00",
            "17:54",
            "08 : 21",
            "20:06",
            "04 : 30",
            "18:44",
            "03:16 :10",
            "12 :03 :22",
            "11:49:41",
            "00:07"
        ],
        "non_matches": [
            "17:2",
            "3:52",
            "time",
            "2345678",
            "5432",
            "noon",
            "12-12",
            "12/12",
            "12/12/12",
            "12-12/12",
            "00000000",
            "9348239"
        ],
        "id": 3556,
        "output": [
            {
                "text": " ([0-9]\\d+:\\d\\d|\\d\\d:\\d\\d)\n\nExercise 4:\nCreate a Regular Expression that will match the password for a PostgreSQL database:\nAnswer:\n^(?=.*[A"
            },
            {
                "text": " [0-9][0-9][0-9]:[0-9][0-9]:[0-9][0-9]\n\"\"\"\n\n#Importing the regular expression module\nimport re\n\n\n#A function to get the current timestamp"
            },
            {
                "text": " (18+0+0+0) | (1+0+0+0) | (0+9) | (0+0)\n\nA:\n\nAnother solution is, you can use the regexp with only one regular expression.\nIn"
            },
            {
                "text": " hh[0-2,9] | hh[0-9] | hh[0-9,9] | hh_[0-2,9] | hh_[0-9] | hh_[0-9"
            },
            {
                "text": " \n^.*\\d{2}:\\d{2}:\\d{2}$\n\nExercise 2:\nWrite a Python class that takes in a time string in the format \"hh:mm:ss\" and returns the number of seconds since the"
            },
            {
                "text": " \"19:00:00-18:00:00\"\n\n2. Write a RegEx to validate a password. It should have a character between 8 and 16 characters, a number between 0 and 9, and at least one uppercase character, lowercase"
            },
            {
                "text": " \n[0-9]:[0-9]:[0-9]:[0-9]\n\nAs you can see, the Regular Expressions are really powerful and can even cover more complicated scenarios. I hope this helped you understand the basics of Regular Express"
            },
            {
                "text": " *(?P<hh>\\d{2}):(?P<min>\\d{2}):(?P<ss>\\d{2})*\"\n\n3. Write a script that takes a string and prints out the number of"
            },
            {
                "text": " (hh.\\d{1,2}|minmin.\\d{1,2}|ss.\\d{2})\n\nExercise 2: Write a function that takes a string representing time in hh:mm:ss format, splits it"
            },
            {
                "text": " \nThe above scenario could be used to validate a time stamp in the format of \"hh:mm:ss\" where hh is always two digits, mm is two digits, and ss is two digits.\n\n```python\npattern = r'^\\"
            }
        ]
    },
    {
        "expression": "^-?[1-9]\\d*\\.?(\\d+([eE][-+]\\d+)?)?$",
        "raw_prompt": "Matches numbers including scintific format",
        "refined_prompt": "Matches numbers including scientific format\nMatch examples:\n- \"-23333.1e+24\"\n- \"123\"\n- \"34.2\"\nNon-match examples:\n- \"23333.01+24\"\n- \"+123\"",
        "matches": [
            "-23333.1e+24",
            "123",
            "34.2",
            "-87693717247827161710694734576192125749089372404404342916330522406312",
            "-58564737552536.48176669308690674801075092379671445298833269473178731660961607224906327105271832084398137517568204770E-543040380162654177953787637765950840354806562831489817623846468396061531953",
            "862812362091683.",
            "-14649493636878381404701033168989841646",
            "-8101504129224558449019.4405431612507291079373009997249872857073731454645109061855654267230552770570547052296479060",
            "-26289839608675870704205108719611455149053083752457354690998470666126956758238188267599153792124132000685265298028593",
            "-6675064312488545378599501435434424173844999467920.",
            "-6814243005789112884114406497450943039122013912782781.890142773956864806716537437059292866176042454049110855352E-316423271089475072396705264608329388811095333019381819638428674",
            "286373605821936943615099.",
            "-970298087661834718193198391350046452602031077045708513613731852440827586137422875"
        ],
        "non_matches": [
            "23333.01+24",
            "+123",
            "34.-20",
            "erfr",
            "x10",
            "SF",
            "erfher",
            "ferh",
            "+234",
            "#43",
            "45%",
            "$67"
        ],
        "id": 3561,
        "output": [
            {
                "text": " (.*)\\.\n\nExercise 3: Use Regular Expressions to find the number of words in each sentence in the following list:\n- 'The quick brown fox jumps over the lazy dog.'\n- 'The quick brown fox jumps over the lazy dog.'\nAnswer: (.*)\\n"
            },
            {
                "text": " \\d+\\.?\\d*e+?[+-]?\\d*\n\n3. Write a Python script to validate a URL. A URL must have a valid top-level domain (e.g..com,.org,.edu,.gov).\n\n"
            },
            {
                "text": " The regular expression should match numbers that start with a digit, end with one or more zeroes, and are followed by a decimal point and one or more positive/negative numbers. \n\nExercise 4:\nUse the'match' method to match an email address that ends with \".edu"
            },
            {
                "text": " ^[-+]?\\d+(\\.\\d+)?$\n- \"123.1\"Generate a RegEx for this description.\nAnswer: ^[-+]?[\\d.]+$\n\n4. Write a Python function that takes a string and returns True if it"
            },
            {
                "text": " \"+\".+?[0-9]?[0-9].+?[0-9]?[0-9].+?[0-9].+?[0-9].+?[0-9]\"\n\nExercise 2: \nMatch numbers with scientific"
            },
            {
                "text": " (\\d+\\.\\d+|\\d+\\.\\d+)\n\n\n\nQuestion 2: John has twice as many marbles as his sister Lisa. If Lisa has 20 marbles, how many marbles do they have combined?\n\nSolution: Let x be the number of"
            },
            {
                "text": " \n- (^|[^0-9a-zA-Ze-z]+)(-([0-9]+(?:\\.[0-9]+)?)|([0-9]+))([e|E][0-9]+)?$\n- (^|"
            },
            {
                "text": " [0-9]+\\.[0-9]+ \n\nExercise 2: \nWhat does \"(\\+)?([0-9]+)(\\.[0-9]+)?\" match? \nAnswer: This regex matches numbers including scientific notation (1e+24), numbers with"
            },
            {
                "text": " (^\\+|\\-)?\\d+(\\.\\d*)?\n\nExercise 2: Regex for a String\nMatch examples:\n- \"The temperature is 25 degrees Celsius\"\n- \"The wind speed is 15 mph\"\n- \"The pressure is 101.3 k"
            },
            {
                "text": "\n- \\-+?\\d+(\\.\\d+)?e[+-]\\d+\n- \\-+?\\d+\n\n2) Generate a RegEx for the following description of a date:\nMatch examples:\n- \"30/06/2020\"\n-"
            }
        ]
    },
    {
        "expression": "^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)\\d\\d$",
        "raw_prompt": "Date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators.",
        "refined_prompt": "Matches date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators.\nMatch examples:\n- \"01/02/2015\"\n- \"5-7-1915\"\n- \"12.8.2035\"\nNon-match examples:\n- \"11-11-1845\"\n- \"31/12/2000\"",
        "matches": [
            "01/02/2015",
            "5-7-1915",
            "12.8.2035",
            "7 15 1963",
            "04.4-2026",
            "11-16 2045",
            "12 31/1965",
            "01/06.2038",
            "6/8.2070",
            "11 22.1990",
            "12 31 1971",
            "10-1 1929",
            "10.8-1940"
        ],
        "non_matches": [
            "11-11-1845",
            "31/12/2000",
            "10-17-85",
            "jan 3",
            "monday the 4",
            "september",
            "324rfds",
            "july",
            "AM",
            "noon",
            "August 6th",
            "23erfo"
        ],
        "id": 3601,
        "output": [
            {
                "text": " r\"^(((?:[1-9"
            },
            {
                "text": " \\b\\d{2}[-/"
            },
            {
                "text": " [0-9]{1,2}"
            },
            {
                "text": " (\\d{2}-\\d{"
            },
            {
                "text": " r'^\\d{1,2}\\"
            },
            {
                "text": " [0-9]{1,2}\\"
            },
            {
                "text": " ([0-9]{1,2}"
            },
            {
                "text": " (\\\\d+-\\\\d{1,"
            },
            {
                "text": " ([0-9]{1,2}"
            },
            {
                "text": " ^(0[1-9]|["
            }
        ]
    },
    {
        "expression": "^(1[0-2]|0[1-9]|[1-9])\\/(1[0-9]|2[0-9]|3[0-1]|0[1-9]|[1-9])\\/\\d{4}$",
        "raw_prompt": "is very accurate when catching\nand matching dates within the correct ranges in US standard date formats MM/DD/YYYY",
        "refined_prompt": "matches dates within the correct ranges in US standard date formats MM/DD/YYYY\nMatch examples:\n- \"1/3/2017\"\n- \"01/03/2017\"\n- \"12/12/2017\"\nNon-match examples:\n- \"31/12/2017\"\n- \"99/99/9999\"",
        "matches": [
            "1/3/2017",
            "01/03/2017",
            "12/12/2017",
            "12/31/2017",
            "11/29/4173",
            "03/30/1641",
            "2/26/2848",
            "4/14/6563",
            "01/31/8745",
            "12/2/5702",
            "09/29/3083",
            "11/07/8412",
            "02/27/8779"
        ],
        "non_matches": [
            "31/12/2017",
            "99/99/9999",
            "12-31-2017",
            "December 30th, 2017",
            "jan 3",
            "12-43 32",
            "14 433 23",
            "23 7834 3",
            "28 84 28",
            "12 12 12",
            "date",
            "$45"
        ],
        "id": 3712,
        "output": [
            {
                "text": "\n[0-9]{2}/[0-9]{2}/[04][0-9]{2}[0-9]{2}\n\nExercise 2"
            },
            {
                "text": " \n\nimport re\n\npattern = re.compile(r\"\"\"(\n    (\\d+/\\d+/\\d+)\\s\n    (?:(?:(?:(?"
            },
            {
                "text": " (0,0-29)\nThe idea is to check the current month and then the current day of the month, for example:\n  if(i.month == 12) {\n    if"
            },
            {
                "text": " The correct regular expression would be [0-9]{2}[.-][0-9]{2}[.-][0-9]{4}\n\n[TA]: Hi there"
            },
            {
                "text": "\n(0)  [0-9]{1,2}/[0-9]{2,3}/[0-9]{4,5}\n(0)*  "
            },
            {
                "text": " (Any RegEx that passes the test case above).\nI did the following:\nimport re\ndef dateRange(date):\n    return re.findall('(?:[0-9]"
            },
            {
                "text": " ^(1|2)[0-9]{2}/[1-9][0-9]{3}/[1-9][0-9]{4}$ \n"
            },
            {
                "text": " \n[01/][3/][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0"
            },
            {
                "text": " ([a-z]{1}/[a-z]{1}/\\d{4}|\\d{4}/\\d{2}/\\d{2}|"
            },
            {
                "text": " (MM/DD/YYYY)\n\nI solved this problem by using the '|' operator to match either the day part or the month part of a date, and then using ':' to specify"
            }
        ]
    },
    {
        "expression": "((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(0(0|4|8)))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[- ]?\\d{4})",
        "raw_prompt": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years",
        "refined_prompt": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years\nMatch examples:\n- \"020955-2012\"\n- \"020955-2012\"\n- \"241283-1234\"\nNon-match examples:\n- \"459434-1234\"\n- \"123456-1234\"",
        "matches": [
            "020955-2012",
            "020955-2012",
            "241283-1234",
            "290204-1234",
            "010111-1111",
            "1609902765",
            "1604403492",
            "300907-9597",
            "071221-9711",
            "130215-1984",
            "3112263460",
            "290232-1685",
            "290276-3597"
        ],
        "non_matches": [
            "459434-1234",
            "123456-1234",
            "32",
            "324213",
            "2332",
            "#3",
            "45%",
            "+9876",
            "-9876543",
            "12/12",
            "12-12",
            "$45"
        ],
        "id": 3731,
        "output": [
            {
                "text": "  The following regex would match this description: [0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9"
            },
            {
                "text": " ([0-9]{4}[-0-9]{2}[-0-9]{2})\n(?<![a-zA-"
            },
            {
                "text": " (http://regex101.com/r/u0jB2a/3)\n\nA:\n\nI would probably not use a regex for this.\n"
            },
            {
                "text": "\n(0[1-9]|1[012])[-/]((0[1-9]|[12]\\d|3[01])-(19"
            },
            {
                "text": " \n(?:\\d{4}-)?(\\d{2})([-\\s])(\\d{2})\n\nAnd the regex for the above example"
            },
            {
                "text": "\n((\\d{3})-(0\\3\\d|1\\3\\d|2\\3\\d|3\\3\\d))-(0\\3"
            },
            {
                "text": "\n- \"^[0-9]{4}-?[1-9][0-9]{3}-?[1-9][0-9]"
            },
            {
                "text": " [a-z]*-?[0-9]{4}-?[0-9]{2}-?[0-9]{2}\n"
            },
            {
                "text": "  \n\\d{3}-\\d{2}-\\d{4}|\\d{1,2}-\\d{1,2}-\\"
            },
            {
                "text": " The regular expression is /([0-9]{4}-[0-9]{2}-[0-9]{1})[^0-9-]+/."
            }
        ]
    },
    {
        "expression": "(\\+989|9|09)(0[1-3]|1[0-9]|2[0-2]|3[0-9]|90|9[8-9])\\d{7}",
        "raw_prompt": "Regex for current available mobile numbers mention at\nhttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7%D9%86",
        "refined_prompt": "Matches phone numbers that start with +989, 09, 9\nMatch examples:\n- \"09221113344\"\n- \"+989157097015\"\n- \"09984114118\"\nNon-match examples:\n- \"09057614584\"\n- \"210843631\"",
        "matches": [
            "09221113344",
            "+989157097015",
            "09984114118",
            "09019240398",
            "+989909222614",
            "9037817824",
            "+989300250188",
            "+989989115757",
            "09901083192",
            "+989989264032",
            "+989900827176",
            "9395962429",
            "9985839583"
        ],
        "non_matches": [
            "09057614584",
            "210843631",
            "134270843",
            "226845794",
            "029897164",
            "022500703",
            "334741498",
            "344497280",
            "379468937",
            "190787239",
            "136765751",
            "162658046"
        ],
        "id": 3753,
        "output": [
            {
                "text": " \\d{3}-\\d{3}-\\d{4}\n\nExample 1:\nSamantha and her friends love to play outdoor games during their break. Today they decided to play basketball. Samantha brought her"
            },
            {
                "text": " ^[^0-9](?:[0-9]{1}[1-9]?)[^0-9]$\n\n#### Exercise 2:\nCreate a RegEx to match email addresses that begin with \""
            },
            {
                "text": " +\\d\\d\\d\\d\\d\\d\\d\"\n\nExercise 2:\nMatch phone numbers that have more than 6 digits.\nAnswer: +9\\d\\d\\d\\d\\d"
            },
            {
                "text": " ^\\+\\d\\d\\d-\\d\\d\\d-\\d\\d(?=\\d\\d)\nExercise 3: Solve the problem of finding the longest common sequence.\nThe longest"
            },
            {
                "text": " The phone number should start with +989 and have 10 digits. The phone numbers should not contain any additional spaces or special characters.\n\nExercise 4:\n- Write a function that takes a user's input, converts it to lower"
            },
            {
                "text": " \\+[0-9]{2}\\d{3}(\\.\\d{3})?\"\n\nExercise 4:\nMatch phone numbers that contain only uppercase letters and dashes.\nAnswer: \\["
            },
            {
                "text": " Phone numbers must start with +989, then 9, then 9 again, followed by 0 or 9, then another 0 or 9 and end with either 0 or 9.\n\nExercise 2:\nMatch or find phone numbers with this"
            },
            {
                "text": " (?:\\s\\+|\\d+)(?:\\s\\-\\d+)?\n\nExercise 4: \nWrite a pattern that matches any email addresses.\nAnswer: [a-zA-Z0-"
            },
            {
                "text": " Match 1\n- \"03968888888\"\n- \"+93993939392\"\n- \"+93395949392\"\n- \"+98659584939\"\n- \"+98658504939\""
            },
            {
                "text": " [0-9]{3,}[0-9]{3,}[0-9]{3}[0-9]{1}\n\nExercise 3:\nMatch these email addresses that end with"
            }
        ]
    },
    {
        "expression": "^([1-9][0][0]|[1-9][0-9][0][0]|[1-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0-9][0][0])$",
        "raw_prompt": "Permite digitar valores m\u00faltiplos de 100 entre 0 e 9999999.",
        "refined_prompt": "Matches integers between 0 and 9999999 that are multiples of 100.\nMatch examples:\n- \"100\"\n- \"200\"\n- \"9999900\"\nNon-match examples:\n- \"101\"\n- \"201\"",
        "matches": [
            "100",
            "200",
            "9999900",
            "392400",
            "8721100",
            "900",
            "149200",
            "50400",
            "9788500",
            "3800",
            "300",
            "700",
            "500"
        ],
        "non_matches": [
            "101",
            "201",
            "9999901",
            "2342",
            "32321",
            "54235",
            "45",
            "3425",
            "65",
            "78657",
            "5437",
            "465"
        ],
        "id": 3772,
        "output": [
            {
                "text": " \"^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]$\"\nExercise 2: Match a string that has"
            },
            {
                "text": " Use the \"\\d*(?:\\.\\d+)?\\s*\" pattern to match any number of digits (including decimals) followed by any number of spaces optionally. \n\nExercise 2: \nMatch numbers between 0.1 and 0.9999 that are integers.\n"
            },
            {
                "text": " \"([1-9])*([0-9])\"\n\n- Write a RegEx to match an email address. \nAnswer: \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a"
            },
            {
                "text": "\n^0[1-9][0-9]*|[1-9][0-9]*[1-9]|99999[0-9]*$\n\nExample: \nimport re\ntext = \"The code is 100 and 200 and there is a match for"
            },
            {
                "text": " [0-9]{3,6}[0-9]{3}\n\n3. Write a regular expression that matches a date in the format \"MM/DD/YYYY\"\nAnswer: [0-9]{2}/[0-9]{2}/["
            },
            {
                "text": " ^([1-9])(\\d\\d)?$\n\n**Exercise 2:** Write a RegEx that matches an email address in the form of 'xxxx@yyyy.com'.\nAnswer: ^[a-zA-Z0-9._%+-]+@["
            },
            {
                "text": " \"[0-9]{4}[0-9]{3}[0-9]{4}[0-9]{3}[0-9]{2}[0-9]{2}[0-9]{1}[0-9]{1"
            },
            {
                "text": " Non-match example.\\d*\\s+\\d+\n\nOverall, I found this subsection to be very challenging, but also very rewarding. I was able to learn a lot about RegEx and how it can be used to solve real-world problems. I also learned how to think creatively and"
            },
            {
                "text": "\nr'\\b[1-9]\\d{0,3}(?:[0-9]{3})'\n\n4) Write a Python script that extracts all numbers from a given string.\nAnswer:\nimport re\n\n# string containing numbers\nstring = \"Find all"
            },
            {
                "text": " [0-9]{1,1}{100}\n\nExercise 5:\nMatch words that are at least 6 characters long that end with a vowel.\nMatch examples:\n- \"apple\"\n- \"orange\"\n- \"igloo\"\nNon-match examples:\n- \""
            }
        ]
    },
    {
        "expression": "((0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])\\d{3}\\d{2}\\d{4})",
        "raw_prompt": "Regex to match the \"Unique Master Citizen Number\" based on the wikipedia description.\nIt doesn't keep in account the checksum, but it matches the example on wikipedia.",
        "refined_prompt": "match the \"Unique Master Citizen Number\" based on the wikipedia description.\r\nIt doesn't keep in account the checksum, but it matches the example on wikipedia.\nMatch examples:\n- \"0101006500006\"\n- \"3112293253271\"\n- \"3108125465983\"\nNon-match examples:\n- \"none\"\n- \"#\"",
        "matches": [
            "0101006500006",
            "3112293253271",
            "3108125465983",
            "3109195422610",
            "3005759418613",
            "0303209389673",
            "0611089194958",
            "3102274338668",
            "1008516980206",
            "0612999408185",
            "1802851243292",
            "2912372658686",
            "0803454542771"
        ],
        "non_matches": [
            "none",
            "#",
            "3edfr",
            "2343",
            "3432345",
            "432",
            "40.43",
            "4%",
            "$43",
            "12/12",
            "3.12",
            "345546"
        ],
        "id": 3791,
        "output": [
            {
                "text": " \"[0-9]{8}[-0-9]{4}[0-9]{4}[0-9]"
            },
            {
                "text": " ^[0-9A-Fa-f]{8}$\n\nA:\n\nIt's not clear what's the expected output"
            },
            {
                "text": " None\n\"\"\"\r\n\r\nfrom collections import Counter\r\nimport re\r\nfrom string import ascii_uppercase, digits\r"
            },
            {
                "text": " ^[a-zA-z0-9]{14}$ \n- \"hello there! \"\n- \"i am a"
            },
            {
                "text": " \"^[0-9]{8}$\"\n\nA:\n\nI would use the regular expression ^#(?=(?:"
            },
            {
                "text": " [^a-zA-Z0-9]# - Generate a RegEx for this description.\n\nA:\n\nThis"
            },
            {
                "text": " ^[^\\#]*\\#[^\\#]*.+$\n\nA:\n\nA couple of regexps:\n"
            },
            {
                "text": " \"#(?:[0-9]+)(?:-[0-9]+){4}$\"\nExplanation: \"The regex matches"
            },
            {
                "text": " \"^\\d{4}-\\d{6}$\"\n\nI am very new to Regular expressions and this is probably a dumb"
            },
            {
                "text": " \"^[0-9]{4}[0-9]{4}[0-9]{4}[0-9"
            }
        ]
    },
    {
        "expression": "([0-8]?\\d[0-5]?\\d[0-5]?\\d|900000)[NS]([0-1]?[0-7]?\\d[0-5]?\\d[0-5]?\\d|1800000)[EW]\\d{3}",
        "raw_prompt": "NOTAM coords and radius in \"Q\" field",
        "refined_prompt": "Matches Notice to Airmen (NOTAM) coords and radius in \"Q\" field\nMatch examples:\n- \"440110N0123634E005\"\n- \"63319S20302E264\"\n- \"2226S0521E554\"\nNon-match examples:\n- \"any other format\"\n- \"east\"",
        "matches": [
            "440110N0123634E005",
            "63319S20302E264",
            "2226S0521E554",
            "900000N1800000W609",
            "69701N1800000E005",
            "426N000926W162",
            "900000N1800000W913",
            "900000N17905E922",
            "34357N1800000E549",
            "900000N1104713E911",
            "900000N3552E951",
            "900000N1800000E645",
            "6807N30413E654"
        ],
        "non_matches": [
            "any other format",
            "east",
            "2345 west",
            "3few34",
            "3445g4",
            "east",
            "north south",
            "4349.349039",
            "343N.49S",
            "40934.err3",
            "49349fs",
            "4r89u34"
        ],
        "id": 3803,
        "output": [
            {
                "text": "\n^[A-Z][a-z]*\\s[0-9]{1,2}\\.[0-9]{1,2}\\.[0-"
            },
            {
                "text": "\n\nimport re\n\n# List of Sample Airmen Locations\nlocations = [\"440110N0123634E005\", \"63319S20302E"
            },
            {
                "text": " (1)^(^\\d+{3}(-?\\d+)(\\d{3}(-?\\d+){1}\\d{3}(-?"
            },
            {
                "text": " (\\d{4})(-)?(\\d{4})-?(\\d{2})(\\d{2})$\n\nExercise 2:\nWrite a"
            },
            {
                "text": " \n^[0-9]\\d{3} [0-9]\\d{3} [0-9]{1} \\d{1} E"
            },
            {
                "text": "\n\n```python\nimport re\n\npattern = r\"([0-9]{1,3}\\.[0-9]{1,3})\\s.*"
            },
            {
                "text": " \n- \"Q\" must be followed by \"N\", \"E\", or \"W\", and must be one character.\n- \"Q\" must be followed by \"S"
            },
            {
                "text": " (\\d{4}\\.\\d{4}\\.\\d{4}E\\d+\\.\\d+),(\\D)    \nExercise 2:"
            },
            {
                "text": " ^[0-9]*$|^[0-9]*$\n- \"North\"Generate a RegEx for this description. \nAnswer: ^["
            },
            {
                "text": "\n-   ^[a-zA-Z0-9\\s]{3}\\s([0-9]{3}\\s){0,1}$\n"
            }
        ]
    },
    {
        "expression": "(((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\\d{4})( |-)([01]8((( |-)\\d{1})|\\d{1}))|(\\d{4}[01]8\\d{1}))",
        "raw_prompt": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\nMatches the format defined as:\nYYMMDDSSSSCAZ.\nYY - Year,\nMM - Month,\nDD - Day,\nSSSS - Gender,\nC - Denotes citizenship (0 or a 1),\nA - Always an 8,\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\nAlso supports the following ways of entering it:\nYYMMDDSSSSCAZ |\nYYMMDD SSSS CAZ |\nYYMMDD SSSS CA Z .\nSee this for a reference:\nhttps://www.westerncape.gov.za/general-publication/decoding-your-south-african-id-number-0",
        "refined_prompt": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDSSSSCAZ |\r\nYYMMDD SSSS CAZ |\r\nYYMMDD SSSS CA Z .\nMatch examples:\n- \"9202204720082\"\n- \"920220 4720 082\"\n- \"920220 4720 08 2\"\nNon-match examples:\n- \"9202204720282\"\n- \"920220 4720 052\"",
        "matches": [
            "9202204720082",
            "920220 4720 082",
            "920220 4720 08 2",
            "920220-4720-082",
            "920220-4720-08-2 9202204720183",
            "920220 4720 183",
            "920220 4720 18 3",
            "920220-4720-183",
            "920220-4720-18-3",
            "680229-2389 186",
            "820202 4161-08 4",
            "6302101315082",
            "1602292137185"
        ],
        "non_matches": [
            "9202204720282",
            "920220 4720 052",
            "920220 4720 05 2",
            "920220-4720-252",
            "312",
            "23",
            "-98765",
            "+875",
            "2.2",
            "12/12",
            "$12",
            "12-12"
        ],
        "id": 3811,
        "output": [
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMD."
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDxx"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDA"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMDDS"
            },
            {
                "text": "Raw prompt:\r\nMatches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\r\nMatches the format defined as:\r\nYYMMDDSSSSCAZ.\r\nYY - Year,\r\nMM - Month,\r\nDD - Day,\r\nSSSS - Gender,\r\nC - Denotes citizenship (0 or a 1),\r\nA - Always an 8,\r\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\r\nAlso supports the following ways of entering it:\r\nYYMMD -"
            }
        ]
    },
    {
        "expression": "^\\d{1,2}-\\d{1,2}-\\d{4}$",
        "raw_prompt": "This takes an American date using mm-dd-yyyy format. It does not validate month or day values.",
        "refined_prompt": "This takes an American date using mm-dd-yyyy format. It does not validate month or day values.\nMatch examples:\n- \"12-9-1969\"\n- \"2-8-1998\"\n- \"8-17-2002\"\nNon-match examples:\n- \"12-9-69\"\n- \"12/2/1948\"",
        "matches": [
            "12-9-1969",
            "2-8-1998",
            "8-17-2002",
            "32-9-7126",
            "7-32-3164",
            "36-41-4023",
            "2-83-5092",
            "65-17-2985",
            "2-6-2573",
            "9-7-6519",
            "73-3-6028",
            "95-92-3946",
            "72-8-3731"
        ],
        "non_matches": [
            "12-9-69",
            "12/2/1948",
            "121212",
            "0303 32",
            "98 32 34",
            "12:12:12",
            "39/ 232 23",
            "=024",
            "date",
            "july 3rd",
            "4th of june",
            "Monday"
        ],
        "id": 3909,
        "output": [
            {
                "text": " /^((0?[1-9]|1[012])-(3[01]|1[012]|0?[9])-(\\d{4"
            },
            {
                "text": " [\\d\\d-\\d\\d-\\d\\d]/[\\d\\d-\\d\\d]/[\\d\\d]\n"
            },
            {
                "text": " \nPattern = 0?[1-9]?[0-9]{2}-(0?[1-9]|1[012])-(0?"
            },
            {
                "text": " ^([0-9]{2})[-/] ([0-9]{2})[-/] ([0-9]{4})$\nExample"
            },
            {
                "text": " \n\n(0[1-9]|1[012])-(0[1-9]|[12]\\d|3[01])-(0["
            },
            {
                "text": " ( \\d+ [\\-\\d] \\d+ [\\-\\d] \\d+ )\n\n#1. Write a python function that cleans up a"
            },
            {
                "text": " [0-9][0-9][0-9][0-9]-(0[1-9]|1[012])[-0-9][0"
            },
            {
                "text": " \\w{2}-\\d{2}-\\d{4}\n3) Write a RegEx for the following text: \n\"The quick brown fox"
            },
            {
                "text": " \\d{1,2}-?[1-9]\\d{9}\n\n2. Use the RegEx generated in exercise 1 to validate an input string"
            },
            {
                "text": "\n^([0-9]{2})-([0-9]{2})-([0-9]{2})$\n\nExercise 4:\n"
            }
        ]
    },
    {
        "expression": "[\\+-]?(([0-9]*\\.[0-9]+|[0-9]+\\.[0-9]*)([Ee][\\+-]?[0-9]+)?[Ff]?|[0-9]+[Ff])",
        "raw_prompt": "match a float number with Exponent sign and f sign",
        "refined_prompt": "Match a float number with the exponent sign and f sign\nMatch examples:\n- \"2.0\"\n- \"0.3\"\n- \"-.4\"\nNon-match examples:\n- \"2\"\n- \"234\"",
        "matches": [
            "2.0",
            "0.3",
            "-.4",
            "3.f",
            "2.4E-2f",
            "0.4E4f",
            "+68434376123571142467671333051141441412549162726665641457598935856888338337434820138985484.664307172223275614010247617296990420438085998112386677234329037864208E+0662457405511922641715466678507712653",
            "+6176362542611252884025597684113289.8105089225831585683374870914605219366760001597567148798178476981283717742061565595146894E+694770675280515632438832830333321081149414075370607346851616310216292621614669458408723624364",
            "-2398391484596794397762854085052915343645012590.339019130297736924518857445618383172895615069F",
            "+90231760797109805979886764272453352040730501449040733319757748212598959228484795.829264756113990",
            "423882003293925017189914016862227084248082211151429215469802112539736543237828143699.74467043139633892985391897055925812735994337546941364549077703709",
            "+1923509943268612511356446160581734383473679536746387878086302297790286613301f",
            "-610004F"
        ],
        "non_matches": [
            "2",
            "234",
            ".f",
            "es.sss",
            "f",
            "E",
            "x",
            "x10",
            "exponent",
            "to the tenth",
            "323",
            "5432"
        ],
        "id": 3910,
        "output": [
            {
                "text": " `[-+]?[0-9]*\\.?[0-9]+`\n\n2. Given the following string, match a number which ends with a decimal and a dot:\n`\"3.45\"`\n\nHint: You will need to import re\n\nSolution:\n"
            },
            {
                "text": " [^0-9.]+.\n\n3) Write a RegEx that matches a string that is made up of both uppercase and lowercase letters, numbers, and hyphens.\nAnswer: [A-Za-z0-9][A-Za-z0-9\\-]"
            },
            {
                "text": " [0-9]?[0-9]?[0-9]|[0-9][0-9][0-9]|[0-9][0-9][0-9][0-9][0-9]|[0-9][0-9][0"
            },
            {
                "text": "\n- Match a float number with the exponent sign and f sign. Match examples: \\d\\.\\d\\d\\d\n- Match a float number with the exponent sign and f sign\n- Match examples: -\\d\\.\\d\\d\\d\nNon-match examples: -2, -"
            },
            {
                "text": " ^[-+]?[0-9]*\\.?[0-9]*[eE][-+]?[0-9]+$\n\nExercise 2: Given two strings, one being a whole number and the other a fraction, combine them into a single string, correctly displaying an error"
            },
            {
                "text": "\n- ^-?\\d*(\\.\\d+)?$\n- ^-?[0-9]*(\\.\\d+)$\n\nI hope it's clear for you now. Let me know if you have any questions\n\nEmail 2:\n\nSubject: Explaining the topic"
            },
            {
                "text": " ^([-+]?(\\.0+)?\\d*[eE][-+]?\\d+)$\n\n3. Write a python function that takes in a string as argument and returns 1 if the string is a decimal number, 0 otherwise.\n\nAnswer:\ndef is_decimal("
            },
            {
                "text": " -?\\d+(?:\\.\\d+)?\n\nExercise 5: Match a non-match\nMatch the following:\n- '123'\n- 'abc123'\n- '(123)'\n- '(abc)123'\n- '123'\n- '2'\nAnswer"
            },
            {
                "text": " ^\\d+\\.?\\d*$\n\n### Exercise 5\n\nGiven an array of student names, names=[(\"John\", \"Doe\", 19), (\"Jane\", \"Smith\", 23), (\"John\", \"Honda\", 25)], generate a RegEx to match student names that have more"
            },
            {
                "text": " ^([-+])([0-9]+(\\.[0-9]+)?)(e[+-]?[0-9]+)?$\n\n### 5. Exercises\n\nCreate a Python Regex that matches a string that starts with \"http://\" and ends with \".com\"."
            }
        ]
    },
    {
        "expression": "(<<=|>>=|&&=|(\\|\\|=)|<<|>>(\\+=)|-=|(\\*=)|(\\/=)|%=|&=|(\\^=)|(\\|=)|<=|>=|==|!=|&&|(\\|\\|)|(\\+\\+)|--|>|<|\\^|&|(\\|)|\\*|\\/|%|\\+|-|~|=)",
        "raw_prompt": "matches almost all programming language operator",
        "refined_prompt": "matches almost all programming language operators\nMatch examples:\n- \"++\"\n- \"<=\"\n- \">>=\"\nNon-match examples:\n- \"identifier\"\n- \"2000\"",
        "matches": [
            "++",
            "<=",
            ">>=",
            "^",
            "*=",
            "|",
            ">>=",
            "<",
            "&",
            "|=",
            "+",
            "||",
            "--"
        ],
        "non_matches": [
            "identifier",
            "2000",
            "0xFFF",
            "32eedw",
            "3refds",
            "3rfeds",
            "54t6yhtgre",
            "frgter",
            "rt5y6t",
            "43tefd",
            "e4fqt5g",
            "egde"
        ],
        "id": 3912,
        "output": [
            {
                "text": " ^[0-9]{4}[-_/]\\d{3}[-_/]\\d{2}[-_/]\\d{1}$\n\nExercise 3:\nUse the RegEx \"^[a-zA-Z0-9_]{6}$\" to write a"
            },
            {
                "text": "\n\nimport re\n\ntext = \"\"\"\nThere are two types of operators : '+' and '-'. '+' is a unary operator.\n\u201c-\u201d: is not a unary operator. '-' is a binary operator.\n\nThere are two types of operators : '++' and '--'. '++'"
            },
            {
                "text": " [a-zA-Z0-9_.-]+ (The \".\" indicates any character including the underscore), and [0-9] after the \".\" indicates the digits.\n\nExercise 4: \nGenerate a list comprehension to get all the even numbers between 1 and 20 using RegEx\n\nimport re\neven_numbers"
            },
            {
                "text": " \"(~identifier|<=identifier){3,}$\"\n\nExercise 4: Use of \\b to define a word boundary\nExercise: \nWrite the regular expression for the following word:\n\"python\"\nAnswer: \\b(python)\\b\n\nExercise 5: Using the replace function to replace a string\n"
            },
            {
                "text": " \"^[a-zA-Z0-9_\\-\\.]+$\"\n\nExercise 3: Write a function that takes in a string and a regular expression pattern and returns a list of all substrings of the string that match the regular expression.\n\nExample:\ndef find_matches(string, pattern):\n    mat"
            },
            {
                "text": " [A-Za-z0-9_]+\n\nExercise 2:\nCreate a Python program that uses RegEx to count the number of times a specified word appears in a sentence.\nAnswer:\nimport re\n\nsentence = \"Python is a great programming language for beginners.\"\nword = \"programming\"\ncount = len"
            },
            {
                "text": " \"^(identifier)\\s*[\\>=\\<]\\s*(\\d+)\\s*$\"\n\n\n\nTitle: Exploring the Marvels of Science, Technology, and Innovation in Daily Life\n\nIntroduction:\nImagine a world without technology and innovation. It would be like living in a time when there were no cars"
            },
            {
                "text": " [a-zA-Z_][a-zA-Z0-9_]*\\s*\n\n4. Write a Python function that takes a string and returns a new string with all the vowels removed. \ndef remove_vowels(string):\n    vowels = 'aeiouAEIOU'"
            },
            {
                "text": "\n- r\"(\\d{1,3}):(\\d{1,2}):(\\d{1,2})(\\.|\\/|\\?|\\,|\\:|\\;|\\|)\"\nMy solution didn't work well:\nimport re\ndef match(line):\n    \n    # match examples\n    "
            },
            {
                "text": " \"^[a-zA-Z0-9_]+(\\.|\\-)?(\\d+)$\"\n\nThe third exercise on the list is to create a regular expression that matches any string of characters that is divisible by 3. \n\nI tried to come up with a regular expression that matches any string that is divisible by 3"
            }
        ]
    },
    {
        "expression": "^(?:[a-zA-Z]\\.?){1,4}$",
        "raw_prompt": "This expression will allow someone to place 1-4 Lower case or Upper case letters with optional periods after each letter for a total of up to 8 possible characters.",
        "refined_prompt": "Matches strings with 1-4 Lower case or Upper case letters with optional periods after each letter for a total of up to 8 possible characters.\nMatch examples:\n- \"J.W.R.\"\n- \"JwR\"\n- \"j.r.\"\nNon-match examples:\n- \"j..r.\"\n- \"jwers\"",
        "matches": [
            "J.W.R.",
            "JwR",
            "j.r.",
            "jwre",
            "JWWR",
            "J.er.e",
            "u.kq.R.",
            "uQ.x.",
            "F.dNx.",
            "u.EP",
            "dz.Y.",
            "mx",
            "Aw.D."
        ],
        "non_matches": [
            "j..r.",
            "jwers",
            "jw2",
            ".j.w.r",
            "ew87yuhbe+efuihjdsk",
            ".",
            ".ew32r4fr",
            "3eds.reew",
            "wsfeew.efw",
            "ewf.ewfw",
            "ewfgtrf.efqw32r",
            "es.sss"
        ],
        "id": 3915,
        "output": [
            {
                "text": " [a-z][a-z][A-Z][a-z]*[a-z][a-z]*[A-Z][a-z]*["
            },
            {
                "text": " ([A-Z][a-z]?[0-9]|[0-9][a-z][A-Z]|[A-Z][a-z0"
            },
            {
                "text": ".*J.*W.*R.*\n\nExercise 4:\nCreate a pattern that allows for any number of spaces between the words.\nAnswer:.*\n\nExercise 5"
            },
            {
                "text": " \n(?i)(?=.*[a-z])(?=.*\\d)(?=.*\\.)[a-z\\d\\.]{1,5}"
            },
            {
                "text": " [a-z][a-z0-9]([a-z0-9]{1})[a-z0-9]?\n\nExercise 3: Gener"
            },
            {
                "text": " [0-9.]\n\nExercise 5: \nCreate a function that takes in a sentence and returns the longest word in the sentence. If more than one word is the same length"
            },
            {
                "text": " ^(?=.*[A-Z][a-z])(?=.*[A-Z][a-z][A-Z])[A-Za-z]"
            },
            {
                "text": " j\\w*(\\.\\w*)?\n\n5. Write a regular expression that matches email addresses of the form (firstname.lastname@domain.com).\nGenerate"
            },
            {
                "text": " [a-zA-Z][a-zA-Z0-9]*[a-zA-Z0-9][a-zA-Z0-9"
            },
            {
                "text": " ^(?=\\S*(?:[a-z])(?:\\.\\S*)?)\\S*(?=\\S*(?:[A-Z])("
            }
        ]
    },
    {
        "expression": "^([\\da-fA-f]{2}[:-]){5}[\\da-fA-f]{2}$",
        "raw_prompt": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters. Needs extended grep.",
        "refined_prompt": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-f0\"",
        "matches": [
            "98-CE-d0-a2-0a-68",
            "98:cE:d0:a2:0a:68",
            "BO:cX-32:d0-RS:C]",
            "Oe:Qe:P2:IN:M5:VJ",
            "LG:BU-U[:eN-PM-dC",
            "\\2:RA:LI-cC-CU:CK",
            "MH:3e-\\1-c2-W[:A0",
            "6[:9J-SB-[3-bC:FP",
            "dC-R7-Ma:e2-QR-d^",
            "]1:1K-f2-QR:[Q-I9",
            "8R-4S-Gb:Ja-6f-TT",
            "4L-Mc:]^:2`:OA-6O",
            "f`:DA:UZ-Y2-WL-AO"
        ],
        "non_matches": [
            "98-cE-d0-a2-0a",
            "98-cE-d0-a2-0a-68-f0",
            "g3refr",
            "4t5rgwfe",
            "345623ewfrgt",
            "tyt54g",
            "5tgrfewrt",
            "2345yhgfds",
            "43r3t4wes",
            "434-g5regdfv-",
            "----",
            "refdvc-"
        ],
        "id": 3934,
        "output": [
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-1"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-\""
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-a"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-1"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-:"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-123"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-01"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-0"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-1"
            },
            {
                "text": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters.\nMatch examples:\n- \"98-CE-d0-a2-0a-68\"\n- \"98:cE:d0:a2:0a:68\"\n- \"BO:cX-32:d0-RS:C]\"\nNon-match examples:\n- \"98-cE-d0-a2-0a\"\n- \"98-cE-d0-a2-0a-68-2"
            }
        ]
    },
    {
        "expression": "^9792\\d{12}$",
        "raw_prompt": "Matches troy credit cards (length 16, prefix 9792)",
        "refined_prompt": "Matches troy credit cards (length 16, prefix 9792)\nMatch examples:\n- \"9792131111111111\"\n- \"9792461111111111\"\n- \"9792111111111111\"\nNon-match examples:\n- \"9792 1311 1111 1111\"\n- \"1234561234561234\"",
        "matches": [
            "9792131111111111",
            "9792461111111111",
            "9792111111111111",
            "9792899105732571",
            "9792236212517562",
            "9792855956101834",
            "9792188559945304",
            "9792740088676935",
            "9792120081486541",
            "9792240253366588",
            "9792512089752934",
            "9792103861993354",
            "9792892078668297"
        ],
        "non_matches": [
            "9792 1311 1111 1111",
            "1234561234561234",
            "4313803785737",
            "7286410428685",
            "8515778623679",
            "4829103934036",
            "2318501150827",
            "2723616635399",
            "1746343796917",
            "1352511310397",
            "7113822627183",
            "2754694421115"
        ],
        "id": 3936,
        "output": [
            {
                "text": "\n\\d{9}[\\d]{15}\\d{2}[^\\d]\\d{15}\n\nExercise 2:\nCreate a list of strings"
            },
            {
                "text": " (?<![0-9])(?<![a-z])\\d{8}\n\nExercise 3: Write a Python script that generates a list of all"
            },
            {
                "text": " /^\\d{9}(\\d{4})?$/\n\n3. Search for all occurrences of the word \"Python\" within a given text.\nAnswer: \"Python"
            },
            {
                "text": " ^(?=[\\d\\d]{16}$)(?!.*[0-9])(?=.*[A-Z])(?=.*[a-z])"
            },
            {
                "text": " \\b[0-9]3[0-9]2[0-9]\\b\n\nExercise 4:\nWrite a Python code to generate a list of all valid"
            },
            {
                "text": " [0-9]{16}\n\n\n\nTitle: Exploring the Marvels of Physics: The Periodic Table, Periodic Trends, and the Periodic Families\n\nIntroduction"
            },
            {
                "text": " \\b19\\d*11\\d*1\\d*\\b\n\n3. Create a list of phone numbers that are in the format of (123)456-7890"
            },
            {
                "text": " \"9792[0-9]{5}[1-9]\"\n\nExercise 2:\nCreate a regex that matches credit card numbers with the American Express format (length 16"
            },
            {
                "text": " \n\n[0-9]{3}[0-9]{3}[0-9]{3}[0-9]{4}\n\n\nExercise"
            },
            {
                "text": " \"^(?:\\d)\\d{4}\\s\\d{2}\\s\\d{2}\\s\\d{2}\\s\\d{4}$\"\n\n"
            }
        ]
    },
    {
        "expression": "^(?:Yes\\b|No\\b|yes\\b|YES\\b|YEs\\b|yeS\\b|yEs\\b|NO\\b|nO\\b|no\\b)",
        "raw_prompt": "This regex will match below values only\nYES\nyes\nYes\nYEs\nyEs\nyeS\nNO\nno\nNo\nnO",
        "refined_prompt": "This regex will match below values only\r\nYES\r\nyes\r\nYes\r\nYEs\r\nyEs\r\nyeS\r\nNO\r\nno\r\nNo\r\nnO\nMatch examples:\n- \"YES\"\n- \"nO\"\n- \"No\"\nNon-match examples:\n- \"Except YES yes Yes YEs yEs yeS NO no No nO\"\n- \"3freds\"",
        "matches": [
            "YES",
            "nO",
            "No",
            "no",
            "NO",
            "yeS",
            "yEs",
            "YEs",
            "Yes",
            "yes"
        ],
        "non_matches": [
            "Except YES yes Yes YEs yEs yeS NO no No nO",
            "3freds",
            "2345rfed",
            "maybe",
            "possiblly",
            "idk",
            "possibility",
            "who knows",
            "rjf3",
            "324ref",
            "jdsf",
            "wefjwe"
        ],
        "id": 3951,
        "output": [
            {
                "text": " 3fred|s\n\nA:\n\nWhy not just use the regex string.format?\nimport"
            },
            {
                "text": "\n[^a-zA-Z0-9-_ \\/\\.]\n\nA:"
            },
            {
                "text": "\n^(?=(?:(?:YES|YES|YEs|yEs|yeS|Ye"
            },
            {
                "text": " \\w+\n\nA:\n\nI think you mean \\bYES\\b in there?\n"
            },
            {
                "text": " (3).\\w*\n\nA:\n\n\"YES\", \"YES\", \"YES\", \""
            },
            {
                "text": "\n[a-zA-Z0-9]*(YES|yes|YESE|YES"
            },
            {
                "text": " [^e]yn|YES[^e]y[^e]|YES[^e]"
            },
            {
                "text": " (.*?[1-9])(?:[1-9]|[0-9])\n"
            },
            {
                "text": "\n^[A-Z][a-z]+$|[A-Z][a-z]+"
            },
            {
                "text": " (^[\\w-]+$)\n\nA:\n\nYou could use a word boundry"
            }
        ]
    },
    {
        "expression": "^01[0125]{1}[0-9]{8}",
        "raw_prompt": "- first 2 digits are 01\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\n- third 8 digits are between 0 and 9",
        "refined_prompt": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"",
        "matches": [
            "01022685544",
            "01229671351",
            "01208664788",
            "01522685544",
            "01102453819",
            "01207811393",
            "01591880142",
            "01220787889",
            "01073085438",
            "01073085438",
            "01008828664",
            "01204198011",
            "01589865476"
        ],
        "non_matches": [
            "+0201622685544",
            "01322685544",
            "01422685544",
            "01622685544",
            "01722685544",
            "01822685544",
            "01922685544",
            "234354657",
            "6245",
            "546754",
            "345245636u37",
            "87654"
        ],
        "id": 3981,
        "output": [
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description."
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description."
            },
            {
                "text": "Matches strings of numbers with the following constraints\r\n- first 2 digits are 01\r\n- second 1 digit is 0 for (Vodafone) or 1 for (Etisalat) or 2 for (orange) or 5 for (We)\r\n- third 8 digits are between 0 and 9\nMatch examples:\n- \"01022685544\"\n- \"01229671351\"\n- \"01208664788\"\nNon-match examples:\n- \"+0201622685544\"\n- \"01322685544\"Generate a RegEx for this description\r"
            }
        ]
    },
    {
        "expression": "^(\\d|\\d{1,9}|1\\d{1,9}|20\\d{8}|21[0-3]\\d{7}|214[0-6]\\d{6}|2147[0-3]\\d{5}|21474[0-7]\\d{4}|214748[0-2]\\d{3}|2147483[0-5]\\d{2}|21474836[0-3][0-9]|214748364[0-7])$",
        "raw_prompt": "regular expression for positive integer",
        "refined_prompt": "Matches a positive integer with max length 10\nMatch examples:\n- \"2147483647\"\n- \"0\"\n- \"2147483639\"\nNon-match examples:\n- \"2147483648\"\n- \"0.0\"",
        "matches": [
            "2147483647",
            "0",
            "2147483639",
            "2146178491",
            "2043838193",
            "696",
            "2057398233",
            "100",
            "2147290029",
            "2120758935",
            "2113395525",
            "43",
            "2147483610"
        ],
        "non_matches": [
            "2147483648",
            "0.0",
            "-54645",
            "-987654",
            "+9876",
            "239.324",
            "#3",
            "$45",
            "54%",
            "-234.234",
            "+0.0",
            ".98765"
        ],
        "id": 3983,
        "output": [
            {
                "text": " ^\\d{1,10}$ \n- \"2147483648+\"Generate a RegEx for this description.\nAnswer: +\\d{1,10}$\n\n2. Find all matches of the following RegEx:\n- \""
            },
            {
                "text": " Matches a positive integer with max length 10\n\nExercise 2:\nMatch an alphanumeric string with min length 5.\nMatch examples:\n- \"01234567\"\n- \"abcdefg\"\n- \"ABC123456\"\nNon-match"
            },
            {
                "text": " \\b[0-9]{1,100}\\b\n\nExercise 2:\nMatch a negative integer with max length 10\nMatch examples:\n- \"-3147483647\"\n- \"-0\"\n- \"-2147483648\"\nNon"
            },
            {
                "text": "\n(^(?![^0-9eEe-z_])([0-9eEe-z_](?![^0-9eEe-z_])*))+\n\nExercise 4:\nRewrite a positive integer"
            },
            {
                "text": "\n^[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-"
            },
            {
                "text": " \n(^[0-9]{1,10}$)|(^[0-9]+(\\.[0-9]{1})?$)\n\nExercise 2:\nMatch each of the following character sets with the corresponding character it would match"
            },
            {
                "text": " ^[1-9]\\d{0,9}$\n3. Write a RegEx to check if a string contains only lowercase letters with at least 2 characters.\nAnswer: ^[a-z]{2,}\\z\n4. Write a Reg"
            },
            {
                "text": " ^[0-9]+$\n\n5. Write a RegEx to match all decimal numbers between 0 and 99.\n\n```python\n# Exercise 5\nimport re\n\npattern = r\"^[0-9]{1,2}([0-"
            },
            {
                "text": " \\b[1-9]\\d*\\b should work.\n\n4. Write a RegEx that will find all the email addresses from a given text file.\n\nHint: an email address is a set of characters that look like this: [a-"
            },
            {
                "text": " \"^[1-9][0-9]?[0-9][0-9][0-9][0-9][0-9]$\"\n\nExercise 2: Write a Python function that takes a string as input, checks if it matches a"
            }
        ]
    },
    {
        "expression": "^(0)((3[0-6][0-9]))(\\d{7})$",
        "raw_prompt": "All phone numbers starting with 03*********. total 11 digit numbers.",
        "refined_prompt": "Matches phone numbers starting with 03*********, for a total of 11 digits.\nMatch examples:\n- \"03355011998\"\n- \"03285760882\"\n- \"03331068752\"\nNon-match examples:\n- \"+923355011998\"\n- \"-43r3442\"",
        "matches": [
            "03355011998",
            "03285760882",
            "03331068752",
            "03304808078",
            "03036593646",
            "03504306683",
            "03262354454",
            "03621102307",
            "03677026308",
            "03219165500",
            "03505625978",
            "03571907284",
            "03699412297"
        ],
        "non_matches": [
            "+923355011998",
            "-43r3442",
            "3258093573409753945942",
            "###",
            "03'",
            "(03)3829472",
            "47348",
            "324567887654324567",
            "42",
            "$45",
            "56%",
            "234"
        ],
        "id": 4010,
        "output": [
            {
                "text": "\n\nThe RegEx I should use is: r'^3[0-9]*(?:\\.(?))?$'.\n\nTutor: Excellent job! What's the next question?\n\nStudent"
            },
            {
                "text": " \\d{3}(?:\\d{3})...\n\nExercise 3:\nMatch a phone number that starts with +734456789*, for a total of 12 digits.\nAnswer: \\+"
            },
            {
                "text": " [0-9]{3}[0-9]{2}[0-9]{2}[0-9]{4}-\\d{4}-\\d{4}\n\n"
            },
            {
                "text": " r\"\\b\\S*(?:\\s+\\S+)*\\b\"\n7. Write a regular expression that matches a string that contains only uppercase letters or digits.\nAnswer: [A-"
            },
            {
                "text": " (3|4|35|3|2)5(1|5|8|9)\n\nExercise 4: The following email address contains a phone number and a domain name separated by whitespace. Write a"
            },
            {
                "text": " ^\\d{3}(?:\\d{3})?(?:\\d{3})?(?:\\d{4})$\n\nExercise 4: Create a regular expression that validates an email address"
            },
            {
                "text": " ^(03[0-3]|04[0-2])\\d{11}$\n\nExercise 2: Create a regular expression with the following pattern: \n- Match phone numbers starting with 10,"
            },
            {
                "text": " ^[0-9][0-9]{2}, [0-9][0-9]{2}[0-9]$\n\nExercise 4: Phone Number Formatting\nSuppose you have"
            },
            {
                "text": "  \\d{3}-\\d{4}-\\d{2}  \n\nExercise 2:\nCreate a regular expression that matches email addresses ending with \".com\".\nAnswer:  [a-"
            },
            {
                "text": " ^\\+?\\d{3}(\\d{3})\\d{3}(?:\\-\\d{3})?$\n\n4. Identify the type of punctuation in the following sentence:"
            }
        ]
    },
    {
        "expression": "^[0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])($|(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9])$)",
        "raw_prompt": "This expression validate the YYYYMMDDHHMMSS datetime format but also only the date YYYYMMDD. It does not control month length or leap years. Made for a SAP retail sales tickets interface.\nFor XML pattern facet this would do:\n([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])(([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]))|([0-9]{4}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1]))",
        "refined_prompt": "This expression matches the YYYYMMDDHHMMSS date time format but also only the date YYYYMMDD. It does not control month length or leap years.\nMatch examples:\n- \"20200707181818\"\n- \"20200707\"\n- \"20200231010000\"\nNon-match examples:\n- \"20201232\"\n- \"20201301\"",
        "matches": [
            "20200707181818",
            "20200707",
            "20200231010000",
            "20200931",
            "00011231235959",
            "00000101",
            "46481230070908",
            "05451230215834",
            "25590127",
            "81181204205631",
            "60501214230518",
            "79531131",
            "19650231"
        ],
        "non_matches": [
            "20201232",
            "20201301",
            "20200028",
            "20200500",
            "20200707235978",
            "20201231128533",
            "20200327453030",
            "3252.54321.",
            "32532332",
            "34557564342",
            "423899",
            "435785"
        ],
        "id": 4029,
        "output": [
            {
                "text": "\n^(20??[1-9])[0-9]{2}(?:-[0-9]{2}"
            },
            {
                "text": " (\\d{4})-(\\d{2}-\\d{2}-\\d{2}T\\d{2"
            },
            {
                "text": "\n(?<![\\d])(?<![\\w])(?<![\\s])\\d{4"
            },
            {
                "text": " ^[0-9]{4}-[0-9]{2}-[0-9]{2}$\n\nEx"
            },
            {
                "text": " \n^\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d$\n\nEx"
            },
            {
                "text": " \n^[^0-9]?\\d{4}-\\d{2}-\\d{2}T\\"
            },
            {
                "text": " (?<Y>\\d{4})(-(?<M>0[1-9])|-(?<M>1"
            },
            {
                "text": " YYYYMMDDHHMMSS\n\n2. Write a RegEx for the following pattern: \n- Phone Number - 555-"
            },
            {
                "text": " \n\nimport re\n\nprint re.search(\"^20201[0-9]{5}\\s[0-9]"
            },
            {
                "text": "\n^[0-9]{4}[0-9]{2}[0-9]{2}[0-"
            }
        ]
    },
    {
        "expression": "(^[3|4|5|6|7|8|9]\\d{2}(\\ |-){0,1}\\d{4}$)|(^[4|5|7|8]\\d{3}(\\ |-){0,1}\\d{4}$)|(^8\\d{2,3}(\\ |-){0,1}\\d{3,4}(\\ |-){0,1}\\d{3,4}$)",
        "raw_prompt": "Supports 7 digits (starting with 3,4,5,6,7,8,9) 8 digits (starting with 4,5,7,8), machine-to-machine (M2M) numbers 9-12 digits (starting with 8).",
        "refined_prompt": "Matches 7 digits (starting with 3,4,5,6,7,8,9), 8 digits (starting with 4,5,7,8), machine-to-machine (M2M) numbers 9-12 digits (starting with 8).\nMatch examples:\n- \"300 3000\"\n- \"300-3000\"\n- \"3003000\"\nNon-match examples:\n- \"3000 3000\"\n- \"9000 9000 9000\"",
        "matches": [
            "300 3000",
            "300-3000",
            "3003000",
            "762 4820",
            "81571127088",
            "8208 3987",
            "837-1862",
            "492-1995",
            "490 3417",
            "8579871",
            "507 3509",
            "8548059787",
            "8429437"
        ],
        "non_matches": [
            "3000 3000",
            "9000 9000 9000",
            "werf",
            "234rtdsfqwe",
            "#3",
            "32456321",
            "876",
            "3521351`2",
            "32534687",
            "231",
            "$45",
            "54%"
        ],
        "id": 4041,
        "output": [
            {
                "text": " \n\n#Generate a RegEx for this description:\nMatching characters:"
            },
            {
                "text": "\n(\\d{3}-\\d{3})\\s*(\\d{"
            },
            {
                "text": " \n^(?!\\\\s*-\\\\s*-\\\\s*-\\\\"
            },
            {
                "text": " (\\d{1,2}\\s*-\\s*\\d{1"
            },
            {
                "text": "\n^(3\\d{0,3})(6\\d{0,"
            },
            {
                "text": " ^[0-9]{3,6}-[0-9]{5"
            },
            {
                "text": " 3 digits, 8 digits, M2M numbers\n\nExercise 2:\nImagine"
            },
            {
                "text": " \"^(0-9)|(0-9)(0-9)$\""
            },
            {
                "text": " [^0-9]{3,4}\\-(?:\\d{3}"
            },
            {
                "text": " [3-9]\\d{3}[-3-9]\\d"
            }
        ]
    },
    {
        "expression": "([s]){10,}",
        "raw_prompt": "Matches the hissing noise of a snake. Link to my GitHub: https://github.com/StoddardSpencer96",
        "refined_prompt": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrsfefsv54543534544 FKR$>%>??W?EK#$Krkdk3oror\"\n- \"qwertyghbn\"",
        "matches": [
            "ssssssssss wwwwwwwwwwwsssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssss",
            "ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss",
            "sssssssssssssssssssssssssssssssss"
        ],
        "non_matches": [
            "effsgrgrsfefsv54543534544 FKR$>%>??W?EK#$Krkdk3oror",
            "qwertyghbn",
            "kjiuyt65re4rft",
            "ytfyuykghiu6757rty",
            "njihgyt67",
            "dftyguio",
            "s",
            "huytr54er5ty78u9",
            "hiugou",
            "wuhqipaxz",
            "ewuhpiru32p9swd",
            "rhfpier"
        ],
        "id": 4043,
        "output": [
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            },
            {
                "text": "Matches the hissing noise of a snake (string of any number of s more than 1).\nMatch examples:\n- \"ssssssssss wwwwwwwwwwwsssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\"\n- \"ssssssssssssssssssssssssssssssssssssssssssssssssss\"\nNon-match examples:\n- \"effsgrgrgr"
            }
        ]
    },
    {
        "expression": "([ing]){3}$",
        "raw_prompt": "Matching any word that ends with \"ing\"\nLink to my GitHub: https://github.com/StoddardSpencer96",
        "refined_prompt": "Matches the \"ing\" in any word that ends with \"ing\"\nMatch examples:\n- \"Reading Playing Comforting Crying\"\n- \"ing\"\nNon-match examples:\n- \"Readings Listenings Playful Comfort\"\n- \"hi\"",
        "matches": [
            "Reading Playing Comforting Crying",
            "ing"
        ],
        "non_matches": [
            "Readings Listenings Playful Comfort",
            "hi",
            "hello",
            "this",
            "Played",
            "Ran",
            "Run",
            "Moved",
            "Test",
            "Listen",
            "threw",
            "cooler"
        ],
        "id": 4044,
        "output": [
            {
                "text": " Match \"ing\" when it appears at the end of a word.\n\nIn conclusion, the study of language arts and the use of tools such as RegEx can greatly enhance reading comprehension skills. Through the use of positive and negative examples, we have demonstrated how RegEx can be a valuable"
            },
            {
                "text": " (\\w+ing\\w+)\n\nExercise 2:\nCreate a RegEx pattern for this description:\nThe cat is sleeping.\nMatch examples:\n- \"Cat Sleeping Dog Sleeping\"\n- \"cat\"\nNon-match examples:\n- \"Dog Sleeping Cat"
            },
            {
                "text": " (.+)(ing)\\b(?=(\\w+th\\s\\w+e\\s\\w+ing))\n\nExercise 3:\nWhat is the difference between a word and a phrase?\nAnswer: A word is a single unit of meaning, while a phrase"
            },
            {
                "text": " \n\nExercise 2: \nFill in the blank with the correct letter: \nThe word \"_____\" has two consonant blends.\nAnswer: \n\nExercise 3: \nWrite a sentence using a word with a diphthong in the last word"
            },
            {
                "text": " The correct pattern is \"hi\" followed by one or more consonants, followed by one or more vowels. However, since \"hi\" is itself a consonant, the correct pattern is \"hi\". Generate a RegEx for this description. \n\nExercise 2: Find"
            },
            {
                "text": " (Any valid RegEx) \"ing$\"\n\n\n\nDear Alien,\n\nI hope this letter finds you well in your exploration of our world. Today, I would like to talk to you about the fascinating topic of Arts, specifically focusing on the elements and principles of design."
            },
            {
                "text": " \nimport re\n\nsentence = \"I am feeling happy today. I am listening to music while I am reading a book.\"\npattern = re.compile(\"[a-zA-Z0-9]+ing\")\n\nmatches = pattern.findall("
            },
            {
                "text": " [Insert the RegEx generated by the student]\n\nExercise 3:\nIdentify the missing letter in the following words.\n- __\n- __\nNon-match examples:\n- \"__\"\n- \"__\"\nAnswer: [Insert the missing letters]\n"
            },
            {
                "text": " The regular expression is /^[a-z]+ing$/.\n\nExercise 2: Using a List Comprehension, extract all the \"ing\" words in a sentence.\nExercise: Find all the \"ing\" words in the following sentence: \"We'll go to"
            },
            {
                "text": " [the word that ends with \"ing\"]\n\nExercise 2: Identifying Non-matching Words\n- Find words that don't match the RegEx pattern \"cat\". \nAnswer: [the word that does not match the pattern]\n\nExercise 3: Creating a"
            }
        ]
    },
    {
        "expression": "((=)[A-F0-9]{2}){3}",
        "raw_prompt": "Using this Regex for finding spam in RAW email\nthis is Case sensitive\nHEX only CAPITAL A-F and numbers 0-9",
        "refined_prompt": "Matches 2 character HEX values between =\nMatch examples:\n- \"=EF=BB=BF\"\n- \"=E2=9C=80\"\n- \"=E2=9D=A4\"\nNon-match examples:\n- \"e2 9d a4\"\n- \"ABCXYZ\"",
        "matches": [
            "=EF=BB=BF",
            "=E2=9C=80",
            "=E2=9D=A4",
            "=38=B9=30",
            "=23=5E=00",
            "=47=7B=35",
            "=5B=12=88",
            "=32=C1=B5",
            "=59=B4=97",
            "=65=FF=02",
            "=C6=8D=79",
            "=D8=E4=96",
            "=B6=B4=DF"
        ],
        "non_matches": [
            "e2 9d a4",
            "ABCXYZ",
            "f0=9f=aa=81",
            "324r",
            "#DHWGDDWJNJ",
            "=",
            "equal",
            "21343re",
            "#HHDI3",
            "====",
            "DHDIE",
            "DDUEY72"
        ],
        "id": 4051,
        "output": [
            {
                "text": "\n\nimport re\n\ndef print_hex_list(hex_str):\n    hex_list = re.findall(r\"\\=?[0-9a-fA-F]"
            },
            {
                "text": "\n^[A-Fa-f0-9][A-Fa-f0-9]$|[^A-Fa-f0-9][A-Fa-f0-9A-"
            },
            {
                "text": " (Any RegEx that matches one of the non-match examples)\nI have a list of input strings: \"=EF=BB=BF\", \"=E2=9C=80\", \"=E"
            },
            {
                "text": "\nimport re\n\nstring_to_be_matched = \"=EF=BB=BF\"\npattern = \"^=E2=([0-9A-Fa-f]+)$\"\n"
            },
            {
                "text": "\n    [0-9A-Fa-f]=[0-9A-Fa-f]=[0-9A-Fa-f]\n\"\"\"\n\n# import\nimport re\n\n#"
            },
            {
                "text": " \nThis RegEx should match any number(s) between two equal characters in the string, where the character in the first position and the character in the second position are equal.\n\n3) Create a list"
            },
            {
                "text": "\n(?=^.+[A-Z])(?=.*[0-9])^[0-9]{5}[A-Z]{1}$\n\nExercise 2"
            },
            {
                "text": "\n[0-9A-Fa-f]{1,4}[0-9A-Fa-f]{1,4}[0-9A-Fa-f]{1,"
            },
            {
                "text": " e2 (\\w) (\\w)\n\n- \"=2=3=4=A\"Generate a RegEx for this description. \nAnswer: \\w (\\w) (\\"
            },
            {
                "text": "\n- [0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}\n\n3. Write a Regex to"
            }
        ]
    },
    {
        "expression": "\\b[0-9]{2}([0][1-9]{1}|[1][0-2]{1})([0][1-9]{1}|[1][0-9]{1}|[2][0-9]{1}|[3][0-1]{1})\\d{5}",
        "raw_prompt": "The PESEL number is an identification number given to every Polish citizen when they are born and registered in Poland.",
        "refined_prompt": "Matches the PESEL number which is an identification number given to every Polish citizen when they are born and registered in Poland.\nMatch examples:\n- \"11083197485\"\n- \"36110878229\"\n- \"00063172200\"\nNon-match examples:\n- \"1F083297485\"\n- \"36204578229\"",
        "matches": [
            "11083197485",
            "36110878229",
            "00063172200",
            "12110383138",
            "71111127030",
            "35103085264",
            "85061017201",
            "39012627489",
            "32021861783",
            "67080861679",
            "59031023643",
            "39063110747",
            "67101809495"
        ],
        "non_matches": [
            "1F083297485",
            "36204578229",
            "AA06317220B",
            "12203383138",
            "23131",
            "2343dsd",
            "GDU&*",
            "PESEL",
            "hefeiwefh342",
            "2121",
            "#3",
            "3e2hr3f"
        ],
        "id": 4067,
        "output": [
            {
                "text": " \"^[A-Z]{3}-?[0-9]{3}$|^[0-9]{4}-[0-9]"
            },
            {
                "text": " Match examples: \"11083197485\" \"36110878229\" and Non-match examples: \"1F083297485\" \"36204578229\""
            },
            {
                "text": " [^0-9]\n\n5. Write a RegEx to match a social security number from a text field.\nMatch examples:\n- \"12345678\""
            },
            {
                "text": " (1F|3[0-8]([0-9]{3})[0-9]{3})\n\nExercise 2:\nMatch this description"
            },
            {
                "text": " \n\nPESEL_MATCH: [a-z][a-z0-9]{4}[a-z0-9]\nPES"
            },
            {
                "text": " (example) [PESEL]{3}[A-Z]{3}[0-9]{9}[A-Z]{3}["
            },
            {
                "text": "\n\nPESEL_RegEx = re.compile(r'^(11[0-9]{3}[0-9]{4}["
            },
            {
                "text": " ^[0-9]{10}$\n\nWhat is the best regular expression to match an ID number like this:\n\"123456789\"\n\nA"
            },
            {
                "text": " (.*)\\/(.*)\\/(.*)\\/(.*)\\/(.*)\\/(.*)\\/(.*)\\/(.*)\\/(.*)\\/"
            },
            {
                "text": " \n\\d{6}\\d{6}\\d{6}\\d{6}\\d{2}\nExplaination:\n[0-9]{6"
            }
        ]
    },
    {
        "expression": "^((0[1-9])|(1[0-2]))[\\/\\.\\-]*((2[0-9])|(3[0-9]))$",
        "raw_prompt": "valid years 2020 to 2039",
        "refined_prompt": "Matches dates with years from 2020-2039\nMatch examples:\n- \"12/20\"\n- \"12/39\"\n- \"05-25\"\nNon-match examples:\n- \"12/40\"\n- \"23/02\"",
        "matches": [
            "12/20",
            "12/39",
            "05-25",
            "11//./--/-//.--./-/.-/.....-.-/..---/-../...-/--...23",
            "11././/31",
            "12////..//-.-.-..--/---..-/--/-/..-//.---29",
            "05-..-/../--//---/...//-..-36",
            "1021",
            "11-.///-./-../.--./-//-/.......///.././/-././-../.-/--/-/----.-.//--/--//-27",
            "10---/-/.-//37",
            "12.-./.--.--/...//-.-.-//.-.//../-/.-/-//33",
            "11///./-/-/-/-.-../-.-./-.../-.//--.-.--.//..-./../-/-/-/.-/-/-/29",
            "08/../../..---.../-.//../-///../------//-///..-./-.31"
        ],
        "non_matches": [
            "12/40",
            "23/02",
            "15-25",
            "1//",
            "12/12",
            "12/43",
            "1/2030",
            "12121212",
            "$45",
            "12-12",
            "july 4 2020",
            "#3"
        ],
        "id": 4072,
        "output": [
            {
                "text": " \"^(?:0?[1-9]|1[012]|2[0-9])\\/(?:0?[1-9]|1[012])\\/(?:19|20)\\d[0-9]$\"\n\nExercise 5:\n"
            },
            {
                "text": " \\d{1,2}/\\d{2,3}\n\nExercise 2: Match expressions that start with a number.\nMatch expressions that start with a number.\nMatch expressions that start with a number.\nMatch expressions that start with a number. \nMatch expressions"
            },
            {
                "text": " \"(^| )(\\d{2}[-/.])?\\d{2}[-/.]\\d{4}$\"\n\nExercise 2: Write a Python function that takes a string, and returns `True` if the string contains only numbers and spaces, and"
            },
            {
                "text": " \n\n```python\nimport re\n\n# regex pattern for year\nregex_year = r\"^\\d{4}-\\d{2}$\"\n\n# regex pattern for month\nregex_month = r\"^\\d{1,2"
            },
            {
                "text": "\nimport re\ndesc = \"Find all dates within 2021 to 2039\"\npattern = \"(20\\d\\d)-(\\d\\d)-(\\d\\d)\"\nmatch = re.findall(pattern, desc)\nmatch\n```\n\n2. Given a list"
            },
            {
                "text": " \"^[1-2][0-9][0-9]$\"\n\n3. Write a Python program that takes a password and returns True if it contains at least one uppercase letter, one lowercase letter, and one digit, and False otherwise.\n\n```"
            },
            {
                "text": " ^((0..9)|(0-9))(\\d)\\-(0\\d)([0-9]{2}[0-9]{2}[0-9]{2}|[11][0-9])$\n\nExercise 3: \n"
            },
            {
                "text": " a few words followed by \"s and the second word. The words may be repeated twice and may have letters in between them. The words may be separated by a comma (,) or a space ( ). The two words must be separated by exactly two words and the two words can have any number of"
            },
            {
                "text": " \\d{1,2}/\\d{1,2}/\\d{4}\n\n**Exercise 2:** \n\nMatch all the following words in the given sentence using RegEx: `\"The quick brown fox jumps over the lazy dog.\"`\n\n"
            },
            {
                "text": " [A-Z]{3}[0-9]{4}\n\n4. Write a Python program that takes a list of email addresses and returns the number of valid email addresses. \nAnswer: \nimport re\n\ndef count_valid_emails(emails"
            }
        ]
    },
    {
        "expression": "^((?!.*(00000|11111|22222|33333|44444|55555|66666|77777|88888|99999))[0-9]{5,10})",
        "raw_prompt": "In example for some input number in case random digits not repeat number 5 number in 5-10 digits in pattern.",
        "refined_prompt": "Matches strings of numbers of the length of at least 5, but can not have more than 4 5's consecutively\nMatch examples:\n- \"0000110000\"\n- \"000010010\"\n- \"158114223\"\nNon-match examples:\n- \"00000\"\n- \"1122000009\"",
        "matches": [
            "0000110000",
            "000010010",
            "158114223",
            "113254",
            "081892",
            "027060",
            "1770189269",
            "408498",
            "42098",
            "01332",
            "85644",
            "019843",
            "33594"
        ],
        "non_matches": [
            "00000",
            "1122000009",
            "3242",
            "12",
            "#3",
            "$45",
            "23%",
            "12/12",
            "3323",
            "23",
            "124&&&&",
            "<32"
        ],
        "id": 4086,
        "output": [
            {
                "text": "\n(?=(?:\\d{9})*\\d{9})\n(?=(?:\\d{4})*\\d{4})\n(?=(?:0?\\d{3})*\\d{"
            },
            {
                "text": "\n[1-9][1-9][1-9][0-9][0-9][^0-9]\n\nHere are some examples that you could use to help you:\n\nExample 1:\n\n"
            },
            {
                "text": " \\b(?=(\\d{5})+)\\d{5}\\b\n\nQuestion 3: Write a Python code to find all the words that are at least 5 characters long. \nAnswer: \nimport re\n"
            },
            {
                "text": " \n^(?!(00)$)(?!(0)$)(?!(1)$)(?!(2)$)(?!(3)$)(?!(4)$)(?!(5)$)(?!("
            },
            {
                "text": " \n(\\d{5})(\\d*)(\\d{5})(\\d*)\n\nA:\n\nThis will work \n^(0{4}1{1}|1{3}0"
            },
            {
                "text": ".*[0-9]{6,}.*[0-9]\n\n3. Create a RegEx to match strings that start with the letter \"a\" or \"A\"\nAnswer: ^[Aa]"
            },
            {
                "text": " ^(?=.{5,10})[0-9]{5}$\n\nWhat are some other types of patterns that you could use to match a string of numbers? \nSome other types of patterns that you"
            },
            {
                "text": "\n^(?:05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|1(?!5)|2(?!5)|3(?!5"
            },
            {
                "text": " [0-9]{5,}\n\n7. Write a Python function that takes in a string and returns the number of consecutive letters that are the same. \nExample: \ncount_consecutive_letters(\""
            },
            {
                "text": " (?<!^[0-9])(?![0-9])[0-9]{5}(?![0-9])\n\nI tried to put it into a small function but it didn't work"
            }
        ]
    },
    {
        "expression": "(?!BG|GB|KN|NK|NT|TN|ZZ)[A-CEGHJ-PR-TW-Z][A-CEGHJ-NPR-TW-Z][0-9]{6}[A-D]",
        "raw_prompt": "UK NI number. ensured that the suffix is always a single character of A-D (as these are the only values currently supported by HMRC). Created 2021",
        "refined_prompt": "Matches UK National Insurance number. The suffix needs to be a single character of A-D (as these are the only values currently supported by HMRC).\nMatch examples:\n- \"XY123456D\"\n- \"AH587561C\"\n- \"CZ106648B\"\nNon-match examples:\n- \"XY123456E\"\n- \"23456\"",
        "matches": [
            "XY123456D",
            "AH587561C",
            "CZ106648B",
            "LJ185856D",
            "BA615520D",
            "OM968321A",
            "OG314869B",
            "BX184126A",
            "ML279103A",
            "SA876126C",
            "CT466022B",
            "KX637827A",
            "GL065214A"
        ],
        "non_matches": [
            "XY123456E",
            "23456",
            "sdfgh",
            "34rd3434f3",
            "#3",
            "number",
            "e34532",
            "dj343232f",
            "E323rj23!!!",
            "34njffW",
            "334jdfwe",
            "wjeirja"
        ],
        "id": 4107,
        "output": [
            {
                "text": "\n- [AB]\\d{6}(E|D)\n\nThis regex will match UK National Insurance numbers with a prefix of A-B and"
            },
            {
                "text": " \"^[A-Z0-9]{5}[0-9]{4}[0-9]{2}$\"\n\n"
            },
            {
                "text": " (\\d{1,3})(\\D+)\n\nExercise 3:\nCreate a RegEx to match a string that contains only the characters '"
            },
            {
                "text": " Match \"XY\" followed by a sequence of 2-9 digits, followed by a sequence of 4-9 digits, followed by a single character, followed by \""
            },
            {
                "text": " /^((?!^)\\d{3})(?!^\\d{6}$)(?!^\\d{6,9}$)(?!^"
            },
            {
                "text": " ^(0[1-9][0-9]?|1[012])(-|[0-9]{5})(?=[A-"
            },
            {
                "text": " (1) \"^[A-D]{1}[0-9]{5,6}$\"\n\nExercise 3:\nMatch"
            },
            {
                "text": " [^A-Z][0-9]+(\\.[0-9]*)?\n\nExercise 4: Match the following words to their respective suffix"
            },
            {
                "text": "\n- ^(?=.*[A-D])(?=|.$)(?=.*[A-D])[A-D]{6"
            },
            {
                "text": " No match. Any value with a non-single character suffix will not match this RegEx.\n\nExample 3:\nA team of scientists is designing a machine"
            }
        ]
    }
]